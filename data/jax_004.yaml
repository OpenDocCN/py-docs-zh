- en: ğŸ”ª JAX - The Sharp Bits ğŸ”ª
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ğŸ”ª JAX - é”‹åˆ©çš„éƒ¨åˆ† ğŸ”ª
- en: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html`](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html`](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html)
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![åœ¨ Colab ä¸­æ‰“å¼€](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)
    ![åœ¨ Kaggle ä¸­æ‰“å¼€](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)'
- en: '*levskaya@ mattjj@*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*levskaya@ mattjj@*'
- en: When walking about the countryside of Italy, the people will not hesitate to
    tell you that **JAX** has [*â€œuna anima di pura programmazione funzionaleâ€*](https://www.sscardapane.it/iaml-backup/jax-intro/).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å¤§åˆ©ä¹¡é—´æ¼«æ­¥æ—¶ï¼Œäººä»¬ä¼šæ¯«ä¸çŠ¹è±«åœ°å‘Šè¯‰æ‚¨ï¼Œ**JAX** å…·æœ‰ [*â€œuna anima di pura programmazione funzionaleâ€*](https://www.sscardapane.it/iaml-backup/jax-intro/)ã€‚
- en: '**JAX** is a language for **expressing** and **composing** **transformations**
    of numerical programs. **JAX** is also able to **compile** numerical programs
    for CPU or accelerators (GPU/TPU). JAX works great for many numerical and scientific
    programs, but **only if they are written with certain constraints** that we describe
    below.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAX** æ˜¯ä¸€ç§ç”¨äºè¡¨è¾¾å’Œç»„åˆæ•°å€¼ç¨‹åºè½¬æ¢çš„è¯­è¨€ã€‚**JAX** è¿˜èƒ½å¤Ÿä¸º CPU æˆ–åŠ é€Ÿå™¨ï¼ˆGPU/TPUï¼‰**ç¼–è¯‘**æ•°å€¼ç¨‹åºã€‚å¯¹äºè®¸å¤šæ•°å€¼å’Œç§‘å­¦ç¨‹åºï¼ŒJAX
    è¡¨ç°å‡ºè‰²ï¼Œä½†å‰ææ˜¯å®ƒä»¬å¿…é¡»æŒ‰ç…§æˆ‘ä»¬ä¸‹é¢æè¿°çš„æŸäº›çº¦æŸæ¡ä»¶ç¼–å†™ã€‚'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ğŸ”ª Pure functions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª çº¯å‡½æ•°
- en: 'JAX transformation and compilation are designed to work only on Python functions
    that are functionally pure: all the input data is passed through the function
    parameters, all the results are output through the function results. A pure function
    will always return the same result if invoked with the same inputs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JAX çš„è½¬æ¢å’Œç¼–è¯‘è®¾è®¡ä»…é€‚ç”¨äºå‡½æ•°å¼çº¯çš„ Python å‡½æ•°ï¼šæ‰€æœ‰è¾“å…¥æ•°æ®é€šè¿‡å‡½æ•°å‚æ•°ä¼ é€’ï¼Œæ‰€æœ‰ç»“æœé€šè¿‡å‡½æ•°ç»“æœè¾“å‡ºã€‚çº¯å‡½æ•°å¦‚æœä»¥ç›¸åŒçš„è¾“å…¥è°ƒç”¨ï¼Œå°†å§‹ç»ˆè¿”å›ç›¸åŒçš„ç»“æœã€‚
- en: Here are some examples of functions that are not functionally pure for which
    JAX behaves differently than the Python interpreter. Note that these behaviors
    are not guaranteed by the JAX system; the proper way to use JAX is to use it only
    on functionally pure Python functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€äº›å‡½æ•°ç¤ºä¾‹ï¼Œè¿™äº›å‡½æ•°ä¸æ˜¯å‡½æ•°å¼çº¯çš„ï¼Œå› æ­¤ JAX çš„è¡Œä¸ºä¸ Python è§£é‡Šå™¨ä¸åŒã€‚è¯·æ³¨æ„ï¼Œè¿™äº›è¡Œä¸ºå¹¶ä¸ç”± JAX ç³»ç»Ÿä¿è¯ï¼›æ­£ç¡®ä½¿ç”¨ JAX
    çš„æ–¹æ³•æ˜¯ä»…åœ¨å‡½æ•°å¼çº¯ Python å‡½æ•°ä¸Šä½¿ç”¨å®ƒã€‚
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A Python function can be functionally pure even if it actually uses stateful
    objects internally, as long as it does not read or write external state:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ä¸€ä¸ª Python å‡½æ•°åœ¨å†…éƒ¨å®é™…ä¸Šä½¿ç”¨äº†æœ‰çŠ¶æ€çš„å¯¹è±¡ï¼Œåªè¦å®ƒä¸è¯»å–æˆ–å†™å…¥å¤–éƒ¨çŠ¶æ€ï¼Œå®ƒå°±å¯ä»¥æ˜¯å‡½æ•°å¼çº¯çš„ï¼š
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is not recommended to use iterators in any JAX function you want to `jit`
    or in any control-flow primitive. The reason is that an iterator is a python object
    which introduces state to retrieve the next element. Therefore, it is incompatible
    with JAX functional programming model. In the code below, there are some examples
    of incorrect attempts to use iterators with JAX. Most of them return an error,
    but some give unexpected results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å»ºè®®åœ¨å¸Œæœ›`jit`çš„ä»»ä½• JAX å‡½æ•°ä¸­ä½¿ç”¨è¿­ä»£å™¨æˆ–ä»»ä½•æ§åˆ¶æµåŸè¯­ã€‚åŸå› æ˜¯è¿­ä»£å™¨æ˜¯ä¸€ä¸ªå¼•å…¥çŠ¶æ€ä»¥æ£€ç´¢ä¸‹ä¸€ä¸ªå…ƒç´ çš„ Python å¯¹è±¡ã€‚å› æ­¤ï¼Œå®ƒä¸ JAX
    çš„å‡½æ•°å¼ç¼–ç¨‹æ¨¡å‹ä¸å…¼å®¹ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæœ‰ä¸€äº›å°è¯•åœ¨ JAX ä¸­ä½¿ç”¨è¿­ä»£å™¨çš„é”™è¯¯ç¤ºä¾‹ã€‚å…¶ä¸­å¤§å¤šæ•°ä¼šè¿”å›é”™è¯¯ï¼Œä½†æœ‰äº›ä¼šç»™å‡ºæ„å¤–çš„ç»“æœã€‚
- en: '[PRE9]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ğŸ”ª In-Place Updates
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª åŸåœ°æ›´æ–°
- en: 'In Numpy youâ€™re used to doing this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Numpy ä¸­ï¼Œæ‚¨ä¹ æƒ¯äºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
- en: '[PRE11]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to update a JAX device array in-place, however, we get an **error**!
    (â˜‰_â˜‰)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬å°è¯•åœ¨ JAX è®¾å¤‡æ•°ç»„ä¸Šå°±åœ°æ›´æ–°ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°**é”™è¯¯**ï¼(â˜‰_â˜‰)
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Allowing mutation of variables in-place makes program analysis and transformation
    difficult. JAX requires that programs are pure functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å…è®¸å˜é‡åœ¨åŸåœ°å˜å¼‚ä¼šä½¿ç¨‹åºåˆ†æå’Œè½¬æ¢å˜å¾—å›°éš¾ã€‚JAX è¦æ±‚ç¨‹åºæ˜¯çº¯å‡½æ•°ã€‚
- en: Instead, JAX offers a *functional* array update using the [`.at` property on
    JAX arrays](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼ŒJAX æä¾›äº†å¯¹ JAX æ•°ç»„ä¸Šçš„ [`.at` å±æ€§è¿›è¡Œå‡½æ•°å¼æ•°ç»„æ›´æ–°](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)ã€‚
- en: ï¸âš ï¸ inside `jit`â€™d code and `lax.while_loop` or `lax.fori_loop` the **size**
    of slices canâ€™t be functions of argument *values* but only functions of argument
    *shapes* â€“ the slice start indices have no such restriction. See the below **Control
    Flow** Section for more information on this limitation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ï¸âš ï¸ åœ¨ `jit` çš„ä»£ç ä¸­å’Œ `lax.while_loop` æˆ– `lax.fori_loop` ä¸­ï¼Œ**åˆ‡ç‰‡çš„å¤§å°**ä¸èƒ½æ˜¯å‚æ•° *å€¼* çš„å‡½æ•°ï¼Œè€Œåªèƒ½æ˜¯å‚æ•°
    *å½¢çŠ¶* çš„å‡½æ•° â€” åˆ‡ç‰‡çš„èµ·å§‹ç´¢å¼•æ²¡æœ‰æ­¤ç±»é™åˆ¶ã€‚æœ‰å…³æ­¤é™åˆ¶çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢çš„ **æ§åˆ¶æµ** éƒ¨åˆ†ã€‚
- en: 'Array updates: `x.at[idx].set(y)`'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ•°ç»„æ›´æ–°ï¼š`x.at[idx].set(y)`
- en: 'For example, the update above can be written as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä¸Šè¿°æ›´æ–°å¯ä»¥å†™æˆï¼š
- en: '[PRE17]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: JAXâ€™s array update functions, unlike their NumPy versions, operate out-of-place.
    That is, the updated array is returned as a new array and the original array is
    not modified by the update.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JAXçš„æ•°ç»„æ›´æ–°å‡½æ•°ä¸å…¶NumPyç‰ˆæœ¬ä¸åŒï¼Œæ˜¯åœ¨**åŸåœ°**å¤–æ‰§è¡Œçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ›´æ–°åçš„æ•°ç»„ä½œä¸ºæ–°æ•°ç»„è¿”å›ï¼ŒåŸå§‹æ•°ç»„ä¸ä¼šè¢«æ›´æ–°ä¿®æ”¹ã€‚
- en: '[PRE19]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, inside **jit**-compiled code, if the **input value** `x` of `x.at[idx].set(y)`
    is not reused, the compiler will optimize the array update to occur *in-place*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨**jit**ç¼–è¯‘çš„ä»£ç å†…éƒ¨ï¼Œå¦‚æœ`x.at[idx].set(y)`çš„**è¾“å…¥å€¼** `x` æ²¡æœ‰è¢«é‡ç”¨ï¼Œç¼–è¯‘å™¨ä¼šä¼˜åŒ–æ•°ç»„æ›´æ–°ä»¥è¿›è¡Œ*åŸåœ°*æ“ä½œã€‚
- en: Array updates with other operations
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å…¶ä»–æ“ä½œçš„æ•°ç»„æ›´æ–°
- en: 'Indexed array updates are not limited simply to overwriting values. For example,
    we can perform indexed addition as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç´¢å¼•æ•°ç»„æ›´æ–°ä¸ä»…é™äºè¦†ç›–å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œç´¢å¼•åŠ æ³•å¦‚ä¸‹ï¼š
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For more details on indexed array updates, see the [documentation for the `.at`
    property](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³ç´¢å¼•æ•°ç»„æ›´æ–°çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[`.at`å±æ€§çš„æ–‡æ¡£](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)ã€‚
- en: ğŸ”ª Out-of-Bounds Indexing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª è¶…å‡ºè¾¹ç•Œç´¢å¼•
- en: 'In Numpy, you are used to errors being thrown when you index an array outside
    of its bounds, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨NumPyä¸­ï¼Œå½“æ‚¨ç´¢å¼•æ•°ç»„è¶…å‡ºå…¶è¾¹ç•Œæ—¶ï¼Œé€šå¸¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œä¾‹å¦‚ï¼š
- en: '[PRE23]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, raising an error from code running on an accelerator can be difficult
    or impossible. Therefore, JAX must choose some non-error behavior for out of bounds
    indexing (akin to how invalid floating point arithmetic results in `NaN`). When
    the indexing operation is an array index update (e.g. `index_add` or `scatter`-like
    primitives), updates at out-of-bounds indices will be skipped; when the operation
    is an array index retrieval (e.g. NumPy indexing or `gather`-like primitives)
    the index is clamped to the bounds of the array since **something** must be returned.
    For example, the last value of the array will be returned from this indexing operation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨åŠ é€Ÿå™¨ä¸Šè¿è¡Œçš„ä»£ç ä¸­å¼•å‘é”™è¯¯å¯èƒ½ä¼šå¾ˆå›°éš¾æˆ–ä¸å¯èƒ½ã€‚å› æ­¤ï¼ŒJAXå¿…é¡»ä¸ºè¶…å‡ºè¾¹ç•Œçš„ç´¢å¼•é€‰æ‹©ä¸€äº›éé”™è¯¯è¡Œä¸ºï¼ˆç±»ä¼¼äºæ— æ•ˆçš„æµ®ç‚¹ç®—æœ¯ç»“æœä¸º`NaN`çš„æƒ…å†µï¼‰ã€‚å½“ç´¢å¼•æ“ä½œæ˜¯æ•°ç»„ç´¢å¼•æ›´æ–°æ—¶ï¼ˆä¾‹å¦‚`index_add`æˆ–ç±»ä¼¼çš„åŸè¯­ï¼‰ï¼Œå°†è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„ç´¢å¼•ï¼›å½“æ“ä½œæ˜¯æ•°ç»„ç´¢å¼•æ£€ç´¢æ—¶ï¼ˆä¾‹å¦‚NumPyç´¢å¼•æˆ–ç±»ä¼¼çš„åŸè¯­ï¼‰ï¼Œç´¢å¼•å°†å¤¹ç´§åˆ°æ•°ç»„çš„è¾¹ç•Œï¼Œå› ä¸ºå¿…é¡»è¿”å›**æŸäº›å†…å®¹**ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„çš„æœ€åä¸€ä¸ªå€¼å°†ä»æ­¤ç´¢å¼•æ“ä½œä¸­è¿”å›ï¼š
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you would like finer-grained control over the behavior for out-of-bound
    indices, you can use the optional parameters of [`ndarray.at`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html);
    for example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨å¸Œæœ›å¯¹è¶…å‡ºè¾¹ç•Œç´¢å¼•çš„è¡Œä¸ºæœ‰æ›´ç²¾ç»†çš„æ§åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨[`ndarray.at`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html)çš„å¯é€‰å‚æ•°ï¼›ä¾‹å¦‚ï¼š
- en: '[PRE27]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that due to this behavior for index retrieval, functions like `jnp.nanargmin`
    and `jnp.nanargmax` return -1 for slices consisting of NaNs whereas Numpy would
    throw an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ç”±äºè¿™ç§ç´¢å¼•æ£€ç´¢è¡Œä¸ºï¼Œåƒ`jnp.nanargmin`å’Œ`jnp.nanargmax`è¿™æ ·çš„å‡½æ•°åœ¨ç”±NaNç»„æˆçš„åˆ‡ç‰‡ä¸­è¿”å›-1ï¼Œè€ŒNumPyä¼šæŠ›å‡ºé”™è¯¯ã€‚
- en: Note also that, as the two behaviors described above are not inverses of each
    other, reverse-mode automatic differentiation (which turns index updates into
    index retrievals and vice versa) [will not preserve the semantics of out of bounds
    indexing](https://github.com/google/jax/issues/5760). Thus it may be a good idea
    to think of out-of-bounds indexing in JAX as a case of [undefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜è¯·æ³¨æ„ï¼Œç”±äºä¸Šè¿°ä¸¤ç§è¡Œä¸ºä¸æ˜¯äº’ä¸ºåæ“ä½œï¼Œåå‘æ¨¡å¼è‡ªåŠ¨å¾®åˆ†ï¼ˆå°†ç´¢å¼•æ›´æ–°è½¬æ¢ä¸ºç´¢å¼•æ£€ç´¢åŠå…¶åä¹‹ï¼‰[å°†ä¸ä¼šä¿ç•™è¶…å‡ºè¾¹ç•Œç´¢å¼•çš„è¯­ä¹‰](https://github.com/google/jax/issues/5760)ã€‚å› æ­¤ï¼Œå°†JAXä¸­çš„è¶…å‡ºè¾¹ç•Œç´¢å¼•è§†ä¸º[æœªå®šä¹‰è¡Œä¸º](https://en.wikipedia.org/wiki/Undefined_behavior)å¯èƒ½æ˜¯ä¸ªå¥½ä¸»æ„ã€‚
- en: 'ğŸ”ª Non-array inputs: NumPy vs. JAX'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª éæ•°ç»„è¾“å…¥ï¼šNumPy vs. JAX
- en: 'NumPy is generally happy accepting Python lists or tuples as inputs to its
    API functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: NumPyé€šå¸¸å¯ä»¥æ¥å—Pythonåˆ—è¡¨æˆ–å…ƒç»„ä½œä¸ºå…¶APIå‡½æ•°çš„è¾“å…¥ï¼š
- en: '[PRE31]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'JAX departs from this, generally returning a helpful error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JAXåœ¨è¿™æ–¹é¢æœ‰æ‰€ä¸åŒï¼Œé€šå¸¸ä¼šè¿”å›æœ‰ç”¨çš„é”™è¯¯ï¼š
- en: '[PRE33]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a deliberate design choice, because passing lists or tuples to traced
    functions can lead to silent performance degradation that might otherwise be difficult
    to detect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæœ‰æ„çš„è®¾è®¡é€‰æ‹©ï¼Œå› ä¸ºå‘è¿½è¸ªå‡½æ•°ä¼ é€’åˆ—è¡¨æˆ–å…ƒç»„å¯èƒ½å¯¼è‡´æ€§èƒ½ä¸‹é™ï¼Œè€Œè¿™ç§æ€§èƒ½ä¸‹é™å¯èƒ½å¾ˆéš¾æ£€æµ‹åˆ°ã€‚
- en: 'For example, consider the following permissive version of `jnp.sum` that allows
    list inputs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè¯·è€ƒè™‘å…è®¸åˆ—è¡¨è¾“å…¥çš„`jnp.sum`çš„ä»¥ä¸‹å®½æ¾ç‰ˆæœ¬ï¼š
- en: '[PRE35]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is what we would expect, but this hides potential performance issues
    under the hood. In JAXâ€™s tracing and JIT compilation model, each element in a
    Python list or tuple is treated as a separate JAX variable, and individually processed
    and pushed to device. This can be seen in the jaxpr for the `permissive_sum` function
    above:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å‡ºä¸é¢„æœŸç›¸ç¬¦ï¼Œä½†è¿™éšè—äº†åº•å±‚çš„æ½œåœ¨æ€§èƒ½é—®é¢˜ã€‚åœ¨JAXçš„è¿½è¸ªå’ŒJITç¼–è¯‘æ¨¡å‹ä¸­ï¼ŒPythonåˆ—è¡¨æˆ–å…ƒç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¢«è§†ä¸ºå•ç‹¬çš„JAXå˜é‡ï¼Œå¹¶åˆ†åˆ«å¤„ç†å’Œæ¨é€åˆ°è®¾å¤‡ã€‚è¿™å¯ä»¥åœ¨ä¸Šé¢çš„`permissive_sum`å‡½æ•°çš„jaxprä¸­çœ‹åˆ°ï¼š
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each entry of the list is handled as a separate input, resulting in a tracing
    & compilation overhead that grows linearly with the size of the list. To prevent
    surprises like this, JAX avoids implicit conversions of lists and tuples to arrays.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨çš„æ¯ä¸ªæ¡ç›®éƒ½ä½œä¸ºå•ç‹¬çš„è¾“å…¥å¤„ç†ï¼Œå¯¼è‡´è¿½è¸ªå’Œç¼–è¯‘å¼€é”€éšåˆ—è¡¨å¤§å°çº¿æ€§å¢é•¿ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„æ„å¤–ï¼ŒJAXé¿å…å°†åˆ—è¡¨å’Œå…ƒç»„éšå¼è½¬æ¢ä¸ºæ•°ç»„ã€‚
- en: 'If you would like to pass a tuple or list to a JAX function, you can do so
    by first explicitly converting it to an array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨å¸Œæœ›å°†å…ƒç»„æˆ–åˆ—è¡¨ä¼ é€’ç»™JAXå‡½æ•°ï¼Œå¯ä»¥é¦–å…ˆæ˜¾å¼åœ°å°†å…¶è½¬æ¢ä¸ºæ•°ç»„ï¼š
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ğŸ”ª Random Numbers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª éšæœºæ•°
- en: '*If all scientific papers whose results are in doubt because of bad `rand()`s
    were to disappear from library shelves, there would be a gap on each shelf about
    as big as your fist.* - Numerical Recipes'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*å¦‚æœæ‰€æœ‰å› ç³Ÿç³•çš„`rand()`è€Œå­˜ç–‘çš„ç§‘å­¦è®ºæ–‡éƒ½ä»å›¾ä¹¦é¦†ä¹¦æ¶ä¸Šæ¶ˆå¤±ï¼Œæ¯ä¸ªä¹¦æ¶ä¸Šä¼šæœ‰ä¸€ä¸ªæ‹³å¤´å¤§å°çš„ç©ºç™½ã€‚* - Numerical Recipes'
- en: RNGs and State
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RNGå’ŒçŠ¶æ€
- en: 'Youâ€™re used to *stateful* pseudorandom number generators (PRNGs) from numpy
    and other libraries, which helpfully hide a lot of details under the hood to give
    you a ready fountain of pseudorandomness:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨ä¹ æƒ¯äºä»numpyå’Œå…¶ä»–åº“ä¸­ä½¿ç”¨*æœ‰çŠ¶æ€çš„*ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆPRNGï¼‰ï¼Œè¿™äº›åº“åœ¨å¹•åå·§å¦™åœ°éšè—äº†è®¸å¤šç»†èŠ‚ï¼Œä¸ºæ‚¨æä¾›äº†ä¼ªéšæœºæ€§çš„ä¸°å¯Œæºæ³‰ï¼š
- en: '[PRE41]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Underneath the hood, numpy uses the [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)
    PRNG to power its pseudorandom functions. The PRNG has a period of \(2^{19937}-1\)
    and at any point can be described by **624 32-bit unsigned ints** and a **position**
    indicating how much of this â€œentropyâ€ has been used up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº•å±‚ï¼Œnumpyä½¿ç”¨[Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)
    PRNGæ¥é©±åŠ¨å…¶ä¼ªéšæœºå‡½æ•°ã€‚è¯¥PRNGå…·æœ‰\(2^{19937}-1\)çš„å‘¨æœŸï¼Œå¹¶ä¸”åœ¨ä»»ä½•æ—¶å€™å¯ä»¥ç”±**624ä¸ª32ä½æ— ç¬¦å·æ•´æ•°**å’Œä¸€ä¸ªè¡¨ç¤ºå·²ä½¿ç”¨çš„â€œç†µâ€é‡çš„**ä½ç½®**æ¥æè¿°ã€‚
- en: '[PRE43]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This pseudorandom state vector is automagically updated behind the scenes every
    time a random number is needed, â€œconsumingâ€ 2 of the uint32s in the Mersenne twister
    state vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¼ªéšæœºçŠ¶æ€å‘é‡åœ¨æ¯æ¬¡éœ€è¦éšæœºæ•°æ—¶éƒ½ä¼šåœ¨å¹•åè‡ªåŠ¨æ›´æ–°ï¼Œâ€œæ¶ˆè€—â€Mersenne TwisterçŠ¶æ€å‘é‡ä¸­çš„2ä¸ªuint32ï¼š
- en: '[PRE44]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The problem with magic PRNG state is that itâ€™s hard to reason about how itâ€™s
    being used and updated across different threads, processes, and devices, and itâ€™s
    *very easy* to screw up when the details of entropy production and consumption
    are hidden from the end user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: é­”æ³•PRNGçŠ¶æ€çš„é—®é¢˜åœ¨äºå¾ˆéš¾æ¨æ–­å®ƒåœ¨ä¸åŒçº¿ç¨‹ã€è¿›ç¨‹å’Œè®¾å¤‡ä¸­çš„ä½¿ç”¨å’Œæ›´æ–°æ–¹å¼ï¼Œå¹¶ä¸”åœ¨ç†µçš„ç”Ÿæˆå’Œæ¶ˆè€—ç»†èŠ‚å¯¹æœ€ç»ˆç”¨æˆ·éšè—æ—¶ï¼Œ*éå¸¸å®¹æ˜“*å‡ºé”™ã€‚
- en: The Mersenne Twister PRNG is also known to have a [number](https://cs.stackexchange.com/a/53475)
    of problems, it has a large 2.5kB state size, which leads to problematic [initialization
    issues](https://dl.acm.org/citation.cfm?id=1276928). It [fails](http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf)
    modern BigCrush tests, and is generally slow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Mersenne Twister PRNGä¹Ÿè¢«è®¤ä¸ºå­˜åœ¨[ä¸€äº›é—®é¢˜](https://cs.stackexchange.com/a/53475)ï¼Œå®ƒå…·æœ‰è¾ƒå¤§çš„2.5kBçŠ¶æ€å¤§å°ï¼Œå¯¼è‡´åˆå§‹åŒ–é—®é¢˜[å¾ˆå¤š](https://dl.acm.org/citation.cfm?id=1276928)ã€‚å®ƒåœ¨ç°ä»£çš„BigCrushæµ‹è¯•ä¸­[å¤±è´¥](http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf)ï¼Œå¹¶ä¸”é€šå¸¸é€Ÿåº¦è¾ƒæ…¢ã€‚
- en: JAX PRNG
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAX PRNG
- en: JAX instead implements an *explicit* PRNG where entropy production and consumption
    are handled by explicitly passing and iterating PRNG state. JAX uses a modern
    [Threefry counter-based PRNG](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)
    thatâ€™s **splittable**. That is, its design allows us to **fork** the PRNG state
    into new PRNGs for use with parallel stochastic generation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼ŒJAXå®ç°äº†ä¸€ä¸ª*æ˜¾å¼çš„*PRNGï¼Œå…¶ä¸­ç†µçš„ç”Ÿæˆå’Œæ¶ˆè€—é€šè¿‡æ˜¾å¼ä¼ é€’å’Œè¿­ä»£PRNGçŠ¶æ€æ¥å¤„ç†ã€‚JAXä½¿ç”¨ä¸€ç§ç°ä»£åŒ–çš„[ThreefryåŸºäºè®¡æ•°å™¨çš„PRNG](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)ï¼Œå®ƒæ˜¯**å¯åˆ†è£‚**çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå…¶è®¾è®¡å…è®¸æˆ‘ä»¬å°†PRNGçŠ¶æ€åˆ†å‰æˆæ–°çš„PRNGï¼Œä»¥ç”¨äºå¹¶è¡Œéšæœºç”Ÿæˆã€‚
- en: 'The random state is described by a special array element that we call a **key**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: éšæœºçŠ¶æ€ç”±ä¸€ä¸ªæˆ‘ä»¬ç§°ä¹‹ä¸º**å¯†é’¥**çš„ç‰¹æ®Šæ•°ç»„å…ƒç´ æè¿°ï¼š
- en: '[PRE45]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: JAXâ€™s random functions produce pseudorandom numbers from the PRNG state, but
    **do not** change the state!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JAXçš„éšæœºå‡½æ•°ä»PRNGçŠ¶æ€ç”Ÿæˆä¼ªéšæœºæ•°ï¼Œä½†**ä¸ä¼š**æ”¹å˜çŠ¶æ€ï¼
- en: 'Reusing the same state will cause **sadness** and **monotony**, depriving the
    end user of **lifegiving chaos**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: å¤ç”¨ç›¸åŒçš„çŠ¶æ€ä¼šå¯¼è‡´**æ‚²ä¼¤**å’Œ**å•è°ƒ**ï¼Œå‰¥å¤ºæœ€ç»ˆç”¨æˆ·**ç”Ÿå‘½åŠ›çš„æ··ä¹±**ï¼š
- en: '[PRE47]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead, we **split** the PRNG to get usable **subkeys** every time we need
    a new pseudorandom number:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬**åˆ†å‰²**PRNGä»¥åœ¨æ¯æ¬¡éœ€è¦æ–°çš„ä¼ªéšæœºæ•°æ—¶è·å¾—å¯ç”¨çš„**å­å¯†é’¥**ï¼š
- en: '[PRE49]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We propagate the **key** and make new **subkeys** whenever we need a new random
    number:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¼ æ’­**å¯†é’¥**å¹¶åœ¨éœ€è¦æ–°çš„éšæœºæ•°æ—¶ç”Ÿæˆæ–°çš„**å­å¯†é’¥**ï¼š
- en: '[PRE51]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can generate more than one **subkey** at a time:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åŒæ—¶ç”Ÿæˆå¤šä¸ª**å­å¯†é’¥**ï¼š
- en: '[PRE53]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ğŸ”ª Control Flow
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª æ§åˆ¶æµ
- en: âœ” python control_flow + autodiff âœ”
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: âœ” pythonæ§åˆ¶æµ + è‡ªåŠ¨å¾®åˆ† âœ”
- en: If you just want to apply `grad` to your python functions, you can use regular
    python control-flow constructs with no problems, as if you were using [Autograd](https://github.com/hips/autograd)
    (or Pytorch or TF Eager).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨åªæƒ³å°†`grad`åº”ç”¨äºæ‚¨çš„Pythonå‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨å¸¸è§„çš„Pythonæ§åˆ¶æµç»“æ„ï¼Œæ²¡æœ‰é—®é¢˜ï¼Œå°±åƒä½¿ç”¨[Autograd](https://github.com/hips/autograd)ï¼ˆæˆ–Pytorchæˆ–TF
    Eagerï¼‰ä¸€æ ·ã€‚
- en: '[PRE55]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: python control flow + JIT
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pythonæ§åˆ¶æµ + JIT
- en: Using control flow with `jit` is more complicated, and by default it has more
    constraints.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`jit`è¿›è¡Œæ§åˆ¶æµæ›´ä¸ºå¤æ‚ï¼Œé»˜è®¤æƒ…å†µä¸‹å…·æœ‰æ›´å¤šçº¦æŸã€‚
- en: 'This works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå¯ä»¥å·¥ä½œï¼š
- en: '[PRE57]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So does this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·ä¹Ÿå¯ä»¥ï¼š
- en: '[PRE59]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But this doesnâ€™t, at least by default:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™æ ·ä¸è¡Œï¼š
- en: '[PRE61]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**What gives!?**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ€ä¹ˆå›äº‹ï¼ï¼Ÿ**'
- en: When we `jit`-compile a function, we usually want to compile a version of the
    function that works for many different argument values, so that we can cache and
    reuse the compiled code. That way we donâ€™t have to re-compile on each function
    evaluation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬`jit`ç¼–è¯‘ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œé€šå¸¸å¸Œæœ›ç¼–è¯‘ä¸€ä¸ªé€‚ç”¨äºè®¸å¤šä¸åŒå‚æ•°å€¼çš„å‡½æ•°ç‰ˆæœ¬ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ç¼“å­˜å’Œé‡å¤ä½¿ç”¨ç¼–è¯‘ä»£ç ã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸å¿…åœ¨æ¯æ¬¡å‡½æ•°è¯„ä¼°æ—¶é‡æ–°ç¼–è¯‘ã€‚
- en: For example, if we evaluate an `@jit` function on the array `jnp.array([1.,
    2., 3.], jnp.float32)`, we might want to compile code that we can reuse to evaluate
    the function on `jnp.array([4., 5., 6.], jnp.float32)` to save on compile time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åœ¨æ•°ç»„`jnp.array([1., 2., 3.], jnp.float32)`ä¸Šè¯„ä¼°`@jit`å‡½æ•°ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›ç¼–è¯‘ä»£ç ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥é‡å¤ä½¿ç”¨å®ƒæ¥åœ¨`jnp.array([4.,
    5., 6.], jnp.float32)`ä¸Šè¯„ä¼°å‡½æ•°ï¼Œä»è€ŒèŠ‚çœç¼–è¯‘æ—¶é—´ã€‚
- en: To get a view of your Python code that is valid for many different argument
    values, JAX traces it on *abstract values* that represent sets of possible inputs.
    There are [multiple different levels of abstraction](https://github.com/google/jax/blob/main/jax/_src/abstract_arrays.py),
    and different transformations use different abstraction levels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æŸ¥çœ‹é€‚ç”¨äºè®¸å¤šä¸åŒå‚æ•°å€¼çš„Pythonä»£ç è§†å›¾ï¼ŒJAXä¼šè·Ÿè¸ª*æŠ½è±¡å€¼*ï¼Œè¿™äº›æŠ½è±¡å€¼è¡¨ç¤ºå¯èƒ½è¾“å…¥é›†åˆçš„é›†åˆã€‚æœ‰å…³ä¸åŒçš„è½¬æ¢ä½¿ç”¨ä¸åŒçš„æŠ½è±¡çº§åˆ«ï¼Œè¯¦è§[å¤šä¸ªä¸åŒçš„æŠ½è±¡çº§åˆ«](https://github.com/google/jax/blob/main/jax/_src/abstract_arrays.py)ã€‚
- en: By default, `jit` traces your code on the `ShapedArray` abstraction level, where
    each abstract value represents the set of all array values with a fixed shape
    and dtype. For example, if we trace using the abstract value `ShapedArray((3,),
    jnp.float32)`, we get a view of the function that can be reused for any concrete
    value in the corresponding set of arrays. That means we can save on compile time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼Œ`jit`ä¼šåœ¨`ShapedArray`æŠ½è±¡çº§åˆ«ä¸Šè·Ÿè¸ªæ‚¨çš„ä»£ç ï¼Œå…¶ä¸­æ¯ä¸ªæŠ½è±¡å€¼è¡¨ç¤ºå…·æœ‰å›ºå®šå½¢çŠ¶å’Œdtypeçš„æ‰€æœ‰æ•°ç»„å€¼çš„é›†åˆã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨æŠ½è±¡å€¼`ShapedArray((3,),
    jnp.float32)`è¿›è¡Œè·Ÿè¸ªï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°å¯ä»¥é‡å¤ä½¿ç”¨äºç›¸åº”æ•°ç»„é›†åˆä¸­çš„ä»»ä½•å…·ä½“å€¼çš„å‡½æ•°è§†å›¾ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥èŠ‚çœç¼–è¯‘æ—¶é—´ã€‚
- en: 'But thereâ€™s a tradeoff here: if we trace a Python function on a `ShapedArray((),
    jnp.float32)` that isnâ€™t committed to a specific concrete value, when we hit a
    line like `if x < 3`, the expression `x < 3` evaluates to an abstract `ShapedArray((),
    jnp.bool_)` that represents the set `{True, False}`. When Python attempts to coerce
    that to a concrete `True` or `False`, we get an error: we donâ€™t know which branch
    to take, and canâ€™t continue tracing! The tradeoff is that with higher levels of
    abstraction we gain a more general view of the Python code (and thus save on re-compilations),
    but we require more constraints on the Python code to complete the trace.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™é‡Œæœ‰ä¸€ä¸ªæƒè¡¡ï¼šå¦‚æœæˆ‘ä»¬åœ¨`ShapedArray((), jnp.float32)`ä¸Šè·Ÿè¸ªPythonå‡½æ•°ï¼Œå®ƒä¸ä¸“æ³¨äºå…·ä½“å€¼ï¼Œå½“æˆ‘ä»¬é‡åˆ°åƒ`if x
    < 3`è¿™æ ·çš„è¡Œæ—¶ï¼Œè¡¨è¾¾å¼`x < 3`ä¼šè¯„ä¼°ä¸ºè¡¨ç¤ºé›†åˆ`{True, False}`çš„æŠ½è±¡`ShapedArray((), jnp.bool_)`ã€‚å½“Pythonå°è¯•å°†å…¶å¼ºåˆ¶è½¬æ¢ä¸ºå…·ä½“çš„`True`æˆ–`False`æ—¶ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°é”™è¯¯ï¼šæˆ‘ä»¬ä¸çŸ¥é“åº”è¯¥é€‰æ‹©å“ªä¸ªåˆ†æ”¯ï¼Œæ— æ³•ç»§ç»­è·Ÿè¸ªï¼æƒè¡¡æ˜¯ï¼Œä½¿ç”¨æ›´é«˜çº§åˆ«çš„æŠ½è±¡ï¼Œæˆ‘ä»¬è·å¾—Pythonä»£ç çš„æ›´ä¸€èˆ¬è§†å›¾ï¼ˆå› æ­¤èŠ‚çœé‡æ–°ç¼–è¯‘çš„æ—¶é—´ï¼‰ï¼Œä½†æˆ‘ä»¬éœ€è¦æ›´å¤šçº¦æŸæ¥å®Œæˆè·Ÿè¸ªã€‚
- en: 'The good news is that you can control this tradeoff yourself. By having `jit`
    trace on more refined abstract values, you can relax the traceability constraints.
    For example, using the `static_argnums` argument to `jit`, we can specify to trace
    on concrete values of some arguments. Hereâ€™s that example function again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½æ¶ˆæ¯æ˜¯ï¼Œæ‚¨å¯ä»¥è‡ªè¡Œæ§åˆ¶è¿™ç§æƒè¡¡ã€‚é€šè¿‡å¯ç”¨`jit`å¯¹æ›´ç²¾ç»†çš„æŠ½è±¡å€¼è¿›è¡Œè·Ÿè¸ªï¼Œæ‚¨å¯ä»¥æ”¾å®½è·Ÿè¸ªçº¦æŸã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨`jit`çš„`static_argnums`å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‡å®šåœ¨æŸäº›å‚æ•°çš„å…·ä½“å€¼ä¸Šè¿›è¡Œè·Ÿè¸ªã€‚ä¸‹é¢æ˜¯è¿™ä¸ªä¾‹å­å‡½æ•°ï¼š
- en: '[PRE63]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Hereâ€™s another example, this time involving a loop:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯å¦ä¸€ä¸ªä¾‹å­ï¼Œè¿™æ¬¡æ¶‰åŠå¾ªç¯ï¼š
- en: '[PRE65]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In effect, the loop gets statically unrolled. JAX can also trace at *higher*
    levels of abstraction, like `Unshaped`, but thatâ€™s not currently the default for
    any transformation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œå¾ªç¯è¢«é™æ€å±•å¼€ã€‚JAX ä¹Ÿå¯ä»¥åœ¨æ›´é«˜çš„æŠ½è±¡çº§åˆ«è¿›è¡Œè¿½è¸ªï¼Œæ¯”å¦‚ `Unshaped`ï¼Œä½†ç›®å‰å¯¹äºä»»ä½•å˜æ¢æ¥è¯´è¿™éƒ½ä¸æ˜¯é»˜è®¤çš„ã€‚
- en: ï¸âš ï¸ **functions with argument-**value** dependent shapes**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ï¸âš ï¸ **å…·æœ‰å‚æ•°-å€¼ç›¸å…³å½¢çŠ¶çš„å‡½æ•°**
- en: 'These control-flow issues also come up in a more subtle way: numerical functions
    we want to **jit** canâ€™t specialize the shapes of internal arrays on argument
    *values* (specializing on argument **shapes** is ok). As a trivial example, letâ€™s
    make a function whose output happens to depend on the input variable `length`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ§åˆ¶æµé—®é¢˜ä¹Ÿä»¥æ›´å¾®å¦™çš„æ–¹å¼å‡ºç°ï¼šæˆ‘ä»¬å¸Œæœ› **jit** çš„æ•°å€¼å‡½æ•°ä¸èƒ½æ ¹æ®å‚æ•° *å€¼* æ¥ç‰¹åŒ–å†…éƒ¨æ•°ç»„çš„å½¢çŠ¶ï¼ˆåœ¨å‚æ•° **å½¢çŠ¶** ä¸Šç‰¹åŒ–æ˜¯å¯ä»¥çš„ï¼‰ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå…¶è¾“å‡ºæ°å¥½ä¾èµ–äºè¾“å…¥å˜é‡
    `length`ã€‚
- en: '[PRE67]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`static_argnums` can be handy if `length` in our example rarely changes, but
    it would be disastrous if it changed a lot!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ `length` å¾ˆå°‘æ›´æ”¹ï¼Œé‚£ä¹ˆ `static_argnums` å°±ä¼šå¾ˆæ–¹ä¾¿ï¼Œä½†å¦‚æœå®ƒç»å¸¸æ›´æ”¹ï¼Œé‚£å°†æ˜¯ç¾éš¾æ€§çš„ï¼
- en: 'Lastly, if your function has global side-effects, JAXâ€™s tracer can cause weird
    things to happen. A common gotcha is trying to print arrays inside **jit**â€™d functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå¦‚æœæ‚¨çš„å‡½æ•°å…·æœ‰å…¨å±€å‰¯ä½œç”¨ï¼ŒJAX çš„è¿½è¸ªå™¨å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…å‘ç”Ÿã€‚ä¸€ä¸ªå¸¸è§çš„å‘æ˜¯å°è¯•åœ¨ **jit** å‡½æ•°ä¸­æ‰“å°æ•°ç»„ï¼š
- en: '[PRE73]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Structured control flow primitives
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ç»“æ„åŒ–æ§åˆ¶æµåŸè¯­
- en: 'There are more options for control flow in JAX. Say you want to avoid re-compilations
    but still want to use control flow thatâ€™s traceable, and that avoids un-rolling
    large loops. Then you can use these 4 structured control flow primitives:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JAX ä¸­æœ‰æ›´å¤šæ§åˆ¶æµé€‰é¡¹ã€‚å‡è®¾æ‚¨æƒ³é¿å…é‡æ–°ç¼–è¯‘ä½†ä»æƒ³ä½¿ç”¨å¯è¿½è¸ªçš„æ§åˆ¶æµï¼Œå¹¶é¿å…å±•å¼€å¤§å¾ªç¯ã€‚é‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨è¿™å››ä¸ªç»“æ„åŒ–çš„æ§åˆ¶æµåŸè¯­ï¼š
- en: '`lax.cond` *differentiable*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.cond` *å¯å¾®åˆ†*'
- en: '`lax.while_loop` **fwd-mode-differentiable**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.while_loop` **å‰å‘æ¨¡å¼å¯å¾®åˆ†**'
- en: '`lax.fori_loop` **fwd-mode-differentiable** in general; **fwd and rev-mode
    differentiable** if endpoints are static.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.fori_loop` **å‰å‘æ¨¡å¼å¯å¾®åˆ†**ï¼›å¦‚æœç«¯ç‚¹æ˜¯é™æ€çš„ï¼Œåˆ™**å‰å‘å’Œåå‘æ¨¡å¼å‡å¯å¾®åˆ†**ã€‚'
- en: '`lax.scan` *differentiable*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.scan` *å¯å¾®åˆ†*'
- en: '`cond`'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`cond`'
- en: 'python equivalent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: python ç­‰æ•ˆï¼š
- en: '[PRE76]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`jax.lax` provides two other functions that allow branching on dynamic predicates:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.lax` è¿˜æä¾›äº†å¦å¤–ä¸¤ä¸ªå‡½æ•°ï¼Œå…è®¸æ ¹æ®åŠ¨æ€è°“è¯è¿›è¡Œåˆ†æ”¯ï¼š'
- en: '[`lax.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html)
    is like a batched version of `lax.cond`, with the choices expressed as pre-computed
    arrays rather than as functions.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`lax.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html)
    ç±»ä¼¼äº `lax.cond` çš„æ‰¹å¤„ç†ç‰ˆæœ¬ï¼Œé€‰æ‹©é¡¹è¡¨è¾¾ä¸ºé¢„å…ˆè®¡ç®—çš„æ•°ç»„è€Œä¸æ˜¯å‡½æ•°ã€‚'
- en: '[`lax.switch`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.switch.html)
    is like `lax.cond`, but allows switching between any number of callable choices.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`lax.switch`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.switch.html)
    ç±»ä¼¼äº `lax.cond`ï¼Œä½†å…è®¸åœ¨ä»»æ„æ•°é‡çš„å¯è°ƒç”¨é€‰é¡¹ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚'
- en: 'In addition, `jax.numpy` provides several numpy-style interfaces to these functions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: å¦å¤–ï¼Œ`jax.numpy` æä¾›äº†å‡ ä¸ª numpy é£æ ¼çš„æ¥å£ï¼š
- en: '[`jnp.where`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.where.html)
    with three arguments is the numpy-style wrapper of `lax.select`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.where`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.where.html)
    çš„ä¸‰ä¸ªå‚æ•°æ˜¯ `lax.select` çš„ numpy é£æ ¼å°è£…ã€‚'
- en: '[`jnp.piecewise`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.piecewise.html)
    is a numpy-style wrapper of `lax.switch`, but switches on a list of boolean conditions
    rather than a single scalar index.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.piecewise`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.piecewise.html)
    æ˜¯ `lax.switch` çš„ numpy é£æ ¼å°è£…ï¼Œä½†æ˜¯æ ¹æ®ä¸€ç³»åˆ—å¸ƒå°”æ¡ä»¶è€Œä¸æ˜¯å•ä¸ªæ ‡é‡ç´¢å¼•è¿›è¡Œåˆ‡æ¢ã€‚'
- en: '[`jnp.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.select.html)
    has an API similar to `jnp.piecewise`, but the choices are given as pre-computed
    arrays rather than as functions. It is implemented in terms of multiple calls
    to `lax.select`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.select.html)
    çš„ API ç±»ä¼¼äº `jnp.piecewise`ï¼Œä½†é€‰æ‹©é¡¹æ˜¯ä½œä¸ºé¢„å…ˆè®¡ç®—çš„æ•°ç»„è€Œä¸æ˜¯å‡½æ•°ç»™å‡ºçš„ã€‚å®ƒæ˜¯åŸºäºå¤šæ¬¡è°ƒç”¨ `lax.select` å®ç°çš„ã€‚'
- en: '`while_loop`'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`while_loop`'
- en: 'python equivalent:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: python ç­‰æ•ˆï¼š
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`fori_loop`'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`fori_loop`'
- en: 'python equivalent:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: python ç­‰æ•ˆï¼š
- en: '[PRE82]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: \[\begin{split} \begin{array} {r|rr} \hline \ \textrm{construct} & \textrm{jit}
    & \textrm{grad} \\ \hline \ \textrm{if} & âŒ & âœ” \\ \textrm{for} & âœ”* & âœ”\\ \textrm{while}
    & âœ”* & âœ”\\ \textrm{lax.cond} & âœ” & âœ”\\ \textrm{lax.while_loop} & âœ” & \textrm{fwd}\\
    \textrm{lax.fori_loop} & âœ” & \textrm{fwd}\\ \textrm{lax.scan} & âœ” & âœ”\\ \hline
    \end{array} \end{split}\]
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \begin{array} {r|rr} \hline \ \textrm{æ„é€ } & \textrm{jit} & \textrm{grad}
    \\ \hline \ \textrm{if} & âŒ & âœ” \\ \textrm{for} & âœ”* & âœ”\\ \textrm{while} & âœ”*
    & âœ”\\ \textrm{lax.cond} & âœ” & âœ”\\ \textrm{lax.while_loop} & âœ” & \textrm{å‰å‘}\\
    \textrm{lax.fori_loop} & âœ” & \textrm{å‰å‘}\\ \textrm{lax.scan} & âœ” & âœ”\\ \hline
    \end{array} \end{split}\]
- en: \(\ast\) = argument-**value**-independent loop condition - unrolls the loop
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: \(\ast\) = å‚æ•°-**å€¼**-ç‹¬ç«‹å¾ªç¯æ¡ä»¶ - å±•å¼€å¾ªç¯
- en: ğŸ”ª Dynamic Shapes
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª åŠ¨æ€å½¢çŠ¶
- en: 'JAX code used within transforms like `jax.jit`, `jax.vmap`, `jax.grad`, etc.
    requires all output arrays and intermediate arrays to have static shape: that
    is, the shape cannot depend on values within other arrays.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åƒ`jax.jit`ã€`jax.vmap`ã€`jax.grad`ç­‰å˜æ¢ä¸­ä½¿ç”¨çš„JAXä»£ç è¦æ±‚æ‰€æœ‰è¾“å‡ºæ•°ç»„å’Œä¸­é—´æ•°ç»„å…·æœ‰é™æ€å½¢çŠ¶ï¼šå³å½¢çŠ¶ä¸èƒ½ä¾èµ–äºå…¶ä»–æ•°ç»„ä¸­çš„å€¼ã€‚
- en: 'For example, if you were implementing your own version of `jnp.nansum`, you
    might start with something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æ­£åœ¨å®ç°è‡ªå·±çš„ç‰ˆæœ¬`jnp.nansum`ï¼Œæ‚¨å¯èƒ½ä¼šä»ä»¥ä¸‹å†…å®¹å¼€å§‹ï¼š
- en: '[PRE85]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Outside JIT and other transforms, this works as expected:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨JITå’Œå…¶ä»–è½¬æ¢ä¹‹å¤–ï¼Œè¿™å¯ä»¥æ­£å¸¸å·¥ä½œï¼š
- en: '[PRE86]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you attempt to apply `jax.jit` or another transform to this function, it
    will error:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå°è¯•å°†`jax.jit`æˆ–å¦ä¸€ä¸ªè½¬æ¢åº”ç”¨äºæ­¤å‡½æ•°ï¼Œåˆ™ä¼šæŠ¥é”™ï¼š
- en: '[PRE88]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The problem is that the size of `x_without_nans` is dependent on the values
    within `x`, which is another way of saying its size is *dynamic*. Often in JAX
    it is possible to work-around the need for dynamically-sized arrays via other
    means. For example, here it is possible to use the three-argument form of `jnp.where`
    to replace the NaN values with zeros, thus computing the same result while avoiding
    dynamic shapes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äº`x_without_nans`çš„å¤§å°å–å†³äº`x`ä¸­çš„å€¼ï¼Œè¿™å¦ä¸€ç§æ–¹å¼è¯´å®ƒçš„å¤§å°æ˜¯*åŠ¨æ€*çš„ã€‚é€šå¸¸åœ¨JAXä¸­ï¼Œå¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼ç»•è¿‡å¯¹åŠ¨æ€å¤§å°æ•°ç»„çš„éœ€æ±‚ã€‚ä¾‹å¦‚ï¼Œåœ¨è¿™é‡Œå¯ä»¥ä½¿ç”¨`jnp.where`çš„ä¸‰å‚æ•°å½¢å¼ï¼Œå°†NaNå€¼æ›¿æ¢ä¸ºé›¶ï¼Œä»è€Œè®¡ç®—å‡ºç›¸åŒçš„ç»“æœï¼ŒåŒæ—¶é¿å…åŠ¨æ€å½¢çŠ¶ï¼š
- en: '[PRE90]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Similar tricks can be played in other situations where dynamically-shaped arrays
    occur.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œç±»ä¼¼çš„æŠ€å·§å¯ä»¥å‘æŒ¥ä½œç”¨ï¼Œå…¶ä¸­åŠ¨æ€å½¢çŠ¶æ•°ç»„å‡ºç°ã€‚
- en: ğŸ”ª NaNs
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª NaNs
- en: Debugging NaNs
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è°ƒè¯•NaNs
- en: 'If you want to trace where NaNs are occurring in your functions or gradients,
    you can turn on the NaN-checker by:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¦è¿½è¸ªä½ çš„å‡½æ•°æˆ–æ¢¯åº¦ä¸­å‡ºç°NaNçš„ä½ç½®ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ‰“å¼€NaNæ£€æŸ¥å™¨ï¼š
- en: setting the `JAX_DEBUG_NANS=True` environment variable;
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¾ç½®`JAX_DEBUG_NANS=True`ç¯å¢ƒå˜é‡ï¼›
- en: adding `jax.config.update("jax_debug_nans", True)` near the top of your main
    file;
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½ çš„ä¸»æ–‡ä»¶é¡¶éƒ¨æ·»åŠ `jax.config.update("jax_debug_nans", True)`ï¼›
- en: adding `jax.config.parse_flags_with_absl()` to your main file, then set the
    option using a command-line flag like `--jax_debug_nans=True`;
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½ çš„ä¸»æ–‡ä»¶ä¸­æ·»åŠ `jax.config.parse_flags_with_absl()`ï¼Œç„¶åä½¿ç”¨å‘½ä»¤è¡Œæ ‡å¿—è®¾ç½®é€‰é¡¹ï¼Œå¦‚`--jax_debug_nans=True`ï¼›
- en: This will cause computations to error-out immediately on production of a NaN.
    Switching this option on adds a nan check to every floating point type value produced
    by XLA. That means values are pulled back to the host and checked as ndarrays
    for every primitive operation not under an `@jit`. For code under an `@jit`, the
    output of every `@jit` function is checked and if a nan is present it will re-run
    the function in de-optimized op-by-op mode, effectively removing one level of
    `@jit` at a time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†å¯¼è‡´NaNäº§ç”Ÿæ—¶ç«‹å³ç»ˆæ­¢è®¡ç®—ã€‚æ‰“å¼€æ­¤é€‰é¡¹ä¼šåœ¨ç”±XLAäº§ç”Ÿçš„æ¯ä¸ªæµ®ç‚¹ç±»å‹å€¼ä¸Šæ·»åŠ NaNæ£€æŸ¥ã€‚è¿™æ„å‘³ç€å¯¹äºä¸åœ¨`@jit`ä¸‹çš„æ¯ä¸ªåŸºå…ƒæ“ä½œï¼Œå€¼å°†è¢«æ‹‰å›ä¸»æœºå¹¶ä½œä¸ºndarraysè¿›è¡Œæ£€æŸ¥ã€‚å¯¹äºåœ¨`@jit`ä¸‹çš„ä»£ç ï¼Œå°†æ£€æŸ¥æ¯ä¸ª`@jit`å‡½æ•°çš„è¾“å‡ºï¼Œå¦‚æœå­˜åœ¨NaNï¼Œåˆ™å°†ä»¥é€ä¸ªæ“ä½œçš„å»ä¼˜åŒ–æ¨¡å¼é‡æ–°è¿è¡Œå‡½æ•°ï¼Œæœ‰æ•ˆåœ°ä¸€æ¬¡ç§»é™¤ä¸€ä¸ª`@jit`çº§åˆ«ã€‚
- en: There could be tricky situations that arise, like nans that only occur under
    a `@jit` but donâ€™t get produced in de-optimized mode. In that case youâ€™ll see
    a warning message print out but your code will continue to execute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: å¯èƒ½ä¼šå‡ºç°æ£˜æ‰‹çš„æƒ…å†µï¼Œæ¯”å¦‚åªåœ¨`@jit`ä¸‹å‡ºç°çš„NaNï¼Œä½†åœ¨å»ä¼˜åŒ–æ¨¡å¼ä¸‹å´ä¸ä¼šäº§ç”Ÿã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ ä¼šçœ‹åˆ°è­¦å‘Šæ¶ˆæ¯æ‰“å°å‡ºæ¥ï¼Œä½†ä½ çš„ä»£ç å°†ç»§ç»­æ‰§è¡Œã€‚
- en: 'If the nans are being produced in the backward pass of a gradient evaluation,
    when an exception is raised several frames up in the stack trace you will be in
    the backward_pass function, which is essentially a simple jaxpr interpreter that
    walks the sequence of primitive operations in reverse. In the example below, we
    started an ipython repl with the command line `env JAX_DEBUG_NANS=True ipython`,
    then ran this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨æ¢¯åº¦è¯„ä¼°çš„åå‘ä¼ é€’ä¸­äº§ç”ŸNaNsï¼Œå½“åœ¨å †æ ˆè·Ÿè¸ªä¸­å¼•å‘å¼‚å¸¸æ—¶ï¼Œæ‚¨å°†ä½äºbackward_passå‡½æ•°ä¸­ï¼Œè¿™æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç®€å•çš„jaxprè§£é‡Šå™¨ï¼Œä»¥åå‘éå†åŸå§‹æ“ä½œåºåˆ—ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‘½ä»¤è¡Œ`env
    JAX_DEBUG_NANS=True ipython`å¯åŠ¨äº†ä¸€ä¸ªipython replï¼Œç„¶åè¿è¡Œäº†ä»¥ä¸‹å‘½ä»¤ï¼š
- en: '[PRE92]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The nan generated was caught. By running `%debug`, we can get a post-mortem
    debugger. This also works with functions under `@jit`, as the example below shows.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: æ•è·åˆ°ç”Ÿæˆçš„NaNã€‚é€šè¿‡è¿è¡Œ`%debug`ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—åæœŸè°ƒè¯•å™¨ã€‚æ­£å¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºï¼Œè¿™ä¹Ÿé€‚ç”¨äºåœ¨`@jit`ä¸‹çš„å‡½æ•°ã€‚
- en: '[PRE93]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When this code sees a nan in the output of an `@jit` function, it calls into
    the de-optimized code, so we still get a clear stack trace. And we can run a post-mortem
    debugger with `%debug` to inspect all the values to figure out the error.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ­¤ä»£ç åœ¨ `@jit` å‡½æ•°çš„è¾“å‡ºä¸­çœ‹åˆ° NaN æ—¶ï¼Œå®ƒè°ƒç”¨å»ä¼˜åŒ–çš„ä»£ç ï¼Œå› æ­¤æˆ‘ä»¬ä»ç„¶å¯ä»¥è·å¾—æ¸…æ™°çš„å †æ ˆè·Ÿè¸ªã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `%debug` è¿è¡Œäº‹åè°ƒè¯•å™¨æ¥æ£€æŸ¥æ‰€æœ‰å€¼ï¼Œä»¥æ‰¾å‡ºé”™è¯¯ã€‚
- en: âš ï¸ You shouldnâ€™t have the NaN-checker on if youâ€™re not debugging, as it can
    introduce lots of device-host round-trips and performance regressions!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸ å¦‚æœæ‚¨ä¸æ˜¯åœ¨è°ƒè¯•ï¼Œå°±ä¸åº”è¯¥å¼€å¯ NaN æ£€æŸ¥å™¨ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šå¯¼è‡´å¤§é‡è®¾å¤‡ä¸»æœºå¾€è¿”å’Œæ€§èƒ½å›å½’ï¼
- en: âš ï¸ The NaN-checker doesnâ€™t work with `pmap`. To debug nans in `pmap` code, one
    thing to try is replacing `pmap` with `vmap`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸ NaN æ£€æŸ¥å™¨åœ¨ `pmap` ä¸­ä¸èµ·ä½œç”¨ã€‚è¦è°ƒè¯• `pmap` ä»£ç ä¸­çš„ NaNï¼Œå¯ä»¥å°è¯•ç”¨ `vmap` æ›¿æ¢ `pmap`ã€‚
- en: ğŸ”ª Double (64bit) precision
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª åŒç²¾åº¦ï¼ˆ64ä½ï¼‰
- en: At the moment, JAX by default enforces single-precision numbers to mitigate
    the Numpy APIâ€™s tendency to aggressively promote operands to `double`. This is
    the desired behavior for many machine-learning applications, but it may catch
    you by surprise!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼ŒJAX å¼ºåˆ¶ä½¿ç”¨å•ç²¾åº¦æ•°å­—ï¼Œä»¥å‡å°‘ Numpy API å°†æ“ä½œæ•°è¿‡åº¦æå‡ä¸º `double` çš„å€¾å‘ã€‚è¿™æ˜¯è®¸å¤šæœºå™¨å­¦ä¹ åº”ç”¨ç¨‹åºçš„æœŸæœ›è¡Œä¸ºï¼Œä½†å¯èƒ½ä¼šè®©æ‚¨æ„Ÿåˆ°æ„å¤–ï¼
- en: '[PRE94]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: To use double-precision numbers, you need to set the `jax_enable_x64` configuration
    variable **at startup**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ä½¿ç”¨åŒç²¾åº¦æ•°ï¼Œæ‚¨éœ€è¦åœ¨å¯åŠ¨æ—¶è®¾ç½® `jax_enable_x64` é…ç½®å˜é‡**ã€‚
- en: 'There are a few ways to do this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å‡ ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š
- en: You can enable 64-bit mode by setting the environment variable `JAX_ENABLE_X64=True`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡ `JAX_ENABLE_X64=True` æ¥å¯ç”¨ 64 ä½æ¨¡å¼ã€‚
- en: 'You can manually set the `jax_enable_x64` configuration flag at startup:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥åœ¨å¯åŠ¨æ—¶æ‰‹åŠ¨è®¾ç½® `jax_enable_x64` é…ç½®æ ‡å¿—ï¼š
- en: '[PRE97]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can parse command-line flags with `absl.app.run(main)`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥ä½¿ç”¨ `absl.app.run(main)` è§£æå‘½ä»¤è¡Œæ ‡å¿—
- en: '[PRE98]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you want JAX to run absl parsing for you, i.e. you donâ€™t want to do `absl.app.run(main)`,
    you can instead use
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨å¸Œæœ› JAX ä¸ºæ‚¨è¿è¡Œ absl è§£æï¼Œå³æ‚¨ä¸æƒ³æ‰§è¡Œ `absl.app.run(main)`ï¼Œæ‚¨å¯ä»¥æ”¹ç”¨
- en: '[PRE99]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Note that #2-#4 work for *any* of JAXâ€™s configuration options.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œ#2-#4 é€‚ç”¨äº*ä»»ä½•* JAX çš„é…ç½®é€‰é¡¹ã€‚
- en: 'We can then confirm that `x64` mode is enabled:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¡®è®¤å·²å¯ç”¨ `x64` æ¨¡å¼ï¼š
- en: '[PRE100]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Caveats
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ³¨æ„äº‹é¡¹
- en: âš ï¸ XLA doesnâ€™t support 64-bit convolutions on all backends!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸ XLA ä¸æ”¯æŒæ‰€æœ‰åç«¯çš„ 64 ä½å·ç§¯ï¼
- en: ğŸ”ª Miscellaneous Divergences from NumPy
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ğŸ”ª NumPy ä¸­çš„å„ç§åˆ†æ­§
- en: While `jax.numpy` makes every attempt to replicate the behavior of numpyâ€™s API,
    there do exist corner cases where the behaviors differ. Many such cases are discussed
    in detail in the sections above; here we list several other known places where
    the APIs diverge.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ `jax.numpy` å°½åŠ›å¤åˆ¶ numpy API çš„è¡Œä¸ºï¼Œä½†ç¡®å®å­˜åœ¨ä¸€äº›è¾¹ç•Œæƒ…å†µï¼Œå…¶è¡Œä¸ºæœ‰æ‰€ä¸åŒã€‚è®¸å¤šè¿™æ ·çš„æƒ…å†µåœ¨å‰é¢çš„éƒ¨åˆ†ä¸­æœ‰è¯¦ç»†è®¨è®ºï¼›è¿™é‡Œæˆ‘ä»¬åˆ—å‡ºäº†å‡ ä¸ªå·²çŸ¥çš„å…¶ä»–
    API åˆ†æ­§å¤„ã€‚
- en: For binary operations, JAXâ€™s type promotion rules differ somewhat from those
    used by NumPy. See [Type Promotion Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html)
    for more details.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºäºŒè¿›åˆ¶æ“ä½œï¼ŒJAX çš„ç±»å‹æå‡è§„åˆ™ä¸ NumPy ç•¥æœ‰ä¸åŒã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[ç±»å‹æå‡è¯­ä¹‰](https://jax.readthedocs.io/en/latest/type_promotion.html)ã€‚
- en: When performing unsafe type casts (i.e. casts in which the target dtype cannot
    represent the input value), JAXâ€™s behavior may be backend dependent, and in general
    may diverge from NumPyâ€™s behavior. Numpy allows control over the result in these
    scenarios via the `casting` argument (see [`np.ndarray.astype`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html));
    JAX does not provide any such configuration, instead directly inheriting the behavior
    of [XLA:ConvertElementType](https://www.tensorflow.org/xla/operation_semantics#convertelementtype).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æ‰§è¡Œä¸å®‰å…¨ç±»å‹è½¬æ¢ï¼ˆå³ç›®æ ‡ dtype ä¸èƒ½è¡¨ç¤ºè¾“å…¥å€¼çš„è½¬æ¢ï¼‰æ—¶ï¼ŒJAX çš„è¡Œä¸ºå¯èƒ½ä¾èµ–äºåç«¯ï¼Œå¹¶ä¸”é€šå¸¸å¯èƒ½ä¸ NumPy çš„è¡Œä¸ºä¸åŒã€‚NumPy å…è®¸é€šè¿‡
    `casting` å‚æ•°ï¼ˆå‚è§[`np.ndarray.astype`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html)ï¼‰æ§åˆ¶è¿™äº›æƒ…å†µä¸‹çš„ç»“æœï¼›JAX
    ä¸æä¾›ä»»ä½•æ­¤ç±»é…ç½®ï¼Œè€Œæ˜¯ç›´æ¥ç»§æ‰¿[XLA:ConvertElementType](https://www.tensorflow.org/xla/operation_semantics#convertelementtype)çš„è¡Œä¸ºã€‚
- en: 'Here is an example of an unsafe cast with differing results between NumPy and
    JAX:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œæ˜¾ç¤ºäº†åœ¨ NumPy å’Œ JAX ä¹‹é—´å­˜åœ¨ä¸åŒç»“æœçš„ä¸å®‰å…¨è½¬æ¢ï¼š
- en: '[PRE103]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This sort of mismatch would typically arise when casting extreme values from
    floating to integer types or vice versa.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™ç§ä¸åŒ¹é…é€šå¸¸åœ¨å°†æµ®ç‚¹å€¼è½¬æ¢ä¸ºæ•´æ•°ç±»å‹æˆ–åä¹‹æ—¶å‡ºç°æç«¯æƒ…å†µã€‚
- en: Fin.
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“æŸã€‚
- en: If somethingâ€™s not covered here that has caused you weeping and gnashing of
    teeth, please let us know and weâ€™ll extend these introductory *advisos*!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™é‡Œæ²¡æœ‰æ¶‰åŠåˆ°æ‚¨æ›¾ç»å› ä¹‹è€Œå“­æ³£å’Œå’¬ç‰™åˆ‡é½¿çš„é—®é¢˜ï¼Œè¯·å‘ŠçŸ¥æˆ‘ä»¬ï¼Œæˆ‘ä»¬å°†æ‰©å±•è¿™äº›ä»‹ç»æ€§*å»ºè®®*ï¼
