- en: ORM Quick Start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM 快速入门
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/quickstart.html](https://docs.sqlalchemy.org/en/20/orm/quickstart.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/quickstart.html](https://docs.sqlalchemy.org/en/20/orm/quickstart.html)
- en: For new users who want to quickly see what basic ORM use looks like, here’s
    an abbreviated form of the mappings and examples used in the [SQLAlchemy Unified
    Tutorial](../tutorial/index.html#unified-tutorial). The code here is fully runnable
    from a clean command line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要快速了解基本 ORM 使用情况的新用户，这里提供了[SQLAlchemy 统一教程](../tutorial/index.html#unified-tutorial)中使用的映射和示例的缩写形式。这里的代码可以从干净的命令行完全运行。
- en: As the descriptions in this section are intentionally **very short**, please
    proceed to the full [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)
    for a much more in-depth description of each of the concepts being illustrated
    here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节中的描述故意**非常简短**，请继续阅读完整的[SQLAlchemy 统一教程](../tutorial/index.html#unified-tutorial)以获得对这里所说明的每个概念更深入的描述。
- en: 'Changed in version 2.0: The ORM Quickstart is updated for the latest [**PEP
    484**](https://peps.python.org/pep-0484/)-aware features using new constructs
    including [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    See the section [ORM Declarative Models](../changelog/whatsnew_20.html#whatsnew-20-orm-declarative-typing)
    for migration information.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.0版本开始更改：ORM 快速入门已更新为最新的[**PEP 484**](https://peps.python.org/pep-0484/)兼容功能，使用包括[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")在内的新构造。有关迁移信息，请参见[ORM 声明模型](../changelog/whatsnew_20.html#whatsnew-20-orm-declarative-typing)部分。
- en: Declare Models
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明模型
- en: 'Here, we define module-level constructs that will form the structures which
    we will be querying from the database. This structure, known as a [Declarative
    Mapping](mapping_styles.html#orm-declarative-mapping), defines at once both a
    Python object model, as well as [database metadata](../glossary.html#term-database-metadata)
    that describes real SQL tables that exist, or will exist, in a particular database:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义模块级别的构造，这些构造将形成我们将从数据库查询的结构。这个结构被称为[声明式映射](mapping_styles.html#orm-declarative-mapping)，它一次定义了Python对象模型，以及描述存在或将存在于特定数据库中的真实SQL表的[数据库元数据](../glossary.html#term-database-metadata)：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mapping starts with a base class, which above is called `Base`, and is created
    by making a simple subclass against the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 映射始于一个基类，这个基类上面称为`Base`，并且是通过对[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类进行简单子类化来创建的。
- en: Individual mapped classes are then created by making subclasses of `Base`. A
    mapped class typically refers to a single particular database table, the name
    of which is indicated by using the `__tablename__` class-level attribute.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过对`Base`进行子类化来创建单独的映射类。一个映射类通常指的是单个特定的数据库表，其名称通过使用`__tablename__`类级别属性指示。
- en: Next, columns that are part of the table are declared, by adding attributes
    that include a special typing annotation called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"). The name of each attribute corresponds to the column
    that is to be part of the database table. The datatype of each column is taken
    first from the Python datatype that’s associated with each [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation; `int` for `INTEGER`, `str` for `VARCHAR`,
    etc. Nullability derives from whether or not the `Optional[]` type modifier is
    used. More specific typing information may be indicated using SQLAlchemy type
    objects in the right side [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directive, such as the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") datatype used above in the `User.name` column. The
    association between Python types and SQL types can be customized using the [type
    annotation map](declarative_tables.html#orm-declarative-mapped-column-type-map).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加包含称为[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的特殊类型注释的属性来声明表的一部分列。每个属性的名称对应于要成为数据库表的一部分的列。每个列的数据类型首先从与每个[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释相关联的Python数据类型中获取；`int`用于`INTEGER`，`str`用于`VARCHAR`，等等。空值性取决于是否使用了`Optional[]`类型修饰符。可以使用右侧[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令中的SQLAlchemy类型对象指示更具体的类型信息，例如上面在`User.name`列中使用的[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")数据类型。可以使用[类型注释映射](declarative_tables.html#orm-declarative-mapped-column-type-map)来自定义Python类型和SQL类型之间的关联。
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive is used for all column-based attributes that require more specific customization.
    Besides typing information, this directive accepts a wide variety of arguments
    that indicate specific details about a database column, including server defaults
    and constraint information, such as membership within the primary key and foreign
    keys. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive accepts a superset of arguments that are accepted by the SQLAlchemy
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    class, which is used by SQLAlchemy Core to represent database columns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")指令用于所有需要更具体定制的基于列的属性。除了类型信息外，此指令还接受各种参数，指示有关数据库列的特定详细信息，包括服务器默认值和约束信息，例如在主键和外键中的成员资格。[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令接受的参数是SQLAlchemy [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")类所接受的参数的一个超集，该类由SQLAlchemy核心用于表示数据库列。'
- en: All ORM mapped classes require at least one column be declared as part of the
    primary key, typically by using the [`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") parameter on those [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects that should be part of the key. In the
    above example, the `User.id` and `Address.id` columns are marked as primary key.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有ORM映射类都要求至少声明一个列作为主键的一部分，通常是通过在那些应该成为主键的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")对象上使用[`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column")参数来实现的。在上面的示例中，`User.id`和`Address.id`列被标记为主键。
- en: Taken together, the combination of a string table name as well as a list of
    column declarations is known in SQLAlchemy as [table metadata](../glossary.html#term-table-metadata).
    Setting up table metadata using both Core and ORM approaches is introduced in
    the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial) at
    [Working with Database Metadata](../tutorial/metadata.html#tutorial-working-with-metadata).
    The above mapping is an example of what’s known as [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑，字符串表名称以及列声明列表的组合在SQLAlchemy中被称为[table metadata](../glossary.html#term-table-metadata)。在[SQLAlchemy统一教程](../tutorial/index.html#unified-tutorial)的[处理数据库元数据](../tutorial/metadata.html#tutorial-working-with-metadata)中介绍了如何使用核心和ORM方法设置表元数据。上述映射是所谓的[注释声明表](declarative_tables.html#orm-declarative-mapped-column)配置的示例。
- en: Other variants of [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    are available, most commonly the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct indicated above. In contrast to the column-based
    attributes, [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") denotes a linkage between two ORM classes. In the
    above example, `User.addresses` links `User` to `Address`, and `Address.user`
    links `Address` to `User`. The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is introduced in the [SQLAlchemy Unified
    Tutorial](../tutorial/index.html#unified-tutorial) at [Working with ORM Related
    Objects](../tutorial/orm_related_objects.html#tutorial-orm-related-objects).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 的其他变体可用，最常见的是上面指示的
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    构造。与基于列的属性相比，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 表示两个 ORM 类之间的关联。在上面的示例中，`User.addresses` 将 `User`
    和 `Address` 连接起来，`Address.user` 将 `Address` 和 `User` 连接起来。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造介绍于 [SQLAlchemy 统一教程](../tutorial/index.html#unified-tutorial)
    的 [处理 ORM 相关对象](../tutorial/orm_related_objects.html#tutorial-orm-related-objects)
    部分。'
- en: Finally, the above example classes include a `__repr__()` method, which is not
    required but is useful for debugging. Mapped classes can be created with methods
    such as `__repr__()` generated automatically, using dataclasses. More on dataclass
    mapping at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，上面的示例类包括一个 `__repr__()` 方法，这并非必需，但对调试很有用。映射类可以使用诸如 `__repr__()` 之类的方法自动生成，使用数据类。有关数据类映射的更多信息，请参阅
    [声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)。
- en: Create an Engine
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个引擎
- en: 'The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is a **factory** that can create new database connections for us, which also holds
    onto connections inside of a [Connection Pool](../core/pooling.html) for fast
    reuse. For learning purposes, we normally use a [SQLite](../dialects/sqlite.html)
    memory-only database for convenience:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    是一个**工厂**，可以为我们创建新的数据库连接，还在 [连接池](../core/pooling.html) 中保存连接以便快速重用。出于学习目的，我们通常使用一个
    [SQLite](../dialects/sqlite.html) 内存数据库方便起见：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `echo=True` parameter indicates that SQL emitted by connections will be
    logged to standard out.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo=True` 参数表示连接发出的 SQL 将被记录到标准输出。'
- en: A full intro to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") starts at [Establishing Connectivity - the Engine](../tutorial/engine.html#tutorial-engine).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    的完整介绍从 [建立连接 - 引擎](../tutorial/engine.html#tutorial-engine) 开始。'
- en: Emit CREATE TABLE DDL
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出 CREATE TABLE DDL
- en: 'Using our table metadata and our engine, we can generate our schema at once
    in our target SQLite database, using a method called [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all"):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们的表格元数据和引擎，我们可以一次性在目标 SQLite 数据库中生成我们的模式，使用的方法是 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A lot just happened from that bit of Python code we wrote. For a complete overview
    of what’s going on on with Table metadata, proceed in the Tutorial at [Working
    with Database Metadata](../tutorial/metadata.html#tutorial-working-with-metadata).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写的那小段 Python 代码发生了很多事情。要完整了解表格元数据的情况，请在教程中继续阅读 [处理数据库元数据](../tutorial/metadata.html#tutorial-working-with-metadata)
    部分。
- en: Create Objects and Persist
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象并持久化
- en: 'We are now ready to insert data in the database. We accomplish this by creating
    instances of `User` and `Address` classes, which have an `__init__()` method already
    as established automatically by the declarative mapping process. We then pass
    them to the database using an object called a [Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session),
    which makes use of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to interact with the database. The [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") method is used here to add multiple objects
    at once, and the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be used to [flush](session_basics.html#session-flushing)
    any pending changes to the database and then [commit](session_basics.html#session-committing)
    the current database transaction, which is always in progress whenever the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好向数据库插入数据了。我们通过创建`User`和`Address`类的实例来实现这一目标，这些类已经通过声明性映射过程自动建立了`__init__()`方法。然后，我们使用一个名为[Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)的对象将它们传递给数据库，该对象利用[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")与数据库进行交互。这里使用了[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")方法一次添加多个对象，并且[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法将被用来[提交](session_basics.html#session-committing)数据库中的任何挂起更改，然后提交当前的数据库事务，无论何时使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，该事务始终处于进行中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It’s recommended that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be used in context manager style as above, that is,
    using the Python `with:` statement. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object represents active database resources so it’s
    good to make sure it’s closed out when a series of operations are completed. In
    the next section, we’ll keep a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") opened just for illustration purposes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 建议以上述上下文管理器风格使用[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，即使用
    Python 的 `with:` 语句。[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象代表了活动的数据库资源，因此确保在完成一系列操作时将其关闭是很好的。在下一节中，我们将保持一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")仅用于说明目的。
- en: Basics on creating a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    are at [Executing with an ORM Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)
    and more at [Basics of Using a Session](session_basics.html#id1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的基础知识请参见[使用
    ORM Session 执行](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)，更多内容请查看[使用
    Session 的基础知识](session_basics.html#id1)。
- en: Then, some varieties of basic persistence operations are introduced at [Inserting
    Rows using the ORM Unit of Work pattern](../tutorial/orm_data_manipulation.html#tutorial-inserting-orm).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在[使用 ORM 工作单元模式插入行](../tutorial/orm_data_manipulation.html#tutorial-inserting-orm)中介绍了一些基本持久性操作的变体。
- en: Simple SELECT
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 SELECT
- en: 'With some rows in the database, here’s the simplest form of emitting a SELECT
    statement to load some objects. To create SELECT statements, we use the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function to create a new [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which we then invoke using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The method that is often useful when querying for ORM
    objects is the [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method, which will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that will iterate through the ORM objects
    we’ve selected:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中有一些行之后，这是发出 SELECT 语句以加载一些对象的最简单形式。要创建 SELECT 语句，我们使用 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 函数创建一个新的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，然后使用一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 调用它。在查询 ORM 对象时经常有用的方法是 [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 方法，它将返回一个 [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 对象，该对象将遍历我们已选择的 ORM 对象：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above query also made use of the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method to add WHERE criteria, and also
    used the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method that’s part of all SQLAlchemy
    column-like constructs to use the SQL IN operator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询还使用了 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 方法添加 WHERE 条件，并且还使用了 SQLAlchemy 类似列的构造中的
    [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 方法来使用 SQL IN 操作符。
- en: More detail on how to select objects and individual columns is at [Selecting
    ORM Entities and Columns](../tutorial/data_select.html#tutorial-selecting-orm-entities).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何选择对象和单独列的更多细节请参见[选择 ORM 实体和列](../tutorial/data_select.html#tutorial-selecting-orm-entities)。
- en: SELECT with JOIN
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JOIN 进行 SELECT
- en: 'It’s very common to query amongst multiple tables at once, and in SQL the JOIN
    keyword is the primary way this happens. The [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct creates joins using the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次性查询多个表格是非常常见的，在 SQL 中，JOIN 关键字是这种情况的主要方式。[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造使用 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法创建连接：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The above query illustrates multiple WHERE criteria which are automatically
    chained together using AND, as well as how to use SQLAlchemy column-like objects
    to create “equality” comparisons, which uses the overridden Python method [`ColumnOperators.__eq__()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") to produce a SQL criteria
    object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询演示了多个 WHERE 条件的使用，这些条件会自动使用 AND 进行链接，以及如何使用 SQLAlchemy 类似列对象创建“相等性”比较，这使用了重写的
    Python 方法 [`ColumnOperators.__eq__()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") 来生成 SQL 条件对象。
- en: Some more background on the concepts above are at [The WHERE clause](../tutorial/data_select.html#tutorial-select-where-clause)
    and [Explicit FROM clauses and JOINs](../tutorial/data_select.html#tutorial-select-join).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关上述概念的更多背景信息在[WHERE子句](../tutorial/data_select.html#tutorial-select-where-clause)和[明确的FROM子句和JOIN](../tutorial/data_select.html#tutorial-select-join)处。
- en: Make Changes
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行更改
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object, in conjunction with our ORM-mapped classes `User` and `Address`, automatically
    track changes to the objects as they are made, which result in SQL statements
    that will be emitted the next time the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") flushes. Below, we change one email address associated
    with “sandy”, and also add a new email address to “patrick”, after emitting a
    SELECT to retrieve the row for “patrick”:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象与我们的ORM映射类`User`和`Address`结合使用，自动跟踪对对象的更改，这些更改将在下次[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") flush时生成SQL语句。 在下面，我们更改了与“sandy”关联的一个电子邮件地址，并在发出SELECT以检索“patrick”的行后向“patrick”添加了一个新的电子邮件地址：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice when we accessed `patrick.addresses`, a SELECT was emitted. This is called
    a [lazy load](../glossary.html#term-lazy-load). Background on different ways to
    access related items using more or less SQL is introduced at [Loader Strategies](../tutorial/orm_related_objects.html#tutorial-orm-loader-strategies).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们访问`patrick.addresses`时，会发出一个SELECT。 这称为[延迟加载](../glossary.html#term-lazy-load)。
    关于使用更多或更少SQL访问相关项目的不同方式的背景介绍在[加载策略](../tutorial/orm_related_objects.html#tutorial-orm-loader-strategies)中引入。
- en: A detailed walkthrough on ORM data manipulation starts at [Data Manipulation
    with the ORM](../tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ORM数据操作的详细说明始于[使用ORM进行数据操作](../tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation)。
- en: Some Deletes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些删除
- en: All things must come to an end, as is the case for some of our database rows
    - here’s a quick demonstration of two different forms of deletion, both of which
    are important based on the specific use case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都必须有个了结，就像我们的一些数据库行一样 - 这里是两种不同形式的删除的快速演示，这两种删除根据特定用例的不同而重要。
- en: 'First we will remove one of the `Address` objects from the “sandy” user. When
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next flushes, this will result in the row being deleted. This behavior is something
    that we configured in our mapping called the [delete cascade](cascades.html#cascade-delete).
    We can get a handle to the `sandy` object by primary key using [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get"), then work with the object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从“sandy”用户中删除一个`Address`对象。 当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")下次flush时，这将导致该行被删除。 此行为是我们在映射中配置的称为[删除级联](cascades.html#cascade-delete)的东西。
    我们可以使用[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")按主键获取`sandy`对象的句柄，然后使用该对象：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last SELECT above was the [lazy load](../glossary.html#term-lazy-load) operation
    proceeding so that the `sandy.addresses` collection could be loaded, so that we
    could remove the `sandy_address` member. There are other ways to go about this
    series of operations that won’t emit as much SQL.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后一个SELECT是[延迟加载](../glossary.html#term-lazy-load)操作进行，以便加载`sandy.addresses`集合，以便我们可以删除`sandy_address`成员。有其他方法可以完成这一系列操作，这些方法不会生成太多的SQL。
- en: 'We can choose to emit the DELETE SQL for what’s set to be changed so far, without
    committing the transaction, using the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择发出DELETE SQL，以删除到目前为止已更改的内容，而不提交事务，使用[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will delete the “patrick” user entirely. For a top-level delete of
    an object by itself, we use the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method; this method doesn’t actually perform
    the deletion, but sets up the object to be deleted on the next flush. The operation
    will also [cascade](../glossary.html#term-cascade) to related objects based on
    the cascade options that we configured, in this case, onto the related `Address`
    objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完全删除“patrick”用户。 对于对象本身的顶级删除，我们使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法； 此方法实际上不执行删除，而是设置对象将在下次flush时被删除。 该操作还将根据我们配置的级联选项级联到相关对象，本例中为相关的`Address`对象：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method in this particular case emitted two SELECT statements, even though it didn’t
    emit a DELETE, which might seem surprising. This is because when the method went
    to inspect the object, it turns out the `patrick` object was [expired](../glossary.html#term-expired),
    which happened when we last called upon [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), and the SQL emitted was to re-load the rows
    from the new transaction. This expiration is optional, and in normal use we will
    often be turning it off for situations where it doesn’t apply well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法发出了两个SELECT语句，即使它没有发出DELETE，这可能看起来令人惊讶。这是因为当该方法去检查对象时，发现`patrick`对象已经[过期](../glossary.html#term-expired)，这是在我们上次调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时发生的，发出的SQL是为了重新从新事务加载行。这种过期是可选的，并且在正常使用中，我们经常会在不适用的情况下关闭它。
- en: 'To illustrate the rows being deleted, here’s the commit:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明被删除的行，这里是提交：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Tutorial discusses ORM deletion at [Deleting ORM Objects using the Unit
    of Work pattern](../tutorial/orm_data_manipulation.html#tutorial-orm-deleting).
    Background on object expiration is at [Expiring / Refreshing](session_basics.html#session-expiring);
    cascades are discussed in depth at [Cascades](cascades.html#unitofwork-cascades).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 教程讨论了ORM删除，详见[使用工作单元模式删除ORM对象](../tutorial/orm_data_manipulation.html#tutorial-orm-deleting)。对象过期的背景信息在[过期/刷新](session_basics.html#session-expiring)；级联在[级联](cascades.html#unitofwork-cascades)中进行了深入讨论。
- en: Learn the above concepts in depth
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入学习上述概念
- en: For a new user, the above sections were likely a whirlwind tour. There’s a lot
    of important concepts in each step above that weren’t covered. With a quick overview
    of what things look like, it’s recommended to work through the [SQLAlchemy Unified
    Tutorial](../tutorial/index.html#unified-tutorial) to gain a solid working knowledge
    of what’s really going on above. Good luck!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新用户来说，上面的部分可能是一个快速浏览。上面的每一步中都有许多重要的概念没有涵盖到。通过快速了解事物的外观，建议通过[SQLAlchemy 统一教程](../tutorial/index.html#unified-tutorial)逐步学习，以获得对上面所发生的事物的坚实的工作知识。祝你好运！
- en: Declare Models
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明模型
- en: 'Here, we define module-level constructs that will form the structures which
    we will be querying from the database. This structure, known as a [Declarative
    Mapping](mapping_styles.html#orm-declarative-mapping), defines at once both a
    Python object model, as well as [database metadata](../glossary.html#term-database-metadata)
    that describes real SQL tables that exist, or will exist, in a particular database:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了将构成我们从数据库查询的模块级构造。这个结构被称为[声明性映射](mapping_styles.html#orm-declarative-mapping)，它一次定义了Python对象模型以及描述真实SQL表的[数据库元数据](../glossary.html#term-database-metadata)，这些表存在或将存在于特定数据库中：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The mapping starts with a base class, which above is called `Base`, and is created
    by making a simple subclass against the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 映射始于一个基类，上面称为`Base`，通过对[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类进行简单的子类化来创建。
- en: Individual mapped classes are then created by making subclasses of `Base`. A
    mapped class typically refers to a single particular database table, the name
    of which is indicated by using the `__tablename__` class-level attribute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`Base`进行子类化，然后创建个体映射类。一个映射类通常指的是一个特定的数据库表，其名称是通过使用`__tablename__`类级属性指示的。
- en: Next, columns that are part of the table are declared, by adding attributes
    that include a special typing annotation called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"). The name of each attribute corresponds to the column
    that is to be part of the database table. The datatype of each column is taken
    first from the Python datatype that’s associated with each [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation; `int` for `INTEGER`, `str` for `VARCHAR`,
    etc. Nullability derives from whether or not the `Optional[]` type modifier is
    used. More specific typing information may be indicated using SQLAlchemy type
    objects in the right side [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directive, such as the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") datatype used above in the `User.name` column. The
    association between Python types and SQL types can be customized using the [type
    annotation map](declarative_tables.html#orm-declarative-mapped-column-type-map).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明表中的列，通过添加包含一个特殊的类型注释称为[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的属性来实现。每个属性的名称对应于要成为数据库表的列。每个列的数据类型首先取自与每个[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释相关联的 Python 数据类型；对于 `INTEGER` 使用 `int`，对于 `VARCHAR`
    使用 `str` 等。可选性取决于是否使用了 `Optional[]` 类型修饰符。可以使用右侧的 SQLAlchemy 类型对象指示更具体的类型信息，例如上面在
    `User.name` 列中使用的 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 数据类型。Python 类型和 SQL 类型之间的关联可以使用[type annotation map](declarative_tables.html#orm-declarative-mapped-column-type-map)进行定制。
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive is used for all column-based attributes that require more specific customization.
    Besides typing information, this directive accepts a wide variety of arguments
    that indicate specific details about a database column, including server defaults
    and constraint information, such as membership within the primary key and foreign
    keys. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive accepts a superset of arguments that are accepted by the SQLAlchemy
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    class, which is used by SQLAlchemy Core to represent database columns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    指令用于所有需要更具体定制的基于列的属性。除了类型信息外，该指令还接受各种参数，指示有关数据库列的特定细节，包括服务器默认值和约束信息，例如主键和外键的成员资格。[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 指令接受了 SQLAlchemy [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 类接受的参数的超集，该类由 SQLAlchemy Core 用于表示数据库列。'
- en: All ORM mapped classes require at least one column be declared as part of the
    primary key, typically by using the [`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") parameter on those [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects that should be part of the key. In the
    above example, the `User.id` and `Address.id` columns are marked as primary key.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 ORM 映射类都需要至少声明一个列作为主键的一部分，通常是通过在应该成为键的那些[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")对象上使用[`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column")参数来实现的。在上面的示例中，`User.id` 和 `Address.id` 列被标记为主键。
- en: Taken together, the combination of a string table name as well as a list of
    column declarations is known in SQLAlchemy as [table metadata](../glossary.html#term-table-metadata).
    Setting up table metadata using both Core and ORM approaches is introduced in
    the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial) at
    [Working with Database Metadata](../tutorial/metadata.html#tutorial-working-with-metadata).
    The above mapping is an example of what’s known as [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来，SQLAlchemy 中一个字符串表名和列声明列表的组合被称为[table metadata](../glossary.html#term-table-metadata)。在[SQLAlchemy
    统一教程](../tutorial/index.html#unified-tutorial)中介绍了使用 Core 和 ORM 方法设置表元数据的方法，在[Working
    with Database Metadata](../tutorial/metadata.html#tutorial-working-with-metadata)章节中。上述映射是[Annotated
    Declarative Table](declarative_tables.html#orm-declarative-mapped-column)配置的示例。
- en: Other variants of [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    are available, most commonly the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct indicated above. In contrast to the column-based
    attributes, [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") denotes a linkage between two ORM classes. In the
    above example, `User.addresses` links `User` to `Address`, and `Address.user`
    links `Address` to `User`. The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is introduced in the [SQLAlchemy Unified
    Tutorial](../tutorial/index.html#unified-tutorial) at [Working with ORM Related
    Objects](../tutorial/orm_related_objects.html#tutorial-orm-related-objects).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的变体可用，最常见的是上面指示的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造。与基于列的属性相反，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")表示两个 ORM 类之间的链接。在上面的示例中，`User.addresses` 将`User`链接到`Address`，`Address.user`
    将`Address`链接到`User`。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造在[SQLAlchemy 统一教程](../tutorial/index.html#unified-tutorial)中的[使用
    ORM 相关对象](../tutorial/orm_related_objects.html#tutorial-orm-related-objects)中进行介绍。
- en: Finally, the above example classes include a `__repr__()` method, which is not
    required but is useful for debugging. Mapped classes can be created with methods
    such as `__repr__()` generated automatically, using dataclasses. More on dataclass
    mapping at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，上面的示例类包括一个 `__repr__()` 方法，虽然不是必需的，但对于调试很有用。映射类可以使用诸如 `__repr__()` 这样的方法自动生成，使用数据类。有关数据类映射的更多信息，请参阅[声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)。
- en: Create an Engine
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建引擎
- en: 'The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is a **factory** that can create new database connections for us, which also holds
    onto connections inside of a [Connection Pool](../core/pooling.html) for fast
    reuse. For learning purposes, we normally use a [SQLite](../dialects/sqlite.html)
    memory-only database for convenience:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")是一个能够为我们创建新数据库连接的**工厂**，它还将连接保留在[连接池](../core/pooling.html)中以供快速重用。出于学习目的，我们通常使用[SQLite](../dialects/sqlite.html)内存数据库以方便起见：'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `echo=True` parameter indicates that SQL emitted by connections will be
    logged to standard out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo=True` 参数表示连接发出的 SQL 将被记录到标准输出。'
- en: A full intro to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") starts at [Establishing Connectivity - the Engine](../tutorial/engine.html#tutorial-engine).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")的全面介绍始于[建立连接
    - 引擎](../tutorial/engine.html#tutorial-engine)。
- en: Emit CREATE TABLE DDL
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出 CREATE TABLE DDL
- en: 'Using our table metadata and our engine, we can generate our schema at once
    in our target SQLite database, using a method called [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all"):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的表元数据和引擎，我们可以一次性在目标 SQLite 数据库中生成我们的模式，使用一种叫做[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")的方法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A lot just happened from that bit of Python code we wrote. For a complete overview
    of what’s going on on with Table metadata, proceed in the Tutorial at [Working
    with Database Metadata](../tutorial/metadata.html#tutorial-working-with-metadata).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才我们编写的那段 Python 代码发生了很多事情。要完整了解表元数据的情况，请参阅[使用数据库元数据](../tutorial/metadata.html#tutorial-working-with-metadata)中的教程。
- en: Create Objects and Persist
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象并持久化
- en: 'We are now ready to insert data in the database. We accomplish this by creating
    instances of `User` and `Address` classes, which have an `__init__()` method already
    as established automatically by the declarative mapping process. We then pass
    them to the database using an object called a [Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session),
    which makes use of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to interact with the database. The [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") method is used here to add multiple objects
    at once, and the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be used to [flush](session_basics.html#session-flushing)
    any pending changes to the database and then [commit](session_basics.html#session-committing)
    the current database transaction, which is always in progress whenever the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将数据插入到数据库中了。我们通过创建`User`和`Address`类的实例来实现这一点，这些类已经通过声明映射过程自动创建了`__init__()`方法。然后，我们使用一个称为[Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)的对象将它们传递给数据库，该对象使用[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")与数据库进行交互。这里使用[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")方法一次添加多个对象，并且将使用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法[刷新](session_basics.html#session-flushing)数据库中的任何待处理更改，然后[提交](session_basics.html#session-committing)当前的数据库事务，该事务始终在使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时处于进行中：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It’s recommended that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be used in context manager style as above, that is,
    using the Python `with:` statement. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object represents active database resources so it’s
    good to make sure it’s closed out when a series of operations are completed. In
    the next section, we’ll keep a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") opened just for illustration purposes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 建议像上面那样使用 Python 的 `with:` 语句，即使用上下文管理器样式使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象代表着活跃的数据库资源，所以当一系列操作完成时，确保关闭它是很好的。在下一节中，我们将保持[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")处于打开状态，仅用于说明目的。
- en: Basics on creating a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    are at [Executing with an ORM Session](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)
    and more at [Basics of Using a Session](session_basics.html#id1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的基础知识请参考[使用
    ORM Session 执行](../tutorial/dbapi_transactions.html#tutorial-executing-orm-session)，更多内容请参考[使用
    Session 的基础知识](session_basics.html#id1)。
- en: Then, some varieties of basic persistence operations are introduced at [Inserting
    Rows using the ORM Unit of Work pattern](../tutorial/orm_data_manipulation.html#tutorial-inserting-orm).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，介绍了一些基本持久化操作的变体，请参阅[使用 ORM 工作单元模式插入行](../tutorial/orm_data_manipulation.html#tutorial-inserting-orm)。
- en: Simple SELECT
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 SELECT
- en: 'With some rows in the database, here’s the simplest form of emitting a SELECT
    statement to load some objects. To create SELECT statements, we use the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function to create a new [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which we then invoke using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The method that is often useful when querying for ORM
    objects is the [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method, which will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that will iterate through the ORM objects
    we’ve selected:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中有一些行时，这是发出 SELECT 语句以加载一些对象的最简单形式。要创建 SELECT 语句，我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 函数创建一个新的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，然后使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 调用它。查询 ORM 对象时经常有用的方法是[`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 方法，它将返回一个[`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 对象，该对象将迭代我们选择的 ORM 对象：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The above query also made use of the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method to add WHERE criteria, and also
    used the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method that’s part of all SQLAlchemy
    column-like constructs to use the SQL IN operator.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询还使用了[`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 方法添加 WHERE 条件，并且还使用了所有 SQLAlchemy 列对象的一部分的[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 方法来使用 SQL IN 操作符。
- en: More detail on how to select objects and individual columns is at [Selecting
    ORM Entities and Columns](../tutorial/data_select.html#tutorial-selecting-orm-entities).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如何选择对象和单独列的更多详细信息请参阅[选择 ORM 实体和列](../tutorial/data_select.html#tutorial-selecting-orm-entities)。
- en: SELECT with JOIN
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JOIN 的 SELECT
- en: 'It’s very common to query amongst multiple tables at once, and in SQL the JOIN
    keyword is the primary way this happens. The [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct creates joins using the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，一次查询多个表是非常常见的，而 JOIN 关键字是实现这一目的的主要方法。[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造函数使用[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法创建连接：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The above query illustrates multiple WHERE criteria which are automatically
    chained together using AND, as well as how to use SQLAlchemy column-like objects
    to create “equality” comparisons, which uses the overridden Python method [`ColumnOperators.__eq__()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") to produce a SQL criteria
    object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询示例说明了多个 WHERE 条件如何自动使用 AND 连接，并且展示了如何使用 SQLAlchemy 列对象创建“相等性”比较，该比较使用了重载的
    Python 方法[`ColumnOperators.__eq__()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__")来生成 SQL 条件对象。
- en: Some more background on the concepts above are at [The WHERE clause](../tutorial/data_select.html#tutorial-select-where-clause)
    and [Explicit FROM clauses and JOINs](../tutorial/data_select.html#tutorial-select-join).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以上概念的更多背景可在[WHERE 子句](../tutorial/data_select.html#tutorial-select-where-clause)和[显式
    FROM 子句和 JOIN](../tutorial/data_select.html#tutorial-select-join)处找到。
- en: Make Changes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行更改
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object, in conjunction with our ORM-mapped classes `User` and `Address`, automatically
    track changes to the objects as they are made, which result in SQL statements
    that will be emitted the next time the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") flushes. Below, we change one email address associated
    with “sandy”, and also add a new email address to “patrick”, after emitting a
    SELECT to retrieve the row for “patrick”:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象与我们的 ORM 映射类 `User` 和 `Address` 一起，会自动跟踪对象的更改，这些更改会导致 SQL 语句在下次 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 刷新时被发出。下面，我们更改了与“sandy”关联的一个电子邮件地址，并在发出 SELECT 以检索“patrick”的行之后，向“patrick”添加了一个新的电子邮件地址：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice when we accessed `patrick.addresses`, a SELECT was emitted. This is called
    a [lazy load](../glossary.html#term-lazy-load). Background on different ways to
    access related items using more or less SQL is introduced at [Loader Strategies](../tutorial/orm_related_objects.html#tutorial-orm-loader-strategies).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们访问`patrick.addresses`时，会发出一个 SELECT。这被称为[延迟加载](../glossary.html#term-lazy-load)。有关使用更多或更少的
    SQL 访问相关项目的不同方法的背景介绍，请参阅[加载器策略](../tutorial/orm_related_objects.html#tutorial-orm-loader-strategies)。
- en: A detailed walkthrough on ORM data manipulation starts at [Data Manipulation
    with the ORM](../tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 ORM 进行数据操作的详细说明，请参阅[ORM 数据操作](../tutorial/orm_data_manipulation.html#tutorial-orm-data-manipulation)。
- en: Some Deletes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些删除操作
- en: All things must come to an end, as is the case for some of our database rows
    - here’s a quick demonstration of two different forms of deletion, both of which
    are important based on the specific use case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 万物都有尽头，就像我们的一些数据库行一样 - 这里快速演示了两种不同形式的删除，根据特定用例的重要性而定。
- en: 'First we will remove one of the `Address` objects from the “sandy” user. When
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next flushes, this will result in the row being deleted. This behavior is something
    that we configured in our mapping called the [delete cascade](cascades.html#cascade-delete).
    We can get a handle to the `sandy` object by primary key using [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get"), then work with the object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从“sandy”用户中删除一个`Address`对象。当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")下次刷新时，这将导致该行被删除。这种行为是我们在映射中配置的，称为[级联删除](cascades.html#cascade-delete)。我们可以使用
    [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    按主键获取到`sandy`对象，然后操作该对象：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last SELECT above was the [lazy load](../glossary.html#term-lazy-load) operation
    proceeding so that the `sandy.addresses` collection could be loaded, so that we
    could remove the `sandy_address` member. There are other ways to go about this
    series of operations that won’t emit as much SQL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后一个 SELECT 是为了进行[延迟加载](../glossary.html#term-lazy-load) 操作，以便加载`sandy.addresses`集合，以便我们可以删除`sandy_address`成员。还有其他方法可以执行这一系列操作，不会发出太多的
    SQL。
- en: 'We can choose to emit the DELETE SQL for what’s set to be changed so far, without
    committing the transaction, using the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择发出针对到目前为止被更改的 DELETE SQL，而不提交事务，使用 [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 方法：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will delete the “patrick” user entirely. For a top-level delete of
    an object by itself, we use the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method; this method doesn’t actually perform
    the deletion, but sets up the object to be deleted on the next flush. The operation
    will also [cascade](../glossary.html#term-cascade) to related objects based on
    the cascade options that we configured, in this case, onto the related `Address`
    objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完全删除“patrick”用户。对于对象的顶级删除，我们使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法；这个方法实际上并不执行删除操作，而是设置对象在下一次刷新时将被删除。该操作还会根据我们配置的级联选项级联到相关对象，本例中是关联的`Address`对象：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method in this particular case emitted two SELECT statements, even though it didn’t
    emit a DELETE, which might seem surprising. This is because when the method went
    to inspect the object, it turns out the `patrick` object was [expired](../glossary.html#term-expired),
    which happened when we last called upon [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), and the SQL emitted was to re-load the rows
    from the new transaction. This expiration is optional, and in normal use we will
    often be turning it off for situations where it doesn’t apply well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法发出了两个SELECT语句，即使它没有发出DELETE，这可能看起来令人惊讶。这是因为当方法检查对象时，发现`patrick`对象已经[过期](../glossary.html#term-expired)，这是在我们上次调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时发生的，发出的SQL是为了从新事务重新加载行。这种过期是可选的，在正常使用中，我们通常会在不适用的情况下关闭它。
- en: 'To illustrate the rows being deleted, here’s the commit:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要说明被删除的行，请看这个提交：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Tutorial discusses ORM deletion at [Deleting ORM Objects using the Unit
    of Work pattern](../tutorial/orm_data_manipulation.html#tutorial-orm-deleting).
    Background on object expiration is at [Expiring / Refreshing](session_basics.html#session-expiring);
    cascades are discussed in depth at [Cascades](cascades.html#unitofwork-cascades).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程讨论了ORM删除操作，详情请见[使用工作单元模式删除ORM对象](../tutorial/orm_data_manipulation.html#tutorial-orm-deleting)。关于对象过期的背景信息请参考[过期/刷新](session_basics.html#session-expiring)；级联操作在[Cascades](cascades.html#unitofwork-cascades)中有详细讨论。
- en: Learn the above concepts in depth
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入学习上述概念
- en: For a new user, the above sections were likely a whirlwind tour. There’s a lot
    of important concepts in each step above that weren’t covered. With a quick overview
    of what things look like, it’s recommended to work through the [SQLAlchemy Unified
    Tutorial](../tutorial/index.html#unified-tutorial) to gain a solid working knowledge
    of what’s really going on above. Good luck!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新用户来说，上述部分可能是一场令人眼花缭乱的旅程。每个步骤中都有许多重要概念没有涵盖。快速了解事物的外观后，建议通过[SQLAlchemy统一教程](../tutorial/index.html#unified-tutorial)来深入了解上述内容。祝好运！
