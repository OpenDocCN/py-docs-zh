- en: Transactions and Connection Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务和连接管理
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_transaction.html](https://docs.sqlalchemy.org/en/20/orm/session_transaction.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_transaction.html](https://docs.sqlalchemy.org/en/20/orm/session_transaction.html)
- en: '## Managing Transactions'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 事务管理'
- en: 'Changed in version 1.4: Session transaction management has been revised to
    be clearer and easier to use. In particular, it now features “autobegin” operation,
    which means the point at which a transaction begins may be controlled, without
    using the legacy “autocommit” mode.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本中更改：会话事务管理已经修订为更清晰、更易于使用。特别是，它现在具有“自动开始”操作，这意味着可以控制事务开始的时间点，而不使用传统的“自动提交”模式。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    tracks the state of a single “virtual” transaction at a time, using an object
    called [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction"). This object then makes use of the underlying
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or engines to which the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object is bound in order to start real connection-level transactions using the
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object as needed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")一次跟踪单个“虚拟”事务的状态，使用一个称为[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")的对象。然后，此对象利用绑定到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的基础[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或引擎，根据需要使用[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象开始真实的连接级事务。'
- en: This “virtual” transaction is created automatically when needed, or can alternatively
    be started using the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. To as great a degree as possible, Python
    context manager use is supported both at the level of creating [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects as well as to maintain the scope of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction").
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此“虚拟”事务在需要时会自动创建，或者可以使用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法启动。尽可能地支持Python上下文管理器的使用，既在创建[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的层面，也在维护[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")的范围方面。
- en: 'Below, assume we start with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now run operations within a demarcated transaction using a context manager:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用上下文管理器在一个确定的事务中运行操作：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the end of the above context, assuming no exceptions were raised, any pending
    objects will be flushed to the database and the database transaction will be committed.
    If an exception was raised within the above block, then the transaction would
    be rolled back. In both cases, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") subsequent to exiting the block is ready to be used
    in subsequent transactions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文结束时，假设没有引发任何异常，则任何待处理的对象都将被刷新到数据库，并且数据库事务将被提交。如果在上述块内引发了异常，则事务将被回滚。在这两种情况下，上述[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在退出块后都已准备好用于后续的事务。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method is optional, and the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be used in a commit-as-you-go approach, where
    it will begin transactions automatically as needed; these only need be committed
    or rolled back:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")方法是可选的，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")也可以使用按需自动开始事务的“随时提交”方法；这些只需要提交或回滚：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself features a [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method. If the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is begun within a transaction that has not yet been
    committed or rolled back, this method will cancel (i.e. rollback) that transaction,
    and also expunge all objects contained within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s state. If the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is being used in such a way that a call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is not guaranteed (e.g. not within a context
    manager or similar), the [`close`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method may be used to ensure all resources are
    released:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    本身具有一个 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法。如果 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    是在尚未提交或回滚的事务内开始的，该方法将取消（即回滚）该事务，并清除 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象状态中包含的所有对象。如果使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的方式不能保证调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")（例如，不在上下文管理器或类似结构中），则可以使用 [`close`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法来确保释放所有资源：'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the session construction / close process can itself be run via context
    manager. This is the best way to ensure that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s use is scoped within a fixed block. Illustrated
    via the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    constructor first:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，会话的构建/关闭过程本身也可以通过上下文管理器运行。这是确保 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象使用范围在一个固定块内的最佳方式。首先通过 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 构造函数进行说明：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can be used in the same way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    可以以相同的方式使用：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    itself includes a [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method to allow both operations to take place
    at once:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    本身包含一个 [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") 方法，允许同时进行两个操作：'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '### Using SAVEPOINT'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 SAVEPOINT'
- en: 'SAVEPOINT transactions, if supported by the underlying engine, may be delineated
    using the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层引擎支持，可以使用 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 方法来划定 SAVEPOINT 事务：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each time [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, a new “BEGIN SAVEPOINT” command
    is emitted to the database within the scope of the current database transaction
    (starting one if not already in progress), and an object of type [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is returned, which represents a handle to
    this SAVEPOINT. When the `.commit()` method on this object is called, “RELEASE
    SAVEPOINT” is emitted to the database, and if instead the `.rollback()` method
    is called, “ROLLBACK TO SAVEPOINT” is emitted. The enclosing database transaction
    remains in progress.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")，都会在当前数据库事务的范围内向数据库发出一个新的“BEGIN SAVEPOINT”命令（如果尚未开始，则开始一个），并返回一个类型为
    [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction "sqlalchemy.orm.SessionTransaction")
    的对象，代表这个 SAVEPOINT 的句柄。当调用该对象的 `.commit()` 方法时，会向数据库发出“RELEASE SAVEPOINT”，如果调用
    `.rollback()` 方法，则会发出“ROLLBACK TO SAVEPOINT”。封闭的数据库事务仍在进行中。
- en: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is typically used as a context manager
    where specific per-instance errors may be caught, in conjunction with a rollback
    emitted for that portion of the transaction’s state, without rolling back the
    whole transaction, as in the example below:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 通常用作上下文管理器，可以捕获特定的每个实例错误，并在该事务状态的部分发出回滚，而不会回滚整个事务，如下例所示：'
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the context manager yielded by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") completes, it “commits” the savepoint,
    which includes the usual behavior of flushing all pending state. When an error
    is raised, the savepoint is rolled back and the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to the objects that were changed is expired.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当由 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 产生的上下文管理器完成时，“提交” savepoint，其中包括刷新所有挂起状态的常规行为。当出现错误时，保存点会被回滚，并且更改的对象的
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    本地状态会过期。
- en: 'This pattern is ideal for situations such as using PostgreSQL and catching
    [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError "sqlalchemy.exc.IntegrityError")
    to detect duplicate rows; PostgreSQL normally aborts the entire transaction when
    such an error is raised, however when using SAVEPOINT, the outer transaction is
    maintained. In the example below a list of data is persisted into the database,
    with the occasional “duplicate primary key” record skipped, without rolling back
    the entire operation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常适用于诸如使用 PostgreSQL 并捕获 [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError") 来检测重复行的情况；通常情况下，当出现此类错误时，PostgreSQL 会中止整个事务，但是使用
    SAVEPOINT 时，外部事务会得以保留。在下面的示例中，将一系列数据持久化到数据库中，并且偶尔会跳过“重复的主键”记录，而无需回滚整个操作：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first flushes all currently pending state to the database;
    this occurs unconditionally, regardless of the value of the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter which normally may be used to disable automatic
    flush. The rationale for this behavior is so that when a rollback on this nested
    transaction occurs, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may expire any in-memory state that was created within the scope of the SAVEPOINT,
    while ensuring that when those expired objects are refreshed, the state of the
    object graph prior to the beginning of the SAVEPOINT will be available to re-load
    from the database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 首先会将当前所有挂起的状态刷新到数据库；这种情况会无条件发生，不管 [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") 参数的值是什么，该参数通常用于禁用自动刷新。这种行为的原因是，当此嵌套事务发生回滚时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 可以使在 SAVEPOINT 范围内创建的任何内存状态过期，同时确保在刷新这些过期对象时，SAVEPOINT
    开始之前的对象图状态将可用于重新从数据库加载。
- en: In modern versions of SQLAlchemy, when a SAVEPOINT initiated by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is rolled back, in-memory object state
    that was modified since the SAVEPOINT was created is expired, however other object
    state that was not altered since the SAVEPOINT began is maintained. This is so
    that subsequent operations can continue to make use of the otherwise unaffected
    data without the need for refreshing it from the database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 的现代版本中，当由 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 启动的 SAVEPOINT 被回滚时，自 SAVEPOINT 创建以来已修改的内存对象状态会过期，但自
    SAVEPOINT 开始后未修改的其他对象状态将保持不变。这样，后续操作可以继续使用其它未受影响的数据，而无需从数据库刷新。
- en: See also
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - Core SAVEPOINT API  ### Session-level
    vs. Engine level transaction control'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - 核心SAVEPOINT API  ### 会话级别与引擎级别的事务控制'
- en: 'The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    in Core and `_session.Session` in ORM feature equivalent transactional semantics,
    both at the level of the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") vs. the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), as well as the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") vs. the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The following sections detail these scenarios
    based on the following scheme:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心中的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")和ORM中的`_session.Session`具有等效的事务语义，无论是在[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的级别，还是在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的级别。以下部分根据以下方案详细说明这些情况：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Commit as you go
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边提交边进行
- en: Both [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    feature [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods. Using SQLAlchemy 2.0-style operation,
    these methods affect the **outermost** transaction in all cases. For the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it is assumed that [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") is left at its default value of `True`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")都具有[`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit")和[`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback")方法。使用SQLAlchemy 2.0风格的操作，这些方法在所有情况下都会影响**最外层**的事务。对于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，假定[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")保持默认值`True`。'
- en: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Begin Once
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一次开始
- en: Both [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    feature a [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method that will both procure a new object with
    which to execute SQL statements (the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), respectively) and then return a context manager
    that will maintain a begin/commit/rollback context for that object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")和[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")都具有[`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")方法，该方法将获取一个新对象来执行SQL语句（分别是[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")），然后返回一个上下文管理器，用于维护该对象的开始/提交/回滚上下文。'
- en: 'Engine:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Session:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Nested Transaction
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套事务
- en: When using a SAVEPOINT via the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") or [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") methods, the transaction object returned
    must be used to commit or rollback the SAVEPOINT. Calling the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") methods will always commit the **outermost**
    transaction; this is a SQLAlchemy 2.0 specific behavior that is reversed from
    the 1.x series.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SAVEPOINT 通过 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 或 [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") 方法时，必须使用返回的事务对象来提交或回滚 SAVEPOINT。
    调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    或 [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") 方法将始终提交**最外层**事务；这是 SQLAlchemy 2.0 特定的行为，与
    1.x 系列相反。
- en: 'Engine:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Session:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE16]  ### Explicit Begin'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]  ### 显式开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    features “autobegin” behavior, meaning that as soon as operations begin to take
    place, it ensures a [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is present to track ongoing operations. This
    transaction is completed when [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    具有“自动开始”行为，这意味着一旦操作开始进行，它就会确保存在一个 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 来跟踪正在进行的操作。 当调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时，此事务将完成。'
- en: 'It is often desirable, particularly in framework integrations, to control the
    point at which the “begin” operation occurs. To suit this, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") uses an “autobegin” strategy, such that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may be called directly for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that has not already had a transaction begun:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望，特别是在框架集成中，控制“开始”操作发生的时间点。 为此，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 使用“自动开始”策略，使得可以直接调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法，以便为尚未启动事务的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 调用：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The above pattern is more idiomatically invoked using a context manager:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式更常用地使用上下文管理器调用：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method and the session’s “autobegin” process use the same sequence of steps to
    begin the transaction. This includes that the [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is invoked when
    it occurs; this hook is used by frameworks in order to integrate their own transactional
    processes with that of the ORM [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### Enabling Two-Phase Commit'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法和会话的“自动开始”过程使用相同的步骤序列开始事务。 这包括在发生时调用 [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件；此挂钩被框架用于将其自己的事务处理过程与
    ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    集成。'
- en: 'For backends which support two-phase operation (currently MySQL and PostgreSQL),
    the session can be instructed to use two-phase commit semantics. This will coordinate
    the committing of transactions across databases so that the transaction is either
    committed or rolled back in all databases. You can also [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") the session for interacting with transactions
    not managed by SQLAlchemy. To use two phase transactions set the flag `twophase=True`
    on the session:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持两阶段操作的后端（目前支持 MySQL 和 PostgreSQL），会话可以被指示使用两阶段提交语义。这将协调跨数据库的事务提交，以便在所有数据库中要么提交事务，要么回滚事务。您还可以[`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 会话以与 SQLAlchemy 不管理的事务进行交互。要使用两阶段事务，请在会话上设置标志
    `twophase=True`：
- en: '[PRE19]  ### Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]  ### 设置事务隔离级别 / DBAPI 自动提交'
- en: Most DBAPIs support the concept of configurable transaction [isolation](../glossary.html#term-isolation)
    levels. These are traditionally the four levels “READ UNCOMMITTED”, “READ COMMITTED”,
    “REPEATABLE READ” and “SERIALIZABLE”. These are usually applied to a DBAPI connection
    before it begins a new transaction, noting that most DBAPIs will begin this transaction
    implicitly when SQL statements are first emitted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 DBAPI 支持可配置的事务[隔离](../glossary.html#term-isolation)级别的概念。传统上有四个级别：“READ
    UNCOMMITTED”，“READ COMMITTED”，“REPEATABLE READ” 和 “SERIALIZABLE”。这些通常应用于 DBAPI
    连接在开始新事务之前，注意大多数 DBAPI 在首次发出 SQL 语句时会隐式开始此事务。
- en: DBAPIs that support isolation levels also usually support the concept of true
    “autocommit”, which means that the DBAPI connection itself will be placed into
    a non-transactional autocommit mode. This usually means that the typical DBAPI
    behavior of emitting “BEGIN” to the database automatically no longer occurs, but
    it may also include other directives. When using this mode, **the DBAPI does not
    use a transaction under any circumstances**. SQLAlchemy methods like `.begin()`,
    `.commit()` and `.rollback()` pass silently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 支持隔离级别的 DBAPI 通常也支持真正的 “自动提交” 概念，这意味着 DBAPI 连接本身将被置于非事务自动提交模式。这通常意味着数据库自动发出
    “BEGIN” 的典型 DBAPI 行为不再发生，但它也可能包括其他指令。在使用此模式时，**DBAPI 在任何情况下都不使用事务**。SQLAlchemy
    方法如 `.begin()`、`.commit()` 和 `.rollback()` 将静默传递。
- en: SQLAlchemy’s dialects support settable isolation modes on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis, using flags at both the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level as well as at the [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") level.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的方言支持在每个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或每个 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 基础上设置可设置的隔离模式，使用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 层级以及 [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") 层级的标志。
- en: When using the ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it acts as a *facade* for engines and connections, but does not expose transaction
    isolation directly. So in order to affect transaction isolation level, we need
    to act upon the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    as appropriate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，它充当引擎和连接的 *facade*，但不直接暴露事务隔离。因此，为了影响事务隔离级别，我们需要根据情况对 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 采取行动。
- en: See also
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    - be sure to review how isolation levels work at the level of the SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as well.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别包括 DBAPI 自动提交](../core/connections.html#dbapi-autocommit) - 请确保查看
    SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象的隔离级别工作方式。'
- en: '#### Setting Isolation For A Sessionmaker / Engine Wide'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为 Sessionmaker / Engine 设置隔离'
- en: 'To set up a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    with a specific isolation level globally, the first technique is that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be constructed against a specific isolation level
    in all cases, which is then used as the source of connectivity for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and/or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的隔离级别全局设置[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")，第一种技术是可以针对所有情况构建一个具有特定隔离级别的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，然后将其用作[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和/或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")的连接源：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another option, useful if there are to be two engines with different isolation
    levels at once, is to use the [`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, which will produce a shallow
    copy of the original [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which shares the same connection pool as the parent
    engine. This is often preferable when operations will be separated into “transactional”
    and “autocommit” operations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，如果同时存在具有不同隔离级别的两个引擎，是使用[`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")方法，该方法将生成一个原始[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的浅拷贝，该浅拷贝与父引擎共享相同的连接池。当操作将被分成“事务”和“自动提交”操作时，这通常是更可取的：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Above, both “`eng`” and `"autocommit_engine"` share the same dialect and connection
    pool. However the “AUTOCOMMIT” mode will be set upon connections when they are
    acquired from the `autocommit_engine`. The two [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") objects “`transactional_session`” and “`autocommit_session"`
    then inherit these characteristics when they work with database connections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，“`eng`”和`"autocommit_engine"`共享相同的方言和连接池。然而，当从`autocommit_engine`获取连接时，将设置“AUTOCOMMIT”模式。这两个[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象“`transactional_session`”和“`autocommit_session`”在与数据库连接工作时继承这些特性。
- en: 'The “`autocommit_session`” **continues to have transactional semantics**, including
    that [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    still consider themselves to be “committing” and “rolling back” objects, however
    the transaction will be silently absent. For this reason, **it is typical, though
    not strictly required, that a Session with AUTOCOMMIT isolation be used in a read-only
    fashion**, that is:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “`autocommit_session`” **仍然具有事务语义**，包括[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")仍然认为自己在“提交”和“回滚”对象，然而事务将会默默地不存在。因此，**通常情况下，尽管不是严格要求，使用
    AUTOCOMMIT 隔离的会话应该以只读方式使用**，即：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Setting Isolation for Individual Sessions
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置单个会话的隔离级别
- en: 'When we make a new [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    either using the constructor directly or when we call upon the callable produced
    by a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker"),
    we can pass the `bind` argument directly, overriding the pre-existing bind. We
    can for example create our [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from a default [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") and pass an engine set for autocommit:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，可以直接使用构造函数，也可以在调用由[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")生成的可调用对象时，直接传递`bind`参数，覆盖预先存在的绑定。例如，我们可以从默认的[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")创建我们的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")并传递一个设置为自动提交的引擎：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the case where the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is configured with multiple “binds”, we can either
    re-specify the `binds` argument fully, or if we want to only replace specific
    binds, we can use the [`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper") or [`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table") methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")配置了多个“binds”的情况，我们可以重新完整指定`binds`参数，或者如果我们只想替换特定的binds，则可以使用[`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper")或[`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table")方法：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Setting Isolation for Individual Transactions
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为个别事务设置隔离级别
- en: A key caveat regarding isolation level is that the setting cannot be safely
    modified on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") where a transaction has already started. Databases
    cannot change the isolation level of a transaction in progress, and some DBAPIs
    and SQLAlchemy dialects have inconsistent behaviors in this area.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隔离级别的一个关键警告是，在已经开始事务的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上不能安全地修改设置。数据库不能在进行中的事务中更改隔离级别，而一些DBAPIs和SQLAlchemy方言在这方面的行为不一致。
- en: 'Therefore it is preferable to use a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is up front bound to an engine with the desired
    isolation level. However, the isolation level on a per-connection basis can be
    affected by using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method at the start of a transaction:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用一个提前绑定到具有所需隔离级别的引擎的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然而，通过在事务开始时使用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")方法可以影响每个连接的隔离级别：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Above, we first produce a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using either the constructor or a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"). Then we explicitly set up the start of a database-level
    transaction by calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection"), which provides for execution options that
    will be passed to the connection before the database-level transaction is begun.
    The transaction proceeds with this selected isolation level. When the transaction
    completes, the isolation level is reset on the connection to its default before
    the connection is returned to the connection pool.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们首先使用构造函数或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")生成一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然后，我们通过调用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")显式设置数据库级事务的开始，该方法提供了在数据库级事务开始之前将传递给连接的执行选项。事务使用此选定的隔离级别进行。当事务完成时，隔离级别会重置为其默认值，然后将连接返回到连接池。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method may also be used to begin the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") level transaction; calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") subsequent to that call may be used to set
    up the per-connection-transaction isolation level:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")方法也可以用于开始[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")级事务；在调用该方法后，可以使用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")来设置每个连接的事务隔离级别：'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tracking Transaction State with Events
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件跟踪事务状态
- en: 'See the section [Transaction Events](session_events.html#session-transaction-events)
    for an overview of the available event hooks for session transaction state changes.  ##
    Joining a Session into an External Transaction (such as for test suites)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '请参阅[事务事件](session_events.html#session-transaction-events)部分，了解有关会话事务状态更改的可用事件挂钩的概述。
    ## 加入会话到外部事务（例如用于测试套件）'
- en: If a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is being used which is already in a transactional state (i.e. has a [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") established), a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be made to participate within that transaction by
    just binding the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to that [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    The usual rationale for this is a test suite that allows ORM code to work freely
    with a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    including the ability to call [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), where afterwards the entire database interaction
    is rolled back.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用处于事务状态的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")（即已建立 [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")），则可以通过将 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 绑定到该 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 来使 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 参与该事务。通常的理由是允许 ORM 代码自由地与 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 一起工作，包括调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，之后整个数据库交互都被回滚。
- en: 'Changed in version 2.0: The “join into an external transaction” recipe is newly
    improved again in 2.0; event handlers to “reset” the nested transaction are no
    longer required.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本中更改：2.0 版本再次对“加入到外部事务”配方进行了改进；不再需要事件处理程序来“重置”嵌套事务。
- en: The recipe works by establishing a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") within a transaction and optionally a SAVEPOINT,
    then passing it to a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as the “bind”; the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter is passed with the setting `"create_savepoint"`,
    which indicates that new SAVEPOINTs should be created in order to implement BEGIN/COMMIT/ROLLBACK
    for the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which will leave the external transaction in the same state in which it was passed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方的工作方式是在事务内部建立一个 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，可选地建立一个 SAVEPOINT，然后将其传递给 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 作为“bind”；[`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") 参数传递了设置为 `"create_savepoint"`，表示应该创建新的 SAVEPOINT 来实现
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的 BEGIN/COMMIT/ROLLBACK，这将使外部事务处于传递时的相同状态。
- en: 'When the test tears down, the external transaction is rolled back so that any
    data changes throughout the test are reverted:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试拆解时，外部事务会被回滚，以便将测试中的任何数据更改还原：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The above recipe is part of SQLAlchemy’s own CI to ensure that it remains working
    as expected.  ## Managing Transactions'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '上述配方是 SQLAlchemy 自己的 CI 的一部分，以确保它仍然按预期工作。 ## 管理事务'
- en: 'Changed in version 1.4: Session transaction management has been revised to
    be clearer and easier to use. In particular, it now features “autobegin” operation,
    which means the point at which a transaction begins may be controlled, without
    using the legacy “autocommit” mode.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版本中更改：会话事务管理已经进行了修改，使其更清晰、更易于使用。特别是，现在它具有“自动开始”操作，这意味着可以控制事务开始的时间点，而无需使用传统的“自动提交”模式。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    tracks the state of a single “virtual” transaction at a time, using an object
    called [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction"). This object then makes use of the underlying
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or engines to which the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object is bound in order to start real connection-level transactions using the
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object as needed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    跟踪一次性的“虚拟”事务的状态，使用一个叫做 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 的对象。然后，该对象利用底层的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或引擎来启动使用 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象所需的真实连接级事务。'
- en: This “virtual” transaction is created automatically when needed, or can alternatively
    be started using the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. To as great a degree as possible, Python
    context manager use is supported both at the level of creating [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects as well as to maintain the scope of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，这个“虚拟”事务会自动创建，或者可以使用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法手动开始。尽可能大程度地支持 Python 上下文管理器的使用，不仅在创建 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的级别上，还在维护 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 的范围上。
- en: 'Below, assume we start with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，假设我们从一个 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    开始：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now run operations within a demarcated transaction using a context manager:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用上下文管理器在标记的事务中运行操作：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At the end of the above context, assuming no exceptions were raised, any pending
    objects will be flushed to the database and the database transaction will be committed.
    If an exception was raised within the above block, then the transaction would
    be rolled back. In both cases, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") subsequent to exiting the block is ready to be used
    in subsequent transactions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述上下文结束时，假设没有引发任何异常，任何待处理的对象都将被刷新到数据库，并且数据库事务将被提交。如果在上述块中引发了异常，则事务将被回滚。在这两种情况下，上述
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    在退出块后都可以在后续事务中使用。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method is optional, and the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be used in a commit-as-you-go approach, where
    it will begin transactions automatically as needed; these only need be committed
    or rolled back:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法是可选的，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    也可以使用逐步提交的方法，在需要时自动开始事务；只需提交或回滚：'
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself features a [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method. If the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is begun within a transaction that has not yet been
    committed or rolled back, this method will cancel (i.e. rollback) that transaction,
    and also expunge all objects contained within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s state. If the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is being used in such a way that a call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is not guaranteed (e.g. not within a context
    manager or similar), the [`close`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method may be used to ensure all resources are
    released:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")本身具有[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法。如果[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")是在尚未提交或回滚的事务内开始的，则此方法将取消（即回滚）该事务，并且还将清除[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象状态中包含的所有对象。如果[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的使用方式不保证调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")（例如不在上下文管理器或类似位置），则可以使用[`close`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法确保释放所有资源：'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, the session construction / close process can itself be run via context
    manager. This is the best way to ensure that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s use is scoped within a fixed block. Illustrated
    via the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    constructor first:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，会话构建/关闭过程本身也可以通过上下文管理器运行。这是确保[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象使用范围在固定块内的最佳方法。首先通过[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")构造函数进行说明：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can be used in the same way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")也可以以相同的方式使用：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    itself includes a [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method to allow both operations to take place
    at once:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")本身包括一个[`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin")方法，允许同时执行这两个操作：'
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '### Using SAVEPOINT'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用SAVEPOINT'
- en: 'SAVEPOINT transactions, if supported by the underlying engine, may be delineated
    using the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层引擎支持SAVEPOINT事务，则可以使用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")方法来区分SAVEPOINT事务：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each time [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, a new “BEGIN SAVEPOINT” command
    is emitted to the database within the scope of the current database transaction
    (starting one if not already in progress), and an object of type [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is returned, which represents a handle to
    this SAVEPOINT. When the `.commit()` method on this object is called, “RELEASE
    SAVEPOINT” is emitted to the database, and if instead the `.rollback()` method
    is called, “ROLLBACK TO SAVEPOINT” is emitted. The enclosing database transaction
    remains in progress.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时，都会在当前数据库事务的范围内（如果尚未开始，则开始一个新的事务）向数据库发送新的“BEGIN
    SAVEPOINT”命令，并返回一个类型为[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")的对象，该对象表示对此SAVEPOINT的句柄。当调用该对象的`.commit()`方法时，将向数据库发出“RELEASE
    SAVEPOINT”命令；如果调用`.rollback()`方法，则发出“ROLLBACK TO SAVEPOINT”命令。封闭的数据库事务保持进行中。
- en: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is typically used as a context manager
    where specific per-instance errors may be caught, in conjunction with a rollback
    emitted for that portion of the transaction’s state, without rolling back the
    whole transaction, as in the example below:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")通常用作上下文管理器，其中可以捕获特定的每个实例错误，与事务状态的部分回滚一起使用，而不是回滚整个事务，如下例所示：'
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the context manager yielded by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") completes, it “commits” the savepoint,
    which includes the usual behavior of flushing all pending state. When an error
    is raised, the savepoint is rolled back and the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to the objects that were changed is expired.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当由[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")生成的上下文管理器完成时，它“提交”了保存点，其中包括刷新所有待定状态的通常行为。当发生错误时，保存点被回滚，并且被更改的对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")本地状态会被过期。
- en: 'This pattern is ideal for situations such as using PostgreSQL and catching
    [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError "sqlalchemy.exc.IntegrityError")
    to detect duplicate rows; PostgreSQL normally aborts the entire transaction when
    such an error is raised, however when using SAVEPOINT, the outer transaction is
    maintained. In the example below a list of data is persisted into the database,
    with the occasional “duplicate primary key” record skipped, without rolling back
    the entire operation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常适合诸如使用PostgreSQL并捕获[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")以检测重复行的情况；当出现此类错误时，PostgreSQL通常会中止整个事务，但是在使用SAVEPOINT时，外部事务会被维持。在下面的示例中，一组数据被持久化到数据库中，偶尔会跳过“重复的主键”记录，而不会回滚整个操作：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first flushes all currently pending state to the database;
    this occurs unconditionally, regardless of the value of the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter which normally may be used to disable automatic
    flush. The rationale for this behavior is so that when a rollback on this nested
    transaction occurs, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may expire any in-memory state that was created within the scope of the SAVEPOINT,
    while ensuring that when those expired objects are refreshed, the state of the
    object graph prior to the beginning of the SAVEPOINT will be available to re-load
    from the database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")首先将当前所有待定状态刷新到数据库；这是无条件发生的，不管[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")参数的值如何，该参数通常用于禁用自动刷新。这种行为的理由是，当在这个嵌套事务上发生回滚时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以使在SAVEPOINT范围内创建的任何内存状态过期，同时确保当这些过期对象被刷新时，SAVEPOINT开始之前的对象图状态可重新从数据库加载。
- en: In modern versions of SQLAlchemy, when a SAVEPOINT initiated by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is rolled back, in-memory object state
    that was modified since the SAVEPOINT was created is expired, however other object
    state that was not altered since the SAVEPOINT began is maintained. This is so
    that subsequent operations can continue to make use of the otherwise unaffected
    data without the need for refreshing it from the database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代版本的SQLAlchemy中，当由[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")发起的SAVEPOINT被回滚时，自从创建SAVEPOINT以来被修改的内存对象状态会被过期，然而自SAVEPOINT开始以来未被改变的其他对象状态会被保留。这样，后续操作可以继续使用未受影响的数据，而无需从数据库中刷新。
- en: See also
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - Core SAVEPOINT API  ### Session-level
    vs. Engine level transaction control'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - 核心SAVEPOINT API  ### 会话级别 vs. 引擎级别的事务控制'
- en: 'The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    in Core and `_session.Session` in ORM feature equivalent transactional semantics,
    both at the level of the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") vs. the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), as well as the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") vs. the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The following sections detail these scenarios
    based on the following scheme:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心中的[`连接`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")和ORM中的`_session.Session`具有等效的事务语义，都在[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")与[`引擎`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的级别，以及[`会话`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`连接`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的级别。以下各节根据以下方案详细说明了这些情况：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Commit as you go
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边做边提交
- en: Both [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    feature [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods. Using SQLAlchemy 2.0-style operation,
    these methods affect the **outermost** transaction in all cases. For the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it is assumed that [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") is left at its default value of `True`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[`会话`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`连接`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")都具有[`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection")和[`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback")方法。使用SQLAlchemy 2.0风格的操作，这些方法在所有情况下都会影响**最外层**的事务。对于[`会话`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，假定[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")保持默认值`True`。'
- en: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[`引擎`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")：'
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[`会话`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")：'
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Begin Once
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单次开始
- en: Both [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    feature a [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method that will both procure a new object with
    which to execute SQL statements (the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), respectively) and then return a context manager
    that will maintain a begin/commit/rollback context for that object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")和[`引擎`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")都具有[`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")方法，该方法将获取一个用于执行SQL语句的新对象（分别是[`会话`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和[`连接`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")），然后返回一个上下文管理器，该管理器将为该对象维护一个开始/提交/回滚的上下文。'
- en: 'Engine:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Session:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nested Transaction
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套事务
- en: When using a SAVEPOINT via the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") or [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") methods, the transaction object returned
    must be used to commit or rollback the SAVEPOINT. Calling the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") methods will always commit the **outermost**
    transaction; this is a SQLAlchemy 2.0 specific behavior that is reversed from
    the 1.x series.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 SAVEPOINT 通过 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 或 [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") 方法时，返回的事务对象必须用于提交或回滚 SAVEPOINT。调用
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    或 [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") 方法将始终提交**最外层**事务；这是 SQLAlchemy 2.0 特定于行为的，与
    1.x 系列相反。
- en: 'Engine:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Session:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE44]  ### Explicit Begin'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]  ### 显式开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    features “autobegin” behavior, meaning that as soon as operations begin to take
    place, it ensures a [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is present to track ongoing operations. This
    transaction is completed when [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    具有“自动开始”行为，这意味着一旦操作开始进行，它就会确保存在一个用于跟踪正在进行的操作的 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。当调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时，该事务将被完成。'
- en: 'It is often desirable, particularly in framework integrations, to control the
    point at which the “begin” operation occurs. To suit this, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") uses an “autobegin” strategy, such that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may be called directly for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that has not already had a transaction begun:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望特别是在框架集成中，控制“开始”操作发生的时机。为此，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 使用“自动开始”策略，使得可以直接调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法来为尚未启动事务的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 开始事务：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The above pattern is more idiomatically invoked using a context manager:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式更惯用地使用上下文管理器调用：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method and the session’s “autobegin” process use the same sequence of steps to
    begin the transaction. This includes that the [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is invoked when
    it occurs; this hook is used by frameworks in order to integrate their own transactional
    processes with that of the ORM [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### Enabling Two-Phase Commit'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法和会话的“自动开始”过程使用相同的步骤序列开始事务。这包括当 [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件发生时调用；此钩子被框架用于将其自己的事务处理过程与
    ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    集成。  ### 启用两阶段提交'
- en: 'For backends which support two-phase operation (currently MySQL and PostgreSQL),
    the session can be instructed to use two-phase commit semantics. This will coordinate
    the committing of transactions across databases so that the transaction is either
    committed or rolled back in all databases. You can also [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") the session for interacting with transactions
    not managed by SQLAlchemy. To use two phase transactions set the flag `twophase=True`
    on the session:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持两阶段操作的后端（当前为MySQL和PostgreSQL），可以指示会话使用两阶段提交语义。这将协调跨数据库的事务提交，以便在所有数据库中提交或回滚事务。您还可以[`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 会话以与SQLAlchemy未管理的事务进行交互。要使用两阶段事务，请在会话上设置标志
    `twophase=True`：
- en: '[PRE47]  ### Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]  ### 设置事务隔离级别 / DBAPI AUTOCOMMIT'
- en: Most DBAPIs support the concept of configurable transaction [isolation](../glossary.html#term-isolation)
    levels. These are traditionally the four levels “READ UNCOMMITTED”, “READ COMMITTED”,
    “REPEATABLE READ” and “SERIALIZABLE”. These are usually applied to a DBAPI connection
    before it begins a new transaction, noting that most DBAPIs will begin this transaction
    implicitly when SQL statements are first emitted.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数DBAPI支持可配置的事务[隔离级别](../glossary.html#term-isolation)概念。传统上有四个级别：“READ UNCOMMITTED”、“READ
    COMMITTED”、“REPEATABLE READ”和“SERIALIZABLE”。这些通常在DBAPI连接开始新事务之前应用，需要注意的是，大多数DBAPI在首次发出SQL语句时会隐式开始此事务。
- en: DBAPIs that support isolation levels also usually support the concept of true
    “autocommit”, which means that the DBAPI connection itself will be placed into
    a non-transactional autocommit mode. This usually means that the typical DBAPI
    behavior of emitting “BEGIN” to the database automatically no longer occurs, but
    it may also include other directives. When using this mode, **the DBAPI does not
    use a transaction under any circumstances**. SQLAlchemy methods like `.begin()`,
    `.commit()` and `.rollback()` pass silently.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 支持隔离级别的DBAPI通常还支持真实的“自动提交”概念，这意味着DBAPI连接本身将被放置在非事务自动提交模式中。这通常意味着自动向数据库发出“BEGIN”的典型DBAPI行为不再发生，但也可能包括其他指令。在使用此模式时，**DBAPI在任何情况下都不使用事务**。SQLAlchemy方法如`.begin()`、`.commit()`
    和 `.rollback()` 会静默通过。
- en: SQLAlchemy’s dialects support settable isolation modes on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis, using flags at both the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level as well as at the [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的方言支持在每个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或每个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 的基础上设置隔离模式，使用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 层次上以及 [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") 层次上的标志。
- en: When using the ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it acts as a *facade* for engines and connections, but does not expose transaction
    isolation directly. So in order to affect transaction isolation level, we need
    to act upon the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    as appropriate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，它充当引擎和连接的*外观*，但不直接暴露事务隔离。因此，为了影响事务隔离级别，我们需要在适当时对[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 进行操作。
- en: See also
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    - be sure to review how isolation levels work at the level of the SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as well.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括DBAPI自动提交](../core/connections.html#dbapi-autocommit) - 一定要查看SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    对象级别的隔离级别是如何工作的。'
- en: '#### Setting Isolation For A Sessionmaker / Engine Wide'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为 Sessionmaker / Engine 设置隔离级别'
- en: 'To set up a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    with a specific isolation level globally, the first technique is that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be constructed against a specific isolation level
    in all cases, which is then used as the source of connectivity for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and/or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    设置特定的隔离级别，全局首选技巧是可以始终根据特定的隔离级别构建一个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，然后将其用作 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 和/或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 的连接源：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Another option, useful if there are to be two engines with different isolation
    levels at once, is to use the [`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, which will produce a shallow
    copy of the original [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which shares the same connection pool as the parent
    engine. This is often preferable when operations will be separated into “transactional”
    and “autocommit” operations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，如果同时存在具有不同隔离级别的两个引擎，是使用 [`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") 方法，该方法将产生原始 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 的浅拷贝，该拷贝与父引擎共享相同的连接池。当操作将被分为“事务性”和“自动提交”操作时，通常最好使用此方法：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Above, both “`eng`” and `"autocommit_engine"` share the same dialect and connection
    pool. However the “AUTOCOMMIT” mode will be set upon connections when they are
    acquired from the `autocommit_engine`. The two [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") objects “`transactional_session`” and “`autocommit_session"`
    then inherit these characteristics when they work with database connections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，“`eng`” 和 `"autocommit_engine"` 共享相同的方言和连接池。但是，当从 `autocommit_engine`
    获取连接时，将设置“AUTOCOMMIT”模式。当这两个 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 对象“`transactional_session`” 和 “`autocommit_session"`
    与数据库连接一起工作时，它们会继承这些特性。
- en: 'The “`autocommit_session`” **continues to have transactional semantics**, including
    that [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    still consider themselves to be “committing” and “rolling back” objects, however
    the transaction will be silently absent. For this reason, **it is typical, though
    not strictly required, that a Session with AUTOCOMMIT isolation be used in a read-only
    fashion**, that is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: “`autocommit_session`” 仍然具有事务语义，包括 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 和 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 仍然将其自己视为“提交”和“回滚”对象，但是事务将会默默消失。因此，**通常情况下，虽然不是严格要求，但
    AUTOCOMMIT 隔离级别的会话应该以只读方式使用**，也就是：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Setting Isolation for Individual Sessions
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置单独会话的隔离级别
- en: 'When we make a new [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    either using the constructor directly or when we call upon the callable produced
    by a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker"),
    we can pass the `bind` argument directly, overriding the pre-existing bind. We
    can for example create our [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from a default [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") and pass an engine set for autocommit:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，无论是直接使用构造函数还是调用由
    [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    生成的可调用函数时，我们都可以直接传递 `bind` 参数，覆盖预先存在的绑定。例如，我们可以从默认的 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 创建我们的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，并传递一个设置为自动提交的引擎：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For the case where the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is configured with multiple “binds”, we can either
    re-specify the `binds` argument fully, or if we want to only replace specific
    binds, we can use the [`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper") or [`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table") methods:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置了多个“绑定”（[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")）的情况，我们可以重新完全指定`binds`参数，或者如果我们只想替换特定的绑定，则可以使用[`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper")或[`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table")方法：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Setting Isolation for Individual Transactions
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为单个事务设置隔离级别
- en: A key caveat regarding isolation level is that the setting cannot be safely
    modified on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") where a transaction has already started. Databases
    cannot change the isolation level of a transaction in progress, and some DBAPIs
    and SQLAlchemy dialects have inconsistent behaviors in this area.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隔离级别的一个关键注意事项是，不能在已经开始事务的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上安全地修改设置。数据库不能更改正在进行的事务的隔离级别，并且一些 DBAPIs 和 SQLAlchemy
    方言在这个领域的行为不一致。
- en: 'Therefore it is preferable to use a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is up front bound to an engine with the desired
    isolation level. However, the isolation level on a per-connection basis can be
    affected by using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method at the start of a transaction:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用一个与所需隔离级别的引擎直接绑定的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然而，可以通过在事务开始时使用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")方法来影响每个连接的隔离级别：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Above, we first produce a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using either the constructor or a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"). Then we explicitly set up the start of a database-level
    transaction by calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection"), which provides for execution options that
    will be passed to the connection before the database-level transaction is begun.
    The transaction proceeds with this selected isolation level. When the transaction
    completes, the isolation level is reset on the connection to its default before
    the connection is returned to the connection pool.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们首先使用构造函数或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")生成一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然后，我们通过调用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")显式设置数据库级别事务的开始，该方法提供了将传递给连接的执行选项，在开始数据库级别事务之前进行设置。事务使用所选的隔离级别进行。事务完成后，将在将连接返回到连接池之前将连接上的隔离级别重置为其默认值。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method may also be used to begin the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") level transaction; calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") subsequent to that call may be used to set
    up the per-connection-transaction isolation level:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")方法也可以用于开始[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")级别的事务；在调用该方法后，可以使用[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")设置每个连接的事务隔离级别：'
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tracking Transaction State with Events
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件跟踪事务状态
- en: See the section [Transaction Events](session_events.html#session-transaction-events)
    for an overview of the available event hooks for session transaction state changes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[事务事件](session_events.html#session-transaction-events)部分，了解会话事务状态更改的可用事件挂钩的概述。
- en: '### Using SAVEPOINT'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用保存点'
- en: 'SAVEPOINT transactions, if supported by the underlying engine, may be delineated
    using the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层引擎支持SAVEPOINT事务，则可以使用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")方法进行分割：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Each time [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, a new “BEGIN SAVEPOINT” command
    is emitted to the database within the scope of the current database transaction
    (starting one if not already in progress), and an object of type [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is returned, which represents a handle to
    this SAVEPOINT. When the `.commit()` method on this object is called, “RELEASE
    SAVEPOINT” is emitted to the database, and if instead the `.rollback()` method
    is called, “ROLLBACK TO SAVEPOINT” is emitted. The enclosing database transaction
    remains in progress.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时，都会在当前数据库事务的范围内（如果尚未开始，则开始一个）向数据库发出新的“BEGIN
    SAVEPOINT”命令，并返回一个[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")类型的对象，该对象表示对此保存点的句柄。当调用此对象的`.commit()`方法时，将向数据库发出“RELEASE
    SAVEPOINT”，如果调用`.rollback()`方法，则会发出“ROLLBACK TO SAVEPOINT”。外层数据库事务仍然在进行中。
- en: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is typically used as a context manager
    where specific per-instance errors may be caught, in conjunction with a rollback
    emitted for that portion of the transaction’s state, without rolling back the
    whole transaction, as in the example below:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")通常用作上下文管理器，其中可以捕获特定的每个实例错误，在此事务状态的一部分上发出回滚，而无需回滚整个事务，就像下面的示例中一样：'
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When the context manager yielded by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") completes, it “commits” the savepoint,
    which includes the usual behavior of flushing all pending state. When an error
    is raised, the savepoint is rolled back and the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to the objects that were changed is expired.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当由[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")生成的上下文管理器完成时，它会“提交”保存点，其中包括刷新所有待处理状态的通常行为。当出现错误时，保存点会被回滚，并且对已更改的对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态将被过期。
- en: 'This pattern is ideal for situations such as using PostgreSQL and catching
    [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError "sqlalchemy.exc.IntegrityError")
    to detect duplicate rows; PostgreSQL normally aborts the entire transaction when
    such an error is raised, however when using SAVEPOINT, the outer transaction is
    maintained. In the example below a list of data is persisted into the database,
    with the occasional “duplicate primary key” record skipped, without rolling back
    the entire operation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式非常适合于使用PostgreSQL并捕获[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")以检测重复行的情况；当引发此类错误时，PostgreSQL通常会中止整个事务，但是当使用SAVEPOINT时，外部事务会得以保留。在下面的示例中，将一系列数据持久化到数据库中，偶尔会跳过“重复主键”记录，而不会回滚整个操作：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first flushes all currently pending state to the database;
    this occurs unconditionally, regardless of the value of the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter which normally may be used to disable automatic
    flush. The rationale for this behavior is so that when a rollback on this nested
    transaction occurs, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may expire any in-memory state that was created within the scope of the SAVEPOINT,
    while ensuring that when those expired objects are refreshed, the state of the
    object graph prior to the beginning of the SAVEPOINT will be available to re-load
    from the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")首先会将当前所有待定状态刷新到数据库；无论[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")参数的值是什么，这都是无条件的，通常可以用来禁用自动刷新。这种行为的原因是当此嵌套事务上发生回滚时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以使在保存点范围内创建的任何内存状态过期，同时确保在刷新这些过期对象时，保存点开始前的对象图状态将可用于重新从数据库加载。
- en: In modern versions of SQLAlchemy, when a SAVEPOINT initiated by [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is rolled back, in-memory object state
    that was modified since the SAVEPOINT was created is expired, however other object
    state that was not altered since the SAVEPOINT began is maintained. This is so
    that subsequent operations can continue to make use of the otherwise unaffected
    data without the need for refreshing it from the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代版本的SQLAlchemy中，当由[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")初始化的保存点被回滚时，自从保存点创建以来被修改的内存对象状态将会被过期，但是其他自保存点开始时未改变的对象状态将会被保留。这样做是为了让后续操作可以继续使用那些未受影响的数据，而无需从数据库中刷新。
- en: See also
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - Core SAVEPOINT API'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") - 核心保存点API'
- en: '### Session-level vs. Engine level transaction control'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '### 会话级与引擎级事务控制'
- en: 'The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    in Core and `_session.Session` in ORM feature equivalent transactional semantics,
    both at the level of the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") vs. the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), as well as the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") vs. the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The following sections detail these scenarios
    based on the following scheme:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Core中的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")和ORM中的`_session.Session`都具有等效的事务语义，无论是在[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")之间，还是在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")之间。以下各节详细说明了这些情景，基于以下方案：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Commit as you go
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边做边提交
- en: Both [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    feature [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods. Using SQLAlchemy 2.0-style operation,
    these methods affect the **outermost** transaction in all cases. For the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it is assumed that [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") is left at its default value of `True`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    和 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    均提供了 [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") 和 [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") 方法。使用 SQLAlchemy 2.0 风格的操作时，这些方法在所有情况下都会影响**最外层**的事务。对于
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，假定
    [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") 保持默认值 `True`。'
- en: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Begin Once
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只初始化一次
- en: Both [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    feature a [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method that will both procure a new object with
    which to execute SQL statements (the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), respectively) and then return a context manager
    that will maintain a begin/commit/rollback context for that object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    和 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    均提供了 [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") 方法，该方法将获取一个新对象来执行 SQL 语句（分别是 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 和 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")），然后返回一个上下文管理器，用于维护该对象的开始/提交/回滚上下文。'
- en: 'Engine:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Session:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE62]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Nested Transaction
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套事务
- en: When using a SAVEPOINT via the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") or [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") methods, the transaction object returned
    must be used to commit or rollback the SAVEPOINT. Calling the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") methods will always commit the **outermost**
    transaction; this is a SQLAlchemy 2.0 specific behavior that is reversed from
    the 1.x series.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 SAVEPOINT 通过 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 或 [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") 方法时，必须使用返回的事务对象来提交或回滚 SAVEPOINT。调用
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    或 [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") 方法将始终提交**最外层**的事务；这是 SQLAlchemy 2.0 特有的行为，与
    1.x 系列相反。
- en: 'Engine:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Session:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Commit as you go
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边提交边执行
- en: Both [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    feature [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods. Using SQLAlchemy 2.0-style operation,
    these methods affect the **outermost** transaction in all cases. For the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it is assumed that [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") is left at its default value of `True`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")均提供[`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit")和[`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback")方法。使用SQLAlchemy 2.0风格的操作，这些方法在所有情况下都会影响到**最外层**的事务。对于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，假定[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")保持其默认值为`True`。'
- en: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")：'
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")：'
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Begin Once
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始一次
- en: Both [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    feature a [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method that will both procure a new object with
    which to execute SQL statements (the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), respectively) and then return a context manager
    that will maintain a begin/commit/rollback context for that object.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")和[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")均提供[`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")方法，该方法将获取一个新对象以执行SQL语句（分别是[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")），然后返回一个上下文管理器，用于维护该对象的开始/提交/回滚上下文。'
- en: 'Engine:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Session:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Nested Transaction
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套事务
- en: When using a SAVEPOINT via the [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") or [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") methods, the transaction object returned
    must be used to commit or rollback the SAVEPOINT. Calling the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") methods will always commit the **outermost**
    transaction; this is a SQLAlchemy 2.0 specific behavior that is reversed from
    the 1.x series.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通过[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")或[`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested")方法创建的SAVEPOINT时，必须使用返回的事务对象提交或回滚SAVEPOINT。调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit")方法将始终提交**最外层**的事务；这是SQLAlchemy 2.0特定行为，与1.x系列相反。
- en: 'Engine:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Session:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 会话：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '### Explicit Begin'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '### 显式开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    features “autobegin” behavior, meaning that as soon as operations begin to take
    place, it ensures a [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") is present to track ongoing operations. This
    transaction is completed when [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    具有“自动开始”行为，这意味着一旦开始执行操作，它就会确保存在一个 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 来跟踪正在进行的操作。当调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时，此事务将被完成。'
- en: 'It is often desirable, particularly in framework integrations, to control the
    point at which the “begin” operation occurs. To suit this, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") uses an “autobegin” strategy, such that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may be called directly for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that has not already had a transaction begun:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，特别是在框架集成中，控制“开始”操作发生的时间点是可取的。为此，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用“自动开始”策略，以便可以直接调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法来启动一个尚未开始事务的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")：
- en: '[PRE71]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The above pattern is more idiomatically invoked using a context manager:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式通常使用上下文管理器更具惯用性：
- en: '[PRE72]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method and the session’s “autobegin” process use the same sequence of steps to
    begin the transaction. This includes that the [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is invoked when
    it occurs; this hook is used by frameworks in order to integrate their own transactional
    processes with that of the ORM [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法和会话的“自动开始”过程使用相同的步骤序列来开始事务。这包括当它发生时调用 [`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件；此钩子由框架使用，以便将其自己的事务处理集成到ORM
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的事务处理中。'
- en: '### Enabling Two-Phase Commit'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '### 启用两阶段提交'
- en: 'For backends which support two-phase operation (currently MySQL and PostgreSQL),
    the session can be instructed to use two-phase commit semantics. This will coordinate
    the committing of transactions across databases so that the transaction is either
    committed or rolled back in all databases. You can also [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") the session for interacting with transactions
    not managed by SQLAlchemy. To use two phase transactions set the flag `twophase=True`
    on the session:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持两阶段操作的后端（目前是MySQL和PostgreSQL），可以指示会话使用两阶段提交语义。这将协调跨数据库的事务提交，以便在所有数据库中要么提交事务，要么回滚事务。您还可以为与SQLAlchemy未管理的事务交互的会话
    [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare "sqlalchemy.orm.Session.prepare")
    。要使用两阶段事务，请在会话上设置标志 `twophase=True`：
- en: '[PRE73]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '### Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置事务隔离级别 / DBAPI自动提交'
- en: Most DBAPIs support the concept of configurable transaction [isolation](../glossary.html#term-isolation)
    levels. These are traditionally the four levels “READ UNCOMMITTED”, “READ COMMITTED”,
    “REPEATABLE READ” and “SERIALIZABLE”. These are usually applied to a DBAPI connection
    before it begins a new transaction, noting that most DBAPIs will begin this transaction
    implicitly when SQL statements are first emitted.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数DBAPI支持可配置的事务隔离级别的概念。传统上，这些级别是“READ UNCOMMITTED”、“READ COMMITTED”、“REPEATABLE
    READ”和“SERIALIZABLE”。这些通常在DBAPI连接开始新事务之前应用，注意大多数DBAPI在首次发出SQL语句时会隐式地开始此事务。
- en: DBAPIs that support isolation levels also usually support the concept of true
    “autocommit”, which means that the DBAPI connection itself will be placed into
    a non-transactional autocommit mode. This usually means that the typical DBAPI
    behavior of emitting “BEGIN” to the database automatically no longer occurs, but
    it may also include other directives. When using this mode, **the DBAPI does not
    use a transaction under any circumstances**. SQLAlchemy methods like `.begin()`,
    `.commit()` and `.rollback()` pass silently.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 支持隔离级别的 DBAPI 通常也支持真正的“自动提交”概念，这意味着 DBAPI 连接本身将被放置到非事务自动提交模式中。这通常意味着数据库自动不再发出“BEGIN”，但也可能包括其他指令。使用此模式时，**DBAPI
    在任何情况下都不使用事务**。SQLAlchemy 方法如`.begin()`、`.commit()`和`.rollback()`会悄无声息地传递。
- en: SQLAlchemy’s dialects support settable isolation modes on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis, using flags at both the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level as well as at the [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") level.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的方言支持在每个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或每个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 上设置可设置的隔离模式，使用的标志既可以在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")级别，也可以在[`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")级别。
- en: When using the ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it acts as a *facade* for engines and connections, but does not expose transaction
    isolation directly. So in order to affect transaction isolation level, we need
    to act upon the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    as appropriate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，它充当引擎和连接的*门面*，但不直接暴露事务隔离。因此，为了影响事务隔离级别，我们需要在适当的时候对[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")进行操作。
- en: See also
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 也请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    - be sure to review how isolation levels work at the level of the SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as well.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括 DBAPI 自动提交](../core/connections.html#dbapi-autocommit) - 一定要查看
    SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象级别上隔离级别的工作方式。'
- en: '#### Setting Isolation For A Sessionmaker / Engine Wide'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 设置会话/引擎范围的隔离级别'
- en: 'To set up a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    with a specific isolation level globally, the first technique is that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be constructed against a specific isolation level
    in all cases, which is then used as the source of connectivity for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and/or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局设置一个具有特定隔离级别的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")，第一种技术是可以在所有情况下构造一个具有特定隔离级别的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，然后将其用作[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和/或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")的连接来源：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Another option, useful if there are to be two engines with different isolation
    levels at once, is to use the [`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, which will produce a shallow
    copy of the original [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which shares the same connection pool as the parent
    engine. This is often preferable when operations will be separated into “transactional”
    and “autocommit” operations:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，如果同时存在两个具有不同隔离级别的引擎，可以使用[`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")方法，该方法将生成原始[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的浅拷贝，该浅拷贝与父引擎共享相同的连接池。当操作将被分为“事务”和“自动提交”操作时，通常更可取：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Above, both “`eng`” and `"autocommit_engine"` share the same dialect and connection
    pool. However the “AUTOCOMMIT” mode will be set upon connections when they are
    acquired from the `autocommit_engine`. The two [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") objects “`transactional_session`” and “`autocommit_session"`
    then inherit these characteristics when they work with database connections.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，“`eng`”和“`autocommit_engine`”共享相同的方言和连接池。然而，当从`autocommit_engine`获取连接时，将设置“AUTOCOMMIT”模式。然后，这两个[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象“`transactional_session`”和“`autocommit_session`”在与数据库连接一起工作时继承这些特性。
- en: 'The “`autocommit_session`” **continues to have transactional semantics**, including
    that [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    still consider themselves to be “committing” and “rolling back” objects, however
    the transaction will be silently absent. For this reason, **it is typical, though
    not strictly required, that a Session with AUTOCOMMIT isolation be used in a read-only
    fashion**, that is:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: “`autocommit_session`” **保持事务语义**，包括[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")仍然认为自己是“提交”和“回滚”对象，但事务将会静默不存在。因此，**通常情况下，尽管不是严格要求，但一个具有
    AUTOCOMMIT 隔离级别的 Session 应该以只读方式使用**，即：
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Setting Isolation for Individual Sessions
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为单个 Session 设置隔离级别
- en: 'When we make a new [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    either using the constructor directly or when we call upon the callable produced
    by a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker"),
    we can pass the `bind` argument directly, overriding the pre-existing bind. We
    can for example create our [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from a default [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") and pass an engine set for autocommit:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，可以直接传递`bind`参数，覆盖预先存在的绑定，无论是直接使用构造函数还是调用由[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")产生的可调用对象。例如，我们可以从默认的[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")创建我们的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")并传递一个设置为自动提交的引擎：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For the case where the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is configured with multiple “binds”, we can either
    re-specify the `binds` argument fully, or if we want to only replace specific
    binds, we can use the [`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper") or [`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table") methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置有多个“binds”的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")的情况，我们可以重新指定完整的`binds`参数，或者如果我们只想替换特定的绑定，我们可以使用[`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper")或[`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table")方法：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Setting Isolation for Individual Transactions
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为单个事务设置隔离级别
- en: A key caveat regarding isolation level is that the setting cannot be safely
    modified on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") where a transaction has already started. Databases
    cannot change the isolation level of a transaction in progress, and some DBAPIs
    and SQLAlchemy dialects have inconsistent behaviors in this area.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隔离级别的一个关键注意事项是，不能在已经启动事务的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 上安全地修改设置。数据库无法更改正在进行的事务的隔离级别，并且一些 DBAPI 和 SQLAlchemy
    方言在这个领域的行为不一致。
- en: 'Therefore it is preferable to use a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is up front bound to an engine with the desired
    isolation level. However, the isolation level on a per-connection basis can be
    affected by using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method at the start of a transaction:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此最好使用一个最初绑定到具有所需隔离级别的引擎的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。但是，通过在事务开始时使用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 方法，可以影响每个连接的隔离级别：
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Above, we first produce a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using either the constructor or a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"). Then we explicitly set up the start of a database-level
    transaction by calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection"), which provides for execution options that
    will be passed to the connection before the database-level transaction is begun.
    The transaction proceeds with this selected isolation level. When the transaction
    completes, the isolation level is reset on the connection to its default before
    the connection is returned to the connection pool.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们首先使用构造函数或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 生成一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然后，通过调用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 明确设置数据库级事务的开始，该方法提供了将传递给连接的执行选项，在开始数据库级事务之前。事务使用此选择的隔离级别进行。当事务完成时，连接上的隔离级别将重置为默认值，然后将连接返回到连接池。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method may also be used to begin the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") level transaction; calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") subsequent to that call may be used to set
    up the per-connection-transaction isolation level:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法也可用于开始 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    级事务；在此调用之后调用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 可以用于设置每个连接的事务隔离级别：'
- en: '[PRE80]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '#### Setting Isolation For A Sessionmaker / Engine Wide'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为 Sessionmaker / Engine 设置隔离级别'
- en: 'To set up a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    with a specific isolation level globally, the first technique is that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be constructed against a specific isolation level
    in all cases, which is then used as the source of connectivity for a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and/or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    全局设置特定的隔离级别，第一种技术是可以在所有情况下构建一个针对特定隔离级别的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，然后将其用作 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 和/或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 的连接来源：
- en: '[PRE81]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another option, useful if there are to be two engines with different isolation
    levels at once, is to use the [`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, which will produce a shallow
    copy of the original [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which shares the same connection pool as the parent
    engine. This is often preferable when operations will be separated into “transactional”
    and “autocommit” operations:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，如果同时有两个具有不同隔离级别的引擎，则可以使用[`Engine.execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")方法，它将生成原始[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的浅拷贝，与父引擎共享相同的连接池。当操作将分成“事务”和“自动提交”操作时，这通常是首选：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Above, both “`eng`” and `"autocommit_engine"` share the same dialect and connection
    pool. However the “AUTOCOMMIT” mode will be set upon connections when they are
    acquired from the `autocommit_engine`. The two [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") objects “`transactional_session`” and “`autocommit_session"`
    then inherit these characteristics when they work with database connections.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，“`eng`”和“`autocommit_engine`”都共享相同的方言和连接池。然而，当从`autocommit_engine`获取连接时，将设置“AUTOCOMMIT”模式。然后，当这两个[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象“`transactional_session`”和“`autocommit_session`”与数据库连接一起工作时，它们继承了这些特征。
- en: 'The “`autocommit_session`” **continues to have transactional semantics**, including
    that [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    still consider themselves to be “committing” and “rolling back” objects, however
    the transaction will be silently absent. For this reason, **it is typical, though
    not strictly required, that a Session with AUTOCOMMIT isolation be used in a read-only
    fashion**, that is:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: “`autocommit_session`”**仍然具有事务语义**，包括当它们从`autocommit_engine`获取时，[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")仍然认为自己是“提交”和“回滚”对象，但事务将默默地不存在。因此，**通常，虽然不是严格要求，但具有AUTOCOMMIT隔离的会话应该以只读方式使用**，即：
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Setting Isolation for Individual Sessions
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为单个会话设置隔离
- en: 'When we make a new [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    either using the constructor directly or when we call upon the callable produced
    by a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker"),
    we can pass the `bind` argument directly, overriding the pre-existing bind. We
    can for example create our [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from a default [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") and pass an engine set for autocommit:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，可以直接传递`bind`参数，覆盖预先存在的绑定。例如，我们可以从默认的[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")创建我们的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，并传递设置为自动提交的引擎：
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For the case where the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is configured with multiple “binds”, we can either
    re-specify the `binds` argument fully, or if we want to only replace specific
    binds, we can use the [`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper") or [`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table") methods:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置了多个“binds”的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")的情况，我们可以重新完全指定`binds`参数，或者如果我们只想替换特定的绑定，我们可以使用[`Session.bind_mapper()`](session_api.html#sqlalchemy.orm.Session.bind_mapper
    "sqlalchemy.orm.Session.bind_mapper")或[`Session.bind_table()`](session_api.html#sqlalchemy.orm.Session.bind_table
    "sqlalchemy.orm.Session.bind_table")方法：
- en: '[PRE85]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Setting Isolation for Individual Transactions
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为单个事务设置隔离
- en: A key caveat regarding isolation level is that the setting cannot be safely
    modified on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") where a transaction has already started. Databases
    cannot change the isolation level of a transaction in progress, and some DBAPIs
    and SQLAlchemy dialects have inconsistent behaviors in this area.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隔离级别的一个关键警告是，在已经开始事务的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 上无法安全地修改设置。数据库无法更改正在进行的事务的隔离级别，并且一些 DBAPI 和 SQLAlchemy
    方言在这个领域的行为不一致。
- en: 'Therefore it is preferable to use a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is up front bound to an engine with the desired
    isolation level. However, the isolation level on a per-connection basis can be
    affected by using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method at the start of a transaction:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用一个明确绑定到具有所需隔离级别的引擎的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。但是，可以通过在事务开始时使用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 方法来影响每个连接的隔离级别：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Above, we first produce a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using either the constructor or a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"). Then we explicitly set up the start of a database-level
    transaction by calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection"), which provides for execution options that
    will be passed to the connection before the database-level transaction is begun.
    The transaction proceeds with this selected isolation level. When the transaction
    completes, the isolation level is reset on the connection to its default before
    the connection is returned to the connection pool.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们首先使用构造函数或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 来生成一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。然后，我们通过调用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 显式设置数据库级事务的开始，该方法提供将在开始数据库级事务之前传递给连接的执行选项。事务会以此选定的隔离级别继续进行。当事务完成时，连接上的隔离级别将被重置为其默认值，然后连接将返回到连接池。
- en: 'The [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    method may also be used to begin the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") level transaction; calling upon [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") subsequent to that call may be used to set
    up the per-connection-transaction isolation level:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法也可用于开始 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    级别的事务；在此调用之后调用 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 可用于设置每个连接的事务隔离级别：'
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Tracking Transaction State with Events
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件跟踪事务状态
- en: See the section [Transaction Events](session_events.html#session-transaction-events)
    for an overview of the available event hooks for session transaction state changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [事务事件](session_events.html#session-transaction-events) 部分，了解会话事务状态更改的可用事件挂钩的概述。
- en: '## Joining a Session into an External Transaction (such as for test suites)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将会话加入到外部事务（例如用于测试套件）'
- en: If a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is being used which is already in a transactional state (i.e. has a [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") established), a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be made to participate within that transaction by
    just binding the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to that [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    The usual rationale for this is a test suite that allows ORM code to work freely
    with a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    including the ability to call [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), where afterwards the entire database interaction
    is rolled back.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")已经处于事务状态（即已建立[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")），则可以通过将[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")绑定到该[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")来使[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")参与该事务。通常的理由是一个测试套件允许ORM代码自由地与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一起工作，包括能够调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，之后整个数据库交互都被回滚。
- en: 'Changed in version 2.0: The “join into an external transaction” recipe is newly
    improved again in 2.0; event handlers to “reset” the nested transaction are no
    longer required.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：在 2.0 中，“加入外部事务”配方再次得到了改进；不再需要事件处理程序来“重置”嵌套事务。
- en: The recipe works by establishing a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") within a transaction and optionally a SAVEPOINT,
    then passing it to a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as the “bind”; the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter is passed with the setting `"create_savepoint"`,
    which indicates that new SAVEPOINTs should be created in order to implement BEGIN/COMMIT/ROLLBACK
    for the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which will leave the external transaction in the same state in which it was passed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方通过在事务内部建立[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")（可选地建立SAVEPOINT），然后将其传递给[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")作为“bind”来实现；传递了[`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")参数，设置为`"create_savepoint"`，这表示应创建新的SAVEPOINT以实现[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的BEGIN/COMMIT/ROLLBACK，这将使外部事务保持与传递时相同的状态。
- en: 'When the test tears down, the external transaction is rolled back so that any
    data changes throughout the test are reverted:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试拆卸时，外部事务将被回滚，以便撤消测试期间的任何数据更改：
- en: '[PRE88]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The above recipe is part of SQLAlchemy’s own CI to ensure that it remains working
    as expected.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配方是SQLAlchemy自身CI的一部分，以确保其按预期工作。
