- en: Working with Database Metadata
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据库元数据
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/metadata.html](https://docs.sqlalchemy.org/en/20/tutorial/metadata.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/metadata.html](https://docs.sqlalchemy.org/en/20/tutorial/metadata.html)
- en: With engines and SQL execution down, we are ready to begin some Alchemy. The
    central element of both SQLAlchemy Core and ORM is the SQL Expression Language
    which allows for fluent, composable construction of SQL queries. The foundation
    for these queries are Python objects that represent database concepts like tables
    and columns. These objects are known collectively as [database metadata](../glossary.html#term-database-metadata).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着引擎和SQL执行完成，我们准备开始一些Alchemy。SQLAlchemy Core和ORM的核心元素是SQL表达语言，它允许流畅、可组合地构建SQL查询。这些查询的基础是代表数据库概念（如表和列）的Python对象。这些对象被统称为[数据库元数据](../glossary.html#term-database-metadata)。
- en: The most common foundational objects for database metadata in SQLAlchemy are
    known as [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData"),
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column").
    The sections below will illustrate how these objects are used in both a Core-oriented
    style as well as an ORM-oriented style.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中数据库元数据的最常见基础对象称为[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")、[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。下面的部分将说明这些对象在Core导向风格和ORM导向风格中的使用方式。
- en: '**ORM readers, stay with us!**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**ORM读者，请继续关注！**'
- en: As with other sections, Core users can skip the ORM sections, but ORM users
    would best be familiar with these objects from both perspectives. The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object discussed here is declared in a more indirect
    (and also fully Python-typed) way when using the ORM, however there is still a
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object within the ORM’s configuration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他部分一样，Core用户可以跳过ORM部分，但ORM用户最好从两个角度熟悉这些对象。这里讨论的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象在使用ORM时以一种更间接的方式（也是完全Python类型化的方式）声明，然而，在ORM的配置中仍然有一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。
- en: '## Setting up MetaData with Table objects'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用表对象设置元数据'
- en: When we work with a relational database, the basic data-holding structure in
    the database which we query from is known as a **table**. In SQLAlchemy, the database
    “table” is ultimately represented by a Python object similarly named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用关系型数据库时，数据库中的基本数据保存结构，我们从中查询的结构称为**表**。在SQLAlchemy中，数据库“表”最终由一个名为[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的Python对象表示。
- en: To start using the SQLAlchemy Expression Language, we will want to have [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects constructed that represent all of the database
    tables we are interested in working with. The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is constructed programmatically, either directly by
    using the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    constructor, or indirectly by using ORM Mapped classes (described later at [Using
    ORM Declarative Forms to Define Table Metadata](#tutorial-orm-table-metadata)).
    There is also the option to load some or all table information from an existing
    database, called [reflection](../glossary.html#term-reflection).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用SQLAlchemy表达语言，我们需要构建[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，这些对象表示我们有兴趣使用的所有数据库表。 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")是通过编程方式构建的，可以直接使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数，也可以间接地使用ORM映射类（稍后在[使用ORM声明形式定义表元数据](#tutorial-orm-table-metadata)中描述）。还有一种选项可以从现有数据库加载一些或全部表信息，称为[反射](../glossary.html#term-reflection)。
- en: 'Whichever kind of approach is used, we always start out with a collection that
    will be where we place our tables known as the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object. This object is essentially a [facade](../glossary.html#term-facade)
    around a Python dictionary that stores a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects keyed to their string name. While the ORM provides
    some options on where to get this collection, we always have the option to simply
    make one directly, which looks like:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法，我们始终从一个集合开始，这个集合将是我们放置表的地方，称为 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象。这个对象本质上是一个围绕 Python 字典的 [外观](../glossary.html#term-facade)，该字典存储了一系列以其字符串名称为键的
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象。虽然 ORM 在获取这个集合的位置上提供了一些选项，但我们始终可以选择直接创建一个，看起来像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, we can declare some [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. This tutorial will start with the classic
    SQLAlchemy tutorial model, which has a table called `user_account` that stores,
    for example, the users of a website, and a related table `address`, which stores
    email addresses associated with rows in the `user_account` table. When not using
    ORM Declarative models at all, we construct each [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object directly, typically assigning each to a variable
    that will be how we will refer to the table in application code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    对象，我们可以声明一些 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象。本教程将从经典的 SQLAlchemy 教程模型开始，其中有一个名为 `user_account` 的表，存储着网站的用户，以及一个相关的 `address`
    表，存储着与 `user_account` 表中的行相关联的电子邮件地址。当完全不使用 ORM Declarative 模型时，我们直接构造每个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，通常将每个对象分配给一个变量，这将是我们在应用程序代码中引用表的方式：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the above example, when we wish to write code that refers to the `user_account`
    table in the database, we will use the `user_table` Python variable to refer to
    it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上面的例子，当我们希望编写引用数据库中 `user_account` 表的代码时，我们将使用 `user_table` Python 变量来引用它。
- en: Components of `Table`
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table` 的组件'
- en: 'We can observe that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct as written in Python has a resemblance to
    a SQL CREATE TABLE statement; starting with the table name, then listing out each
    column, where each column has a name and a datatype. The objects we use above
    are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，Python 中的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    构造与 SQL CREATE TABLE 语句相似；从表名开始，然后列出每个列，其中每个列都有一个名称和一个数据类型。我们上面使用的对象是：
- en: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - represents a database table and assigns itself to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - 表示数据库表并将自己分配给 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合。'
- en: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - represents a column in a database table, and assigns itself to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") usually includes a string name and a type object.
    The collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects in terms of the parent [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are typically accessed via an associative array located
    at [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c"):'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - 表示数据库表中的列，并将自己分配给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象。[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    通常包括一个字符串名称和一个类型对象。以父 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的集合通常通过位于 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") 的关联数组来访问：'
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer"),
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    - these classes represent SQL datatypes and can be passed to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with or without necessarily being instantiated. Above,
    we want to give a length of “30” to the “name” column, so we instantiated `String(30)`.
    But for “id” and “fullname” we did not specify these, so we can send the class
    itself.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")，[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") - 这些类表示SQL数据类型，并且可以被传递给具有或没有必要被实例化的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。在上面的例子中，我们想要给“name”列一个长度为“30”，因此我们实例化了`String(30)`。但对于“id”和“fullname”，我们没有指定这些，所以我们可以发送类本身。'
- en: See also
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The reference and API documentation for [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is at [Describing Databases with MetaData](../core/metadata.html).
    The reference documentation for datatypes is at [SQL Datatype Objects](../core/types.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的参考和API文档位于[用MetaData描述数据库](../core/metadata.html)。数据类型的参考文档位于[SQL数据类型对象](../core/types.html)。'
- en: In an upcoming section, we will illustrate one of the fundamental functions
    of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    which is to generate [DDL](../glossary.html#term-DDL) on a particular database
    connection. But first we will declare a second [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一节中，我们将说明[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")的一个基本功能，即在特定数据库连接上生成[DDL](../glossary.html#term-DDL)。但首先，我们将声明第二个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: Declaring Simple Constraints
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明简单约束
- en: 'The first [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    in the example `user_table` includes the [`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") parameter which is a shorthand technique of indicating
    that this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    should be part of the primary key for this table. The primary key itself is normally
    declared implicitly and is represented by the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct, which we can see on the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute on the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")在`user_table`中包含[`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column")参数，这是一种简写技术，表示这个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")应该是这个表的主键的一部分。主键本身通常是隐式声明的，并且由[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")构造表示，我们可以在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的[`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key")属性上看到它：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constraint that is most typically declared explicitly is the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that corresponds to a database
    [foreign key constraint](../glossary.html#term-foreign-key-constraint). When we
    declare tables that are related to each other, SQLAlchemy uses the presence of
    these foreign key constraint declarations not only so that they are emitted within
    CREATE statements to the database, but also to assist in constructing SQL expressions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最常显式声明的约束是对应于数据库[外键约束](../glossary.html#term-foreign-key-constraint)的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象。当我们声明相互关联的表时，SQLAlchemy不仅使用这些外键约束声明在向数据库发送CREATE语句时将其发送出去，而且还用于帮助构造SQL表达式。
- en: 'A [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that involves only a single column on
    the target table is typically declared using a column-level shorthand notation
    via the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object. Below we declare a second table `address` that will have a foreign key
    constraint referring to the `user` table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个涉及目标表上仅一个列的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")通常使用列级别的速记符号通过[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象声明。下面我们声明了一个将具有引用`user`表的外键约束的第二个表`address`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The table above also features a third kind of constraint, which in SQL is the
    “NOT NULL” constraint, indicated above using the [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的表还包含了第三种约束类型，在SQL中是“NOT NULL”约束，在上面使用[`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column")参数进行指示。
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object within a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") definition, we can omit the datatype for that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); it is automatically inferred from that of the related
    column, in the above example the [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") datatype of the `user_account.id` column.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")定义中使用[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象时，我们可以省略该[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的数据类型；它会自动从相关列的数据类型中推断出来，在上面的示例中是`user_account.id`列的[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")数据类型。
- en: In the next section we will emit the completed DDL for the `user` and `address`
    table to see the completed result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将发出`user`和`address`表的完整DDL以查看完成的结果。
- en: '### Emitting DDL to the Database'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '### 发出DDL到数据库'
- en: We’ve constructed an object structure that represents two database tables in
    a database, starting at the root [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, then into two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, each of which hold onto a collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects. This object structure will be at the
    center of most operations we perform with both Core and ORM going forward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个对象结构，代表数据库中的两个数据库表，在根[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象开始，然后进入两个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，每个对象都包含一组[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")和[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象。这个对象结构将成为我们今后使用Core和ORM执行的大多数操作的中心。
- en: 'The first useful thing we can do with this structure will be to emit CREATE
    TABLE statements, or [DDL](../glossary.html#term-DDL), to our SQLite database
    so that we can insert and query data from them. We have already all the tools
    needed to do so, by invoking the [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") method on our [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), sending it the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that refers to the target database:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对此结构进行的第一个有用的操作是发出CREATE TABLE语句，或者[DDL](../glossary.html#term-DDL)到我们的SQLite数据库，以便我们可以从中插入和查询数据。我们已经拥有完成此操作所需的所有工具，通过在我们的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")上调用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")方法，将目标数据库的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")传递给它：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The DDL create process above includes some SQLite-specific PRAGMA statements
    that test for the existence of each table before emitting a CREATE. The full series
    of steps are also included within a BEGIN/COMMIT pair to accommodate for transactional
    DDL.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以上的 DDL 创建过程包括一些 SQLite 特定的 PRAGMA 语句，用于在发出 CREATE 之前测试每个表的存在性。所有步骤也包含在 BEGIN/COMMIT
    对中，以适应事务性 DDL。
- en: The create process also takes care of emitting CREATE statements in the correct
    order; above, the FOREIGN KEY constraint is dependent on the `user` table existing,
    so the `address` table is created second. In more complicated dependency scenarios
    the FOREIGN KEY constraints may also be applied to tables after the fact using
    ALTER.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: create 进程还负责按正确顺序发出 CREATE 语句；以上，FOREIGN KEY 约束依赖于 `user` 表的存在，因此 `address`
    表在第二创建。在更复杂的依赖情况下，FOREIGN KEY 约束也可能使用 ALTER 在表创建后进行应用。
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object also features a [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") method that will emit DROP statements in
    the reverse order as it would emit CREATE in order to drop schema elements.  ##
    Using ORM Declarative Forms to Define Table Metadata'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    对象还具有一个 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 方法，它将按照与发出 CREATE 相反的顺序发出 DROP 语句以删除模式元素。##
    使用 ORM 声明式表单定义表元数据'
- en: When using the ORM, the process by which we declare [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata is usually combined with the process of declaring
    [mapped](../glossary.html#term-mapped) classes. The mapped class is any Python
    class we’d like to create, which will then have attributes on it that will be
    linked to the columns in a database table. While there are a few varieties of
    how this is achieved, the most common style is known as [declarative](../orm/declarative_config.html),
    and allows us to declare our user-defined classes and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata at once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 时，声明 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据的过程通常与声明 [映射](../glossary.html#term-mapped) 类的过程结合在一起。映射类是我们想要创建的任何 Python
    类，然后它将具有链接到数据库表中列的属性。虽然有几种实现方式，但最常见的风格称为 [声明式](../orm/declarative_config.html)，它允许我们一次声明我们的用户定义类和
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据。
- en: '### Establishing a Declarative Base'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '### 建立声明性基础'
- en: 'When using the ORM, the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection remains present, however it itself is
    associated with an ORM-only construct commonly referred towards as the **Declarative
    Base**. The most expedient way to acquire a new Declarative Base is to create
    a new class that subclasses the SQLAlchemy [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 时，[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合仍然存在，但它本身与一个仅用于 ORM 的构造关联，通常称为 **声明式基础**。获取新的声明式基础的最简便方法是创建一个继承 SQLAlchemy [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类的新类：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Above, the `Base` class is what we’ll call the Declarative Base. When we make
    new classes that are subclasses of `Base`, combined with appropriate class-level
    directives, they will each be established as a new **ORM mapped class** at class
    creation time, each one typically (but not exclusively) referring to a particular
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，`Base` 类就是我们将称为声明式基础的类。当我们创建新的类作为 `Base` 的子类时，并结合适当的类级指令，它们将在类创建时各自作为一个新的
    **ORM 映射类** 建立，每个类通常（但不一定）引用一个特定的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象。
- en: 'The Declarative Base refers to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection that is created for us automatically,
    assuming we didn’t provide one from the outside. This [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection is accessible via the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") class-level attribute. As we create
    new mapped classes, they each will reference a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") within this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Declarative Base 指的是一个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合，它会自动为我们创建，假设我们没有从外部提供。这个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合可以通过[`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata")类级别属性访问。当我们创建新的映射类时，它们将分别引用此[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合内的一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Declarative Base also refers to a collection called [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which is the central “mapper configuration” unit in
    the SQLAlchemy ORM. While seldom accessed directly, this object is central to
    the mapper configuration process, as a set of ORM mapped classes will coordinate
    with each other via this registry. As was the case with [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), our Declarative Base also created a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") for us (again with options to pass our own [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")), which we can access via the [`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry") class variable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Declarative Base 还指的是一个称为[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")的集合，它是 SQLAlchemy ORM 中的中央“映射器配置”单元。虽然很少直接访问，但该对象在映射器配置过程中是至关重要的，因为一组
    ORM 映射类将通过此注册表相互协调。与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")的情况一样，我们的 Declarative Base 也为我们创建了一个[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")（再次提供自己的[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")的选项），我们可以通过[`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry")类变量访问它：
- en: '[PRE8]  ### Declaring Mapped Classes'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]  ### 声明映射类'
- en: 'With the `Base` class established, we can now define ORM mapped classes for
    the `user_account` and `address` tables in terms of new classes `User` and `Address`.
    We illustrate below the most modern form of Declarative, which is driven from
    [**PEP 484**](https://peps.python.org/pep-0484/) type annotations using a special
    type [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"),
    which indicates attributes to be mapped as particular types:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Base`类的设立，我们现在可以根据新类`User`和`Address`定义`user_account`和`address`表的 ORM 映射类。我们下面展示了最现代化的
    Declarative 形式，它是从[**PEP 484**](https://peps.python.org/pep-0484/)类型注解中驱动的，使用了一个特殊类型[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")，它指示要映射为特定类型的属性：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The two classes above, `User` and `Address`, are now called as **ORM Mapped
    Classes**, and are available for use in ORM persistence and query operations,
    which will be described later. Details about these classes include:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个类`User`和`Address`现在被称为**ORM 映射类**，并且可以在 ORM 持久性和查询操作中使用，稍后将对这些类的详细信息进行描述：
- en: Each class refers to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that was generated as part of the declarative
    mapping process, which is named by assigning a string to the [`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__") attribute. Once the class is created,
    this generated [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is available from the [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__") attribute.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类都指向一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，该对象是作为声明性映射过程的一部分生成的，并通过将字符串赋值给[`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__")属性命名。一旦类被创建，这个生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")可以通过[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")属性进行访问。
- en: As mentioned previously, this form is known as [Declarative Table Configuration](../orm/declarative_tables.html#orm-declarative-table-configuration).
    One of several alternative declaration styles would instead have us build the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object directly, and **assign** it directly to [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__"). This style is known as [Declarative
    with Imperative Table](../orm/declarative_tables.html#orm-imperative-table-configuration).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，这种形式被称为[声明性表配置](../orm/declarative_tables.html#orm-declarative-table-configuration)。数种替代声明风格之一会让我们直接构建[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，并直接将其分配给[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")。这种风格被称为[声明性与命令式表配置](../orm/declarative_tables.html#orm-imperative-table-configuration)。
- en: To indicate columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), we use the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in combination with typing annotations
    based on the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type. This object will generate [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are applied to the construction of the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指示[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")中的列，我们使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，结合基于[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型的类型注释。此对象将生成应用于[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: For columns with simple datatypes and no other options, we can indicate a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation alone, using simple Python types like
    `int` and `str` to mean [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") and [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"). Customization of how Python types are interpreted
    within the Declarative mapping process is very open ended; see the sections [Using
    Annotated Declarative Table (Type Annotated Forms for mapped_column())](../orm/declarative_tables.html#orm-declarative-mapped-column)
    and [Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    for background.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单数据类型且没有其他选项的列，我们可以单独指定[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释，使用简单的 Python 类型如`int`和`str`表示[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")和[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")。在声明性映射过程中，如何解释 Python 类型的定制化是非常开放的；请参阅[使用注释的声明性表（用于`mapped_column()`的类型注释形式）](../orm/declarative_tables.html#orm-declarative-mapped-column)和[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)部分了解背景知识。
- en: A column can be declared as “nullable” or “not null” based on the presence of
    the `Optional[<typ>]` type annotation (or its equivalents, `<typ> | None` or `Union[<typ>,
    None]`). The [`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter may also be used explicitly (and does
    not have to match the annotation’s optionality).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`Optional[<typ>]`类型注释（或其等效形式，`<typ> | None`或`Union[<typ>, None]`）的存在，可以将列声明为“可空”或“非空”。还可以显式使用[`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数（不必与注释的可选性匹配）。
- en: Use of explicit typing annotations is **completely optional**. We can also use
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    without annotations. When using this form, we would use more explicit type objects
    like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    and [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    as well as `nullable=False` as needed within each [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式类型注释是**完全可选的**。我们也可以在没有注释的情况下使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。在使用这种形式时，我们会根据需要在每个[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造内使用更明确的类型对象，如[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")和[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")以及`nullable=False`。
- en: Two additional attributes, `User.addresses` and `Address.user`, define a different
    kind of attribute called [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), which features similar annotation-aware configuration
    styles as shown. The [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is discussed more fully at [Working with
    ORM Related Objects](orm_related_objects.html#tutorial-orm-related-objects).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外两个属性，`User.addresses`和`Address.user`，定义了一种不同类型的属性，称为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，它具有与注释相似的配置样式。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造在[使用ORM相关对象](orm_related_objects.html#tutorial-orm-related-objects)中有更详细的讨论。
- en: 'The classes are automatically given an `__init__()` method if we don’t declare
    one of our own. The default form of this method accepts all attribute names as
    optional keyword arguments:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有声明自己的`__init__()`方法，则会自动为类添加一个`__init__()`方法。该方法的默认形式接受所有属性名称作为可选关键字参数：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To automatically generate a full-featured `__init__()` method which provides
    for positional arguments as well as arguments with default keyword values, the
    dataclasses feature introduced at [Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    may be used. It’s of course always an option to use an explicit `__init__()` method
    as well.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要自动生成一个全功能的`__init__()`方法，既提供位置参数又提供具有默认关键字值的参数，可以使用在[声明式数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)中引入的数据类功能。当然，始终可以选择使用显式的`__init__()`方法。
- en: The `__repr__()` methods are added so that we get a readable string output;
    there’s no requirement for these methods to be here. As is the case with `__init__()`,
    a `__repr__()` method can be generated automatically by using the [dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    feature.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`__repr__()`方法是为了获得可读的字符串输出；这些方法不需要存在的要求。与`__init__()`一样，可以使用[dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)功能自动生成`__repr__()`方法。
- en: See also
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Mapping Styles](../orm/mapping_styles.html#orm-mapping-styles) - full
    background on different ORM configurational styles.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM映射风格](../orm/mapping_styles.html#orm-mapping-styles) - 不同ORM配置风格的完整背景。'
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping) -
    overview of Declarative class mapping'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式映射](../orm/mapping_styles.html#orm-declarative-mapping) - 声明式类映射概述'
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - detail on how to use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to define the columns within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be mapped when using Declarative.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用`mapped_column()`的声明式表](../orm/declarative_tables.html#orm-declarative-table)
    - 详细说明如何使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")来定义在使用声明式时要映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")中的列。'
- en: Emitting DDL to the database from an ORM mapping
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从ORM映射向数据库发出DDL
- en: 'As our ORM mapped classes refer to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects contained within a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection, emitting DDL given the Declarative Base
    uses the same process as that described previously at [Emitting DDL to the Database](#tutorial-emitting-ddl).
    In our case, we have already generated the `user` and `address` tables in our
    SQLite database. If we had not done so already, we would be free to make use of
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    associated with our ORM Declarative Base class in order to do so, by accessing
    the collection from the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") attribute and then using [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") as before. In this case, PRAGMA statements
    are run, but no new tables are generated since they are found to be present already:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的ORM映射类引用包含在[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，所以根据声明式基类发出DDL与在[Emitting DDL to the Database](#tutorial-emitting-ddl)中描述的过程相同。在我们的情况下，我们已经在我们的SQLite数据库中生成了`user`和`address`表。如果我们之前没有这样做，我们可以自由地利用与我们的ORM声明基类相关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")来做到这一点，方法是通过访问[`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata")属性中的集合，然后像以前一样使用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")。在这种情况下，会运行PRAGMA语句，但不会生成新表，因为已经发现它们已经存在：
- en: '[PRE11]  ## Table Reflection'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]  ## 表反射'
- en: To round out the section on working with table metadata, we will illustrate
    another operation that was mentioned at the beginning of the section, that of
    **table reflection**. Table reflection refers to the process of generating [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and related objects by reading the current state of
    a database. Whereas in the previous sections we’ve been declaring [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in Python, where we then have the option to
    emit DDL to the database to generate such a schema, the reflection process does
    these two steps in reverse, starting from an existing database and generating
    in-Python data structures to represent the schemas within that database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成与表元数据一起工作的部分，我们将说明在该部分开头提到的另一个操作，即**表反射**。表反射是指通过读取数据库的当前状态来生成[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和相关对象的过程。而在之前的部分中，我们一直在Python中声明[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，然后有选择地将DDL发出到数据库以生成这样的模式，反射过程将这两个步骤反向执行，从现有数据库开始，并生成用于表示该数据库中模式的Python数据结构。
- en: Tip
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is no requirement that reflection must be used in order to use SQLAlchemy
    with a pre-existing database. It is entirely typical that the SQLAlchemy application
    declares all metadata explicitly in Python, such that its structure corresponds
    to that the existing database. The metadata structure also need not include tables,
    columns, or other constraints and constructs in the pre-existing database that
    are not needed for the local application to function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并非要求必须使用反射才能将SQLAlchemy与现有数据库一起使用。完全可以在Python中显式声明所有元数据，使其结构与现有数据库相对应，这是很典型的。元数据结构也不必包含表、列或其他在本地应用程序中不需要的预先存在数据库中的约束和构造。
- en: 'As an example of reflection, we will create a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object which represents the `some_table` object we
    created manually in the earlier sections of this document. There are again some
    varieties of how this is performed, however the most basic is to construct a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, given the name of the table and a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection to which it will belong, then instead
    of indicating individual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects, pass it the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") using the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为反射的示例，我们将创建一个新的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，该对象表示我们在本文档的前几节中手动创建的`some_table`对象。这样做的方式有很多种，但最基本的方式是构建一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，给定表的名称和它将属于的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合，然后不是指示单独的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")和[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象，而是传递目标[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")使用[`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table")参数：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end of the process, the `some_table` object now contains the information
    about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects present in the table, and the object is usable in exactly the same way
    as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that we declared explicitly:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的结尾，`some_table`对象现在包含了表中存在的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的信息，该对象可与我们明确声明的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")完全相同的方式使用：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read more about table and schema reflection at [Reflecting Database Objects](../core/reflection.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 了解有关表和模式反射的更多信息，请参阅[反射数据库对象](../core/reflection.html)。
- en: For ORM-related variants of table reflection, the section [Mapping Declaratively
    with Reflected Tables](../orm/declarative_tables.html#orm-declarative-reflected)
    includes an overview of the available options.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ORM相关的表反射变体，在[使用反射表声明映射](../orm/declarative_tables.html#orm-declarative-reflected)一节中包含了可用选项的概述。
- en: Next Steps
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: We now have a SQLite database ready to go with two tables present, and Core
    and ORM table-oriented constructs that we can use to interact with these tables
    via a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    and/or ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    In the following sections, we will illustrate how to create, manipulate, and select
    data using these structures.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个SQLite数据库准备好使用，其中有两个表存在，并且我们可以使用[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")和/或ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")通过Core和ORM表导向的构造与这些表进行交互。在接下来的章节中，我们将说明如何使用这些结构创建、操作和选择数据。
- en: '## Setting up MetaData with Table objects'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用Table对象设置MetaData'
- en: When we work with a relational database, the basic data-holding structure in
    the database which we query from is known as a **table**. In SQLAlchemy, the database
    “table” is ultimately represented by a Python object similarly named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用关系型数据库时，数据库中我们查询的基本数据持有结构被称为**表**。在SQLAlchemy中，数据库中的“表”最终由一个名为[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的Python对象表示。
- en: To start using the SQLAlchemy Expression Language, we will want to have [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects constructed that represent all of the database
    tables we are interested in working with. The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is constructed programmatically, either directly by
    using the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    constructor, or indirectly by using ORM Mapped classes (described later at [Using
    ORM Declarative Forms to Define Table Metadata](#tutorial-orm-table-metadata)).
    There is also the option to load some or all table information from an existing
    database, called [reflection](../glossary.html#term-reflection).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用SQLAlchemy表达式语言，我们将希望构建[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，这些对象代表我们有兴趣使用的所有数据库表。[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")是以编程方式构建的，可以直接使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数，也可以间接地使用ORM映射的类（稍后在[使用ORM声明形式定义表元数据](#tutorial-orm-table-metadata)中描述）。还可以选择从现有数据库加载一些或所有表信息，称为[反射](../glossary.html#term-reflection)。
- en: 'Whichever kind of approach is used, we always start out with a collection that
    will be where we place our tables known as the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object. This object is essentially a [facade](../glossary.html#term-facade)
    around a Python dictionary that stores a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects keyed to their string name. While the ORM provides
    some options on where to get this collection, we always have the option to simply
    make one directly, which looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用哪种方法，我们始终从一个集合开始，这个集合将是我们放置表的地方，称为[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象。这个对象本质上是一个Python字典的[外观](../glossary.html#term-facade)，它存储了一系列以它们的字符串名称为键的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。虽然ORM提供了一些选项来获取此集合，但我们始终有直接制作一个的选择，看起来像这样：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once we have a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, we can declare some [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. This tutorial will start with the classic
    SQLAlchemy tutorial model, which has a table called `user_account` that stores,
    for example, the users of a website, and a related table `address`, which stores
    email addresses associated with rows in the `user_account` table. When not using
    ORM Declarative models at all, we construct each [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object directly, typically assigning each to a variable
    that will be how we will refer to the table in application code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们有了[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象，我们就可以声明一些[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。本教程将从经典的SQLAlchemy教程模型开始，其中有一个名为`user_account`的表，该表存储网站的用户，以及一个相关的`address`表，该表存储与`user_account`表中的行关联的电子邮件地址。当完全不使用ORM声明模型时，我们直接构建每个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，通常将每个分配给将在应用程序代码中引用表的变量： '
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the above example, when we wish to write code that refers to the `user_account`
    table in the database, we will use the `user_table` Python variable to refer to
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上面的示例，当我们希望编写引用数据库中`user_account`表的代码时，我们将使用`user_table` Python变量来引用它。
- en: Components of `Table`
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table`的组成部分'
- en: 'We can observe that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct as written in Python has a resemblance to
    a SQL CREATE TABLE statement; starting with the table name, then listing out each
    column, where each column has a name and a datatype. The objects we use above
    are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，用Python编写的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造与SQL
    CREATE TABLE语句相似；从表名开始，然后列出每个列，每个列都有一个名称和一个数据类型。我们使用的对象包括：
- en: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - represents a database table and assigns itself to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - 表示数据库表并将自己分配给[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")集合。'
- en: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - represents a column in a database table, and assigns itself to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") usually includes a string name and a type object.
    The collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects in terms of the parent [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are typically accessed via an associative array located
    at [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c"):'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - 表示数据库表中的列，并将自身分配给[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象。[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")通常包括一个字符串名称和一个类型对象。关于父[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的集合通常通过位于[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")的关联数组进行访问：'
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer"),
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    - these classes represent SQL datatypes and can be passed to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with or without necessarily being instantiated. Above,
    we want to give a length of “30” to the “name” column, so we instantiated `String(30)`.
    But for “id” and “fullname” we did not specify these, so we can send the class
    itself.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")、[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") - 这些类表示 SQL 数据类型，可以带着或者不带着实例化传递给[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。在上面的例子中，我们想给“name”列指定长度为“30”，所以我们实例化了`String(30)`。但对于“id”和“fullname”，我们没有指定长度，所以我们可以直接发送类本身。'
- en: See also
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The reference and API documentation for [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is at [Describing Databases with MetaData](../core/metadata.html).
    The reference documentation for datatypes is at [SQL Datatype Objects](../core/types.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")、[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的参考文档和 API 文档在[使用 MetaData 描述数据库](../core/metadata.html)。数据类型的参考文档在[SQL
    数据类型对象](../core/types.html)。'
- en: In an upcoming section, we will illustrate one of the fundamental functions
    of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    which is to generate [DDL](../glossary.html#term-DDL) on a particular database
    connection. But first we will declare a second [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一节中，我们将说明[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")的一个基本功能，即在特定的数据库连接上生成[DDL](../glossary.html#term-DDL)。但首先我们将声明第二个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: Declaring Simple Constraints
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明简单的约束
- en: 'The first [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    in the example `user_table` includes the [`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") parameter which is a shorthand technique of indicating
    that this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    should be part of the primary key for this table. The primary key itself is normally
    declared implicitly and is represented by the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct, which we can see on the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute on the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中`user_table`的第一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")包括[`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column")参数，这是一种指示此[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")应该成为该表主键的简写技术。主键本身通常是隐式声明的，并由[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")构造表示，我们可以在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的[`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key")属性中看到：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The constraint that is most typically declared explicitly is the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that corresponds to a database
    [foreign key constraint](../glossary.html#term-foreign-key-constraint). When we
    declare tables that are related to each other, SQLAlchemy uses the presence of
    these foreign key constraint declarations not only so that they are emitted within
    CREATE statements to the database, but also to assist in constructing SQL expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最常明确声明的约束是与数据库[外键约束](../glossary.html#term-foreign-key-constraint)对应的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象。当我们声明相互关联的表时，SQLAlchemy使用这些外键约束声明的存在，不仅在将它们发射到数据库的CREATE语句中，还用于辅助构建SQL表达式。
- en: 'A [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that involves only a single column on
    the target table is typically declared using a column-level shorthand notation
    via the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object. Below we declare a second table `address` that will have a foreign key
    constraint referring to the `user` table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只涉及目标表上的单个列的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")通常使用列级别的简写表示法通过[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象声明。下面我们声明一个将引用`user`表的外键约束的第二个表`address`：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The table above also features a third kind of constraint, which in SQL is the
    “NOT NULL” constraint, indicated above using the [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表还包含第三种约束，这在SQL中是“NOT NULL”约束，上面使用[`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column")参数指示。
- en: Tip
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object within a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") definition, we can omit the datatype for that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); it is automatically inferred from that of the related
    column, in the above example the [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") datatype of the `user_account.id` column.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")定义中使用[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象时，我们可以省略该[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的数据类型；它将自动从相关列的数据类型推断出来，在上面的示例中为`user_account.id`列的[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")数据类型。
- en: In the next section we will emit the completed DDL for the `user` and `address`
    table to see the completed result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将发射完成的DDL到`user`和`address`表，以查看完成的结果。
- en: '### Emitting DDL to the Database'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '### 发射 DDL 到数据库'
- en: We’ve constructed an object structure that represents two database tables in
    a database, starting at the root [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, then into two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, each of which hold onto a collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects. This object structure will be at the
    center of most operations we perform with both Core and ORM going forward.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个对象结构，表示数据库中的两个数据库表，从根[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象开始，然后进入两个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，每个对象都包含一组[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")和[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象。这个对象结构将成为我们今后在 Core 和 ORM 中执行大多数操作的核心。
- en: 'The first useful thing we can do with this structure will be to emit CREATE
    TABLE statements, or [DDL](../glossary.html#term-DDL), to our SQLite database
    so that we can insert and query data from them. We have already all the tools
    needed to do so, by invoking the [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") method on our [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), sending it the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that refers to the target database:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个结构的第一项有用的事情是发出 CREATE TABLE 语句，或者[DDL](../glossary.html#term-DDL)到我们的
    SQLite 数据库中，以便我们可以向其中插入和查询数据。我们已经拥有完成这样做所需的所有工具，只需在我们的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")上调用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")方法，发送给它引用目标数据库的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The DDL create process above includes some SQLite-specific PRAGMA statements
    that test for the existence of each table before emitting a CREATE. The full series
    of steps are also included within a BEGIN/COMMIT pair to accommodate for transactional
    DDL.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 DDL 创建过程包括一些特定于 SQLite 的 PRAGMA 语句，用于测试每个表的存在性，然后发出 CREATE。全部步骤也包括在一个 BEGIN/COMMIT
    对中，以适应事务性 DDL。
- en: The create process also takes care of emitting CREATE statements in the correct
    order; above, the FOREIGN KEY constraint is dependent on the `user` table existing,
    so the `address` table is created second. In more complicated dependency scenarios
    the FOREIGN KEY constraints may also be applied to tables after the fact using
    ALTER.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建过程还负责按正确顺序发出 CREATE 语句；上面，FOREIGN KEY 约束依赖于`user`表的存在，因此`address`表第二个创建。在更复杂的依赖场景中，FOREIGN
    KEY 约束也可以在创建后使用 ALTER 应用于表。
- en: The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object also features a [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") method that will emit DROP statements in
    the reverse order as it would emit CREATE in order to drop schema elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象还具有一个[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")方法，它将按相反顺序发出 DROP 语句，以便删除模式元素，就像发出 CREATE
    语句一样。'
- en: Components of `Table`
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table` 的组件'
- en: 'We can observe that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct as written in Python has a resemblance to
    a SQL CREATE TABLE statement; starting with the table name, then listing out each
    column, where each column has a name and a datatype. The objects we use above
    are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，Python 中的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造与
    SQL CREATE TABLE 语句有些相似；从表名开始，然后列出每个列，其中每个列都有一个名称和一个数据类型。我们上面使用的对象是：
- en: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - represents a database table and assigns itself to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    - 表示数据库表，并将自己分配给[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合。'
- en: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - represents a column in a database table, and assigns itself to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") usually includes a string name and a type object.
    The collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects in terms of the parent [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are typically accessed via an associative array located
    at [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c"):'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    - 表示数据库表中的列，并将自身分配给一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象。[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")通常包括一个字符串名称和一个类型对象。关于父[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的集合通常通过位于[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")的关联数组来访问：'
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer"),
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    - these classes represent SQL datatypes and can be passed to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with or without necessarily being instantiated. Above,
    we want to give a length of “30” to the “name” column, so we instantiated `String(30)`.
    But for “id” and “fullname” we did not specify these, so we can send the class
    itself.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")，[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") - 这些类表示SQL数据类型，并且可以被传递给一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，无论是否被实例化。在上面的例子中，我们想给“name”列设置长度为“30”，所以我们实例化了`String(30)`。但是对于“id”和“fullname”，我们没有指定长度，所以我们可以直接发送类本身。'
- en: See also
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The reference and API documentation for [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is at [Describing Databases with MetaData](../core/metadata.html).
    The reference documentation for datatypes is at [SQL Datatype Objects](../core/types.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的参考文档和API文档位于[用MetaData描述数据库](../core/metadata.html)。数据类型的参考文档位于[SQL数据类型对象](../core/types.html)。
- en: In an upcoming section, we will illustrate one of the fundamental functions
    of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    which is to generate [DDL](../glossary.html#term-DDL) on a particular database
    connection. But first we will declare a second [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将说明[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")的一个基本功能，即在特定数据库连接上生成[DDL](../glossary.html#term-DDL)。但首先，我们将声明第二个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: Declaring Simple Constraints
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明简单约束
- en: 'The first [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    in the example `user_table` includes the [`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") parameter which is a shorthand technique of indicating
    that this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    should be part of the primary key for this table. The primary key itself is normally
    declared implicitly and is represented by the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct, which we can see on the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute on the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")包含了[`Column.primary_key`](../core/metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column")参数，这是一种简写技术，表示这个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")应该是这个表的主键的一部分。主键本身通常是隐式声明的，并且由[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")构造表示，我们可以在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的[`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key")属性上看到：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The constraint that is most typically declared explicitly is the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that corresponds to a database
    [foreign key constraint](../glossary.html#term-foreign-key-constraint). When we
    declare tables that are related to each other, SQLAlchemy uses the presence of
    these foreign key constraint declarations not only so that they are emitted within
    CREATE statements to the database, but also to assist in constructing SQL expressions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最常明确声明的约束是对应于数据库[外键约束](../glossary.html#term-foreign-key-constraint)的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象。当我们声明彼此相关的表时，SQLAlchemy 使用这些外键约束声明的存在不仅使它们在向数据库发送
    CREATE 语句时被发射，而且还有助于构建 SQL 表达式。
- en: 'A [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that involves only a single column on
    the target table is typically declared using a column-level shorthand notation
    via the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object. Below we declare a second table `address` that will have a foreign key
    constraint referring to the `user` table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只涉及目标表中的单个列的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")通常使用列级别的简写符号通过[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象声明。下面我们声明了一个第二个表`address`，它将有一个外键约束，指向`user`表：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The table above also features a third kind of constraint, which in SQL is the
    “NOT NULL” constraint, indicated above using the [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的表还具有第三种约束，这在 SQL 中是“NOT NULL”约束，在上面使用[`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column")参数指示。
- en: Tip
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object within a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") definition, we can omit the datatype for that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); it is automatically inferred from that of the related
    column, in the above example the [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") datatype of the `user_account.id` column.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")定义中使用[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象时，我们可以省略该[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的数据类型；它会自动从相关列的数据类型中推断出来，在上面的例子中是`user_account.id`列的[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")数据类型。
- en: In the next section we will emit the completed DDL for the `user` and `address`
    table to see the completed result.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将发送完成的`user`和`address`表的 DDL 以查看完成的结果。
- en: '### Emitting DDL to the Database'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '### 发送 DDL 到数据库'
- en: We’ve constructed an object structure that represents two database tables in
    a database, starting at the root [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, then into two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, each of which hold onto a collection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects. This object structure will be at the
    center of most operations we perform with both Core and ORM going forward.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个对象结构，表示数据库中的两个数据库表，从根[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象开始，然后进入两个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，每个对象都持有一组[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")和[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象的集合。这个对象结构将成为我们使用Core和ORM执行的大多数操作的中心。
- en: 'The first useful thing we can do with this structure will be to emit CREATE
    TABLE statements, or [DDL](../glossary.html#term-DDL), to our SQLite database
    so that we can insert and query data from them. We have already all the tools
    needed to do so, by invoking the [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") method on our [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), sending it the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that refers to the target database:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这个结构进行的第一项有用的事情是发出CREATE TABLE语句，或者[DDL](../glossary.html#term-DDL)到我们的SQLite数据库，这样我们就可以向其中插入和查询数据。我们已经拥有所有必要的工具来做到这一点，通过在我们的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")上调用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")方法，将指向目标数据库的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")传递给它：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The DDL create process above includes some SQLite-specific PRAGMA statements
    that test for the existence of each table before emitting a CREATE. The full series
    of steps are also included within a BEGIN/COMMIT pair to accommodate for transactional
    DDL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的DDL创建过程包括一些SQLite特定的PRAGMA语句，用于在发出CREATE之前测试每个表的存在。完整的步骤系列也包含在BEGIN/COMMIT对中，以适应事务性DDL。
- en: The create process also takes care of emitting CREATE statements in the correct
    order; above, the FOREIGN KEY constraint is dependent on the `user` table existing,
    so the `address` table is created second. In more complicated dependency scenarios
    the FOREIGN KEY constraints may also be applied to tables after the fact using
    ALTER.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建过程还负责按正确顺序发出CREATE语句；上面，FOREIGN KEY约束依赖于`user`表的存在，因此`address`表是第二个被创建的。在更复杂的依赖场景中，FOREIGN
    KEY约束也可以在创建后针对表使用ALTER来应用。
- en: The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object also features a [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") method that will emit DROP statements in
    the reverse order as it would emit CREATE in order to drop schema elements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象还具有一个[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")方法，它将按相反顺序发出DROP语句，以删除模式元素，与发出CREATE语句的顺序相反。'
- en: '## Using ORM Declarative Forms to Define Table Metadata'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用ORM声明形式定义表元数据'
- en: When using the ORM, the process by which we declare [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata is usually combined with the process of declaring
    [mapped](../glossary.html#term-mapped) classes. The mapped class is any Python
    class we’d like to create, which will then have attributes on it that will be
    linked to the columns in a database table. While there are a few varieties of
    how this is achieved, the most common style is known as [declarative](../orm/declarative_config.html),
    and allows us to declare our user-defined classes and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata at once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ORM时，声明[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据的过程通常与声明[映射](../glossary.html#term-mapped)类的过程结合在一起。映射类是我们想要创建的任何Python类，然后该类上将具有与数据库表中的列相关联的属性。虽然有几种实现这一目标的方式，但最常见的风格被称为[声明式](../orm/declarative_config.html)，它允许我们一次声明我们的用户定义类和[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据。
- en: '### Establishing a Declarative Base'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '### 建立声明式基础'
- en: 'When using the ORM, the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection remains present, however it itself is
    associated with an ORM-only construct commonly referred towards as the **Declarative
    Base**. The most expedient way to acquire a new Declarative Base is to create
    a new class that subclasses the SQLAlchemy [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ORM时，[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合仍然存在，但它本身与一个仅在ORM中使用的构造关联，通常称为**声明式基础**。获得新的声明式基础的最快捷方式是创建一个新类，它是 SQLAlchemy
    [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    类的子类：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Above, the `Base` class is what we’ll call the Declarative Base. When we make
    new classes that are subclasses of `Base`, combined with appropriate class-level
    directives, they will each be established as a new **ORM mapped class** at class
    creation time, each one typically (but not exclusively) referring to a particular
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，`Base` 类是我们所称的声明式基础。当我们创建的新类是 `Base` 的子类，并且结合适当的类级指令时，它们将在类创建时作为一个新的**ORM映射类**建立，每个类通常（但不仅限于）引用一个特定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。
- en: 'The Declarative Base refers to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection that is created for us automatically,
    assuming we didn’t provide one from the outside. This [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection is accessible via the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") class-level attribute. As we create
    new mapped classes, they each will reference a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") within this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式基础指的是一个自动为我们创建的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合，假设我们没有从外部提供。这个 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合可通过类级属性 [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") 访问。当我们创建新的映射类时，它们每个都会引用这个 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合中的一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Declarative Base also refers to a collection called [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which is the central “mapper configuration” unit in
    the SQLAlchemy ORM. While seldom accessed directly, this object is central to
    the mapper configuration process, as a set of ORM mapped classes will coordinate
    with each other via this registry. As was the case with [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), our Declarative Base also created a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") for us (again with options to pass our own [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")), which we can access via the [`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry") class variable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式基础还指一个称为 [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    的集合，这是 SQLAlchemy ORM 中的中心“映射器配置”单元。虽然很少直接访问，但该对象是映射器配置过程的核心，因为一组ORM映射类将通过该注册表相互协调。就像
    [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    一样，我们的声明式基础也为我们创建了一个 [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")（再次有选项传递我们自己的 [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")），我们可以通过类变量 [`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry") 访问：
- en: '[PRE26]  ### Declaring Mapped Classes'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]  ### 声明映射类'
- en: 'With the `Base` class established, we can now define ORM mapped classes for
    the `user_account` and `address` tables in terms of new classes `User` and `Address`.
    We illustrate below the most modern form of Declarative, which is driven from
    [**PEP 484**](https://peps.python.org/pep-0484/) type annotations using a special
    type [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"),
    which indicates attributes to be mapped as particular types:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Base`类，我们现在可以根据新类`User`和`Address`为`user_account`和`address`表定义ORM映射类。我们下面展示了声明性的最现代形式，它是由[**PEP
    484**](https://peps.python.org/pep-0484/)类型注释驱动的，使用了一种特殊类型[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")，指示要映射为特定类型的属性：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The two classes above, `User` and `Address`, are now called as **ORM Mapped
    Classes**, and are available for use in ORM persistence and query operations,
    which will be described later. Details about these classes include:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个类，`User`和`Address`，现在被称为**ORM映射类**，并可用于ORM持久性和查询操作，稍后将描述。关于这些类的详细信息包括：
- en: Each class refers to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that was generated as part of the declarative
    mapping process, which is named by assigning a string to the [`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__") attribute. Once the class is created,
    this generated [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is available from the [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__") attribute.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类都指向一个由声明性映射过程生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，通过将字符串赋值给[`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__")属性来命名。一旦类被创建，这个生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")可以通过[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")属性访问。
- en: As mentioned previously, this form is known as [Declarative Table Configuration](../orm/declarative_tables.html#orm-declarative-table-configuration).
    One of several alternative declaration styles would instead have us build the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object directly, and **assign** it directly to [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__"). This style is known as [Declarative
    with Imperative Table](../orm/declarative_tables.html#orm-imperative-table-configuration).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，此形式被称为[声明性表配置](../orm/declarative_tables.html#orm-declarative-table-configuration)。几种替代的声明样式之一将直接构建[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，并将其直接分配给[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")。这种风格被称为[声明性与命令式表配置](../orm/declarative_tables.html#orm-imperative-table-configuration)。
- en: To indicate columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), we use the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in combination with typing annotations
    based on the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type. This object will generate [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are applied to the construction of the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指示[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")中的列，我们使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构，结合基于[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型的类型注释。这个对象将生成应用于[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: For columns with simple datatypes and no other options, we can indicate a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation alone, using simple Python types like
    `int` and `str` to mean [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") and [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"). Customization of how Python types are interpreted
    within the Declarative mapping process is very open ended; see the sections [Using
    Annotated Declarative Table (Type Annotated Forms for mapped_column())](../orm/declarative_tables.html#orm-declarative-mapped-column)
    and [Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    for background.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有简单数据类型且没有其他选项的列，我们可以单独指定[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释，使用简单的 Python 类型如`int`和`str`来表示[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")和[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")。在 Declarative 映射过程中解释 Python 类型的方式非常开放；请参阅[使用注释的 Declarative
    表（对 mapped_column() 的类型注释形式）](../orm/declarative_tables.html#orm-declarative-mapped-column)和[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)部分了解背景信息。
- en: A column can be declared as “nullable” or “not null” based on the presence of
    the `Optional[<typ>]` type annotation (or its equivalents, `<typ> | None` or `Union[<typ>,
    None]`). The [`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter may also be used explicitly (and does
    not have to match the annotation’s optionality).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以根据存在`Optional[<typ>]`类型注释（或其等效项`<typ> | None`或`Union[<typ>, None]`）来声明列是否“可空”或“非空”。还可以显式使用[`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数（不必与注释的可选性匹配）。
- en: Use of explicit typing annotations is **completely optional**. We can also use
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    without annotations. When using this form, we would use more explicit type objects
    like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    and [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    as well as `nullable=False` as needed within each [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型注释的使用**完全是可选的**。我们还可以在没有注释的情况下使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。在使用这种形式时，我们会根据每个[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造中的需要使用更明确的类型对象，例如[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")和[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，以及`nullable=False`。
- en: Two additional attributes, `User.addresses` and `Address.user`, define a different
    kind of attribute called [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), which features similar annotation-aware configuration
    styles as shown. The [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is discussed more fully at [Working with
    ORM Related Objects](orm_related_objects.html#tutorial-orm-related-objects).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个额外的属性，`User.addresses`和`Address.user`，定义了一种称为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的不同类型属性，它具有与上述类似的注释感知配置样式。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造更详细地讨论在[处理 ORM 相关对象](orm_related_objects.html#tutorial-orm-related-objects)中。
- en: 'The classes are automatically given an `__init__()` method if we don’t declare
    one of our own. The default form of this method accepts all attribute names as
    optional keyword arguments:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有声明自己的`__init__()`方法，类会自动获得一个。默认情况下，这个方法接受所有属性名称作为可选关键字参数：
- en: '[PRE28]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To automatically generate a full-featured `__init__()` method which provides
    for positional arguments as well as arguments with default keyword values, the
    dataclasses feature introduced at [Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    may be used. It’s of course always an option to use an explicit `__init__()` method
    as well.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要自动生成一个支持位置参数以及具有默认关键字值的全功能`__init__()`方法，可以使用在[声明性数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)中介绍的
    dataclasses 功能。当然，始终可以选择使用显式的`__init__()`方法。
- en: The `__repr__()` methods are added so that we get a readable string output;
    there’s no requirement for these methods to be here. As is the case with `__init__()`,
    a `__repr__()` method can be generated automatically by using the [dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    feature.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__repr__()` 方法被添加以便我们获得可读的字符串输出；这些方法不要求必须在这里。与 `__init__()` 一样，可以通过使用 [dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    功能来自动生成 `__repr__()` 方法。'
- en: See also
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[ORM Mapping Styles](../orm/mapping_styles.html#orm-mapping-styles) - full
    background on different ORM configurational styles.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 映射样式](../orm/mapping_styles.html#orm-mapping-styles) - 不同 ORM 配置样式的完整背景。'
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping) -
    overview of Declarative class mapping'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式映射](../orm/mapping_styles.html#orm-declarative-mapping) - 声明类映射的概述'
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - detail on how to use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to define the columns within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be mapped when using Declarative.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[带有 mapped_column() 的声明式表](../orm/declarative_tables.html#orm-declarative-table)
    - 如何使用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 和 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 来定义在使用声明式时映射到 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中的列的详细信息。'
- en: Emitting DDL to the database from an ORM mapping
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 ORM 映射向数据库发出 DDL
- en: 'As our ORM mapped classes refer to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects contained within a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection, emitting DDL given the Declarative Base
    uses the same process as that described previously at [Emitting DDL to the Database](#tutorial-emitting-ddl).
    In our case, we have already generated the `user` and `address` tables in our
    SQLite database. If we had not done so already, we would be free to make use of
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    associated with our ORM Declarative Base class in order to do so, by accessing
    the collection from the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") attribute and then using [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") as before. In this case, PRAGMA statements
    are run, but no new tables are generated since they are found to be present already:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 ORM 映射类引用了包含在 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合中的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，因此，使用声明基类发出 DDL 与之前在 [将 DDL 发送到数据库](#tutorial-emitting-ddl)
    中描述的过程相同。在我们的情况下，我们已经在我们的 SQLite 数据库中生成了 `user` 和 `address` 表。如果我们还没有这样做，我们可以自由地利用与我们
    ORM 声明基类关联的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    来执行此操作，方法是从 [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") 属性访问集合，然后像之前一样使用 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")。在这种情况下，将运行 PRAGMA 语句，但不会生成新表，因为已经发现它们已经存在：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '### Establishing a Declarative Base'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '### 建立声明基类'
- en: 'When using the ORM, the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection remains present, however it itself is
    associated with an ORM-only construct commonly referred towards as the **Declarative
    Base**. The most expedient way to acquire a new Declarative Base is to create
    a new class that subclasses the SQLAlchemy [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 时，[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合仍然存在，但它本身与一个仅与 ORM 关联的构造相关联，通常称为**声明基类**。获取新的声明基类的最方便的方法是创建一个新类，该类是 SQLAlchemy
    [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    类的子类：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Above, the `Base` class is what we’ll call the Declarative Base. When we make
    new classes that are subclasses of `Base`, combined with appropriate class-level
    directives, they will each be established as a new **ORM mapped class** at class
    creation time, each one typically (but not exclusively) referring to a particular
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`Base` 类是我们将称之为声明性基类的内容。当我们创建新的类作为 `Base` 的子类时，结合适当的类级指令，它们将在类创建时分别被确立为新的**ORM
    映射类**，每个类通常（但不是唯一地）引用一个特定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。
- en: 'The Declarative Base refers to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection that is created for us automatically,
    assuming we didn’t provide one from the outside. This [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection is accessible via the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") class-level attribute. As we create
    new mapped classes, they each will reference a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") within this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性基类引用了一个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")集合，如果我们没有从外部提供，将会自动创建。这个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合可通过[`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata")类级属性访问。当我们创建新的映射类时，它们每个都将引用此[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合内的一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Declarative Base also refers to a collection called [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which is the central “mapper configuration” unit in
    the SQLAlchemy ORM. While seldom accessed directly, this object is central to
    the mapper configuration process, as a set of ORM mapped classes will coordinate
    with each other via this registry. As was the case with [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), our Declarative Base also created a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") for us (again with options to pass our own [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")), which we can access via the [`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry") class variable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性基类还引用了一个称为[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")的集合，它是
    SQLAlchemy ORM 中的中心“映射器配置”单元。虽然很少直接访问，但该对象对映射器配置过程至关重要，因为一组 ORM 映射类将通过此注册表相互协调。与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")一样，我们的声明性基类也为我们创建了一个[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")（再次有选项传递我们自己的[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")），我们可以通过[`DeclarativeBase.registry`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.registry
    "sqlalchemy.orm.DeclarativeBase.registry")类变量访问它：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '### Declaring Mapped Classes'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '### 声明映射类'
- en: 'With the `Base` class established, we can now define ORM mapped classes for
    the `user_account` and `address` tables in terms of new classes `User` and `Address`.
    We illustrate below the most modern form of Declarative, which is driven from
    [**PEP 484**](https://peps.python.org/pep-0484/) type annotations using a special
    type [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"),
    which indicates attributes to be mapped as particular types:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `Base` 类的确立，我们现在可以根据 `User` 和 `Address` 的新类分别为 `user_account` 和 `address`
    表定义 ORM 映射类。我们下面展示了声明性的最现代形式，它是从[**PEP 484**](https://peps.python.org/pep-0484/)类型注释驱动的，使用特殊类型[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")，它指示要映射为特定类型的属性：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The two classes above, `User` and `Address`, are now called as **ORM Mapped
    Classes**, and are available for use in ORM persistence and query operations,
    which will be described later. Details about these classes include:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个类，`User` 和 `Address`，现在被称为**ORM 映射类**，并可用于 ORM 持久性和查询操作，这将在后面进行描述。关于这些类的详细信息包括：
- en: Each class refers to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that was generated as part of the declarative
    mapping process, which is named by assigning a string to the [`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__") attribute. Once the class is created,
    this generated [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is available from the [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__") attribute.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类都引用了作为声明性映射过程的一部分生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，该对象通过将字符串分配给[`DeclarativeBase.__tablename__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__tablename__
    "sqlalchemy.orm.DeclarativeBase.__tablename__")属性而命名。一旦类被创建，此生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")可从[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")属性中获得。
- en: As mentioned previously, this form is known as [Declarative Table Configuration](../orm/declarative_tables.html#orm-declarative-table-configuration).
    One of several alternative declaration styles would instead have us build the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object directly, and **assign** it directly to [`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__"). This style is known as [Declarative
    with Imperative Table](../orm/declarative_tables.html#orm-imperative-table-configuration).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，这种形式称为[声明性表配置](../orm/declarative_tables.html#orm-declarative-table-configuration)。几种备选声明样式之一是直接构建[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，并将其直接分配给[`DeclarativeBase.__table__`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.__table__
    "sqlalchemy.orm.DeclarativeBase.__table__")。这种样式称为[具有命令式表的声明性](../orm/declarative_tables.html#orm-imperative-table-configuration)。
- en: To indicate columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), we use the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in combination with typing annotations
    based on the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type. This object will generate [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are applied to the construction of the
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指示[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")中的列，我们使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，结合基于[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型的类型注释。这个对象将生成应用于[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: For columns with simple datatypes and no other options, we can indicate a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation alone, using simple Python types like
    `int` and `str` to mean [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") and [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"). Customization of how Python types are interpreted
    within the Declarative mapping process is very open ended; see the sections [Using
    Annotated Declarative Table (Type Annotated Forms for mapped_column())](../orm/declarative_tables.html#orm-declarative-mapped-column)
    and [Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    for background.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有简单数据类型且没有其他选项的列，我们可以单独指示[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释，使用简单的Python类型，如`int`和`str`，表示[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")和[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")。如何在声明性映射过程中解释Python类型的定制非常开放；请参阅[使用带注释的声明性表（对mapped_column()的类型注释形式）](../orm/declarative_tables.html#orm-declarative-mapped-column)和[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)章节了解背景信息。
- en: A column can be declared as “nullable” or “not null” based on the presence of
    the `Optional[<typ>]` type annotation (or its equivalents, `<typ> | None` or `Union[<typ>,
    None]`). The [`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter may also be used explicitly (and does
    not have to match the annotation’s optionality).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据存在的`Optional[<typ>]`类型注释（或其等效形式`<typ> | None`或`Union[<typ>, None]`），可以将列声明为“可为空”或“非空”。还可以显式使用[`mapped_column.nullable`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数（不一定要与注释的可选性匹配）。
- en: Use of explicit typing annotations is **completely optional**. We can also use
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    without annotations. When using this form, we would use more explicit type objects
    like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    and [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    as well as `nullable=False` as needed within each [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型注释的使用**完全是可选的**。我们也可以在不带注释的情况下使用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。在使用这种形式时，我们将根据每个[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造中所需的更明确的类型对象，如[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") 和 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，以及 `nullable=False`。
- en: Two additional attributes, `User.addresses` and `Address.user`, define a different
    kind of attribute called [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), which features similar annotation-aware configuration
    styles as shown. The [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is discussed more fully at [Working with
    ORM Related Objects](orm_related_objects.html#tutorial-orm-related-objects).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个额外的属性，`User.addresses` 和 `Address.user`，定义了一种称为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的不同类型的属性，该属性具有与示例相似的注释感知配置样式。更多关于 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的讨论请见[使用 ORM 相关对象](orm_related_objects.html#tutorial-orm-related-objects)。
- en: 'The classes are automatically given an `__init__()` method if we don’t declare
    one of our own. The default form of this method accepts all attribute names as
    optional keyword arguments:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有声明自己的 `__init__()` 方法，这些类将自动获得一个 `__init__()` 方法。该方法的默认形式接受所有属性名称作为可选关键字参数：
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To automatically generate a full-featured `__init__()` method which provides
    for positional arguments as well as arguments with default keyword values, the
    dataclasses feature introduced at [Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    may be used. It’s of course always an option to use an explicit `__init__()` method
    as well.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要自动生成一个提供位置参数以及带有默认关键字值的全功能 `__init__()` 方法，可以使用在[声明性数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)中介绍的数据类功能。当然，始终可以选择使用显式的
    `__init__()` 方法。
- en: The `__repr__()` methods are added so that we get a readable string output;
    there’s no requirement for these methods to be here. As is the case with `__init__()`,
    a `__repr__()` method can be generated automatically by using the [dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)
    feature.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了 `__repr__()` 方法以获得可读的字符串输出；这些方法没有必须存在的要求。与 `__init__()` 类似，可以使用[dataclasses](../orm/dataclasses.html#orm-declarative-native-dataclasses)功能自动生成
    `__repr__()` 方法。
- en: See also
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[ORM Mapping Styles](../orm/mapping_styles.html#orm-mapping-styles) - full
    background on different ORM configurational styles.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 映射样式](../orm/mapping_styles.html#orm-mapping-styles) - 不同 ORM 配置样式的完整背景。'
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping) -
    overview of Declarative class mapping'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明性映射](../orm/mapping_styles.html#orm-declarative-mapping) - 声明性类映射概述'
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - detail on how to use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to define the columns within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be mapped when using Declarative.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 `mapped_column()` 的声明式表](../orm/declarative_tables.html#orm-declarative-table)
    - 关于如何使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")来定义在声明式使用时要映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")中的列的详细信息。'
- en: Emitting DDL to the database from an ORM mapping
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从ORM映射向数据库发出DDL
- en: 'As our ORM mapped classes refer to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects contained within a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection, emitting DDL given the Declarative Base
    uses the same process as that described previously at [Emitting DDL to the Database](#tutorial-emitting-ddl).
    In our case, we have already generated the `user` and `address` tables in our
    SQLite database. If we had not done so already, we would be free to make use of
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    associated with our ORM Declarative Base class in order to do so, by accessing
    the collection from the [`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata") attribute and then using [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") as before. In this case, PRAGMA statements
    are run, but no new tables are generated since they are found to be present already:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的ORM映射类引用了包含在[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，所以给定声明性基类发出DDL与先前描述的[Emitting DDL to the Database](#tutorial-emitting-ddl)相同。在我们的情况下，我们已经在我们的SQLite数据库中生成了`user`和`address`表。如果我们还没有这样做，我们可以自由地利用与我们的ORM声明性基类关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")，通过访问从[`DeclarativeBase.metadata`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase.metadata
    "sqlalchemy.orm.DeclarativeBase.metadata")属性获取的集合，然后像以前一样使用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")。在这种情况下，会运行PRAGMA语句，但是不会生成新的表，因为它们已经存在：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '## Table Reflection'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '## 表反射'
- en: To round out the section on working with table metadata, we will illustrate
    another operation that was mentioned at the beginning of the section, that of
    **table reflection**. Table reflection refers to the process of generating [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and related objects by reading the current state of
    a database. Whereas in the previous sections we’ve been declaring [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in Python, where we then have the option to
    emit DDL to the database to generate such a schema, the reflection process does
    these two steps in reverse, starting from an existing database and generating
    in-Python data structures to represent the schemas within that database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充对工作中的表元数据的部分说明，我们将说明一种在部分开始时提到的操作，即**表反射**。表反射是指通过读取数据库的当前状态生成[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和相关对象的过程。在以前的部分中，我们在Python中声明了[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，然后我们有选择地将DDL发出到数据库以生成这样的模式，反射过程将这两个步骤倒置，从现有数据库开始，并生成Python中的数据结构以表示该数据库中的模式。
- en: Tip
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is no requirement that reflection must be used in order to use SQLAlchemy
    with a pre-existing database. It is entirely typical that the SQLAlchemy application
    declares all metadata explicitly in Python, such that its structure corresponds
    to that the existing database. The metadata structure also need not include tables,
    columns, or other constraints and constructs in the pre-existing database that
    are not needed for the local application to function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 并非要求使用反射来与预先存在的数据库一起使用SQLAlchemy。完全可以将SQLAlchemy应用程序中的所有元数据都在Python中显式声明，以使其结构与现有数据库相对应。元数据结构也不必包括表、列或其他在预先存在的数据库中不需要的约束和结构，在本地应用程序中不需要。
- en: 'As an example of reflection, we will create a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object which represents the `some_table` object we
    created manually in the earlier sections of this document. There are again some
    varieties of how this is performed, however the most basic is to construct a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, given the name of the table and a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection to which it will belong, then instead
    of indicating individual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects, pass it the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") using the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为反射的示例，我们将创建一个新的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，该对象表示我们在本文档早期部分手动创建的`some_table`对象。这又有一些执行方式的变体，但最基本的是构建一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，给出表的名称和它将属于的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合，然后不是指示单独的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")和[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象，而是使用[`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table")参数传递目标[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the end of the process, the `some_table` object now contains the information
    about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects present in the table, and the object is usable in exactly the same way
    as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that we declared explicitly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程结束时，`some_table`对象现在包含了表中存在的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的信息，并且该对象可像我们显式声明的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")一样使用：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See also
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read more about table and schema reflection at [Reflecting Database Objects](../core/reflection.html).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读有关表和模式反射的更多信息，请访问[反射数据库对象](../core/reflection.html)。
- en: For ORM-related variants of table reflection, the section [Mapping Declaratively
    with Reflected Tables](../orm/declarative_tables.html#orm-declarative-reflected)
    includes an overview of the available options.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ORM相关的表反射变体，本节[使用反射表声明性映射](../orm/declarative_tables.html#orm-declarative-reflected)包括了可用选项的概述。
- en: Next Steps
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: We now have a SQLite database ready to go with two tables present, and Core
    and ORM table-oriented constructs that we can use to interact with these tables
    via a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    and/or ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    In the following sections, we will illustrate how to create, manipulate, and select
    data using these structures.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个准备好的SQLite数据库，其中包含两个表，以及我们可以使用它们与这些表进行交互的Core和ORM表导向结构，通过[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")和/或ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。在接下来的章节中，我们将说明如何使用这些结构来创建、操作和选择数据。
