- en: Automap
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Automap
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/extensions/automap.html](https://docs.sqlalchemy.org/en/20/orm/extensions/automap.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/extensions/automap.html](https://docs.sqlalchemy.org/en/20/orm/extensions/automap.html)
- en: Define an extension to the [`sqlalchemy.ext.declarative`](declarative/api.html#module-sqlalchemy.ext.declarative
    "sqlalchemy.ext.declarative") system which automatically generates mapped classes
    and relationships from a database schema, typically though not necessarily one
    which is reflected.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个扩展到[`sqlalchemy.ext.declarative`](declarative/api.html#module-sqlalchemy.ext.declarative
    "sqlalchemy.ext.declarative")系统的系统，自动生成从数据库模式到映射类和关系，通常而不一定是一个反射的数据库模式。
- en: It is hoped that the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    system provides a quick and modernized solution to the problem that the very famous
    [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/) also tries to solve, that
    of generating a quick and rudimentary object model from an existing database on
    the fly. By addressing the issue strictly at the mapper configuration level, and
    integrating fully with existing Declarative class techniques, [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 希望[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")系统提供了一个快速和现代化的解决方案，解决了非常著名的[SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)也试图解决的问题，即从现有数据库动态生成快速和基本的对象模型。通过严格在映射器配置级别解决该问题，并与现有的声明类技术完全集成，[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")试图提供一个与问题紧密集成的方法，以迅速自动生成临时映射。
- en: Tip
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The [Automap](#) extension is geared towards a “zero declaration” approach,
    where a complete ORM model including classes and pre-named relationships can be
    generated on the fly from a database schema. For applications that still want
    to use explicit class declarations including explicit relationship definitions
    in conjunction with reflection of tables, the [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class, described at [Using DeferredReflection](../declarative_tables.html#orm-declarative-reflected-deferred-reflection),
    is a better choice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[Automap](#)扩展针对“零声明”方法，其中可以从数据库模式动态生成包括类和预命名关系在内的完整ORM模型。对于仍希望使用显式类声明以及与表反射结合使用的显式关系定义的应用程序，描述在[使用DeferredReflection](../declarative_tables.html#orm-declarative-reflected-deferred-reflection)中的[`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类是更好的选择。'
- en: '## Basic Use'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 基本用法'
- en: 'The simplest usage is to reflect an existing database into a new model. We
    create a new [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class in a similar manner as to how we create a declarative base class, using
    [`automap_base()`](#sqlalchemy.ext.automap.automap_base "sqlalchemy.ext.automap.automap_base").
    We then call [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") on the resulting base class, asking
    it to reflect the schema and produce mappings:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用法是将现有数据库反映到一个新模型中。我们创建一个新的[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")类，方式类似于我们创建声明性基类，使用[`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base")。然后，我们调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")在生成的基类上，要求它反映模式并生成映射：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, calling [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") while passing along the [`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter indicates that the [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method will be called on this declarative
    base classes’ [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection; then, each **viable** [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") within the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will get a new mapped class generated automatically.
    The [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which link the various tables
    together will be used to produce new, bidirectional [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects between classes. The classes and relationships
    follow along a default naming scheme that we can customize. At this point, our
    basic mapping consisting of related `User` and `Address` classes is ready to use
    in the traditional way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")并传递[`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数，表示将在此声明基类的[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合上调用[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")方法; 然后，[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")中的每个** viable **[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")都将自动生成一个新的映射类。将连接各个表的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象将用于在类之间生成新的双向[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象。类和关系遵循一个默认命名方案，我们可以自定义。在这一点上，我们基本的映射包含了相关的`User`和`Address`类，可以以传统方式使用。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By **viable**, we mean that for a table to be mapped, it must specify a primary
    key. Additionally, if the table is detected as being a pure association table
    between two other tables, it will not be directly mapped and will instead be configured
    as a many-to-many table between the mappings for the two referring tables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过** viable **，我们指的是表必须指定主键才能进行映射。此外，如果检测到表是两个其他表之间的纯关联表，则不会直接映射该表，而是将其配置为两个引用表的映射之间的多对多表。
- en: Generating Mappings from an Existing MetaData
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有元数据生成映射
- en: 'We can pass a pre-declared [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object to [`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base"). This object can be constructed in any
    way, including programmatically, from a serialized file, or from itself being
    reflected using [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). Below we illustrate a combination of reflection
    and explicit table declaration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将预先声明的[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象传递给[`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base")。该对象可以以任何方式构造，包括以编程方式、从序列化文件或从使用[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")反映的自身构造。下面我们演示了反射和显式表声明的组合：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '## Generating Mappings from Multiple Schemas'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '## 从多个模式生成映射'
- en: 'The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare "sqlalchemy.ext.automap.AutomapBase.prepare")
    method when used with reflection may reflect tables from one schema at a time
    at most, using the [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter to indicate the name of
    a schema to be reflected from. In order to populate the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") with tables from multiple schemas, [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") may be invoked multiple times, each
    time passing a different name to the [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter. The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method keeps an internal list of
    [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that have already been mapped, and will add new mappings only for those
    [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that are new since the last time [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") was run:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用反射时，[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 方法一次最多只能从一个模式中反射表，使用 [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数来指示要从中反射的模式的名称。为了从多个模式中填充 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 中的表，可以多次调用 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")，每次将不同的名称传递给 [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数。[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 方法会保持一个内部列表，其中包含已经映射过的 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，并且只会为自上次运行 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 以来新增的那些 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象添加新的映射：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'New in version 2.0: The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method may be called any number
    of times; only newly added tables will be mapped on each run. Previously in version
    1.4 and earlier, multiple calls would cause errors as it would attempt to re-map
    an already mapped class. The previous workaround approach of invoking [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") directly remains available as well.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中新增了 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 方法，可以任意调用；每次运行时只会映射新增的表。在 1.4 版本及之前的版本中，多次调用会导致错误，因为它会尝试重新映射已经映射过的类。之前的解决方法是直接调用
    [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")，该方法仍然可用。
- en: Automapping same-named tables across multiple schemas
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨多个模式自动映射同名表
- en: 'For the common case where multiple schemas may have same-named tables and therefore
    would generate same-named classes, conflicts can be resolved either through use
    of the [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to apply different classnames
    on a per-schema basis, or by using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook, which allows disambiguation
    of same-named classes by changing their effective `__module__` attribute. In the
    example below, this hook is used to create a `__module__` attribute for all classes
    that is of the form `mymodule.<schemaname>`, where the schema name `default` is
    used if no schema is present:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个模式可能有同名表的常见情况，因此可能生成同名类，可以通过使用 [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子在每个模式基础上应用不同的类名来解决冲突，或者通过使用 [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子来解决同名类的歧义，该钩子允许通过更改它们的有效 `__module__`
    属性来区分同名类。在下面的示例中，此钩子用于为所有类创建一个 `__module__` 属性，其形式为 `mymodule.<schemaname>`，如果没有模式，则使用模式名称
    `default`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The same named-classes are organized into a hierarchical collection available
    at [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module "sqlalchemy.ext.automap.AutomapBase.by_module").
    This collection is traversed using the dot-separated name of a particular package/module
    down into the desired class name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同名类被组织成可在 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 中使用的分层集合。使用特定包/模块的点分隔名称向下遍历到所需的类名。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to return a new `__module__`
    that is not `None`, the class is **not** placed into the [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") collection; only classes that were
    not given an explicit modulename are placed here, as the collection cannot represent
    same-named classes individually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子来返回一个不是 `None` 的新 `__module__`
    时，类**不会**被放入 [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") 集合中；只有那些没有给定显式模块名的类才会放在这里，因为该集合不能单独表示同名类。
- en: 'In the example above, if the database contained a table named `accounts` in
    all three of the default schema, the `test_schema` schema, and the `test_schema_2`
    schema, three separate classes will be available as:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，如果数据库中包含了三个默认模式、`test_schema` 模式和 `test_schema_2` 模式中都命名为 `accounts`
    的表，将会有三个单独的类可用，分别是：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The default module namespace generated for all [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") classes is `sqlalchemy.ext.automap`. If
    no [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook is used, the contents of [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") will be entirely within the `sqlalchemy.ext.automap`
    namespace (e.g. `MyBase.by_module.sqlalchemy.ext.automap.<classname>`), which
    would contain the same series of classes as what would be seen in [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes"). Therefore it’s generally only necessary
    to use [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") when explicit `__module__` conventions
    are present.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类生成的默认模块命名空间是 `sqlalchemy.ext.automap`。如果没有使用 [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子，[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 的内容将完全在 `sqlalchemy.ext.automap`
    命名空间内（例如 `MyBase.by_module.sqlalchemy.ext.automap.<classname>`），其中将包含与 [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") 中看到的相同系列的类。因此，只有在存在显式 `__module__`
    约定时才通常需要使用 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")。
- en: Specifying Classes Explicitly
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式指定类
- en: Tip
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If explicit classes are expected to be prominent in an application, consider
    using [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") instead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序中期望显式类占据主要地位，请考虑改用 [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")。
- en: 'The [`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") extension
    allows classes to be defined explicitly, in a way similar to that of the [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Classes that extend from
    [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    act like regular declarative classes, but are not immediately mapped after their
    construction, and are instead mapped when we call [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare"). The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method will make use of the classes
    we’ve established based on the table name we use. If our schema contains tables
    `user` and `address`, we can define one or both of the classes to be used:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 扩展允许类被明确定义，类似于[`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类的方式。从[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")继承的类表现得像常规的声明类，但在构建后不会立即映射，而是在调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")时映射。[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法将利用我们根据使用的表名建立的类。如果我们的模式包含表`user`和`address`，我们可以定义要使用的一个或两个类：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, one of the more intricate details is that we illustrated overriding one
    of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that automap would have created. To do
    this, we needed to make sure the names match up with what automap would normally
    generate, in that the relationship name would be `User.address_collection` and
    the name of the class referred to, from automap’s perspective, is called `address`,
    even though we are referring to it as `Address` within our usage of this class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，更复杂的细节之一是，我们展示了覆盖[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象的过程，这是 automap 会创建的。为了做到这一点，我们需要确保名称与 automap
    通常生成的名称匹配，即关系名称将是`User.address_collection`，而从 automap 的角度来看，所指的类的名称被称为`address`，尽管我们在使用这个类时将其称为`Address`。
- en: Overriding Naming Schemes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖命名方案
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") is tasked
    with producing mapped classes and relationship names based on a schema, which
    means it has decision points in how these names are determined. These three decision
    points are provided using functions which can be passed to the [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method, and are known as [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table"), [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship"), and [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship"). Any or all of these
    functions are provided as in the example below, where we use a “camel case” scheme
    for class names and a “pluralizer” for collection names using the [Inflect](https://pypi.org/project/inflect)
    package:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 负责根据模式生成映射类和关系名称，这意味着它在确定这些名称时有决策点。这三个决策点是使用函数提供的，这些函数可以传递给[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法，并被称为[`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")、[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship")和[`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship")。以下示例中提供了任意或所有这些函数，我们使用“驼峰命名法”为类名和使用
    [Inflect](https://pypi.org/project/inflect) 包的“复数形式”为集合名：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the above mapping, we would now have classes `User` and `Address`, where
    the collection from `User` to `Address` is called `User.addresses`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述映射，我们现在将拥有`User`和`Address`两个类，其中从`User`到`Address`的集合被称为`User.addresses`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Relationship Detection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系检测
- en: 'The vast majority of what automap accomplishes is the generation of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") structures based on foreign keys. The mechanism
    by which this works for many-to-one and one-to-many relationships is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自动映射所实现的绝大部分是基于外键生成 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 结构。其工作原理如下：
- en: A given [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    known to be mapped to a particular class, is examined for [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查已知映射到特定类的给定 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    是否存在[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: From each [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), the remote [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object present is matched up to the class to which
    it is to be mapped, if any, else it is skipped.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，将匹配到的远程[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象与其应映射到的类相匹配，如果有的话，否则将跳过。
- en: As the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") we are examining corresponds to a reference
    from the immediate mapped class, the relationship will be set up as a many-to-one
    referring to the referred class; a corresponding one-to-many backref will be created
    on the referred class referring to this class.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在检查的 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对应于来自直接映射类的引用，因此关系将被设置为指向引用类的多对一关系；在引用类上将创建相应的一个对多反向引用，引用此类。
- en: If any of the columns that are part of the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") are not nullable (e.g. `nullable=False`),
    a [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") keyword argument of `all, delete-orphan` will be
    added to the keyword arguments to be passed to the relationship or backref. If
    the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") reports that [`ForeignKeyConstraint.ondelete`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete
    "sqlalchemy.schema.ForeignKeyConstraint") is set to `CASCADE` for a not null or
    `SET NULL` for a nullable set of columns, the option [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") flag is set to `True` in the set of relationship
    keyword arguments. Note that not all backends support reflection of ON DELETE.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果属于[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 的任何列不可为空（例如 `nullable=False`），则将在要传递给关系或反向引用的关键字参数中添加一个
    `relationship.cascade` 关键字参数，其值为 `all, delete-orphan`。如果[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 报告对于一组非空列设置了 [`ForeignKeyConstraint.ondelete`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete
    "sqlalchemy.schema.ForeignKeyConstraint") 为 `CASCADE`，或者对于可为空列设置了 `SET NULL`，则在关系关键字参数集合中将选项[`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")标志设置为 `True`。请注意，并非所有后端都支持对 ON DELETE 的反射。
- en: The names of the relationships are determined using the [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") and [`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") callable functions. It is important
    to note that the default relationship naming derives the name from the **the actual
    class name**. If you’ve given a particular class an explicit name by declaring
    it, or specified an alternate class naming scheme, that’s the name from which
    the relationship name will be derived.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关系的名称是使用[`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")和[`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")可调用函数确定的。重要的是要注意，默认关系命名是从**实际类名**派生的。如果您通过声明给出了特定类的显式名称，或者指定了备用类命名方案，那么关系名称将从该名称派生。
- en: The classes are inspected for an existing mapped property matching these names.
    If one is detected on one side, but none on the other side, [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") attempts to create a relationship on the
    missing side, then uses the [`relationship.back_populates`](../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter in order to point the new relationship
    to the other side.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些名称，类被检查是否存在匹配的已映射属性。如果在一侧检测到一个，但在另一侧没有，则[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")尝试在缺失的一侧创建一个关系，然后使用[`relationship.back_populates`](../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数将新关系指向另一侧。
- en: In the usual case where no relationship is on either side, [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") produces a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on the “many-to-one” side and matches it to the
    other using the [`relationship.backref`](../relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通常情况下，如果任一侧都没有关系，则[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")会在“多对一”一侧生成一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，并使用[`relationship.backref`](../relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")参数将其与另一侧匹配。
- en: Production of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and optionally the [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") is handed off to the [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") function, which can be supplied
    by the end-user in order to augment the arguments passed to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") or to make use of custom implementations of these functions.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的生成以及可选地[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")的生成由[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")函数处理，该函数可以由最终用户提供，以增强传递给[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")的参数或者使用这些函数的自定义实现。'
- en: Custom Relationship Arguments
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义关系参数
- en: The [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook can be used to add parameters
    to relationships. For most cases, we can make use of the existing [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function to return the object,
    after augmenting the given keyword dictionary with our own arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子可用于向关系添加参数。对于大多数情况，我们可以利用现有的 [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") 函数，在使用我们自己的参数扩充给定的关键字字典后，返回对象。'
- en: 'Below is an illustration of how to send [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") and [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") options along to all one-to-many relationships:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将 [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 和 [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 选项传递给所有一对多关系的示例：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many-to-Many relationships
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will generate
    many-to-many relationships, e.g. those which contain a `secondary` argument. The
    process for producing these is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 将生成多对多关系，例如包含
    `secondary` 参数的关系。生成这些关系的过程如下：'
- en: A given [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is examined for [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, before any mapped class has
    been assigned to it.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何映射类被分配给它之前，给定的 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 将被检查是否包含 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: If the table contains two and exactly two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, and all columns within this
    table are members of these two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, the table is assumed to be
    a “secondary” table, and will **not be mapped directly**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表包含两个且仅两个 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象，并且此表中的所有列都是这两个 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象的成员，则假定该表是“secondary”表，并且**不会直接映射**。
- en: The two (or one, for self-referential) external tables to which the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") refers to are matched to the classes to which they
    will be mapped, if any.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    所指向的两个（或一个，用于自引用）外部表将与它们将要映射到的类进行匹配，如果有的话。'
- en: If mapped classes for both sides are located, a many-to-many bi-directional
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    pair is created between the two classes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果双方的映射类位于同一位置，则在两个类之间创建一个双向的多对多 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 对。
- en: The override logic for many-to-many works the same as that of one-to-many/ many-to-one;
    the [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function is called upon to generate
    the structures and existing attributes will be maintained.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多对多的覆盖逻辑与一对多/多对一的相同；在调用 [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") 函数生成结构后，现有属性将被保留。
- en: Relationships with Inheritance
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有继承关系的关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will not
    generate any relationships between two classes that are in an inheritance relationship.
    That is, with two classes given as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 不会在处于继承关系的两个类之间生成任何关系。也就是说，对于以下给定的两个类：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The foreign key from `Engineer` to `Employee` is used not for a relationship,
    but to establish joined inheritance between the two classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engineer` 到 `Employee` 的外键不是用于建立关系，而是用于在两个类之间建立连接的继承关系。'
- en: 'Note that this means automap will not generate *any* relationships for foreign
    keys that link from a subclass to a superclass. If a mapping has actual relationships
    from subclass to superclass as well, those need to be explicit. Below, as we have
    two separate foreign keys from `Engineer` to `Employee`, we need to set up both
    the relationship we want as well as the `inherit_condition`, as these are not
    things SQLAlchemy can guess:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这意味着自动映射将不会为从子类到父类的外键生成 *任何* 关系。如果一个映射还具有从子类到父类的实际关系，那么这些关系需要是显式的。在下面的例子中，由于
    `Engineer` 到 `Employee` 有两个单独的外键，我们需要设置我们想要的关系以及 `inherit_condition`，因为这些都不是 SQLAlchemy
    可以猜测的：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Handling Simple Naming Conflicts
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理简单的命名冲突
- en: 'In the case of naming conflicts during mapping, override any of [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table"), [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship"), and [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship") as needed. For example,
    if automap is attempting to name a many-to-one relationship the same as an existing
    column, an alternate convention can be conditionally selected. Given a schema:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射过程中如果出现命名冲突的情况，根据需要覆盖 [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")、[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship") 和 [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship") 中的任何一个。例如，如果自动映射尝试将一个多对一关系命名为一个现有列相同的名称，可以有条件地选择替代约定。给定一个模式：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The above schema will first automap the `table_a` table as a class named `table_a`;
    it will then automap a relationship onto the class for `table_b` with the same
    name as this related class, e.g. `table_a`. This relationship name conflicts with
    the mapping column `table_b.table_a`, and will emit an error on mapping.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式将首先将 `table_a` 表自动映射为名为 `table_a` 的类；然后将在 `table_b` 的类上自动映射一个与此相关类相同名称的关系，例如
    `table_a`。这个关系名称与映射列 `table_b.table_a` 冲突，并且将在映射时发出错误。
- en: 'We can resolve this conflict by using an underscore as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用下划线解决这个冲突：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, we can change the name on the column side. The columns that
    are mapped can be modified using the technique described at [Naming Declarative
    Mapped Columns Explicitly](../declarative_tables.html#mapper-column-distinct-names),
    by assigning the column explicitly to a new name:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在列的一侧更改名称。可以使用在[Naming Declarative Mapped Columns Explicitly](../declarative_tables.html#mapper-column-distinct-names)
    中描述的技术修改映射的列，通过将列显式地分配给一个新名称：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using Automap with Explicit Declarations
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用明确声明的自动映射
- en: 'As noted previously, automap has no dependency on reflection, and can make
    use of any collection of [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects within a [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection. From this, it follows that automap can
    also be used generate missing relationships given an otherwise complete model
    that fully defines table metadata:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，自动映射不依赖于反射，并且可以利用[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合内的任何 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象集合。由此可见，自动映射也可以在完全定义了表元数据的完整模型中生成丢失的关系：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Above, given mostly complete `User` and `Address` mappings, the [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") which we defined on `Address.user_id` allowed
    a bidirectional relationship pair `Address.user` and `User.address_collection`
    to be generated on the mapped classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的例子中，对于大部分完成的 `User` 和 `Address` 映射，我们在 `Address.user_id` 上定义的 [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 允许在映射的类上生成一个双向关系对 `Address.user` 和 `User.address_collection`。 '
- en: Note that when subclassing [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase"), the [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method is required; if not called,
    the classes we’ve declared are in an un-mapped state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当子类化[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")时，需要调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法；如果不调用，我们声明的类处于未映射状态。
- en: '## Intercepting Column Definitions'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '## 拦截列定义'
- en: 'The [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    and [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects support an event hook [`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") that may be used to intercept the
    information reflected about a database column before the [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is constructed. For example if we wanted to
    map columns using a naming convention such as `"attr_<columnname>"`, the event
    could be applied as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    和 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象支持一个事件钩子[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")，可用于拦截关于数据库列反射的信息，在构建[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象之前。例如，如果我们想要使用类似`"attr_<columnname>"`的命名约定来映射列，可以应用该事件：'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'New in version 1.4.0b2: the [`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event may be applied to a [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4.0b2开始：[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")事件可以应用于[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象。
- en: See also
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
- en: '[Automating Column Naming Schemes from Reflected Tables](../declarative_tables.html#mapper-automated-reflection-schemes)
    - in the ORM mapping documentation'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动从反射表中命名列](../declarative_tables.html#mapper-automated-reflection-schemes)
    - 在 ORM 映射文档中'
- en: API Reference
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 参考
- en: '| Object Name | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [automap_base](#sqlalchemy.ext.automap.automap_base)([declarative_base],
    **kw) | Produce a declarative automap base. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| [automap_base](#sqlalchemy.ext.automap.automap_base)([declarative_base],
    **kw) | 生成一个声明式自动映射基类。 |'
- en: '| [AutomapBase](#sqlalchemy.ext.automap.AutomapBase) | Base class for an “automap”
    schema. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| [AutomapBase](#sqlalchemy.ext.automap.AutomapBase) | 用于“自动映射”模式的基类。 |'
- en: '| [classname_for_table](#sqlalchemy.ext.automap.classname_for_table)(base,
    tablename, table) | Return the class name that should be used, given the name
    of a table. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| [classname_for_table](#sqlalchemy.ext.automap.classname_for_table)(base,
    tablename, table) | 返回应用于给定表名的类名。 |'
- en: '| [generate_relationship](#sqlalchemy.ext.automap.generate_relationship)(base,
    direction, return_fn, attrname, ..., **kw) | Generate a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") on behalf of two mapped classes. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| [generate_relationship](#sqlalchemy.ext.automap.generate_relationship)(base,
    direction, return_fn, attrname, ..., **kw) | 代表两个映射类生成一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")。 |'
- en: '| [name_for_collection_relationship](#sqlalchemy.ext.automap.name_for_collection_relationship)(base,
    local_cls, referred_cls, constraint) | Return the attribute name that should be
    used to refer from one class to another, for a collection reference. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| [name_for_collection_relationship](#sqlalchemy.ext.automap.name_for_collection_relationship)(base,
    local_cls, referred_cls, constraint) | 返回应用于从一个类到另一个类的集合引用的属性名称。 |'
- en: '| [name_for_scalar_relationship](#sqlalchemy.ext.automap.name_for_scalar_relationship)(base,
    local_cls, referred_cls, constraint) | Return the attribute name that should be
    used to refer from one class to another, for a scalar object reference. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| [name_for_scalar_relationship](#sqlalchemy.ext.automap.name_for_scalar_relationship)(base,
    local_cls, referred_cls, constraint) | 返回应用于标量对象引用的一个类到另一个类的属性名称。 |'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Produce a declarative automap base.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个声明式自动映射基类。
- en: This function produces a new base class that is a product of the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class as well a declarative base produced
    by `declarative_base()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成一个新的基类，它是 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类的产品，以及由 `declarative_base()` 生成的一个声明基类。
- en: All parameters other than `declarative_base` are keyword arguments that are
    passed directly to the `declarative_base()` function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `declarative_base` 外，所有参数都是直接传递给 `declarative_base()` 函数的关键字参数。
- en: 'Parameters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`declarative_base` – an existing class produced by `declarative_base()`. When
    this is passed, the function no longer invokes `declarative_base()` itself, and
    all other keyword arguments are ignored.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarative_base` – 由 `declarative_base()` 生成的现有类。当传递了这个参数时，函数不再调用 `declarative_base()`
    本身，所有其他关键字参数都会被忽略。'
- en: '`**kw` – keyword arguments are passed along to `declarative_base()`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kw` – 关键字参数被传递给 `declarative_base()`。'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Base class for an “automap” schema.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用于“自动映射”模式的基类。
- en: The [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class can be compared to the “declarative base” class that is produced by the
    `declarative_base()` function. In practice, the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is always used as a mixin along with
    an actual declarative base.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类可以与由 `declarative_base()` 函数生成的“声明基类”类相比较。实际上，[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 类总是与实际的声明基类一起使用作为一个 mixin。'
- en: A new subclassable [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    is typically instantiated using the [`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base") function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的可子类化的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    通常使用 [`automap_base()`](#sqlalchemy.ext.automap.automap_base "sqlalchemy.ext.automap.automap_base")
    函数实例化。
- en: '**Members**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[by_module](#sqlalchemy.ext.automap.AutomapBase.by_module), [classes](#sqlalchemy.ext.automap.AutomapBase.classes),
    [metadata](#sqlalchemy.ext.automap.AutomapBase.metadata), [prepare()](#sqlalchemy.ext.automap.AutomapBase.prepare)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[by_module](#sqlalchemy.ext.automap.AutomapBase.by_module), [classes](#sqlalchemy.ext.automap.AutomapBase.classes),
    [metadata](#sqlalchemy.ext.automap.AutomapBase.metadata), [prepare()](#sqlalchemy.ext.automap.AutomapBase.prepare)'
- en: See also
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](#)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动映射](#)'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An instance of `Properties` containing a hierarchal structure of dot-separated
    module names linked to classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含点分隔的模块名称层次结构链接到类的 `Properties` 实例。
- en: This collection is an alternative to the [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") collection that is useful when making
    use of the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter, which will apply distinct
    `__module__` attributes to generated classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合是一个替代 [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") 集合的选择，当使用 [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数时，这个参数将为生成的类应用不同的 `__module__`
    属性。
- en: 'The default `__module__` an automap-generated class is `sqlalchemy.ext.automap`;
    to access this namespace using [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自动映射生成的类的默认 `__module__` 是 `sqlalchemy.ext.automap`；使用 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 访问这个命名空间会像这样：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If a class had a `__module__` of `mymodule.account`, accessing this namespace
    looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类的 `__module__` 是 `mymodule.account`，访问这个命名空间会像这样：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: New in version 2.0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 新特性在版本 2.0 中添加。
- en: See also
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Generating Mappings from Multiple Schemas](#automap-by-module)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[从多个模式生成映射](#automap-by-module)'
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An instance of `Properties` containing classes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 包含类的 `Properties` 实例。
- en: 'This object behaves much like the `.c` collection on a table. Classes are present
    under the name they were given, e.g.:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的行为类似于表上的 `.c` 集合。类以它们被赋予的名称呈现，例如：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For class names that overlap with a method name of `Properties`, such as `items()`,
    the getitem form is also supported:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类名与 `Properties` 方法名重叠的情况，比如 `items()`，也支持获取项的形式：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Refers to the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection that will be used for new [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 指的是将用于新 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合。
- en: See also
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Accessing Table and Metadata](../declarative_tables.html#orm-declarative-metadata)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[访问表和元数据](../declarative_tables.html#orm-declarative-metadata)'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Extract mapped classes and relationships from the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") and perform mappings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    中提取映射类和关系，并执行映射。
- en: For full documentation and examples see [Basic Use](#automap-basic-use).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整文档和示例，请参阅 [基本用法](#automap-basic-use)。
- en: 'Parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`autoload_with` – an [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with which to perform schema reflection; when
    specified, the [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method will be invoked within the scope
    of this method.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoload_with` – 用于执行模式反射的 [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")；当指定时，[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 方法将在此方法的范围内调用。'
- en: '`engine` –'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`engine` –'
- en: legacy; use [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase"). Used to indicate the [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with which to reflect tables with, if [`AutomapBase.reflect`](#sqlalchemy.ext.automap.AutomapBase.params.reflect
    "sqlalchemy.ext.automap.AutomapBase") is True.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 旧版；如果 [`AutomapBase.reflect`](#sqlalchemy.ext.automap.AutomapBase.params.reflect
    "sqlalchemy.ext.automap.AutomapBase") 为 True，则用于指示反映表的 [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。
- en: 'Deprecated since version 1.4: The [`AutomapBase.prepare.engine`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter is deprecated and will
    be removed in a future release. Please use the [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自 1.4 版开始弃用：[`AutomapBase.prepare.engine`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数已弃用，并将在未来版本中移除。请使用 [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数。
- en: '`reflect` –'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect` –'
- en: legacy; use [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase"). Indicates that [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") should be invoked.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 旧版；如果 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 应被调用，则使用 [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase")。
- en: 'Deprecated since version 1.4: The [`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter is deprecated and will
    be removed in a future release. Reflection is enabled when [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") is passed.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自 1.4 版开始弃用：[`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数已弃用，并将在未来版本中移除。当传递 [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") 时，将启用反射。
- en: '`classname_for_table` – callable function which will be used to produce new
    class names, given a table name. Defaults to [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table").'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classname_for_table` – 可调用函数，用于根据表名生成新类名。默认为 [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")。'
- en: '`modulename_for_table` –'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulename_for_table` –'
- en: callable function which will be used to produce the effective `__module__` for
    an internally generated class, to allow for multiple classes of the same name
    in a single automap base which would be in different “modules”.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`__module__` 的有效值将由可调用函数产生，用于为内部生成的类生成模块名，以允许在单个自动映射基类中具有相同名称的多个类，这些类可能位于不同的“模块”中。'
- en: Defaults to `None`, which will indicate that `__module__` will not be set explicitly;
    the Python runtime will use the value `sqlalchemy.ext.automap` for these classes.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认为 `None`，表示 `__module__` 不会被显式设置；Python 运行时将使用值 `sqlalchemy.ext.automap` 用于这些类。
- en: When assigning `__module__` to generated classes, they can be accessed based
    on dot-separated module names using the [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") collection. Classes that have
    an explicit `__module_` assigned using this hook do **not** get placed into the
    [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes "sqlalchemy.ext.automap.AutomapBase.classes")
    collection, only into [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module").
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当为生成的类分配 `__module__` 时，可以使用 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 集合基于点分隔的模块名称进行访问。使用此钩子分配了显式 `__module_`
    的类**不**会被放置到 [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") 集合中，只会放置到 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 中。
- en: New in version 2.0.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本 2.0 中的新内容。
- en: See also
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Generating Mappings from Multiple Schemas](#automap-by-module)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[从多个模式生成映射](#automap-by-module)'
- en: '`name_for_scalar_relationship` – callable function which will be used to produce
    relationship names for scalar relationships. Defaults to [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship").'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_for_scalar_relationship` – 用于生成标量关系的关系名称的可调用函数。默认为 [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship")。'
- en: '`name_for_collection_relationship` – callable function which will be used to
    produce relationship names for collection-oriented relationships. Defaults to
    [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship").'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_for_collection_relationship` – 用于为面向集合的关系生成关系名称的可调用函数。默认为 [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship")。'
- en: '`generate_relationship` – callable function which will be used to actually
    generate [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") constructs. Defaults to [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship").'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_relationship` – 实际生成 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 和 [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 构造的可调用函数。默认为 [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship")。'
- en: '`collection_class` – the Python collection class that will be used when a new
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    object is created that represents a collection. Defaults to `list`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection_class` – 当创建表示集合的新 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象时将使用的 Python 集合类。默认为 `list`。'
- en: '`schema` –'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema` –'
- en: Schema name to reflect when reflecting tables using the [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter. The name is passed to
    the [`MetaData.reflect.schema`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect") parameter of [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). When omitted, the default schema in use
    by the database connection is used.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用 [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数反射表时要反射的模式名称。名称传递给 [`MetaData.reflect.schema`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect") 参数的 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")。当省略时，数据库连接使用的默认模式将被使用。
- en: Note
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter supports reflection of
    a single schema at a time. In order to include tables from many schemas, use multiple
    calls to [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare").
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数支持一次反射单个模式。为了包含来自多个模式的表，请多次调用
    [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare "sqlalchemy.ext.automap.AutomapBase.prepare")。'
- en: For an overview of multiple-schema automap including the use of additional naming
    conventions to resolve table name conflicts, see the section [Generating Mappings
    from Multiple Schemas](#automap-by-module).
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于多模式自动映射的概述，包括使用额外命名约定解决表名冲突，请参见 [从多个模式生成映射](#automap-by-module) 部分。
- en: 'New in version 2.0: [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") supports being directly invoked
    any number of times, keeping track of tables that have already been processed
    to avoid processing them a second time.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本 2.0 中的新功能：[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 支持直接调用任意次数，跟踪已经处理过的表，以避免第二次处理它们。
- en: '`reflection_options` –'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflection_options` –'
- en: When present, this dictionary of options will be passed to [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") to supply general reflection-specific options
    like `only` and/or dialect-specific options like `oracle_resolve_synonyms`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当存在时，此选项字典将传递给 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")，以提供一般的反射特定选项，如 `only` 和/或特定于方言的选项，如 `oracle_resolve_synonyms`。
- en: New in version 1.4.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本 1.4 中的新功能。
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Return the class name that should be used, given the name of a table.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定表名时应该使用的类名。
- en: 'The default implementation is:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现是：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数指定备用实现。
- en: 'Parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 执行准备工作的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类。'
- en: '`tablename` – string name of the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tablename` – [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的字符串名称。'
- en: '`table` – the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object itself.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table` – [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象本身。'
- en: 'Returns:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: a string class name.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串类名。
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 2, the string used for the class name **must** be a non-Unicode object,
    e.g. a `str()` object. The `.name` attribute of [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is typically a Python unicode subclass, so the `str()`
    function should be applied to this name, after accounting for any non-ASCII characters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2 中，用于类名的字符串**必须**是非 Unicode 对象，例如 `str()` 对象。[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的 `.name` 属性通常是 Python 的 unicode 子类，因此应该在考虑任何非 ASCII
    字符后，对此名称应用 `str()` 函数。
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Return the attribute name that should be used to refer from one class to another,
    for a scalar object reference.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应该用于从一个类到另一个类引用的属性名称，用于标量对象引用。
- en: 'The default implementation is:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现是：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数指定备用实现。
- en: 'Parameters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 执行准备工作的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类。'
- en: '`local_cls` – the class to be mapped on the local side.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 要映射到本地端的类。'
- en: '`referred_cls` – the class to be mapped on the referring side.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 要映射到引用方的类。'
- en: '`constraint` – the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that is being inspected to produce this
    relationship.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraint` – 正在检查以产生此关系的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")。'
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Return the attribute name that should be used to refer from one class to another,
    for a collection reference.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应该用于从一个类引用到另一个类的属性名称，用于集合引用。
- en: 'The default implementation is:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现如下：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数指定备用实现。
- en: 'Parameters:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 进行准备工作的[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类。'
- en: '`local_cls` – the class to be mapped on the local side.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 在本地端映射的类。'
- en: '`referred_cls` – the class to be mapped on the referring side.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 在引用方的类。'
- en: '`constraint` – the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that is being inspected to produce this
    relationship.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraint` – 正在检查以产生此关系的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")。'
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Generate a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") on behalf of two mapped classes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代表两个映射类生成[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")。
- en: An alternate implementation of this function can be specified using the [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数指定备用实现。
- en: 'The default implementation of this function is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的默认实现如下：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Parameters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 进行准备工作的[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类。'
- en: '`direction` – indicate the “direction” of the relationship; this will be one
    of `ONETOMANY`, `MANYTOONE`, `MANYTOMANY`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction` – 表示关系的“方向”; 这将是`ONETOMANY`、`MANYTOONE`、`MANYTOMANY`之一。'
- en: '`return_fn` – the function that is used by default to create the relationship.
    This will be either [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref"). The [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function’s result will be used to produce a new [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in a second step, so it is critical that user-defined
    implementations correctly differentiate between the two functions, if a custom
    relationship function is being used.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return_fn` – 默认用于创建关系的函数。这将是[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")中的一个。[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数的结果将用于在第二步产生一个新的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，因此如果正在使用自定义关系函数，则用户定义的实现正确区分这两个函数非常关键。'
- en: '`attrname` – the attribute name to which this relationship is being assigned.
    If the value of [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") is the [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function, then this name is the name that is being assigned
    to the backref.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attrname` – 正在分配此关系的属性名称。如果[`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship")的值是[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数，则此名称是分配给反向引用的名称。'
- en: '`local_cls` – the “local” class to which this relationship or backref will
    be locally present.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 此关系或反向引用将在本地存在的“本地”类。'
- en: '`referred_cls` – the “referred” class to which the relationship or backref
    refers to.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 关系或反向引用所指向的“被引用”类。'
- en: '`**kw` – all additional keyword arguments are passed along to the function.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kw` – 所有额外的关键字参数都将传递给函数。'
- en: 'Returns:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    construct, as dictated by the [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") parameter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由 [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") 参数指定的 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 或 [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 结构。
- en: '## Basic Use'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '## 基本用法'
- en: 'The simplest usage is to reflect an existing database into a new model. We
    create a new [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class in a similar manner as to how we create a declarative base class, using
    [`automap_base()`](#sqlalchemy.ext.automap.automap_base "sqlalchemy.ext.automap.automap_base").
    We then call [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") on the resulting base class, asking
    it to reflect the schema and produce mappings:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用法是将现有数据库反映到新模型中。我们以与创建声明性基类相似的方式创建一个新的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 类，使用 [`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base")。然后，我们调用 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 在生成的基类上，要求它反映架构并生成映射：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Above, calling [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") while passing along the [`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter indicates that the [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method will be called on this declarative
    base classes’ [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection; then, each **viable** [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") within the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will get a new mapped class generated automatically.
    The [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which link the various tables
    together will be used to produce new, bidirectional [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects between classes. The classes and relationships
    follow along a default naming scheme that we can customize. At this point, our
    basic mapping consisting of related `User` and `Address` classes is ready to use
    in the traditional way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，在传递 [`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数时调用 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 表示将在此声明基类的 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合上调用 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 方法；然后，每个 **viable** [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 在 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 内将自动生成一个新的映射类。将连接各个表的 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象用于在类之间生成新的双向 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象。类和关系遵循默认命名方案，我们可以自定义。在此时，我们的基本映射由相关的 `User`
    和 `Address` 类组成，可以像传统方式一样使用。
- en: Note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By **viable**, we mean that for a table to be mapped, it must specify a primary
    key. Additionally, if the table is detected as being a pure association table
    between two other tables, it will not be directly mapped and will instead be configured
    as a many-to-many table between the mappings for the two referring tables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 **viable** 意味着要将表映射，必须指定主键。此外，如果检测到表是两个其他表之间的纯关联表，则不会直接映射，而是将其配置为两个引用表的映射之间的多对多表。
- en: Generating Mappings from an Existing MetaData
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有的元数据生成映射
- en: 'We can pass a pre-declared [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object to [`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base"). This object can be constructed in any
    way, including programmatically, from a serialized file, or from itself being
    reflected using [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). Below we illustrate a combination of reflection
    and explicit table declaration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将预先声明的[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象传递给[`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base")。这个对象可以以任何方式构建，包括以编程方式、从序列化文件中或者通过[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")自身进行反射。下面我们展示了反射和显式表声明的结合使用：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '## Generating Mappings from Multiple Schemas'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '## 从多个模式生成映射'
- en: 'The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare "sqlalchemy.ext.automap.AutomapBase.prepare")
    method when used with reflection may reflect tables from one schema at a time
    at most, using the [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter to indicate the name of
    a schema to be reflected from. In order to populate the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") with tables from multiple schemas, [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") may be invoked multiple times, each
    time passing a different name to the [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter. The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method keeps an internal list of
    [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that have already been mapped, and will add new mappings only for those
    [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that are new since the last time [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") was run:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用反射时，[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法最多一次只能从一个模式中反射表，使用[`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数来指示要反射的模式的名称。为了将[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")填充到来自多个模式的表中，可以多次调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")，每次传递不同的名称给[`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数。[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法会保留一个已经映射过的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的内部列表，并且只会为那些自上次运行[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")以来新的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象添加新的映射：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'New in version 2.0: The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method may be called any number
    of times; only newly added tables will be mapped on each run. Previously in version
    1.4 and earlier, multiple calls would cause errors as it would attempt to re-map
    an already mapped class. The previous workaround approach of invoking [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") directly remains available as well.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本新增功能：[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法可以被任意次数调用；每次运行只会映射新添加的表。在1.4版本及更早版本中，多次调用会导致错误，因为它会尝试重新映射已经映射的类。直接调用[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")的先前解决方法仍然可用。
- en: Automapping same-named tables across multiple schemas
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个模式中自动映射同名表
- en: 'For the common case where multiple schemas may have same-named tables and therefore
    would generate same-named classes, conflicts can be resolved either through use
    of the [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to apply different classnames
    on a per-schema basis, or by using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook, which allows disambiguation
    of same-named classes by changing their effective `__module__` attribute. In the
    example below, this hook is used to create a `__module__` attribute for all classes
    that is of the form `mymodule.<schemaname>`, where the schema name `default` is
    used if no schema is present:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见情况，即多个模式可能具有相同命名的表，因此可能生成相同命名的类，可以通过使用[`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")挂钩来在每个模式基础上应用不同的类名来解决冲突，或者使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")挂钩，通过更改它们的有效`__module__`属性来消除同名类的歧义。在下面的示例中，此挂钩用于为所有类创建一个`__module__`属性，其形式为`mymodule.<schemaname>`，其中如果没有模式，则使用模式名为`default`：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The same named-classes are organized into a hierarchical collection available
    at [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module "sqlalchemy.ext.automap.AutomapBase.by_module").
    This collection is traversed using the dot-separated name of a particular package/module
    down into the desired class name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相同命名的类被组织成一个层次化的集合，可在[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")中使用。该集合使用特定包/模块的点分隔名称进行遍历，直到所需的类名。
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to return a new `__module__`
    that is not `None`, the class is **not** placed into the [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") collection; only classes that were
    not given an explicit modulename are placed here, as the collection cannot represent
    same-named classes individually.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")挂钩返回一个不是`None`的新`__module__`时，类**不会**放置到[`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes")集合中；只有没有给定显式模块名称的类才会放在这里，因为该集合无法表示同名类。
- en: 'In the example above, if the database contained a table named `accounts` in
    all three of the default schema, the `test_schema` schema, and the `test_schema_2`
    schema, three separate classes will be available as:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，如果数据库中包含默认模式，`test_schema`模式和`test_schema_2`模式中的一个名为`accounts`的表，那么将会有三个不同的类可用：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The default module namespace generated for all [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") classes is `sqlalchemy.ext.automap`. If
    no [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook is used, the contents of [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") will be entirely within the `sqlalchemy.ext.automap`
    namespace (e.g. `MyBase.by_module.sqlalchemy.ext.automap.<classname>`), which
    would contain the same series of classes as what would be seen in [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes"). Therefore it’s generally only necessary
    to use [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") when explicit `__module__` conventions
    are present.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类生成的默认模块命名空间是`sqlalchemy.ext.automap`。如果没有使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")挂钩，则[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")的内容将完全在`sqlalchemy.ext.automap`命名空间内（例如`MyBase.by_module.sqlalchemy.ext.automap.<classname>`），其中包含与[`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes")中看到的相同的一系列类。因此，通常只有在存在显式`__module__`约定时才需要使用[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")。
- en: Automapping same-named tables across multiple schemas
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在跨多个模式自动映射同名表时
- en: 'For the common case where multiple schemas may have same-named tables and therefore
    would generate same-named classes, conflicts can be resolved either through use
    of the [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to apply different classnames
    on a per-schema basis, or by using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook, which allows disambiguation
    of same-named classes by changing their effective `__module__` attribute. In the
    example below, this hook is used to create a `__module__` attribute for all classes
    that is of the form `mymodule.<schemaname>`, where the schema name `default` is
    used if no schema is present:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见情况，即多个模式可能具有相同命名的表，因此会生成相同命名的类，可以通过使用[`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")钩子来根据每个模式应用不同的类名来解决冲突，或者通过使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")钩子来解决相同命名类的歧义问题，该钩子允许通过更改它们的有效`__module__`属性来区分相同命名的类。在下面的示例中，该钩子用于创建一个形式为`mymodule.<schemaname>`的`__module__`属性，其中如果不存在模式，则使用模式名称`default`：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The same named-classes are organized into a hierarchical collection available
    at [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module "sqlalchemy.ext.automap.AutomapBase.by_module").
    This collection is traversed using the dot-separated name of a particular package/module
    down into the desired class name.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 相同命名的类被组织成一个层次结构集合，可在[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")中使用。该集合通过特定包/模块的点分隔名称向下遍历到所需的类名。
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook to return a new `__module__`
    that is not `None`, the class is **not** placed into the [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") collection; only classes that were
    not given an explicit modulename are placed here, as the collection cannot represent
    same-named classes individually.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")钩子返回一个不是`None`的新`__module__`时，该类**不会**被放置到[`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes")集合中；只有那些没有给定显式模块名的类会被放置在此处，因为集合不能单独表示同名类。
- en: 'In the example above, if the database contained a table named `accounts` in
    all three of the default schema, the `test_schema` schema, and the `test_schema_2`
    schema, three separate classes will be available as:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，如果数据库中包含了三个默认模式、`test_schema`模式和`test_schema_2`模式中都命名为`accounts`的表，则会分别获得三个单独的类：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The default module namespace generated for all [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") classes is `sqlalchemy.ext.automap`. If
    no [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook is used, the contents of [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") will be entirely within the `sqlalchemy.ext.automap`
    namespace (e.g. `MyBase.by_module.sqlalchemy.ext.automap.<classname>`), which
    would contain the same series of classes as what would be seen in [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes"). Therefore it’s generally only necessary
    to use [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") when explicit `__module__` conventions
    are present.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类生成的默认模块命名空间是`sqlalchemy.ext.automap`。
    如果未使用[`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare")挂钩，则[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")的内容将完全在`sqlalchemy.ext.automap`命名空间内（例如，`MyBase.by_module.sqlalchemy.ext.automap.<classname>`），其中包含与[`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes")中看到的相同系列的类。 因此，仅当存在显式的`__module__`约定时才通常需要使用[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")。
- en: Specifying Classes Explicitly
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确指定类
- en: Tip
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If explicit classes are expected to be prominent in an application, consider
    using [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") instead.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果明确的类在应用程序中占主导地位，请考虑改用[`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")。
- en: 'The [`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") extension
    allows classes to be defined explicitly, in a way similar to that of the [`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Classes that extend from
    [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    act like regular declarative classes, but are not immediately mapped after their
    construction, and are instead mapped when we call [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare"). The [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method will make use of the classes
    we’ve established based on the table name we use. If our schema contains tables
    `user` and `address`, we can define one or both of the classes to be used:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap")扩展允许以与[`DeferredReflection`](declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类相似的方式明确定义类。 从[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")继承的类表现得像常规的声明性类一样，但在构造后不会立即映射，而是在调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")时映射。 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法将利用我们基于所使用的表名建立的类。 如果我们的模式包含表`user`和`address`，我们可以定义要使用的一个或两个类：'
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Above, one of the more intricate details is that we illustrated overriding one
    of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that automap would have created. To do
    this, we needed to make sure the names match up with what automap would normally
    generate, in that the relationship name would be `User.address_collection` and
    the name of the class referred to, from automap’s perspective, is called `address`,
    even though we are referring to it as `Address` within our usage of this class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，更复杂的细节之一是，我们说明了如何覆盖[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象之一，该对象automap将会创建。 为此，我们需要确保名称与automap通常生成的名称相匹配，即关系名称将为`User.address_collection`，并且从automap的角度来看，所引用的类的名称称为`address`，即使我们在对此类的使用中将其称为`Address`。
- en: Overriding Naming Schemes
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖命名方案
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") is tasked
    with producing mapped classes and relationship names based on a schema, which
    means it has decision points in how these names are determined. These three decision
    points are provided using functions which can be passed to the [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method, and are known as [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table"), [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship"), and [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship"). Any or all of these
    functions are provided as in the example below, where we use a “camel case” scheme
    for class names and a “pluralizer” for collection names using the [Inflect](https://pypi.org/project/inflect)
    package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 被要求根据模式生成映射类和关系名称，这意味着它在确定这些名称的方式上有决策点。这三个决策点通过可以传递给[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法的函数来提供，分别称为[`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")、[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship")和[`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship")。以下示例中提供了任意或全部这些函数，我们使用了“驼峰命名法”作为类名，并使用了
    [Inflect](https://pypi.org/project/inflect) 包来对集合名称进行“复数化”：'
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From the above mapping, we would now have classes `User` and `Address`, where
    the collection from `User` to `Address` is called `User.addresses`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的映射中，我们现在会有 `User` 和 `Address` 两个类，其中从 `User` 到 `Address` 的集合被称为 `User.addresses`：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Relationship Detection
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系检测
- en: 'The vast majority of what automap accomplishes is the generation of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") structures based on foreign keys. The mechanism
    by which this works for many-to-one and one-to-many relationships is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: automap 的绝大部分工作是根据外键生成[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")结构。它对于多对一和一对多关系的工作机制如下：
- en: A given [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    known to be mapped to a particular class, is examined for [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已知映射到特定类的给定[`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，会被检查其是否存在[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象。
- en: From each [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), the remote [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object present is matched up to the class to which
    it is to be mapped, if any, else it is skipped.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一个[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，远程的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象被匹配到其要映射的类，如果有的话，否则将被跳过。
- en: As the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") we are examining corresponds to a reference
    from the immediate mapped class, the relationship will be set up as a many-to-one
    referring to the referred class; a corresponding one-to-many backref will be created
    on the referred class referring to this class.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在检查的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对应于从直接映射类的引用，该关系将被设置为指向被引用类的多对一关系；在被引用的类上将创建一个相应的一对多反向引用，指向该类。
- en: If any of the columns that are part of the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") are not nullable (e.g. `nullable=False`),
    a [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") keyword argument of `all, delete-orphan` will be
    added to the keyword arguments to be passed to the relationship or backref. If
    the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") reports that [`ForeignKeyConstraint.ondelete`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete
    "sqlalchemy.schema.ForeignKeyConstraint") is set to `CASCADE` for a not null or
    `SET NULL` for a nullable set of columns, the option [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") flag is set to `True` in the set of relationship
    keyword arguments. Note that not all backends support reflection of ON DELETE.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")的任何一列不可为空（例如，`nullable=False`），将会将`all,
    delete-orphan`的[`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")关键字参数添加到要传递给关联或反向引用的关键字参数中。如果[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")报告对于一组非空列设置了`CASCADE`或对于可为空列设置了`SET NULL`的[`ForeignKeyConstraint.ondelete`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete
    "sqlalchemy.schema.ForeignKeyConstraint")，则将在关系关键字参数集合中将选项[`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")标志设置为`True`。请注意，并非所有后端都支持删除操作的反射。
- en: The names of the relationships are determined using the [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") and [`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") callable functions. It is important
    to note that the default relationship naming derives the name from the **the actual
    class name**. If you’ve given a particular class an explicit name by declaring
    it, or specified an alternate class naming scheme, that’s the name from which
    the relationship name will be derived.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关联的名称是使用[`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")和[`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")可调用函数确定的。重要的是要注意，默认的关联命名从**实际类名**派生名称。如果您通过声明为特定类指定了显式名称，或指定了替代类命名方案，则关系名称将从该名称派生。
- en: The classes are inspected for an existing mapped property matching these names.
    If one is detected on one side, but none on the other side, [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") attempts to create a relationship on the
    missing side, then uses the [`relationship.back_populates`](../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter in order to point the new relationship
    to the other side.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查类以查找与这些名称匹配的现有映射属性。如果在一侧检测到一个属性，但在另一侧没有，则[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")尝试在缺失的一侧创建一个关联，然后使用[`relationship.back_populates`](../relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数指向新关联到另一侧。
- en: In the usual case where no relationship is on either side, [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") produces a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on the “many-to-one” side and matches it to the
    other using the [`relationship.backref`](../relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通常情况下，如果任何一侧都没有关联，则[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")会在“多对一”一侧产生一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，并使用[`relationship.backref`](../relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")参数将其与另一侧匹配。
- en: Production of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and optionally the [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") is handed off to the [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") function, which can be supplied
    by the end-user in order to augment the arguments passed to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") or to make use of custom implementations of these functions.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的生成以及可选的[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")的生成被交由[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")函数处理，该函数可以由最终用户提供，以增强传递给[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")的参数，或者利用这些函数的自定义实现。'
- en: Custom Relationship Arguments
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义关系参数
- en: The [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook can be used to add parameters
    to relationships. For most cases, we can make use of the existing [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function to return the object,
    after augmenting the given keyword dictionary with our own arguments.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")钩子可用于向关系添加参数。对于大多数情况，我们可以利用现有的[`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship")函数，在用自己的参数扩充给定关键字字典后返回对象。'
- en: 'Below is an illustration of how to send [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") and [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") options along to all one-to-many relationships:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何向所有一对多关系发送[`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 和[`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")选项的示例：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Many-to-Many relationships
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will generate
    many-to-many relationships, e.g. those which contain a `secondary` argument. The
    process for producing these is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap")将生成多对多关系，例如包含`secondary`参数的关系。生成这些关系的过程如下：'
- en: A given [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is examined for [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, before any mapped class has
    been assigned to it.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")在分配任何映射类之前将被检查其[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象。
- en: If the table contains two and exactly two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, and all columns within this
    table are members of these two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, the table is assumed to be
    a “secondary” table, and will **not be mapped directly**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表包含两个且仅两个[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象，并且此表中的所有列都是这两个[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象的成员，则假定该表是“次要”表，并且**不会直接映射**。
- en: The two (or one, for self-referential) external tables to which the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") refers to are matched to the classes to which they
    will be mapped, if any.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")引用的两个（对于自引用的情况则为一个）外部表会与它们将要映射到的类匹配，如果有的话。'
- en: If mapped classes for both sides are located, a many-to-many bi-directional
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    pair is created between the two classes.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两边的映射类被定位，那么在两个类之间将创建一个多对多的双向 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 对。
- en: The override logic for many-to-many works the same as that of one-to-many/ many-to-one;
    the [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function is called upon to generate
    the structures and existing attributes will be maintained.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多对多的覆盖逻辑与一对多/多对一的逻辑相同；调用[`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") 函数来生成结构，已存在的属性将被保留。
- en: Relationships with Inheritance
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有继承关系的关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will not
    generate any relationships between two classes that are in an inheritance relationship.
    That is, with two classes given as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 不会在处于继承关系的两个类之间生成任何关系。
    也就是说，给定以下两个类：'
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The foreign key from `Engineer` to `Employee` is used not for a relationship,
    but to establish joined inheritance between the two classes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Engineer`到`Employee`的外键不是用于关系，而是用于在两个类之间建立联合继承。
- en: 'Note that this means automap will not generate *any* relationships for foreign
    keys that link from a subclass to a superclass. If a mapping has actual relationships
    from subclass to superclass as well, those need to be explicit. Below, as we have
    two separate foreign keys from `Engineer` to `Employee`, we need to set up both
    the relationship we want as well as the `inherit_condition`, as these are not
    things SQLAlchemy can guess:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这意味着 automap 将不会为从子类到超类的外键生成 *任何* 关系。 如果映射还具有从子类到超类的实际关系，那么这些关系需要显式说明。 如下，由于从`Engineer`到`Employee`有两个单独的外键，我们需要设置我们想要的关系以及`inherit_condition`，因为这些不是
    SQLAlchemy 可以猜测的事情：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Handling Simple Naming Conflicts
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理简单的命名冲突
- en: 'In the case of naming conflicts during mapping, override any of [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table"), [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship"), and [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship") as needed. For example,
    if automap is attempting to name a many-to-one relationship the same as an existing
    column, an alternate convention can be conditionally selected. Given a schema:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射过程中出现命名冲突的情况下，根据需要覆盖 [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")、[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship") 和 [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship") 中的任何一个。 例如，如果 automap
    正试图将多对一关系命名为现有列相同的名称，可以条件地选择替代约定。 给定一个模式：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The above schema will first automap the `table_a` table as a class named `table_a`;
    it will then automap a relationship onto the class for `table_b` with the same
    name as this related class, e.g. `table_a`. This relationship name conflicts with
    the mapping column `table_b.table_a`, and will emit an error on mapping.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式首先将`table_a`表自动映射为一个名为`table_a`的类；然后将关系自动映射到`table_b`的类上，该关系的名称与此相关类的名称相同，例如`table_a`。
    此关系名称与映射列`table_b.table_a`冲突，并且在映射时会发出错误。
- en: 'We can resolve this conflict by using an underscore as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用下划线来解决此冲突：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, we can change the name on the column side. The columns that
    are mapped can be modified using the technique described at [Naming Declarative
    Mapped Columns Explicitly](../declarative_tables.html#mapper-column-distinct-names),
    by assigning the column explicitly to a new name:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在列方面更改名称。 可以使用在 [Naming Declarative Mapped Columns Explicitly](../declarative_tables.html#mapper-column-distinct-names)
    中描述的技术来修改映射的列，通过将列显式地分配给新名称：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Custom Relationship Arguments
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义关系参数
- en: The [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") hook can be used to add parameters
    to relationships. For most cases, we can make use of the existing [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function to return the object,
    after augmenting the given keyword dictionary with our own arguments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") 钩子可用于向关系添加参数。对于大多数情况，我们可以利用现有的 [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") 函数，在使用我们自己的参数扩充给定的关键字字典后返回对象。'
- en: 'Below is an illustration of how to send [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") and [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") options along to all one-to-many relationships:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将 [`relationship.cascade`](../relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 和 [`relationship.passive_deletes`](../relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 选项传递给所有一对多关系的示例：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Many-to-Many relationships
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will generate
    many-to-many relationships, e.g. those which contain a `secondary` argument. The
    process for producing these is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 将生成多对多关系，例如那些包含
    `secondary` 参数的关系。生成这些关系的过程如下：'
- en: A given [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is examined for [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, before any mapped class has
    been assigned to it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为其分配任何映射类之前，将检查给定的 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 是否包含 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: If the table contains two and exactly two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, and all columns within this
    table are members of these two [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects, the table is assumed to be
    a “secondary” table, and will **not be mapped directly**.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表包含两个并且仅有两个 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象，并且此表中的所有列都是这两个 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象的成员，则假定该表是一个“次要”表，并且**不会直接映射**。
- en: The two (or one, for self-referential) external tables to which the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") refers to are matched to the classes to which they
    will be mapped, if any.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    所引用的两个（或一个，用于自引用）外部表将与它们将被映射到的类匹配，如果有的话。'
- en: If mapped classes for both sides are located, a many-to-many bi-directional
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    pair is created between the two classes.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两侧的映射类位于同一处，则在两个类之间创建一个双向的多对多 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") / [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 对。
- en: The override logic for many-to-many works the same as that of one-to-many/ many-to-one;
    the [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") function is called upon to generate
    the structures and existing attributes will be maintained.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多对多的覆盖逻辑与一对多/多对一的逻辑相同；调用 [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship") 函数来生成结构，并将保留现有属性。
- en: Relationships with Inheritance
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承关系
- en: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") will not
    generate any relationships between two classes that are in an inheritance relationship.
    That is, with two classes given as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[`automap`](#module-sqlalchemy.ext.automap "sqlalchemy.ext.automap") 将不会在处于继承关系的两个类之间生成任何关系。也就是说，对于以下两个给定的类：'
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The foreign key from `Engineer` to `Employee` is used not for a relationship,
    but to establish joined inheritance between the two classes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Engineer` 到 `Employee` 的外键不是用于关系，而是用于在两个类之间建立联合继承。
- en: 'Note that this means automap will not generate *any* relationships for foreign
    keys that link from a subclass to a superclass. If a mapping has actual relationships
    from subclass to superclass as well, those need to be explicit. Below, as we have
    two separate foreign keys from `Engineer` to `Employee`, we need to set up both
    the relationship we want as well as the `inherit_condition`, as these are not
    things SQLAlchemy can guess:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这意味着 automap 不会为从子类到超类的外键生成*任何*关系。如果映射实际上还有从子类到超类的关系，那么这些关系需要是显式的。在下面的例子中，由于从
    `Engineer` 到 `Employee` 有两个单独的外键，我们需要设置我们想要的关系以及 `inherit_condition`，因为这些是 SQLAlchemy
    无法猜测的事情：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Handling Simple Naming Conflicts
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理简单的命名冲突
- en: 'In the case of naming conflicts during mapping, override any of [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table"), [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship"), and [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship") as needed. For example,
    if automap is attempting to name a many-to-one relationship the same as an existing
    column, an alternate convention can be conditionally selected. Given a schema:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射过程中出现命名冲突的情况下，根据需要覆盖任何 [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")、[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship") 和 [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship")。例如，如果 automap 尝试将一个多对一关系命名为现有列的名称，可以有条件地选择替代约定。给定一个模式：
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The above schema will first automap the `table_a` table as a class named `table_a`;
    it will then automap a relationship onto the class for `table_b` with the same
    name as this related class, e.g. `table_a`. This relationship name conflicts with
    the mapping column `table_b.table_a`, and will emit an error on mapping.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式将首先将 `table_a` 表自动映射为名为 `table_a` 的类；然后将在 `table_b` 类上自动映射一个与此相关类相同名称的关系，例如
    `table_a`。这个关系名称与映射列 `table_b.table_a` 冲突，并且在映射时会发出错误。
- en: 'We can resolve this conflict by using an underscore as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用下划线，我们可以解决这个冲突：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Alternatively, we can change the name on the column side. The columns that
    are mapped can be modified using the technique described at [Naming Declarative
    Mapped Columns Explicitly](../declarative_tables.html#mapper-column-distinct-names),
    by assigning the column explicitly to a new name:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在列的一侧更改名称。可以使用在 [显式命名声明性映射列](../declarative_tables.html#mapper-column-distinct-names)
    中描述的技术修改映射的列，通过将列显式分配给一个新名称：
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using Automap with Explicit Declarations
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用具有显式声明的 Automap
- en: 'As noted previously, automap has no dependency on reflection, and can make
    use of any collection of [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects within a [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection. From this, it follows that automap can
    also be used generate missing relationships given an otherwise complete model
    that fully defines table metadata:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所指出的，automap 不依赖于反射，并且可以利用 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象集合中的任何对象在 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合中。由此可见，automap 也可以用于生成缺失的关系，只要有一个完全定义了表元数据的完整模型：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Above, given mostly complete `User` and `Address` mappings, the [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") which we defined on `Address.user_id` allowed
    a bidirectional relationship pair `Address.user` and `User.address_collection`
    to be generated on the mapped classes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，给定了大部分完整的 `User` 和 `Address` 映射，我们在 `Address.user_id` 上定义的 [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 允许在映射类上生成一个双向关系对 `Address.user` 和 `User.address_collection`。
- en: Note that when subclassing [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase"), the [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") method is required; if not called,
    the classes we’ve declared are in an un-mapped state.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当子类化[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")时，需要调用[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")方法；如果未调用，则我们声明的类处于未映射状态。
- en: '## Intercepting Column Definitions'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '## 拦截列定义'
- en: 'The [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    and [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects support an event hook [`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") that may be used to intercept the
    information reflected about a database column before the [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is constructed. For example if we wanted to
    map columns using a naming convention such as `"attr_<columnname>"`, the event
    could be applied as:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")和[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象支持一个事件钩子[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")，可用于在构建[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象之前拦截有关数据库列的反射信息。例如，如果我们想要使用命名约定来映射列，例如`"attr_<columnname>"`，则可以应用该事件如下：'
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'New in version 1.4.0b2: the [`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event may be applied to a [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4.0b2中的新内容：[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")事件可以应用于一个[`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象。
- en: See also
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DDLEvents.column_reflect()`](../../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
- en: '[Automating Column Naming Schemes from Reflected Tables](../declarative_tables.html#mapper-automated-reflection-schemes)
    - in the ORM mapping documentation'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[从反射表自动命名方案](../declarative_tables.html#mapper-automated-reflection-schemes)
    - 在 ORM 映射文档中'
- en: API Reference
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 参考
- en: '| Object Name | Description |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [automap_base](#sqlalchemy.ext.automap.automap_base)([declarative_base],
    **kw) | Produce a declarative automap base. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| [automap_base](#sqlalchemy.ext.automap.automap_base)([declarative_base],
    **kw) | 生成一个声明式自动映射基类。 |'
- en: '| [AutomapBase](#sqlalchemy.ext.automap.AutomapBase) | Base class for an “automap”
    schema. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| [AutomapBase](#sqlalchemy.ext.automap.AutomapBase) | 用于“自动映射”模式的基类。 |'
- en: '| [classname_for_table](#sqlalchemy.ext.automap.classname_for_table)(base,
    tablename, table) | Return the class name that should be used, given the name
    of a table. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| [classname_for_table](#sqlalchemy.ext.automap.classname_for_table)(base,
    tablename, table) | 给定表名，返回应该使用的类名。 |'
- en: '| [generate_relationship](#sqlalchemy.ext.automap.generate_relationship)(base,
    direction, return_fn, attrname, ..., **kw) | Generate a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") on behalf of two mapped classes. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| [generate_relationship](#sqlalchemy.ext.automap.generate_relationship)(base,
    direction, return_fn, attrname, ..., **kw) | 代表两个映射类生成一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或者[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")。 |'
- en: '| [name_for_collection_relationship](#sqlalchemy.ext.automap.name_for_collection_relationship)(base,
    local_cls, referred_cls, constraint) | Return the attribute name that should be
    used to refer from one class to another, for a collection reference. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| [name_for_collection_relationship](#sqlalchemy.ext.automap.name_for_collection_relationship)(base,
    local_cls, referred_cls, constraint) | 返回用于从一个类引用另一个类的属性名称，用于集合引用。 |'
- en: '| [name_for_scalar_relationship](#sqlalchemy.ext.automap.name_for_scalar_relationship)(base,
    local_cls, referred_cls, constraint) | Return the attribute name that should be
    used to refer from one class to another, for a scalar object reference. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| [name_for_scalar_relationship](#sqlalchemy.ext.automap.name_for_scalar_relationship)(base,
    local_cls, referred_cls, constraint) | 返回用于从一个类引用另一个类的属性名称，用于标量对象引用。 |'
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Produce a declarative automap base.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个声明式自动映射基类。
- en: This function produces a new base class that is a product of the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class as well a declarative base produced
    by `declarative_base()`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成一个新的基类，该基类是由 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类和由 `declarative_base()` 产生的声明性基类的产品。
- en: All parameters other than `declarative_base` are keyword arguments that are
    passed directly to the `declarative_base()` function.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `declarative_base` 外的所有参数都是直接传递给 `declarative_base()` 函数的关键字参数。
- en: 'Parameters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`declarative_base` – an existing class produced by `declarative_base()`. When
    this is passed, the function no longer invokes `declarative_base()` itself, and
    all other keyword arguments are ignored.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarative_base` – 由 `declarative_base()` 产生的现有类。当传递此参数时，函数不再调用 `declarative_base()`
    自身，并且所有其他关键字参数都将被忽略。'
- en: '`**kw` – keyword arguments are passed along to `declarative_base()`.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kw` – 关键字参数会传递给 `declarative_base()`。'
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Base class for an “automap” schema.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 用于“automap”模式的基类。
- en: The [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class can be compared to the “declarative base” class that is produced by the
    `declarative_base()` function. In practice, the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is always used as a mixin along with
    an actual declarative base.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类可以与由 `declarative_base()` 函数产生的“声明性基类”类进行比较。在实践中，[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 类始终与实际的声明性基类一起使用作为混入。'
- en: A new subclassable [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    is typically instantiated using the [`automap_base()`](#sqlalchemy.ext.automap.automap_base
    "sqlalchemy.ext.automap.automap_base") function.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的可子类化的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    通常是使用 [`automap_base()`](#sqlalchemy.ext.automap.automap_base "sqlalchemy.ext.automap.automap_base")
    函数实例化的。
- en: '**Members**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[by_module](#sqlalchemy.ext.automap.AutomapBase.by_module), [classes](#sqlalchemy.ext.automap.AutomapBase.classes),
    [metadata](#sqlalchemy.ext.automap.AutomapBase.metadata), [prepare()](#sqlalchemy.ext.automap.AutomapBase.prepare)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[by_module](#sqlalchemy.ext.automap.AutomapBase.by_module), [classes](#sqlalchemy.ext.automap.AutomapBase.classes),
    [metadata](#sqlalchemy.ext.automap.AutomapBase.metadata), [prepare()](#sqlalchemy.ext.automap.AutomapBase.prepare)'
- en: See also
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](#)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[Automap](#)'
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: An instance of `Properties` containing a hierarchal structure of dot-separated
    module names linked to classes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 包含点分隔的模块名称的层次结构，链接到类的 `Properties` 实例。
- en: This collection is an alternative to the [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes") collection that is useful when making
    use of the [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter, which will apply distinct
    `__module__` attributes to generated classes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合是 [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes "sqlalchemy.ext.automap.AutomapBase.classes")
    集合的一种替代方法，当利用 [`AutomapBase.prepare.modulename_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.modulename_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数时，该参数将为生成的类应用不同的 `__module__`
    属性。
- en: 'The default `__module__` an automap-generated class is `sqlalchemy.ext.automap`;
    to access this namespace using [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") looks like:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: automap 生成类的默认 `__module__` 是 `sqlalchemy.ext.automap`；要使用 [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") 访问此命名空间，看起来像这样：
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If a class had a `__module__` of `mymodule.account`, accessing this namespace
    looks like:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类的 `__module__` 是 `mymodule.account`，访问此命名空间看起来像这样：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: New in version 2.0.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版中的新功能。
- en: See also
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Generating Mappings from Multiple Schemas](#automap-by-module)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[从多个模式生成映射](#automap-by-module)'
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An instance of `Properties` containing classes.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 包含类的 `Properties` 实例。
- en: 'This object behaves much like the `.c` collection on a table. Classes are present
    under the name they were given, e.g.:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象的行为类似于表上的 `.c` 集合。类以其给定的名称存在，例如：
- en: '[PRE64]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For class names that overlap with a method name of `Properties`, such as `items()`,
    the getitem form is also supported:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 `Properties` 方法名重叠的类名，例如 `items()`，也支持使用getitem形式：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Refers to the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection that will be used for new [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 指的是将用于新 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合。
- en: See also
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Accessing Table and Metadata](../declarative_tables.html#orm-declarative-metadata)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[访问表和元数据](../declarative_tables.html#orm-declarative-metadata)'
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Extract mapped classes and relationships from the [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") and perform mappings.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [`MetaData`](../../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    中提取映射类和关系，并执行映射。
- en: For full documentation and examples see [Basic Use](#automap-basic-use).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整文档和示例，请参见 [基本使用](#automap-basic-use)。
- en: 'Parameters:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`autoload_with` – an [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with which to perform schema reflection; when
    specified, the [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method will be invoked within the scope
    of this method.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoload_with` – 使用与其执行模式反射的 [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")；当指定时，[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 方法将在此方法的范围内调用。'
- en: '`engine` –'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`engine` –'
- en: legacy; use [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase"). Used to indicate the [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with which to reflect tables with, if [`AutomapBase.reflect`](#sqlalchemy.ext.automap.AutomapBase.params.reflect
    "sqlalchemy.ext.automap.AutomapBase") is True.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已弃用；使用 [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase")。用于指示在反映表时使用的 [`Engine`](../../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，如果 [`AutomapBase.reflect`](#sqlalchemy.ext.automap.AutomapBase.params.reflect
    "sqlalchemy.ext.automap.AutomapBase") 为 True。
- en: 'Deprecated since version 1.4: The [`AutomapBase.prepare.engine`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter is deprecated and will
    be removed in a future release. Please use the [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自版本 1.4 起已弃用：[`AutomapBase.prepare.engine`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数已弃用，并将在未来版本中删除。请使用 [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数。
- en: '`reflect` –'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect` –'
- en: legacy; use [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase"). Indicates that [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") should be invoked.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已弃用；使用 [`AutomapBase.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase")。指示是否应调用 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")。
- en: 'Deprecated since version 1.4: The [`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter is deprecated and will
    be removed in a future release. Reflection is enabled when [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") is passed.'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自版本 1.4 起已弃用：[`AutomapBase.prepare.reflect`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数已弃用，并将在未来版本中删除。当传递了 [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") 时启用反射。
- en: '`classname_for_table` – callable function which will be used to produce new
    class names, given a table name. Defaults to [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table").'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classname_for_table` – 一个可调用的函数，将根据表名生成新类名。默认为 [`classname_for_table()`](#sqlalchemy.ext.automap.classname_for_table
    "sqlalchemy.ext.automap.classname_for_table")。'
- en: '`modulename_for_table` –'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulename_for_table` –'
- en: callable function which will be used to produce the effective `__module__` for
    an internally generated class, to allow for multiple classes of the same name
    in a single automap base which would be in different “modules”.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可调用函数，用于为内部生成的类生成有效的`__module__`，以允许在单个自动映射基类中具有相同名称的多个类，这些类将位于不同的“模块”中。
- en: Defaults to `None`, which will indicate that `__module__` will not be set explicitly;
    the Python runtime will use the value `sqlalchemy.ext.automap` for these classes.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认为`None`，表示`__module__`不会被显式设置；Python运行时将为这些类使用值`sqlalchemy.ext.automap`。
- en: When assigning `__module__` to generated classes, they can be accessed based
    on dot-separated module names using the [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module") collection. Classes that have
    an explicit `__module_` assigned using this hook do **not** get placed into the
    [`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes "sqlalchemy.ext.automap.AutomapBase.classes")
    collection, only into [`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module").
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在为生成的类分配`__module__`时，可以基于点分隔的模块名称使用[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")集合访问它们。使用此钩子分配了显式`__module_`的类**不会**放入[`AutomapBase.classes`](#sqlalchemy.ext.automap.AutomapBase.classes
    "sqlalchemy.ext.automap.AutomapBase.classes")集合中，而只会放入[`AutomapBase.by_module`](#sqlalchemy.ext.automap.AutomapBase.by_module
    "sqlalchemy.ext.automap.AutomapBase.by_module")中。
- en: New in version 2.0.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0版中的新功能。
- en: See also
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Generating Mappings from Multiple Schemas](#automap-by-module)'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[从多个模式生成映射](#automap-by-module)'
- en: '`name_for_scalar_relationship` – callable function which will be used to produce
    relationship names for scalar relationships. Defaults to [`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship").'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_for_scalar_relationship` – 可调用函数，用于为标量关系生成关系名称。默认为[`name_for_scalar_relationship()`](#sqlalchemy.ext.automap.name_for_scalar_relationship
    "sqlalchemy.ext.automap.name_for_scalar_relationship")。'
- en: '`name_for_collection_relationship` – callable function which will be used to
    produce relationship names for collection-oriented relationships. Defaults to
    [`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship").'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_for_collection_relationship` – 可调用函数，用于为面向集合的关系生成关系名称。默认为[`name_for_collection_relationship()`](#sqlalchemy.ext.automap.name_for_collection_relationship
    "sqlalchemy.ext.automap.name_for_collection_relationship")。'
- en: '`generate_relationship` – callable function which will be used to actually
    generate [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") constructs. Defaults to [`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship").'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_relationship` – 可调用函数，用于实际生成[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")构造。默认为[`generate_relationship()`](#sqlalchemy.ext.automap.generate_relationship
    "sqlalchemy.ext.automap.generate_relationship")。'
- en: '`collection_class` – the Python collection class that will be used when a new
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    object is created that represents a collection. Defaults to `list`.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection_class` – 当创建代表集合的新[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象时将使用的Python集合类。默认为`list`。'
- en: '`schema` –'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema` –'
- en: Schema name to reflect when reflecting tables using the [`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter. The name is passed to
    the [`MetaData.reflect.schema`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect") parameter of [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). When omitted, the default schema in use
    by the database connection is used.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反映表时要反映的模式名称，使用[`AutomapBase.prepare.autoload_with`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数。该名称传递给[`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")的[`MetaData.reflect.schema`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect")参数。当省略时，将使用数据库连接使用的默认模式。
- en: Note
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The [`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter supports reflection of
    a single schema at a time. In order to include tables from many schemas, use multiple
    calls to [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare").
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`AutomapBase.prepare.schema`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数支持一次反射单个模式。要包含来自多个模式的表，请多次调用 [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare")。'
- en: For an overview of multiple-schema automap including the use of additional naming
    conventions to resolve table name conflicts, see the section [Generating Mappings
    from Multiple Schemas](#automap-by-module).
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关多模式自动映射的概述，包括使用附加命名约定解决表名冲突的方法，请参阅[从多个模式生成映射](#automap-by-module) 部分。
- en: 'New in version 2.0: [`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") supports being directly invoked
    any number of times, keeping track of tables that have already been processed
    to avoid processing them a second time.'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：[`AutomapBase.prepare()`](#sqlalchemy.ext.automap.AutomapBase.prepare
    "sqlalchemy.ext.automap.AutomapBase.prepare") 可以直接调用任意次数，并跟踪已处理的表，以避免再次处理它们。
- en: '`reflection_options` –'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflection_options` –'
- en: When present, this dictionary of options will be passed to [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") to supply general reflection-specific options
    like `only` and/or dialect-specific options like `oracle_resolve_synonyms`.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当存在时，此选项字典将传递给 [`MetaData.reflect()`](../../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 以提供通用的反射特定选项，如 `only` 和/或特定于方言的选项，如 `oracle_resolve_synonyms`。
- en: New in version 1.4.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本 1.4 中。
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Return the class name that should be used, given the name of a table.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应使用的类名，给定表的名称。
- en: 'The default implementation is:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现为：
- en: '[PRE69]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`AutomapBase.prepare.classname_for_table`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数指定替代实现。
- en: 'Parameters:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 进行准备的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类。'
- en: '`tablename` – string name of the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tablename` – [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的字符串名称。'
- en: '`table` – the [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object itself.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table` – [`Table`](../../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象本身。'
- en: 'Returns:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: a string class name.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串类名。
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 2, the string used for the class name **must** be a non-Unicode object,
    e.g. a `str()` object. The `.name` attribute of [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is typically a Python unicode subclass, so the `str()`
    function should be applied to this name, after accounting for any non-ASCII characters.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2 中，用于类名的字符串 **必须** 是非 Unicode 对象，例如 `str()` 对象。[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的 `.name` 属性通常是 Python unicode 子类，因此应在考虑任何非 ASCII 字符后，应用
    `str()` 函数到此名称。
- en: '[PRE70]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Return the attribute name that should be used to refer from one class to another,
    for a scalar object reference.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应用于从一个类到另一个类的引用的属性名称，用于标量对象引用。
- en: 'The default implementation is:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现为：
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`AutomapBase.prepare.name_for_scalar_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") 参数指定替代实现。
- en: 'Parameters:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 进行准备的 [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    类。'
- en: '`local_cls` – the class to be mapped on the local side.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 映射到本地方的类。'
- en: '`referred_cls` – the class to be mapped on the referring side.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 映射到引用方的类。'
- en: '`constraint` – the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that is being inspected to produce this
    relationship.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraint` – 正在检查以生成此关系的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")。'
- en: '[PRE72]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Return the attribute name that should be used to refer from one class to another,
    for a collection reference.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应用于从一个类到另一个类的引用的属性名称，用于集合引用。
- en: 'The default implementation is:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现如下：
- en: '[PRE73]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Alternate implementations can be specified using the [`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`AutomapBase.prepare.name_for_collection_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数指定替代实现。
- en: 'Parameters:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 执行准备工作的[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类。'
- en: '`local_cls` – the class to be mapped on the local side.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 要映射到本地方的类。'
- en: '`referred_cls` – the class to be mapped on the referring side.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 要映射到引用方的类。'
- en: '`constraint` – the [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that is being inspected to produce this
    relationship.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraint` – 正在检查以生成此关系的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")。'
- en: '[PRE74]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Generate a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") on behalf of two mapped classes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 代表两个映射类生成一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")。
- en: An alternate implementation of this function can be specified using the [`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare") parameter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`AutomapBase.prepare.generate_relationship`](#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship
    "sqlalchemy.ext.automap.AutomapBase.prepare")参数指定此函数的替代实现。
- en: 'The default implementation of this function is as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的默认实现如下：
- en: '[PRE75]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Parameters:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`base` – the [`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")
    class doing the prepare.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` – 执行准备工作的[`AutomapBase`](#sqlalchemy.ext.automap.AutomapBase "sqlalchemy.ext.automap.AutomapBase")类。'
- en: '`direction` – indicate the “direction” of the relationship; this will be one
    of `ONETOMANY`, `MANYTOONE`, `MANYTOMANY`.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction` – 指示关系的“方向”; 这将是`ONETOMANY`、`MANYTOONE`、`MANYTOMANY`之一。'
- en: '`return_fn` – the function that is used by default to create the relationship.
    This will be either [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref"). The [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function’s result will be used to produce a new [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in a second step, so it is critical that user-defined
    implementations correctly differentiate between the two functions, if a custom
    relationship function is being used.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return_fn` – 默认用于创建关系的函数。这将是[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")或[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")之一。[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数的结果将用于在第二步生成新的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，因此如果使用自定义关系函数，则用户定义的实现必须正确区分这两个函数。'
- en: '`attrname` – the attribute name to which this relationship is being assigned.
    If the value of [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") is the [`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function, then this name is the name that is being assigned
    to the backref.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attrname` – 正在分配此关系的属性名称。如果[`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship")的值是[`backref()`](../relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数，则此名称是分配给反向引用的名称。'
- en: '`local_cls` – the “local” class to which this relationship or backref will
    be locally present.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_cls` – 此关系或反向引用将在本地存在的“本地”类。'
- en: '`referred_cls` – the “referred” class to which the relationship or backref
    refers to.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referred_cls` – 此关系或反向引用所指向的“引用”类。'
- en: '`**kw` – all additional keyword arguments are passed along to the function.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kw` – 所有附加的关键字参数都将传递给该函数。'
- en: 'Returns:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值：
- en: a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    construct, as dictated by the [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") parameter.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    或 [`backref()`](../relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    构造，由 [`generate_relationship.return_fn`](#sqlalchemy.ext.automap.generate_relationship.params.return_fn
    "sqlalchemy.ext.automap.generate_relationship") 参数所指定。'
