- en: What’s New in SQLAlchemy 0.6?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.6 中的新功能是什么？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_06.html](https://docs.sqlalchemy.org/en/20/changelog/migration_06.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_06.html](https://docs.sqlalchemy.org/en/20/changelog/migration_06.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.5, last released
    January 16, 2010, and SQLAlchemy version 0.6, last released May 5, 2012.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了 SQLAlchemy 版本 0.5（上次发布于 2010 年 1 月 16 日）与 SQLAlchemy 版本 0.6（上次发布于 2012
    年 5 月 5 日）之间的变化。
- en: 'Document date: June 6, 2010'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档日期：2010 年 6 月 6 日
- en: This guide documents API changes which affect users migrating their applications
    from the 0.5 series of SQLAlchemy to 0.6\. Note that SQLAlchemy 0.6 removes some
    behaviors which were deprecated throughout the span of the 0.5 series, and also
    deprecates more behaviors specific to 0.5.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南记录了影响用户将其应用程序从 SQLAlchemy 0.5 系列迁移到 0.6 版本的 API 更改。请注意，SQLAlchemy 0.6 移除了一些在
    0.5 系列期间已弃用的行为，并且还弃用了更多与 0.5 版本特定的行为。
- en: Platform Support
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: cPython versions 2.4 and upwards throughout the 2.xx series
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cPython 版本 2.4 及以上，遍及 2.xx 系列
- en: Jython 2.5.1 - using the zxJDBC DBAPI included with Jython.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jython 2.5.1 - 使用 Jython 随附的 zxJDBC DBAPI。
- en: cPython 3.x - see [source:sqlalchemy/trunk/README.py3k] for information on how
    to build for python3.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cPython 3.x - 有关如何为 python3 构建的信息，请参见 [source:sqlalchemy/trunk/README.py3k]。
- en: New Dialect System
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的方言系统
- en: Dialect modules are now broken up into distinct subcomponents, within the scope
    of a single database backend. Dialect implementations are now in the `sqlalchemy.dialects`
    package. The `sqlalchemy.databases` package still exists as a placeholder to provide
    some level of backwards compatibility for simple imports.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 方言模块现在被分解为单个数据库后端范围内的不同子组件。方言实现现在位于 `sqlalchemy.dialects` 包中。`sqlalchemy.databases`
    包仍然存在作为占位符，以提供一定程度的向后兼容性，用于简单的导入。
- en: For each supported database, a sub-package exists within `sqlalchemy.dialects`
    where several files are contained. Each package contains a module called `base.py`
    which defines the specific SQL dialect used by that database. It also contains
    one or more “driver” modules, each one corresponding to a specific DBAPI - these
    files are named corresponding to the DBAPI itself, such as `pysqlite`, `cx_oracle`,
    or `pyodbc`. The classes used by SQLAlchemy dialects are first declared in the
    `base.py` module, defining all behavioral characteristics defined by the database.
    These include capability mappings, such as “supports sequences”, “supports returning”,
    etc., type definitions, and SQL compilation rules. Each “driver” module in turn
    provides subclasses of those classes as needed which override the default behavior
    to accommodate the additional features, behaviors, and quirks of that DBAPI. For
    DBAPIs that support multiple backends (pyodbc, zxJDBC, mxODBC), the dialect module
    will use mixins from the `sqlalchemy.connectors` package, which provide functionality
    common to that DBAPI across all backends, most typically dealing with connect
    arguments. This means that connecting using pyodbc, zxJDBC or mxODBC (when implemented)
    is extremely consistent across supported backends.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个受支持的数据库，在 `sqlalchemy.dialects` 中都存在一个子包，其中包含几个文件。每个包包含一个名为 `base.py` 的模块，该模块定义了该数据库使用的特定
    SQL 方言。它还包含一个或多个“driver”模块，每个模块对应一个特定的 DBAPI - 这些文件的名称与 DBAPI 本身相对应，例如 `pysqlite`、`cx_oracle`
    或 `pyodbc`。SQLAlchemy 方言使用的类首先在 `base.py` 模块中声明，定义数据库定义的所有行为特征。这些包括能力映射，例如“支持序列”，“支持返回”等，类型定义和
    SQL 编译规则。然后，每个“driver”模块根据需要提供那些类的子类，这些子类覆盖默认行为，以适应该 DBAPI 的附加功能、行为和怪癖。对于支持多个后端的
    DBAPI（如 pyodbc、zxJDBC、mxODBC），方言模块将使用来自 `sqlalchemy.connectors` 包的混合物，这些混合物提供了跨所有后端的该
    DBAPI 的功能，最常见的是处理连接参数。这意味着使用 pyodbc、zxJDBC 或 mxODBC（当实现时）进行连接在受支持的后端上是非常一致的。
- en: 'The URL format used by `create_engine()` has been enhanced to handle any number
    of DBAPIs for a particular backend, using a scheme that is inspired by that of
    JDBC. The previous format still works, and will select a “default” DBAPI implementation,
    such as the PostgreSQL URL below that will use psycopg2:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_engine()` 使用的 URL 格式已经增强，以处理特定后端的任意数量的 DBAPI，使用的方案受到 JDBC 的启发。以前的格式仍然有效，并且将选择“默认”DBAPI
    实现，例如下面的 PostgreSQL URL 将使用 psycopg2：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However to specify a specific DBAPI backend such as pg8000, add it to the “protocol”
    section of the URL using a plus sign “+”:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要指定特定的 DBAPI 后端，比如 pg8000，请将其添加到 URL 的“protocol”部分，使用加号“+”：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Important Dialect Links:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的方言链接：
- en: 'Documentation on connect arguments: [https://www.sqlalchemy.org/docs/06/dbengine.html#create](https://www.sqlalchemy.org/docs/06/dbengine.html#create)-
    engine-url-arguments.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接参数的文档：[https://www.sqlalchemy.org/docs/06/dbengine.html#create](https://www.sqlalchemy.org/docs/06/dbengine.html#create)-
    engine-url-arguments。
- en: 'Reference documentation for individual dialects: [https://ww](https://ww) w.sqlalchemy.org/docs/06/reference/dialects/index.html'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个别方言的参考文档：[https://ww](https://ww) w.sqlalchemy.org/docs/06/reference/dialects/index.html
- en: The tips and tricks at DatabaseNotes.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DatabaseNotes上的技巧和窍门。
- en: 'Other notes regarding dialects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方言的其他注意事项：
- en: the type system has been changed dramatically in SQLAlchemy 0.6\. This has an
    impact on all dialects regarding naming conventions, behaviors, and implementations.
    See the section on “Types” below.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.6中类型系统发生了巨大变化。这对所有方言都有影响，包括命名约定、行为和实现。请参阅下面关于“类型”的部分。
- en: the `ResultProxy` object now offers a 2x speed improvement in some cases thanks
    to some refactorings.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy`对象现在在某些情况下提供了2倍的速度改进，这要归功于一些重构。'
- en: the `RowProxy`, i.e. individual result row object, is now directly pickleable.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowProxy`，即单个结果行对象，现在可以直接进行pickle。'
- en: the setuptools entrypoint used to locate external dialects is now called `sqlalchemy.dialects`.
    An external dialect written against 0.4 or 0.5 will need to be modified to work
    with 0.6 in any case so this change does not add any additional difficulties.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setuptools入口点现在用于定位外部方言的名称是`sqlalchemy.dialects`。针对0.4或0.5编写的外部方言需要修改以适应0.6，在任何情况下这个改变并不增加任何额外的困难。
- en: dialects now receive an initialize() event on initial connection to determine
    connection properties.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言现在在初始连接时接收一个initialize()事件来确定连接属性。
- en: Functions and operators generated by the compiler now use (almost) regular dispatch
    functions of the form “visit_<opname>” and “visit_<funcname>_fn” to provide customed
    processing. This replaces the need to copy the “functions” and “operators” dictionaries
    in compiler subclasses with straightforward visitor methods, and also allows compiler
    subclasses complete control over rendering, as the full _Function or _BinaryExpression
    object is passed in.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器生成的函数和操作符现在使用（几乎）常规的调度函数形式“visit_<opname>”和“visit_<funcname>_fn”来提供定制处理。这取代了在编译器子类中复制“functions”和“operators”字典的需要，改为使用直接的访问者方法，同时也允许编译器子类完全控制渲染，因为完整的_Function或_BinaryExpression对象被传递进来。
- en: Dialect Imports
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方言导入
- en: 'The import structure of dialects has changed. Each dialect now exports its
    base “dialect” class as well as the full set of SQL types supported on that dialect
    via `sqlalchemy.dialects.<name>`. For example, to import a set of PG types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方言的导入结构已经改变。每个方言现在通过`sqlalchemy.dialects.<name>`导出其基本的“dialect”类以及该方言支持的完整一组SQL类型。例如，要导入一组PG类型：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Above, `INTEGER` is actually the plain `INTEGER` type from `sqlalchemy.types`,
    but the PG dialect makes it available in the same way as those types which are
    specific to PG, such as `BYTEA` and `MACADDR`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`INTEGER`实际上是来自`sqlalchemy.types`的普通`INTEGER`类型，但PG方言使其以与那些特定于PG的类型相同的方式可用，例如`BYTEA`和`MACADDR`。
- en: Expression Language Changes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语言变化
- en: An Important Expression Language Gotcha
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个重要的表达式语言陷阱
- en: There’s one quite significant behavioral change to the expression language which
    may affect some applications. The boolean value of Python boolean expressions,
    i.e. `==`, `!=`, and similar, now evaluates accurately with regards to the two
    clause objects being compared.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语言有一个相当重要的行为变化，可能会影响一些应用程序。Python布尔表达式的布尔值，即`==`、`!=`等，现在在比较两个子句对象时会准确评估。
- en: 'As we know, comparing a `ClauseElement` to any other object returns another
    `ClauseElement`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，将`ClauseElement`与任何其他对象进行比较会返回另一个`ClauseElement`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This so that Python expressions produce SQL expressions when converted to strings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样Python表达式在转换为字符串时会产生SQL表达式：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But what happens if we say this?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们这样说会发生什么？
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In previous versions of SQLAlchemy, the returned `_BinaryExpression` was a
    plain Python object which evaluated to `True`. Now it evaluates to whether or
    not the actual `ClauseElement` should have the same hash value as to that being
    compared. Meaning:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的SQLAlchemy版本中，返回的`_BinaryExpression`是一个普通的Python对象，其求值为`True`。现在它的求值取决于实际的`ClauseElement`是否应该具有与被比较的相同哈希值。意思是：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That means code such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如下代码：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Would not evaluate if `expression` was a binary clause. Since the above pattern
    should never be used, the base `ClauseElement` now raises an exception if called
    in a boolean context:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `expression` 是二进制子句，则不会被评估。由于上述模式永远不应该被使用，因此基本的 `ClauseElement` 现在在布尔上下文中调用时会引发异常：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code that wants to check for the presence of a `ClauseElement` expression should
    instead say:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 希望检查 `ClauseElement` 表达式是否存在的代码应该这样说：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind, **this applies to Table and Column objects too**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**这也适用于 Table 和 Column 对象**。
- en: 'The rationale for the change is twofold:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更改的理由有两个：
- en: Comparisons of the form `if c1 == c2:  <do something>` can actually be written
    now
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形如 `if c1 == c2:  <do something>` 的比较现在可以这样写了。
- en: Support for correct hashing of `ClauseElement` objects now works on alternate
    platforms, namely Jython. Up until this point SQLAlchemy relied heavily on the
    specific behavior of cPython in this regard (and still had occasional problems
    with it).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在支持在其他平台（即 Jython）上正确对 `ClauseElement` 对象进行哈希处理。直到这一点，SQLAlchemy 在这方面严重依赖 cPython
    的特定行为（并且仍然偶尔出现问题）。
- en: Stricter “executemany” Behavior
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更严格的“executemany”行为
- en: 'An “executemany” in SQLAlchemy corresponds to a call to `execute()`, passing
    along a collection of bind parameter sets:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 中的“executemany”对应于调用 `execute()`，传递一系列绑定参数集：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the `Connection` object sends off the given `insert()` construct for compilation,
    it passes to the compiler the keynames present in the first set of binds passed
    along to determine the construction of the statement’s VALUES clause. Users familiar
    with this construct will know that additional keys present in the remaining dictionaries
    don’t have any impact. What’s different now is that all subsequent dictionaries
    need to include at least *every* key that is present in the first dictionary.
    This means that a call like this no longer works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Connection` 对象发送给定的 `insert()` 构造进行编译时，它传递给编译器传递的第一组绑定中存在的键名，以确定语句的 VALUES
    子句的构造。熟悉这种构造的用户会知道，剩余字典中存在的额外键没有任何影响。现在的不同之处在于，所有后续字典都需要至少包含第一个字典中存在的*每个*键。这意味着像这样的调用不再起作用：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because the third row does not specify the ‘timestamp’ column. Previous versions
    of SQLAlchemy would simply insert NULL for these missing columns. However, if
    the `timestamp` column in the above example contained a Python-side default value
    or function, it would *not* be used. This because the “executemany” operation
    is optimized for maximum performance across huge numbers of parameter sets, and
    does not attempt to evaluate Python-side defaults for those missing keys. Because
    defaults are often implemented either as SQL expressions which are embedded inline
    with the INSERT statement, or are server side expressions which again are triggered
    based on the structure of the INSERT string, which by definition cannot fire off
    conditionally based on each parameter set, it would be inconsistent for Python
    side defaults to behave differently vs. SQL/server side defaults. (SQL expression
    based defaults are embedded inline as of the 0.5 series, again to minimize the
    impact of huge numbers of parameter sets).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第三行没有指定‘timestamp’列。之前的 SQLAlchemy 版本会简单地为这些缺失的列插入 NULL。然而，如果上面示例中的 `timestamp`
    列包含 Python 端的默认值或函数，则*不会*被使用。这是因为“executemany”操作针对大量参数集的最大性能进行了优化，并且不会尝试评估那些缺失键的
    Python 端默认值。由于默认值通常被实现为嵌入在 INSERT 语句中的 SQL 表达式，或者是服务器端表达式，再次根据 INSERT 字符串的结构触发，这些默认值无法根据每个参数集有条件地触发，因此
    Python 端默认值与 SQL/服务器端默认值的行为不同是不一致的。（基于 SQL 表达式的默认值从 0.5 系列开始嵌入在内部，再次为了最小化大量参数集的影响）。
- en: SQLAlchemy 0.6 therefore establishes predictable consistency by forbidding any
    subsequent parameter sets from leaving any fields blank. That way, there’s no
    more silent failure of Python side default values and functions, which additionally
    are allowed to remain consistent in their behavior versus SQL and server side
    defaults.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SQLAlchemy 0.6 通过禁止任何后续参数集留下任何字段空白来建立可预测的一致性。这样，Python 端默认值和函数就不会再默默失败，而且它们的行为与
    SQL 和服务器端默认值保持一致。
- en: UNION and other “compound” constructs parenthesize consistently
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNION 和其他“复合”结构都有一致的括号配对。
- en: 'A rule that was designed to help SQLite has been removed, that of the first
    compound element within another compound (such as, a `union()` inside of an `except_()`)
    wouldn’t be parenthesized. This is inconsistent and produces the wrong results
    on PostgreSQL, which has precedence rules regarding INTERSECTION, and its generally
    a surprise. When using complex composites with SQLite, you now need to turn the
    first element into a subquery (which is also compatible on PG). A new example
    is in the SQL expression tutorial at the end of [[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]. See [#1665](https://www.sqlalchemy.org/trac/ticket/1665)
    and r6690 for more background.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '为了帮助SQLite而设计的规则已被移除，即在另一个复合元素内的第一个复合元素（例如，在`except_()`内部的`union()`）不会被括号括起来。这是不一致的，并且在PostgreSQL上产生错误的结果，因为它对INTERSECTION有优先规则，这通常会让人感到惊讶。在与SQLite使用复杂复合时，现在需要将第一个元素转换为子查询（这也在PG上兼容）。在SQL表达式教程的最后有一个新的示例[[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]。更多背景信息请参见[#1665](https://www.sqlalchemy.org/trac/ticket/1665)和r6690。'
- en: C Extensions for Result Fetching
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于结果提取的C扩展
- en: The `ResultProxy` and related elements, including most common “row processing”
    functions such as unicode conversion, numerical/boolean conversions and date parsing,
    have been re-implemented as optional C extensions for the purposes of performance.
    This represents the beginning of SQLAlchemy’s path to the “dark side” where we
    hope to continue improving performance by reimplementing critical sections in
    C. The extensions can be built by specifying `--with-cextensions`, i.e. `python
    setup.py --with- cextensions install`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultProxy`及其相关元素，包括大多数常见的“行处理”函数，如Unicode转换、数值/布尔转换和日期解析，已经被重新实现为可选的C扩展，以提高性能。这标志着SQLAlchemy走向“黑暗面”的开始，我们希望通过在C中重新实现关键部分来持续改进性能。可以通过指定`--with-cextensions`来构建这些扩展，即`python
    setup.py --with- cextensions install`。'
- en: The extensions have the most dramatic impact on result fetching using direct
    `ResultProxy` access, i.e. that which is returned by `engine.execute()`, `connection.execute()`,
    or `session.execute()`. Within results returned by an ORM `Query` object, result
    fetching is not as high a percentage of overhead, so ORM performance improves
    more modestly, and mostly in the realm of fetching large result sets. The performance
    improvements highly depend on the dbapi in use and on the syntax used to access
    the columns of each row (eg `row['name']` is much faster than `row.name`). The
    current extensions have no impact on the speed of inserts/updates/deletes, nor
    do they improve the latency of SQL execution, that is, an application that spends
    most of its time executing many statements with very small result sets will not
    see much improvement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展对使用直接`ResultProxy`访问的结果提取影响最为显著，即由`engine.execute()`、`connection.execute()`或`session.execute()`返回的结果。在ORM
    `Query`对象返回的结果中，结果提取不占很高的开销比例，因此ORM性能改善较为适度，主要体现在提取大型结果集方面。性能改进高度依赖于使用的dbapi以及访问每行列的语法（例如，`row['name']`比`row.name`快得多）。当前的扩展对插入/更新/删除的速度没有影响，也不会改善SQL执行的延迟，也就是说，一个大部分时间用于执行许多语句且结果集非常小的应用程序不会看到太多改进。
- en: 'Performance has been improved in 0.6 versus 0.5 regardless of the extensions.
    A quick overview of what connecting and fetching 50,000 rows looks like with SQLite,
    using mostly direct SQLite access, a `ResultProxy`, and a simple mapped ORM object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展无关，0.6版本的性能比0.5版本有所提高。使用SQLite连接和提取50000行的快速概述，主要使用直接的SQLite访问、`ResultProxy`和简单的映射ORM对象：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Above, the ORM fetches the rows 33% faster than 0.5 due to in-python performance
    enhancements. With the C extensions we get another 20%. However, `ResultProxy`
    fetches improve by 67% with the C extension versus not. Other tests report as
    much as a 200% speed improvement for some scenarios, such as those where lots
    of string conversions are occurring.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，ORM由于Python中的性能增强，比0.5版本快33%。使用C扩展，我们又获得了20%的提升。然而，与不使用C扩展相比，`ResultProxy`的提取速度提高了67%。其他测试报告显示，在某些场景中，如发生大量字符串转换的情况下，速度提高了多达200%。
- en: New Schema Capabilities
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的模式功能
- en: 'The `sqlalchemy.schema` package has received some long- needed attention. The
    most visible change is the newly expanded DDL system. In SQLAlchemy, it was possible
    since version 0.5 to create custom DDL strings and associate them with tables
    or metadata objects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.schema`包得到了一些长期需要的关注。最显著的变化是新扩展的DDL系统。在SQLAlchemy中，自版本0.5以来，可以创建自定义的DDL字符串并将其与表或元数据对象关联：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now the full suite of DDL constructs are available under the same system, including
    those for CREATE TABLE, ADD CONSTRAINT, etc.:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完整的DDL构造都在同一系统下可用，包括用于CREATE TABLE、ADD CONSTRAINT等的构造：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, all the DDL objects are now regular `ClauseElement` objects just
    like any other SQLAlchemy expression object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有DDL对象现在都是常规的`ClauseElement`对象，就像任何其他SQLAlchemy表达式对象一样：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'and using the `sqlalchemy.ext.compiler` extension you can make your own:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用`sqlalchemy.ext.compiler`扩展，你可以自己制作：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Deprecated/Removed Schema Elements
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃/移除的模式元素
- en: The schema package has also been greatly streamlined. Many options and methods
    which were deprecated throughout 0.5 have been removed. Other little known accessors
    and methods have also been removed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模式包也经过了大幅简化。在整个0.5版本中被废弃的许多选项和方法已被移除。其他鲜为人知的访问器和方法也已被移除。
- en: the “owner” keyword argument is removed from `Table`. Use “schema” to represent
    any namespaces to be prepended to the table name.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “owner”关键字参数从`Table`中移除。使用“schema”表示要预置到表名之前的任何命名空间。
- en: deprecated `MetaData.connect()` and `ThreadLocalMetaData.connect()` have been
    removed - send the “bind” attribute to bind a metadata.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的`MetaData.connect()`和`ThreadLocalMetaData.connect()`已被移除 - 将“bind”属性发送到绑定元数据。
- en: deprecated metadata.table_iterator() method removed (use sorted_tables)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的metadata.table_iterator()方法已移除（使用sorted_tables）
- en: the “metadata” argument is removed from `DefaultGenerator` and subclasses, but
    remains locally present on `Sequence`, which is a standalone construct in DDL.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DefaultGenerator`和子类中移除了“metadata”参数，但在`Sequence`上仍然本地存在，`Sequence`是DDL中的一个独立构造。
- en: deprecated `PassiveDefault` - use `DefaultClause`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的`PassiveDefault` - 使用`DefaultClause`。
- en: 'Removed public mutability from `Index` and `Constraint` objects:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Index`和`Constraint`对象中移除了公共可变性：
- en: '`ForeignKeyConstraint.append_element()`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKeyConstraint.append_element()`'
- en: '`Index.append_column()`'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index.append_column()`'
- en: '`UniqueConstraint.append_column()`'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint.append_column()`'
- en: '`PrimaryKeyConstraint.add()`'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.add()`'
- en: '`PrimaryKeyConstraint.remove()`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.remove()`'
- en: These should be constructed declaratively (i.e. in one construction).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该以声明方式构建（即一次构建）。
- en: 'Other removed things:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他已移除的内容：
- en: '`Table.key` (no idea what this was for)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.key`（不知道这是干什么的）'
- en: '`Column.bind` (get via column.table.bind)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.bind`（通过column.table.bind获取）'
- en: '`Column.metadata` (get via column.table.metadata)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.metadata`（通过column.table.metadata获取）'
- en: '`Column.sequence` (use column.default)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.sequence`（使用column.default）'
- en: Other Behavioral Changes
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他行为变化
- en: '`UniqueConstraint`, `Index`, `PrimaryKeyConstraint` all accept lists of column
    names or column objects as arguments.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint`，`Index`，`PrimaryKeyConstraint`都接受列名或列对象的列表作为参数。'
- en: The `use_alter` flag on `ForeignKey` is now a shortcut option for operations
    that can be hand-constructed using the `DDL()` event system. A side effect of
    this refactor is that `ForeignKeyConstraint` objects with `use_alter=True` will
    *not* be emitted on SQLite, which does not support ALTER for foreign keys. This
    has no effect on SQLite’s behavior since SQLite does not actually honor FOREIGN
    KEY constraints.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKey`上的`use_alter`标志现在是一个快捷选项，用于可以使用`DDL()`事件系统手动构建的操作。这次重构的一个副作用是，具有`use_alter=True`的`ForeignKeyConstraint`对象将不会在SQLite上发出，因为SQLite不支持外键的ALTER。这对SQLite的行为没有影响，因为SQLite实际上不遵守外键约束。'
- en: '`Table.primary_key` is not assignable - use `table.append_constraint(PrimaryKeyConstraint(...))`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.primary_key`不可分配 - 使用`table.append_constraint(PrimaryKeyConstraint(...))`'
- en: A `Column` definition with a `ForeignKey` and no type, e.g. `Column(name, ForeignKey(sometable.c.somecol))`
    used to get the type of the referenced column. Now support for that automatic
    type inference is partial and may not work in all cases.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`ForeignKey`但没有类型的`Column`定义，例如`Column(name, ForeignKey(sometable.c.somecol))`曾经可以获得引用列的类型。现在对于该自动类型推断的支持是部分的，可能不适用于所有情况。
- en: Logging opened up
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志打开了
- en: At the expense of a few extra method calls here and there, you can set log levels
    for INFO and DEBUG after an engine, pool, or mapper has been created, and logging
    will commence. The `isEnabledFor(INFO)` method is now called per-`Connection`
    and `isEnabledFor(DEBUG)` per-`ResultProxy` if already enabled on the parent connection.
    Pool logging sends to `log.info()` and `log.debug()` with no check - note that
    pool checkout/checkin is typically once per transaction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在引擎、池或映射器创建后进行一些额外的方法调用，您可以设置INFO和DEBUG的日志级别，日志记录将开始。现在，isEnabledFor(INFO)方法将每个Connection调用一次，isEnabledFor(DEBUG)将每个ResultProxy调用一次，如果已在父连接上启用。池日志发送到log.info()和log.debug()，无需检查
    - 请注意，池的检出/归还通常是每个事务一次。
- en: Reflection/Inspector API
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射/检查器API
- en: The reflection system, which allows reflection of table columns via `Table('sometable',
    metadata, autoload=True)` has been opened up into its own fine-grained API, which
    allows direct inspection of database elements such as tables, columns, constraints,
    indexes, and more. This API expresses return values as simple lists of strings,
    dictionaries, and `TypeEngine` objects. The internals of `autoload=True` now build
    upon this system such that the translation of raw database information into `sqlalchemy.schema`
    constructs is centralized and the contract of individual dialects greatly simplified,
    vastly reducing bugs and inconsistencies across different backends.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统，允许通过Table('sometable', metadata, autoload=True)反射表列的系统已经开放为自己的细粒度API，允许直接检查数据库元素，如表、列、约束、索引等。这个API将返回值表达为简单的字符串列表、字典和TypeEngine对象。现在，autoload=True的内部构建在这个系统之上，将原始数据库信息转换为sqlalchemy.schema构造集中化，各个方言的契约大大简化，大大减少了不同后端之间的错误和不一致性。
- en: 'To use an inspector:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用检查器：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'the `from_engine()` method will in some cases provide a backend-specific inspector
    with additional capabilities, such as that of PostgreSQL which provides a `get_table_oid()`
    method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，from_engine()方法将提供一个特定于后端的检查器，具有额外的功能，例如PostgreSQL提供了一个get_table_oid()方法：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: RETURNING Support
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RETURNING支持
- en: The `insert()`, `update()` and `delete()` constructs now support a `returning()`
    method, which corresponds to the SQL RETURNING clause as supported by PostgreSQL,
    Oracle, MS-SQL, and Firebird. It is not supported for any other backend at this
    time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: insert()、update()和delete()构造现在支持一个returning()方法，对应于SQL RETURNING子句，支持PostgreSQL、Oracle、MS-SQL和Firebird。目前不支持其他后端。
- en: 'Given a list of column expressions in the same manner as that of a `select()`
    construct, the values of these columns will be returned as a regular result set:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个与select()构造相同方式的列表达式列表，这些列的值将作为常规结果集返回：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The implementation of RETURNING across the four supported backends varies wildly,
    in the case of Oracle requiring an intricate usage of OUT parameters which are
    re-routed into a “mock” result set, and in the case of MS-SQL using an awkward
    SQL syntax. The usage of RETURNING is subject to limitations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 四个支持后端的RETURNING实现差异很大，Oracle需要复杂使用OUT参数，这些参数被重新路由到一个“模拟”结果集中，而MS-SQL使用笨拙的SQL语法。RETURNING的使用受到限制：
- en: it does not work for any “executemany()” style of execution. This is a limitation
    of all supported DBAPIs.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于任何“executemany()”风格的执行。这是所有支持的DBAPI的限制。
- en: Some backends, such as Oracle, only support RETURNING that returns a single
    row - this includes UPDATE and DELETE statements, meaning the update() or delete()
    construct must match only a single row, or an error is raised (by Oracle, not
    SQLAlchemy).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些后端，比如Oracle，只支持返回单行的RETURNING - 这包括UPDATE和DELETE语句，这意味着update()或delete()构造必须仅匹配单行，否则会引发错误（由Oracle而不是SQLAlchemy引发）。
- en: RETURNING is also used automatically by SQLAlchemy, when available and when
    not otherwise specified by an explicit `returning()` call, to fetch the value
    of newly generated primary key values for single-row INSERT statements. This means
    there’s no more “SELECT nextval(sequence)” pre- execution for insert statements
    where the primary key value is required. Truth be told, implicit RETURNING feature
    does incur more method overhead than the old “select nextval()” system, which
    used a quick and dirty cursor.execute() to get at the sequence value, and in the
    case of Oracle requires additional binding of out parameters. So if method/protocol
    overhead is proving to be more expensive than additional database round trips,
    the feature can be disabled by specifying `implicit_returning=False` to `create_engine()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当单行INSERT语句需要获取新生成的主键值时，SQLAlchemy也会自动使用RETURNING，当没有通过显式的`returning()`调用另行指定时。这意味着在需要主键值的插入语句中不再需要“SELECT
    nextval(sequence)”预执行。说实话，隐式RETURNING功能确实比旧的“select nextval()”系统产生更多的方法开销，后者使用快速而简单的cursor.execute()来获取序列值，并且在Oracle的情况下需要额外绑定输出参数。因此，如果方法/协议开销比额外的数据库往返更昂贵，可以通过在`create_engine()`中指定`implicit_returning=False`来禁用该功能。
- en: Type System Changes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型系统更改
- en: New Architecture
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新架构
- en: 'The type system has been completely reworked behind the scenes to provide two
    goals:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统在幕后完全重建，以实现两个目标：
- en: Separate the handling of bind parameters and result row values, typically a
    DBAPI requirement, from the SQL specification of the type itself, which is a database
    requirement. This is consistent with the overall dialect refactor that separates
    database SQL behavior from DBAPI.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将绑定参数和结果行值的处理分开，通常是DBAPI的要求，与类型本身的SQL规范分开，这是与总体方言重构一致的，将数据库SQL行为与DBAPI分开。
- en: Establish a clear and consistent contract for generating DDL from a `TypeEngine`
    object and for constructing `TypeEngine` objects based on column reflection.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为从`TypeEngine`对象生成DDL和基于列反射构造`TypeEngine`对象建立明确一致的契约。
- en: 'Highlights of these changes include:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化的亮点包括：
- en: The construction of types within dialects has been totally overhauled. Dialects
    now define publicly available types as UPPERCASE names exclusively, and internal
    implementation types using underscore identifiers (i.e. are private). The system
    by which types are expressed in SQL and DDL has been moved to the compiler system.
    This has the effect that there are much fewer type objects within most dialects.
    A detailed document on this architecture for dialect authors is in [source:/lib/sqlalc
    hemy/dialects/type_migration_guidelines.txt].
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言中类型的构建已经彻底改变。方言现在专门将公开可用的类型定义为大写名称，并使用下划线标识符（即私有）来定义内部实现类型。用于在SQL和DDL中表达类型的系统已移至编译器系统。这样做的效果是大多数方言中的类型对象要少得多。有关此架构的详细文档供方言作者参考在[source:/lib/sqlalchemy/dialects/type_migration_guidelines.txt]中。
- en: Reflection of types now returns the exact UPPERCASE type within types.py, or
    the UPPERCASE type within the dialect itself if the type is not a standard SQL
    type. This means reflection now returns more accurate information about reflected
    types.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在类型的反射返回types.py中的确切大写类型，或者如果类型不是标准SQL类型，则返回方言本身中的大写类型。这意味着反射现在返回有关反射类型的更准确信息。
- en: User defined types that subclass `TypeEngine` and wish to provide `get_col_spec()`
    should now subclass `UserDefinedType`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类型，如果要提供`get_col_spec()`方法，现在应该继承`UserDefinedType`。
- en: The `result_processor()` method on all type classes now accepts an additional
    argument `coltype`. This is the DBAPI type object attached to cursor.description,
    and should be used when applicable to make better decisions on what kind of result-processing
    callable should be returned. Ideally result processor functions would never need
    to use `isinstance()`, which is an expensive call at this level.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型类上的`result_processor()`方法现在接受额外的参数`coltype`。这是附加到cursor.description的DBAPI类型对象，应在适用时使用，以便更好地决定应返回什么类型的结果处理可调用函数。理想情况下，结果处理函数永远不应该使用`isinstance()`，因为在这个级别上这是一个昂贵的调用。
- en: Native Unicode Mode
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地Unicode模式
- en: 'As more DBAPIs support returning Python unicode objects directly, the base
    dialect now performs a check upon the first connection which establishes whether
    or not the DBAPI returns a Python unicode object for a basic select of a VARCHAR
    value. If so, the `String` type and all subclasses (i.e. `Text`, `Unicode`, etc.)
    will skip the “unicode” check/conversion step when result rows are received. This
    offers a dramatic performance increase for large result sets. The “unicode mode”
    currently is known to work with:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多的DBAPI支持直接返回Python Unicode对象，基本方言现在在第一次连接时执行检查，以确定DBAPI是否为基本的VARCHAR值的基本选择返回Python
    Unicode对象。如果是这样，`String`类型和所有子类（即`Text`，`Unicode`等）将在接收到结果行时跳过“unicode”检查/转换步骤。这为大型结果集提供了显著的性能提升。目前已知“unicode模式”可以与以下一起使用：
- en: sqlite3 / pysqlite
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3 / pysqlite
- en: psycopg2 - SQLA 0.6 now uses the “UNICODE” type extension by default on each
    psycopg2 connection object
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2 - SQLA 0.6现在默认在每个psycopg2连接对象上使用“UNICODE”类型扩展
- en: pg8000
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg8000
- en: cx_oracle (we use an output processor - nice feature !)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_oracle（我们使用输出处理器 - 很好的功能！）
- en: Other types may choose to disable unicode processing as needed, such as the
    `NVARCHAR` type when used with MS-SQL.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型可能会根据需要禁用Unicode处理，例如在与MS-SQL一起使用时的`NVARCHAR`类型。
- en: In particular, if porting an application based on a DBAPI that formerly returned
    non-unicode strings, the “native unicode” mode has a plainly different default
    behavior - columns that are declared as `String` or `VARCHAR` now return unicode
    by default whereas they would return strings before. This can break code which
    expects non-unicode strings. The psycopg2 “native unicode” mode can be disabled
    by passing `use_native_unicode=False` to `create_engine()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果迁移基于以前返回非Unicode字符串的DBAPI的应用程序，则“本地Unicode”模式具有明显不同的默认行为 - 声明为`String`或`VARCHAR`的列现在默认返回Unicode，而以前会返回字符串。这可能会破坏期望非Unicode字符串的代码。可以通过向`create_engine()`传递`use_native_unicode=False`来禁用psycopg2的“本地Unicode”模式。
- en: 'A more general solution for string columns that explicitly do not want a unicode
    object is to use a `TypeDecorator` that converts unicode back to utf-8, or whatever
    is desired:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更通用的解决方案是针对明确不想要Unicode对象的字符串列使用`TypeDecorator`，将Unicode转换回utf-8，或者其他所需的格式：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that the `assert_unicode` flag is now deprecated. SQLAlchemy allows the
    DBAPI and backend database in use to handle Unicode parameters when available,
    and does not add operational overhead by checking the incoming type; modern systems
    like sqlite and PostgreSQL will raise an encoding error on their end if invalid
    data is passed. In those cases where SQLAlchemy does need to coerce a bind parameter
    from Python Unicode to an encoded string, or when the Unicode type is used explicitly,
    a warning is raised if the object is a bytestring. This warning can be suppressed
    or converted to an exception using the Python warnings filter documented at: [https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`assert_unicode`标志现已弃用。SQLAlchemy允许DBAPI和后端数据库在可用时处理Unicode参数，并且不会通过检查传入类型增加操作开销；现代系统如sqlite和PostgreSQL会在其端引发编码错误，如果传递了无效数据。在SQLAlchemy确实需要将绑定参数从Python
    Unicode强制转换为编码字符串时，或者显式使用Unicode类型时，如果对象是字节串，则会发出警告。可以使用Python警告过滤器文档中记录的警告来抑制或将其转换为异常：[https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)
- en: Generic Enum Type
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用枚举类型
- en: We now have an `Enum` in the `types` module. This is a string type that is given
    a collection of “labels” which constrain the possible values given to those labels.
    By default, this type generates a `VARCHAR` using the size of the largest label,
    and applies a CHECK constraint to the table within the CREATE TABLE statement.
    When using MySQL, the type by default uses MySQL’s ENUM type, and when using PostgreSQL
    the type will generate a user defined type using `CREATE TYPE <mytype> AS ENUM`.
    In order to create the type using PostgreSQL, the `name` parameter must be specified
    to the constructor. The type also accepts a `native_enum=False` option which will
    issue the VARCHAR/CHECK strategy for all databases. Note that PostgreSQL ENUM
    types currently don’t work with pg8000 or zxjdbc.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `types` 模块中有一个 `Enum`。这是一个字符串类型，给定一组“标签”，限制了给这些标签赋予的可能值。默认情况下，该类型生成一个`VARCHAR`，使用最大标签的大小，并在
    CREATE TABLE 语句中对表应用 CHECK 约束。当使用 MySQL 时，默认情况下，该类型使用 MySQL 的 ENUM 类型；当使用 PostgreSQL
    时，该类型将使用 `CREATE TYPE <mytype> AS ENUM` 生成用户定义类型。为了使用 PostgreSQL 创建类型，必须在构造函数中指定
    `name` 参数。该类型还接受一个 `native_enum=False` 选项，该选项将为所有数据库发出 VARCHAR/CHECK 策略。请注意，当前
    PostgreSQL ENUM 类型不能与 pg8000 或 zxjdbc 一起使用。
- en: Reflection Returns Dialect-Specific Types
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射返回方言特定类型
- en: Reflection now returns the most specific type possible from the database. That
    is, if you create a table using `String`, then reflect it back, the reflected
    column will likely be `VARCHAR`. For dialects that support a more specific form
    of the type, that’s what you’ll get. So a `Text` type would come back as `oracle.CLOB`
    on Oracle, a `LargeBinary` might be an `mysql.MEDIUMBLOB` etc. The obvious advantage
    here is that reflection preserves as much information possible from what the database
    had to say.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 反射现在从数据库返回尽可能最具体的类型。也就是说，如果您使用 `String` 创建一个表，然后反射它，那么反射的列可能是 `VARCHAR`。对于支持更特定形式类型的方言，您将得到相应的类型。因此，在
    Oracle 上，`Text` 类型将返回为 `oracle.CLOB`，`LargeBinary` 可能是 `mysql.MEDIUMBLOB` 等等。这里的明显优势是反射尽可能地保留了数据库要说的信息。
- en: 'Some applications that deal heavily in table metadata may wish to compare types
    across reflected tables and/or non- reflected tables. There’s a semi-private accessor
    available on `TypeEngine` called `_type_affinity` and an associated comparison
    helper `_compare_type_affinity`. This accessor returns the “generic” `types` class
    which the type corresponds to:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些处理表元数据的应用程序可能希望比较反映的表和/或非反射的表上的类型。`TypeEngine` 上有一个半私有访问器叫做 `_type_affinity`，以及一个相关的比较助手
    `_compare_type_affinity`。此访问器返回类型对应的“通用” `types` 类：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Miscellaneous API Changes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项 API 更改
- en: 'The usual “generic” types are still the general system in use, i.e. `String`,
    `Float`, `DateTime`. There’s a few changes there:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的“通用”类型仍然是正在使用的一般系统，即 `String`、`Float`、`DateTime`。在那里有一些变化：
- en: Types no longer make any guesses as to default parameters. In particular, `Numeric`,
    `Float`, as well as subclasses NUMERIC, FLOAT, DECIMAL don’t generate any length
    or scale unless specified. This also continues to include the controversial `String`
    and `VARCHAR` types (although MySQL dialect will pre-emptively raise when asked
    to render VARCHAR with no length). No defaults are assumed, and if they are used
    in a CREATE TABLE statement, an error will be raised if the underlying database
    does not allow non-lengthed versions of these types.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型不再猜测默认参数。特别是，`Numeric`、`Float`，以及 NUMERIC、FLOAT、DECIMAL 的子类不生成长度或比例，除非指定。这也包括有争议的
    `String` 和 `VARCHAR` 类型（尽管 MySQL 方言在要求不带长度渲染 VARCHAR 时会预先引发）。不假设默认值，如果它们在 CREATE
    TABLE 语句中使用，则在底层数据库不允许这些类型的非长度版本时会引发错误。
- en: the `Binary` type has been renamed to `LargeBinary`, for BLOB/BYTEA/similar
    types. For `BINARY` and `VARBINARY`, those are present directly as `types.BINARY`,
    `types.VARBINARY`, as well as in the MySQL and MS-SQL dialects.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Binary` 类型已更名为 `LargeBinary`，用于 BLOB/BYTEA/类似类型。对于 `BINARY` 和 `VARBINARY`，它们直接存在于
    `types.BINARY`、`types.VARBINARY`，以及 MySQL 和 MS-SQL 方言中。'
- en: '`PickleType` now uses == for comparison of values when mutable=True, unless
    the “comparator” argument with a comparison function is specified to the type.
    If you are pickling a custom object you should implement an `__eq__()` method
    so that value-based comparisons are accurate.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 mutable=True 时，`PickleType` 现在使用 == 比较值，除非为该类型指定了带有比较函数的“comparator”参数。如果您要
    pickle 自定义对象，应该实现一个 `__eq__()` 方法，以便基于值的比较准确。
- en: The default “precision” and “scale” arguments of Numeric and Float have been
    removed and now default to None. NUMERIC and FLOAT will be rendered with no numeric
    arguments by default unless these values are provided.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numeric 和 Float 的默认“precision”和“scale”参数已被移除，并且现在默认为 None。NUMERIC 和 FLOAT 默认情况下将不带有数值参数呈现，除非提供了这些值。
- en: DATE, TIME and DATETIME types on SQLite can now take optional “storage_format”
    and “regexp” argument. “storage_format” can be used to store those types using
    a custom string format. “regexp” allows to use a custom regular expression to
    match string values from the database.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 DATE、TIME 和 DATETIME 类型现在可以接受可选的“storage_format”和“regexp”参数。“storage_format”可用于使用自定义字符串格式存储这些类型。“regexp”允许使用自定义正则表达式来匹配数据库中的字符串值。
- en: '`__legacy_microseconds__` on SQLite `Time` and `DateTime` types is not supported
    anymore. You should use the new “storage_format” argument instead.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再支持 SQLite 上 `Time` 和 `DateTime` 类型的 `__legacy_microseconds__`。你应该使用新的 “storage_format”
    参数。
- en: '`DateTime` types on SQLite now use by a default a stricter regular expression
    to match strings from the database. Use the new “regexp” argument if you are using
    data stored in a legacy format.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 `DateTime` 类型现在默认使用更严格的正则表达式来匹配数据库中的字符串。如果你使用存储在传统格式中的数据，请使用新的 “regexp”
    参数。
- en: ORM Changes
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM 变更
- en: Upgrading an ORM application from 0.5 to 0.6 should require little to no changes,
    as the ORM’s behavior remains almost identical. There are some default argument
    and name changes, and some loading behaviors have been improved.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0.5 升级到 0.6 的 ORM 应用应该几乎不需要更改，因为 ORM 的行为基本保持不变。有一些默认参数和名称更改，以及一些加载行为已经改进。
- en: New Unit of Work
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新工作单元
- en: The internals for the unit of work, primarily `topological.py` and `unitofwork.py`,
    have been completely rewritten and are vastly simplified. This should have no
    impact on usage, as all existing behavior during flush has been maintained exactly
    (or at least, as far as it is exercised by our testsuite and the handful of production
    environments which have tested it heavily). The performance of flush() now uses
    20-30% fewer method calls and should also use less memory. The intent and flow
    of the source code should now be reasonably easy to follow, and the architecture
    of the flush is fairly open-ended at this point, creating room for potential new
    areas of sophistication. The flush process no longer has any reliance on recursion
    so flush plans of arbitrary size and complexity can be flushed. Additionally,
    the mapper’s “save” process, which issues INSERT and UPDATE statements, now caches
    the “compiled” form of the two statements so that callcounts are further dramatically
    reduced with very large flushes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元的内部，主要是 `topological.py` 和 `unitofwork.py`，已经完全重写并且大大简化。这对使用没有影响，因为所有现有的行为在
    flush 过程中都被完全保持了下来（或者至少在我们的测试套件和少数重度测试的生产环境中被保持了下来）。flush() 的性能现在减少了 20-30% 的方法调用，并且应该使用更少的内存。现在，源代码的意图和流程应该相当容易理解，而且
    flush 的架构在这一点上相当开放，为潜在的新领域创造了空间。flush 过程不再依赖递归，因此可以刷新任意大小和复杂度的 flush 计划。此外，mapper
    的 “save” 过程，发出 INSERT 和 UPDATE 语句，现在缓存了两个语句的 “compiled” 形式，因此在非常大的 flush 过程中进一步大幅减少了调用次数。
- en: Any changes in behavior observed with flush versus earlier versions of 0.6 or
    0.5 should be reported to us ASAP - we’ll make sure no functionality is lost.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期版本 0.6 或 0.5 相比，在 flush 与 flush 之间观察到的任何行为变化都应该尽快向我们报告 - 我们将确保不会丢失任何功能。
- en: Changes to `query.update()` and `query.delete()`
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`query.update()` 和 `query.delete()` 的变更'
- en: the ‘expire’ option on query.update() has been renamed to ‘fetch’, thus matching
    that of query.delete()
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: query.update() 上的 ‘expire’ 选项已更名为 ‘fetch’，因此与 query.delete() 的匹配项相匹配
- en: '`query.update()` and `query.delete()` both default to ‘evaluate’ for the synchronize
    strategy.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.update()` 和 `query.delete()` 的 synchronize 策略都默认为 ‘evaluate’。'
- en: the ‘synchronize’ strategy for update() and delete() raises an error on failure.
    There is no implicit fallback onto “fetch”. Failure of evaluation is based on
    the structure of criteria, so success/failure is deterministic based on code structure.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘synchronize’ 策略对 update() 和 delete() 抛出错误时会触发错误。在失败时没有隐式回退到“fetch”。评估的失败基于条件的结构，因此成功/失败是基于代码结构确定性的。
- en: '`relation()` is officially named `relationship()`'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`relation()` 现在正式命名为 `relationship()`'
- en: This to solve the long running issue that “relation” means a “table or derived
    table” in relational algebra terms. The `relation()` name, which is less typing,
    will hang around for the foreseeable future so this change should be entirely
    painless.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了解决长期存在的问题，“relation”在关系代数术语中意味着“表或派生表”。`relation()`名称，少打字，将在可预见的未来继续存在，因此这个改变应该完全没有痛苦。
- en: Subquery eager loading
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子查询的急切加载
- en: A new kind of eager loading is added called “subquery” loading. This is a load
    that emits a second SQL query immediately after the first which loads full collections
    for all the parents in the first query, joining upwards to the parent using INNER
    JOIN. Subquery loading is used similarly to the current joined-eager loading,
    using the ``subqueryload()[PRE22]subqueryload_all()[PRE23]lazy='subquery'[PRE24]relationship()``.
    The subquery load is usually much more efficient for loading many larger collections
    as it uses INNER JOIN unconditionally and also doesn’t re-load parent rows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种新的急切加载方式，称为“subquery”加载。这是一种在第一个SQL查询之后立即发出第二个SQL查询的加载方式，为第一个查询中的所有父级加载完整集合，使用INNER
    JOIN向上连接到父级。子查询加载类似于当前的连接急切加载，使用``subqueryload()[PRE22]subqueryload_all()[PRE23]lazy='subquery'[PRE24]relationship()``。子查询加载通常比较高效，用于加载许多较大的集合，因为它无条件地使用INNER
    JOIN，而且也不会重新加载父行。
- en: '``eagerload()[PRE25]eagerload_all()[PRE26]joinedload()[PRE27]joinedload_all()``'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``eagerload()[PRE25]eagerload_all()[PRE26]joinedload()[PRE27]joinedload_all()``'
- en: To make room for the new subquery load feature, the existing ``eagerload()[PRE28]eagerload_all()[PRE29]joinedload()[PRE30]joinedload_all()[PRE31]relation()``.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为新的子查询加载功能腾出空间，现有的``eagerload()[PRE28]eagerload_all()[PRE29]joinedload()[PRE30]joinedload_all()[PRE31]relation()``。
- en: '``lazy=False|None|True|''dynamic''[PRE32]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``lazy=False|None|True|''dynamic''[PRE32]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
- en: Continuing on the theme of loader strategies opened up, the standard keywords
    for the ``lazy[PRE33]relationship()[PRE34]select[PRE35]joined[PRE36]subquery[PRE37]noload[PRE38]dynamic[PRE39]True[PRE40]False[PRE41]None``
    arguments are still accepted with the identical behavior as before.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续开放加载器策略的主题上，``lazy[PRE33]relationship()[PRE34]select[PRE35]joined[PRE36]subquery[PRE37]noload[PRE38]dynamic[PRE39]True[PRE40]False[PRE41]None``参数的标准关键字仍然被接受，并具有与以前相同的行为。
- en: innerjoin=True on relation, joinedload
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关系、joinedload上设置innerjoin=True
- en: Joined-eagerly loaded scalars and collections can now be instructed to use INNER
    JOIN instead of OUTER JOIN. On PostgreSQL this is observed to provide a 300-600%
    speedup on some queries. Set this flag for any many-to-one which is on a NOT NULLable
    foreign key, and similarly for any collection where related items are guaranteed
    to exist.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以指示连接急切加载的标量和集合使用INNER JOIN而不是OUTER JOIN。在PostgreSQL上观察到这可以在某些查询上提供300-600%的速度提升。为任何在NOT
    NULLable外键上的多对一设置此标志，以及对于任何保证存在相关项目的集合。
- en: 'At mapper level:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射器级别：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At query time level:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询时间级别：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `innerjoin=True` flag at the `relationship()` level will also take effect
    for any `joinedload()` option which does not override the value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`relationship()`级别设置`innerjoin=True`标志也将对任何不覆盖该值的`joinedload()`选项生效。
- en: Many-to-one Enhancements
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对一增强
- en: many-to-one relations now fire off a lazyload in fewer cases, including in most
    cases will not fetch the “old” value when a new one is replaced.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一关系现在在更少的情况下会触发延迟加载，包括在大多数情况下不会在替换新值时获取“旧”值。
- en: many-to-one relation to a joined-table subclass now uses get() for a simple
    load (known as the “use_get” condition), i.e. `Related`->``Sub(Base)``, without
    the need to redefine the primaryjoin condition in terms of the base table. [ticket:1186]
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一关系到一个连接表子类现在使用get()进行简单加载（称为“use_get”条件），即`Related`->``Sub(Base)``，无需重新定义基表的primaryjoin条件。[ticket:1186]
- en: specifying a foreign key with a declarative column, i.e. `ForeignKey(MyRelatedClass.id)`
    doesn’t break the “use_get” condition from taking place [ticket:1492]
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明性列指定外键，即`ForeignKey(MyRelatedClass.id)`不会导致“use_get”条件发生变化 [ticket:1492]
- en: relationship(), joinedload(), and joinedload_all() now feature an option called
    “innerjoin”. Specify `True` or `False` to control whether an eager join is constructed
    as an INNER or OUTER join. Default is `False` as always. The mapper options will
    override whichever setting is specified on relationship(). Should generally be
    set for many-to-one, not nullable foreign key relations to allow improved join
    performance. [ticket:1544]
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: relationship()，joinedload()和joinedload_all()现在具有一个名为“innerjoin”的选项。指定`True`或`False`来控制是否构建内连接或外连接的预加载连接。默认始终为`False`。映射器选项将覆盖在relationship()上指定的任何设置。通常应该为多对一、非空外键关系设置���以允许改进的连接性能。[ticket:1544]
- en: the behavior of joined eager loading such that the main query is wrapped in
    a subquery when LIMIT/OFFSET are present now makes an exception for the case when
    all eager loads are many-to-one joins. In those cases, the eager joins are against
    the parent table directly along with the limit/offset without the extra overhead
    of a subquery, since a many-to-one join does not add rows to the result.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在LIMIT/OFFSET时，连接式预加载的行为会将主查询包装在子查询中，现在对所有预加载都是多对一连接的情况做了一个例外。在这些情况下，预加载连接直接针对父表进行，同时包括限制/偏移，而不需要额外的子查询开销，因为多对一连接不会向结果添加行。
- en: 'For example, in 0.5 this query:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在0.5中，这个查询：
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'would produce SQL like:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会生成类似于以下的SQL：
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This because the presence of any eager loaders suggests that some or all of
    them may relate to multi-row collections, which would necessitate wrapping any
    kind of rowcount-sensitive modifiers like LIMIT inside of a subquery.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为任何预加载的存在都暗示着其中一些或全部可能与多行集合相关联，这将需要将任何类似于LIMIT这样的行数敏感修饰符包装在子查询中。
- en: 'In 0.6, that logic is more sensitive and can detect if all eager loaders represent
    many-to-ones, in which case the eager joins don’t affect the rowcount:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在0.6中，该逻辑更加敏感，可以检测到所有预加载是否都表示多对一关系，如果是这种情况，预加载连接不会影响行数：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Mutable Primary Keys with Joined Table Inheritance
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有联接表继承的可变主键
- en: A joined table inheritance config where the child table has a PK that foreign
    keys to the parent PK can now be updated on a CASCADE-capable database like PostgreSQL.
    `mapper()` now has an option `passive_updates=True` which indicates this foreign
    key is updated automatically. If on a non-cascading database like SQLite or MySQL/MyISAM,
    set this flag to `False`. A future feature enhancement will try to get this flag
    to be auto-configuring based on dialect/table style in use.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在子表具有外键指向父表主键的联接表继承配置现在可以在像PostgreSQL这样支持级联的数据库上更新。`mapper()`现在有一个选项`passive_updates=True`，表示此外键将自动更新。如果在不支持级联的数据库上，如SQLite或MySQL/MyISAM上，将此标志设置为`False`。未来的功能增强将尝试根据使用的方言/表格样式自动配置此标志。
- en: Beaker Caching
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Beaker缓存
- en: A promising new example of Beaker integration is in `examples/beaker_caching`.
    This is a straightforward recipe which applies a Beaker cache within the result-
    generation engine of `Query`. Cache parameters are provided via `query.options()`,
    and allows full control over the contents of the cache. SQLAlchemy 0.6 includes
    improvements to the `Session.merge()` method to support this and similar recipes,
    as well as to provide significantly improved performance in most scenarios.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Beaker集成的一个有前途的新示例在`examples/beaker_caching`中。这是一个简单的示例，它在`Query`的结果生成引擎中应用了一个Beaker缓存。缓存参数通过`query.options()`提供，并允许完全控制缓存内容。SQLAlchemy
    0.6对`Session.merge()`方法进行了改进，以支持这种和类似的示例，并在大多数情况下提供了显著改进的性能。
- en: Other Changes
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他更改
- en: the “row tuple” object returned by `Query` when multiple column/entities are
    selected is now picklable as well as higher performing.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择多个列/实体时，`Query`返回的“行元组”对象现在也是可序列化的，并且性能更高。
- en: '`query.join()` has been reworked to provide more consistent behavior and more
    flexibility (includes [ticket:1537])'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.join()`已经重新设计，以提供更一致的行为和更灵活的功能（包括[ticket:1537]）'
- en: '`query.select_from()` accepts multiple clauses to produce multiple comma separated
    entries within the FROM clause. Useful when selecting from multiple-homed join()
    clauses.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.select_from()`接受多个子句，以在FROM子句中生成多个逗号分隔的条目。在从多个join()子句中选择时很有用。'
- en: the “dont_load=True” flag on `Session.merge()` is deprecated and is now “load=False”.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session.merge()`上的“dont_load=True”标志已被弃用，现在是“load=False”。'
- en: added “make_transient()” helper function which transforms a persistent/ detached
    instance into a transient one (i.e. deletes the instance_key and removes from
    any session.) [ticket:1052]
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了“make_transient()”辅助函数，将持久化/分离实例转换为瞬态实例（即删除实例键并从任何会话中移除）。[ticket:1052]
- en: the allow_null_pks flag on mapper() is deprecated and has been renamed to allow_partial_pks.
    It is turned “on” by default. This means that a row which has a non-null value
    for any of its primary key columns will be considered an identity. The need for
    this scenario typically only occurs when mapping to an outer join. When set to
    False, a PK that has NULLs in it will not be considered a primary key - in particular
    this means a result row will come back as None (or not be filled into a collection),
    and new in 0.6 also indicates that session.merge() won’t issue a round trip to
    the database for such a PK value. [ticket:1680]
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mapper() 上的 allow_null_pks 标志已被废弃，并已重命名为 allow_partial_pks。默认情况下已打开此标志。这意味着对于任何主键列中有非空值的行将被视为标识。通常只有在映射到外连接时才需要此情景。当设置为
    False 时，具有 NULL 值的 PK 不会被视为主键 - 特别是这意味着结果行将返回为 None（或不会填充到集合中），并且在 0.6 中还表示 session.merge()
    不会为此类 PK 值发出数据库的往返。【票号：1680】
- en: the mechanics of “backref” have been fully merged into the finer grained “back_populates”
    system, and take place entirely within the `_generate_backref()` method of `RelationProperty`.
    This makes the initialization procedure of `RelationProperty` simpler and allows
    easier propagation of settings (such as from subclasses of `RelationProperty`)
    into the reverse reference. The internal `BackRef()` is gone and `backref()` returns
    a plain tuple that is understood by `RelationProperty`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “backref”的机制已完全合并到更精细的 “back_populates” 系统中，并完全在 `RelationProperty` 的 `_generate_backref()`
    方法中进行。这使得 `RelationProperty` 的初始化过程更简单，并允许更容易地将设置（如 `RelationProperty` 的子类）传播到反向引用中。内部的
    `BackRef()` 已经消失，`backref()` 返回一个普通元组，被 `RelationProperty` 理解。
- en: the keys attribute of `ResultProxy` is now a method, so references to it (`result.keys`)
    must be changed to method invocations (`result.keys()`)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy` 的 keys 属性现在是一个方法，因此对它的引用（`result.keys`）必须更改为方法调用（`result.keys()`）。'
- en: '`ResultProxy.last_inserted_ids` is now deprecated, use `ResultProxy.inserted_primary_key`
    instead.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy.last_inserted_ids` 现在已废弃，使用 `ResultProxy.inserted_primary_key`
    替代。'
- en: Deprecated/Removed ORM Elements
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃/移除的 ORM 元素
- en: Most elements that were deprecated throughout 0.5 and raised deprecation warnings
    have been removed (with a few exceptions). All elements that were marked “pending
    deprecation” are now deprecated and will raise a warning upon use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.5 版本中废弃并引发废弃警告的大多数元素已被移除（有几个例外）。所有标记为 “待废弃” 的元素现在已被废弃，并在使用时引发警告。
- en: ‘transactional’ flag on sessionmaker() and others is removed. Use ‘autocommit=True’
    to indicate ‘transactional=False’.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sessionmaker() 和其他地方上的 ‘transactional’ 标志已移除。使用 ‘autocommit=True’ 表示 ‘transactional=False’。
- en: ‘polymorphic_fetch’ argument on mapper() is removed. Loading can be controlled
    using the ‘with_polymorphic’ option.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mapper() 上的 ‘polymorphic_fetch’ 参数已移除。可以使用 ‘with_polymorphic’ 选项来控制加载。
- en: ‘select_table’ argument on mapper() is removed. Use ‘with_polymorphic=(“*”,
    <some selectable>)’ for this functionality.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mapper() 上的 ‘select_table’ 参数已移除。使用 ‘with_polymorphic=(“*”, <some selectable>)’
    实现此功能。
- en: ‘proxy’ argument on synonym() is removed. This flag did nothing throughout 0.5,
    as the “proxy generation” behavior is now automatic.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: synonym() 上的 ‘proxy’ 参数已移除。在 0.5 版本中此标志没有任何作用，因为 “代理生成” 行为现在是自动的。
- en: Passing a single list of elements to joinedload(), joinedload_all(), contains_eager(),
    lazyload(), defer(), and undefer() instead of multiple positional *args is deprecated.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个元素列表传递给 joinedload()、joinedload_all()、contains_eager()、lazyload()、defer()
    和 undefer() 而不是多个位置 *args 已被废弃。
- en: Passing a single list of elements to query.order_by(), query.group_by(), query.join(),
    or query.outerjoin() instead of multiple positional *args is deprecated.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个元素列表传递给 query.order_by()、query.group_by()、query.join() 或 query.outerjoin()
    而不是多个位置 *args 已被废弃。
- en: '`query.iterate_instances()` is removed. Use `query.instances()`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.iterate_instances()` 被移除了。使用 `query.instances()`。'
- en: '`Query.query_from_parent()` is removed. Use the sqlalchemy.orm.with_parent()
    function to produce a “parent” clause, or alternatively `query.with_parent()`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query.query_from_parent()` 被移除了。使用 sqlalchemy.orm.with_parent() 函数生成 “parent”
    子句，或者使用 `query.with_parent()`。'
- en: '`query._from_self()` is removed, use `query.from_self()` instead.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query._from_self()` 被移除，使用 `query.from_self()` 代替。'
- en: the “comparator” argument to composite() is removed. Use “comparator_factory”.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: composite() 方法的 “comparator” 参数被移除了。使用 “comparator_factory”。
- en: '`RelationProperty._get_join()` is removed.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelationProperty._get_join()` 已移除。'
- en: the ‘echo_uow’ flag on Session is removed. Use logging on the “sqlalchemy.orm.unitofwork”
    name.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Session 上的 ‘echo_uow’ 标志已移除。在 “sqlalchemy.orm.unitofwork” 名称上使用日志记录。
- en: '`session.clear()` is removed. use `session.expunge_all()`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.clear()` 已移除。使用 `session.expunge_all()`。'
- en: '`session.save()`, `session.update()`, `session.save_or_update()` are removed.
    Use `session.add()` and `session.add_all()`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.save()`，`session.update()`，`session.save_or_update()` 已移除。使用 `session.add()`
    和 `session.add_all()`。'
- en: the “objects” flag on session.flush() remains deprecated.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `session.flush()` 上的 “objects” 标志仍然被弃用。
- en: the “dont_load=True” flag on session.merge() is deprecated in favor of “load=False”.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `session.merge()` 上的 “dont_load=True” 标志已弃用，建议使用 “load=False”。
- en: '`ScopedSession.mapper` remains deprecated. See the usage recipe at [https://www.sqlalchemy.org/trac/wiki/Usag](https://www.sqlalchemy.org/trac/wiki/Usag)
    eRecipes/SessionAwareMapper'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper` 仍然被弃用。请参阅[用法](https://www.sqlalchemy.org/trac/wiki/Usag)配方在Recipes/SessionAwareMapper'
- en: passing an `InstanceState` (internal SQLAlchemy state object) to `attributes.init_collection()`
    or `attributes.get_history()` is deprecated. These functions are public API and
    normally expect a regular mapped object instance.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `InstanceState`（内部 SQLAlchemy 状态对象）传递给 `attributes.init_collection()` 或 `attributes.get_history()`
    已弃用。 这些函数是公共 API，并且通常希望是常规映射对象实例。
- en: the ‘engine’ parameter to `declarative_base()` is removed. Use the ‘bind’ keyword
    argument.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarative_base()` 的 “engine” 参数已移除。使用 “bind” 关键字参数。'
- en: Extensions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: SQLSoup
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup has been modernized and updated to reflect common 0.5/0.6 capabilities,
    including well defined session integration. Please read the new docs at [[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html].
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 已现代化并更新以反映常见的 0.5/0.6 功能，包括明确定义的会话集成。请阅读新文档[[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html]。
- en: Declarative
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: The `DeclarativeMeta` (default metaclass for `declarative_base`) previously
    allowed subclasses to modify `dict_` to add class attributes (e.g. columns). This
    no longer works, the `DeclarativeMeta` constructor now ignores `dict_`. Instead,
    the class attributes should be assigned directly, e.g. `cls.id=Column(...)`, or
    the [MixIn class](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    approach should be used instead of the metaclass approach.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeclarativeMeta`（`declarative_base` 的默认元类）之前允许子类修改 `dict_` 来添加类属性（例如列）。 这种方式不再有效，`DeclarativeMeta`
    构造函数现在忽略 `dict_`。相反，类属性应直接赋值，例如 `cls.id=Column(...)`，或者应该使用 [MixIn 类](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    方法而不是元类方法。'
- en: Platform Support
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: cPython versions 2.4 and upwards throughout the 2.xx series
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cPython 版本从 2.4 开始，在 2.xx 系列中
- en: Jython 2.5.1 - using the zxJDBC DBAPI included with Jython.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jython 2.5.1 - 使用 Jython 自带的 zxJDBC DBAPI。
- en: cPython 3.x - see [source:sqlalchemy/trunk/README.py3k] for information on how
    to build for python3.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cPython 3.x - 参见[源码:sqlalchemy/trunk/README.py3k] 了解如何构建 Python3 版本。
- en: New Dialect System
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新方言系统
- en: Dialect modules are now broken up into distinct subcomponents, within the scope
    of a single database backend. Dialect implementations are now in the `sqlalchemy.dialects`
    package. The `sqlalchemy.databases` package still exists as a placeholder to provide
    some level of backwards compatibility for simple imports.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 方言模块现在被分解为单个数据库后端范围内的不同子组件。 方言实现现在在 `sqlalchemy.dialects` 包中。 `sqlalchemy.databases`
    包仍然存在，作为一个占位符，为简单导入提供一定程度的向后兼容性。
- en: For each supported database, a sub-package exists within `sqlalchemy.dialects`
    where several files are contained. Each package contains a module called `base.py`
    which defines the specific SQL dialect used by that database. It also contains
    one or more “driver” modules, each one corresponding to a specific DBAPI - these
    files are named corresponding to the DBAPI itself, such as `pysqlite`, `cx_oracle`,
    or `pyodbc`. The classes used by SQLAlchemy dialects are first declared in the
    `base.py` module, defining all behavioral characteristics defined by the database.
    These include capability mappings, such as “supports sequences”, “supports returning”,
    etc., type definitions, and SQL compilation rules. Each “driver” module in turn
    provides subclasses of those classes as needed which override the default behavior
    to accommodate the additional features, behaviors, and quirks of that DBAPI. For
    DBAPIs that support multiple backends (pyodbc, zxJDBC, mxODBC), the dialect module
    will use mixins from the `sqlalchemy.connectors` package, which provide functionality
    common to that DBAPI across all backends, most typically dealing with connect
    arguments. This means that connecting using pyodbc, zxJDBC or mxODBC (when implemented)
    is extremely consistent across supported backends.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个支持的数据库，在`sqlalchemy.dialects`中都存在一个子包，其中包含几个文件。每个包都包含一个名为`base.py`的模块，该模块定义了该数据库使用的特定SQL方言。它还包含一个或多个“driver”模块，每个模块对应于特定的DBAPI
    - 这些文件的命名与DBAPI本身相对应，例如`pysqlite`、`cx_oracle`或`pyodbc`。SQLAlchemy方言使用的类首先在`base.py`模块中声明，定义了数据库定义的所有行为特征。这些包括功能映射，例如“支持序列”，“支持返回”等，类型定义和SQL编译规则。每个“driver”模块依次提供所需的那些类的子类，这些子类覆盖默认行为以适应该DBAPI的附加功能、行为和怪癖。对于支持多个后端的DBAPI（pyodbc、zxJDBC、mxODBC），方言模块将使用`sqlalchemy.connectors`包中的mixin，这些mixin提供了在所有后端上通用的功能，最常见的是处理连接参数。这意味着使用pyodbc、zxJDBC或mxODBC（一旦实现）进行连接在支持的后端上是非常一致的。
- en: 'The URL format used by `create_engine()` has been enhanced to handle any number
    of DBAPIs for a particular backend, using a scheme that is inspired by that of
    JDBC. The previous format still works, and will select a “default” DBAPI implementation,
    such as the PostgreSQL URL below that will use psycopg2:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_engine()`使用的URL格式已经改进，以处理特定后端的任意数量的DBAPI，使用了受JDBC启发的方案。以前的格式仍然有效，并且将选择一个“默认”的DBAPI实现，例如下面将使用psycopg2的PostgreSQL
    URL：'
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However to specify a specific DBAPI backend such as pg8000, add it to the “protocol”
    section of the URL using a plus sign “+”:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要指定特定的DBAPI后端，例如pg8000，请在URL的“protocol”部分使用加号“+”：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Important Dialect Links:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的方言链接：
- en: 'Documentation on connect arguments: [https://www.sqlalchemy.org/docs/06/dbengine.html#create](https://www.sqlalchemy.org/docs/06/dbengine.html#create)-
    engine-url-arguments.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接参数的文档：[https://www.sqlalchemy.org/docs/06/dbengine.html#create](https://www.sqlalchemy.org/docs/06/dbengine.html#create)-
    engine-url-arguments。
- en: 'Reference documentation for individual dialects: [https://ww](https://ww) w.sqlalchemy.org/docs/06/reference/dialects/index.html'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个方言的参考文档：[https://ww](https://ww) w.sqlalchemy.org/docs/06/reference/dialects/index.html
- en: The tips and tricks at DatabaseNotes.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DatabaseNotes中的技巧和窍门。
- en: 'Other notes regarding dialects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方言的其他注意事项：
- en: the type system has been changed dramatically in SQLAlchemy 0.6\. This has an
    impact on all dialects regarding naming conventions, behaviors, and implementations.
    See the section on “Types” below.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.6中类型系统发生了巨大变化。这对所有方言的命名约定、行为和实现都产生了影响。请参见下面关于“类型”的部分。
- en: the `ResultProxy` object now offers a 2x speed improvement in some cases thanks
    to some refactorings.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy`对象现在在某些情况下提供了2倍的速度改进，这要归功于一些重构。'
- en: the `RowProxy`, i.e. individual result row object, is now directly pickleable.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowProxy`，即单个结果行对象，现在可以直接进行pickle。'
- en: the setuptools entrypoint used to locate external dialects is now called `sqlalchemy.dialects`.
    An external dialect written against 0.4 or 0.5 will need to be modified to work
    with 0.6 in any case so this change does not add any additional difficulties.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定位外部方言的setuptools entrypoint现在称为`sqlalchemy.dialects`。针对0.4或0.5编写的外部方言需要修改以适应0.6，在任何情况下，因此这一变化并不会增加任何额外的困难。
- en: dialects now receive an initialize() event on initial connection to determine
    connection properties.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言现在在初始连接时会接收一个initialize()事件，以确定连接属性。
- en: Functions and operators generated by the compiler now use (almost) regular dispatch
    functions of the form “visit_<opname>” and “visit_<funcname>_fn” to provide customed
    processing. This replaces the need to copy the “functions” and “operators” dictionaries
    in compiler subclasses with straightforward visitor methods, and also allows compiler
    subclasses complete control over rendering, as the full _Function or _BinaryExpression
    object is passed in.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器生成的函数和操作符现在使用（几乎）常规的分发函数形式“visit_<opname>”和“visit_<funcname>_fn”来提供定制处理。这取代了在编译器子类中复制“functions”和“operators”字典的需要，改为使用直接的访问者方法，并且还允许编译器子类完全控制渲染，因为完整的
    _Function 或 _BinaryExpression 对象被传递进来。
- en: Dialect Imports
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方���导入
- en: 'The import structure of dialects has changed. Each dialect now exports its
    base “dialect” class as well as the full set of SQL types supported on that dialect
    via `sqlalchemy.dialects.<name>`. For example, to import a set of PG types:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 方言的导入结构已经改变。每个方言现在通过 `sqlalchemy.dialects.<name>` 导出其基本的“dialect”类以及该方言支持的完整一组
    SQL 类型。例如，要导入一组 PG 类型：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Above, `INTEGER` is actually the plain `INTEGER` type from `sqlalchemy.types`,
    but the PG dialect makes it available in the same way as those types which are
    specific to PG, such as `BYTEA` and `MACADDR`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`INTEGER` 实际上是 `sqlalchemy.types` 中的普通 `INTEGER` 类型，但 PG 方言使其以与那些特定于 PG 的类型相同的方式可用，比如
    `BYTEA` 和 `MACADDR`。
- en: Dialect Imports
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方言导入
- en: 'The import structure of dialects has changed. Each dialect now exports its
    base “dialect” class as well as the full set of SQL types supported on that dialect
    via `sqlalchemy.dialects.<name>`. For example, to import a set of PG types:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 方言的导入结构已经改变。每个方言现在通过 `sqlalchemy.dialects.<name>` 导出其基本的“dialect”类以及该方言支持的完整一组
    SQL 类型。例如，要导入一组 PG 类型：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Above, `INTEGER` is actually the plain `INTEGER` type from `sqlalchemy.types`,
    but the PG dialect makes it available in the same way as those types which are
    specific to PG, such as `BYTEA` and `MACADDR`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`INTEGER` 实际上是 `sqlalchemy.types` 中的普通 `INTEGER` 类型，但 PG 方言使其以与那些特定于 PG 的类型相同的方式可用，比如
    `BYTEA` 和 `MACADDR`。
- en: Expression Language Changes
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语言变化
- en: An Important Expression Language Gotcha
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个重要的表达式语言陷阱
- en: There’s one quite significant behavioral change to the expression language which
    may affect some applications. The boolean value of Python boolean expressions,
    i.e. `==`, `!=`, and similar, now evaluates accurately with regards to the two
    clause objects being compared.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语言有一个相当重要的行为变化，可能会影响一些应用程序。Python 布尔表达式的布尔值，即 `==`、`!=` 等，现在在与被比较的两个子句对象相关时会准确求值。
- en: 'As we know, comparing a `ClauseElement` to any other object returns another
    `ClauseElement`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，将 `ClauseElement` 与任何其他对象进行比较会返回另一个 `ClauseElement`：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This so that Python expressions produce SQL expressions when converted to strings:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这样当 Python 表达式转换为字符串时会产生 SQL 表达式：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: But what happens if we say this?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们这样说会发生什么？
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In previous versions of SQLAlchemy, the returned `_BinaryExpression` was a
    plain Python object which evaluated to `True`. Now it evaluates to whether or
    not the actual `ClauseElement` should have the same hash value as to that being
    compared. Meaning:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 SQLAlchemy 版本中，返回的 `_BinaryExpression` 是一个普通的 Python 对象，其求值为 `True`。现在它的求值取决于实际的
    `ClauseElement` 是否应该具有与被比较的哈希值相同的值。意思是：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'That means code such as the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像下面这样的代码：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Would not evaluate if `expression` was a binary clause. Since the above pattern
    should never be used, the base `ClauseElement` now raises an exception if called
    in a boolean context:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `expression` 是一个二进制子句，则不会求值。由于上述模式永远不应该被使用，基本的 `ClauseElement` 现在在布尔上下文中调用时会引发异常：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Code that wants to check for the presence of a `ClauseElement` expression should
    instead say:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 想要检查是否存在 `ClauseElement` 表达式的代码应该改为：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Keep in mind, **this applies to Table and Column objects too**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**这也适用于 Table 和 Column 对象**。
- en: 'The rationale for the change is twofold:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更改的理由有两个：
- en: Comparisons of the form `if c1 == c2:  <do something>` can actually be written
    now
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形如 `if c1 == c2:  <do something>` 的比较现在可以这样写
- en: Support for correct hashing of `ClauseElement` objects now works on alternate
    platforms, namely Jython. Up until this point SQLAlchemy relied heavily on the
    specific behavior of cPython in this regard (and still had occasional problems
    with it).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在正确哈希 `ClauseElement` 对象的支持也适用于其他平台，比如 Jython。直到这一点，SQLAlchemy 在这方面严重依赖 cPython
    的特定行为（并且仍然偶尔出现问题）。
- en: Stricter “executemany” Behavior
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更严格的 “executemany” 行为
- en: 'An “executemany” in SQLAlchemy corresponds to a call to `execute()`, passing
    along a collection of bind parameter sets:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，“executemany” 对应于调用 `execute()`，传递一系列绑定参数集：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When the `Connection` object sends off the given `insert()` construct for compilation,
    it passes to the compiler the keynames present in the first set of binds passed
    along to determine the construction of the statement’s VALUES clause. Users familiar
    with this construct will know that additional keys present in the remaining dictionaries
    don’t have any impact. What’s different now is that all subsequent dictionaries
    need to include at least *every* key that is present in the first dictionary.
    This means that a call like this no longer works:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Connection` 对象将给定的 `insert()` 构造发送到编译时，它会传递给编译器在第一组传递的绑定中存在的键名，以确定语句的 VALUES
    子句的构造。熟悉这种构造的用户会知道剩余字典中存在的额外键没有任何影响。现在不同的是，所有后续字典都需要至少包含第一个字典中存在的*每个*键。这意味着像这样的调用不再起作用：
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because the third row does not specify the ‘timestamp’ column. Previous versions
    of SQLAlchemy would simply insert NULL for these missing columns. However, if
    the `timestamp` column in the above example contained a Python-side default value
    or function, it would *not* be used. This because the “executemany” operation
    is optimized for maximum performance across huge numbers of parameter sets, and
    does not attempt to evaluate Python-side defaults for those missing keys. Because
    defaults are often implemented either as SQL expressions which are embedded inline
    with the INSERT statement, or are server side expressions which again are triggered
    based on the structure of the INSERT string, which by definition cannot fire off
    conditionally based on each parameter set, it would be inconsistent for Python
    side defaults to behave differently vs. SQL/server side defaults. (SQL expression
    based defaults are embedded inline as of the 0.5 series, again to minimize the
    impact of huge numbers of parameter sets).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第三行没有指定 ‘timestamp’ 列。之前的 SQLAlchemy 版本会简单地为这些缺失的列插入 NULL。然而，在上面的示例中，如果 `timestamp`
    列包含 Python 端默认值或函数，则*不*会被使用。这是因为 “executemany” 操作被优化为在大量参数集上实现最大性能，并且不会尝试评估那些缺失键的
    Python 端默认值。因为默认值通常被实现为嵌入在 INSERT 语句中的 SQL 表达式，或者是服务器端表达式，再次根据 INSERT 字符串的结构触发，这些默认值不能根据每个参数集有条件地触发，让
    Python 端默认值与 SQL/服务器端默认值的行为不一致将是不一致的。 （从 0.5 系列开始，基于 SQL 表达式的默认值被嵌入到行内，以最小化大量参数集的影响）。
- en: SQLAlchemy 0.6 therefore establishes predictable consistency by forbidding any
    subsequent parameter sets from leaving any fields blank. That way, there’s no
    more silent failure of Python side default values and functions, which additionally
    are allowed to remain consistent in their behavior versus SQL and server side
    defaults.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SQLAlchemy 0.6 通过禁止任何后续参数集留下任何字段空白来建立可预测的一致性。这样，Python 端默认值和函数不再默默失败，此外，它们允许保持与
    SQL 和服务器端默认值一致的行为。
- en: UNION and other “compound” constructs parenthesize consistently
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNION 和其他“复合”结构一致地加括号。
- en: 'A rule that was designed to help SQLite has been removed, that of the first
    compound element within another compound (such as, a `union()` inside of an `except_()`)
    wouldn’t be parenthesized. This is inconsistent and produces the wrong results
    on PostgreSQL, which has precedence rules regarding INTERSECTION, and its generally
    a surprise. When using complex composites with SQLite, you now need to turn the
    first element into a subquery (which is also compatible on PG). A new example
    is in the SQL expression tutorial at the end of [[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]. See [#1665](https://www.sqlalchemy.org/trac/ticket/1665)
    and r6690 for more background.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '为了帮助 SQLite 而设计的规则已被移除，即在另一个复合元素内的第一个复合元素（例如，在 `except_()` 中的 `union()`）不会被括号括起来。这是不一致的，并且在
    PostgreSQL 上产生错误的结果，因为它有关于 INTERSECTION 的优先规则，通常会让人感到惊讶。在使用 SQLite 的复杂组合时，现在需要将第一个元素转换为子查询（这也与
    PG 兼容）。在[[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]的 SQL 表达式教程的末尾有一个新的示例。查看[#1665](https://www.sqlalchemy.org/trac/ticket/1665)和
    r6690 以获取更多背景信息。'
- en: An Important Expression Language Gotcha
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个重要的表达语言陷阱
- en: There’s one quite significant behavioral change to the expression language which
    may affect some applications. The boolean value of Python boolean expressions,
    i.e. `==`, `!=`, and similar, now evaluates accurately with regards to the two
    clause objects being compared.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表达语言中有一个相当重要的行为变化，可能会影响一些应用程序。Python布尔表达式的布尔值，即`==`，`!=`等，现在在比较两个子句对象时会准确评估。
- en: 'As we know, comparing a `ClauseElement` to any other object returns another
    `ClauseElement`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，将`ClauseElement`与任何其他对象进行比较会返回另一个`ClauseElement`：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This so that Python expressions produce SQL expressions when converted to strings:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这样Python表达式在转换为字符串时会产生SQL表达式：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: But what happens if we say this?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们这样说会发生什么呢？
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In previous versions of SQLAlchemy, the returned `_BinaryExpression` was a
    plain Python object which evaluated to `True`. Now it evaluates to whether or
    not the actual `ClauseElement` should have the same hash value as to that being
    compared. Meaning:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的SQLAlchemy版本中，返回的`_BinaryExpression`是一个普通的Python对象，其求值为`True`。现在它的求值取决于实际的`ClauseElement`是否应该具有与被比较的相同哈希值。意思是：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That means code such as the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像下面这样的代码：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Would not evaluate if `expression` was a binary clause. Since the above pattern
    should never be used, the base `ClauseElement` now raises an exception if called
    in a boolean context:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expression`是一个二元子句，将不会评估。由于上述模式不应该被使用，基本的`ClauseElement`现在在布尔上下文中调用时会引发异常：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Code that wants to check for the presence of a `ClauseElement` expression should
    instead say:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 想要检查`ClauseElement`表达式是否存在的代码应该改为：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Keep in mind, **this applies to Table and Column objects too**.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**这也适用于Table和Column对象**。
- en: 'The rationale for the change is twofold:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 更改的原因有两个：
- en: Comparisons of the form `if c1 == c2:  <do something>` can actually be written
    now
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '现在实际上可以编写形式为`if c1 == c2: <do something>`的比较。'
- en: Support for correct hashing of `ClauseElement` objects now works on alternate
    platforms, namely Jython. Up until this point SQLAlchemy relied heavily on the
    specific behavior of cPython in this regard (and still had occasional problems
    with it).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`ClauseElement`对象进行正确哈希的支持现在在其他平台上也能正常工作，即Jython。直到这一点，SQLAlchemy在这方面严重依赖cPython的特定行为（并且偶尔还会出现问题）。
- en: Stricter “executemany” Behavior
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更严格的“executemany”行为
- en: 'An “executemany” in SQLAlchemy corresponds to a call to `execute()`, passing
    along a collection of bind parameter sets:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，“executemany”对应于调用`execute()`，传递一系列绑定参数集合：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When the `Connection` object sends off the given `insert()` construct for compilation,
    it passes to the compiler the keynames present in the first set of binds passed
    along to determine the construction of the statement’s VALUES clause. Users familiar
    with this construct will know that additional keys present in the remaining dictionaries
    don’t have any impact. What’s different now is that all subsequent dictionaries
    need to include at least *every* key that is present in the first dictionary.
    This means that a call like this no longer works:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Connection`对象发送给定的`insert()`构造进行编译时，它会传递给编译器在第一组传递的绑定中存在的键名，以确定语句的VALUES子句的构造。熟悉这种构造的用户将知道，剩余字典中存在的额外键不会产生任何影响。现在不同的是，所有后续字典都需要至少包含第一个字典中存在的*每个*键。这意味着像这样的调用不再起作用：
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Because the third row does not specify the ‘timestamp’ column. Previous versions
    of SQLAlchemy would simply insert NULL for these missing columns. However, if
    the `timestamp` column in the above example contained a Python-side default value
    or function, it would *not* be used. This because the “executemany” operation
    is optimized for maximum performance across huge numbers of parameter sets, and
    does not attempt to evaluate Python-side defaults for those missing keys. Because
    defaults are often implemented either as SQL expressions which are embedded inline
    with the INSERT statement, or are server side expressions which again are triggered
    based on the structure of the INSERT string, which by definition cannot fire off
    conditionally based on each parameter set, it would be inconsistent for Python
    side defaults to behave differently vs. SQL/server side defaults. (SQL expression
    based defaults are embedded inline as of the 0.5 series, again to minimize the
    impact of huge numbers of parameter sets).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第三行未指定‘timestamp’列。之前的SQLAlchemy版本会简单地为这些缺失的列插入NULL。然而，在上面的示例中，如果`timestamp`列包含Python端默认值或函数，则*不会*被使用。这是因为“executemany”操作针对大量参数集进行了优化，不会尝试评估这些缺失键的Python端默认值。因为默认值通常被实现为嵌入在INSERT语句中的SQL表达式，或者是服务器端表达式，再次根据INSERT字符串的结构触发，这显然不能根据每个参数集有条件地触发，让Python端默认值与SQL/服务器端默认值的行为不一致是不合理的（从0.5系列开始，基于SQL表达式的默认值被嵌入到内联，以最小化大量参数集的影响）。
- en: SQLAlchemy 0.6 therefore establishes predictable consistency by forbidding any
    subsequent parameter sets from leaving any fields blank. That way, there’s no
    more silent failure of Python side default values and functions, which additionally
    are allowed to remain consistent in their behavior versus SQL and server side
    defaults.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.6因此通过禁止任何后续参数集留空字段来确立可预测的一致性。这样，Python端默认值和函数不再默默失败，而且它们的行为与SQL和服务器端默认值保持一致。
- en: UNION and other “compound” constructs parenthesize consistently
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNION和其他“复合”结构一致地加括号
- en: 'A rule that was designed to help SQLite has been removed, that of the first
    compound element within another compound (such as, a `union()` inside of an `except_()`)
    wouldn’t be parenthesized. This is inconsistent and produces the wrong results
    on PostgreSQL, which has precedence rules regarding INTERSECTION, and its generally
    a surprise. When using complex composites with SQLite, you now need to turn the
    first element into a subquery (which is also compatible on PG). A new example
    is in the SQL expression tutorial at the end of [[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]. See [#1665](https://www.sqlalchemy.org/trac/ticket/1665)
    and r6690 for more background.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '为了帮助SQLite而设计的规则已被移除，即另一个复合元素内的第一个复合元素（例如，在`except_()`内部的`union()`）不会被括号括起来。这是不一致的，并且在PostgreSQL上产生错误的结果，因为它有关于INTERSECTION的优先规则，通常会让人感到惊讶。在与SQLite一起使用复杂的复合时，现在需要将第一个元素转换为子查询（这也在PG上兼容）。在[[https://www.sqlalchemy.org/docs/06/sqlexpression.html](https://www.sqlalchemy.org/docs/06/sqlexpression.html)
    #unions-and-other-set-operations]的SQL表达式教程的末尾有一个新示例。查看[#1665](https://www.sqlalchemy.org/trac/ticket/1665)和r6690以获取更多背景信息。'
- en: C Extensions for Result Fetching
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于结果获取的C扩展
- en: The `ResultProxy` and related elements, including most common “row processing”
    functions such as unicode conversion, numerical/boolean conversions and date parsing,
    have been re-implemented as optional C extensions for the purposes of performance.
    This represents the beginning of SQLAlchemy’s path to the “dark side” where we
    hope to continue improving performance by reimplementing critical sections in
    C. The extensions can be built by specifying `--with-cextensions`, i.e. `python
    setup.py --with- cextensions install`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultProxy`和相关元素，包括大多数常见的“行处理”函数，如Unicode转换、数值/布尔转换和日期解析，已被重新实现为可选的C扩展，以提高性能。这标志着SQLAlchemy走向“黑暗面”的开始，我们希望通过在C中重新实现关键部分来继续改进性能。可以通过指定`--with-cextensions`来构建这些扩展，即`python
    setup.py --with- cextensions install`。'
- en: The extensions have the most dramatic impact on result fetching using direct
    `ResultProxy` access, i.e. that which is returned by `engine.execute()`, `connection.execute()`,
    or `session.execute()`. Within results returned by an ORM `Query` object, result
    fetching is not as high a percentage of overhead, so ORM performance improves
    more modestly, and mostly in the realm of fetching large result sets. The performance
    improvements highly depend on the dbapi in use and on the syntax used to access
    the columns of each row (eg `row['name']` is much faster than `row.name`). The
    current extensions have no impact on the speed of inserts/updates/deletes, nor
    do they improve the latency of SQL execution, that is, an application that spends
    most of its time executing many statements with very small result sets will not
    see much improvement.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展对使用直接`ResultProxy`访问的结果获取具有最显著影响，即由`engine.execute()`、`connection.execute()`或`session.execute()`返回的结果。在ORM
    `Query`对象返回的结果中，结果获取不是开销的高比例，因此ORM性能改善较为适度，主要在获取大型结果集的领域。性能改进高度依赖于使用的dbapi以及访问每行列的语法（例如`row['name']`比`row.name`快得多）。当前的扩展对插入/更新/删除的速度没有影响，也不会提高SQL执行的延迟，也就是说，一个大部分时间用于执行许多具有非常小结果集的语句的应用程序不会看到太多改进。
- en: 'Performance has been improved in 0.6 versus 0.5 regardless of the extensions.
    A quick overview of what connecting and fetching 50,000 rows looks like with SQLite,
    using mostly direct SQLite access, a `ResultProxy`, and a simple mapped ORM object:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展无关，0.6版本的性能比0.5版本有所提高。使用SQLite连接和获取50,000行的快速概述，主要使用直接SQLite访问、`ResultProxy`和简单映射的ORM对象：
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Above, the ORM fetches the rows 33% faster than 0.5 due to in-python performance
    enhancements. With the C extensions we get another 20%. However, `ResultProxy`
    fetches improve by 67% with the C extension versus not. Other tests report as
    much as a 200% speed improvement for some scenarios, such as those where lots
    of string conversions are occurring.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，ORM比0.5版本快33%获取行，这归功于Python内部性能的提升。使用C扩展我们可以再获得20%的提升。然而，`ResultProxy`使用C扩展比不使用提升了67%。其他测试报告显示在某些情况下，例如发生大量字符串转换的情况下，速度提高了高达200%。
- en: New Schema Capabilities
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的模式功能
- en: 'The `sqlalchemy.schema` package has received some long- needed attention. The
    most visible change is the newly expanded DDL system. In SQLAlchemy, it was possible
    since version 0.5 to create custom DDL strings and associate them with tables
    or metadata objects:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.schema`包得到了一些长期需要的关注。最显著的变化是新扩展的DDL系统。在SQLAlchemy中，自0.5版本以来，可以创建自定义DDL字符串并将其与表或元数据对象关联：'
- en: '[PRE70]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now the full suite of DDL constructs are available under the same system, including
    those for CREATE TABLE, ADD CONSTRAINT, etc.:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完整的DDL构造都在同一系统下可用，包括用于CREATE TABLE、ADD CONSTRAINT等的构造：
- en: '[PRE71]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Additionally, all the DDL objects are now regular `ClauseElement` objects just
    like any other SQLAlchemy expression object:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有DDL对象现在都是常规的`ClauseElement`对象，就像任何其他SQLAlchemy表达式对象一样：
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'and using the `sqlalchemy.ext.compiler` extension you can make your own:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用`sqlalchemy.ext.compiler`扩展，您可以制作自己的：
- en: '[PRE73]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Deprecated/Removed Schema Elements
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃/移除的模式元素
- en: The schema package has also been greatly streamlined. Many options and methods
    which were deprecated throughout 0.5 have been removed. Other little known accessors
    and methods have also been removed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: schema包也得到了极大简化。许多在0.5版本中被废弃的选项和方法已被移除。其他鲜为人知的访问器和方法也已被移除。
- en: the “owner” keyword argument is removed from `Table`. Use “schema” to represent
    any namespaces to be prepended to the table name.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “owner”关键字参数已从`Table`中移除。使用“schema”表示要预先添加到表名的任何命名空间。
- en: deprecated `MetaData.connect()` and `ThreadLocalMetaData.connect()` have been
    removed - send the “bind” attribute to bind a metadata.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的`MetaData.connect()`和`ThreadLocalMetaData.connect()`已被移除 - 将“bind”属性发送到绑定元数据。
- en: deprecated metadata.table_iterator() method removed (use sorted_tables)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的metadata.table_iterator()方法已被移除（使用sorted_tables）。
- en: the “metadata” argument is removed from `DefaultGenerator` and subclasses, but
    remains locally present on `Sequence`, which is a standalone construct in DDL.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DefaultGenerator`和子类中移除了“metadata”参数，但仍然在`Sequence`上本地存在，这是DDL��的一个独立构造。
- en: deprecated `PassiveDefault` - use `DefaultClause`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的`PassiveDefault` - 使用`DefaultClause`。
- en: 'Removed public mutability from `Index` and `Constraint` objects:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Index`和`Constraint`对象中移除了公共可变性：
- en: '`ForeignKeyConstraint.append_element()`'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKeyConstraint.append_element()`'
- en: '`Index.append_column()`'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index.append_column()`'
- en: '`UniqueConstraint.append_column()`'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint.append_column()`'
- en: '`PrimaryKeyConstraint.add()`'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.add()`'
- en: '`PrimaryKeyConstraint.remove()`'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.remove()`'
- en: These should be constructed declaratively (i.e. in one construction).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该以声明性的方式构造（即一次性构造）。
- en: 'Other removed things:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他已移除的内容：
- en: '`Table.key` (no idea what this was for)'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.key`（不知道用于什么）'
- en: '`Column.bind` (get via column.table.bind)'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.bind`（通过列的`table.bind`获取）'
- en: '`Column.metadata` (get via column.table.metadata)'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.metadata`（通过列的`table.metadata`获取）'
- en: '`Column.sequence` (use column.default)'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.sequence`（使用列的默认值`column.default`）'
- en: Other Behavioral Changes
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他行为变化
- en: '`UniqueConstraint`, `Index`, `PrimaryKeyConstraint` all accept lists of column
    names or column objects as arguments.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint`、`Index`、`PrimaryKeyConstraint` 都接受列名或列对象的列表作为参数。'
- en: The `use_alter` flag on `ForeignKey` is now a shortcut option for operations
    that can be hand-constructed using the `DDL()` event system. A side effect of
    this refactor is that `ForeignKeyConstraint` objects with `use_alter=True` will
    *not* be emitted on SQLite, which does not support ALTER for foreign keys. This
    has no effect on SQLite’s behavior since SQLite does not actually honor FOREIGN
    KEY constraints.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKey` 上的 `use_alter` 标志现在是一个快捷选项，用于可以手动构造使用 `DDL()` 事件系统的操作。此重构的一个副作用是，具有
    `use_alter=True` 的 `ForeignKeyConstraint` 对象将 *不会* 在 SQLite 上发出，因为 SQLite 不支持外键的
    ALTER。这对 SQLite 的行为没有影响，因为 SQLite 实际上不遵守外键约束。'
- en: '`Table.primary_key` is not assignable - use `table.append_constraint(PrimaryKeyConstraint(...))`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.primary_key` 不可分配 - 使用 `table.append_constraint(PrimaryKeyConstraint(...))`'
- en: A `Column` definition with a `ForeignKey` and no type, e.g. `Column(name, ForeignKey(sometable.c.somecol))`
    used to get the type of the referenced column. Now support for that automatic
    type inference is partial and may not work in all cases.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `ForeignKey` 但没有类型定义的 `Column` 定义，例如 `Column(name, ForeignKey(sometable.c.somecol))`
    曾用于获取引用列的类型。现在，对于该自动类型推断的支持是部分的，可能并不适用于所有情况。
- en: Deprecated/Removed Schema Elements
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃/移除的模式元素
- en: The schema package has also been greatly streamlined. Many options and methods
    which were deprecated throughout 0.5 have been removed. Other little known accessors
    and methods have also been removed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 模式包也已经大大简化。在 0.5 版本中已弃用的许多选项和方法已被移除。其他不太常用的访问器和方法也已被移除。
- en: the “owner” keyword argument is removed from `Table`. Use “schema” to represent
    any namespaces to be prepended to the table name.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Table` 中移除了“owner”关键字参数。使用“schema”表示要预先添加到表名的任何命名空间。
- en: deprecated `MetaData.connect()` and `ThreadLocalMetaData.connect()` have been
    removed - send the “bind” attribute to bind a metadata.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的 `MetaData.connect()` 和 `ThreadLocalMetaData.connect()` 已被移除 - 发送“bind”属性以绑定元数据。
- en: deprecated metadata.table_iterator() method removed (use sorted_tables)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已移除的废弃的 `metadata.table_iterator()` 方法（使用 `sorted_tables`）
- en: the “metadata” argument is removed from `DefaultGenerator` and subclasses, but
    remains locally present on `Sequence`, which is a standalone construct in DDL.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `DefaultGenerator` 和子类中移除了“metadata”参数，但在 `Sequence` 中仍然局部存在，`Sequence` 是
    DDL 中的一个独立构造。
- en: deprecated `PassiveDefault` - use `DefaultClause`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的 `PassiveDefault` - 使用 `DefaultClause`。
- en: 'Removed public mutability from `Index` and `Constraint` objects:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Index` 和 `Constraint` 对象中移除了公共可变性：
- en: '`ForeignKeyConstraint.append_element()`'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKeyConstraint.append_element()`'
- en: '`Index.append_column()`'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index.append_column()`'
- en: '`UniqueConstraint.append_column()`'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint.append_column()`'
- en: '`PrimaryKeyConstraint.add()`'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.add()`'
- en: '`PrimaryKeyConstraint.remove()`'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryKeyConstraint.remove()`'
- en: These should be constructed declaratively (i.e. in one construction).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该以声明性的方式构造（即一次性构造）。
- en: 'Other removed things:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他已移除的内容：
- en: '`Table.key` (no idea what this was for)'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.key`（不知道用于什么）'
- en: '`Column.bind` (get via column.table.bind)'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.bind`（通过列的`table.bind`获取）'
- en: '`Column.metadata` (get via column.table.metadata)'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.metadata`（通过列的`table.metadata`获取）'
- en: '`Column.sequence` (use column.default)'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column.sequence`（使用列的默认值`column.default`）'
- en: Other Behavioral Changes
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他行为变化
- en: '`UniqueConstraint`, `Index`, `PrimaryKeyConstraint` all accept lists of column
    names or column objects as arguments.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConstraint`、`Index`、`PrimaryKeyConstraint` 都接受列名或列对象的列表作为参数。'
- en: The `use_alter` flag on `ForeignKey` is now a shortcut option for operations
    that can be hand-constructed using the `DDL()` event system. A side effect of
    this refactor is that `ForeignKeyConstraint` objects with `use_alter=True` will
    *not* be emitted on SQLite, which does not support ALTER for foreign keys. This
    has no effect on SQLite’s behavior since SQLite does not actually honor FOREIGN
    KEY constraints.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForeignKey` 上的 `use_alter` 标志现在是手动构造使用 `DDL()` 事件系统的操作的快捷选项。这个重构的副作用是，带有 `use_alter=True`
    的 `ForeignKeyConstraint` 对象将不会在 SQLite 上发出，因为 SQLite 不支持外键的 ALTER。这对 SQLite 的行为没有影响，因为
    SQLite 实际上不遵守 FOREIGN KEY 约束。'
- en: '`Table.primary_key` is not assignable - use `table.append_constraint(PrimaryKeyConstraint(...))`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table.primary_key` 不可分配 - 使用 `table.append_constraint(PrimaryKeyConstraint(...))`'
- en: A `Column` definition with a `ForeignKey` and no type, e.g. `Column(name, ForeignKey(sometable.c.somecol))`
    used to get the type of the referenced column. Now support for that automatic
    type inference is partial and may not work in all cases.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column` 定义中有一个 `ForeignKey` 而没有类型，例如 `Column(name, ForeignKey(sometable.c.somecol))`
    用于获取引用列的类型。现在对于这种自动类型推断的支持是部分的，并且可能不适用于所有情况。'
- en: Logging opened up
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志开放
- en: At the expense of a few extra method calls here and there, you can set log levels
    for INFO and DEBUG after an engine, pool, or mapper has been created, and logging
    will commence. The `isEnabledFor(INFO)` method is now called per-`Connection`
    and `isEnabledFor(DEBUG)` per-`ResultProxy` if already enabled on the parent connection.
    Pool logging sends to `log.info()` and `log.debug()` with no check - note that
    pool checkout/checkin is typically once per transaction.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次额外的方法调用，你可以在创建引擎、池或映射器后设置 INFO 和 DEBUG 的日志级别，日志将开始记录。`isEnabledFor(INFO)`
    方法现在每个 `Connection` 调用一次，如果已在父连接上启用，则每个 `ResultProxy` 调用一次 `isEnabledFor(DEBUG)`。池日志发送到
    `log.info()` 和 `log.debug()`，没有检查 - 请注意，池的检出/归还通常是每个事务一次。
- en: Reflection/Inspector API
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射/检查器 API
- en: The reflection system, which allows reflection of table columns via `Table('sometable',
    metadata, autoload=True)` has been opened up into its own fine-grained API, which
    allows direct inspection of database elements such as tables, columns, constraints,
    indexes, and more. This API expresses return values as simple lists of strings,
    dictionaries, and `TypeEngine` objects. The internals of `autoload=True` now build
    upon this system such that the translation of raw database information into `sqlalchemy.schema`
    constructs is centralized and the contract of individual dialects greatly simplified,
    vastly reducing bugs and inconsistencies across different backends.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统，允许通过 `Table('sometable', metadata, autoload=True)` 反射表列已被开放到其自己的细粒度 API
    中，该 API 允许直接检查数据库元素，如表、列、约束、索引等等。此 API 将返回值表示为简单的字符串、字典和 `TypeEngine` 对象列表。现在
    `autoload=True` 的内部构建在此系统之上，将原始数据库信息转换为 `sqlalchemy.schema` 构造的过程集中化，并且各个方言的契约大大简化，极大地减少了不同后端之间的错误和不一致性。
- en: 'To use an inspector:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检查器：
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'the `from_engine()` method will in some cases provide a backend-specific inspector
    with additional capabilities, such as that of PostgreSQL which provides a `get_table_oid()`
    method:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_engine()` 方法在某些情况下将提供一个具有额外功能的特定于后端的检查器，例如 PostgreSQL 提供一个 `get_table_oid()`
    方法：'
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: RETURNING Support
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RETURNING 支持
- en: The `insert()`, `update()` and `delete()` constructs now support a `returning()`
    method, which corresponds to the SQL RETURNING clause as supported by PostgreSQL,
    Oracle, MS-SQL, and Firebird. It is not supported for any other backend at this
    time.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`、`update()` 和 `delete()` 构造现在支持一个 `returning()` 方法，该方法对应于 PostgreSQL、Oracle、MS-SQL
    和 Firebird 支持的 SQL RETURNING 子句。目前其他后端不支持。'
- en: 'Given a list of column expressions in the same manner as that of a `select()`
    construct, the values of these columns will be returned as a regular result set:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个与 `select()` 构造方式相同的列表达式列表，这些列的值将作为常规结果集返回：
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The implementation of RETURNING across the four supported backends varies wildly,
    in the case of Oracle requiring an intricate usage of OUT parameters which are
    re-routed into a “mock” result set, and in the case of MS-SQL using an awkward
    SQL syntax. The usage of RETURNING is subject to limitations:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在四个支持的后端中，RETURNING 的实现差异很大，在 Oracle 的情况下，需要复杂地使用 OUT 参数，这些参数被重新路由到一个“模拟”结果集中，在
    MS-SQL 的情况下使用笨拙的 SQL 语法。RETURNING 的使用受到限制：
- en: it does not work for any “executemany()” style of execution. This is a limitation
    of all supported DBAPIs.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于任何“executemany()”风格的执行。这是所有支持的 DBAPI 的限制。
- en: Some backends, such as Oracle, only support RETURNING that returns a single
    row - this includes UPDATE and DELETE statements, meaning the update() or delete()
    construct must match only a single row, or an error is raised (by Oracle, not
    SQLAlchemy).
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些后端，如Oracle，仅支持返回单行的RETURNING - 这包括UPDATE和DELETE语句，意味着update()或delete()构造必须仅匹配单行，否则会引发错误（由Oracle而不是SQLAlchemy引发）。
- en: RETURNING is also used automatically by SQLAlchemy, when available and when
    not otherwise specified by an explicit `returning()` call, to fetch the value
    of newly generated primary key values for single-row INSERT statements. This means
    there’s no more “SELECT nextval(sequence)” pre- execution for insert statements
    where the primary key value is required. Truth be told, implicit RETURNING feature
    does incur more method overhead than the old “select nextval()” system, which
    used a quick and dirty cursor.execute() to get at the sequence value, and in the
    case of Oracle requires additional binding of out parameters. So if method/protocol
    overhead is proving to be more expensive than additional database round trips,
    the feature can be disabled by specifying `implicit_returning=False` to `create_engine()`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当单行INSERT语句需要获取新生成的主键值时，SQLAlchemy也会自动使用RETURNING，当其他地方没有通过显式的`returning()`调用指定时。这意味着对于需要主键值的插入语句，不再需要“SELECT
    nextval(sequence)”预执行。说实话，隐式的RETURNING特性确实比旧的“select nextval()”系统多产生了更多的方法开销，后者使用了一个快速而肮脏的cursor.execute()来获取序列值，并且在Oracle的情况下需要额外绑定out参数。因此，如果方法/协议开销比额外的数据库往返开销更昂贵，则可以通过向`create_engine()`指定`implicit_returning=False`来禁用该特性。
- en: Type System Changes
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型系统更改
- en: New Architecture
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新架构
- en: 'The type system has been completely reworked behind the scenes to provide two
    goals:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，类型系统已经完全重构，以实现两个目标：
- en: Separate the handling of bind parameters and result row values, typically a
    DBAPI requirement, from the SQL specification of the type itself, which is a database
    requirement. This is consistent with the overall dialect refactor that separates
    database SQL behavior from DBAPI.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将绑定参数和结果行值的处理分开，通常是DBAPI的要求，与类型本身的SQL规范分开，这是数据库的要求。这与将数据库SQL行为与DBAPI分离的总体方言重构一致。
- en: Establish a clear and consistent contract for generating DDL from a `TypeEngine`
    object and for constructing `TypeEngine` objects based on column reflection.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为从`TypeEngine`对象生成DDL和基于列反射构造`TypeEngine`对象建立清晰一致的合同。
- en: 'Highlights of these changes include:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化的亮点包括：
- en: The construction of types within dialects has been totally overhauled. Dialects
    now define publicly available types as UPPERCASE names exclusively, and internal
    implementation types using underscore identifiers (i.e. are private). The system
    by which types are expressed in SQL and DDL has been moved to the compiler system.
    This has the effect that there are much fewer type objects within most dialects.
    A detailed document on this architecture for dialect authors is in [source:/lib/sqlalc
    hemy/dialects/type_migration_guidelines.txt].
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言中类型的构造已彻底改写。方言现在将公开可用的类型定义为仅大写名称，并使用下划线标识符（即私有）进行内部实现类型。类型在SQL和DDL中的表达方式已移至编译器系统。这样做的效果是大多数方言中几乎没有类型对象。关于此架构的详细文档可供方言作者使用，在[source:/lib/sqlalchemy/dialects/type_migration_guidelines.txt]中。
- en: Reflection of types now returns the exact UPPERCASE type within types.py, or
    the UPPERCASE type within the dialect itself if the type is not a standard SQL
    type. This means reflection now returns more accurate information about reflected
    types.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在类型的反射将返回types.py中的确切大写类型，或者如果该类型不是标准SQL类型，则在方言本身中返回大写类型。这意味着反射现在返回更准确的反射类型信息。
- en: User defined types that subclass `TypeEngine` and wish to provide `get_col_spec()`
    should now subclass `UserDefinedType`.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类型，其子类为`TypeEngine`且希望提供`get_col_spec()`，现在应该将其子类化为`UserDefinedType`。
- en: The `result_processor()` method on all type classes now accepts an additional
    argument `coltype`. This is the DBAPI type object attached to cursor.description,
    and should be used when applicable to make better decisions on what kind of result-processing
    callable should be returned. Ideally result processor functions would never need
    to use `isinstance()`, which is an expensive call at this level.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型类上的`result_processor()`方法现在接受一个额外的参数`coltype`。这是附加到cursor.description的DBAPI类型对象，并且在适用时应该使用它来做出更好的决定，以确定应返回什么类型的结果处理可调用对象。理想情况下，结果处理函数永远不应该使用`isinstance()`，因为这是一个在这个级别上昂贵的调用。
- en: Native Unicode Mode
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地Unicode模式
- en: 'As more DBAPIs support returning Python unicode objects directly, the base
    dialect now performs a check upon the first connection which establishes whether
    or not the DBAPI returns a Python unicode object for a basic select of a VARCHAR
    value. If so, the `String` type and all subclasses (i.e. `Text`, `Unicode`, etc.)
    will skip the “unicode” check/conversion step when result rows are received. This
    offers a dramatic performance increase for large result sets. The “unicode mode”
    currently is known to work with:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多的DBAPI支持直接返回Python unicode对象，基本方言现在在建立第一个连接时执行检查，以确定DBAPI是否为基本VARCHAR值的基本选择返回Python
    unicode对象。如果是这样，`String`类型及其所有子类（即`Text`，`Unicode`等）在接收到结果行时将跳过“unicode”检查/转换步骤。对于大型结果集，这将大幅提高性能。目前已知“unicode模式”可以与以下内容配合使用：
- en: sqlite3 / pysqlite
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3 / pysqlite
- en: psycopg2 - SQLA 0.6 now uses the “UNICODE” type extension by default on each
    psycopg2 connection object
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2 - SQLA 0.6现在在每个psycopg2连接对象上默认使用“UNICODE”类型扩展
- en: pg8000
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg8000
- en: cx_oracle (we use an output processor - nice feature !)
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_oracle（我们使用输出处理器 - 很好的功能！）
- en: Other types may choose to disable unicode processing as needed, such as the
    `NVARCHAR` type when used with MS-SQL.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型可以根据需要选择禁用unicode处理，例如与MS-SQL一起使用时的`NVARCHAR`类型。
- en: In particular, if porting an application based on a DBAPI that formerly returned
    non-unicode strings, the “native unicode” mode has a plainly different default
    behavior - columns that are declared as `String` or `VARCHAR` now return unicode
    by default whereas they would return strings before. This can break code which
    expects non-unicode strings. The psycopg2 “native unicode” mode can be disabled
    by passing `use_native_unicode=False` to `create_engine()`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果基于以前返回非unicode字符串的DBAPI的应用程序，则“本地unicode”模式具有明显不同的默认行为 - 声明为`String`或`VARCHAR`的列现在默认返回unicode，而以前则返回字符串。这可能会破坏期望非unicode字符串的代码。可以通过将`use_native_unicode=False`传递给`create_engine()`来禁用psycopg2的“本地unicode”模式。
- en: 'A more general solution for string columns that explicitly do not want a unicode
    object is to use a `TypeDecorator` that converts unicode back to utf-8, or whatever
    is desired:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 对于明确不希望使用unicode对象的字符串列，更一般的解决方案是使用`TypeDecorator`将unicode转换回utf-8，或者任何所需的格式：
- en: '[PRE77]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Note that the `assert_unicode` flag is now deprecated. SQLAlchemy allows the
    DBAPI and backend database in use to handle Unicode parameters when available,
    and does not add operational overhead by checking the incoming type; modern systems
    like sqlite and PostgreSQL will raise an encoding error on their end if invalid
    data is passed. In those cases where SQLAlchemy does need to coerce a bind parameter
    from Python Unicode to an encoded string, or when the Unicode type is used explicitly,
    a warning is raised if the object is a bytestring. This warning can be suppressed
    or converted to an exception using the Python warnings filter documented at: [https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`assert_unicode`标志现已弃用。SQLAlchemy允许DBAPI和正在使用的后端数据库在可用时处理Unicode参数，并且通过检查传入类型来增加操作开销;像sqlite和PostgreSQL这样的现代系统将在其端口上引发编码错误，如果传递的数据无效。在SQLAlchemy确实需要将绑定参数从Python
    Unicode强制转换为编码字符串时，或者当显式使用Unicode类型时，如果对象是字节串，则会发出警告。可以使用Python警告过滤器抑制或将此警告转换为异常，该过滤器的文档在：[https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)
- en: Generic Enum Type
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用枚举类型
- en: We now have an `Enum` in the `types` module. This is a string type that is given
    a collection of “labels” which constrain the possible values given to those labels.
    By default, this type generates a `VARCHAR` using the size of the largest label,
    and applies a CHECK constraint to the table within the CREATE TABLE statement.
    When using MySQL, the type by default uses MySQL’s ENUM type, and when using PostgreSQL
    the type will generate a user defined type using `CREATE TYPE <mytype> AS ENUM`.
    In order to create the type using PostgreSQL, the `name` parameter must be specified
    to the constructor. The type also accepts a `native_enum=False` option which will
    issue the VARCHAR/CHECK strategy for all databases. Note that PostgreSQL ENUM
    types currently don’t work with pg8000 or zxjdbc.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 `types` 模块中有一个 `Enum`。这是一个字符串类型，给定一组“标签”，限制给这些标签的可能值。默认情况下，此类型生成一个 `VARCHAR`，其大小为最大标签的大小，并在
    CREATE TABLE 语句中对表施加 CHECK 约束。当使用 MySQL 时，默认情况下该类型使用 MySQL 的 ENUM 类型；当使用 PostgreSQL
    时，该类型将使用 `CREATE TYPE <mytype> AS ENUM` 生成用户定义类型。为了在 PostgreSQL 中创建该类型，必须在构造函数中指定
    `name` 参数。该类型还接受一个 `native_enum=False` 选项，它将为所有数据库使用 VARCHAR/CHECK 策略。请注意，PostgreSQL
    的 ENUM 类型目前无法与 pg8000 或 zxjdbc 一起使用。
- en: Reflection Returns Dialect-Specific Types
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射返回方言特定类型
- en: Reflection now returns the most specific type possible from the database. That
    is, if you create a table using `String`, then reflect it back, the reflected
    column will likely be `VARCHAR`. For dialects that support a more specific form
    of the type, that’s what you’ll get. So a `Text` type would come back as `oracle.CLOB`
    on Oracle, a `LargeBinary` might be an `mysql.MEDIUMBLOB` etc. The obvious advantage
    here is that reflection preserves as much information possible from what the database
    had to say.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 反射现在从数据库返回最具体的类型。也就是说，如果你使用 `String` 创建一个表，然后将其反射回来，反射的列可能是 `VARCHAR`。对于支持更具体类型形式的方言，你会得到相应的类型。因此，在
    Oracle 上，`Text` 类型会返回 `oracle.CLOB`，`LargeBinary` 可能是 `mysql.MEDIUMBLOB` 等等。这里的明显优势在于反射尽可能保留来自数据库的信息。
- en: 'Some applications that deal heavily in table metadata may wish to compare types
    across reflected tables and/or non- reflected tables. There’s a semi-private accessor
    available on `TypeEngine` called `_type_affinity` and an associated comparison
    helper `_compare_type_affinity`. This accessor returns the “generic” `types` class
    which the type corresponds to:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一些处理表元数据的应用程序可能希望在反射表和/或非反射表之间比较类型。`TypeEngine` 上有一个半私有访问器叫做 `_type_affinity`，以及一个相关的比较辅助函数
    `_compare_type_affinity`。该访问器返回与类型对应的“通用” `types` 类：
- en: '[PRE78]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Miscellaneous API Changes
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项 API 变更
- en: 'The usual “generic” types are still the general system in use, i.e. `String`,
    `Float`, `DateTime`. There’s a few changes there:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的“通用”类型仍然是通用系统中使用的一般类型，即 `String`、`Float`、`DateTime`。这里有一些变化：
- en: Types no longer make any guesses as to default parameters. In particular, `Numeric`,
    `Float`, as well as subclasses NUMERIC, FLOAT, DECIMAL don’t generate any length
    or scale unless specified. This also continues to include the controversial `String`
    and `VARCHAR` types (although MySQL dialect will pre-emptively raise when asked
    to render VARCHAR with no length). No defaults are assumed, and if they are used
    in a CREATE TABLE statement, an error will be raised if the underlying database
    does not allow non-lengthed versions of these types.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型不再猜测默认参数。特别是 `Numeric`、`Float`，以及 NUMERIC、FLOAT、DECIMAL 的子类，除非指定，否则不会生成任何长度或比例。这也包括有争议的
    `String` 和 `VARCHAR` 类型（尽管 MySQL 方言在要求不带长度的 VARCHAR 时会预先引发错误）。不假设任何默认值，如果它们在 CREATE
    TABLE 语句中使用，并且底层数据库不允许这些类型的非长度版本，则会引发错误。
- en: the `Binary` type has been renamed to `LargeBinary`, for BLOB/BYTEA/similar
    types. For `BINARY` and `VARBINARY`, those are present directly as `types.BINARY`,
    `types.VARBINARY`, as well as in the MySQL and MS-SQL dialects.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Binary` 类型已经改名为 `LargeBinary`，用于 BLOB/BYTEA/类似类型。对于 `BINARY` 和 `VARBINARY`，直接使用
    `types.BINARY`、`types.VARBINARY`，以及在 MySQL 和 MS-SQL 方言中。'
- en: '`PickleType` now uses == for comparison of values when mutable=True, unless
    the “comparator” argument with a comparison function is specified to the type.
    If you are pickling a custom object you should implement an `__eq__()` method
    so that value-based comparisons are accurate.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `PickleType` 的 `mutable=True` 时，现在使用 `==` 进行值的比较，除非指定了带有比较函数的 “comparator”
    参数给该类型。如果您要 pickle 一个自定义对象，应该实现一个 `__eq__()` 方法，以确保基于值的比较准确。
- en: The default “precision” and “scale” arguments of Numeric and Float have been
    removed and now default to None. NUMERIC and FLOAT will be rendered with no numeric
    arguments by default unless these values are provided.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numeric 和 Float 的默认 “precision” 和 “scale” 参数已移除，现在默认为 None。NUMERIC 和 FLOAT 将默认不带数字参数呈现，除非提供这些值。
- en: DATE, TIME and DATETIME types on SQLite can now take optional “storage_format”
    and “regexp” argument. “storage_format” can be used to store those types using
    a custom string format. “regexp” allows to use a custom regular expression to
    match string values from the database.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 DATE、TIME 和 DATETIME 类型现在可以使用可选的 “storage_format” 和 “regexp” 参数。“storage_format”
    可用于使用自定义字符串格式存储这些类型。“regexp” 允许使用自定义正则表达式来匹配来自数据库的字符串值。
- en: '`__legacy_microseconds__` on SQLite `Time` and `DateTime` types is not supported
    anymore. You should use the new “storage_format” argument instead.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__legacy_microseconds__` 在 SQLite 的 `Time` 和 `DateTime` 类型上不再受支持。您应该使用新的 “storage_format”
    参数代替。'
- en: '`DateTime` types on SQLite now use by a default a stricter regular expression
    to match strings from the database. Use the new “regexp” argument if you are using
    data stored in a legacy format.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 `DateTime` 类型现在默认使用更严格的正则表达式来匹配来自数据库的字符串。如果您使用存储在遗留格式中的数据，请使用新的 “regexp”
    参数。
- en: New Architecture
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新架构
- en: 'The type system has been completely reworked behind the scenes to provide two
    goals:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统已在幕后完全重做，以实现两个目标：
- en: Separate the handling of bind parameters and result row values, typically a
    DBAPI requirement, from the SQL specification of the type itself, which is a database
    requirement. This is consistent with the overall dialect refactor that separates
    database SQL behavior from DBAPI.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将绑定参数和结果行值的处理分开，通常是 DBAPI 的要求，与类型本身的 SQL 规范分开，这是数据库的要求。这与将数据库 SQL 行为与 DBAPI
    分开的整体方言重构保持一致。
- en: Establish a clear and consistent contract for generating DDL from a `TypeEngine`
    object and for constructing `TypeEngine` objects based on column reflection.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为从 `TypeEngine` 对象生成 DDL 和基于列反射构造 `TypeEngine` 对象建立清晰一致的合同。
- en: 'Highlights of these changes include:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变更的亮点包括：
- en: The construction of types within dialects has been totally overhauled. Dialects
    now define publicly available types as UPPERCASE names exclusively, and internal
    implementation types using underscore identifiers (i.e. are private). The system
    by which types are expressed in SQL and DDL has been moved to the compiler system.
    This has the effect that there are much fewer type objects within most dialects.
    A detailed document on this architecture for dialect authors is in [source:/lib/sqlalc
    hemy/dialects/type_migration_guidelines.txt].
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言中类型的构造已完全重构。方言现在专门使用大写名称定义公开可用的类型，并使用下划线标识符（即私有）定义内部实现类型。用于在 SQL 和 DDL 中表达类型的系统已移至编译器系统。这意味着大多数方言中的类型对象大大减少。有关此架构的详细文档，供方言作者参考在
    [source:/lib/sqlalchemy/dialects/type_migration_guidelines.txt]。
- en: Reflection of types now returns the exact UPPERCASE type within types.py, or
    the UPPERCASE type within the dialect itself if the type is not a standard SQL
    type. This means reflection now returns more accurate information about reflected
    types.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，类型的反射返回 types.py 中的确切大写类型，或者如果类型不是标准 SQL 类型，则返回方言本身的大写类型。这意味着反射现在返回有关反射类型的更准确信息。
- en: User defined types that subclass `TypeEngine` and wish to provide `get_col_spec()`
    should now subclass `UserDefinedType`.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化 `TypeEngine` 并希望提供 `get_col_spec()` 的用户定义类型现在应该子类化 `UserDefinedType`。
- en: The `result_processor()` method on all type classes now accepts an additional
    argument `coltype`. This is the DBAPI type object attached to cursor.description,
    and should be used when applicable to make better decisions on what kind of result-processing
    callable should be returned. Ideally result processor functions would never need
    to use `isinstance()`, which is an expensive call at this level.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型类上的 `result_processor()` 方法现在接受附加参数 `coltype`。这是附加到 cursor.description 的
    DBAPI 类型对象，并且应该在适用时使用，以便更好地决定返回何种类型的结果处理可调用函数。理想情况下，结果处理函数永远不应该使用 `isinstance()`，因为这是在此级别的一个昂贵的调用。
- en: Native Unicode Mode
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地 Unicode 模式
- en: 'As more DBAPIs support returning Python unicode objects directly, the base
    dialect now performs a check upon the first connection which establishes whether
    or not the DBAPI returns a Python unicode object for a basic select of a VARCHAR
    value. If so, the `String` type and all subclasses (i.e. `Text`, `Unicode`, etc.)
    will skip the “unicode” check/conversion step when result rows are received. This
    offers a dramatic performance increase for large result sets. The “unicode mode”
    currently is known to work with:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的 DBAPI 支持直接返回 Python Unicode 对象，基本方言现在在第一次连接时执行检查，以确定 DBAPI 是否为 VARCHAR
    值的基本选择返回 Python Unicode 对象。如果是这样，`String` 类型和所有子类（即 `Text`，`Unicode` 等）在接收到结果行时将跳过“unicode”检查/转换步骤。这为大型结果集提供了显著的性能提升。目前“unicode
    模式”已知可与以下一起使用：
- en: sqlite3 / pysqlite
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3 / pysqlite
- en: psycopg2 - SQLA 0.6 now uses the “UNICODE” type extension by default on each
    psycopg2 connection object
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2 - SQLA 0.6 现在默认在每个 psycopg2 连接对象上使用“UNICODE” 类型扩展
- en: pg8000
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg8000
- en: cx_oracle (we use an output processor - nice feature !)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_oracle（我们使用输出处理器 - 很好的功能！）
- en: Other types may choose to disable unicode processing as needed, such as the
    `NVARCHAR` type when used with MS-SQL.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型可能会根据需要禁用 Unicode 处理，例如在与 MS-SQL 一起使用时的 `NVARCHAR` 类型。
- en: In particular, if porting an application based on a DBAPI that formerly returned
    non-unicode strings, the “native unicode” mode has a plainly different default
    behavior - columns that are declared as `String` or `VARCHAR` now return unicode
    by default whereas they would return strings before. This can break code which
    expects non-unicode strings. The psycopg2 “native unicode” mode can be disabled
    by passing `use_native_unicode=False` to `create_engine()`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果迁移基于以前返回非 Unicode 字符串的 DBAPI 的应用程序，则“本机 Unicode” 模式具有明显不同的默认行为 - 声明为 `String`
    或 `VARCHAR` 的列现在默认返回 Unicode，而以前会返回字符串。这可能会破坏期望非 Unicode 字符串的代码。可以通过向 `create_engine()`
    传递 `use_native_unicode=False` 来禁用 psycopg2 的“本机 Unicode” 模式。
- en: 'A more general solution for string columns that explicitly do not want a unicode
    object is to use a `TypeDecorator` that converts unicode back to utf-8, or whatever
    is desired:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于明确不希望使用 Unicode 对象的字符串列的更一般解决方案是使用一个 `TypeDecorator`，将 Unicode 转换回 utf-8，或者其他所需的格式：
- en: '[PRE79]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that the `assert_unicode` flag is now deprecated. SQLAlchemy allows the
    DBAPI and backend database in use to handle Unicode parameters when available,
    and does not add operational overhead by checking the incoming type; modern systems
    like sqlite and PostgreSQL will raise an encoding error on their end if invalid
    data is passed. In those cases where SQLAlchemy does need to coerce a bind parameter
    from Python Unicode to an encoded string, or when the Unicode type is used explicitly,
    a warning is raised if the object is a bytestring. This warning can be suppressed
    or converted to an exception using the Python warnings filter documented at: [https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`assert_unicode` 标志现已弃用。SQLAlchemy 允许 DBAPI 和后端数据库在可用时处理 Unicode 参数，并且不通过检查传入类型增加操作开销；现代系统如
    sqlite 和 PostgreSQL 将在其端引发编码错误，如果传递了无效数据。在 SQLAlchemy 需要将绑定参数从 Python Unicode
    强制转换为编码字符串时，或者显式使用 Unicode 类型时，如果对象是字节字符串，则会发出警告。可以使用 Python 警告过滤器文档中记录的警告过滤器将此警告抑制或转换为异常：[https://docs.python.org/library/warnings.html](https://docs.python.org/library/warnings.html)
- en: Generic Enum Type
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用枚举类型
- en: We now have an `Enum` in the `types` module. This is a string type that is given
    a collection of “labels” which constrain the possible values given to those labels.
    By default, this type generates a `VARCHAR` using the size of the largest label,
    and applies a CHECK constraint to the table within the CREATE TABLE statement.
    When using MySQL, the type by default uses MySQL’s ENUM type, and when using PostgreSQL
    the type will generate a user defined type using `CREATE TYPE <mytype> AS ENUM`.
    In order to create the type using PostgreSQL, the `name` parameter must be specified
    to the constructor. The type also accepts a `native_enum=False` option which will
    issue the VARCHAR/CHECK strategy for all databases. Note that PostgreSQL ENUM
    types currently don’t work with pg8000 or zxjdbc.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `types` 模块中有一个 `Enum`。这是一个字符串类型，给定一组“标签”，这些标签限制了给定给这些标签的可能值。默认情况下，此类型生成一个使用最大标签大小的
    `VARCHAR`，并在 CREATE TABLE 语句中对表应用 CHECK 约束。在使用 MySQL 时，默认情况下，该类型使用 MySQL 的 ENUM
    类型，而在使用 PostgreSQL 时，该类型将生成一个使用 `CREATE TYPE <mytype> AS ENUM` 的用户定义类型。为了在 PostgreSQL
    中创建类型，必须在构造函数中指定 `name` 参数。该类型还接受一个 `native_enum=False` 选项，该选项将为所有数据库发出 VARCHAR/CHECK
    策略。请注意，PostgreSQL ENUM 类型目前无法与 pg8000 或 zxjdbc 一起使用。
- en: Reflection Returns Dialect-Specific Types
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射返回方言特定类型
- en: Reflection now returns the most specific type possible from the database. That
    is, if you create a table using `String`, then reflect it back, the reflected
    column will likely be `VARCHAR`. For dialects that support a more specific form
    of the type, that’s what you’ll get. So a `Text` type would come back as `oracle.CLOB`
    on Oracle, a `LargeBinary` might be an `mysql.MEDIUMBLOB` etc. The obvious advantage
    here is that reflection preserves as much information possible from what the database
    had to say.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 反射现在从数据库返回尽可能具体的类型。也就是说，如果使用 `String` 创建表，然后反射它，反射的列可能是 `VARCHAR`。对于支持更具体形式的类型的方言，您将得到该类型。因此，在
    Oracle 上，`Text` 类型将返回为 `oracle.CLOB`，在 MySQL 上，`LargeBinary` 可能是 `mysql.MEDIUMBLOB`
    等。这里的明显优势是反射尽可能保留数据库所说的信息。
- en: 'Some applications that deal heavily in table metadata may wish to compare types
    across reflected tables and/or non- reflected tables. There’s a semi-private accessor
    available on `TypeEngine` called `_type_affinity` and an associated comparison
    helper `_compare_type_affinity`. This accessor returns the “generic” `types` class
    which the type corresponds to:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一些处理表元数据的应用程序可能希望比较反射表和/或非反射表上的类型。`TypeEngine` 上有一个半私有访问器叫做 `_type_affinity`，以及一个相关的比较助手
    `_compare_type_affinity`。此访问器返回类型对应的“通用” `types` 类：
- en: '[PRE80]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Miscellaneous API Changes
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项 API 更改
- en: 'The usual “generic” types are still the general system in use, i.e. `String`,
    `Float`, `DateTime`. There’s a few changes there:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的“通用”类型仍然是使用的一般系统，即 `String`、`Float`、`DateTime`。在那里有一些变化：
- en: Types no longer make any guesses as to default parameters. In particular, `Numeric`,
    `Float`, as well as subclasses NUMERIC, FLOAT, DECIMAL don’t generate any length
    or scale unless specified. This also continues to include the controversial `String`
    and `VARCHAR` types (although MySQL dialect will pre-emptively raise when asked
    to render VARCHAR with no length). No defaults are assumed, and if they are used
    in a CREATE TABLE statement, an error will be raised if the underlying database
    does not allow non-lengthed versions of these types.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型不再对默认参数进行任何猜测。特别是，`Numeric`、`Float`，以及子类 NUMERIC、FLOAT、DECIMAL 不会生成任何长度或精度，除非指定。这也包括有争议的
    `String` 和 `VARCHAR` 类型（尽管 MySQL 方言在要求渲染没有长度的 VARCHAR 时会预先引发错误）。不会假设任何默认值，如果它们在
    CREATE TABLE 语句中使用，如果底层数据库不允许这些类型的无长度版本，则会引发错误。
- en: the `Binary` type has been renamed to `LargeBinary`, for BLOB/BYTEA/similar
    types. For `BINARY` and `VARBINARY`, those are present directly as `types.BINARY`,
    `types.VARBINARY`, as well as in the MySQL and MS-SQL dialects.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Binary` 类型已更名为 `LargeBinary`，用于 BLOB/BYTEA/类似类型。对于 `BINARY` 和 `VARBINARY`，它们直接存在于
    `types.BINARY`、`types.VARBINARY`，以及 MySQL 和 MS-SQL 方言中。'
- en: '`PickleType` now uses == for comparison of values when mutable=True, unless
    the “comparator” argument with a comparison function is specified to the type.
    If you are pickling a custom object you should implement an `__eq__()` method
    so that value-based comparisons are accurate.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `PickleType` 的 mutable=True 时，现在使用 == 进行值比较，除非为该类型指定了带有比较函数的 “comparator”
    参数。如果要对自定义对象进行 pickle，应实现一个 `__eq__()` 方法，以确保基于值的比较准确。
- en: The default “precision” and “scale” arguments of Numeric and Float have been
    removed and now default to None. NUMERIC and FLOAT will be rendered with no numeric
    arguments by default unless these values are provided.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numeric 和 Float 的默认“precision” 和 “scale” 参数已被移除，现在默认为 None。NUMERIC 和 FLOAT 现在默认不带任何数字参数呈现，除非提供这些值。
- en: DATE, TIME and DATETIME types on SQLite can now take optional “storage_format”
    and “regexp” argument. “storage_format” can be used to store those types using
    a custom string format. “regexp” allows to use a custom regular expression to
    match string values from the database.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 DATE、TIME 和 DATETIME 类型现在可以使用可选的 “storage_format” 和 “regexp” 参数。“storage_format”
    可以用于使用自定义字符串格式存储这些类型。“regexp” 允许使用自定义正则表达式来匹配数据库中的字符串值。
- en: '`__legacy_microseconds__` on SQLite `Time` and `DateTime` types is not supported
    anymore. You should use the new “storage_format” argument instead.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQLite 的 `Time` 和 `DateTime` 类型上不再支持 `__legacy_microseconds__`。您应该使用新的“storage_format”参数。
- en: '`DateTime` types on SQLite now use by a default a stricter regular expression
    to match strings from the database. Use the new “regexp” argument if you are using
    data stored in a legacy format.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 上的 `DateTime` 类型现在默认使用更严格的正则表达式来匹配来自数据库的字符串。如果使用存储在传统格式中的数据，则使用新的“regexp”参数。
- en: ORM Changes
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM 更改
- en: Upgrading an ORM application from 0.5 to 0.6 should require little to no changes,
    as the ORM’s behavior remains almost identical. There are some default argument
    and name changes, and some loading behaviors have been improved.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ORM 应用程序从 0.5 升级到 0.6 应该几乎不需要任何更改，因为 ORM 的行为几乎保持不变。有一些默认参数和名称更改，以及一些加载行为已经得到改进。
- en: New Unit of Work
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的工作单元
- en: The internals for the unit of work, primarily `topological.py` and `unitofwork.py`,
    have been completely rewritten and are vastly simplified. This should have no
    impact on usage, as all existing behavior during flush has been maintained exactly
    (or at least, as far as it is exercised by our testsuite and the handful of production
    environments which have tested it heavily). The performance of flush() now uses
    20-30% fewer method calls and should also use less memory. The intent and flow
    of the source code should now be reasonably easy to follow, and the architecture
    of the flush is fairly open-ended at this point, creating room for potential new
    areas of sophistication. The flush process no longer has any reliance on recursion
    so flush plans of arbitrary size and complexity can be flushed. Additionally,
    the mapper’s “save” process, which issues INSERT and UPDATE statements, now caches
    the “compiled” form of the two statements so that callcounts are further dramatically
    reduced with very large flushes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元的内部，主要是 `topological.py` 和 `unitofwork.py`，已完全重写并大大简化。这不应对使用产生任何影响，因为所有现有的刷新行为都已完全保持不变（或者至少在我们的测试套件和少数经过大量测试的生产环境中被使用）。刷新()
    的性能现在使用 20-30% 更少的方法调用，并且还应该使用更少的内存。源代码的意图和流程现在应该相当容易理解，刷新的架构在这一点上相当开放，为潜在的新领域提供了空间。刷新过程不再依赖递归，因此可以刷新任意大小和复杂度的刷新计划。此外，映射器的“保存”过程，发出
    INSERT 和 UPDATE 语句，现在缓存了这两个语句的“编译”形式，因此在非常大的刷新中进一步大幅减少了调用次数。
- en: Any changes in behavior observed with flush versus earlier versions of 0.6 or
    0.5 should be reported to us ASAP - we’ll make sure no functionality is lost.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 与 0.6 或 0.5 早期版本相比，刷新的任何行为变化都应尽快向我们报告 - 我们将确保不会丢失任何功能。
- en: Changes to `query.update()` and `query.delete()`
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 `query.update()` 和 `query.delete()` 的更改
- en: the ‘expire’ option on query.update() has been renamed to ‘fetch’, thus matching
    that of query.delete()
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询.update() 上的 ‘expire’ 选项已更名为 ‘fetch’，与 query.delete() 的匹配方式相同。
- en: '`query.update()` and `query.delete()` both default to ‘evaluate’ for the synchronize
    strategy.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.update()` 和 `query.delete()` 的同步策略默认为 ‘evaluate’。'
- en: the ‘synchronize’ strategy for update() and delete() raises an error on failure.
    There is no implicit fallback onto “fetch”. Failure of evaluation is based on
    the structure of criteria, so success/failure is deterministic based on code structure.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: update() 和 delete() 的 ‘synchronize’ 策略在失败时会引发错误。没有隐式回退到 “fetch”。评估的失败基于条件的结构，因此成功/失败是基于代码结构的确定性的。
- en: '`relation()` is officially named `relationship()`'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`relation()` 现在正式更名为 `relationship()`'
- en: This to solve the long running issue that “relation” means a “table or derived
    table” in relational algebra terms. The `relation()` name, which is less typing,
    will hang around for the foreseeable future so this change should be entirely
    painless.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了解决长期存在的问题，“relation”在关系代数术语中意味着“表或派生表”。`relation()`名称，输入较少，将会持续存在可预见的未来，因此此更改应完全无痛。
- en: Subquery eager loading
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子查询急切加载
- en: A new kind of eager loading is added called “subquery” loading. This is a load
    that emits a second SQL query immediately after the first which loads full collections
    for all the parents in the first query, joining upwards to the parent using INNER
    JOIN. Subquery loading is used similarly to the current joined-eager loading,
    using the ``subqueryload()[PRE81]subqueryload_all()[PRE82]lazy='subquery'[PRE83]relationship()``.
    The subquery load is usually much more efficient for loading many larger collections
    as it uses INNER JOIN unconditionally and also doesn’t re-load parent rows.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种称为“子查询”加载的新型急切加载。这是一种在第一个SQL查询之后立即发出第二个SQL查询的加载，该查询为第一个查询中的所有父项加载完整集合，使用INNER
    JOIN向上连接到父项。子查询加载类似于当前的连接急切加载，使用``subqueryload()[PRE81]subqueryload_all()[PRE82]lazy='subquery'[PRE83]relationship()``。子查询加载通常对加载许多较大的集合更有效，因为它无条件地使用INNER
    JOIN，并且还不会重新加载父行。
- en: '``eagerload()[PRE84]eagerload_all()[PRE85]joinedload()[PRE86]joinedload_all()``'
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``eagerload()[PRE84]eagerload_all()[PRE85]joinedload()[PRE86]joinedload_all()``'
- en: To make room for the new subquery load feature, the existing ``eagerload()[PRE87]eagerload_all()[PRE88]joinedload()[PRE89]joinedload_all()[PRE90]relation()``.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为新的子查询加载功能腾出空间，现有的``eagerload()[PRE87]eagerload_all()[PRE88]joinedload()[PRE89]joinedload_all()[PRE90]relation()``将会改变。
- en: '``lazy=False|None|True|''dynamic''[PRE91]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``lazy=False|None|True|''dynamic''[PRE91]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
- en: Continuing on the theme of loader strategies opened up, the standard keywords
    for the ``lazy[PRE92]relationship()[PRE93]select[PRE94]joined[PRE95]subquery[PRE96]noload[PRE97]dynamic[PRE98]True[PRE99]False[PRE100]None``
    arguments are still accepted with the identical behavior as before.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开放加载器策略的主题，标准关键字``lazy[PRE92]relationship()[PRE93]select[PRE94]joined[PRE95]subquery[PRE96]noload[PRE97]dynamic[PRE98]True[PRE99]False[PRE100]None``参数仍然被接受，行为与以前完全相同。
- en: innerjoin=True on relation, joinedload
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关系、连接加载上的`innerjoin=True`
- en: Joined-eagerly loaded scalars and collections can now be instructed to use INNER
    JOIN instead of OUTER JOIN. On PostgreSQL this is observed to provide a 300-600%
    speedup on some queries. Set this flag for any many-to-one which is on a NOT NULLable
    foreign key, and similarly for any collection where related items are guaranteed
    to exist.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以指示连接急切加载的标量和集合使用INNER JOIN而不是OUTER JOIN。在PostgreSQL上，观察到这可以在某些查询中提供300-600%的加速。为任何在NOT
    NULLable外键上的多对一关系设置此标志，类似地，为任何保证存在相关项的集合设置此标志。
- en: 'At mapper level:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射器级别：
- en: '[PRE101]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'At query time level:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询时级别：
- en: '[PRE102]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `innerjoin=True` flag at the `relationship()` level will also take effect
    for any `joinedload()` option which does not override the value.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在`relationship()`级别使用`innerjoin=True`标志也将影响任何不覆盖该值的`joinedload()`选项。
- en: Many-to-one Enhancements
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对一增强
- en: many-to-one relations now fire off a lazyload in fewer cases, including in most
    cases will not fetch the “old” value when a new one is replaced.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一关系现在在更少的情况下会触发惰性加载，包括在大多数情况下当新值替换旧值时不会获取“旧”值。
- en: many-to-one relation to a joined-table subclass now uses get() for a simple
    load (known as the “use_get” condition), i.e. `Related`->``Sub(Base)``, without
    the need to redefine the primaryjoin condition in terms of the base table. [ticket:1186]
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与连接表子类的多对一关系现在使用`get()`进行简单加载（称为“use_get”条件），即`Related`->``Sub(Base)``，无需重新定义基表的主连接条件。[ticket:1186]
- en: specifying a foreign key with a declarative column, i.e. `ForeignKey(MyRelatedClass.id)`
    doesn’t break the “use_get” condition from taking place [ticket:1492]
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明性列指定外键，即`ForeignKey(MyRelatedClass.id)`不会破坏“use_get”条件的发生。[ticket:1492]
- en: relationship(), joinedload(), and joinedload_all() now feature an option called
    “innerjoin”. Specify `True` or `False` to control whether an eager join is constructed
    as an INNER or OUTER join. Default is `False` as always. The mapper options will
    override whichever setting is specified on relationship(). Should generally be
    set for many-to-one, not nullable foreign key relations to allow improved join
    performance. [ticket:1544]
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: relationship()、joinedload() 和 joinedload_all() 现在具有一个名为“innerjoin”的选项。指定 `True`
    或 `False` 来控制急切连接是构造为 INNER 还是 OUTER 连接。默认始终为 `False`。映射器选项将覆盖 relationship()
    上指定的任何设置。通常应该为一对多、非空外键关系设置此选项，以允许改进的连接性能。[ticket:1544]
- en: the behavior of joined eager loading such that the main query is wrapped in
    a subquery when LIMIT/OFFSET are present now makes an exception for the case when
    all eager loads are many-to-one joins. In those cases, the eager joins are against
    the parent table directly along with the limit/offset without the extra overhead
    of a subquery, since a many-to-one join does not add rows to the result.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联接急切加载的行为，当存在 LIMIT/OFFSET 时，使主查询包装在子查询中的情况现在除了所有急切加载都是一对多连接时有一个例外。在这些情况下，急切连接直接针对父表，同时限制/偏移量没有子查询的额外开销，因为一对多连接不会将行添加到结果中。
- en: 'For example, in 0.5 this query:'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在 0.5 版本中这个查询：
- en: '[PRE103]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'would produce SQL like:'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将生成如下SQL语句：
- en: '[PRE104]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This because the presence of any eager loaders suggests that some or all of
    them may relate to multi-row collections, which would necessitate wrapping any
    kind of rowcount-sensitive modifiers like LIMIT inside of a subquery.
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为任何急切的加载程序的存在都表明它们中的一部分或全部可能与多行集合相关，这将需要将任何种类的行数敏感修改器，如 LIMIT，包装在子查询中。
- en: 'In 0.6, that logic is more sensitive and can detect if all eager loaders represent
    many-to-ones, in which case the eager joins don’t affect the rowcount:'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 0.6 版本中，该逻辑更加敏感，并且可以检测到所有急切加载是否表示一对多关系，在这种情况下，急切连接不会影响行数：
- en: '[PRE105]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Mutable Primary Keys with Joined Table Inheritance
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有联接表继承的可变主键
- en: A joined table inheritance config where the child table has a PK that foreign
    keys to the parent PK can now be updated on a CASCADE-capable database like PostgreSQL.
    `mapper()` now has an option `passive_updates=True` which indicates this foreign
    key is updated automatically. If on a non-cascading database like SQLite or MySQL/MyISAM,
    set this flag to `False`. A future feature enhancement will try to get this flag
    to be auto-configuring based on dialect/table style in use.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有子表主键外键到父表主键的联接表继承配置上，现在可以在类似于 PostgreSQL 的具有级联功能的数据库上更新子表。`mapper()` 现在有一个选项
    `passive_updates=True`，表示此外键将自动更新。如果在不支持级联的数据库上，如 SQLite 或 MySQL/MyISAM，则将此标志设置为
    `False`。将来的功能增强将尝试根据正在使用的方言/表样式来自动配置此标志。
- en: Beaker Caching
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Beaker 缓存
- en: A promising new example of Beaker integration is in `examples/beaker_caching`.
    This is a straightforward recipe which applies a Beaker cache within the result-
    generation engine of `Query`. Cache parameters are provided via `query.options()`,
    and allows full control over the contents of the cache. SQLAlchemy 0.6 includes
    improvements to the `Session.merge()` method to support this and similar recipes,
    as well as to provide significantly improved performance in most scenarios.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Beaker 集成的一个有前途的新示例在 `examples/beaker_caching` 中。这是一个简单的示例，它在 `Query` 的结果生成引擎中应用了
    Beaker 缓存。缓存参数通过 `query.options()` 提供，并允许完全控制缓存内容。SQLAlchemy 0.6 对 `Session.merge()`
    方法进行了改进，以支持此类示例，并在大多数情况下提供了显著改进的性能。
- en: Other Changes
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他更改
- en: the “row tuple” object returned by `Query` when multiple column/entities are
    selected is now picklable as well as higher performing.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择多列/实体时，`Query` 返回的“行元组”对象现在可以进行序列化，性能更高。
- en: '`query.join()` has been reworked to provide more consistent behavior and more
    flexibility (includes [ticket:1537])'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.join()` 已重新设计以提供更一致的行为和更灵活的功能（包括 [ticket:1537]）'
- en: '`query.select_from()` accepts multiple clauses to produce multiple comma separated
    entries within the FROM clause. Useful when selecting from multiple-homed join()
    clauses.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.select_from()` 接受多个子句，以在 FROM 子句中生成多个逗号分隔的条目。在从多个 join() 子句中选择时非常有用。'
- en: the “dont_load=True” flag on `Session.merge()` is deprecated and is now “load=False”.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session.merge()` 上的“dont_load=True”标志已弃用，现在为“load=False”。'
- en: added “make_transient()” helper function which transforms a persistent/ detached
    instance into a transient one (i.e. deletes the instance_key and removes from
    any session.) [ticket:1052]
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了“make_transient()”助手函数，它将一个持久化/分离的实例转换为瞬态实例（即删除实例键并从任何会话中删除）。[ticket:1052]
- en: the allow_null_pks flag on mapper() is deprecated and has been renamed to allow_partial_pks.
    It is turned “on” by default. This means that a row which has a non-null value
    for any of its primary key columns will be considered an identity. The need for
    this scenario typically only occurs when mapping to an outer join. When set to
    False, a PK that has NULLs in it will not be considered a primary key - in particular
    this means a result row will come back as None (or not be filled into a collection),
    and new in 0.6 also indicates that session.merge() won’t issue a round trip to
    the database for such a PK value. [ticket:1680]
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在mapper()上的allow_null_pks标志已弃用，并已更名为allow_partial_pks。它默认为“on”。这意味着对于任何主键列具有非空值的行都将被视为标识。这种情况的需要通常仅在映射到外连接时发生。当设置为False时，具有NULL的PK将不被视为主键
    - 特别是这意味着结果行将返回为None（或不填入集合中），并且新的0.6版本还表示session.merge()不会为此类PK值向数据库发出往返传输。【票号：1680】
- en: the mechanics of “backref” have been fully merged into the finer grained “back_populates”
    system, and take place entirely within the `_generate_backref()` method of `RelationProperty`.
    This makes the initialization procedure of `RelationProperty` simpler and allows
    easier propagation of settings (such as from subclasses of `RelationProperty`)
    into the reverse reference. The internal `BackRef()` is gone and `backref()` returns
    a plain tuple that is understood by `RelationProperty`.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “backref”的机制已完全合并到更精细的“back_populates”系统中，并完全在`RelationProperty`的`_generate_backref()`方法中进行。这使得`RelationProperty`的初始化过程更简单，并允许更轻松地传播设置（例如从`RelationProperty`的子类）。内部的`BackRef()`已经消失，`backref()`返回一个纯元组，`RelationProperty`理解这个元组。
- en: the keys attribute of `ResultProxy` is now a method, so references to it (`result.keys`)
    must be changed to method invocations (`result.keys()`)
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy`的keys属性现在是一个方法，因此对它的引用（`result.keys`）必须改为方法调用（`result.keys()`）'
- en: '`ResultProxy.last_inserted_ids` is now deprecated, use `ResultProxy.inserted_primary_key`
    instead.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy.last_inserted_ids`现已弃用，请改用`ResultProxy.inserted_primary_key`。'
- en: Deprecated/Removed ORM Elements
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已弃用/移除的ORM元素
- en: Most elements that were deprecated throughout 0.5 and raised deprecation warnings
    have been removed (with a few exceptions). All elements that were marked “pending
    deprecation” are now deprecated and will raise a warning upon use.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在0.5版本中已弃用并引发弃用警告的元素已移除（有几个例外）。所有标记为“待弃用”的元素现在已弃用，并将在使用时引发警告。
- en: ‘transactional’ flag on sessionmaker() and others is removed. Use ‘autocommit=True’
    to indicate ‘transactional=False’.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘transactional’标志在sessionmaker()和其他函数中已移除。使用‘autocommit=True’表示‘transactional=False’。
- en: ‘polymorphic_fetch’ argument on mapper() is removed. Loading can be controlled
    using the ‘with_polymorphic’ option.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在mapper()上的‘polymorphic_fetch’参数已移除。加载可以使用‘with_polymorphic’选项来控制。
- en: ‘select_table’ argument on mapper() is removed. Use ‘with_polymorphic=(“*”,
    <some selectable>)’ for this functionality.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在mapper()上的‘select_table’参数已移除。为了实现此功能，请使用‘with_polymorphic=(“*”, <some selectable>)’。
- en: ‘proxy’ argument on synonym() is removed. This flag did nothing throughout 0.5,
    as the “proxy generation” behavior is now automatic.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在synonym()上的‘proxy’参数已移除。此标志在0.5版本中未起作用，因为“proxy generation”行为现在是自动的。
- en: Passing a single list of elements to joinedload(), joinedload_all(), contains_eager(),
    lazyload(), defer(), and undefer() instead of multiple positional *args is deprecated.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对joinedload()、joinedload_all()、contains_eager()、lazyload()、defer()和undefer()传递单个元素列表而不是多个位置参数的做法已弃用。
- en: Passing a single list of elements to query.order_by(), query.group_by(), query.join(),
    or query.outerjoin() instead of multiple positional *args is deprecated.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对query.order_by()、query.group_by()、query.join()或query.outerjoin()传递单个元素列表而不是多个位置参数的做法已弃用。
- en: '`query.iterate_instances()` is removed. Use `query.instances()`.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.iterate_instances()`已移除。使用`query.instances()`。'
- en: '`Query.query_from_parent()` is removed. Use the sqlalchemy.orm.with_parent()
    function to produce a “parent” clause, or alternatively `query.with_parent()`.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query.query_from_parent()`已移除。使用sqlalchemy.orm.with_parent()函数生成一个“parent”子句，或者使用`query.with_parent()`。'
- en: '`query._from_self()` is removed, use `query.from_self()` instead.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query._from_self()`已移除，请改用`query.from_self()`。'
- en: the “comparator” argument to composite() is removed. Use “comparator_factory”.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对composite()的“comparator”参数已移除。使用“comparator_factory”。
- en: '`RelationProperty._get_join()` is removed.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelationProperty._get_join()`已移除。'
- en: the ‘echo_uow’ flag on Session is removed. Use logging on the “sqlalchemy.orm.unitofwork”
    name.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Session上的‘echo_uow’标志已移除。在“sqlalchemy.orm.unitofwork”名称上使用日志记录。
- en: '`session.clear()` is removed. use `session.expunge_all()`.'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.clear()` 已移除。请使用 `session.expunge_all()`。'
- en: '`session.save()`, `session.update()`, `session.save_or_update()` are removed.
    Use `session.add()` and `session.add_all()`.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.save()`、`session.update()` 和 `session.save_or_update()` 已移除。请使用 `session.add()`
    和 `session.add_all()`。'
- en: the “objects” flag on session.flush() remains deprecated.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.flush()` 中的 “objects” 标志仍然被弃用。'
- en: the “dont_load=True” flag on session.merge() is deprecated in favor of “load=False”.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.merge()` 中的 “dont_load=True” 标志已弃用，改为使用 “load=False”。'
- en: '`ScopedSession.mapper` remains deprecated. See the usage recipe at [https://www.sqlalchemy.org/trac/wiki/Usag](https://www.sqlalchemy.org/trac/wiki/Usag)
    eRecipes/SessionAwareMapper'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper` 仍然被弃用。请参阅[https://www.sqlalchemy.org/trac/wiki/Usag](https://www.sqlalchemy.org/trac/wiki/Usag)
    eRecipes/SessionAwareMapper 上的使用配方。'
- en: passing an `InstanceState` (internal SQLAlchemy state object) to `attributes.init_collection()`
    or `attributes.get_history()` is deprecated. These functions are public API and
    normally expect a regular mapped object instance.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `InstanceState`（内部 SQLAlchemy 状态对象）传递给 `attributes.init_collection()` 或 `attributes.get_history()`
    已被弃用。这些函数是公共 API，通常期望一个常规映射对象实例。
- en: the ‘engine’ parameter to `declarative_base()` is removed. Use the ‘bind’ keyword
    argument.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarative_base()` 中的 ‘engine’ 参数已被移除。请使用 ‘bind’ 关键字参数。'
- en: New Unit of Work
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的工作单元
- en: The internals for the unit of work, primarily `topological.py` and `unitofwork.py`,
    have been completely rewritten and are vastly simplified. This should have no
    impact on usage, as all existing behavior during flush has been maintained exactly
    (or at least, as far as it is exercised by our testsuite and the handful of production
    environments which have tested it heavily). The performance of flush() now uses
    20-30% fewer method calls and should also use less memory. The intent and flow
    of the source code should now be reasonably easy to follow, and the architecture
    of the flush is fairly open-ended at this point, creating room for potential new
    areas of sophistication. The flush process no longer has any reliance on recursion
    so flush plans of arbitrary size and complexity can be flushed. Additionally,
    the mapper’s “save” process, which issues INSERT and UPDATE statements, now caches
    the “compiled” form of the two statements so that callcounts are further dramatically
    reduced with very large flushes.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元的内部，主要是 `topological.py` 和 `unitofwork.py`，已完全重写并大大简化。这对使用没有影响，因为所有现有的刷新行为都被完全保留了（或者至少在我们的测试套件和少数大量测试的生产环境中被保留了）。刷新（flush）的性能现在使用的方法调用减少了
    20-30%，而且还应该使用更少的内存。源代码的意图和流程现在应该相当容易跟踪，并且刷新的架构在这一点上相当开放，为潜在的新技术领域提供了空间。刷新过程不再依赖于递归，因此可以刷新任意大小和复杂度的刷新计划。此外，映射器的“保存”过程，发出
    INSERT 和 UPDATE 语句，现在缓存了这两个语句的“编译”形式，以便在非常大的刷新中进一步大幅减少调用次数。
- en: Any changes in behavior observed with flush versus earlier versions of 0.6 or
    0.5 should be reported to us ASAP - we’ll make sure no functionality is lost.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 请尽快向我们报告在刷新与 0.6 或 0.5 早期版本之间观察到的任何行为变化——我们将确保不会丢失任何功能。
- en: Changes to `query.update()` and `query.delete()`
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 `query.update()` 和 `query.delete()` 的更改
- en: the ‘expire’ option on query.update() has been renamed to ‘fetch’, thus matching
    that of query.delete()
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.update()` 中的‘expire’选项已更名为‘fetch’，与 `query.delete()` 的命名一致。'
- en: '`query.update()` and `query.delete()` both default to ‘evaluate’ for the synchronize
    strategy.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.update()` 和 `query.delete()` 在同步策略上都默认为 ‘evaluate’。'
- en: the ‘synchronize’ strategy for update() and delete() raises an error on failure.
    There is no implicit fallback onto “fetch”. Failure of evaluation is based on
    the structure of criteria, so success/failure is deterministic based on code structure.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `update()` 和 `delete()` 的 ‘synchronize’ 策略在失败时会引发错误。没有隐式回退到“fetch”。评估的失败是基于条件结构的，因此基于代码结构，成功/失败是可以确定的。
- en: '`relation()` is officially named `relationship()`'
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`relation()` 正式更名为 `relationship()`'
- en: This to solve the long running issue that “relation” means a “table or derived
    table” in relational algebra terms. The `relation()` name, which is less typing,
    will hang around for the foreseeable future so this change should be entirely
    painless.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了解决“relation”在关系代数中表示“表或派生表”的长期问题。`relation()` 这个名字，打字更少，将在可预见的将来继续存在，所以这个变化应该完全没有痛苦。
- en: Subquery eager loading
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子查询的贪婪加载
- en: A new kind of eager loading is added called “subquery” loading. This is a load
    that emits a second SQL query immediately after the first which loads full collections
    for all the parents in the first query, joining upwards to the parent using INNER
    JOIN. Subquery loading is used similarly to the current joined-eager loading,
    using the ``subqueryload()[PRE106]subqueryload_all()[PRE107]lazy='subquery'[PRE108]relationship()``.
    The subquery load is usually much more efficient for loading many larger collections
    as it uses INNER JOIN unconditionally and also doesn’t re-load parent rows.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种名为“subquery”加载的新类型的急切加载。这是一种加载，它在第一个加载完整集合的 SQL 查询之后立即发出第二个 SQL 查询，通过 INNER
    JOIN 连接到第一个查询中的所有父级。子查询加载类似于当前的连接预加载，使用``subqueryload()[PRE106]subqueryload_all()[PRE107]lazy='subquery'[PRE108]relationship()``。子查询加载通常更有效地加载许多较大的集合，因为它无条件地使用
    INNER JOIN，而且也不会重新加载父行。
- en: '``eagerload()[PRE109]eagerload_all()[PRE110]joinedload()[PRE111]joinedload_all()``'
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``eagerload()[PRE109]eagerload_all()[PRE110]joinedload()[PRE111]joinedload_all()``'
- en: To make room for the new subquery load feature, the existing ``eagerload()[PRE112]eagerload_all()[PRE113]joinedload()[PRE114]joinedload_all()[PRE115]relation()``.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为新的子查询加载功能腾出空间，现有的``eagerload()[PRE112]eagerload_all()[PRE113]joinedload()[PRE114]joinedload_all()[PRE115]relation()``。
- en: '``lazy=False|None|True|''dynamic''[PRE116]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '``lazy=False|None|True|''dynamic''[PRE116]lazy=''noload''|''joined''|''subquery''|''select''|''dynamic''``'
- en: Continuing on the theme of loader strategies opened up, the standard keywords
    for the ``lazy[PRE117]relationship()[PRE118]select[PRE119]joined[PRE120]subquery[PRE121]noload[PRE122]dynamic[PRE123]True[PRE124]False[PRE125]None``
    arguments are still accepted with the identical behavior as before.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载器策略开放的主题上继续，``lazy[PRE117]relationship()[PRE118]select[PRE119]joined[PRE120]subquery[PRE121]noload[PRE122]dynamic[PRE123]True[PRE124]False[PRE125]None``
    参数的标准关键字仍然被接受，并具有与以前相同的行为。
- en: innerjoin=True on relation, joinedload
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关系、joinedload 上设置 innerjoin=True
- en: Joined-eagerly loaded scalars and collections can now be instructed to use INNER
    JOIN instead of OUTER JOIN. On PostgreSQL this is observed to provide a 300-600%
    speedup on some queries. Set this flag for any many-to-one which is on a NOT NULLable
    foreign key, and similarly for any collection where related items are guaranteed
    to exist.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以指示使用INNER JOIN而不是OUTER JOIN来连接预加载的标量和集合。在 PostgreSQL 上，这被观察到可以为某些查询提供 300-600%
    的速度提升。为任何在 NOT NULLable 外键上的多对一设置此标志，以及对于任何保证存在相关项目的集合。
- en: 'At mapper level:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射器级别：
- en: '[PRE126]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'At query time level:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询时间级别：
- en: '[PRE127]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `innerjoin=True` flag at the `relationship()` level will also take effect
    for any `joinedload()` option which does not override the value.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `relationship()` 级别的 `innerjoin=True` 标志也将对任何不覆盖该值的 `joinedload()` 选项产生影响。
- en: Many-to-one Enhancements
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对许多对一的增强
- en: many-to-one relations now fire off a lazyload in fewer cases, including in most
    cases will not fetch the “old” value when a new one is replaced.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多对一关系现在在更少的情况下会触发延迟加载，包括在大多数情况下不会在替换新值时获取“旧”值。
- en: many-to-one relation to a joined-table subclass now uses get() for a simple
    load (known as the “use_get” condition), i.e. `Related`->``Sub(Base)``, without
    the need to redefine the primaryjoin condition in terms of the base table. [ticket:1186]
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于连接表子类的多对一关系现在使用 get() 进行简单加载（称为“use_get”条件），即 `Related`->``Sub(Base)``, 无需重新定义基表的主连接条件。[ticket:1186]
- en: specifying a foreign key with a declarative column, i.e. `ForeignKey(MyRelatedClass.id)`
    doesn’t break the “use_get” condition from taking place [ticket:1492]
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定具有声明列的外键，即 `ForeignKey(MyRelatedClass.id)` 不会阻止“use_get”条件的发生 [ticket:1492]
- en: relationship(), joinedload(), and joinedload_all() now feature an option called
    “innerjoin”. Specify `True` or `False` to control whether an eager join is constructed
    as an INNER or OUTER join. Default is `False` as always. The mapper options will
    override whichever setting is specified on relationship(). Should generally be
    set for many-to-one, not nullable foreign key relations to allow improved join
    performance. [ticket:1544]
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: relationship()、joinedload() 和 joinedload_all() 现在具有一个名为“innerjoin”的选项。指定 `True`
    或 `False` 来控制是否构建一个 INNER 或 OUTER 连接的急切连接。默认始终为 `False`。映射器选项将覆盖在 relationship()
    上指定的任何设置。通常应为多对一、非空外键关系设置以允许改进的连接性能。[ticket:1544]
- en: the behavior of joined eager loading such that the main query is wrapped in
    a subquery when LIMIT/OFFSET are present now makes an exception for the case when
    all eager loads are many-to-one joins. In those cases, the eager joins are against
    the parent table directly along with the limit/offset without the extra overhead
    of a subquery, since a many-to-one join does not add rows to the result.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联接急切加载的行为，即当LIMIT/OFFSET存在时，主查询被包装在子查询中，现在对所有急切加载都是多对一联接的情况做了一个例外。在这些情况下，急切连接直接针对父表进行，同时限制/偏移量没有额外的子查询开销，因为多对一连接不会向结果添加行。
- en: 'For example, in 0.5 this query:'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在0.5版本中，这个查询：
- en: '[PRE128]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'would produce SQL like:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会生成类似于以下的SQL：
- en: '[PRE129]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This because the presence of any eager loaders suggests that some or all of
    them may relate to multi-row collections, which would necessitate wrapping any
    kind of rowcount-sensitive modifiers like LIMIT inside of a subquery.
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为任何急切加载器的存在都表明它们中的一些或全部可能与多行集合相关联，这将需要将任何种类的行计数敏感修饰符（如LIMIT）包装在子查询中。
- en: 'In 0.6, that logic is more sensitive and can detect if all eager loaders represent
    many-to-ones, in which case the eager joins don’t affect the rowcount:'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在0.6版本中，该逻辑更加敏感，可以检测到所有急切加载器是否代表多对一关系，如果是这种情况，则急切连接不会影响行数：
- en: '[PRE130]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Mutable Primary Keys with Joined Table Inheritance
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用联接表继承的可变主键
- en: A joined table inheritance config where the child table has a PK that foreign
    keys to the parent PK can now be updated on a CASCADE-capable database like PostgreSQL.
    `mapper()` now has an option `passive_updates=True` which indicates this foreign
    key is updated automatically. If on a non-cascading database like SQLite or MySQL/MyISAM,
    set this flag to `False`. A future feature enhancement will try to get this flag
    to be auto-configuring based on dialect/table style in use.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在子表具有外键到父表主键的联接表继承配置中，现在可以在类似PostgreSQL这样支持级联的数据库上进行更新。`mapper()`现在有一个选项`passive_updates=True`，表示此外键将自动更新。如果在不支持级联的数据库上，如SQLite或MySQL/MyISAM上，将此标志设置为`False`。未来的功能增强将尝试根据使用的方言/表样式自动配置此标志。
- en: Beaker Caching
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Beaker缓存
- en: A promising new example of Beaker integration is in `examples/beaker_caching`.
    This is a straightforward recipe which applies a Beaker cache within the result-
    generation engine of `Query`. Cache parameters are provided via `query.options()`,
    and allows full control over the contents of the cache. SQLAlchemy 0.6 includes
    improvements to the `Session.merge()` method to support this and similar recipes,
    as well as to provide significantly improved performance in most scenarios.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Beaker集成的一个有前途的新例子在`examples/beaker_caching`中。这是一个简单的配方，将Beaker缓存应用于`Query`的结果生成引擎中。缓存参数通过`query.options()`提供，并允许完全控制缓存的内容。SQLAlchemy
    0.6对`Session.merge()`方法进行了改进，以支持这种和类似的配方，并在大多数情况下提供了显著改进的性能。
- en: Other Changes
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他变化
- en: the “row tuple” object returned by `Query` when multiple column/entities are
    selected is now picklable as well as higher performing.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择多列/实体时，`Query`返回的“行元组”对象现在也是可序列化的，并且性能更高。
- en: '`query.join()` has been reworked to provide more consistent behavior and more
    flexibility (includes [ticket:1537])'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.join()`已经重新设计，以提供更一致的行为和更灵活性（包括[ticket:1537]）'
- en: '`query.select_from()` accepts multiple clauses to produce multiple comma separated
    entries within the FROM clause. Useful when selecting from multiple-homed join()
    clauses.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query.select_from()`接受多个子句，以在FROM子句中产生多个逗号分隔的条目。在从多个join()子句中选择时很有用。'
- en: the “dont_load=True” flag on `Session.merge()` is deprecated and is now “load=False”.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session.merge()`上的“dont_load=True”标志已被弃用，现在是“load=False”。'
- en: added “make_transient()” helper function which transforms a persistent/ detached
    instance into a transient one (i.e. deletes the instance_key and removes from
    any session.) [ticket:1052]
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了“make_transient()”辅助函数，将持久/分离实例转换为瞬态实例（即删除实例键并从任何会话中移除。）[ticket:1052]
- en: the allow_null_pks flag on mapper() is deprecated and has been renamed to allow_partial_pks.
    It is turned “on” by default. This means that a row which has a non-null value
    for any of its primary key columns will be considered an identity. The need for
    this scenario typically only occurs when mapping to an outer join. When set to
    False, a PK that has NULLs in it will not be considered a primary key - in particular
    this means a result row will come back as None (or not be filled into a collection),
    and new in 0.6 also indicates that session.merge() won’t issue a round trip to
    the database for such a PK value. [ticket:1680]
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper()`上的`allow_null_pks`标志已被弃用，并已重命名为`allow_partial_pks`。默认情况下已打开。这意味着对于任何主键列中有非空值的行将被视为标识。这种情况通常只在映射到外连接时发生。当设置为False时，具有NULL值的PK将不被视为主键
    - 特别是这意味着结果行将返回为None（或不会填充到集合中），并且在0.6版本中还表示`session.merge()`不会为此类PK值发出往返数据库的请求。[ticket:1680]'
- en: the mechanics of “backref” have been fully merged into the finer grained “back_populates”
    system, and take place entirely within the `_generate_backref()` method of `RelationProperty`.
    This makes the initialization procedure of `RelationProperty` simpler and allows
    easier propagation of settings (such as from subclasses of `RelationProperty`)
    into the reverse reference. The internal `BackRef()` is gone and `backref()` returns
    a plain tuple that is understood by `RelationProperty`.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “backref”的机制已完全合并到更精细的“back_populates”系统中，并完全在`RelationProperty`的`_generate_backref()`方法中进行。这使得`RelationProperty`的初始化过程更简单，并允许更容易地传播设置（例如从`RelationProperty`的子类）到反向引用。内部的`BackRef()`已经消失，`backref()`返回一个被`RelationProperty`理解的普通元组。
- en: the keys attribute of `ResultProxy` is now a method, so references to it (`result.keys`)
    must be changed to method invocations (`result.keys()`)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy`的`keys`属性现在是一个方法，因此对它的引用（`result.keys`）必须更改为方法调用（`result.keys()`）。'
- en: '`ResultProxy.last_inserted_ids` is now deprecated, use `ResultProxy.inserted_primary_key`
    instead.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultProxy.last_inserted_ids`现已弃用，改用`ResultProxy.inserted_primary_key`。'
- en: Deprecated/Removed ORM Elements
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弃用/移除的ORM元素
- en: Most elements that were deprecated throughout 0.5 and raised deprecation warnings
    have been removed (with a few exceptions). All elements that were marked “pending
    deprecation” are now deprecated and will raise a warning upon use.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.5版本中被弃用并引发弃用警告的大多数元素已被移除（有少数例外）。所有标记为“即将弃用”的元素现在已被弃用，并在使用时会引发警告。
- en: ‘transactional’ flag on sessionmaker() and others is removed. Use ‘autocommit=True’
    to indicate ‘transactional=False’.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionmaker()`和其他地方的‘transactional’标志已被移除。使用‘autocommit=True’来表示‘transactional=False’。'
- en: ‘polymorphic_fetch’ argument on mapper() is removed. Loading can be controlled
    using the ‘with_polymorphic’ option.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper()`上的‘polymorphic_fetch’参数已被移除。可以使用‘with_polymorphic’选项来控制加载。'
- en: ‘select_table’ argument on mapper() is removed. Use ‘with_polymorphic=(“*”,
    <some selectable>)’ for this functionality.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper()`上的‘select_table’参数已被移除。使用‘with_polymorphic=(“*”, <some selectable>)’来实现此功能。'
- en: ‘proxy’ argument on synonym() is removed. This flag did nothing throughout 0.5,
    as the “proxy generation” behavior is now automatic.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synonym()`上的‘proxy’参数已被移除。在0.5版本中，此标志没有任何作用，因为“代理生成”行为现在是自动的。'
- en: Passing a single list of elements to joinedload(), joinedload_all(), contains_eager(),
    lazyload(), defer(), and undefer() instead of multiple positional *args is deprecated.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素的单个列表传递给`joinedload()`、`joinedload_all()`、`contains_eager()`、`lazyload()`、`defer()`和`undefer()`，而不是多个位置*args，已被弃用。
- en: Passing a single list of elements to query.order_by(), query.group_by(), query.join(),
    or query.outerjoin() instead of multiple positional *args is deprecated.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素的单个列表传递给`query.order_by()`、`query.group_by()`、`query.join()`或`query.outerjoin()`，而不是多个位置*args，已被弃用。
- en: '`query.iterate_instances()` is removed. Use `query.instances()`.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了`query.iterate_instances()`。使用`query.instances()`。
- en: '`Query.query_from_parent()` is removed. Use the sqlalchemy.orm.with_parent()
    function to produce a “parent” clause, or alternatively `query.with_parent()`.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了`Query.query_from_parent()`。使用`sqlalchemy.orm.with_parent()`函数生成“parent”子句，或者使用`query.with_parent()`。
- en: '`query._from_self()` is removed, use `query.from_self()` instead.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了`query._from_self()`，请改用`query.from_self()`。
- en: the “comparator” argument to composite() is removed. Use “comparator_factory”.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`composite()`的“comparator”参数已被移除。使用“comparator_factory”。'
- en: '`RelationProperty._get_join()` is removed.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了`RelationProperty._get_join()`。
- en: the ‘echo_uow’ flag on Session is removed. Use logging on the “sqlalchemy.orm.unitofwork”
    name.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session`上的‘echo_uow’标志已被移除。在“sqlalchemy.orm.unitofwork”名称上使用日志记录。'
- en: '`session.clear()` is removed. use `session.expunge_all()`.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.clear()` 被移除。使用 `session.expunge_all()`。'
- en: '`session.save()`, `session.update()`, `session.save_or_update()` are removed.
    Use `session.add()` and `session.add_all()`.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.save()`、`session.update()`、`session.save_or_update()` 被移除。使用 `session.add()`
    和 `session.add_all()`。'
- en: the “objects” flag on session.flush() remains deprecated.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `session.flush()` 上的 “objects” 标志仍然被弃用。
- en: the “dont_load=True” flag on session.merge() is deprecated in favor of “load=False”.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `session.merge()` 上的 “dont_load=True” 标志已被弃用，改用 “load=False”。
- en: '`ScopedSession.mapper` remains deprecated. See the usage recipe at [https://www.sqlalchemy.org/trac/wiki/Usag](https://www.sqlalchemy.org/trac/wiki/Usag)
    eRecipes/SessionAwareMapper'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper` 仍然被弃用。参见使用方法的示例：[https://www.sqlalchemy.org/trac/wiki/Usag](https://www.sqlalchemy.org/trac/wiki/Usag)
    eRecipes/SessionAwareMapper'
- en: passing an `InstanceState` (internal SQLAlchemy state object) to `attributes.init_collection()`
    or `attributes.get_history()` is deprecated. These functions are public API and
    normally expect a regular mapped object instance.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `attributes.init_collection()` 或 `attributes.get_history()` 中传递 `InstanceState`（内部
    SQLAlchemy 状态对象）已被弃用。这些函数是公共 API，通常期望普通映射对象实例。
- en: the ‘engine’ parameter to `declarative_base()` is removed. Use the ‘bind’ keyword
    argument.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarative_base()` 上的 ‘engine’ 参数已被移除。使用 ‘bind’ 关键字参数。'
- en: Extensions
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: SQLSoup
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup has been modernized and updated to reflect common 0.5/0.6 capabilities,
    including well defined session integration. Please read the new docs at [[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html].
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 已经现代化并更新以反映常见的 0.5/0.6 功能，包括明确定义的会话集成。请阅读新文档：[[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html]。
- en: Declarative
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative
- en: The `DeclarativeMeta` (default metaclass for `declarative_base`) previously
    allowed subclasses to modify `dict_` to add class attributes (e.g. columns). This
    no longer works, the `DeclarativeMeta` constructor now ignores `dict_`. Instead,
    the class attributes should be assigned directly, e.g. `cls.id=Column(...)`, or
    the [MixIn class](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    approach should be used instead of the metaclass approach.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeclarativeMeta`（`declarative_base` 的默认元类）以前允许子类修改 `dict_` 来添加类属性（例如列）。这种方式已不再起作用，`DeclarativeMeta`
    构造函数现在忽略 `dict_`。相反，类属性应直接赋值，例如 `cls.id=Column(...)`，或者应该使用 [MixIn 类](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    方法而不是元类方法。'
- en: SQLSoup
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup has been modernized and updated to reflect common 0.5/0.6 capabilities,
    including well defined session integration. Please read the new docs at [[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html].
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 已经现代化并更新以反映常见的 0.5/0.6 功能，包括明确定义的会话集成。请阅读新文档：[[https://www.sqlalc](https://www.sqlalc)
    hemy.org/docs/06/reference/ext/sqlsoup.html]。
- en: Declarative
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative
- en: The `DeclarativeMeta` (default metaclass for `declarative_base`) previously
    allowed subclasses to modify `dict_` to add class attributes (e.g. columns). This
    no longer works, the `DeclarativeMeta` constructor now ignores `dict_`. Instead,
    the class attributes should be assigned directly, e.g. `cls.id=Column(...)`, or
    the [MixIn class](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    approach should be used instead of the metaclass approach.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeclarativeMeta`（`declarative_base` 的默认元类）以前允许子类修改 `dict_` 来添加类属性（例如列）。这种方式已不再起作用，`DeclarativeMeta`
    构造函数现在忽略 `dict_`。相反，类属性应直接赋值，例如 `cls.id=Column(...)`，或者应该使用 [MixIn 类](https://www.sqlalchemy.org/docs/reference/ext/declarative.html#mix-in-classes)
    方法而不是元类方法。'
