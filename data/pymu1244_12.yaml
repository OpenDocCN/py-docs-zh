- en: Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/recipes-images.html](https://pymupdf.readthedocs.io/en/latest/recipes-images.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pymupdf.readthedocs.io/en/latest/recipes-images.html](https://pymupdf.readthedocs.io/en/latest/recipes-images.html)
- en: '## How to Make Images from Document Pages'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何从文档页面创建图像'
- en: This little script will take a document filename and generate a PNG file from
    each of its pages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小脚本将获取一个文档文件名并生成每页的 PNG 文件。
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以是任何 [支持的类型](how-to-open-a-file.html#supported-file-types)。
- en: 'The script works as a command line tool which expects the filename being supplied
    as a parameter. The generated image files (1 per page) are stored in the directory
    of the script:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本作为一个命令行工具运行，需要将文件名作为参数提供。生成的图像文件（每页一个）存储在脚本所在的目录中：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script directory will now contain PNG image files named *page-0.png*, *page-1.png*,
    etc. Pictures have the dimension of their pages with width and height rounded
    to integers, e.g. 595 x 842 pixels for an A4 portrait sized page. They will have
    a resolution of 96 dpi in x and y dimension and have no transparency. You can
    change all that – for how to do this, read the next sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本目录现在将包含名为 *page-0.png*、*page-1.png* 等的 PNG 图像文件。图片的尺寸是其页面的宽度和高度取整，例如 A4 纵向页面的尺寸为
    595 x 842 像素。它们的 x 和 y 维度分辨率为 96 dpi，并且没有透明度。您可以更改所有这些内容 - 要了解如何执行此操作，请阅读以下各节。
- en: '* * *  ## How to Increase Image Resolution'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何增加图像分辨率'
- en: The image of a document page is represented by a [Pixmap](pixmap.html#pixmap),
    and the simplest way to create a pixmap is via method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 文档页面的图像由一个 [Pixmap](pixmap.html#pixmap) 表示，创建 Pixmap 的最简单方法是通过方法 [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap")。
- en: This method has many options to influence the result. The most important among
    them is the [Matrix](matrix.html#matrix), which lets you zoom, rotate, distort
    or mirror the outcome.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有许多选项可以影响结果。其中最重要的是 [Matrix](matrix.html#matrix)，它允许您缩放、旋转、扭曲或镜像结果。
- en: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") by default
    will use the [Identity](identity.html#identity) matrix, which does nothing.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") 默认将使用 [Identity](identity.html#identity)
    矩阵，不起任何作用。'
- en: 'In the following, we apply a zoom factor of 2 to each dimension, which will
    generate an image with a four times better resolution for us (and also about 4
    times the size):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们对每个维度应用了 2 倍的缩放因子，这将为我们生成一个四倍更好分辨率的图像（并且大约增加了 4 倍的大小）：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since version 1.19.2 there is a more direct way to set the resolution: Parameter
    `"dpi"` (dots per inch) can be used in place of `"matrix"`. To create a 300 dpi
    image of a page specify `pix = page.get_pixmap(dpi=300)`. Apart from notation
    brevity, this approach has the additional advantage that the **dpi value is saved
    with the image** file – which does not happen automatically when using the Matrix
    notation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从版本 1.19.2 开始，有一种更直接的设置分辨率的方法：可以使用参数 `"dpi"`（每英寸点数）代替 `"matrix"`。要创建一个 300
    dpi 分辨率的页面图像，请指定 `pix = page.get_pixmap(dpi=300)`。除了简洁的标记法之外，这种方法的额外优势在于 **dpi
    值保存在图像文件中**，而在使用矩阵标记时不会自动发生这种情况。
- en: '* * *  ## How to Create Partial Pixmaps (Clips)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何创建部分图像（剪辑）'
- en: You do not always need or want the full image of a page. This is the case e.g.
    when you display the image in a GUI and would like to fill the respective window
    with a zoomed part of the page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是需要或希望获取页面的完整图像。例如，在您将图像显示在 GUI 中并希望填充页面的缩放部分时，就是这种情况。
- en: Let’s assume your GUI window has room to display a full document page, but you
    now want to fill this room with the bottom right quarter of your page, thus using
    a four times better resolution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的 GUI 窗口可以显示完整的文档页面，但现在您希望将页面的右下角四分之一填充到这个区域，从而使用四倍更好的分辨率。
- en: To achieve this, define a rectangle equal to the area you want to appear in
    the GUI and call it “clip”. One way of constructing rectangles in PyMuPDF is by
    providing two diagonally opposite corners, which is what we are doing here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请定义一个与 GUI 中要显示的区域相等的矩形并称其为“clip”。在 PyMuPDF 中构造矩形的一种方法是提供两个对角相对的角，这就是我们在这里做的。
- en: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the above we construct *clip* by specifying two diagonally opposite points:
    the middle point *mp* of the page rectangle, and its bottom right, *rect.br*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述过程中，我们通过指定两个对角点构造*clip*：页面矩形的中点*mp*和其右下角*rect.br*。
- en: '* * *  ## How to Zoom a Clip to a GUI Window'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何将剪辑缩放到GUI窗口'
- en: Please also read the previous section. This time we want to **compute the zoom
    factor** for a clip, such that its image best fits a given GUI window. This means,
    that the image’s width or height (or both) will equal the window dimension. For
    the following code snippet you need to provide the WIDTH and HEIGHT of your GUI’s
    window that should receive the page’s clip rectangle.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请还要阅读前面的部分。这次我们想要计算一个剪辑的缩放因子，使其图像最适合给定的GUI窗口。这意味着图像的宽度或高度（或两者）将等于窗口尺寸。对于下面的代码段，您需要提供GUI窗口的WIDTH和HEIGHT，以接收页面的剪辑矩形。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the other way round, now assume you **have** the zoom factor and need to
    **compute the fitting clip**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一种方式，现在假设你**有**缩放因子，并且需要**计算适合的剪辑**。
- en: 'In this case we have `zoom = HEIGHT/clip.height = WIDTH/clip.width`, so we
    must set `clip.height = HEIGHT/zoom` and, `clip.width = WIDTH/zoom`. Choose the
    top-left point [`tl`](irect.html#IRect.tl "IRect.tl") of the clip on the page
    to compute the right pixmap:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有`zoom = HEIGHT/clip.height = WIDTH/clip.width`，因此我们必须设置`clip.height
    = HEIGHT/zoom`和`clip.width = WIDTH/zoom`。选择页面上剪辑的左上点[`tl`](irect.html#IRect.tl
    "IRect.tl")来计算正确的像素图：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '* * *  ## How to Create or Suppress Annotation Images'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何创建或禁止注释图像'
- en: Normally, the pixmap of a page also shows the page’s annotations. Occasionally,
    this may not be desirable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，页面的像素图还显示页面的注释。偶尔，这可能不是理想的。
- en: To suppress the annotation images on a rendered page, just specify `annots=False`
    in [`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染页面上禁止注释图像，只需在[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap")中指定`annots=False`。
- en: 'You can also render annotations separately: they have their own [`Annot.get_pixmap()`](annot.html#Annot.get_pixmap
    "Annot.get_pixmap") method. The resulting pixmap has the same dimensions as the
    annotation rectangle.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以单独渲染注释：它们有自己的[`Annot.get_pixmap()`](annot.html#Annot.get_pixmap "Annot.get_pixmap")方法。生成的像素图的尺寸与注释矩形相同。
- en: '* * *  ## How to Extract Images: Non-PDF Documents'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何提取图像：非PDF文档'
- en: In contrast to the previous sections, this section deals with **extracting**
    images **contained** in documents, so they can be displayed as part of one or
    more pages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的部分相比，本节处理从文档中**提取**包含的图像，以便它们可以作为一个或多个页面的一部分显示。
- en: 'If you want to recreate the original image in file form or as a memory area,
    you have basically two options:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将原始图像重新创建为文件形式或内存区域，基本上有两个选择：
- en: 'Convert your document to a PDF, and then use one of the PDF-only extraction
    methods. This snippet will convert a document to PDF:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文档转换为PDF，然后使用PDF-only提取方法之一。此片段将文档转换为PDF：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use [`Page.get_text()`](page.html#Page.get_text "Page.get_text") with the “dict”
    parameter. This works for all document types. It will extract all text and images
    shown on the page, formatted as a Python dictionary. Every image will occur in
    an image block, containing meta information and **the binary image data**. For
    details of the dictionary’s structure, see [TextPage](textpage.html#textpage).
    The method works equally well for PDF files. This creates a list of all images
    shown on a page:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有“dict”参数的[`Page.get_text()`](page.html#Page.get_text "Page.get_text")。这适用于所有文档类型。它将提取页面上显示的所有文本和图像，格式化为Python字典。每个图像将出现在一个图像块中，包含元信息和**二进制图像数据**。有关字典结构的详细信息，请参阅[TextPage](textpage.html#textpage)。该方法同样适用于PDF文件。这将创建一个显示在页面上所有图像的列表：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '* * *  ## How to Extract Images: PDF Documents'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何提取图像：PDF文档'
- en: 'Like any other “object” in a PDF, images are identified by a cross reference
    number ([`xref`](glossary.html#xref "xref"), an integer). If you know this number,
    you have two ways to access the image’s data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像PDF中的任何其他“对象”一样，图像由交叉引用号（[`xref`](glossary.html#xref "xref")，一个整数）标识。如果你知道这个号码，你有两种方式访问图像的数据：
- en: '**Create** a [Pixmap](pixmap.html#pixmap) of the image with instruction *pix
    = pymupdf.Pixmap(doc, xref)*. This method is **very** fast (single digit micro-seconds).
    The pixmap’s properties (width, height, …) will reflect the ones of the image.
    In this case there is no way to tell which image format the embedded original
    has.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令*pix = pymupdf.Pixmap(doc, xref)*创建[Pixmap](pixmap.html#pixmap)图像。此方法**非常**快（单个数字微秒）。像素图的属性（宽度、高度等）将反映图像的属性。在这种情况下，无法确定嵌入原始图像的格式。
- en: '**Extract** the image with *img = doc.extract_image(xref)*. This is a dictionary
    containing the binary image data as *img[“image”]*. A number of meta data are
    also provided – mostly the same as you would find in the pixmap of the image.
    The major difference is string *img[“ext”]*, which specifies the image format:
    apart from “png”, strings like “jpeg”, “bmp”, “tiff”, etc. can also occur. Use
    this string as the file extension if you want to store to disk. The execution
    speed of this method should be compared to the combined speed of the statements
    *pix = pymupdf.Pixmap(doc, xref);pix.tobytes()*. If the embedded image is in PNG
    format, the speed of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") is about the same (and the binary image data are identical).
    Otherwise, this method is **thousands of times faster**, and the **image data
    is much smaller**.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提取**图像使用*img = doc.extract_image(xref)*。 这是一个包含二进制图像数据的字典，如*img[“image”]*所示。还提供了许多元数据，大多数与图像的像素图中的内容相同。主要区别在于字符串*img[“ext”]*，它指定图像格式：除了“png”外，还可能出现像“jpeg”、“bmp”、“tiff”等。如果要存储到磁盘，请使用此字符串作为文件扩展名。与*pix
    = pymupdf.Pixmap(doc, xref);pix.tobytes()*语句的组合速度相比，此方法的执行速度应该要快。如果嵌入的图像是PNG格式，则[`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image")的速度大致相同（且二进制图像数据相同）。否则，此方法**快几千倍**，而且**图像数据要小得多**。'
- en: 'The question remains: **“How do I know those ‘xref’ numbers of images?”**.
    There are two answers to this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：“**我怎么知道这些‘xref’图像的编号呢？**” 这有两个答案：
- en: '**“Inspect the page objects:”** Loop through the items of [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"). It is a list of list, and its items look like *[xref, smask,
    …]*, containing the [`xref`](glossary.html#xref "xref") of an image. This [`xref`](glossary.html#xref
    "xref") can then be used with one of the above methods. Use this method for **valid
    (undamaged)** documents. Be wary however, that the same image may be referenced
    multiple times (by different pages), so you might want to provide a mechanism
    avoiding multiple extracts.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“检查页面对象：”** 遍历[`Page.get_images()`](page.html#Page.get_images "Page.get_images")的项目。它是一个列表的列表，其项目看起来像*[xref,
    smask, …]*，包含一个图像的[xref](glossary.html#xref "xref")。然后可以使用其中一种以上的方法。对于**有效（未损坏）**的文档，请使用此方法。但请注意，同一图像可能被多个页面引用，因此可能需要提供一个机制以避免多次提取。'
- en: '**“No need to know:”** Loop through the list of **all xrefs** of the document
    and perform a [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") for each one. If the returned dictionary is empty, then
    continue – this [`xref`](glossary.html#xref "xref") is no image. Use this method
    if the PDF is **damaged (unusable pages)**. Note that a PDF often contains “pseudo-images”
    (“stencil masks”) with the special purpose of defining the transparency of some
    other image. You may want to provide logic to exclude those from extraction. Also
    have a look at the next section.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“不需要知道：”** 遍历文档的所有[xrefs](glossary.html#xref "xref")列表，并对每个执行[`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image")。如果返回的字典为空，则继续 – 此[xref](glossary.html#xref "xref")不是图像。如果PDF文件损坏（不可用页面），请使用此方法。请注意，PDF文件通常包含“伪图像”（“模板掩码”），用于定义其他图像的透明度。您可能希望提供逻辑以排除这些内容的提取。还可以查看下一节。'
- en: 'For both extraction approaches, there exist ready-to-use general purpose scripts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种提取方法，都存在可用的通用脚本：
- en: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    extracts images page by page:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    逐页提取图像：'
- en: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
- en: 'and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    extracts images by xref table:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 而[extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)通过xref表提取图像：
- en: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
- en: '* * *  ## How to Handle Image Masks'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何处理图像蒙版'
- en: Some images in PDFs are accompanied by **image masks**. In their simplest form,
    masks represent alpha (transparency) bytes stored as separate images. In order
    to reconstruct the original of an image, which has a mask, it must be “enriched”
    with transparency bytes taken from its mask.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: PDF中的一些图像附带**图像蒙版**。在最简单的形式中，蒙版表示为单独存储的alpha（透明度）字节图像。为了重建具有蒙版的图像的原始图像，必须使用蒙版中的透明度字节对其进行“丰富”。
- en: 'Whether an image does have such a mask can be recognized in one of two ways
    in PyMuPDF:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyMuPDF中，判断图像是否具有蒙版可以通过以下两种方式之一进行识别：
- en: An item of [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") has the general format `(xref, smask, ...)`, where
    *xref* is the image’s [`xref`](glossary.html#xref "xref") and *smask*, if positive,
    then it is the [`xref`](glossary.html#xref "xref") of a mask.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Document.get_page_images()`](document.html#Document.get_page_images "Document.get_page_images")的一项具有一般格式`(xref,
    smask, ...)`, 其中*xref*是图像的[`xref`](glossary.html#xref "xref")，如果*smask*为正，则是蒙版的[`xref`](glossary.html#xref
    "xref")。'
- en: The (dictionary) results of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") have a key *“smask”*, which also contains any mask’s
    [`xref`](glossary.html#xref "xref") if positive.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Document.extract_image()`](document.html#Document.extract_image "Document.extract_image")的结果（字典）具有一个键*“smask”*，该键还包含任何蒙版的[`xref`](glossary.html#xref
    "xref")（如果为正）。'
- en: If *smask == 0* then the image encountered via [`xref`](glossary.html#xref "xref")
    can be processed as it is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*smask == 0*，那么通过[`xref`](glossary.html#xref "xref")遇到的图像可以按原样处理。
- en: 'To recover the original image using PyMuPDF, the procedure depicted as follows
    must be executed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyMuPDF恢复原始图像，必须执行以下所示的过程：
- en: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Step (1) creates a pixmap of the basic image. Step (2) does the same with the
    image mask. Step (3) adds an alpha channel and fills it with transparency information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步创建基本图像的位图。第二步对图像蒙版执行相同操作。第三步添加一个alpha通道并填充透明度信息。
- en: The scripts [extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py),
    and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    above also contain this logic.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)和[extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)也包含此逻辑。
- en: '* * *  ## How to Make one PDF of all your Pictures (or Files)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何制作所有图片（或文件）的一个PDF'
- en: We show here **three scripts** that take a list of (image and other) files and
    put them all in one PDF.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示**三个脚本**，它们接受一个（图像和其他）文件列表，并将它们全部放入一个PDF中。
- en: '**Method 1: Inserting Images as Pages**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 1: 将图像插入为页面**'
- en: 'The first one converts each image to a PDF page with the same dimensions. The
    result will be a PDF with one page per image. It will only work for [supported
    image](how-to-open-a-file.html#supported-file-types) file formats:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法将每个图像转换为具有相同尺寸的PDF页面。结果将是一个PDF，每个图像占一页。它仅适用于[支持的图像](how-to-open-a-file.html#supported-file-types)文件格式：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will generate a PDF only marginally larger than the combined pictures’
    size. Some numbers on performance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个PDF，大小仅比合并的图片总大小略大。一些性能数据：
- en: The above script needed about 1 minute on my machine for 149 pictures with a
    total size of 514 MB (and about the same resulting PDF size).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本在我的机器上对149张总大小为514 MB的图片需要大约1分钟时间（生成的PDF大小大致相同）。
- en: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
- en: 'Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)
    for a more complete source code: it offers a directory selection dialog and skips
    unsupported files and non-file entries.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[这里](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)获取更完整的源代码：它提供了一个目录选择对话框，并跳过不支持的文件和非文件条目。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We might have used [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    instead of [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page"),
    and the result would have been a similar looking file. However, depending on the
    image type, it may store **images uncompressed**. Therefore, the save option *deflate
    = True* must be used to achieve a reasonable file size, which hugely increases
    the runtime for large numbers of images. So this alternative **cannot be recommended**
    here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用[`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")而不是[`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page")来创建一个外观类似的文件。然而，根据图像类型的不同，可能会存储**未压缩的图像**。因此，必须使用保存选项*deflate
    = True*以获得合理的文件大小，这会大大增加处理大量图像的运行时间。因此，在此**不推荐使用**这种替代方法。
- en: '**Method 2: Embedding Files**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法2：嵌入文件**'
- en: 'The second script **embeds** arbitrary files – not only images. The resulting
    PDF will have just one (empty) page, required for technical reasons. To later
    access the embedded files again, you would need a suitable PDF viewer that can
    display and / or extract embedded files:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本**嵌入**任意文件 - 不仅仅是图片。由于技术原因，生成的PDF将只有一页（空白页）。要稍后再次访问嵌入的文件，您需要一个能够显示和/或提取嵌入文件的合适PDF查看器：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
- en: 'This is by far the fastest method, and it also produces the smallest possible
    output file size. The above pictures needed 20 seconds on my machine and yielded
    a PDF size of 510 MB. Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)
    for a more complete source code: it offers a directory selection dialog and skips
    non-file entries.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是最快的方法，同时也能生成最小可能的输出文件大小。上述图片在我的设备上花了20秒，并生成了一个大小为510 MB的PDF文件。查看[这里](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)获取更完整的源代码：它提供了一个目录选择对话框，并跳过非文件条目。
- en: '**Method 3: Attaching Files**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法3：附加文件**'
- en: A third way to achieve this task is **attaching files** via page annotations
    see [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)
    for the complete source code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种完成此任务的方法是通过页面注释**附加文件**，请参见[此处](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)获取完整的源代码。
- en: This has a similar performance as the previous script and it also produces a
    similar file size. It will produce PDF pages which show a ‘FileAttachment’ icon
    for each attached file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一个脚本具有类似的性能，并且还会产生类似的文件大小。它将为每个附加文件生成显示“文件附件”图标的PDF页面。
- en: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both, the **embed** and the **attach** methods can be used for **arbitrary files**
    – not just images.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入**和**附加**方法都可以用于**任意文件** - 不只是图片。'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We strongly recommend using the awesome package [PySimpleGUI](https://pypi.org/project/PySimpleGUI/)
    to display a progress meter for tasks that may run for an extended time span.
    It’s pure Python, uses Tkinter (no additional GUI package) and requires just one
    more line of code!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈推荐使用令人惊叹的包[PySimpleGUI](https://pypi.org/project/PySimpleGUI/)来显示任务可能运行时间较长的进度条。它纯粹使用Python，使用Tkinter（无需额外的GUI包），并且只需要增加一行代码！
- en: '* * *  ## How to Create Vector Images'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何创建矢量图像'
- en: The usual way to create an image from a document page is [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap"). A pixmap represents a raster image, so you must decide on
    its quality (i.e. resolution) at creation time. It cannot be changed later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文档页面图像的常规方法是[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap")。像素图表示栅格图像，因此您必须在创建时决定其质量（即分辨率）。以后不能更改。
- en: PyMuPDF also offers a way to create a **vector image** of a page in SVG format
    (scalable vector graphics, defined in XML syntax). SVG images remain precise across
    zooming levels (of course with the exception of any raster graphic elements embedded
    therein).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PyMuPDF还提供了一种方法来创建页面的**矢量图像**，以SVG格式（可伸缩矢量图形，以XML语法定义）。SVG图像在缩放级别上保持精确（当然，其中嵌入的任何栅格图形元素除外）。
- en: Instruction *svg = page.get_svg_image(matrix=pymupdf.Identity)* delivers a UTF-8
    string *svg* which can be stored with extension “.svg”.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 *svg = page.get_svg_image(matrix=pymupdf.Identity)* 提供了一个 UTF-8 字符串 *svg*，可以使用扩展名“.svg”存储。
- en: '* * *  ## How to Convert Images'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何转换图像'
- en: Just as a feature among others, PyMuPDF’s image conversion is easy. It may avoid
    using other graphics packages like PIL/Pillow in many cases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个特性，PyMuPDF 的图像转换很简单。在许多情况下，可以避免使用其他图形包如 PIL/Pillow。
- en: Notwithstanding that interfacing with Pillow is almost trivial.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与 Pillow 的交互几乎是微不足道的。
- en: '| **Input Formats** | **Output Formats** | **Description** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **输入格式** | **输出格式** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| BMP | . | Windows Bitmap |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| BMP | . | Windows 位图 |'
- en: '| JPEG | JPEG | Joint Photographic Experts Group |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| JPEG | JPEG | 联合图像专家组 |'
- en: '| JXR | . | JPEG Extended Range |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| JXR | . | JPEG 扩展范围 |'
- en: '| JPX/JP2 | . | JPEG 2000 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| JPX/JP2 | . | JPEG 2000 |'
- en: '| GIF | . | Graphics Interchange Format |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| GIF | . | 图形互换格式 |'
- en: '| TIFF | . | Tagged Image File Format |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| TIFF | . | 标记图像文件格式 |'
- en: '| PNG | PNG | Portable Network Graphics |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| PNG | PNG | 便携网络图形 |'
- en: '| PNM | PNM | Portable Anymap |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| PNM | PNM | 便携任意映射 |'
- en: '| PGM | PGM | Portable Graymap |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| PGM | PGM | 便携灰度图 |'
- en: '| PBM | PBM | Portable Bitmap |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| PBM | PBM | 便携位图 |'
- en: '| PPM | PPM | Portable Pixmap |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| PPM | PPM | 便携像素图 |'
- en: '| PAM | PAM | Portable Arbitrary Map |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| PAM | PAM | 便携任意映射 |'
- en: '| . | PSD | Adobe Photoshop Document |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| . | PSD | Adobe Photoshop 文档 |'
- en: '| . | PS | Adobe Postscript |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| . | PS | Adobe Postscript |'
- en: 'The general scheme is just the following two lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般方案仅为以下两行：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Remarks**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: The **input** argument of *pymupdf.Pixmap(arg)* can be a file or a bytes / io.BytesIO
    object containing an image.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pymupdf.Pixmap(arg)* 的 **input** 参数可以是包含图像的文件或 bytes / io.BytesIO 对象。'
- en: Instead of an output **file**, you can also create a bytes object via *pix.tobytes(“yyy”)*
    and pass this around.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不仅仅可以创建输出 **文件**，还可以通过 *pix.tobytes(“yyy”)* 创建一个 bytes 对象并传递它。
- en: As a matter of course, input and output formats must be compatible in terms
    of colorspace and transparency. The *Pixmap* class has batteries included if adjustments
    are needed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，输入和输出格式在颜色空间和透明度方面必须兼容。如果需要调整，*Pixmap* 类已经内置了电池。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Convert JPEG to Photoshop**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**将 JPEG 转换为 Photoshop**：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Convert **JPEG to Tkinter PhotoImage**. Any **RGB / no-alpha** image works
    exactly the same. Conversion to one of the **Portable Anymap** formats (PPM, PGM,
    etc.) does the trick, because they are supported by all Tkinter versions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **JPEG 转换为 Tkinter 的 PhotoImage**。任何 **RGB / 无 alpha** 图像效果相同。将其转换为一个 **便携任意映射**
    格式（如 PPM、PGM 等）即可，因为所有的 Tkinter 版本都支持它们：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Convert **PNG with alpha** to Tkinter PhotoImage. This requires **removing
    the alpha bytes**, before we can do the PPM conversion:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **带 alpha 通道的 PNG** 转换为 Tkinter 的 PhotoImage，这需要在进行 PPM 转换之前 **移除 alpha 字节**：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '* * *  ## How to Use Pixmaps: Gluing Images'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何使用 Pixmaps: 粘贴图像'
- en: 'This shows how pixmaps can be used for purely graphical, non-document purposes.
    The script reads an image file and creates a new image which consist of 3 * 4
    tiles of the original:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何仅用于图形、非文档目的的 pixmap。脚本读取一个图像文件并创建一个新图像，该图像由原始图像的 3 * 4 个瓦片组成：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the input picture:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输入图片：
- en: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
- en: 'Here is the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
- en: '* * *  ## How to Use Pixmaps: Making a Fractal'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何使用 Pixmaps: 制作分形'
- en: Here is another Pixmap example that creates **Sierpinski’s Carpet** – a fractal
    generalizing the **Cantor Set** to two dimensions. Given a square carpet, mark
    its 9 sub-suqares (3 times 3) and cut out the one in the center. Treat each of
    the remaining eight sub-squares in the same way, and continue *ad infinitum*.
    The end result is a set with area zero and fractal dimension 1.8928…
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个 Pixmap 的示例，创建了 **谢尔宾斯基地毯** —— 一种将 **康托集** 广义化到二维的分形。给定一个正方形地毯，标记其 9 个子方块（3
    * 3），并切掉中心的一个。以相同方式处理每个剩余的八个子方块，并继续 *ad infinitum*。最终结果是一个面积为零且分形维度为 1.8928...
    的集合。
- en: 'This script creates an approximate image of it as a PNG, by going down to one-pixel
    granularity. To increase the image precision, change the value of n (precision):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本以 PNG 的形式创建其近似图像，通过一像素粒度下降。要增加图像精度，改变 n 的值（精度）：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result should look something like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
- en: '* * *  ## How to Interface with NumPy'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何与 NumPy 接口'
- en: 'This shows how to create a PNG file from a numpy array (several times faster
    than most other methods):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何从 NumPy 数组创建 PNG 文件（比大多数其他方法快几倍）：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '* * *  ## How to Add Images to a PDF Page'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *  ## 如何向 PDF 页面添加图像'
- en: 'There are two methods to add images to a PDF page: [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image") and [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Both methods have things in common, but there are also
    differences.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 向 PDF 页面添加图像有两种方法：[`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    和 [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")。这两种方法有共同之处，但也有不同之处。
- en: '| **Criterion** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **标准** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| displayable content | image file, image in memory, pixmap | PDF page |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 可显示内容 | 图像文件，内存中的图像，像素图 | PDF 页面 |'
- en: '| display resolution | image resolution | vectorized (except raster page content)
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 显示分辨率 | 图像分辨率 | 矢量化（除了位图页面内容） |'
- en: '| rotation | 0, 90, 180 or 270 degrees | any angle |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | 0、90、180 或 270 度 | 任意角度 |'
- en: '| clipping | no (full image only) | yes |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 裁剪 | 否（仅完整图像） | 是 |'
- en: '| keep aspect ratio | yes (default option) | yes (default option) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 保持长宽比 | 是（默认选项） | 是（默认选项） |'
- en: '| transparency (water marking) | depends on the image | depends on the page
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 透明度（水印） | 取决于图像 | 取决于页面 |'
- en: '| location / placement | scaled to fit target rectangle | scaled to fit target
    rectangle |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 位置 / 放置 | 缩放以适应目标矩形 | 缩放以适应目标矩形 |'
- en: '| performance | automatic prevention of duplicates; | automatic prevention
    of duplicates; |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 自动防止重复； | 自动防止重复； |'
- en: '| multi-page image support | no | yes |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 多页图像支持 | 否 | 是 |'
- en: '| ease of use | simple, intuitive; | simple, intuitive; **usable for all document
    types** (including images!) after conversion to PDF via [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 使用简便性 | 简单，直观； | 简单，直观； **转换为 PDF 后适用于所有文档类型**（包括图像！）通过 [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
- en: 'Basic code pattern for [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image"). **Exactly one** of the parameters **filename / stream /
    pixmap** must be given, if not re-inserting an existing image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image") 的基本代码模式。如果不是重新插入现有图像，则必须给出
    **文件名 / 流 / 像素图** 参数中的**一个**：'
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Basic code pattern for [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Source and target PDF must be different [Document](document.html#document)
    objects (but may be opened from the same file):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    的基本代码模式。源 PDF 和目标 PDF 必须是不同的 [Document](document.html#document) 对象（但可以从同一文件打开）：'
- en: '[PRE18]  ## How to Use Pixmaps: Checking Text Visibility'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]  ## 如何使用像素图：检查文本可见性'
- en: 'Whether or not a given piece of text is actually visible on a page depends
    on a number of factors:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是否实际可见取决于多个因素：
- en: Text is not covered by another object but may have the same color as the background
    i.e., white-on-white etc.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本没有被其他对象覆盖，但可能与背景色相同，例如白色字体在白色背景上等。
- en: Text may be covered by an image or vector graphics. Detecting this is an important
    capability, for example to uncover badly anonymized legal documents.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本可能被图像或矢量图覆盖。检测这一点是一项重要的功能，例如用于揭示不当匿名化的法律文件。
- en: Text is created hidden. This technique is usually used by OCR tools to store
    the recognized text in an invisible layer on the page.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本是隐藏创建的。这种技术通常由 OCR 工具使用，将识别的文本存储在页面上的不可见层中。
- en: 'The following shows how to detect situation 1\. above, or situation 2\. if
    the covering object is unicolor:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了如何检测情况 1\. 或者情况 2\. 如果遮盖物是单色的话：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Method [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    returns a tuple `(ratio, pixel)` where 0 < ratio <= 1 and *pixel* is the pixel
    value of the color. Please note that we create a **pixmap only once**. This can
    save a lot of processing time if there are multiple hit rectangles.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    返回一个元组 `(ratio, pixel)`，其中 0 < ratio <= 1，*pixel* 是颜色的像素值。请注意，我们仅创建一次**像素图**。如果有多个命中矩形，这可以节省大量处理时间。
- en: 'The logic of the above code is: If the needle’s rectangle is (“almost”: > 95%)
    unicolor, then the text cannot be visible. A typical result for visible text returns
    the color of the background (mostly white) and a ratio around 0.7 to 0.8, for
    example `(0.685, b''xffxffxff'')`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的逻辑是：如果针的矩形是“几乎”单色的（> 95%），则文本不可见。对于可见文本的典型结果返回背景色（通常是白色）和约为0.7到0.8的比率，例如
    `(0.685, b'xffxffxff')`。
- en: Do you have any feedback on this page?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这个页面有什么反馈吗？
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本软件按原样提供，不提供任何明示或暗示的担保。本软件在许可下分发，并且除非在该许可条款明确授权下，否则不得复制、修改或分发。请参考 [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    获取许可信息或联系Artifex Software Inc.，39 Mesa Street，Suite 108A，San Francisco CA 94129，美国，以获取进一步的信息。
- en: This documentation covers all versions up to 1.24.4.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档覆盖所有版本，直至1.24.4。
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## How to Make Images from Document Pages'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## 如何从文档页面创建图像'
- en: This little script will take a document filename and generate a PNG file from
    each of its pages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小脚本将接受文档文件名，并为每一页生成一个PNG文件。
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以是任何 [支持的类型](how-to-open-a-file.html#supported-file-types)。
- en: 'The script works as a command line tool which expects the filename being supplied
    as a parameter. The generated image files (1 per page) are stored in the directory
    of the script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本作为一个命令行工具运行，需要将文件名作为参数提供。生成的图像文件（每页一个）存储在脚本的目录中：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The script directory will now contain PNG image files named *page-0.png*, *page-1.png*,
    etc. Pictures have the dimension of their pages with width and height rounded
    to integers, e.g. 595 x 842 pixels for an A4 portrait sized page. They will have
    a resolution of 96 dpi in x and y dimension and have no transparency. You can
    change all that – for how to do this, read the next sections.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本目录下将包含命名为 *page-0.png*、*page-1.png* 等的PNG图像文件。图片的尺寸与其页面的宽度和高度四舍五入为整数，例如A4纵向页面的尺寸为595
    x 842像素。它们在x和y维度上具有96 dpi的分辨率，并且没有透明度。您可以更改所有这些内容-有关如何操作，请阅读下面的部分。
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Increase Image Resolution'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何增加图像分辨率'
- en: The image of a document page is represented by a [Pixmap](pixmap.html#pixmap),
    and the simplest way to create a pixmap is via method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 文档页面的图像由 [Pixmap](pixmap.html#pixmap) 表示，创建像素图的最简单方法是通过方法 [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap")。
- en: This method has many options to influence the result. The most important among
    them is the [Matrix](matrix.html#matrix), which lets you zoom, rotate, distort
    or mirror the outcome.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有许多选项可以影响结果。其中最重要的是 [Matrix](matrix.html#matrix)，它允许您缩放、旋转、扭曲或镜像结果。
- en: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") by default
    will use the [Identity](identity.html#identity) matrix, which does nothing.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") 默认将使用 [Identity](identity.html#identity)
    矩阵，即不进行任何操作。'
- en: 'In the following, we apply a zoom factor of 2 to each dimension, which will
    generate an image with a four times better resolution for us (and also about 4
    times the size):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们对每个维度应用了2倍的缩放因子，这将为我们生成具有四倍更好分辨率的图像（大约也是四倍的大小）：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since version 1.19.2 there is a more direct way to set the resolution: Parameter
    `"dpi"` (dots per inch) can be used in place of `"matrix"`. To create a 300 dpi
    image of a page specify `pix = page.get_pixmap(dpi=300)`. Apart from notation
    brevity, this approach has the additional advantage that the **dpi value is saved
    with the image** file – which does not happen automatically when using the Matrix
    notation.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.19.2 版本起，有一种更直接的设置分辨率的方法：参数 `"dpi"`（每英寸点数）可以用于替换 `"matrix"`。要创建页面的 300 dpi
    图像，请指定 `pix = page.get_pixmap(dpi=300)`。除了表示简洁外，这种方法的另一个优点是 **dpi 值将与图像文件一起保存**
    —— 使用矩阵表示时不会自动发生这种情况。
- en: '* * *'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Create Partial Pixmaps (Clips)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何创建部分位图（剪辑）'
- en: You do not always need or want the full image of a page. This is the case e.g.
    when you display the image in a GUI and would like to fill the respective window
    with a zoomed part of the page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是需要或想要完整的页面图像。例如，当您在 GUI 中显示图像并希望用页面的放大部分填充相应的窗口时，就是这种情况。
- en: Let’s assume your GUI window has room to display a full document page, but you
    now want to fill this room with the bottom right quarter of your page, thus using
    a four times better resolution.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 GUI 窗口有足够的空间来显示完整的文档页面，但现在你想要用页面的右下角的四分之一来填充这个空间，从而使用四倍更好的分辨率。
- en: To achieve this, define a rectangle equal to the area you want to appear in
    the GUI and call it “clip”. One way of constructing rectangles in PyMuPDF is by
    providing two diagonally opposite corners, which is what we are doing here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，请定义一个等于您希望显示在 GUI 中的区域的矩形，并将其命名为“剪辑”。在 PyMuPDF 中构建矩形的一种方式是提供两个对角线相对的角，这就是我们在这里做的事情。
- en: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the above we construct *clip* by specifying two diagonally opposite points:
    the middle point *mp* of the page rectangle, and its bottom right, *rect.br*.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们通过指定两个对角线相对的点来构造*剪辑*：页面矩形的中点*mp*和它的右下角*rect.br*。
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Zoom a Clip to a GUI Window'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何将剪辑缩放到 GUI 窗口'
- en: Please also read the previous section. This time we want to **compute the zoom
    factor** for a clip, such that its image best fits a given GUI window. This means,
    that the image’s width or height (or both) will equal the window dimension. For
    the following code snippet you need to provide the WIDTH and HEIGHT of your GUI’s
    window that should receive the page’s clip rectangle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请还请阅读前一节。这次我们想要**计算剪辑的缩放因子**，以便其图像最适合给定的 GUI 窗口。这意味着图像的宽度或高度（或两者）将等于窗口尺寸。对于以下代码片段，您需要提供
    GUI 窗口的 WIDTH 和 HEIGHT，该窗口应接收页面的剪辑矩形。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For the other way round, now assume you **have** the zoom factor and need to
    **compute the fitting clip**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一种情况，现在假设您**已有**缩放因子并且需要**计算适合的剪辑**。
- en: 'In this case we have `zoom = HEIGHT/clip.height = WIDTH/clip.width`, so we
    must set `clip.height = HEIGHT/zoom` and, `clip.width = WIDTH/zoom`. Choose the
    top-left point [`tl`](irect.html#IRect.tl "IRect.tl") of the clip on the page
    to compute the right pixmap:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有 `zoom = HEIGHT/clip.height = WIDTH/clip.width`，因此我们必须设置 `clip.height
    = HEIGHT/zoom` 和 `clip.width = WIDTH/zoom`。选择页面上剪辑的左上角点[`tl`](irect.html#IRect.tl
    "IRect.tl")来计算正确的位图：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '* * *'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Create or Suppress Annotation Images'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何创建或抑制注释图片'
- en: Normally, the pixmap of a page also shows the page’s annotations. Occasionally,
    this may not be desirable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，页面的位图还显示页面的注释。偶尔，这可能是不可取的。
- en: To suppress the annotation images on a rendered page, just specify `annots=False`
    in [`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap").
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染页面上抑制注释图片，只需在[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap")中指定`annots=False`。
- en: 'You can also render annotations separately: they have their own [`Annot.get_pixmap()`](annot.html#Annot.get_pixmap
    "Annot.get_pixmap") method. The resulting pixmap has the same dimensions as the
    annotation rectangle.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以单独呈现注释：它们有自己的[`Annot.get_pixmap()`](annot.html#Annot.get_pixmap "Annot.get_pixmap")方法。结果位图的尺寸与注释矩形相同。
- en: '* * *'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Extract Images: Non-PDF Documents'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何提取图片：非 PDF 文档'
- en: In contrast to the previous sections, this section deals with **extracting**
    images **contained** in documents, so they can be displayed as part of one or
    more pages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几节相反，这一节涉及**提取**文档中**包含的**图像，以便它们可以作为一个或多个页面的一部分显示。
- en: 'If you want to recreate the original image in file form or as a memory area,
    you have basically two options:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要以文件形式或作为内存区域重新创建原始图像，您基本上有两个选项：
- en: 'Convert your document to a PDF, and then use one of the PDF-only extraction
    methods. This snippet will convert a document to PDF:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的文档转换为 PDF，然后使用其中一个仅适用于 PDF 的提取方法。此代码片段将文档转换为 PDF：
- en: '[PRE25]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use [`Page.get_text()`](page.html#Page.get_text "Page.get_text") with the “dict”
    parameter. This works for all document types. It will extract all text and images
    shown on the page, formatted as a Python dictionary. Every image will occur in
    an image block, containing meta information and **the binary image data**. For
    details of the dictionary’s structure, see [TextPage](textpage.html#textpage).
    The method works equally well for PDF files. This creates a list of all images
    shown on a page:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`Page.get_text()`](page.html#Page.get_text "Page.get_text") 方法和 “dict” 参数。适用于所有文档类型。将提取页面上显示的所有文本和图像，格式化为
    Python 字典。每个图像将出现在图像块中，包含元信息和**二进制图像数据**。有关字典结构的详细信息，请参阅 [TextPage](textpage.html#textpage)。该方法同样适用于
    PDF 文件。这将创建页面上显示的所有图像的列表：
- en: '[PRE26]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '* * *'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Extract Images: PDF Documents'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何提取图像：PDF 文档'
- en: 'Like any other “object” in a PDF, images are identified by a cross reference
    number ([`xref`](glossary.html#xref "xref"), an integer). If you know this number,
    you have two ways to access the image’s data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 PDF 中的任何其他“对象”一样，图像由交叉引用编号（[`xref`](glossary.html#xref "xref")，整数）标识。如果您知道这个编号，您有两种方法可以访问图像的数据：
- en: '**Create** a [Pixmap](pixmap.html#pixmap) of the image with instruction *pix
    = pymupdf.Pixmap(doc, xref)*. This method is **very** fast (single digit micro-seconds).
    The pixmap’s properties (width, height, …) will reflect the ones of the image.
    In this case there is no way to tell which image format the embedded original
    has.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**一个 [Pixmap](pixmap.html#pixmap) 图像，使用指令 *pix = pymupdf.Pixmap(doc, xref)*。该方法**非常**快速（单个数字微秒）。Pixmap
    的属性（宽度、高度等）将反映图像的属性。在这种情况下，无法确定嵌入原始图像的图像格式。'
- en: '**Extract** the image with *img = doc.extract_image(xref)*. This is a dictionary
    containing the binary image data as *img[“image”]*. A number of meta data are
    also provided – mostly the same as you would find in the pixmap of the image.
    The major difference is string *img[“ext”]*, which specifies the image format:
    apart from “png”, strings like “jpeg”, “bmp”, “tiff”, etc. can also occur. Use
    this string as the file extension if you want to store to disk. The execution
    speed of this method should be compared to the combined speed of the statements
    *pix = pymupdf.Pixmap(doc, xref);pix.tobytes()*. If the embedded image is in PNG
    format, the speed of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") is about the same (and the binary image data are identical).
    Otherwise, this method is **thousands of times faster**, and the **image data
    is much smaller**.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提取**图像，使用 *img = doc.extract_image(xref)*。这是一个包含二进制图像数据的字典，如 *img[“image”]*
    所示。还提供了许多元数据 – 大多数与图像的 Pixmap 中相同。主要区别在于字符串 *img[“ext”]*，它指定图像格式：除了“png”外，还可以出现像“jpeg”、“bmp”、“tiff”等的字符串。如果要将其存储到磁盘，请使用此字符串作为文件扩展名。此方法的执行速度应与语句
    *pix = pymupdf.Pixmap(doc, xref); pix.tobytes()* 的组合速度进行比较。如果嵌入的图像是 PNG 格式，则 [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") 的速度大约相同（并且二进制图像数据相同）。否则，此方法**快几千倍**，并且**图像数据更小**。'
- en: 'The question remains: **“How do I know those ‘xref’ numbers of images?”**.
    There are two answers to this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 问题仍然是：“**如何知道这些‘xref’图像的编号？**”。对此有两个答案：
- en: '**“Inspect the page objects:”** Loop through the items of [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"). It is a list of list, and its items look like *[xref, smask,
    …]*, containing the [`xref`](glossary.html#xref "xref") of an image. This [`xref`](glossary.html#xref
    "xref") can then be used with one of the above methods. Use this method for **valid
    (undamaged)** documents. Be wary however, that the same image may be referenced
    multiple times (by different pages), so you might want to provide a mechanism
    avoiding multiple extracts.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“检查页面对象：”** 遍历 [`Page.get_images()`](page.html#Page.get_images "Page.get_images")
    的项。这是一个列表的列表，其项看起来像 *[xref, smask, …]*，包含图像的 [`xref`](glossary.html#xref "xref")。然后可以使用其中一个上述方法使用此
    [`xref`](glossary.html#xref "xref")。对于**有效（未损坏）**文档使用此方法要小心。然而，请注意，同一图像可能被多个页面引用，因此可能需要提供机制以避免多次提取。'
- en: '**“No need to know:”** Loop through the list of **all xrefs** of the document
    and perform a [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") for each one. If the returned dictionary is empty, then
    continue – this [`xref`](glossary.html#xref "xref") is no image. Use this method
    if the PDF is **damaged (unusable pages)**. Note that a PDF often contains “pseudo-images”
    (“stencil masks”) with the special purpose of defining the transparency of some
    other image. You may want to provide logic to exclude those from extraction. Also
    have a look at the next section.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“不需要知道：”** 遍历文档的所有xref列表，并对每个执行 [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image")。如果返回的字典为空，则继续 - 此[`xref`](glossary.html#xref "xref")不是图像。如果
    PDF 文件损坏（无法使用的页面），请使用此方法。注意，PDF 文件通常包含具有特殊目的（定义其他图像的透明度）的“伪图像”（“模版掩码”）。您可能希望提供逻辑来排除这些内容的提取。也请查看下一节。'
- en: 'For both extraction approaches, there exist ready-to-use general purpose scripts:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种提取方法，都有现成的通用脚本可供使用：
- en: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    extracts images page by page:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    按页提取图像：'
- en: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
- en: 'and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    extracts images by xref table:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 和 [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    通过 xref 表提取图像：
- en: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
- en: '* * *'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Handle Image Masks'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何处理图像掩码'
- en: Some images in PDFs are accompanied by **image masks**. In their simplest form,
    masks represent alpha (transparency) bytes stored as separate images. In order
    to reconstruct the original of an image, which has a mask, it must be “enriched”
    with transparency bytes taken from its mask.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: PDF 中的某些图像伴随着**图像掩码**。在最简单的形式下，掩码表示作为单独图像存储的 alpha（透明度）字节。为了重建具有掩码的图像的原始图像，必须从其掩码中提取透明度字节来“丰富”它。
- en: 'Whether an image does have such a mask can be recognized in one of two ways
    in PyMuPDF:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyMuPDF 中可以通过以下两种方式之一识别图像是否有掩码：
- en: An item of [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") has the general format `(xref, smask, ...)`, where
    *xref* is the image’s [`xref`](glossary.html#xref "xref") and *smask*, if positive,
    then it is the [`xref`](glossary.html#xref "xref") of a mask.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Document.get_page_images()`](document.html#Document.get_page_images "Document.get_page_images")
    的项具有一般格式 `(xref, smask, ...)`，其中 *xref* 是图像的[`xref`](glossary.html#xref "xref")，如果
    *smask* 为正，则为掩码的[`xref`](glossary.html#xref "xref")。'
- en: The (dictionary) results of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") have a key *“smask”*, which also contains any mask’s
    [`xref`](glossary.html#xref "xref") if positive.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Document.extract_image()`](document.html#Document.extract_image "Document.extract_image")
    的（字典）结果具有一个 *“smask”* 键，如果为正，则包含任何掩码的[`xref`](glossary.html#xref "xref")。'
- en: If *smask == 0* then the image encountered via [`xref`](glossary.html#xref "xref")
    can be processed as it is.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *smask == 0*，那么通过[`xref`](glossary.html#xref "xref")遇到的图像可以直接处理。
- en: 'To recover the original image using PyMuPDF, the procedure depicted as follows
    must be executed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PyMuPDF 恢复原始图像，需执行以下过程：
- en: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Step (1) creates a pixmap of the basic image. Step (2) does the same with the
    image mask. Step (3) adds an alpha channel and fills it with transparency information.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤（1）创建基本图像的像素图。步骤（2）使用图像掩码完成相同操作。步骤（3）添加 alpha 通道并填充透明信息。
- en: The scripts [extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py),
    and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    above also contain this logic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本 [extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    和 [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    也包含此逻辑。
- en: '* * *'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Make one PDF of all your Pictures (or Files)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何制作所有图片（或文件）的一个 PDF 文件'
- en: We show here **three scripts** that take a list of (image and other) files and
    put them all in one PDF.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示了**三个脚本**，它们接受一个（图像和其他）文件列表，并将它们全部放入一个 PDF 中。
- en: '**Method 1: Inserting Images as Pages**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 1：将图像插入为页面**'
- en: 'The first one converts each image to a PDF page with the same dimensions. The
    result will be a PDF with one page per image. It will only work for [supported
    image](how-to-open-a-file.html#supported-file-types) file formats:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本将每个图像转换为具有相同尺寸的 PDF 页面。结果将是一个每个图像一个页面的 PDF。它只适用于[支持的图像](how-to-open-a-file.html#supported-file-types)文件格式：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will generate a PDF only marginally larger than the combined pictures’
    size. Some numbers on performance:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 PDF 文件，大小仅比合并图片的大小稍大一点。一些关于性能的数字：
- en: The above script needed about 1 minute on my machine for 149 pictures with a
    total size of 514 MB (and about the same resulting PDF size).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本在我的机器上用于 149 张图片大约需要 1 分钟，总共大小为 514 MB（生成的 PDF 文件大小大约相同）。
- en: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
- en: 'Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)
    for a more complete source code: it offers a directory selection dialog and skips
    unsupported files and non-file entries.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[这里](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)获取更完整的源代码：它提供了一个目录选择对话框并跳过了不支持的文件和非文件条目。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We might have used [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    instead of [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page"),
    and the result would have been a similar looking file. However, depending on the
    image type, it may store **images uncompressed**. Therefore, the save option *deflate
    = True* must be used to achieve a reasonable file size, which hugely increases
    the runtime for large numbers of images. So this alternative **cannot be recommended**
    here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    而不是 [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")，结果会是一个外观相似的文件。但是，根据图像类型，它可能以**未压缩的图像**存储。因此，必须使用保存选项
    *deflate = True* 来获得合理的文件大小，这会极大地增加大量图像的运行时间。因此，在这里**不能推荐**这种替代方案。
- en: '**Method 2: Embedding Files**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 2：嵌入文件**'
- en: 'The second script **embeds** arbitrary files – not only images. The resulting
    PDF will have just one (empty) page, required for technical reasons. To later
    access the embedded files again, you would need a suitable PDF viewer that can
    display and / or extract embedded files:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本**嵌入**了任意文件 - 不仅仅是图像。由于技术原因，生成的 PDF 将只有一页（空白）。要稍后再次访问嵌入的文件，您需要一个能够显示和/或提取嵌入文件的合适的
    PDF 查看器：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
- en: 'This is by far the fastest method, and it also produces the smallest possible
    output file size. The above pictures needed 20 seconds on my machine and yielded
    a PDF size of 510 MB. Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)
    for a more complete source code: it offers a directory selection dialog and skips
    non-file entries.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是最快的方法，同时也产生了可能的最小输出文件大小。上述图片在我的机器上需要 20 秒，并生成了一个大小为 510 MB 的 PDF 文件。查看[这里](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)获取更完整的源代码：它提供了一个目录选择对话框并跳过了非文件条目。
- en: '**Method 3: Attaching Files**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 3：附加文件**'
- en: A third way to achieve this task is **attaching files** via page annotations
    see [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)
    for the complete source code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此任务的第三种方法是通过页面注释**附加文件**，请查看[这里](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)获取完整的源代码。
- en: This has a similar performance as the previous script and it also produces a
    similar file size. It will produce PDF pages which show a ‘FileAttachment’ icon
    for each attached file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一个脚本具有类似的性能，并且也产生了类似的文件大小。它将为每个附加文件显示一个‘FileAttachment’图标的 PDF 页面。
- en: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both, the **embed** and the **attach** methods can be used for **arbitrary files**
    – not just images.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入**和**附加**方法都可用于**任意文件** - 不仅仅是图像。'
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We strongly recommend using the awesome package [PySimpleGUI](https://pypi.org/project/PySimpleGUI/)
    to display a progress meter for tasks that may run for an extended time span.
    It’s pure Python, uses Tkinter (no additional GUI package) and requires just one
    more line of code!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议使用出色的包[PySimpleGUI](https://pypi.org/project/PySimpleGUI/)来为可能运行较长时间的任务显示进度条。它纯粹使用Tkinter（无需额外的GUI包），只需再加一行代码！
- en: '* * *'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Create Vector Images'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何创建矢量图像'
- en: The usual way to create an image from a document page is [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap"). A pixmap represents a raster image, so you must decide on
    its quality (i.e. resolution) at creation time. It cannot be changed later.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档页面创建图像的常规方法是[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap")。像素图表示一幅光栅图像，因此必须在创建时决定其质量（即分辨率）。后期无法更改。
- en: PyMuPDF also offers a way to create a **vector image** of a page in SVG format
    (scalable vector graphics, defined in XML syntax). SVG images remain precise across
    zooming levels (of course with the exception of any raster graphic elements embedded
    therein).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PyMuPDF还提供了一种方式来创建SVG格式（可缩放矢量图形，以XML语法定义）的**矢量图像**。SVG图像在各种缩放级别下保持精确（当然除了其中嵌入的任何栅格图形元素）。
- en: Instruction *svg = page.get_svg_image(matrix=pymupdf.Identity)* delivers a UTF-8
    string *svg* which can be stored with extension “.svg”.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 指令*svg = page.get_svg_image(matrix=pymupdf.Identity)*提供了一个UTF-8字符串*svg*，可以用扩展名“.svg”存储。
- en: '* * *'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Convert Images'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何转换图像'
- en: Just as a feature among others, PyMuPDF’s image conversion is easy. It may avoid
    using other graphics packages like PIL/Pillow in many cases.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就像PyMuPDF的一个特性一样，图像转换非常简单。在许多情况下，它可以避免使用其他图形包（如PIL/Pillow）。
- en: Notwithstanding that interfacing with Pillow is almost trivial.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与Pillow接口几乎是微不足道的。
- en: '| **Input Formats** | **Output Formats** | **Description** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **输入格式** | **输出格式** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| BMP | . | Windows Bitmap |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| BMP | . | Windows位图 |'
- en: '| JPEG | JPEG | Joint Photographic Experts Group |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| JPEG | JPEG | 联合图像专家组 |'
- en: '| JXR | . | JPEG Extended Range |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| JXR | . | JPEG扩展范围 |'
- en: '| JPX/JP2 | . | JPEG 2000 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| JPX/JP2 | . | JPEG 2000 |'
- en: '| GIF | . | Graphics Interchange Format |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| GIF | . | 图形交换格式 |'
- en: '| TIFF | . | Tagged Image File Format |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| TIFF | . | 标记图像文件格式 |'
- en: '| PNG | PNG | Portable Network Graphics |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| PNG | PNG | 可移植网络图形 |'
- en: '| PNM | PNM | Portable Anymap |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| PNM | PNM | 可移植任意图形 |'
- en: '| PGM | PGM | Portable Graymap |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| PGM | PGM | 可移植灰度图 |'
- en: '| PBM | PBM | Portable Bitmap |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| PBM | PBM | 可移植位图 |'
- en: '| PPM | PPM | Portable Pixmap |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| PPM | PPM | 可移植像素图 |'
- en: '| PAM | PAM | Portable Arbitrary Map |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| PAM | PAM | 可移植任意地图 |'
- en: '| . | PSD | Adobe Photoshop Document |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| . | PSD | Adobe Photoshop文档 |'
- en: '| . | PS | Adobe Postscript |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| . | PS | Adobe Postscript |'
- en: 'The general scheme is just the following two lines:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 基本方案仅包括以下两行：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Remarks**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: The **input** argument of *pymupdf.Pixmap(arg)* can be a file or a bytes / io.BytesIO
    object containing an image.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pymupdf.Pixmap(arg)*的**输入**参数可以是包含图像的文件或字节/io.BytesIO对象。'
- en: Instead of an output **file**, you can also create a bytes object via *pix.tobytes(“yyy”)*
    and pass this around.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是一个输出**文件**，你也可以通过*pix.tobytes(“yyy”)*创建一个字节对象并传递它。
- en: As a matter of course, input and output formats must be compatible in terms
    of colorspace and transparency. The *Pixmap* class has batteries included if adjustments
    are needed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，输入和输出格式在颜色空间和透明度方面必须兼容。如果需要调整，*Pixmap*类已经包括了相关功能。
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Convert JPEG to Photoshop**:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**将JPEG转换为Photoshop**：'
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Convert **JPEG to Tkinter PhotoImage**. Any **RGB / no-alpha** image works
    exactly the same. Conversion to one of the **Portable Anymap** formats (PPM, PGM,
    etc.) does the trick, because they are supported by all Tkinter versions:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将**JPEG转换为Tkinter PhotoImage**。任何**RGB / 无Alpha**图像的工作原理都是相同的。转换为**可移植任意图形**格式（PPM、PGM等）是解决问题的方法，因为它们被所有Tkinter版本支持：
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Convert **PNG with alpha** to Tkinter PhotoImage. This requires **removing
    the alpha bytes**, before we can do the PPM conversion:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将**带Alpha通道的PNG转换为Tkinter PhotoImage**。这需要**移除Alpha字节**，然后进行PPM转换：
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '* * *'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Use Pixmaps: Gluing Images'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何使用像素图：粘合图像'
- en: 'This shows how pixmaps can be used for purely graphical, non-document purposes.
    The script reads an image file and creates a new image which consist of 3 * 4
    tiles of the original:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了像素图如何用于纯粹的图形非文档目的。脚本读取图像文件并创建一个新图像，由原始图像的3 * 4个瓷砖组成：
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the input picture:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输入图片：
- en: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
- en: 'Here is the output:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
- en: '* * *'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Use Pixmaps: Making a Fractal'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何使用 Pixmaps：制作分形'
- en: Here is another Pixmap example that creates **Sierpinski’s Carpet** – a fractal
    generalizing the **Cantor Set** to two dimensions. Given a square carpet, mark
    its 9 sub-suqares (3 times 3) and cut out the one in the center. Treat each of
    the remaining eight sub-squares in the same way, and continue *ad infinitum*.
    The end result is a set with area zero and fractal dimension 1.8928…
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个 Pixmap 示例，创建了**谢尔宾斯基地毯** - 将**康托集**推广到二维的分形。给定一个正方形地毯，标记其 9 个子正方形（3×3）并切除中心的一个。以相同方式处理剩下的八个子正方形，并*无限继续*。最终结果是一个面积为零、分形维度为
    1.8928… 的集合。
- en: 'This script creates an approximate image of it as a PNG, by going down to one-pixel
    granularity. To increase the image precision, change the value of n (precision):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本通过一像素的粒度制作其近似图像，将其制作为 PNG。要增加图像的精度，请更改 n 的值（精度）：
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result should look something like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
- en: '* * *'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Interface with NumPy'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何与 NumPy 交互'
- en: 'This shows how to create a PNG file from a numpy array (several times faster
    than most other methods):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何从一个 numpy 数组创建 PNG 文件（比大多数其他方法快几倍）：
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '* * *'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## How to Add Images to a PDF Page'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何向 PDF 页面添加图像'
- en: 'There are two methods to add images to a PDF page: [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image") and [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Both methods have things in common, but there are also
    differences.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法向 PDF 页面添加图像：[`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    和 [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")。这两种方法有共同之处，但也有区别。
- en: '| **Criterion** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **准则** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
- en: '| --- | --- | --- |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| displayable content | image file, image in memory, pixmap | PDF page |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 可显示内容 | 图像文件、内存中的图像、Pixmap | PDF 页面 |'
- en: '| display resolution | image resolution | vectorized (except raster page content)
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 显示分辨率 | 图像分辨率 | 矢量化（除了光栅页面内容） |'
- en: '| rotation | 0, 90, 180 or 270 degrees | any angle |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | 0、90、180 或 270 度 | 任意角度 |'
- en: '| clipping | no (full image only) | yes |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 裁剪 | 否（仅完整图像） | 是 |'
- en: '| keep aspect ratio | yes (default option) | yes (default option) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 保持长宽比 | 是（默认选项） | 是（默认选项） |'
- en: '| transparency (water marking) | depends on the image | depends on the page
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 透明度（水印） | 取决于图像 | 取决于页面 |'
- en: '| location / placement | scaled to fit target rectangle | scaled to fit target
    rectangle |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 位置 / 放置 | 缩放以适应目标矩形 | 缩放以适应目标矩形 |'
- en: '| performance | automatic prevention of duplicates; | automatic prevention
    of duplicates; |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 自动防止重复； | 自动防止重复； |'
- en: '| multi-page image support | no | yes |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 多页面图像支持 | 否 | 是 |'
- en: '| ease of use | simple, intuitive; | simple, intuitive; **usable for all document
    types** (including images!) after conversion to PDF via [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 使用便捷性 | 简单、直观； | 简单、直观；**转换为 PDF 后适用于所有文档类型（包括图像！）**通过 [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
- en: 'Basic code pattern for [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image"). **Exactly one** of the parameters **filename / stream /
    pixmap** must be given, if not re-inserting an existing image:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image") 的基本代码模式。如果不重新插入现有图像，则必须**恰好给出一个**参数**文件名
    / 流 / Pixmap**：'
- en: '[PRE37]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Basic code pattern for [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Source and target PDF must be different [Document](document.html#document)
    objects (but may be opened from the same file):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    的基本代码模式。源 PDF 和目标 PDF 必须是不同的[Document](document.html#document)对象（但可以从同一文件打开）：'
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '## How to Use Pixmaps: Checking Text Visibility'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何使用 Pixmaps：检查文本可见性'
- en: 'Whether or not a given piece of text is actually visible on a page depends
    on a number of factors:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 给定文本是否实际上在页面上可见取决于多个因素：
- en: Text is not covered by another object but may have the same color as the background
    i.e., white-on-white etc.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本未被其他对象覆盖，但可能与背景颜色相同，例如白色背景等。
- en: Text may be covered by an image or vector graphics. Detecting this is an important
    capability, for example to uncover badly anonymized legal documents.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本可能被图像或矢量图形覆盖。检测这一点是一个重要的能力，例如揭示糟糕匿名化的法律文件。
- en: Text is created hidden. This technique is usually used by OCR tools to store
    the recognized text in an invisible layer on the page.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本被创建为隐藏状态。这种技术通常被OCR工具使用，将识别的文本存储在页面的一个不可见层中。
- en: 'The following shows how to detect situation 1\. above, or situation 2\. if
    the covering object is unicolor:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示如何检测上述情况1，或者如果遮盖对象是单色的，则检测情况2。
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Method [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    returns a tuple `(ratio, pixel)` where 0 < ratio <= 1 and *pixel* is the pixel
    value of the color. Please note that we create a **pixmap only once**. This can
    save a lot of processing time if there are multiple hit rectangles.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    返回一个元组 `(ratio, pixel)`，其中 0 < ratio <= 1，*pixel* 是颜色的像素值。请注意，我们只创建一次**pixmap**。如果有多个命中矩形，这可以节省大量处理时间。
- en: 'The logic of the above code is: If the needle’s rectangle is (“almost”: > 95%)
    unicolor, then the text cannot be visible. A typical result for visible text returns
    the color of the background (mostly white) and a ratio around 0.7 to 0.8, for
    example `(0.685, b''xffxffxff'')`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '上述代码的逻辑是：如果针的矩形是（“几乎”: > 95%）单色的，则文本不可见。对于可见文本的典型结果返回背景的颜色（主要是白色）和约 0.7 到 0.8
    的比率，例如 `(0.685, b''xffxffxff'')`。'
- en: Do you have any feedback on this page?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对本页面有任何反馈吗？
- en: '* * *'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本软件按原样提供，不附带任何明示或暗示的保证。本软件在许可下分发，除非在该许可的条款下明确授权，否则不得复制、修改或分发。请参阅 [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    的许可信息或联系位于美国旧金山 CA 94129 Mesa Street, Suite 108A 的 Artifex Software Inc. 了解更多信息。
- en: This documentation covers all versions up to 1.24.4.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档涵盖所有版本直至 1.24.4。
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
