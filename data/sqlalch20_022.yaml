- en: Integration with dataclasses and attrs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与dataclasses和attrs集成
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/dataclasses.html](https://docs.sqlalchemy.org/en/20/orm/dataclasses.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/dataclasses.html](https://docs.sqlalchemy.org/en/20/orm/dataclasses.html)
- en: SQLAlchemy as of version 2.0 features “native dataclass” integration where an
    [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping may be turned into a Python [dataclass](https://docs.python.org/3/library/dataclasses.html)
    by adding a single mixin or decorator to mapped classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy从2.0版本开始具有“本地数据类”集成，在[带注释的声明表](declarative_tables.html#orm-declarative-mapped-column)映射中，可以通过向映射类添加单个mixin或装饰器将其转换为Python
    [dataclass](https://docs.python.org/3/library/dataclasses.html)。
- en: 'New in version 2.0: Integrated dataclass creation with ORM Declarative classes'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中的新功能：将数据类创建与ORM声明类集成
- en: There are also patterns available that allow existing dataclasses to be mapped,
    as well as to map classes instrumented by the [attrs](https://pypi.org/project/attrs/)
    third party integration library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可用的模式，允许将现有的数据类映射，以及映射由第三方集成库[attrs](https://pypi.org/project/attrs/)仪表化的类。
- en: '## Declarative Dataclass Mapping'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## 声明式数据类映射'
- en: SQLAlchemy [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mappings may be augmented with an additional mixin class or decorator directive,
    which will add an additional step to the Declarative process after the mapping
    is complete that will convert the mapped class **in-place** into a Python [dataclass](https://docs.python.org/3/library/dataclasses.html),
    before completing the mapping process which applies ORM-specific [instrumentation](../glossary.html#term-instrumentation)
    to the class. The most prominent behavioral addition this provides is generation
    of an `__init__()` method with fine-grained control over positional and keyword
    arguments with or without defaults, as well as generation of methods like `__repr__()`
    and `__eq__()`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy [带注释的声明表](declarative_tables.html#orm-declarative-mapped-column)映射可以通过附加的mixin类或装饰器指令进行扩展，在映射完成后将映射类**原地**转换为Python
    [dataclass](https://docs.python.org/3/library/dataclasses.html)，然后完成应用ORM特定的[仪表化](../glossary.html#term-instrumentation)到类的映射过程。这提供的最突出的行为增加是生成具有对位置和关键字参数具有或不具有默认值的精细控制的`__init__()`方法，以及生成诸如`__repr__()`和`__eq__()`等方法。
- en: From a [**PEP 484**](https://peps.python.org/pep-0484/) typing perspective,
    the class is recognized as having Dataclass-specific behaviors, most notably by
    taking advantage of [**PEP 681**](https://peps.python.org/pep-0681/) “Dataclass
    Transforms”, which allows typing tools to consider the class as though it were
    explicitly decorated using the `@dataclasses.dataclass` decorator.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从[**PEP 484**](https://peps.python.org/pep-0484/)的类型化角度来看，该类被认为具有特定于Dataclass的行为，最重要的是通过利用[**PEP
    681**](https://peps.python.org/pep-0681/)“数据类转换”，使类型工具可以将该类视为明确使用了`@dataclasses.dataclass`装饰器装饰的类。
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Support for [**PEP 681**](https://peps.python.org/pep-0681/) in typing tools
    as of **April 4, 2023** is limited and is currently known to be supported by [Pyright](https://github.com/microsoft/pyright)
    as well as [Mypy](https://mypy.readthedocs.io/en/stable/) as of **version 1.2**.
    Note that Mypy 1.1.1 introduced [**PEP 681**](https://peps.python.org/pep-0681/)
    support but did not correctly accommodate Python descriptors which will lead to
    errors when using SQLAlchemy’s ORM mapping scheme.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**2023年4月4日**之后，对于[**PEP 681**](https://peps.python.org/pep-0681/)在类型工具中的支持是有限的，目前已知由[Pyright](https://github.com/microsoft/pyright)以及**1.2版**的[Mypy](https://mypy.readthedocs.io/en/stable/)支持。请注意，Mypy
    1.1.1引入了[**PEP 681**](https://peps.python.org/pep-0681/)支持，但未正确适配Python描述符，这将导致在使用SQLAlchemy的ORM映射方案时出现错误。'
- en: See also
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://peps.python.org/pep-0681/#the-dataclass-transform-decorator](https://peps.python.org/pep-0681/#the-dataclass-transform-decorator)
    - background on how libraries like SQLAlchemy enable [**PEP 681**](https://peps.python.org/pep-0681/)
    support'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://peps.python.org/pep-0681/#the-dataclass-transform-decorator](https://peps.python.org/pep-0681/#the-dataclass-transform-decorator)
    - 有关像SQLAlchemy这样的库如何实现[**PEP 681**](https://peps.python.org/pep-0681/)支持的背景信息'
- en: Dataclass conversion may be added to any Declarative class either by adding
    the [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    mixin to a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class hierarchy, or for decorator mapping by
    using the [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") class decorator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类转换可以通过将[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")混入添加到[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类层次结构中的任何声明性类，或通过使用[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")类装饰器进行装饰器映射来添加。
- en: 'The [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin may be applied either to the Declarative
    `Base` class or any superclass, as in the example below:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")混入可以应用于声明性`Base`类或任何超类，如下例所示：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or may be applied directly to classes that extend from the Declarative base:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者直接应用于从声明性基类扩展的类：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using the decorator form, only the [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator is supported:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用装饰器形式时，仅支持[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")装饰器：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Class level feature configuration
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类级特性配置
- en: Support for dataclasses features is partial. Currently **supported** are the
    `init`, `repr`, `eq`, `order` and `unsafe_hash` features, `match_args` and `kw_only`
    are supported on Python 3.10+. Currently **not supported** are the `frozen` and
    `slots` features.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据类功能的支持是部分的。目前**支持**的功能有`init`、`repr`、`eq`、`order`和`unsafe_hash`，`match_args`和`kw_only`在Python
    3.10+上支持。目前**不支持**的功能有`frozen`和`slots`。
- en: 'When using the mixin class form with [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), class configuration arguments are passed
    as class-level parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用混入类形式的[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")时，类配置参数作为类级参数传递：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When using the decorator form with [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), class configuration arguments
    are passed to the decorator directly:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")的装饰器形式时，类配置参数直接传递给装饰器：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For background on dataclass class options, see the [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    documentation at [@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据类类选项的背景，请参阅[@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass)中的[dataclasses](https://docs.python.org/3/library/dataclasses.html)文档。
- en: Attribute Configuration
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性配置
- en: SQLAlchemy native dataclasses differ from normal dataclasses in that attributes
    to be mapped are described using the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic annotation container in all cases. Mappings follow
    the same forms as those documented at [Declarative Table with mapped_column()](declarative_tables.html#orm-declarative-table),
    and all features of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") are supported.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy原生数据类与普通数据类的不同之处在于，要映射的属性在所有情况下都是使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型注解容器来描述的。映射遵循与[带有mapped_column()的声明性表](declarative_tables.html#orm-declarative-table)中记录的相同形式，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的所有功能都得到支持。
- en: 'Additionally, ORM attribute configuration constructs including [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") support **per-attribute field options**, including
    `init`, `default`, `default_factory` and `repr`. The names of these arguments
    is fixed as specified in [**PEP 681**](https://peps.python.org/pep-0681/). Functionality
    is equivalent to dataclasses:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，ORM属性配置结构，包括[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")支持**每个属性字段选项**，包括`init`，`default`，`default_factory`和`repr`。这些参数的名称是按照[**PEP
    681**](https://peps.python.org/pep-0681/)中指定的固定的。功能与dataclasses相同：
- en: '`init`, as in [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"), [`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship"), if False indicates the field should not be part
    of the `__init__()` method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`，如[`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")，[`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship")，如果为False，则表示该字段不应该是`__init__()`方法的一部分'
- en: '`default`, as in [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") indicates a default value for the field as given
    as a keyword argument in the `__init__()` method.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`，比如[`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column")，[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")，表示字段的默认值，可以在`__init__()`方法中作为关键字参数给出。'
- en: '`default_factory`, as in [`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column"), [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship"), indicates a callable function that will be invoked
    to generate a new default value for a parameter if not passed explicitly to the
    `__init__()` method.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory`，如[`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column")，[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")，表示一个可调用的函数，如果未显式传递给`__init__()`方法，则将调用该函数生成参数的新默认值。'
- en: '`repr` True by default, indicates the field should be part of the generated
    `__repr__()` method'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr`默认为True，表示该字段应该是生成的`__repr__()`方法的一部分'
- en: Another key difference from dataclasses is that default values for attributes
    **must** be configured using the `default` parameter of the ORM construct, such
    as `mapped_column(default=None)`. A syntax that resembles dataclass syntax which
    accepts simple Python values as defaults without using `@dataclases.field()` is
    not supported.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与dataclasses的另一个关键区别是，属性的默认值**必须**使用ORM结构的`default`参数进行配置，例如`mapped_column(default=None)`。不支持类似于dataclass语法的语法，该语法接受简单的Python值作为默认值，而无需使用`@dataclasses.field()`。
- en: 'As an example using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), the mapping below will produce an `__init__()`
    method that accepts only the fields `name` and `fullname`, where `name` is required
    and may be passed positionally, and `fullname` is optional. The `id` field, which
    we expect to be database-generated, is not part of the constructor at all:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")为例，下面的映射将产生一个`__init__()`方法，该方法仅接受`name`和`fullname`字段，其中`name`是必需的，可以作为位置参数传递，而`fullname`是可选的。我们预期`id`字段是由数据库生成的，根本不是构造函数的一部分：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Column Defaults
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列默认值
- en: 'In order to accommodate the name overlap of the `default` argument with the
    existing [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct disambiguates the two names by adding
    a new parameter [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column"), which will be populated directly into the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), independently of what may be set on [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), which is always used for the dataclasses configuration.
    For example, to configure a datetime column with a [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") set to the `func.utc_timestamp()` SQL function, but
    where the parameter is optional in the constructor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 `default` 参数与 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 构造函数中现有的参数重叠，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造函数通过添加一个新的参数 [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column") 来消除这两个名称的歧义，该参数将直接填充到 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 参数中，独立于 [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column") 的设置，后者始终用于数据类配置。例如，要配置一个日期时间列，其 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 设置为 `func.utc_timestamp()` SQL 函数，但构造函数中该参数是可选的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the above mapping, an `INSERT` for a new `User` object where no parameter
    for `created_at` were passed proceeds as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，对于未传递 `created_at` 参数的新 `User` 对象的 `INSERT` 将如下进行：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Integration with Annotated
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 Annotated 的集成
- en: 'The approach introduced at [Mapping Whole Column Declarations to Python Types](declarative_tables.html#orm-declarative-mapped-column-pep593)
    illustrates how to use [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    objects to package whole [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs for re-use. This feature is supported
    with the dataclasses feature. One aspect of the feature however requires a workaround
    when working with typing tools, which is that the [**PEP 681**](https://peps.python.org/pep-0681/)-specific
    arguments `init`, `default`, `repr`, and `default_factory` **must** be on the
    right hand side, packaged into an explicit [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in order for the typing tool to interpret
    the attribute correctly. As an example, the approach below will work perfectly
    fine at runtime, however typing tools will consider the `User()` construction
    to be invalid, as they do not see the `init=False` parameter present:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[将整个列声明映射到 Python 类型](declarative_tables.html#orm-declarative-mapped-column-pep593)
    中介绍的方法演示了如何使用 [**PEP 593**](https://peps.python.org/pep-0593/) 的 `Annotated` 对象将整个
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造函数打包以供重用。此功能受数据类功能支持。但是，该功能的一个方面在使用类型工具时需要一个解决方法，即 [**PEP 681**](https://peps.python.org/pep-0681/)
    特定参数 `init`、`default`、`repr` 和 `default_factory` **必须** 包含在右侧，并打包到显式的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造函数中，以便类型工具正确解释属性。例如，下面的方法在运行时完全正常工作，但是类型工具将认为
    `User()` 构造函数是无效的，因为它们看不到 `init=False` 参数存在：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") must be present on the right side as well with
    an explicit setting for [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"); the other arguments can remain within the `Annotated`
    construct:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    必须同时出现在右侧，并对 [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column") 进行显式设置；其他参数可以保留在 `Annotated` 构造中：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '### Using mixins and abstract superclasses'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用混合和抽象超类'
- en: 'Any mixins or base classes that are used in a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mapped class which include [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") attributes must themselves be part of a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") hierarchy, such as in the example below using
    a mixin:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")映射类中使用的任何混合类或基类，其中包括[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")属性，必须本身是[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")层次结构的一部分，例如，在下面的示例中使用混合类：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python type checkers which support [**PEP 681**](https://peps.python.org/pep-0681/)
    will otherwise not consider attributes from non-dataclass mixins to be part of
    the dataclass.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，支持[**PEP 681**](https://peps.python.org/pep-0681/)的Python类型检查器将不考虑来自非数据类混合类的属性作为数据类的一部分。
- en: 'Deprecated since version 2.0.8: Using mixins and abstract bases within [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") hierarchies which are not themselves
    dataclasses is deprecated, as these fields are not supported by [**PEP 681**](https://peps.python.org/pep-0681/)
    as belonging to the dataclass. A warning is emitted for this case which will later
    be an error.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.0.8版已弃用：在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")或[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")层次结构中使用混合类和抽象基类，这些类本身不是数据类，因此这些字段不受[**PEP
    681**](https://peps.python.org/pep-0681/)支持。对于此情况，将发出警告，以后将是一个错误。
- en: See also
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[When transforming <cls> to a dataclass, attribute(s) originate from superclass
    <cls> which is not a dataclass.](../errors.html#error-dcmx) - background on rationale'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[将<cls>转换为数据类时，属性来自不是数据类的超类<cls>。](../errors.html#error-dcmx) - 关于原因的背景'
- en: Relationship Configuration
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系配置
- en: 'The [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation in combination with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is used in the same way as described at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns). When specifying
    a collection-based [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as an optional keyword argument, the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") parameter must be passed and it must refer to the
    collection class that’s to be used. Many-to-one and scalar object references may
    make use of [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") if the default value is to be `None`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")结合使用时，[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释的使用方式与[基本关系模式](basic_relationships.html#relationship-patterns)中描述的方式相同。在指定基于集合的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")作为可选关键字参数时，必须传递[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")参数，并且它必须指向要使用的集合类。如果默认值为`None`，则多对一和标量对象引用可以使用[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The above mapping will generate an empty list for `Parent.children` when a new
    `Parent()` object is constructed without passing `children`, and similarly a `None`
    value for `Child.parent` when a new `Child()` object is constructed without passing
    `parent`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造新的`Parent()`对象而不传递`children`时，上述映射将为`Parent.children`生成一个空列表，类似地，当构造新的`Child()`对象而不传递`parent`时，将为`Child.parent`生成一个`None`值。
- en: While the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") can be automatically derived from the given collection
    class of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, this would break compatibility with dataclasses,
    as the presence of [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") or [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") is what determines if the parameter is to be required
    or optional when rendered into the `__init__()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") 可以从 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 自身的给定集合类自动推导出来，但这会破坏与 dataclasses 的兼容性，因为 [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") 或 [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") 的存在决定了参数在转换为 `__init__()` 方法时是必需的还是可选的。
- en: '### Using Non-Mapped Dataclass Fields'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用非映射数据类字段'
- en: 'When using Declarative dataclasses, non-mapped fields may be used on the class
    as well, which will be part of the dataclass construction process but will not
    be mapped. Any field that does not use [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") will be ignored by the mapping process. In the example
    below, the fields `ctrl_one` and `ctrl_two` will be part of the instance-level
    state of the object, but will not be persisted by the ORM:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用声明式数据类时，类上也可以使用非映射字段，这些字段将成为数据类构造过程的一部分，但不会被映射。任何不使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的字段都将被映射过程忽略。在下面的示例中，字段 `ctrl_one` 和 `ctrl_two` 将成为对象的实例级状态的一部分，但不会被
    ORM 持久化：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instance of `Data` above can be created as:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `Data` 实例可以通过以下方式创建：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A more real world example might be to make use of the Dataclasses `InitVar`
    feature in conjunction with the `__post_init__()` feature to receive init-only
    fields that can be used to compose persisted data. In the example below, the `User`
    class is declared using `id`, `name` and `password_hash` as mapped features, but
    makes use of init-only `password` and `repeat_password` fields to represent the
    user creation process (note: to run this example, replace the function `your_crypt_function_here()`
    with a third party crypt function, such as [bcrypt](https://pypi.org/project/bcrypt/)
    or [argon2-cffi](https://pypi.org/project/argon2-cffi/)):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 更现实的例子可能是结合使用 Dataclasses 的 `InitVar` 特性和 `__post_init__()` 特性来接收只初始化的字段，这些字段可以用来组成持久化数据。在下面的示例中，`User`
    类使用 `id`、`name` 和 `password_hash` 作为映射特性，但使用只初始化的 `password` 和 `repeat_password`
    字段来表示用户创建过程（注意：在运行此示例时，请将函数 `your_crypt_function_here()` 替换为第三方加密函数，例如 [bcrypt](https://pypi.org/project/bcrypt/)
    或 [argon2-cffi](https://pypi.org/project/argon2-cffi/)）：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The above object is created with parameters `password` and `repeat_password`,
    which are consumed up front so that the `password_hash` variable may be generated:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对象使用了 `password` 和 `repeat_password` 参数，这些参数被提前使用，以便生成 `password_hash` 变量：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Changed in version 2.0.0rc1: When using [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") or [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), fields that do not include the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be included, which will be treated as
    part of the resulting dataclass but not be mapped, without the need to also indicate
    the `__allow_unmapped__` class attribute. Previous 2.0 beta releases would require
    this attribute to be explicitly present, even though the purpose of this attribute
    was only to allow legacy ORM typed mappings to continue to function.  ### Integrating
    with Alternate Dataclass Providers such as Pydantic'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '从版本 2.0.0rc1 起发生了变化：当使用 [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") 或 [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") 时，不包含 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 注解的字段可能会被包括在内，这些字段将被视为结果数据类的一部分，但不会被映射，无需指定 `__allow_unmapped__`
    类属性也可以。以前的 2.0 beta 版本需要显式地包含此属性，即使此属性的目的仅是为了使传统的 ORM 类型映射继续正常工作。  ### 与 Pydantic
    等备选数据类提供程序集成'
- en: Warning
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The dataclass layer of Pydantic is **not fully compatible** with SQLAlchemy’s
    class instrumentation without additional internal changes, and many features such
    as related collections may not work correctly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic的数据类层与SQLAlchemy的类仪器不完全兼容，除非进行额外的内部更改，否则许多功能，如相关集合，可能无法正常工作。
- en: For Pydantic compatibility, please consider the [SQLModel](https://sqlmodel.tiangolo.com)
    ORM which is built with Pydantic on top of SQLAlchemy ORM, which includes special
    implementation details which **explicitly resolve** these incompatibilities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Pydantic兼容，请考虑使用基于SQLAlchemy ORM构建的[SQLModel](https://sqlmodel.tiangolo.com)
    ORM，该ORM包含专门解决这些不兼容性的实现细节。
- en: 'SQLAlchemy’s [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") class and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") method call directly into the Python
    standard library `dataclasses.dataclass` class decorator, after the declarative
    mapping process has been applied to the class. This function call may be swapped
    out for alternateive dataclasses providers, such as that of Pydantic, using the
    `dataclass_callable` parameter accepted by [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") as a class keyword argument as well as by
    [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")类和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")方法直接调用Python标准库的`dataclasses.dataclass`类装饰器，此操作在将声明性映射过程应用于类之后进行。此函数调用可以通过[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")作为类关键字参数以及[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")接受的`dataclass_callable`参数进行替换，以使用Pydantic等替代数据类提供程序：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The above `User` class will be applied as a dataclass, using Pydantic’s `pydantic.dataclasses.dataclasses`
    callable. The process is available both for mapped classes as well as mixins that
    extend from [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or which have [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") applied directly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`User`类将被应用为数据类，使用Pydantic的`pydantic.dataclasses.dataclasses`可调用。该过程既适用于映射类，也适用于从[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")扩展或直接应用[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")的混入。
- en: 'New in version 2.0.4: Added the `dataclass_callable` class and method parameters
    for [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), and adjusted some of the dataclass
    internals to accommodate more strict dataclass functions such as that of Pydantic.  ##
    Applying ORM Mappings to an existing dataclass (legacy dataclass use)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能版本2.0.4：为[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")添加了`dataclass_callable`类和方法参数，并调整了一些数据类内部，以适应更严格的数据类功能，例如Pydantic的功能。##
    将ORM映射应用于现有数据类（旧版数据类用法）
- en: Legacy Feature
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留特性
- en: The approaches described here are superseded by the [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses)
    feature new in the 2.0 series of SQLAlchemy. This newer version of the feature
    builds upon the dataclass support first added in version 1.4, which is described
    in this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此处描述的方法已被2.0系列SQLAlchemy中的[声明性数据类映射](#orm-declarative-native-dataclasses)功能取代。这一更新版本的功能是建立在首次添加到1.4版本的数据类支持之上的，该支持在本节中进行了描述。
- en: 'To map an existing dataclass, SQLAlchemy’s “inline” declarative directives
    cannot be used directly; ORM directives are assigned using one of three techniques:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要映射现有的数据类，不能直接使用SQLAlchemy的“内联”声明性指令；ORM指令通过以下三种技术之一分配：
- en: Using “Declarative with Imperative Table”, the table / column to be mapped is
    defined using a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object assigned to the `__table__` attribute of the class; relationships are defined
    within `__mapper_args__` dictionary. The class is mapped using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator. An example is below at [Mapping pre-existing
    dataclasses using Declarative With Imperative Table](#orm-declarative-dataclasses-imperative-table).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“具有命令式表”的方法，要映射的表/列是使用分配给类的`__table__`属性的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象来定义的；关系在`__mapper_args__`字典中定义。使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器对类进行映射。以下是一个示例，位于[使用具有命令式表的预先存在的数据类进行映射](#orm-declarative-dataclasses-imperative-table)。
- en: Using full “Declarative”, the Declarative-interpreted directives such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are added to the `.metadata` dictionary of the
    `dataclasses.field()` construct, where they are consumed by the declarative process.
    The class is again mapped using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator. See the example below at [Mapping
    pre-existing dataclasses using Declarative-style fields](#orm-declarative-dataclasses-declarative-table).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完全“声明式”方法，Declarative解释的指令，如[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")被添加到`dataclasses.field()`构造函数的`.metadata`字典中，它们被声明性过程使用。再次使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器对类进行映射。请参见下面的示例，在[使用声明式样式字段映射预先存在的数据类](#orm-declarative-dataclasses-declarative-table)。
- en: An “Imperative” mapping can be applied to an existing dataclass using the [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method to produce the mapping in exactly
    the same way as described at [Imperative Mapping](mapping_styles.html#orm-imperative-mapping).
    This is illustrated below at [Mapping pre-existing dataclasses using Imperative
    Mapping](#orm-imperative-dataclasses).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")方法将“命令式”映射应用到现有的数据类上，以完全相同的方式生成映射，就像在[命令式映射](mapping_styles.html#orm-imperative-mapping)中描述的那样。下面在[使用命令式映射映射预先存在的数据类](#orm-imperative-dataclasses)中进行了说明。
- en: The general process by which SQLAlchemy applies mappings to a dataclass is the
    same as that of an ordinary class, but also includes that SQLAlchemy will detect
    class-level attributes that were part of the dataclasses declaration process and
    replace them at runtime with the usual SQLAlchemy ORM mapped attributes. The `__init__`
    method that would have been generated by dataclasses is left intact, as is the
    same for all the other methods that dataclasses generates such as `__eq__()`,
    `__repr__()`, etc.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy将映射应用到数据类的一般过程与普通类的过程相同，但还包括SQLAlchemy将检测到的类级属性，这些属性是数据类声明过程的一部分，并在运行时用通常的SQLAlchemy
    ORM映射属性替换它们。由数据类生成的`__init__`方法保持不变，以及数据类生成的所有其他方法，如`__eq__()`，`__repr__()`等。
- en: '### Mapping pre-existing dataclasses using Declarative With Imperative Table'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用具有命令式表的预先存在的数据类进行映射'
- en: 'An example of a mapping using `@dataclass` using [Declarative with Imperative
    Table (a.k.a. Hybrid Declarative)](declarative_tables.html#orm-imperative-table-configuration)
    is below. A complete [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed explicitly and assigned to the `__table__` attribute. Instance
    fields are defined using normal dataclass syntaxes. Additional [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") definitions such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), are placed in the [__mapper_args__](declarative_config.html#orm-declarative-mapper-options)
    class-level dictionary underneath the `properties` key, corresponding to the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用[带命令式表的声明式（即混合声明）](declarative_tables.html#orm-imperative-table-configuration)的`@dataclass`进行映射的示例。一个完整的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象被显式地构建并分配给`__table__`属性。使用普通数据类语法定义实例字段。其他[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")定义，如[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，放置在类级别的字典[__mapper_args__](declarative_config.html#orm-declarative-mapper-options)中，位于`properties`键下，对应于[`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper")参数：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the above example, the `User.id`, `Address.id`, and `Address.user_id` attributes
    are defined as `field(init=False)`. This means that parameters for these won’t
    be added to `__init__()` methods, but [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will still be able to set them after getting their values
    during flush from autoincrement or other default value generator. To allow them
    to be specified in the constructor explicitly, they would instead be given a default
    value of `None`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`User.id`、`Address.id`和`Address.user_id`属性被定义为`field(init=False)`。这意味着这些参数不会被添加到`__init__()`方法中，但[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")仍然可以在获取它们的值后通过自动增量或其他默认值生成器进行刷新时设置它们。要允许在构造函数中显式指定它们，它们将被赋予`None`的默认值。
- en: For a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    to be declared separately, it needs to be specified directly within the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") dictionary which itself is specified within the `__mapper_args__`
    dictionary, so that it is passed to the constructor for [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"). An alternative to this approach is in the next example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独声明一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，需要直接在[`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper")字典中指定它，该字典本身是在`__mapper_args__`字典中指定的，以便将其传递给[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")的构造函数。这种方法的另一种选择在下一个示例中。
- en: Warning
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Declaring a dataclass `field()` setting a `default` together with `init=False`
    will not work as would be expected with a totally plain dataclass, since the SQLAlchemy
    class instrumentation will replace the default value set on the class by the dataclass
    creation process. Use `default_factory` instead. This adaptation is done automatically
    when making use of [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).  ###
    Mapping pre-existing dataclasses using Declarative-style fields'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`default`设置一个`default`与`init=False`的数据类字段()将不像预期的那样与完全普通的数据类一起工作，因为SQLAlchemy类工具将替换数据类创建过程中在类上设置的默认值。而是使用`default_factory`。当使用[声明性数据类映射](#orm-declarative-native-dataclasses)时，此适应过程会自动完成。###
    使用声明式字段映射现有数据类
- en: Legacy Feature
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留功能
- en: This approach to Declarative mapping with dataclasses should be considered as
    legacy. It will remain supported however is unlikely to offer any advantages against
    the new approach detailed at [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类进行声明性映射的这种方法应被视为遗留。它将继续受支持，但不太可能提供任何优势，与[声明性数据类映射](#orm-declarative-native-dataclasses)中详细描述的新方法相比。
- en: Note that **mapped_column() is not supported with this use**; the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct should continue to be used to declare table
    metadata within the `metadata` field of `dataclasses.field()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**不支持使用mapped_column()**; 应继续使用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")构造在`dataclasses.field()`的`metadata`字段中声明表元数据。
- en: 'The fully declarative approach requires that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are declared as class attributes, which when
    using dataclasses would conflict with the dataclass-level attributes. An approach
    to combine these together is to make use of the `metadata` attribute on the `dataclass.field`
    object, where SQLAlchemy-specific mapping information may be supplied. Declarative
    supports extraction of these parameters when the class specifies the attribute
    `__sa_dataclass_metadata_key__`. This also provides a more succinct method of
    indicating the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") association:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完全的声明性方法要求[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象被声明为类属性，而在使用数据类时会与数据类级别的属性冲突。将这些内容结合在一起的一种方法是利用`dataclass.field`对象上的`metadata`属性，其中可以提供特定于SQLAlchemy的映射信息。当类指定属性`__sa_dataclass_metadata_key__`时，声明性支持提取这些参数。这也提供了一种更简洁的方法来指示[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")关联：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#### Using Declarative Mixins with pre-existing dataclasses'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用声明性混合类型与预先存在的数据类'
- en: 'In the section [Composing Mapped Hierarchies with Mixins](declarative_mixins.html),
    Declarative Mixin classes are introduced. One requirement of declarative mixins
    is that certain constructs that can’t be easily duplicated must be given as callables,
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator, such as in the example at [Mixing in Relationships](declarative_mixins.html#orm-declarative-mixins-relationships):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用混合类型构成映射层次结构](declarative_mixins.html)部分中，引入了声明性混合类型类。声明性混合类型的一个要求是，某些不能轻易复制的构造必须作为可调用对象给出，使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰器，例如在[混合关系](declarative_mixins.html#orm-declarative-mixins-relationships)示例中：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This form is supported within the Dataclasses `field()` object by using a lambda
    to indicate the SQLAlchemy construct inside the `field()`. Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to surround the lambda is optional. If we wanted
    to produce our `User` class above where the ORM fields came from a mixin that
    is itself a dataclass, the form would be:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据类`field()`对象中，通过使用lambda表示SQLAlchemy构造来支持此形式。使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")将lambda包围起来是可选的。如果我们想要生成上面的`User`类，其中ORM字段来自一个本身就是数据类的mixin，形式将是：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'New in version 1.4.2: Added support for “declared attr” style mixin attributes,
    namely [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs as well as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with foreign key declarations, to be used
    within “Dataclasses with Declarative Table” style mappings.  ### Mapping pre-existing
    dataclasses using Imperative Mapping'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4.2中：为“声明属性”样式的mixin属性增加了支持，即[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造以及带有外键声明的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，用于在“带有声明性表格的数据类”样式映射中使用。### 使用命令式映射映射预先存在的数据类
- en: 'As described previously, a class which is set up as a dataclass using the `@dataclass`
    decorator can then be further decorated using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator in order to apply declarative-style
    mapping to the class. As an alternative to using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator, we may also pass the class through
    the [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method instead, so that we may pass
    all [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    configuration imperatively to the function rather than having them defined on
    the class itself as class variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 `@dataclass` 装饰器设置为 dataclass 的类可以进一步使用 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器进行装饰，以便对类应用声明式样式的映射。作为使用 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器的替代方案，我们也可以将类通过 [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") 方法传递，这样我们就可以将所有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 和 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 的配置以命令方式传递给函数，而不是将它们定义为类变量：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The same warning mentioned in [Mapping pre-existing dataclasses using Declarative
    With Imperative Table](#orm-declarative-dataclasses-imperative-table) applies
    when using this mapping style.  ## Applying ORM mappings to an existing attrs
    class'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此映射样式时，请注意 [Mapping pre-existing dataclasses using Declarative With Imperative
    Table](#orm-declarative-dataclasses-imperative-table) 中提到的相同警告。## 对现有 attrs 类应用
    ORM 映射
- en: The [attrs](https://pypi.org/project/attrs/) library is a popular third party
    library that provides similar features as dataclasses, with many additional features
    provided not found in ordinary dataclasses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[attrs](https://pypi.org/project/attrs/) 库是一个流行的第三方库，提供了类似 dataclasses 的功能，并提供了许多普通
    dataclasses 中没有的附加功能。'
- en: A class augmented with [attrs](https://pypi.org/project/attrs/) uses the `@define`
    decorator. This decorator initiates a process to scan the class for attributes
    that define the class’ behavior, which are then used to generate methods, documentation,
    and annotations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [attrs](https://pypi.org/project/attrs/) 扩展的类使用 `@define` 装饰器。该装饰器启动一个过程来扫描类以定义类的行为的属性，然后用于生成方法、文档和注释。
- en: The SQLAlchemy ORM supports mapping an [attrs](https://pypi.org/project/attrs/)
    class using **Declarative with Imperative Table** or **Imperative** mapping. The
    general form of these two styles is fully equivalent to the [Mapping pre-existing
    dataclasses using Declarative-style fields](#orm-declarative-dataclasses-declarative-table)
    and [Mapping pre-existing dataclasses using Declarative With Imperative Table](#orm-declarative-dataclasses-imperative-table)
    mapping forms used with dataclasses, where the inline attribute directives used
    by dataclasses or attrs are unchanged, and SQLAlchemy’s table-oriented instrumentation
    is applied at runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 支持使用 **Declarative with Imperative Table** 或 **Imperative** 映射来映射
    [attrs](https://pypi.org/project/attrs/) 类。这两种样式的一般形式与用于 dataclasses 的 [Mapping
    pre-existing dataclasses using Declarative-style fields](#orm-declarative-dataclasses-declarative-table)
    和 [Mapping pre-existing dataclasses using Declarative With Imperative Table](#orm-declarative-dataclasses-imperative-table)
    映射形式完全等效，其中 dataclasses 或 attrs 使用的内联属性指令保持不变，并且 SQLAlchemy 的面向表的仪器化在运行时应用。
- en: The `@define` decorator of [attrs](https://pypi.org/project/attrs/) by default
    replaces the annotated class with a new __slots__ based class, which is not supported.
    When using the old style annotation `@attr.s` or using `define(slots=False)`,
    the class does not get replaced. Furthermore attrs removes its own class-bound
    attributes after the decorator runs, so that SQLAlchemy’s mapping process takes
    over these attributes without any issue. Both decorators, `@attr.s` and `@define(slots=False)`
    work with SQLAlchemy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[attrs](https://pypi.org/project/attrs/) 的 `@define` 装饰器默认用基于新 __slots__ 的类替换带注释的类，这是不支持的。当使用旧样式注释
    `@attr.s` 或使用 `define(slots=False)` 时，类不会被替换。此外，attrs 在装饰器运行后移除其自己的类绑定属性，以便 SQLAlchemy
    的映射过程接管这些属性而不会出现任何问题。`@attr.s` 和 `@define(slots=False)` 这两个装饰器都与 SQLAlchemy 兼容。'
- en: Mapping attrs with Declarative “Imperative Table”
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Declarative “Imperative Table” 映射 attrs
- en: 'In the “Declarative with Imperative Table” style, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object is declared inline with the declarative class.
    The `@define` decorator is applied to the class first, then the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator second:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在“声明式与命令式表”风格中，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象与声明式类内联声明。首先将 `@define` 装饰器应用于类，然后将[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器应用于类：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `attrs` `slots=True` option, which enables `__slots__` on a mapped class,
    cannot be used with SQLAlchemy mappings without fully implementing alternative
    [attribute instrumentation](examples.html#examples-instrumentation), as mapped
    classes normally rely upon direct access to `__dict__` for state storage. Behavior
    is undefined when this option is present.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrs`的`slots=True`选项，该选项在映射类上启用`__slots__`，不能与SQLAlchemy映射一起使用，除非完全实现了替代的[属性仪器化](examples.html#examples-instrumentation)，因为映射类通常依赖于对`__dict__`的直接访问来存储状态。当此选项存在时，行为是未定义的。'
- en: Mapping attrs with Imperative Mapping
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令式映射映射 attrs
- en: 'Just as is the case with dataclasses, we can make use of [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") to map an existing `attrs` class as
    well:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对待 dataclasses 一样，我们可以利用[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")来将现有的 `attrs` 类映射为：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The above form is equivalent to the previous example using Declarative with
    Imperative Table.  ## Declarative Dataclass Mapping'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式等同于之前使用声明式与命令式表的示例。## 声明式数据类映射
- en: SQLAlchemy [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mappings may be augmented with an additional mixin class or decorator directive,
    which will add an additional step to the Declarative process after the mapping
    is complete that will convert the mapped class **in-place** into a Python [dataclass](https://docs.python.org/3/library/dataclasses.html),
    before completing the mapping process which applies ORM-specific [instrumentation](../glossary.html#term-instrumentation)
    to the class. The most prominent behavioral addition this provides is generation
    of an `__init__()` method with fine-grained control over positional and keyword
    arguments with or without defaults, as well as generation of methods like `__repr__()`
    and `__eq__()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy [带注释的声明表](declarative_tables.html#orm-declarative-mapped-column)映射可以通过附加的
    mixin 类或装饰器指令来增强，这将在映射完成后的声明过程中添加一个额外的步骤，将映射的类**原地**转换为 Python [dataclass](https://docs.python.org/3/library/dataclasses.html)，然后完成应用于类的
    ORM 特定[仪器化](../glossary.html#term-instrumentation)过程。这提供的最突出的行为增强是生成具有对位置和关键字参数的细粒度控制的`__init__()`方法，有或没有默认值，以及生成诸如`__repr__()`和`__eq__()`之类的方法。
- en: From a [**PEP 484**](https://peps.python.org/pep-0484/) typing perspective,
    the class is recognized as having Dataclass-specific behaviors, most notably by
    taking advantage of [**PEP 681**](https://peps.python.org/pep-0681/) “Dataclass
    Transforms”, which allows typing tools to consider the class as though it were
    explicitly decorated using the `@dataclasses.dataclass` decorator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从[**PEP 484**](https://peps.python.org/pep-0484/)的类型学角度来看，该类被认为具有 Dataclass
    特定的行为，最值得注意的是通过利用[**PEP 681**](https://peps.python.org/pep-0681/)“Dataclass Transforms”，这允许类型工具将该类视为明确使用`@dataclasses.dataclass`装饰器装饰的类。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Support for [**PEP 681**](https://peps.python.org/pep-0681/) in typing tools
    as of **April 4, 2023** is limited and is currently known to be supported by [Pyright](https://github.com/microsoft/pyright)
    as well as [Mypy](https://mypy.readthedocs.io/en/stable/) as of **version 1.2**.
    Note that Mypy 1.1.1 introduced [**PEP 681**](https://peps.python.org/pep-0681/)
    support but did not correctly accommodate Python descriptors which will lead to
    errors when using SQLAlchemy’s ORM mapping scheme.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 截至**2023年4月4日**，在类型工具中支持[**PEP 681**](https://peps.python.org/pep-0681/)的情况是有限的，并且目前已知被[Pyright](https://github.com/microsoft/pyright)以及**1.2版**的[Mypy](https://mypy.readthedocs.io/en/stable/)支持。请注意，Mypy
    1.1.1引入了[**PEP 681**](https://peps.python.org/pep-0681/)支持，但未正确适应Python描述符，这将导致在使用SQLAlchemy的ORM映射方案时出现错误。
- en: See also
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://peps.python.org/pep-0681/#the-dataclass-transform-decorator](https://peps.python.org/pep-0681/#the-dataclass-transform-decorator)
    - background on how libraries like SQLAlchemy enable [**PEP 681**](https://peps.python.org/pep-0681/)
    support'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://peps.python.org/pep-0681/#the-dataclass-transform-decorator](https://peps.python.org/pep-0681/#the-dataclass-transform-decorator)
    - 背景介绍了像 SQLAlchemy 这样的库如何启用 [**PEP 681**](https://peps.python.org/pep-0681/)
    支持'
- en: Dataclass conversion may be added to any Declarative class either by adding
    the [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    mixin to a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class hierarchy, or for decorator mapping by
    using the [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") class decorator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类转换可以通过将 [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin 添加到 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类层次结构中的任何声明性类来实现，或者通过使用 [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") 类装饰器来进行装饰映射。
- en: 'The [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin may be applied either to the Declarative
    `Base` class or any superclass, as in the example below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    mixin 可以应用于声明性的 `Base` 类或任何超类，如下例所示：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or may be applied directly to classes that extend from the Declarative base:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接应用于从声明性基类扩展的类：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When using the decorator form, only the [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator is supported:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器形式时，仅支持 [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") 装饰器：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Class level feature configuration
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类级别的功能配置
- en: Support for dataclasses features is partial. Currently **supported** are the
    `init`, `repr`, `eq`, `order` and `unsafe_hash` features, `match_args` and `kw_only`
    are supported on Python 3.10+. Currently **not supported** are the `frozen` and
    `slots` features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类功能的支持是部分的。目前支持的是`init`、`repr`、`eq`、`order`和`unsafe_hash`功能，`match_args` 和
    `kw_only`在 Python 3.10+ 上支持。目前不支持的是 `frozen` 和 `slots` 功能。
- en: 'When using the mixin class form with [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), class configuration arguments are passed
    as class-level parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") 的 mixin 类形式时，类配置参数作为类级别参数传递：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When using the decorator form with [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), class configuration arguments
    are passed to the decorator directly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") 的装饰器形式时，类配置参数直接传递给装饰器：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For background on dataclass class options, see the [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    documentation at [@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有关数据类选项的背景，请参阅 [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    文档中的 [@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass).
- en: Attribute Configuration
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性配置
- en: SQLAlchemy native dataclasses differ from normal dataclasses in that attributes
    to be mapped are described using the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic annotation container in all cases. Mappings follow
    the same forms as those documented at [Declarative Table with mapped_column()](declarative_tables.html#orm-declarative-table),
    and all features of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") are supported.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 原生数据类与普通数据类不同之处在于，要映射的属性在所有情况下都是使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 泛型注释容器描述的。映射遵循与 [声明性表格与 mapped_column()](declarative_tables.html#orm-declarative-table)
    中记录的相同形式，所有 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 和 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的功能都得到支持。
- en: 'Additionally, ORM attribute configuration constructs including [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") support **per-attribute field options**, including
    `init`, `default`, `default_factory` and `repr`. The names of these arguments
    is fixed as specified in [**PEP 681**](https://peps.python.org/pep-0681/). Functionality
    is equivalent to dataclasses:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ORM属性配置构造，包括[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 支持**每个属性字段选项**，包括`init`，`default`，`default_factory`和`repr`。这些参数的名称固定为[**PEP
    681**](https://peps.python.org/pep-0681/)中指定的名称。功能等同于dataclasses：
- en: '`init`, as in [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"), [`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship"), if False indicates the field should not be part
    of the `__init__()` method'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`，如[`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")，[`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship")，如果为False，则表示该字段不应该是`__init__()`方法的一部分'
- en: '`default`, as in [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") indicates a default value for the field as given
    as a keyword argument in the `__init__()` method.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`，如[`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column")，[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")，表示字段的默认值，可以作为关键字参数在`__init__()`方法中传递。'
- en: '`default_factory`, as in [`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column"), [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship"), indicates a callable function that will be invoked
    to generate a new default value for a parameter if not passed explicitly to the
    `__init__()` method.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory`，如[`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column")，[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")，表示一个可调用函数，如果未明确传递给`__init__()`方法，则会调用它生成新的默认值。'
- en: '`repr` True by default, indicates the field should be part of the generated
    `__repr__()` method'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr` 默认为True，表示该字段应该是生成的`__repr__()`方法的一部分'
- en: Another key difference from dataclasses is that default values for attributes
    **must** be configured using the `default` parameter of the ORM construct, such
    as `mapped_column(default=None)`. A syntax that resembles dataclass syntax which
    accepts simple Python values as defaults without using `@dataclases.field()` is
    not supported.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与dataclasses的另一个关键区别是，属性的默认值**必须**使用ORM构造函数的`default`参数进行配置，例如`mapped_column(default=None)`。不支持类似dataclass语法的语法，该语法接受简单的Python值作为默认值，而不使用`@dataclases.field()`。
- en: 'As an example using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), the mapping below will produce an `__init__()`
    method that accepts only the fields `name` and `fullname`, where `name` is required
    and may be passed positionally, and `fullname` is optional. The `id` field, which
    we expect to be database-generated, is not part of the constructor at all:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")的示例，下面的映射将生成一个仅接受字段`name`和`fullname`的`__init__()`方法，其中`name`是必需的，可以按位置传递，而`fullname`是可选的。我们预期会从数据库生成`id`字段，根本不是构造函数的一部分：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Column Defaults
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列默认值
- en: 'In order to accommodate the name overlap of the `default` argument with the
    existing [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct disambiguates the two names by adding
    a new parameter [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column"), which will be populated directly into the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), independently of what may be set on [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), which is always used for the dataclasses configuration.
    For example, to configure a datetime column with a [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") set to the `func.utc_timestamp()` SQL function, but
    where the parameter is optional in the constructor:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 `default` 参数与现有 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 参数之间的名称重叠，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造通过添加一个新参数 [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column") 来消除这两个名称的歧义，该参数将直接填充到 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 参数中，并且独立于在 [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column") 上设置的内容，后者始终用于数据类配置。例如，配置一个带有 `func.utc_timestamp()`
    SQL 函数作为 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 的日期时间列，但在构造函数中该参数是可选的：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the above mapping, an `INSERT` for a new `User` object where no parameter
    for `created_at` were passed proceeds as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，对于未传递任何 `created_at` 参数的新 `User` 对象的 `INSERT` 如下进行：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Integration with Annotated
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 Annotated 的集成
- en: 'The approach introduced at [Mapping Whole Column Declarations to Python Types](declarative_tables.html#orm-declarative-mapped-column-pep593)
    illustrates how to use [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    objects to package whole [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs for re-use. This feature is supported
    with the dataclasses feature. One aspect of the feature however requires a workaround
    when working with typing tools, which is that the [**PEP 681**](https://peps.python.org/pep-0681/)-specific
    arguments `init`, `default`, `repr`, and `default_factory` **must** be on the
    right hand side, packaged into an explicit [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in order for the typing tool to interpret
    the attribute correctly. As an example, the approach below will work perfectly
    fine at runtime, however typing tools will consider the `User()` construction
    to be invalid, as they do not see the `init=False` parameter present:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[将整个列声明映射到 Python 类型](declarative_tables.html#orm-declarative-mapped-column-pep593)
    中介绍的方法演示了如何使用 [**PEP 593**](https://peps.python.org/pep-0593/) 的 `Annotated` 对象来打包整个
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造以便重用。该功能支持使用数据类特性。然而，该特性的一个方面在与类型工具一起使用时需要一种解决方法，即必须将 [**PEP 681**](https://peps.python.org/pep-0681/)
    中的参数 `init`、`default`、`repr` 和 `default_factory` **必须** 放在右侧，并打包到一个明确的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造中，以便类型工具正确解释属性。例如，下面的方法在运行时完全正常，但是类型工具将认为 `User()`
    构造无效，因为它们看不到 `init=False` 参数：'
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") must be present on the right side as well with
    an explicit setting for [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"); the other arguments can remain within the `Annotated`
    construct:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    必须出现在右侧，并且使用明确设置的 [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")；其他参数可以保留在 `Annotated` 结构内：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '### Using mixins and abstract superclasses'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用混入和抽象超类'
- en: 'Any mixins or base classes that are used in a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mapped class which include [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") attributes must themselves be part of a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") hierarchy, such as in the example below using
    a mixin:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")映射类中使用的任何混入或基类，其中包括[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")属性，必须本身是 [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")层次结构的一部分，例如下面的示例使用混入：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Python type checkers which support [**PEP 681**](https://peps.python.org/pep-0681/)
    will otherwise not consider attributes from non-dataclass mixins to be part of
    the dataclass.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 [**PEP 681**](https://peps.python.org/pep-0681/) 的 Python 类型检查器将否则不会认为来自非数据类混入的属性属于数据类的一部分。
- en: 'Deprecated since version 2.0.8: Using mixins and abstract bases within [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") hierarchies which are not themselves
    dataclasses is deprecated, as these fields are not supported by [**PEP 681**](https://peps.python.org/pep-0681/)
    as belonging to the dataclass. A warning is emitted for this case which will later
    be an error.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.0.8 版开始已弃用：在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")或[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")层次结构中使用混入和抽象基类，这些结构本身不是数据类已被弃用，因为这些字段不被
    [**PEP 681**](https://peps.python.org/pep-0681/) 视为数据类的一部分。对于这种情况会发出警告，稍后将成为错误。
- en: See also
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[When transforming <cls> to a dataclass, attribute(s) originate from superclass
    <cls> which is not a dataclass.](../errors.html#error-dcmx) - background on rationale'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[将<cls>转换为数据类时，属性来自非数据类的超类<cls>。](../errors.html#error-dcmx) - 关于原因的背景'
- en: Relationship Configuration
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系配置
- en: 'The [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation in combination with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is used in the same way as described at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns). When specifying
    a collection-based [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as an optional keyword argument, the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") parameter must be passed and it must refer to the
    collection class that’s to be used. Many-to-one and scalar object references may
    make use of [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") if the default value is to be `None`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 注释与
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    结合使用的方式与[基本关系模式](basic_relationships.html#relationship-patterns)中描述的方式相同。当指定基于集合的
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    作为可选关键字参数时，必须传递 [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") 参数，并且它必须引用要使用的集合类。如果默认值为 `None`，则多对一和标量对象引用可以使用
    [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship"):'
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The above mapping will generate an empty list for `Parent.children` when a new
    `Parent()` object is constructed without passing `children`, and similarly a `None`
    value for `Child.parent` when a new `Child()` object is constructed without passing
    `parent`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将在构造新的`Parent()`对象时，如果没有传递`children`参数，则为`Parent.children`生成一个空列表，并且在构造新的`Child()`对象时，如果没有传递`parent`参数，则为`Child.parent`生成一个`None`值。
- en: While the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") can be automatically derived from the given collection
    class of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, this would break compatibility with dataclasses,
    as the presence of [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") or [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") is what determines if the parameter is to be required
    or optional when rendered into the `__init__()` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")可以从[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")自身的给定集合类中自动推导出来，但这将与数据类的兼容性破坏，因为[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")或[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")的存在决定了参数在渲染到`__init__()`方法时是必需还是可选。
- en: '### Using Non-Mapped Dataclass Fields'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用非映射数据类字段'
- en: 'When using Declarative dataclasses, non-mapped fields may be used on the class
    as well, which will be part of the dataclass construction process but will not
    be mapped. Any field that does not use [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") will be ignored by the mapping process. In the example
    below, the fields `ctrl_one` and `ctrl_two` will be part of the instance-level
    state of the object, but will not be persisted by the ORM:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用声明性数据类时，类上也可以使用非映射字段，这些字段将成为数据类构造过程的一部分，但不会被映射。任何未使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的字段都将被映射过程忽略。在下面的示例中，字段`ctrl_one`和`ctrl_two`将成为对象的实例级状态的一部分，但不会由ORM持久化：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instance of `Data` above can be created as:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`Data`实例可以创建为：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A more real world example might be to make use of the Dataclasses `InitVar`
    feature in conjunction with the `__post_init__()` feature to receive init-only
    fields that can be used to compose persisted data. In the example below, the `User`
    class is declared using `id`, `name` and `password_hash` as mapped features, but
    makes use of init-only `password` and `repeat_password` fields to represent the
    user creation process (note: to run this example, replace the function `your_crypt_function_here()`
    with a third party crypt function, such as [bcrypt](https://pypi.org/project/bcrypt/)
    or [argon2-cffi](https://pypi.org/project/argon2-cffi/)):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更实际的例子可能是结合数据类的`InitVar`特性和`__post_init__()`特性来接收仅初始化字段，这些字段可用于组成持久化数据。在下面的示例中，`User`类使用`id`、`name`和`password_hash`作为映射特性，但使用仅初始化的`password`和`repeat_password`字段表示用户创建过程（注意：要运行此示例，请将函数`your_crypt_function_here()`替换为第三方加密函数，如[bcrypt](https://pypi.org/project/bcrypt/)或[argon2-cffi](https://pypi.org/project/argon2-cffi/)）：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The above object is created with parameters `password` and `repeat_password`,
    which are consumed up front so that the `password_hash` variable may be generated:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对象使用参数`password`和`repeat_password`创建，这些参数被立即消耗，以便生成`password_hash`变量：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Changed in version 2.0.0rc1: When using [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") or [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), fields that do not include the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be included, which will be treated as
    part of the resulting dataclass but not be mapped, without the need to also indicate
    the `__allow_unmapped__` class attribute. Previous 2.0 beta releases would require
    this attribute to be explicitly present, even though the purpose of this attribute
    was only to allow legacy ORM typed mappings to continue to function.  ### Integrating
    with Alternate Dataclass Providers such as Pydantic'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0.0rc1开始更改：当使用[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")或[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")时，可以包括不包括[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释的字段，这些字段将被视为生成的数据类的一部分，但不会被映射，无需指定`__allow_unmapped__`类属性。以前的2.0
    beta版本将要求明确存在此属性，即使此属性的目的仅是允许旧版ORM类型映射继续运行。### 与诸如Pydantic等替代数据类提供者集成
- en: Warning
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The dataclass layer of Pydantic is **not fully compatible** with SQLAlchemy’s
    class instrumentation without additional internal changes, and many features such
    as related collections may not work correctly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 的 dataclass 层与 SQLAlchemy 的类仪器化不完全兼容，需要额外的内部更改，许多功能，例如相关集合，可能无法正常工作。
- en: For Pydantic compatibility, please consider the [SQLModel](https://sqlmodel.tiangolo.com)
    ORM which is built with Pydantic on top of SQLAlchemy ORM, which includes special
    implementation details which **explicitly resolve** these incompatibilities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Pydantic兼容，请考虑使用[SQLModel](https://sqlmodel.tiangolo.com) ORM，该 ORM 基于 SQLAlchemy
    ORM 构建，使用 Pydantic，其中包括明确解决这些不兼容性的特殊实现细节。
- en: 'SQLAlchemy’s [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") class and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") method call directly into the Python
    standard library `dataclasses.dataclass` class decorator, after the declarative
    mapping process has been applied to the class. This function call may be swapped
    out for alternateive dataclasses providers, such as that of Pydantic, using the
    `dataclass_callable` parameter accepted by [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") as a class keyword argument as well as by
    [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")类和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")方法调用直接进入 Python 标准库 `dataclasses.dataclass`
    类装饰器，经过类的声明性映射处理后。此函数调用可以通过[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")作为类关键字参数以及[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")接受的`dataclass_callable`参数交换为备用 dataclasses
    提供程序，例如 Pydantic 的提供程序：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The above `User` class will be applied as a dataclass, using Pydantic’s `pydantic.dataclasses.dataclasses`
    callable. The process is available both for mapped classes as well as mixins that
    extend from [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or which have [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") applied directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `User` 类将被应用为一个数据类，使用 Pydantic 的 `pydantic.dataclasses.dataclasses` 可调用。该过程对映射类以及从[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")扩展的混合类或直接应用了[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")的类都可用。
- en: 'New in version 2.0.4: Added the `dataclass_callable` class and method parameters
    for [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), and adjusted some of the dataclass
    internals to accommodate more strict dataclass functions such as that of Pydantic.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.4 中：为[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")添加了 `dataclass_callable` 类和方法参数，并调整了一些数据类内部，以适应更严格的数据类函数，例如
    Pydantic 的函数。
- en: Class level feature configuration
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类级特性配置
- en: Support for dataclasses features is partial. Currently **supported** are the
    `init`, `repr`, `eq`, `order` and `unsafe_hash` features, `match_args` and `kw_only`
    are supported on Python 3.10+. Currently **not supported** are the `frozen` and
    `slots` features.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对 dataclasses 特性的支持是部分的。当前支持的特性包括 `init`、`repr`、`eq`、`order` 和 `unsafe_hash`
    特性，`match_args` 和 `kw_only` 在 Python 3.10+ 上受支持。当前不支持的特性包括 `frozen` 和 `slots`
    特性。
- en: 'When using the mixin class form with [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), class configuration arguments are passed
    as class-level parameters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用与[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")配合使用的混合类形式时，类配置参数被作为类级参数传递：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When using the decorator form with [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), class configuration arguments
    are passed to the decorator directly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用装饰器形式与[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")一起使用时，类配置参数直接传递给装饰器：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For background on dataclass class options, see the [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    documentation at [@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 dataclass 类选项的背景，请参阅[dataclasses](https://docs.python.org/3/library/dataclasses.html)文档中的[@dataclasses.dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass)。
- en: Attribute Configuration
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性配置
- en: SQLAlchemy native dataclasses differ from normal dataclasses in that attributes
    to be mapped are described using the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic annotation container in all cases. Mappings follow
    the same forms as those documented at [Declarative Table with mapped_column()](declarative_tables.html#orm-declarative-table),
    and all features of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") are supported.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 本地 dataclasses 与普通 dataclasses 不同之处在于，要映射的属性在所有情况下都使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")通用注释容器描述。映射遵循与[使用 mapped_column() 声明的声明性表格](declarative_tables.html#orm-declarative-table)文档中记录的相同形式，支持所有[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的功能。
- en: 'Additionally, ORM attribute configuration constructs including [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") support **per-attribute field options**, including
    `init`, `default`, `default_factory` and `repr`. The names of these arguments
    is fixed as specified in [**PEP 681**](https://peps.python.org/pep-0681/). Functionality
    is equivalent to dataclasses:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ORM 属性配置构造包括[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")支持**每个属性字段选项**，包括`init`，`default`，`default_factory`和`repr`。这些参数的名称如[**PEP
    681**](https://peps.python.org/pep-0681/)中指定的那样固定。功能与 dataclasses 等效：
- en: '`init`, as in [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"), [`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship"), if False indicates the field should not be part
    of the `__init__()` method'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`，比如[`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")，[`relationship.init`](relationship_api.html#sqlalchemy.orm.relationship.params.init
    "sqlalchemy.orm.relationship")，如果为 False，表示该字段不应该是`__init__()`方法的一部分。'
- en: '`default`, as in [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") indicates a default value for the field as given
    as a keyword argument in the `__init__()` method.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`，比如[`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column")，[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")，表示字段的默认值，作为`__init__()`方法的关键字参数传递。'
- en: '`default_factory`, as in [`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column"), [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship"), indicates a callable function that will be invoked
    to generate a new default value for a parameter if not passed explicitly to the
    `__init__()` method.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory`，比如[`mapped_column.default_factory`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default_factory
    "sqlalchemy.orm.mapped_column")，[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")，表示一个可调用函数，将被调用以生成一个新的默认值，如果参数未明确传递给`__init__()`方法。'
- en: '`repr` True by default, indicates the field should be part of the generated
    `__repr__()` method'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr` 默认为 True，表示该字段应该是生成的`__repr__()`方法的一部分。'
- en: Another key difference from dataclasses is that default values for attributes
    **must** be configured using the `default` parameter of the ORM construct, such
    as `mapped_column(default=None)`. A syntax that resembles dataclass syntax which
    accepts simple Python values as defaults without using `@dataclases.field()` is
    not supported.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与 dataclasses 的另一个关键区别是，属性的默认值**必须**使用 ORM 构造函数的 `default` 参数进行配置，例如 `mapped_column(default=None)`。不支持接受简单
    Python 值作为默认值的类似 dataclass 语法，而不使用 `@dataclases.field()`。
- en: 'As an example using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), the mapping below will produce an `__init__()`
    method that accepts only the fields `name` and `fullname`, where `name` is required
    and may be passed positionally, and `fullname` is optional. The `id` field, which
    we expect to be database-generated, is not part of the constructor at all:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    的示例，下面的映射将生成一个 `__init__()` 方法，该方法仅接受字段 `name` 和 `fullname`，其中 `name` 是必需的，并且可以按位置传递，而
    `fullname` 是可选的。我们预期的由数据库生成的 `id` 字段根本不是构造函数的一部分：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Column Defaults
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列默认值
- en: 'In order to accommodate the name overlap of the `default` argument with the
    existing [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct disambiguates the two names by adding
    a new parameter [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column"), which will be populated directly into the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), independently of what may be set on [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), which is always used for the dataclasses configuration.
    For example, to configure a datetime column with a [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") set to the `func.utc_timestamp()` SQL function, but
    where the parameter is optional in the constructor:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 `default` 参数与 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 构造函数现有参数的名称重叠，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造函数通过添加一个新参数 [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column") 来消除两个名称之间的歧义，该参数将直接填充到 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 参数中，独立于 [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column") 上的设置，后者始终用于数据类配置。例如，要配置一个 datetime 列，其中 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 设置为 `func.utc_timestamp()` SQL 函数，但构造函数中该参数是可选的：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the above mapping, an `INSERT` for a new `User` object where no parameter
    for `created_at` were passed proceeds as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，对于一个新的 `User` 对象的 `INSERT`，如果没有传递 `created_at` 的参数，操作将如下进行：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Integration with Annotated
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 Annotated 集成
- en: 'The approach introduced at [Mapping Whole Column Declarations to Python Types](declarative_tables.html#orm-declarative-mapped-column-pep593)
    illustrates how to use [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    objects to package whole [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs for re-use. This feature is supported
    with the dataclasses feature. One aspect of the feature however requires a workaround
    when working with typing tools, which is that the [**PEP 681**](https://peps.python.org/pep-0681/)-specific
    arguments `init`, `default`, `repr`, and `default_factory` **must** be on the
    right hand side, packaged into an explicit [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in order for the typing tool to interpret
    the attribute correctly. As an example, the approach below will work perfectly
    fine at runtime, however typing tools will consider the `User()` construction
    to be invalid, as they do not see the `init=False` parameter present:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[将整个列声明映射到 Python 类型](declarative_tables.html#orm-declarative-mapped-column-pep593)介绍的方法说明了如何使用
    [**PEP 593**](https://peps.python.org/pep-0593/) 中的 `Annotated` 对象将整个 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构建打包以供重复使用。此功能支持 dataclasses 功能。然而，该功能的一个方面在使用类型工具时需要一个解决方法，即
    [**PEP 681**](https://peps.python.org/pep-0681/) 特定参数 `init`、`default`、`repr`
    和 `default_factory` **必须** 在右侧，被打包到显式的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构建中，以便类型工具正确解释属性。例如，下面的方法在运行时将完美地工作，但是类型工具会认为
    `User()` 构造无效，因为它们没有看到 `init=False` 参数：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") must be present on the right side as well with
    an explicit setting for [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"); the other arguments can remain within the `Annotated`
    construct:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    必须在右侧也存在，并且必须显式设置 [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")；其他参数可以保留在 `Annotated` 结构中：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Column Defaults
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列默认值
- en: 'In order to accommodate the name overlap of the `default` argument with the
    existing [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct disambiguates the two names by adding
    a new parameter [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column"), which will be populated directly into the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") parameter of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), independently of what may be set on [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column"), which is always used for the dataclasses configuration.
    For example, to configure a datetime column with a [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") set to the `func.utc_timestamp()` SQL function, but
    where the parameter is optional in the constructor:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 `default` 参数与 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 构造函数的现有参数的名称重叠，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造函数通过添加一个新参数 [`mapped_column.insert_default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.insert_default
    "sqlalchemy.orm.mapped_column") 来消除这两个名称之间的歧义，该参数将直接填充到 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 参数中，而与 [`mapped_column.default`](mapping_api.html#sqlalchemy.orm.mapped_column.params.default
    "sqlalchemy.orm.mapped_column") 设置无关，后者始终用于 dataclasses 配置。例如，要配置一个 datetime 列，并将
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 设置为 `func.utc_timestamp()` SQL 函数，但构造函数中该参数是可选的：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With the above mapping, an `INSERT` for a new `User` object where no parameter
    for `created_at` were passed proceeds as:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述映射中，当未传递 `created_at` 参数的情况下，对新的 `User` 对象进行 `INSERT` 操作如下进行：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Integration with Annotated
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 `Annotated` 的集成
- en: 'The approach introduced at [Mapping Whole Column Declarations to Python Types](declarative_tables.html#orm-declarative-mapped-column-pep593)
    illustrates how to use [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    objects to package whole [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs for re-use. This feature is supported
    with the dataclasses feature. One aspect of the feature however requires a workaround
    when working with typing tools, which is that the [**PEP 681**](https://peps.python.org/pep-0681/)-specific
    arguments `init`, `default`, `repr`, and `default_factory` **must** be on the
    right hand side, packaged into an explicit [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, in order for the typing tool to interpret
    the attribute correctly. As an example, the approach below will work perfectly
    fine at runtime, however typing tools will consider the `User()` construction
    to be invalid, as they do not see the `init=False` parameter present:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[将整个列声明映射到Python类型](declarative_tables.html#orm-declarative-mapped-column-pep593)中介绍的方法说明了如何使用[**PEP
    593**](https://peps.python.org/pep-0593/) `Annotated`对象来打包整个[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构以供重用。该功能与数据类功能一起使用。然而，该功能的一个方面在使用类型工具时需要一个解决方法，即[**PEP
    681**](https://peps.python.org/pep-0681/)特定的参数`init`、`default`、`repr`和`default_factory`
    **必须** 在右侧，打包到显式的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造中，以便类型工具正确解释属性。例如，下面的方法在运行时将完美运行，但是类型工具将认为`User()`构造无效，因为它们看不到`init=False`参数的存在：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Instead, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") must be present on the right side as well with
    an explicit setting for [`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column"); the other arguments can remain within the `Annotated`
    construct:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")也必须出现在右侧，并在`Annotated`结构中包含对[`mapped_column.init`](mapping_api.html#sqlalchemy.orm.mapped_column.params.init
    "sqlalchemy.orm.mapped_column")的显式设置；其他参数可以保留在`Annotated`结构中：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '### Using mixins and abstract superclasses'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用混入和抽象超类'
- en: 'Any mixins or base classes that are used in a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mapped class which include [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") attributes must themselves be part of a [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") hierarchy, such as in the example below using
    a mixin:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")映射类中使用的任何混入或基类，其中包括[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")属性，必须本身是[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")层次结构的一部分，例如，在下面的示例中使用混入：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Python type checkers which support [**PEP 681**](https://peps.python.org/pep-0681/)
    will otherwise not consider attributes from non-dataclass mixins to be part of
    the dataclass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型检查器，支持[**PEP 681**](https://peps.python.org/pep-0681/)，否则将不考虑非数据类混入的属性作为数据类的一部分。
- en: 'Deprecated since version 2.0.8: Using mixins and abstract bases within [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") hierarchies which are not themselves
    dataclasses is deprecated, as these fields are not supported by [**PEP 681**](https://peps.python.org/pep-0681/)
    as belonging to the dataclass. A warning is emitted for this case which will later
    be an error.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0.8开始已弃用：在[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")或[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")层次结构中使用混入和抽象基类，这些类本身不是数据类，这是不推荐的，因为这些字段不被[**PEP
    681**](https://peps.python.org/pep-0681/)支持为数据类的一部分。对于这种情况会发出警告，以后会成为错误。
- en: See also
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[When transforming <cls> to a dataclass, attribute(s) originate from superclass
    <cls> which is not a dataclass.](../errors.html#error-dcmx) - background on rationale'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[当将<cls>转换为数据类时，属性源自不是数据类的超类<cls>。](../errors.html#error-dcmx) - 关于原因的背景'
- en: Relationship Configuration
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系配置
- en: 'The [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation in combination with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is used in the same way as described at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns). When specifying
    a collection-based [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as an optional keyword argument, the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") parameter must be passed and it must refer to the
    collection class that’s to be used. Many-to-one and scalar object references may
    make use of [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") if the default value is to be `None`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注解与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")结合使用的方式与[基本关系模式](basic_relationships.html#relationship-patterns)中描述的相同。当将基于集合的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")指定为可选关键字参数时，必须传递[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")参数，并且它必须引用要使用的集合类。如果默认值是`None`，则多对一和标量对象引用可以使用[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship"):'
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The above mapping will generate an empty list for `Parent.children` when a new
    `Parent()` object is constructed without passing `children`, and similarly a `None`
    value for `Child.parent` when a new `Child()` object is constructed without passing
    `parent`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将在构造新的`Parent()`对象时为`Parent.children`生成一个空列表，当构造新的`Child()`对象时，如果不传递`parent`，则`Child.parent`将生成一个`None`值。
- en: While the [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") can be automatically derived from the given collection
    class of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, this would break compatibility with dataclasses,
    as the presence of [`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship") or [`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship") is what determines if the parameter is to be required
    or optional when rendered into the `__init__()` method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")可以自动从[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")本身的给定集合类中派生，但这会与数据类兼容性破坏，因为[`relationship.default_factory`](relationship_api.html#sqlalchemy.orm.relationship.params.default_factory
    "sqlalchemy.orm.relationship")或[`relationship.default`](relationship_api.html#sqlalchemy.orm.relationship.params.default
    "sqlalchemy.orm.relationship")的存在决定了参数在渲染为`__init__()`方法时是必需还是可选。
- en: '### Using Non-Mapped Dataclass Fields'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用非映射数据类字段'
- en: 'When using Declarative dataclasses, non-mapped fields may be used on the class
    as well, which will be part of the dataclass construction process but will not
    be mapped. Any field that does not use [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") will be ignored by the mapping process. In the example
    below, the fields `ctrl_one` and `ctrl_two` will be part of the instance-level
    state of the object, but will not be persisted by the ORM:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用声明性数据类时，也可以在类上使用非映射字段，这些字段将成为数据类构造过程的一部分，但不会被映射。任何不使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的字段都将被映射过程忽略。在下面的示例中，字段`ctrl_one`和`ctrl_two`将成为对象的实例级状态的一部分，但不会被ORM持久化：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Instance of `Data` above can be created as:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`Data`实例可以创建为：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A more real world example might be to make use of the Dataclasses `InitVar`
    feature in conjunction with the `__post_init__()` feature to receive init-only
    fields that can be used to compose persisted data. In the example below, the `User`
    class is declared using `id`, `name` and `password_hash` as mapped features, but
    makes use of init-only `password` and `repeat_password` fields to represent the
    user creation process (note: to run this example, replace the function `your_crypt_function_here()`
    with a third party crypt function, such as [bcrypt](https://pypi.org/project/bcrypt/)
    or [argon2-cffi](https://pypi.org/project/argon2-cffi/)):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更真实的示例可能是结合Dataclasses的`InitVar`特性和`__post_init__()`特性来使用仅初始化的字段，这些字段可以用于组合持久化数据。在下面的示例中，`User`类使用`id`、`name`和`password_hash`作为映射特性声明，但使用了仅初始化的`password`和`repeat_password`字段来表示用户创建过程（注意：要运行此示例，请将函数`your_crypt_function_here()`替换为第三方加密函数，如[bcrypt](https://pypi.org/project/bcrypt/)或[argon2-cffi](https://pypi.org/project/argon2-cffi/)）：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The above object is created with parameters `password` and `repeat_password`,
    which are consumed up front so that the `password_hash` variable may be generated:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对象使用了参数`password`和`repeat_password`，这些参数首先被使用，以便生成`password_hash`变量：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Changed in version 2.0.0rc1: When using [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") or [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), fields that do not include the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be included, which will be treated as
    part of the resulting dataclass but not be mapped, without the need to also indicate
    the `__allow_unmapped__` class attribute. Previous 2.0 beta releases would require
    this attribute to be explicitly present, even though the purpose of this attribute
    was only to allow legacy ORM typed mappings to continue to function.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0.0rc1开始更改：当使用[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")或[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")时，可以包括不包含[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释的字段，这些字段将被视为生成的dataclass的一部分，但不会被映射，无需另外指示`__allow_unmapped__`类属性。先前的2.0
    beta版本将要求明确包含此属性，即使此属性的目的仅是允许旧的ORM类型映射继续工作。
- en: '### Integrating with Alternate Dataclass Providers such as Pydantic'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与Pydantic等替代Dataclass提供程序集成'
- en: Warning
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The dataclass layer of Pydantic is **not fully compatible** with SQLAlchemy’s
    class instrumentation without additional internal changes, and many features such
    as related collections may not work correctly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic的dataclass层与SQLAlchemy的类仪器化**不完全兼容**，需要额外的内部更改，许多功能，如相关集合，可能无法正常工作。
- en: For Pydantic compatibility, please consider the [SQLModel](https://sqlmodel.tiangolo.com)
    ORM which is built with Pydantic on top of SQLAlchemy ORM, which includes special
    implementation details which **explicitly resolve** these incompatibilities.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Pydantic兼容，请考虑使用[SQLModel](https://sqlmodel.tiangolo.com) ORM，它是在SQLAlchemy
    ORM的基础上构建的Pydantic，其中包含了专门解决这些不兼容性的实现细节。
- en: 'SQLAlchemy’s [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") class and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") method call directly into the Python
    standard library `dataclasses.dataclass` class decorator, after the declarative
    mapping process has been applied to the class. This function call may be swapped
    out for alternateive dataclasses providers, such as that of Pydantic, using the
    `dataclass_callable` parameter accepted by [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") as a class keyword argument as well as by
    [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")类和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")方法调用直接进入Python标准库的`dataclasses.dataclass`类装饰器中，声明性映射过程应用到类之后。此函数调用可以用Pydantic等替代数据类提供程序替换，使用[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")作为类关键字参数接受的`dataclass_callable`参数，以及[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")同样接受的参数：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The above `User` class will be applied as a dataclass, using Pydantic’s `pydantic.dataclasses.dataclasses`
    callable. The process is available both for mapped classes as well as mixins that
    extend from [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") or which have [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") applied directly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`User`类将被应用为一个数据类，使用Pydantic的`pydantic.dataclasses.dataclasses`可调用。此过程对于映射类和扩展自[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")或直接应用了[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")的混入类都可用。
- en: 'New in version 2.0.4: Added the `dataclass_callable` class and method parameters
    for [`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass "sqlalchemy.orm.MappedAsDataclass")
    and [`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass"), and adjusted some of the dataclass
    internals to accommodate more strict dataclass functions such as that of Pydantic.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.4版本中的新内容：为[`MappedAsDataclass`](mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")和[`registry.mapped_as_dataclass()`](mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")添加了`dataclass_callable`类和方法参数，并调整了一些数据类内部，以适应更严格的数据类函数，例如Pydantic的函数。
- en: '## Applying ORM Mappings to an existing dataclass (legacy dataclass use)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将ORM映射应用于现有数据类（旧数据类使用）'
- en: Legacy Feature
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留特性
- en: The approaches described here are superseded by the [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses)
    feature new in the 2.0 series of SQLAlchemy. This newer version of the feature
    builds upon the dataclass support first added in version 1.4, which is described
    in this section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的方法已被SQLAlchemy 2.0系列中的[声明性数据类映射](#orm-declarative-native-dataclasses)特性取代。该特性的新版本建立在首次在1.4版本中添加的数据类支持之上，该支持在本节中描述。
- en: 'To map an existing dataclass, SQLAlchemy’s “inline” declarative directives
    cannot be used directly; ORM directives are assigned using one of three techniques:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要映射现有的数据类，不能直接使用SQLAlchemy的“内联”声明性指令；ORM指令是使用以下三种技术之一分配的：
- en: Using “Declarative with Imperative Table”, the table / column to be mapped is
    defined using a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object assigned to the `__table__` attribute of the class; relationships are defined
    within `__mapper_args__` dictionary. The class is mapped using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator. An example is below at [Mapping pre-existing
    dataclasses using Declarative With Imperative Table](#orm-declarative-dataclasses-imperative-table).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“带命令式表”的方法，要映射的表/列是使用分配给类的`__table__`属性的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象定义的；关系在`__mapper_args__`字典中定义。使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器映射类。下面是一个示例，在[使用带命令式表的方式映射预先存在的数据类](#orm-declarative-dataclasses-imperative-table)中。
- en: Using full “Declarative”, the Declarative-interpreted directives such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are added to the `.metadata` dictionary of the
    `dataclasses.field()` construct, where they are consumed by the declarative process.
    The class is again mapped using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator. See the example below at [Mapping
    pre-existing dataclasses using Declarative-style fields](#orm-declarative-dataclasses-declarative-table).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完整的“声明式”，将Declarative解释的指令（例如[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")）添加到`dataclasses.field()`构造函数的`.metadata`字典中，它们将被声明性过程使用。再次使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器映射类。请参见下面的示例，在[使用声明式字段映射预先存在的数据类](#orm-declarative-dataclasses-declarative-table)中。
- en: An “Imperative” mapping can be applied to an existing dataclass using the [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method to produce the mapping in exactly
    the same way as described at [Imperative Mapping](mapping_styles.html#orm-imperative-mapping).
    This is illustrated below at [Mapping pre-existing dataclasses using Imperative
    Mapping](#orm-imperative-dataclasses).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") 方法将“命令式”映射应用于现有数据类，以完全相同的方式生成映射，如[命令式映射](mapping_styles.html#orm-imperative-mapping)中所述。下面在
    [使用命令式映射预存在的数据类](#orm-imperative-dataclasses)中说明。
- en: The general process by which SQLAlchemy applies mappings to a dataclass is the
    same as that of an ordinary class, but also includes that SQLAlchemy will detect
    class-level attributes that were part of the dataclasses declaration process and
    replace them at runtime with the usual SQLAlchemy ORM mapped attributes. The `__init__`
    method that would have been generated by dataclasses is left intact, as is the
    same for all the other methods that dataclasses generates such as `__eq__()`,
    `__repr__()`, etc.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SQLAlchemy 将映射应用于数据类的一般过程与普通类的过程相同，但还包括 SQLAlchemy 将检测到的类级别属性，这些属性是数据类声明过程的一部分，并在运行时用通常的
    SQLAlchemy ORM 映射属性替换它们。数据类生成的 `__init__` 方法保持不变，所有其他由数据类生成的方法，例如 `__eq__()`、`__repr__()`
    等也是如此。
- en: '### Mapping pre-existing dataclasses using Declarative With Imperative Table'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用声明式与命令式表（即混合式声明式）映射预存在的数据类'
- en: 'An example of a mapping using `@dataclass` using [Declarative with Imperative
    Table (a.k.a. Hybrid Declarative)](declarative_tables.html#orm-imperative-table-configuration)
    is below. A complete [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed explicitly and assigned to the `__table__` attribute. Instance
    fields are defined using normal dataclass syntaxes. Additional [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") definitions such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), are placed in the [__mapper_args__](declarative_config.html#orm-declarative-mapper-options)
    class-level dictionary underneath the `properties` key, corresponding to the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 `@dataclass` 和 [使用声明式与命令式表（又名混合式声明式）](declarative_tables.html#orm-imperative-table-configuration)
    进行映射的示例。完整的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象是明确构造的，并分配给 `__table__` 属性。实例字段使用正常的数据类语法进行定义。其他 [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") 定义，如 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，放置在 [__mapper_args__](declarative_config.html#orm-declarative-mapper-options)
    类级别字典中，位于 `properties` 键下，与 [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") 参数对应：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the above example, the `User.id`, `Address.id`, and `Address.user_id` attributes
    are defined as `field(init=False)`. This means that parameters for these won’t
    be added to `__init__()` methods, but [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will still be able to set them after getting their values
    during flush from autoincrement or other default value generator. To allow them
    to be specified in the constructor explicitly, they would instead be given a default
    value of `None`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`User.id`、`Address.id` 和 `Address.user_id` 属性被定义为 `field(init=False)`。这意味着这些参数不会被添加到
    `__init__()` 方法中，但[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仍然能够在从自增或其他默认值生成器刷新时获取它们的值并设置它们。为了允许在构造函数中明确指定它们，它们将被赋予 `None` 的默认值。
- en: For a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    to be declared separately, it needs to be specified directly within the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") dictionary which itself is specified within the `__mapper_args__`
    dictionary, so that it is passed to the constructor for [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"). An alternative to this approach is in the next example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独声明一个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，需要将其直接指定在 [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") 字典中，该字典本身在 `__mapper_args__` 字典中指定，以便将其传递给 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 的构造函数。另一种方法在下一个示例中。
- en: Warning
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Declaring a dataclass `field()` setting a `default` together with `init=False`
    will not work as would be expected with a totally plain dataclass, since the SQLAlchemy
    class instrumentation will replace the default value set on the class by the dataclass
    creation process. Use `default_factory` instead. This adaptation is done automatically
    when making use of [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).  ###
    Mapping pre-existing dataclasses using Declarative-style fields'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个 dataclass `field()` 设置一个 `default` 与 `init=False` 一起使用不会像完全普通的 dataclass
    那样起作用，因为SQLAlchemy类的内部机制会用数据类创建过程中设置的默认值替换类上的默认值。使用 `default_factory` 代替。当使用 [声明式
    Dataclass 映射](#orm-declarative-native-dataclasses) 时，此适应将自动完成。### 使用声明式字段映射现有数据类
- en: Legacy Feature
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版特性
- en: This approach to Declarative mapping with dataclasses should be considered as
    legacy. It will remain supported however is unlikely to offer any advantages against
    the new approach detailed at [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 应将此数据类与声明式映射一起使用的方法视为旧版。它将继续受到支持，但是不太可能提供与 [声明式 Dataclass 映射](#orm-declarative-native-dataclasses)
    中详细说明的新方法相比的任何优势。
- en: Note that **mapped_column() is not supported with this use**; the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct should continue to be used to declare table
    metadata within the `metadata` field of `dataclasses.field()`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**`mapped_column()`在这种用法下不受支持**；应继续使用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 构造函数来声明 `metadata` 字段中的表元数据。
- en: 'The fully declarative approach requires that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are declared as class attributes, which when
    using dataclasses would conflict with the dataclass-level attributes. An approach
    to combine these together is to make use of the `metadata` attribute on the `dataclass.field`
    object, where SQLAlchemy-specific mapping information may be supplied. Declarative
    supports extraction of these parameters when the class specifies the attribute
    `__sa_dataclass_metadata_key__`. This also provides a more succinct method of
    indicating the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") association:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完全声明式方法要求将 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象声明为类属性，在使用 dataclasses 时会与 dataclass 级别的属性冲突。结合这些的一种方法是利用 `dataclass.field`
    对象上的 `metadata` 属性，在那里可以提供 SQLAlchemy 特定的映射信息。声明式支持在类指定属性 `__sa_dataclass_metadata_key__`
    时提取这些参数。这也提供了一种更简洁的方法来指示 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 关联：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '#### Using Declarative Mixins with pre-existing dataclasses'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用声明式 Mixin 与现有数据类'
- en: 'In the section [Composing Mapped Hierarchies with Mixins](declarative_mixins.html),
    Declarative Mixin classes are introduced. One requirement of declarative mixins
    is that certain constructs that can’t be easily duplicated must be given as callables,
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator, such as in the example at [Mixing in Relationships](declarative_mixins.html#orm-declarative-mixins-relationships):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 Mixins 构建映射层次结构](declarative_mixins.html) 部分介绍了声明式 Mixin 类。声明式 Mixin 的一个要求是，某些无法轻松复制的构造必须作为可调用对象给出，使用
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器，例如在 [混合关系](declarative_mixins.html#orm-declarative-mixins-relationships) 中的示例：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This form is supported within the Dataclasses `field()` object by using a lambda
    to indicate the SQLAlchemy construct inside the `field()`. Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to surround the lambda is optional. If we wanted
    to produce our `User` class above where the ORM fields came from a mixin that
    is itself a dataclass, the form would be:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在数据类`field()`对象中使用lambda来表示`field()`内的SQLAlchemy构造支持此形式。使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")将lambda包围起来是可选的。如果我们想要生成上述的`User`类，其中ORM字段来自于一个自身是数据类的混合类，形式将是：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'New in version 1.4.2: Added support for “declared attr” style mixin attributes,
    namely [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs as well as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with foreign key declarations, to be used
    within “Dataclasses with Declarative Table” style mappings.  ### Mapping pre-existing
    dataclasses using Imperative Mapping'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能在版本1.4.2中新增：对“已声明属性”样式的混合属性提供支持，即[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造以及带有外键声明的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，可用于“声明式表的数据类”样式的映射中。### 使用命令式映射映射预先存在的数据类
- en: 'As described previously, a class which is set up as a dataclass using the `@dataclass`
    decorator can then be further decorated using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator in order to apply declarative-style
    mapping to the class. As an alternative to using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator, we may also pass the class through
    the [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method instead, so that we may pass
    all [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    configuration imperatively to the function rather than having them defined on
    the class itself as class variables:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用`@dataclass`装饰器设置为数据类的类，然后可以进一步使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器来将声明式样式的映射应用于类。作为使用[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器的替代方案，我们也可以将类通过[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")方法传递，以便我们可以将所有[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")配置命令式地传递给函数，而不是将它们定义为类本身的类变量：
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The same warning mentioned in [Mapping pre-existing dataclasses using Declarative
    With Imperative Table](#orm-declarative-dataclasses-imperative-table) applies
    when using this mapping style.  ### Mapping pre-existing dataclasses using Declarative
    With Imperative Table'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此映射样式时，请注意[使用声明式带命令式表映射预先存在的数据类](#orm-declarative-dataclasses-imperative-table)中提到的相同警告。###
    使用声明式带命令式表映射预先存在的数据类
- en: 'An example of a mapping using `@dataclass` using [Declarative with Imperative
    Table (a.k.a. Hybrid Declarative)](declarative_tables.html#orm-imperative-table-configuration)
    is below. A complete [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed explicitly and assigned to the `__table__` attribute. Instance
    fields are defined using normal dataclass syntaxes. Additional [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") definitions such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), are placed in the [__mapper_args__](declarative_config.html#orm-declarative-mapper-options)
    class-level dictionary underneath the `properties` key, corresponding to the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 [声明式和命令式表格（也称为混合声明式）](declarative_tables.html#orm-imperative-table-configuration)
    的 `@dataclass` 进行映射的示例。一个完整的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象被明确构建并分配给 `__table__` 属性。使用普通数据类语法定义实例字段。其他 [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") 定义，如 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，被放置在 [__mapper_args__](declarative_config.html#orm-declarative-mapper-options)
    类级别的字典中，位于 `properties` 键下，对应于 [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") 参数：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the above example, the `User.id`, `Address.id`, and `Address.user_id` attributes
    are defined as `field(init=False)`. This means that parameters for these won’t
    be added to `__init__()` methods, but [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will still be able to set them after getting their values
    during flush from autoincrement or other default value generator. To allow them
    to be specified in the constructor explicitly, they would instead be given a default
    value of `None`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`User.id`、`Address.id` 和 `Address.user_id` 属性被定义为 `field(init=False)`。这意味着这些属性的参数不会被添加到
    `__init__()` 方法中，但[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仍然可以在 flush 期间从自增或其他默认值生成器获取它们的值后设置它们。为了允许在构造函数中显式指定它们，它们将被给定一个默认值`None`。
- en: For a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    to be declared separately, it needs to be specified directly within the [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") dictionary which itself is specified within the `__mapper_args__`
    dictionary, so that it is passed to the constructor for [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"). An alternative to this approach is in the next example.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独声明一个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，需要直接在 [`Mapper.properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.properties
    "sqlalchemy.orm.Mapper") 字典内指定它，该字典本身在 `__mapper_args__` 字典内指定，以便将其传递给 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 的构造函数。这种方法的替代方案在下一个示例中。
- en: Warning
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Declaring a dataclass `field()` setting a `default` together with `init=False`
    will not work as would be expected with a totally plain dataclass, since the SQLAlchemy
    class instrumentation will replace the default value set on the class by the dataclass
    creation process. Use `default_factory` instead. This adaptation is done automatically
    when making use of [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `field()` 声明一个数据类并设置 `default` 以及 `init=False` 不会像在完全普通的数据类中预期的那样起作用，因为 SQLAlchemy
    类的装饰会替换数据类创建过程中在类上设置的默认值。使用 `default_factory` 代替。当使用[声明式数据类映射](#orm-declarative-native-dataclasses)时，这个适配会自动完成。
- en: '### Mapping pre-existing dataclasses using Declarative-style fields'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用声明式字段映射现有数据类'
- en: Legacy Feature
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留特性
- en: This approach to Declarative mapping with dataclasses should be considered as
    legacy. It will remain supported however is unlikely to offer any advantages against
    the new approach detailed at [Declarative Dataclass Mapping](#orm-declarative-native-dataclasses).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用数据类进行声明式映射的方法应被视为遗留。它仍然会得到支持，但不太可能在[声明式数据类映射](#orm-declarative-native-dataclasses)的新方法面前提供任何优势。
- en: Note that **mapped_column() is not supported with this use**; the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct should continue to be used to declare table
    metadata within the `metadata` field of `dataclasses.field()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 **mapped_column() 不支持此用法**；应继续使用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 构造在 `dataclasses.field()` 的 `metadata` 字段内声明表元数据。
- en: 'The fully declarative approach requires that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are declared as class attributes, which when
    using dataclasses would conflict with the dataclass-level attributes. An approach
    to combine these together is to make use of the `metadata` attribute on the `dataclass.field`
    object, where SQLAlchemy-specific mapping information may be supplied. Declarative
    supports extraction of these parameters when the class specifies the attribute
    `__sa_dataclass_metadata_key__`. This also provides a more succinct method of
    indicating the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") association:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完全声明式的方法要求 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象被声明为类属性，当使用数据类时，这将与数据类级别的属性冲突。结合这些的一种方法是利用 `dataclass.field` 对象上的 `metadata`
    属性，其中可以提供特定于 SQLAlchemy 的映射信息。当类指定属性 `__sa_dataclass_metadata_key__` 时，声明式支持提取这些参数。这也提供了一种更简洁的方法来指示
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    关联：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '#### Using Declarative Mixins with pre-existing dataclasses'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用具有预先存在的数据类的声明式混合'
- en: 'In the section [Composing Mapped Hierarchies with Mixins](declarative_mixins.html),
    Declarative Mixin classes are introduced. One requirement of declarative mixins
    is that certain constructs that can’t be easily duplicated must be given as callables,
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator, such as in the example at [Mixing in Relationships](declarative_mixins.html#orm-declarative-mixins-relationships):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用混合组合映射层次结构](declarative_mixins.html) 部分介绍了声明式 Mixin 类。声明式 mixins 的一个要求是，某些无法轻松复制的构造必须以可调用的形式给出，使用
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器，例如在 [混合关系](declarative_mixins.html#orm-declarative-mixins-relationships) 中的示例：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This form is supported within the Dataclasses `field()` object by using a lambda
    to indicate the SQLAlchemy construct inside the `field()`. Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to surround the lambda is optional. If we wanted
    to produce our `User` class above where the ORM fields came from a mixin that
    is itself a dataclass, the form would be:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此形式在 Dataclasses 的 `field()` 对象中得到支持，通过使用 lambda 来指示 `field()` 内部的 SQLAlchemy
    构造。在 lambda 周围使用 [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 是可选的。如果我们想要生成我们上面的 `User` 类，其中 ORM 字段来自一个本身就是数据类的
    mixin，形式将是：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'New in version 1.4.2: Added support for “declared attr” style mixin attributes,
    namely [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs as well as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with foreign key declarations, to be used
    within “Dataclasses with Declarative Table” style mappings.  #### Using Declarative
    Mixins with pre-existing dataclasses'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '新版本 1.4.2 中新增：为“声明式表中的数据类”样式映射添加了对“已声明属性”样式 mixin 属性的支持，即用于“使用声明式混合具有预先存在的数据类”样式映射中的
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    结构以及具有外键声明的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象。  #### 使用具有预先存在的数据类的声明式混合'
- en: 'In the section [Composing Mapped Hierarchies with Mixins](declarative_mixins.html),
    Declarative Mixin classes are introduced. One requirement of declarative mixins
    is that certain constructs that can’t be easily duplicated must be given as callables,
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator, such as in the example at [Mixing in Relationships](declarative_mixins.html#orm-declarative-mixins-relationships):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用混合组合映射层次结构](declarative_mixins.html) 部分介绍了声明式 Mixin 类。声明式 mixins 的一个要求是，某些无法轻松复制的构造必须以可调用的形式给出，使用
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器，例如在 [混合关系](declarative_mixins.html#orm-declarative-mixins-relationships) 中的示例：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This form is supported within the Dataclasses `field()` object by using a lambda
    to indicate the SQLAlchemy construct inside the `field()`. Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to surround the lambda is optional. If we wanted
    to produce our `User` class above where the ORM fields came from a mixin that
    is itself a dataclass, the form would be:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dataclasses `field()` 对象中支持此形式，通过使用 lambda 表示 SQLAlchemy 构造在 `field()` 内部。使用
    [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    将 lambda 包围起来是可选的。如果我们想要生成上述的 `User` 类，其中 ORM 字段来自于一个自身是 dataclass 的 mixin，那么形式将是：
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'New in version 1.4.2: Added support for “declared attr” style mixin attributes,
    namely [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs as well as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with foreign key declarations, to be used
    within “Dataclasses with Declarative Table” style mappings.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4.2 中的新内容：添加了对“声明属性”风格 mixin 属性的支持，即 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造以及带有外键声明的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，用于在“具有声明性表”的样式映射中使用。
- en: '### Mapping pre-existing dataclasses using Imperative Mapping'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用命令式映射映射现有 dataclasses'
- en: 'As described previously, a class which is set up as a dataclass using the `@dataclass`
    decorator can then be further decorated using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator in order to apply declarative-style
    mapping to the class. As an alternative to using the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator, we may also pass the class through
    the [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method instead, so that we may pass
    all [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    configuration imperatively to the function rather than having them defined on
    the class itself as class variables:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过使用 `@dataclass` 装饰器设置为 dataclass 的类，然后可以进一步使用 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器装饰该类，以将声明性映射应用到类。作为使用 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器的替代方案，我们也可以将类传递给 [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") 方法，这样我们就可以将所有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 和 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 配置命令性地传递给函数，而不是将它们定义为类变量：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The same warning mentioned in [Mapping pre-existing dataclasses using Declarative
    With Imperative Table](#orm-declarative-dataclasses-imperative-table) applies
    when using this mapping style.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此映射样式时，与[使用声明性与命令性表映射现有数据类](#orm-declarative-dataclasses-imperative-table)中提到的相同警告适用。
- en: '## Applying ORM mappings to an existing attrs class'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将 ORM 映射应用到现有 attrs 类'
- en: The [attrs](https://pypi.org/project/attrs/) library is a popular third party
    library that provides similar features as dataclasses, with many additional features
    provided not found in ordinary dataclasses.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[attrs](https://pypi.org/project/attrs/) 库是一个流行的第三方库，提供了类似于 dataclasses 的功能，同时提供了许多在普通
    dataclasses 中找不到的附加功能。'
- en: A class augmented with [attrs](https://pypi.org/project/attrs/) uses the `@define`
    decorator. This decorator initiates a process to scan the class for attributes
    that define the class’ behavior, which are then used to generate methods, documentation,
    and annotations.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [attrs](https://pypi.org/project/attrs/) 增强的类使用 `@define` 装饰器。此装饰器启动一个过程，用于扫描类以查找定义类行为的属性，然后使用这些属性生成方法、文档和注释。
- en: The SQLAlchemy ORM supports mapping an [attrs](https://pypi.org/project/attrs/)
    class using **Declarative with Imperative Table** or **Imperative** mapping. The
    general form of these two styles is fully equivalent to the [Mapping pre-existing
    dataclasses using Declarative-style fields](#orm-declarative-dataclasses-declarative-table)
    and [Mapping pre-existing dataclasses using Declarative With Imperative Table](#orm-declarative-dataclasses-imperative-table)
    mapping forms used with dataclasses, where the inline attribute directives used
    by dataclasses or attrs are unchanged, and SQLAlchemy’s table-oriented instrumentation
    is applied at runtime.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQLAlchemy ORM 支持使用**声明式与命令式表**或**命令式**映射来映射 [attrs](https://pypi.org/project/attrs/)
    类。这两种风格的一般形式与数据类一起使用的[使用声明式字段映射预先存在的数据类](#orm-declarative-dataclasses-declarative-table)和[使用声明式与命令式表映射预先存在的数据类](#orm-declarative-dataclasses-imperative-table)的映射形式完全相同，其中数据类或
    attrs 使用的内联属性指令保持不变，并且 SQLAlchemy 的面向表的仪器化在运行时应用。  '
- en: The `@define` decorator of [attrs](https://pypi.org/project/attrs/) by default
    replaces the annotated class with a new __slots__ based class, which is not supported.
    When using the old style annotation `@attr.s` or using `define(slots=False)`,
    the class does not get replaced. Furthermore attrs removes its own class-bound
    attributes after the decorator runs, so that SQLAlchemy’s mapping process takes
    over these attributes without any issue. Both decorators, `@attr.s` and `@define(slots=False)`
    work with SQLAlchemy.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[attrs](https://pypi.org/project/attrs/) 的 `@define` 装饰器默认用新的基于 __slots__ 的类替换注释类，这是不受支持的。当使用旧式注释
    `@attr.s` 或使用 `define(slots=False)` 时，类不会被替换。此外，attrs 在装饰器运行后移除了自己的类绑定属性，以便 SQLAlchemy
    的映射过程接管这些属性而不会出现任何问题。`@attr.s` 和 `@define(slots=False)` 两个装饰器都适用于 SQLAlchemy。'
- en: Mapping attrs with Declarative “Imperative Table”
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用声明式“命令式表”映射属性
- en: 'In the “Declarative with Imperative Table” style, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object is declared inline with the declarative class.
    The `@define` decorator is applied to the class first, then the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator second:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在“声明式与命令式表”风格中，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象与声明式类内联声明。首先将 `@define` 装饰器应用于类，然后将 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器应用于第二个位置：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `attrs` `slots=True` option, which enables `__slots__` on a mapped class,
    cannot be used with SQLAlchemy mappings without fully implementing alternative
    [attribute instrumentation](examples.html#examples-instrumentation), as mapped
    classes normally rely upon direct access to `__dict__` for state storage. Behavior
    is undefined when this option is present.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrs` 的 `slots=True` 选项，在映射类上启用了 `__slots__`，不能与未完全实现备用 [属性仪器化](examples.html#examples-instrumentation)
    的 SQLAlchemy 映射一起使用，因为映射类通常依赖于直接访问 `__dict__` 进行状态存储。当此选项存在时，行为是未定义的。'
- en: Mapping attrs with Imperative Mapping
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令式映射映射属性
- en: 'Just as is the case with dataclasses, we can make use of [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") to map an existing `attrs` class as
    well:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如对于数据类一样，我们可以使用 [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") 来映射现有的 `attrs` 类：
- en: '[PRE72]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The above form is equivalent to the previous example using Declarative with
    Imperative Table.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式等同于先前使用声明式与命令式表的示例。
- en: Mapping attrs with Declarative “Imperative Table”
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用声明式“命令式表”映射属性
- en: 'In the “Declarative with Imperative Table” style, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object is declared inline with the declarative class.
    The `@define` decorator is applied to the class first, then the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator second:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在“声明式与命令式表”风格中，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象与声明式类内联声明。首先将 `@define` 装饰器应用于类，然后将 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器应用于第二个位置：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `attrs` `slots=True` option, which enables `__slots__` on a mapped class,
    cannot be used with SQLAlchemy mappings without fully implementing alternative
    [attribute instrumentation](examples.html#examples-instrumentation), as mapped
    classes normally rely upon direct access to `__dict__` for state storage. Behavior
    is undefined when this option is present.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrs` 的 `slots=True` 选项可以在映射类上启用 `__slots__`，但在不完全实现替代的[属性调试](examples.html#examples-instrumentation)时，无法与
    SQLAlchemy 映射一起使用，因为映射类通常依赖于直接访问 `__dict__` 来存储状态。当存在此选项时，行为是未定义的。'
- en: Mapping attrs with Imperative Mapping
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令式映射（Imperative Mapping）进行属性映射
- en: 'Just as is the case with dataclasses, we can make use of [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") to map an existing `attrs` class as
    well:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在数据类中一样，我们可以利用[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")来映射现有的 `attrs` 类：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The above form is equivalent to the previous example using Declarative with
    Imperative Table.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式等同于使用命令式表格进行声明的上一个示例。
