- en: Sessions / Queries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话 / 查询
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/sessions.html](https://docs.sqlalchemy.org/en/20/faq/sessions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/faq/sessions.html](https://docs.sqlalchemy.org/en/20/faq/sessions.html)
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用 Session 重新加载数据，但它没有看到我在其他地方提交的更改](#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere)'
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“此会话的事务已由于刷新期间的先前异常而回滚。”（或类似消息）](#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar)'
- en: '[But why does flush() insist on issuing a ROLLBACK?](#but-why-does-flush-insist-on-issuing-a-rollback)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[但为什么 flush() 坚持发出 ROLLBACK？](#but-why-does-flush-insist-on-issuing-a-rollback)'
- en: '[But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?](#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[但为什么一个自动调用 ROLLBACK 不够？为什么我必须再次 ROLLBACK？](#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again)'
- en: '[How do I make a Query that always adds a certain filter to every query?](#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何创建一个始终向每个查询添加特定过滤器的查询？](#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query)'
- en: '[My Query does not return the same number of objects as query.count() tells
    me - why?](#my-query-does-not-return-the-same-number-of-objects-as-query-count-tells-me-why)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我的查询返回的对象数与 query.count() 告诉我的不一致 - 为什么？](#my-query-does-not-return-the-same-number-of-objects-as-query-count-tells-me-why)'
- en: '[I’ve created a mapping against an Outer Join, and while the query returns
    rows, no objects are returned. Why not?](#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我已经创建了一个对 Outer Join 的映射，虽然查询返回行，但没有返回对象。为什么？](#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not)'
- en: '[I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)](#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我使用 `joinedload()` 或 `lazy=False` 创建 JOIN/OUTER JOIN，但当我尝试添加 WHERE、ORDER BY、LIMIT
    等条件时，SQLAlchemy 没有构造正确的查询（这取决于 (OUTER) JOIN）](#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join)'
- en: '[Query has no `__len__()`, why not?](#query-has-no-len-why-not)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查询没有 `__len__()`，为什么？](#query-has-no-len-why-not)'
- en: '[How Do I use Textual SQL with ORM Queries?](#how-do-i-use-textual-sql-with-orm-queries)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在 ORM 查询中使用文本 SQL？](#how-do-i-use-textual-sql-with-orm-queries)'
- en: '[I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!](#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调用 `Session.delete(myobject)` 后，我的对象未从父集合中移除！](#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection)'
- en: '[why isn’t my `__init__()` called when I load objects?](#why-isn-t-my-init-called-when-i-load-objects)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加载对象时为什么不调用我的 `__init__()`？](#why-isn-t-my-init-called-when-i-load-objects)'
- en: '[how do I use ON DELETE CASCADE with SA’s ORM?](#how-do-i-use-on-delete-cascade-with-sa-s-orm)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在 SA 的 ORM 中使用 ON DELETE CASCADE？](#how-do-i-use-on-delete-cascade-with-sa-s-orm)'
- en: '[I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?](#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我将实例的“foo_id”属性设置为“7”，但“foo”属性仍然为 `None` - 应该加载 id 为 #7 的 Foo 吗？](#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7)'
- en: '[How do I walk all objects that are related to a given object?](#how-do-i-walk-all-objects-that-are-related-to-a-given-object)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何遍历与给定对象相关的所有对象？](#how-do-i-walk-all-objects-that-are-related-to-a-given-object)'
- en: '[Is there a way to automagically have only unique keywords (or other kinds
    of objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?](#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[有没有一种方法可以自动只获取唯一关键字（或其他类型的对象），而不需要查询关键字并获取包含该关键字的行的引用？](#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword)'
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](#why-does-post-update-emit-update-in-addition-to-the-first-update)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么post_update除了第一个UPDATE之外还会发出UPDATE？](#why-does-post-update-emit-update-in-addition-to-the-first-update)'
- en: '## I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我重新加载了我的会话中的数据，但它没有看到我在其他地方提交的更改'
- en: The main issue regarding this behavior is that the session acts as though the
    transaction is in the *serializable* isolation state, even if it’s not (and it
    usually is not). In practical terms, this means that the session does not alter
    any data that it’s already read within the scope of a transaction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的主要问题在于，会话表现得好像事务处于*可串行化*隔离状态一样，即使实际上并非如此（通常也不是）。从实际角度来看，这意味着会话在事务范围内已经读取的数据不会发生任何更改。
- en: 'If the term “isolation level” is unfamiliar, then you first need to read this
    link:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果术语“隔离级别”不熟悉，那么您首先需要阅读此链接：
- en: '[Isolation Level](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[隔离级别](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
- en: In short, serializable isolation level generally means that once you SELECT
    a series of rows in a transaction, you will get *the identical data* back each
    time you re-emit that SELECT. If you are in the next-lower isolation level, “repeatable
    read”, you’ll see newly added rows (and no longer see deleted rows), but for rows
    that you’ve *already* loaded, you won’t see any change. Only if you are in a lower
    isolation level, e.g. “read committed”, does it become possible to see a row of
    data change its value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可串行化隔离级通常意味着一旦在事务中选择了一系列行，每次重新发出该SELECT时都会获得*相同的数据*。如果您处于较低的隔离级别“可重复读”，您将看到新添加的行（不再看到已删除的行），但对于您已经加载的行，您不会看到任何更改。只有当您处于较低的隔离级别，例如“读取提交”，才有可能看到数据行更改其值。
- en: For information on controlling the isolation level when using the SQLAlchemy
    ORM, see [Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在使用SQLAlchemy ORM时控制隔离级别的信息，请参阅[设置事务隔离级别 / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation)。
- en: To simplify things dramatically, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") itself works in terms of a completely isolated transaction,
    and doesn’t overwrite any mapped attributes it’s already read unless you tell
    it to. The use case of trying to re-read data you’ve already loaded in an ongoing
    transaction is an *uncommon* use case that in many cases has no effect, so this
    is considered to be the exception, not the norm; to work within this exception,
    several methods are provided to allow specific data to be reloaded within the
    context of an ongoing transaction.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了极大地简化事情，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")本身是基于完全隔离的事务运行的，并且不会覆盖已经读取的任何映射属性，除非您告诉它这样做。尝试在进行中的事务中重新读取已加载的数据的用例是一个*不常见*的用例，在许多情况下没有任何效果，因此这被认为是例外而不是规范；为了在这种例外情况下工作，提供了几种方法允许在进行中的事务上下文中重新加载特定数据。
- en: To understand what we mean by “the transaction” when we talk about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), your [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to only work within a transaction. An overview
    of this is at [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们在谈论[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时所说的“事务”是什么意思，您的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")只能在事务内部工作。有关概述，请参阅[管理事务](../orm/session_transaction.html#unitofwork-transaction)。
- en: Once we’ve figured out what our isolation level is, and we think that our isolation
    level is set at a low enough level so that if we re-SELECT a row, we should see
    new data in our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    how do we see it?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们弄清楚了我们的隔离级别是什么，并且我们认为我们的隔离级别设置得足够低，以便如果我们重新选择一行，我们应该能够在我们的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中看到新数据，那么我们该如何看到它？
- en: 'Three ways, from most common to least:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从最常见到最不常见的三种方式：
- en: We simply end our transaction and start a new one on next access with our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") by calling [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") (note that if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is in the lesser-used “autocommit” mode, there would
    be a call to [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") as well). The vast majority of applications and
    use cases do not have any issues with not being able to “see” data in other transactions
    because they stick to this pattern, which is at the core of the best practice
    of **short lived transactions**. See [When do I construct a Session, when do I
    commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate)
    for some thoughts on this.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需结束当前事务，并在下一次访问时启动新事务，通过调用 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")（请注意，如果 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 处于较少使用的“自动提交”模式，则还会调用 [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")）。绝大多数应用和用例不会出现无法“看到”其他事务中的数据的问题，因为它们遵循了这一模式，这是**短事务**最佳实践的核心。有关此问题的一些想法，请参阅
    [何时构建 Session，何时提交它，何时关闭它？](../orm/session_basics.html#session-faq-whentocreate)。
- en: We tell our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to re-read rows that it has already read, either when we next query for them using
    [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"), or immediately on an object using `refresh`.
    See [Refreshing / Expiring](../orm/session_state_management.html#session-expire)
    for detail on this.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉我们的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    重新读取它已经读取过的行，要么在下次使用 [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 或 [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 查询它们时，要么立即在对象上使用 `refresh`。有关此事的详细信息，请参阅 [刷新
    / 过期](../orm/session_state_management.html#session-expire)。
- en: We can run whole queries while setting them to definitely overwrite already-loaded
    objects as they read rows by using “populate existing”. This is an execution option
    described at [Populate Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在设置了“填充现有”选项的情况下运行整个查询，这样它们读取行时就会覆盖已加载的对象。这是一个在 [填充现有](../orm/queryguide/api.html#orm-queryguide-populate-existing)
    中描述的执行选项。
- en: 'But remember, **the ORM cannot see changes in rows if our isolation level is
    repeatable read or higher, unless we start a new transaction**.  ## “This Session’s
    transaction has been rolled back due to a previous exception during flush.” (or
    similar)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，**如果我们的隔离级别是可重复读或更高，则 ORM 无法看到行中的更改，除非我们开始新的事务**。## “此会话的事务由于在 flush 期间发生的先前异常而回滚。”（或类似）
- en: This is an error that occurs when a [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") raises an exception, rolls back the transaction,
    but further commands upon the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are called without an explicit call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    引发异常、回滚事务，但后续对 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的命令未显式调用 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 时会出现此错误。
- en: 'It usually corresponds to an application that catches an exception upon [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and does not properly handle the exception. For
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常对应于在 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 或 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 上捕获异常并且不正确处理异常的应用程序。例如：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should fit within a structure similar to this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    应该符合类似于此结构：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many things can cause a failure within the try/except besides flushes. Applications
    should ensure some system of “framing” is applied to ORM-oriented processes so
    that connection and transaction resources have a definitive boundary, and so that
    transactions can be explicitly rolled back if any failure conditions occur.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 flushes 外，很多事情都可能导致 try/except 内部的失败。应用程序应确保对基于 ORM 的过程应用某种“框架”系统，以便连接和事务资源具有明确的边界，并且如果发生任何失败条件，则可以显式地回滚事务。
- en: This does not mean there should be try/except blocks throughout an application,
    which would not be a scalable architecture. Instead, a typical approach is that
    when ORM-oriented methods and functions are first called, the process that’s calling
    the functions from the very top would be within a block that commits transactions
    at the successful completion of a series of operations, as well as rolls transactions
    back if operations fail for any reason, including failed flushes. There are also
    approaches using function decorators or context managers to achieve similar results.
    The kind of approach taken depends very much on the kind of application being
    written.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着整个应用程序都应该有 try/except 块，这将不是一种可扩展的架构。相反，一种典型的方法是，当首次调用基于 ORM 的方法和函数时，从最顶层调用函数的过程将处于一个块中，该块在一系列操作成功完成时提交事务，并且在任何原因失败时，包括失败的
    flushes 时回滚事务。也有使用函数装饰器或上下文管理器来实现类似结果的方法。采取的方法取决于正在编写的应用程序的类型。
- en: For a detailed discussion on how to organize usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), please see [When do I construct a Session, when do
    I commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何组织使用 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的详细讨论，请参阅[何时构造会话，何时提交它，何时关闭它？](../orm/session_basics.html#session-faq-whentocreate)。
- en: But why does flush() insist on issuing a ROLLBACK?
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么 flush() 一定要发出 ROLLBACK 呢？
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 能够部分完成而不回滚，那将是很好的，但是由于其当前能力有限，因此这超出了它的当前能力范围，因为其内部簿记必须被修改，以便可以随时停止，并且与已刷新到数据库的内容完全一致。虽然从理论上讲这是可能的，但是增强功能的有用性因为许多数据库操作在任何情况下都需要回滚而大大降低。特别是，Postgres
    有一些操作，一旦失败，事务就不允许继续进行：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供的解决这两个问题的方法是支持 SAVEPOINT，通过 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")。使用 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")，您可以在事务内部对可能失败的操作进行框架化，然后在保持封闭事务的同时“回滚”到失败之前的点。
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么一个自动调用ROLLBACK不够？为什么我必须再次ROLLBACK？
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由`flush()`引起的回滚并不是完整事务块的结束；虽然它结束了正在进行的数据库事务，但从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的角度来看，仍然存在一个现在处于非活动状态的事务。
- en: 'Given a block such as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样一个块：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，当首次创建一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，假设没有使用“自动提交模式”，在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")内建立了一个逻辑事务。这个事务是“逻辑”的，因为直到调用SQL语句时才会实际使用任何数据库资源，此时会启动连接级和DBAPI级事务。然而，无论数据库级事务是否是其状态的一部分，逻辑事务将保持不变，直到使用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")结束它。
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当上面的`flush()`失败时，代码仍然位于由try/commit/except/rollback块框定的事务中。如果`flush()`完全回滚逻辑事务，那么当我们到达`except:`块时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将处于干净状态，准备在全新事务上发出新的SQL，并且调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")将不按顺序进行。特别是，此时[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")已经开始了一个新事务，而[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")将错误地对其进行操作。在这个正常情况下应该进行回滚的地方，而不是允许SQL操作在新事务上继续进行，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会拒绝继续直到显式回滚实际发生。
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，期望调用代码**始终**调用 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 来对应当前事务块。`flush()` 保持 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 在这个事务块内，以便上述代码的行为是可预测和一致的。
- en: How do I make a Query that always adds a certain filter to every query?
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使一个查询始终对每个查询添加某个过滤器？
- en: See the recipe at [FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 [FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery)
    的配方。
- en: '## My Query does not return the same number of objects as query.count() tells
    me - why?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我的查询返回的对象数与 query.count() 告诉我的不一样 - 为什么？'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, when asked to return a list of ORM-mapped objects, will **deduplicate
    the objects based on primary key**. That is, if we for example use the `User`
    mapping described at [Using ORM Declarative Forms to Define Table Metadata](../tutorial/metadata.html#tutorial-orm-table-metadata),
    and we had a SQL query like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象被要求返回一个 ORM 映射对象列表时，将**根据主键对对象进行去重**。也就是说，如果我们例如使用了在 [使用 ORM 声明形式定义表元数据](../tutorial/metadata.html#tutorial-orm-table-metadata)
    中描述的 `User` 映射，并且我们有一个如下所示的 SQL 查询：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Above, the sample data used in the tutorial has two rows in the `addresses`
    table for the `users` row with the name `''jack''`, primary key value 5. If we
    ask the above query for a [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count"), we will get the answer **2**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在教程中使用的示例数据中，`addresses` 表中有两行数据，其中 `name` 为 `'jack'`、主键值为 5 的 `users` 行。如果我们要求上述查询的
    [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count")，我们将得到答案
    **2**：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if we run [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") or iterate over the query, we get back **one element**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们运行 [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") 或遍历查询，我们将得到**一个元素**：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is because when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object returns full entities, they are **deduplicated**.
    This does not occur if we instead request individual columns back:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象返回完整实体时，它们会被**去重**。如果我们改为请求单个列返回，则不会发生这种情况：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two main reasons the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will deduplicate:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    将去重的主要原因有两个：'
- en: '**To allow joined eager loading to work correctly** - [Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    works by querying rows using joins against related tables, where it then routes
    rows from those joins into collections upon the lead objects. In order to do this,
    it has to fetch rows where the lead object primary key is repeated for each sub-entry.
    This pattern can then continue into further sub-collections such that a multiple
    of rows may be processed for a single lead object, such as `User(id=5)`. The dedpulication
    allows us to receive objects in the way they were queried, e.g. all the `User()`
    objects whose name is `''jack''` which for us is one object, with the `User.addresses`
    collection eagerly loaded as was indicated either by `lazy=''joined''` on the
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or via the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option. For consistency, the deduplication is still
    applied whether or not the joinedload is established, as the key philosophy behind
    eager loading is that these options never affect the result.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许联接预加载正常工作** - [联接预加载](../orm/queryguide/relationships.html#joined-eager-loading)通过使用与相关表的连接来查询行，然后将这些连接的行路由到主对象的集合中来工作。为了做到这一点，它必须获取主对象主键在每个子条目中重复的行。这种模式可以继续到更深层的子集合，以便为单个主对象（如`User(id=5)`）处理多行。去重允许我们按照查询的方式接收对象，例如所有名为''jack''的`User()`对象，对于我们来说是一个对象，其中`User.addresses`集合已经被急加载，就像在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上通过`lazy=''joined''`或通过[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")选项指示的那样。为了保持一致性，无论是否建立了联接加载，去重仍然适用，因为急加载背后的关键理念是这些选项永远不会影响结果。'
- en: '**To eliminate confusion regarding the identity map** - this is admittedly
    the less critical reason. As the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") makes use of an [identity map](../glossary.html#term-identity-map),
    even though our SQL result set has two rows with primary key 5, there is only
    one `User(id=5)` object inside the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which must be maintained uniquely on its identity, that
    is, its primary key / class combination. It doesn’t actually make much sense,
    if one is querying for `User()` objects, to get the same object multiple times
    in the list. An ordered set would potentially be a better representation of what
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    seeks to return when it returns full objects.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除关于身份映射的混淆** - 这显然是较不重要的原因。由于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用了[身份映射](../glossary.html#term-identity-map)，即使我们的 SQL
    结果集中有两行主键为 5 的记录，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中只有一个`User(id=5)`对象，必须在其身份上保持唯一，即其主键/类组合。如果一个查询`User()`对象，多次在列表中获取相同对象实际上并没有太多意义。有序集合可能更好地表示[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 在返回完整对象时所寻求的内容。'
- en: The issue of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    deduplication remains problematic, mostly for the single reason that the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method is inconsistent, and the current status is
    that joined eager loading has in recent releases been superseded first by the
    “subquery eager loading” strategy and more recently the “select IN eager loading”
    strategy, both of which are generally more appropriate for collection eager loading.
    As this evolution continues, SQLAlchemy may alter this behavior on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which may also involve new APIs in order to more directly
    control this behavior, and may also alter the behavior of joined eager loading
    in order to create a more consistent usage pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")去重问题仍然存在问题，主要是因为[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count")方法不一致，并且当前状态是最近的版本中的连接急加载首先被“子查询急加载”策略取代，最近是“select
    IN急加载”策略，这两种策略通常更适合于集合急加载。随着这一演变的继续，SQLAlchemy 可能会更改 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的行为，这也可能涉及新的 API，以更直接地控制此行为，并且也可能更改连接的急加载的行为，以创建更一致的使用模式。'
- en: I’ve created a mapping against an Outer Join, and while the query returns rows,
    no objects are returned. Why not?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我已经针对外连接创建了映射，但是虽然查询返回行，但没有返回对象。为什么？
- en: Rows returned by an outer join may contain NULL for part of the primary key,
    as the primary key is the composite of both tables. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object ignores incoming rows that don’t have an acceptable
    primary key. Based on the setting of the `allow_partial_pks` flag on [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"), a primary key is accepted if the value has at least
    one non-NULL value, or alternatively if the value has no NULL values. See `allow_partial_pks`
    at [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由外连接返回的行可能包含主键的部分 NULL，因为主键是两个表的组合。[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象忽略不具有可接受主键的传入行。根据[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")上的`allow_partial_pks`标志的设置，如果该值至少具有一个非 NULL 值，则接受主键，或者如果该值没有
    NULL 值，则接受该值。请参见 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")上的`allow_partial_pks`。
- en: I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在使用`joinedload()`或`lazy=False`来创建 JOIN/OUTER JOIN，当我尝试添加 WHERE、ORDER BY、LIMIT
    等条件时，SQLAlchemy 没有构造正确的查询。（这依赖于（OUTER）JOIN）
- en: The joins generated by joined eager loading are only used to fully load related
    collections, and are designed to have no impact on the primary results of the
    query. Since they are anonymously aliased, they cannot be referenced directly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由连接的急加载生成的连接仅用于完全加载相关集合，并设计为不影响查询的主要结果。由于它们是匿名别名，因此不能直接引用。
- en: For detail on this behavior, see [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种行为的详细信息，请参见[急加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading)。
- en: Query has no `__len__()`, why not?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询没有`__len__()`，为什么？
- en: 'The Python `__len__()` magic method applied to an object allows the `len()`
    builtin to be used to determine the length of the collection. It’s intuitive that
    a SQL query object would link `__len__()` to the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method, which emits a SELECT COUNT. The reason this
    is not possible is because evaluating the query as a list would incur two SQL
    calls instead of one:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于对象的 Python `__len__()` 魔术方法允许使用`len()`内置函数来确定集合的长度。直觉上，SQL 查询对象将`__len__()`链接到[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count")方法，该方法发出 SELECT COUNT。不可能的原因是评估查询为列表将导致两次 SQL 调用而不是一次：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How Do I use Textual SQL with ORM Queries?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 ORM 查询中使用文本 SQL？
- en: 'See:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参见：
- en: '[Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - Ad-hoc textual blocks with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从文本语句获取 ORM 结果](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - 使用 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    进行即席文本块。'
- en: '[Using SQL Expressions with Sessions](../orm/persistence_techniques.html#session-sql-expressions)
    - Using [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with textual SQL directly.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在会话中使用 SQL 表达式](../orm/persistence_techniques.html#session-sql-expressions)
    - 直接使用 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    进行文本 SQL 操作。'
- en: I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我调用 `Session.delete(myobject)`，但它没有从父集合中删除！
- en: See [Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](../orm/cascades.html#session-deleting-from-collections) for a description
    of this behavior.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[关于删除的注释 - 从集合和标量关系中删除对象](../orm/cascades.html#session-deleting-from-collections)以了解此行为的描述。
- en: why isn’t my `__init__()` called when I load objects?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当加载对象时，为什么我的 `__init__()` 没有被调用？
- en: See [Maintaining Non-Mapped State Across Loads](../orm/mapping_styles.html#mapped-class-load-events)
    for a description of this behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[跨加载保持非映射状态](../orm/mapping_styles.html#mapped-class-load-events)以了解此行为的描述。
- en: how do I use ON DELETE CASCADE with SA’s ORM?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何在 SA 的 ORM 中使用 ON DELETE CASCADE？
- en: SQLAlchemy will always issue UPDATE or DELETE statements for dependent rows
    which are currently loaded in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For rows which are not loaded, it will by default issue
    SELECT statements to load those rows and update/delete those as well; in other
    words it assumes there is no ON DELETE CASCADE configured. To configure SQLAlchemy
    to cooperate with ON DELETE CASCADE, see [Using foreign key ON DELETE cascade
    with ORM relationships](../orm/cascades.html#passive-deletes).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 总是对当前加载在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的依赖行发出 UPDATE 或 DELETE 语句。对于未加载的行，默认情况下会发出 SELECT 语句来加载这些行并更新/删除它们；换句话说，它假定没有配置
    ON DELETE CASCADE。要配置 SQLAlchemy 与 ON DELETE CASCADE 协作，请参见[使用 ORM 关系的外键 ON DELETE
    cascade](../orm/cascades.html#passive-deletes)。
- en: 'I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '我将实例的“foo_id”属性设置为“7”，但“foo”属性仍然为`None` - 它不应该加载具有 id #7 的 Foo 吗？'
- en: 'The ORM is not constructed in such a way as to support immediate population
    of relationships driven from foreign key attribute changes - instead, it is designed
    to work the other way around - foreign key attributes are handled by the ORM behind
    the scenes, the end user sets up object relationships naturally. Therefore, the
    recommended way to set `o.foo` is to do just that - set it!:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的构建不支持根据外键属性变化驱动的关系的立即填充 - 相反，它被设计成反向工作 - 外键属性由 ORM 在幕后处理，最终用户自然设置对象关系。因此，设置
    `o.foo` 的推荐方式是做到这一点 - 设置它！：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Manipulation of foreign key attributes is of course entirely legal. However,
    setting a foreign-key attribute to a new value currently does not trigger an “expire”
    event of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in which it’s involved. This means that for the
    following sequence:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对外键属性进行操作是完全合法的。但是，将外键属性设置为新值当前不会触发 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 中涉及的“expire”事件。这意味着对于以下序列：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`o.foo` is loaded with its effective database value of `None` when it is first
    accessed. Setting `o.foo_id = 7` will have the value of “7” as a pending change,
    but no flush has occurred - so `o.foo` is still `None`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次访问时，`o.foo` 会加载其有效的数据库值为 `None`。将 `o.foo_id = 7` 设置为挂起更改的值为“7”，但尚未刷新 - 因此
    `o.foo` 仍然为 `None`：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For `o.foo` to load based on the foreign key mutation is usually achieved naturally
    after the commit, which both flushes the new foreign key value and expires all
    state:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `o.foo` 基于外键变化进行加载，通常在提交后自然实现，因为提交既刷新了新的外键值，又使所有状态过期：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A more minimal operation is to expire the attribute individually - this can
    be performed for any [persistent](../glossary.html#term-persistent) object using
    [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire "sqlalchemy.orm.Session.expire"):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更精简的操作是单独过期属性 - 这可以为任何[持久的](../glossary.html#term-persistent)对象执行，使用[`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that if the object is not persistent but present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it’s known as [pending](../glossary.html#term-pending).
    This means the row for the object has not been INSERTed into the database yet.
    For such an object, setting `foo_id` does not have meaning until the row is inserted;
    otherwise there is no row yet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果对象不是持久的但存在于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，则被称为[待定](../glossary.html#term-pending)。这意味着对象的行尚未插入到数据库中。对于这样的对象，设置`foo_id`在行被插入之前没有意义；否则还没有行：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The recipe [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    features an example using SQLAlchemy events in order to coordinate the setting
    of foreign key attributes with many-to-one relationships.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方[ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)展示了一个使用SQLAlchemy事件的示例，以协调设置具有多对一关系的外键属性。
- en: '## How do I walk all objects that are related to a given object?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何遍历所有与给定对象相关联的对象？'
- en: 'An object that has other objects related to it will correspond to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs set up between mappers. This code fragment
    will iterate all the objects, correcting for cycles as well:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 具有其他对象相关联的对象将对应于设置在映射器之间的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造。此代码片段将迭代所有对象，并校正循环：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function can be demonstrated as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以演示如下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Is there a way to automagically have only unique keywords (or other kinds of
    objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否有一种方法可以自动地仅获取唯一的关键词（或其他类型的对象），而不是对关键词进行查询并获取包含该关键词的行的引用？
- en: When people read the many-to-many example in the docs, they get hit with the
    fact that if you create the same `Keyword` twice, it gets put in the DB twice.
    Which is somewhat inconvenient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们阅读文档中的多对多示例时，他们会遇到一个事实，即如果您两次创建相同的`Keyword`，它会被放入数据库两次。这有点不方便。
- en: This [UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)
    recipe was created to address this issue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个[UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)配方是为了解决这个问题而创建的。
- en: '## Why does post_update emit UPDATE in addition to the first UPDATE?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么post_update除了第一个UPDATE外还发出UPDATE？'
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. While the primary purpose of this UPDATE statement is that
    it pairs up with an INSERT or DELETE of that row, so that it can post-set or pre-unset
    a foreign key reference in order to break a cycle with a mutually dependent foreign
    key, it currently is also bundled as a second UPDATE that emits when the target
    row itself is subject to an UPDATE. In this case, the UPDATE emitted by post_update
    is *usually* unnecessary and will often appear wasteful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: post_update功能，在[指向自身的行/相互依赖的行](../orm/relationship_persistence.html#post-update)文档中记录，涉及在对特定关系绑定的外键进行更改时发出UPDATE语句，除了通常会对目标行发出的INSERT/UPDATE/DELETE之外。虽然这个UPDATE语句的主要目的是与INSERT或DELETE配对，以便它可以在INSERT或DELETE操作后设置或取消设置一个外键引用，以断开与相互依赖的外键的循环，但它目前也被捆绑为在目标行本身被更新时发出的第二个UPDATE。在这种情况下，post_update发出的UPDATE
    *通常* 是不必要的，并且通常会显得浪费。
- en: However, some research into trying to remove this “UPDATE / UPDATE” behavior
    reveals that major changes to the unit of work process would need to occur not
    just throughout the post_update implementation, but also in areas that aren’t
    related to post_update for this to work, in that the order of operations would
    need to be reversed on the non-post_update side in some cases, which in turn can
    impact other cases, such as correctly handling an UPDATE of a referenced primary
    key value (see [#1063](https://www.sqlalchemy.org/trac/ticket/1063) for a proof
    of concept).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对尝试删除这种“UPDATE / UPDATE”行为的一些研究表明，不仅需要在 post_update 实现中进行重大更改，而且还需要在与 post_update
    不相关的区域进行更改，以使其工作，因为在某些情况下需要对非 post_update 部分的操作顺序进行反转，这反过来又会影响其他情况，例如正确处理引用主键值的
    UPDATE（参见[#1063](https://www.sqlalchemy.org/trac/ticket/1063) 以获取概念验证）。
- en: 'The answer is that “post_update” is used to break a cycle between two mutually
    dependent foreign keys, and to have this cycle breaking be limited to just INSERT/DELETE
    of the target table implies that the ordering of UPDATE statements elsewhere would
    need to be liberalized, leading to breakage in other edge cases.  ## I’m re-loading
    data with my Session but it isn’t seeing changes that I committed elsewhere'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，“post_update”用于打破两个相互依赖的外键之间的循环，并且使得此循环打破仅限于目标表的 INSERT/DELETE 意味着其他地方的
    UPDATE 语句的顺序需要变得自由化，导致其他边缘情况的破坏。## 我正在使用我的会话重新加载数据，但它没有看到我在其他地方提交的更改
- en: The main issue regarding this behavior is that the session acts as though the
    transaction is in the *serializable* isolation state, even if it’s not (and it
    usually is not). In practical terms, this means that the session does not alter
    any data that it’s already read within the scope of a transaction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种行为的主要问题是，会话的行为就像事务处于*可串行化*隔离状态一样，即使事务并不是（通常情况下并不是）。从实际角度来看，这意味着会话不会更改已经在事务范围内读取的任何数据。
- en: 'If the term “isolation level” is unfamiliar, then you first need to read this
    link:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果术语“隔离级别”不熟悉，那么您首先需要阅读此链接：
- en: '[Isolation Level](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[隔离级别](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
- en: In short, serializable isolation level generally means that once you SELECT
    a series of rows in a transaction, you will get *the identical data* back each
    time you re-emit that SELECT. If you are in the next-lower isolation level, “repeatable
    read”, you’ll see newly added rows (and no longer see deleted rows), but for rows
    that you’ve *already* loaded, you won’t see any change. Only if you are in a lower
    isolation level, e.g. “read committed”, does it become possible to see a row of
    data change its value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可串行化隔离级别通常意味着一旦您在事务中选择一系列行，您每次重新发出该 SELECT 时都会得到*相同的数据*。如果您处于较低的隔离级别，例如“可重复读”，您将看到新添加的行（不再看到删除的行），但对于您已经*加载*的行，您不会看到任何更改。只有当您处于较低的隔离级别时，例如“读取已提交的”，才有可能看到数据行更改其值。
- en: For information on controlling the isolation level when using the SQLAlchemy
    ORM, see [Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在使用 SQLAlchemy ORM 时控制隔离级别的信息，请参阅[设置事务隔离级别 / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation)。
- en: To simplify things dramatically, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") itself works in terms of a completely isolated transaction,
    and doesn’t overwrite any mapped attributes it’s already read unless you tell
    it to. The use case of trying to re-read data you’ve already loaded in an ongoing
    transaction is an *uncommon* use case that in many cases has no effect, so this
    is considered to be the exception, not the norm; to work within this exception,
    several methods are provided to allow specific data to be reloaded within the
    context of an ongoing transaction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要极大地简化事情，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    本身是在完全隔离的事务中运行的，并且不会覆盖任何已经读取的映射属性，除非你告诉它这样做。在进行中的事务中尝试重新读取已经加载的数据的用例是一个*不常见*的用例，在许多情况下没有效果，因此这被认为是例外而不是规范；为了在这个例外中工作，提供了几种方法，允许在进行中的事务的上下文中重新加载特定的数据。
- en: To understand what we mean by “the transaction” when we talk about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), your [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to only work within a transaction. An overview
    of this is at [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，理解我们所说的“事务”是什么意思，你的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")只能在事务内工作。关于此的概述请参阅[管理事务](../orm/session_transaction.html#unitofwork-transaction)。
- en: Once we’ve figured out what our isolation level is, and we think that our isolation
    level is set at a low enough level so that if we re-SELECT a row, we should see
    new data in our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    how do we see it?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了我们的隔离级别，并且我们认为我们的隔离级别设置得足够低，以至于如果我们重新选择一行，我们应该在我们的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中看到新数据，那我们如何看到它呢？
- en: 'Three ways, from most common to least:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 三种方式，从最常见到最不常见：
- en: We simply end our transaction and start a new one on next access with our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") by calling [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") (note that if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is in the lesser-used “autocommit” mode, there would
    be a call to [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") as well). The vast majority of applications and
    use cases do not have any issues with not being able to “see” data in other transactions
    because they stick to this pattern, which is at the core of the best practice
    of **short lived transactions**. See [When do I construct a Session, when do I
    commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate)
    for some thoughts on this.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需结束当前事务，并在下一次访问时通过调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")（请注意，如果[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")处于较少使用的“自动提交”模式，则还将调用[`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")）。绝大多数应用程序和用例不会出现无法在其他事务中“看到”数据的问题，因为它们遵循这种模式，这是**短事务**最佳实践的核心。有关此问题的一些想法，请参阅[我何时构造一个会话，何时提交它，何时关闭它？](../orm/session_basics.html#session-faq-whentocreate)。
- en: We tell our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to re-read rows that it has already read, either when we next query for them using
    [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"), or immediately on an object using `refresh`.
    See [Refreshing / Expiring](../orm/session_state_management.html#session-expire)
    for detail on this.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉我们的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")重新读取已经读取的行，要么在下次查询它们时使用[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")或[`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")，要么立即在对象上使用`refresh`。有关此操作的详细信息，请参阅[刷新/过期](../orm/session_state_management.html#session-expire)。
- en: We can run whole queries while setting them to definitely overwrite already-loaded
    objects as they read rows by using “populate existing”. This is an execution option
    described at [Populate Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在设置了“填充现有”选项的情况下运行整个查询，以确保在读取行时覆盖已加载的对象。这是一种在[填充现有](../orm/queryguide/api.html#orm-queryguide-populate-existing)中描述的执行选项。
- en: But remember, **the ORM cannot see changes in rows if our isolation level is
    repeatable read or higher, unless we start a new transaction**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，**如果我们的隔离级别是可重复读或更高级别，ORM无法看到行中的更改，除非我们启动一个新的事务**。
- en: '## “This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '## “此会话的事务由于刷新期间的先前异常已被回滚。”（或类似内容）'
- en: This is an error that occurs when a [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") raises an exception, rolls back the transaction,
    but further commands upon the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are called without an explicit call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")引发异常，回滚事务，但在未显式调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的情况下调用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上的进一步命令时，就会发生这种错误。
- en: 'It usually corresponds to an application that catches an exception upon [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and does not properly handle the exception. For
    example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常对应于一个应用程序在[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")或[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")上捕获异常，但未正确处理异常。 例如：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should fit within a structure similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")应该符合类似于这样的结构：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Many things can cause a failure within the try/except besides flushes. Applications
    should ensure some system of “framing” is applied to ORM-oriented processes so
    that connection and transaction resources have a definitive boundary, and so that
    transactions can be explicitly rolled back if any failure conditions occur.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事情除了刷新之外，都可能导致try/except中的失败。 应用程序应确保对ORM导向的进程应用某种“框架”系统，以便连接和事务资源具有明确定界，并且如果发生任何失败条件，则可以显式回滚事务。
- en: This does not mean there should be try/except blocks throughout an application,
    which would not be a scalable architecture. Instead, a typical approach is that
    when ORM-oriented methods and functions are first called, the process that’s calling
    the functions from the very top would be within a block that commits transactions
    at the successful completion of a series of operations, as well as rolls transactions
    back if operations fail for any reason, including failed flushes. There are also
    approaches using function decorators or context managers to achieve similar results.
    The kind of approach taken depends very much on the kind of application being
    written.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着整个应用程序中应该到处都是try/except块，这不是可扩展的架构。 相反，一个典型的方法是，当首次调用ORM导向的方法和函数时，从最顶层调用函数的进程将在成功完成一系列操作时提交事务，并且如果操作因任何原因失败，包括失败的刷新，则回滚事务。
    还有使用函数装饰器或上下文管理器来实现类似结果的方法。 采取的方法取决于正在编写的应用程序的类型。
- en: For a detailed discussion on how to organize usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), please see [When do I construct a Session, when do
    I commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何组织使用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的详细讨论，请参见[何时构建会话，何时提交会话，何时关闭会话？](../orm/session_basics.html#session-faq-whentocreate)。
- en: But why does flush() insist on issuing a ROLLBACK?
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么flush()坚持发出ROLLBACK？
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 能部分完成然后不回滚，那将会很好，但是由于它当前的能力限制，这是不可能的，因为它的内部记录必须被修改，以便随时停止，并且与已刷新到数据库的内容完全一致。虽然这在理论上是可能的，但增强功能的有用性大大降低了，因为许多数据库操作在任何情况下都需要回滚。特别是
    Postgres 有一些操作，一旦失败，事务就不允许继续：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供的解决这两个问题的方法是通过支持 SAVEPOINT，通过 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")。使用 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")，您可以在事务中设置一个可能会失败的操作，然后在保持封闭事务的同时“回滚”到其失败之前的点。
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么一次自动调用 ROLLBACK 不够？为什么我还必须再次 ROLLBACK？
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由 flush() 引起的回滚并不是完整事务块的结束；尽管它结束了正在进行的数据库事务，但从 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的角度来看，仍然存在一个处于非活动状态的事务。
- en: 'Given a block such as:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这样的代码块：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，当一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    第一次被创建时，假设没有使用“自动提交模式”，则在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 内建立了一个逻辑事务。这个事务是“逻辑”的，因为它实际上并不使用任何数据库资源，直到调用 SQL 语句时，此时会启动一个连接级别和
    DBAPI 级别的事务。然而，无论数据库级别的事务是否是其状态的一部分，逻辑事务都会保持不变，直到使用 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 结束它。
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当上面的`flush()`失败时，代码仍位于由try/commit/except/rollback块框定的事务内。 如果`flush()`完全回滚逻辑事务，那么当我们到达`except:`块时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将处于干净状态，准备在全新的事务上发出新的SQL，并且对[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的调用将处于不正确的顺序。 特别是，到这一点为止，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")已经开始了一个新的事务，而[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")将错误地对其进行操作。 与其允许SQL操作在此处继续新事务，而正常用法规定要进行回滚的地方，则[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")拒绝继续，直到显式回滚实际发生。
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，预期调用代码将**始终**调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")与当前事务块对应。 `flush()`保持[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在此事务块中，以便上述代码的行为可预测且一致。
- en: But why does flush() insist on issuing a ROLLBACK?
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么`flush()`坚持要发出一个ROLLBACK呢？
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")可以部分完成然后不回滚，那将是很好的，但是由于其当前能力范围之外，因为其内部记账必须被修改，以便它可以随时停止，并且与已经刷新到数据库的内容完全一致。
    尽管理论上可能，但增强功能的实用性大大降低了，因为许多数据库操作无论如何都要求回滚。 特别是，Postgres有一些操作，一旦失败，就不允许事务继续：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供解决这两个问题的方法是通过 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 支持 SAVEPOINT。使用 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")，您可以在事务中执行一个可能会失败的操作，然后在维持封闭事务的同时“回滚”到失败之前的状态。
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但为什么一次自动调用 ROLLBACK 不够？为什么我必须再次 ROLLBACK？
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由 flush() 引起的回滚不是完整事务块的结束；虽然它结束了正在进行的数据库事务，在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的视角下仍然存在一个现在处于不活动状态的事务。
- en: 'Given a block such as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个如下的块：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，当首次创建一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，假设没有使用“自动提交模式”，则在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")内建立了一个逻辑事务。该事务是“逻辑”的，因为它实际上不使用任何数据库资源，直到调用 SQL 语句，此时开始连接级和
    DBAPI 级的事务。但是，无论数据库级事务是否是其状态的一部分，逻辑事务将保持不变，直到使用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")结束为止。
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当上面的`flush()`失败时，代码仍然处于由try/commit/except/rollback块框定的事务中。如果`flush()`完全回滚了逻辑事务，这意味着当我们到达`except:`块时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将处于干净的状态，准备在一个全新的事务中发出新的SQL，并且对[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的调用将会处于顺序错误的状态。特别是，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")此时已经开始了一个新的事务，而[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")将在错误地执行。与其在这个地方允许SQL操作在新的事务中进行，而正常使用指示将要进行回滚的地方，则[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")拒绝继续，直到显式回滚实际发生为止。
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，期望调用代码**始终**调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")与当前事务块相对应。`flush()`保持[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在这个事务块内，以便上述代码的行为是可预测且一致的。
- en: How do I make a Query that always adds a certain filter to every query?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何创建一个始终向每个查询添加特定过滤器的查询？
- en: See the recipe at [FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery)中的配方。
- en: '## My Query does not return the same number of objects as query.count() tells
    me - why?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我的查询返回的对象数量与 query.count() 告诉我的数量不一样 - 为什么？'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, when asked to return a list of ORM-mapped objects, will **deduplicate
    the objects based on primary key**. That is, if we for example use the `User`
    mapping described at [Using ORM Declarative Forms to Define Table Metadata](../tutorial/metadata.html#tutorial-orm-table-metadata),
    and we had a SQL query like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象被要求返回一个ORM映射对象列表时，将根据主键对对象进行**去重**。也就是说，如果我们例如使用了在[使用ORM声明形式定义表元数据](../tutorial/metadata.html#tutorial-orm-table-metadata)中描述的`User`映射，并且我们有一个如下的SQL查询：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Above, the sample data used in the tutorial has two rows in the `addresses`
    table for the `users` row with the name `''jack''`, primary key value 5. If we
    ask the above query for a [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count"), we will get the answer **2**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，教程中使用的样例数据在`addresses`表中有两行，对应于名为`'jack'`的`users`行，主键值为5。如果我们对上述查询使用[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count")，我们将得到答案**2**：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if we run [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") or iterate over the query, we get back **one element**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行[`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all")或者迭代查询，我们会得到**一个元素**：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is because when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object returns full entities, they are **deduplicated**.
    This does not occur if we instead request individual columns back:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象返回完整实体时，它们会被**去重**。如果我们请求单个列返回，则不会发生这种情况：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two main reasons the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will deduplicate:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")会进行去重的两个主要原因有：'
- en: '**To allow joined eager loading to work correctly** - [Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    works by querying rows using joins against related tables, where it then routes
    rows from those joins into collections upon the lead objects. In order to do this,
    it has to fetch rows where the lead object primary key is repeated for each sub-entry.
    This pattern can then continue into further sub-collections such that a multiple
    of rows may be processed for a single lead object, such as `User(id=5)`. The dedpulication
    allows us to receive objects in the way they were queried, e.g. all the `User()`
    objects whose name is `''jack''` which for us is one object, with the `User.addresses`
    collection eagerly loaded as was indicated either by `lazy=''joined''` on the
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or via the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option. For consistency, the deduplication is still
    applied whether or not the joinedload is established, as the key philosophy behind
    eager loading is that these options never affect the result.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许连接式贪婪加载正常工作** - [连接式贪婪加载](../orm/queryguide/relationships.html#joined-eager-loading)通过使用与相关表的连接查询行，然后将这些连接查询行路由到导航对象的集合中来工作。为了做到这一点，它必须获取重复了主导对象主键的行，以便每个子条目。这种模式可以继续到更进一步的子集合，以便为单个主导对象，如`User(id=5)`，处理多行。去重允许我们按照查询时的方式接收对象，例如，所有`User()`对象其名称为`''jack''`，对我们来说是一个对象，并且`User.addresses`集合被贪婪加载，就像在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上使用`lazy=''joined''`或通过[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")选项指示的那样。为了保持一致性，去重仍然适用于是否已建立连接加载，因为贪婪加载的核心理念是这些选项从不影响结果。'
- en: '**To eliminate confusion regarding the identity map** - this is admittedly
    the less critical reason. As the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") makes use of an [identity map](../glossary.html#term-identity-map),
    even though our SQL result set has two rows with primary key 5, there is only
    one `User(id=5)` object inside the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which must be maintained uniquely on its identity, that
    is, its primary key / class combination. It doesn’t actually make much sense,
    if one is querying for `User()` objects, to get the same object multiple times
    in the list. An ordered set would potentially be a better representation of what
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    seeks to return when it returns full objects.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除关于身份映射的混淆** - 这显然是较不重要的原因。由于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用了一个[身份映射](../glossary.html#term-identity-map)，即使我们的SQL结果集有两行主键为5的记录，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")内也只有一个`User(id=5)`对象，必须以其身份唯一性进行维护，即其主键/类组合。如果查询`User()`对象，获取相同对象多次在列表中实际上没有太多意义。有序集合可能更能代表[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")在返回完整对象时所寻求的内容。'
- en: The issue of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    deduplication remains problematic, mostly for the single reason that the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method is inconsistent, and the current status is
    that joined eager loading has in recent releases been superseded first by the
    “subquery eager loading” strategy and more recently the “select IN eager loading”
    strategy, both of which are generally more appropriate for collection eager loading.
    As this evolution continues, SQLAlchemy may alter this behavior on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which may also involve new APIs in order to more directly
    control this behavior, and may also alter the behavior of joined eager loading
    in order to create a more consistent usage pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    去重的问题仍然存在问题，主要原因是 [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") 方法不一致，当前状态是，在最近的发布中，联合急加载首先被“子查询急加载”策略所取代，更近期的是“选择
    IN 急加载”策略，这两者通常更适用于集合急加载。随着这种演变的继续，SQLAlchemy 可能会改变 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的行为，这也可能涉及到新的 API，以更直接地控制这种行为，并且还可能改变联合急加载的行为，以创建更一致的使用模式。'
- en: I’ve created a mapping against an Outer Join, and while the query returns rows,
    no objects are returned. Why not?
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我已经创建了一个针对 Outer Join 的映射，虽然查询返回了行，但没有返回对象。为什么？
- en: Rows returned by an outer join may contain NULL for part of the primary key,
    as the primary key is the composite of both tables. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object ignores incoming rows that don’t have an acceptable
    primary key. Based on the setting of the `allow_partial_pks` flag on [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"), a primary key is accepted if the value has at least
    one non-NULL value, or alternatively if the value has no NULL values. See `allow_partial_pks`
    at [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 外部连接返回的行可能会对主键的某部分包含 NULL，因为主键是两个表的组合。[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象忽略那些没有可接受主键的传入行。根据 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 上 `allow_partial_pks` 标志的设置，如果值至少有一个非 NULL 值，则接受主键，或者如果值没有
    NULL 值，则接受主键。请参阅 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    上的 `allow_partial_pks`。
- en: I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当我尝试添加 WHERE、ORDER BY、LIMIT 等条件（这依赖于（外部）JOIN）时，我使用 `joinedload()` 或 `lazy=False`
    创建了一个 JOIN/OUTER JOIN，但 SQLAlchemy 在构造查询时出现了问题。
- en: The joins generated by joined eager loading are only used to fully load related
    collections, and are designed to have no impact on the primary results of the
    query. Since they are anonymously aliased, they cannot be referenced directly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由联合急加载生成的连接仅用于完全加载相关集合，并且设计为不会影响查询的主要结果。由于它们是匿名别名，因此不能直接引用。
- en: For detail on this behavior, see [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种行为的详细信息，请参见 [Joined Eager Loading 的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading)。
- en: Query has no `__len__()`, why not?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Query 没有 `__len__()`，为什么？
- en: 'The Python `__len__()` magic method applied to an object allows the `len()`
    builtin to be used to determine the length of the collection. It’s intuitive that
    a SQL query object would link `__len__()` to the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method, which emits a SELECT COUNT. The reason this
    is not possible is because evaluating the query as a list would incur two SQL
    calls instead of one:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `__len__()` 魔法方法应用于对象，允许使用 `len()` 内置函数来确定集合的长度。很直观地，一个 SQL 查询对象会将
    `__len__()` 关联到 [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") 方法，该方法会发出一个 SELECT COUNT。然而，不可能做到这一点的原因是因为将查询作为列表进行评估会导致两个
    SQL 调用而不是一个：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How Do I use Textual SQL with ORM Queries?
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 ORM 查询中使用 Textual SQL？
- en: 'See:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：
- en: '[Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - Ad-hoc textual blocks with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从文本语句获取 ORM 结果](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - 使用 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    进行自定义文本块。'
- en: '[Using SQL Expressions with Sessions](../orm/persistence_techniques.html#session-sql-expressions)
    - Using [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with textual SQL directly.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 SQL 表达式与会话](../orm/persistence_techniques.html#session-sql-expressions)
    - 直接使用文本 SQL 与 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")。'
- en: I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我调用`Session.delete(myobject)`但它没有从父集合中删除！
- en: See [Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](../orm/cascades.html#session-deleting-from-collections) for a description
    of this behavior.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此行为的描述，请参阅 [关于删除的说明 - 从集合和标量关系引用的对象删除](../orm/cascades.html#session-deleting-from-collections)。
- en: why isn’t my `__init__()` called when I load objects?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当我加载对象时，为什么我的`__init__()`没有被调用？
- en: See [Maintaining Non-Mapped State Across Loads](../orm/mapping_styles.html#mapped-class-load-events)
    for a description of this behavior.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此行为的描述，请参阅 [跨加载保持非映射状态](../orm/mapping_styles.html#mapped-class-load-events)。
- en: how do I use ON DELETE CASCADE with SA’s ORM?
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何在 SA 的 ORM 中使用 ON DELETE CASCADE？
- en: SQLAlchemy will always issue UPDATE or DELETE statements for dependent rows
    which are currently loaded in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For rows which are not loaded, it will by default issue
    SELECT statements to load those rows and update/delete those as well; in other
    words it assumes there is no ON DELETE CASCADE configured. To configure SQLAlchemy
    to cooperate with ON DELETE CASCADE, see [Using foreign key ON DELETE cascade
    with ORM relationships](../orm/cascades.html#passive-deletes).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 总是针对当前加载在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的依赖行发出 UPDATE 或 DELETE 语句。对于未加载的行，默认情况下会发出 SELECT 语句来加载这些行，并对其进行更新/删除；换句话说，它假定未配置
    ON DELETE CASCADE。要配置 SQLAlchemy 以配合 ON DELETE CASCADE，请参阅 [使用 ORM 关系的外键 ON DELETE
    cascade](../orm/cascades.html#passive-deletes)。
- en: 'I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我将我的实例的“foo_id”属性设置为“7”，但“foo”属性仍然为`None` - 它不应该加载 ID 为#7的 Foo 吗？
- en: 'The ORM is not constructed in such a way as to support immediate population
    of relationships driven from foreign key attribute changes - instead, it is designed
    to work the other way around - foreign key attributes are handled by the ORM behind
    the scenes, the end user sets up object relationships naturally. Therefore, the
    recommended way to set `o.foo` is to do just that - set it!:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 并非以支持从外键属性更改驱动的关系的即时填充方式构建的 - 相反，它设计为以相反的方式工作 - 外键属性由 ORM 在幕后处理，最终用户自然设置对象关系。因此，设置`o.foo`的推荐方法就是这样
    - 设置它！：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Manipulation of foreign key attributes is of course entirely legal. However,
    setting a foreign-key attribute to a new value currently does not trigger an “expire”
    event of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in which it’s involved. This means that for the
    following sequence:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，操作外键属性是完全合法的。但是，目前设置外键属性为新值不会触发其中涉及的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的“过期”事件。这意味着对于以下序列：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`o.foo` is loaded with its effective database value of `None` when it is first
    accessed. Setting `o.foo_id = 7` will have the value of “7” as a pending change,
    but no flush has occurred - so `o.foo` is still `None`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次访问时，`o.foo`加载为其有效的数据库值`None`。设置`o.foo_id = 7`将使值“7”作为挂起更改，但尚未刷新 - 因此`o.foo`仍然为`None`：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For `o.foo` to load based on the foreign key mutation is usually achieved naturally
    after the commit, which both flushes the new foreign key value and expires all
    state:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`o.foo`的加载，基于外键变异通常在提交后自然实现，这既刷新了新的外键值，也使所有状态失效：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A more minimal operation is to expire the attribute individually - this can
    be performed for any [persistent](../glossary.html#term-persistent) object using
    [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire "sqlalchemy.orm.Session.expire"):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '一个更简单的操作是单独使属性过期 - 这可以针对任何[persistent](../glossary.html#term-persistent)对象使用[`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"):'
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that if the object is not persistent but present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it’s known as [pending](../glossary.html#term-pending).
    This means the row for the object has not been INSERTed into the database yet.
    For such an object, setting `foo_id` does not have meaning until the row is inserted;
    otherwise there is no row yet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果对象不是持久的但存在于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，则称为[pending](../glossary.html#term-pending)。这意味着对象的行尚未INSERT到数据库中。对于这样的对象，设置`foo_id`在行被插入之前没有意义；否则还没有行：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The recipe [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    features an example using SQLAlchemy events in order to coordinate the setting
    of foreign key attributes with many-to-one relationships.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案[ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)提供了一个使用SQLAlchemy事件的示例，以便协调与多对一关系中的外键属性的设置。
- en: '## How do I walk all objects that are related to a given object?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何遍历与给定对象相关的所有对象？'
- en: 'An object that has other objects related to it will correspond to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs set up between mappers. This code fragment
    will iterate all the objects, correcting for cycles as well:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相关的其他对象的对象将与映射器之间设置的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造相对应。这段代码片段将迭代所有对象，纠正循环：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The function can be demonstrated as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以如下所示演示：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Is there a way to automagically have only unique keywords (or other kinds of
    objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有没有一种方法可以自动地只有唯一的关键词（或其他类型的对象），而不必查询关键词并获取包含该关键词的行的引用呢？
- en: When people read the many-to-many example in the docs, they get hit with the
    fact that if you create the same `Keyword` twice, it gets put in the DB twice.
    Which is somewhat inconvenient.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们阅读文档中的多对多示例时，他们会发现如果您创建相同的`Keyword`两次，它会在数据库中出现两次。这有点不方便。
- en: This [UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)
    recipe was created to address this issue.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个[UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)方案是为了解决这个问题而创建的。
- en: '## Why does post_update emit UPDATE in addition to the first UPDATE?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么post_update除了第一个UPDATE之外还会发出UPDATE？'
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. While the primary purpose of this UPDATE statement is that
    it pairs up with an INSERT or DELETE of that row, so that it can post-set or pre-unset
    a foreign key reference in order to break a cycle with a mutually dependent foreign
    key, it currently is also bundled as a second UPDATE that emits when the target
    row itself is subject to an UPDATE. In this case, the UPDATE emitted by post_update
    is *usually* unnecessary and will often appear wasteful.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性，详细说明请参见[指向自身的行/相互依赖行](../orm/relationship_persistence.html#post-update)，会在特定关系绑定的外键发生更改时发出UPDATE语句，除了会针对目标行通常发出的INSERT/UPDATE/DELETE之外。虽然此UPDATE语句的主要目的是与该行的INSERT或DELETE配对，以便它可以在后设置或前取消外键引用，以打破与相互依赖的外键的循环，但目前它也被捆绑为第二个UPDATE，当目标行本身被UPDATE时发出。在这种情况下，post_update发出的UPDATE
    *通常* 是不必要的，并且通常会显得浪费。
- en: However, some research into trying to remove this “UPDATE / UPDATE” behavior
    reveals that major changes to the unit of work process would need to occur not
    just throughout the post_update implementation, but also in areas that aren’t
    related to post_update for this to work, in that the order of operations would
    need to be reversed on the non-post_update side in some cases, which in turn can
    impact other cases, such as correctly handling an UPDATE of a referenced primary
    key value (see [#1063](https://www.sqlalchemy.org/trac/ticket/1063) for a proof
    of concept).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些研究试图消除这种“UPDATE / UPDATE”行为的努力表明，不仅需要在post_update实现中进行重大更改，还需要在与post_update无关的领域进行一些变更，以使其生效，因为在某些情况下，非post_update方面的操作顺序需要被颠倒，这反过来可能会影响其他情况，比如正确处理引用主键值的UPDATE（参见[#1063](https://www.sqlalchemy.org/trac/ticket/1063)以获取概念验证）。
- en: The answer is that “post_update” is used to break a cycle between two mutually
    dependent foreign keys, and to have this cycle breaking be limited to just INSERT/DELETE
    of the target table implies that the ordering of UPDATE statements elsewhere would
    need to be liberalized, leading to breakage in other edge cases.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，“post_update”用于打破两个相互依赖的外键之间的循环，并且使得这种循环打破仅限于目标表的INSERT/DELETE意味着其他地方UPDATE语句的排序需要被放宽，导致其他边缘情况的破坏。
