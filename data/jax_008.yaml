- en: Just-in-time compilation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å³æ—¶ç¼–è¯‘
- en: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/jit-compilation.html`](https://jax.readthedocs.io/en/latest/jit-compilation.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/jit-compilation.html`](https://jax.readthedocs.io/en/latest/jit-compilation.html)
- en: In this section, we will further explore how JAX works, and how we can make
    it performant. We will discuss the `jax.jit()` transformation, which will perform
    *Just In Time* (JIT) compilation of a JAX Python function so it can be executed
    efficiently in XLA.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†è¿›ä¸€æ­¥æ¢è®¨ JAX çš„å·¥ä½œåŸç†ï¼Œä»¥åŠå¦‚ä½•ä½¿å…¶æ€§èƒ½å“è¶Šã€‚æˆ‘ä»¬å°†è®¨è®º `jax.jit()` å˜æ¢ï¼Œå®ƒå°† JAX Python å‡½æ•°è¿›è¡Œå³æ—¶ç¼–è¯‘ï¼Œä»¥ä¾¿åœ¨
    XLA ä¸­é«˜æ•ˆæ‰§è¡Œã€‚
- en: How JAX transformations work
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦‚ä½•å·¥ä½œ JAX å˜æ¢
- en: In the previous section, we discussed that JAX allows us to transform Python
    functions. JAX accomplishes this by reducing each function into a sequence of
    primitive operations, each representing one fundamental unit of computation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº† JAX å…è®¸æˆ‘ä»¬è½¬æ¢ Python å‡½æ•°çš„èƒ½åŠ›ã€‚JAX é€šè¿‡å°†æ¯ä¸ªå‡½æ•°å‡å°‘ä¸ºä¸€ç³»åˆ—åŸå§‹æ“ä½œæ¥å®ç°è¿™ä¸€ç‚¹ï¼Œæ¯ä¸ªåŸå§‹æ“ä½œä»£è¡¨ä¸€ç§åŸºæœ¬çš„è®¡ç®—å•ä½ã€‚
- en: 'One way to see the sequence of primitives behind a function is using `jax.make_jaxpr()`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹å‡½æ•°èƒŒååŸå§‹æ“ä½œåºåˆ—çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `jax.make_jaxpr()`ï¼š
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Understanding Jaxprs section of the documentation provides more information
    on the meaning of the above output.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡æ¡£çš„ç†è§£ Jaxprs éƒ¨åˆ†æä¾›äº†æœ‰å…³ä¸Šè¿°è¾“å‡ºå«ä¹‰çš„æ›´å¤šä¿¡æ¯ã€‚
- en: 'Importantly, notice that the jaxpr does not capture the side-effect present
    in the function: there is nothing in it corresponding to `global_list.append(x)`.
    This is a feature, not a bug: JAX transformations are designed to understand side-effect-free
    (a.k.a. functionally pure) code. If *pure function* and *side-effect* are unfamiliar
    terms, this is explained in a little more detail in [ğŸ”ª JAX - The Sharp Bits ğŸ”ª:
    Pure Functions](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œjaxpr ä¸æ•è·å‡½æ•°ä¸­å­˜åœ¨çš„å‰¯ä½œç”¨ï¼šå…¶ä¸­æ²¡æœ‰å¯¹ `global_list.append(x)` çš„ä»»ä½•å†…å®¹ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ€§ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªé”™è¯¯ï¼šJAX
    å˜æ¢æ—¨åœ¨ç†è§£æ— å‰¯ä½œç”¨ï¼ˆä¹Ÿç§°ä¸ºå‡½æ•°çº¯ç²¹ï¼‰çš„ä»£ç ã€‚å¦‚æœ *çº¯å‡½æ•°* å’Œ *å‰¯ä½œç”¨* æ˜¯é™Œç”Ÿçš„æœ¯è¯­ï¼Œè¿™åœ¨ [ğŸ”ª JAX - The Sharp Bits ğŸ”ª: Pure
    Functions](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions)
    ä¸­æœ‰ç¨å¾®è¯¦ç»†çš„è§£é‡Šã€‚'
- en: Impure functions are dangerous because under JAX transformations they are likely
    not to behave as intended; they might fail silently, or produce surprising downstream
    errors like leaked Tracers. Moreover, JAX often canâ€™t detect when side effects
    are present. (If you want debug printing, use `jax.debug.print()`. To express
    general side-effects at the cost of performance, see `jax.experimental.io_callback()`.
    To check for tracer leaks at the cost of performance, use with `jax.check_tracer_leaks()`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: éçº¯å‡½æ•°å¾ˆå±é™©ï¼Œå› ä¸ºåœ¨ JAX å˜æ¢ä¸‹å®ƒä»¬å¯èƒ½æ— æ³•æŒ‰é¢„æœŸè¿è¡Œï¼›å®ƒä»¬å¯èƒ½ä¼šæ‚„æ— å£°æ¯åœ°å¤±è´¥ï¼Œæˆ–è€…äº§ç”Ÿæ„å¤–çš„ä¸‹æ¸¸é”™è¯¯ï¼Œå¦‚æ³„æ¼çš„è·Ÿè¸ªå™¨ã€‚æ­¤å¤–ï¼ŒJAX é€šå¸¸æ— æ³•æ£€æµ‹åˆ°æ˜¯å¦å­˜åœ¨å‰¯ä½œç”¨ã€‚ï¼ˆå¦‚æœéœ€è¦è°ƒè¯•æ‰“å°ï¼Œè¯·ä½¿ç”¨
    `jax.debug.print()`ã€‚è¦è¡¨è¾¾ä¸€èˆ¬æ€§å‰¯ä½œç”¨è€Œç‰ºç‰²æ€§èƒ½ï¼Œè¯·å‚é˜… `jax.experimental.io_callback()`ã€‚è¦æ£€æŸ¥è·Ÿè¸ªå™¨æ³„æ¼è€Œç‰ºç‰²æ€§èƒ½ï¼Œè¯·ä½¿ç”¨
    `jax.check_tracer_leaks()`ï¼‰ã€‚
- en: When tracing, JAX wraps each argument by a *tracer* object. These tracers then
    record all JAX operations performed on them during the function call (which happens
    in regular Python). Then, JAX uses the tracer records to reconstruct the entire
    function. The output of that reconstruction is the jaxpr. Since the tracers do
    not record the Python side-effects, they do not appear in the jaxpr. However,
    the side-effects still happen during the trace itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è·Ÿè¸ªæ—¶ï¼ŒJAX é€šè¿‡ *è·Ÿè¸ªå™¨* å¯¹è±¡åŒ…è£…æ¯ä¸ªå‚æ•°ã€‚è¿™äº›è·Ÿè¸ªå™¨è®°å½•äº†åœ¨å‡½æ•°è°ƒç”¨æœŸé—´ï¼ˆå³åœ¨å¸¸è§„ Python ä¸­å‘ç”Ÿï¼‰å¯¹å®ƒä»¬æ‰§è¡Œçš„æ‰€æœ‰ JAX æ“ä½œã€‚ç„¶åï¼ŒJAX
    ä½¿ç”¨è·Ÿè¸ªå™¨è®°å½•é‡æ„æ•´ä¸ªå‡½æ•°ã€‚é‡æ„çš„è¾“å‡ºæ˜¯ jaxprã€‚ç”±äºè·Ÿè¸ªå™¨ä¸è®°å½• Python çš„å‰¯ä½œç”¨ï¼Œå®ƒä»¬ä¸ä¼šå‡ºç°åœ¨ jaxpr ä¸­ã€‚ä½†æ˜¯ï¼Œå‰¯ä½œç”¨ä»ä¼šåœ¨è·Ÿè¸ªè¿‡ç¨‹ä¸­å‘ç”Ÿã€‚
- en: 'Note: the Python `print()` function is not pure: the text output is a side-effect
    of the function. Therefore, any `print()` calls will only happen during tracing,
    and will not appear in the jaxpr:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šPython çš„ `print()` å‡½æ•°ä¸æ˜¯çº¯å‡½æ•°ï¼šæ–‡æœ¬è¾“å‡ºæ˜¯å‡½æ•°çš„å‰¯ä½œç”¨ã€‚å› æ­¤ï¼Œåœ¨è·Ÿè¸ªæœŸé—´ï¼Œä»»ä½• `print()` è°ƒç”¨éƒ½å°†åªå‘ç”Ÿä¸€æ¬¡ï¼Œå¹¶ä¸”ä¸ä¼šå‡ºç°åœ¨
    jaxpr ä¸­ï¼š
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See how the printed `x` is a `Traced` object? Thatâ€™s the JAX internals at work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹æ‰“å°å‡ºæ¥çš„ `x` æ˜¯ä¸€ä¸ª `Traced` å¯¹è±¡ï¼Ÿè¿™å°±æ˜¯ JAX å†…éƒ¨çš„å·¥ä½œåŸç†ã€‚
- en: The fact that the Python code runs at least once is strictly an implementation
    detail, and so shouldnâ€™t be relied upon. However, itâ€™s useful to understand as
    you can use it when debugging to print out intermediate values of a computation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python ä»£ç è‡³å°‘è¿è¡Œä¸€æ¬¡çš„äº‹å®ä¸¥æ ¼æ¥è¯´æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼Œå› æ­¤ä¸åº”ä¾èµ–å®ƒã€‚ç„¶è€Œï¼Œåœ¨è°ƒè¯•æ—¶ç†è§£å®ƒæ˜¯æœ‰ç”¨çš„ï¼Œå› ä¸ºæ‚¨å¯ä»¥åœ¨è®¡ç®—çš„ä¸­é—´å€¼æ‰“å°å‡ºæ¥ã€‚
- en: 'A key thing to understand is that a jaxpr captures the function as executed
    on the parameters given to it. For example, if we have a Python conditional, the
    jaxpr will only know about the branch we take:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå…³é”®çš„ç†è§£ç‚¹æ˜¯ï¼Œjaxpræ•æ‰å‡½æ•°åœ¨ç»™å®šå‚æ•°ä¸Šæ‰§è¡Œçš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªPythonæ¡ä»¶è¯­å¥ï¼Œjaxpråªä¼šäº†è§£æˆ‘ä»¬é€‰æ‹©çš„åˆ†æ”¯ï¼š
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JIT compiling a function
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JITç¼–è¯‘å‡½æ•°
- en: 'As explained before, JAX enables operations to execute on CPU/GPU/TPU using
    the same code. Letâ€™s look at an example of computing a *Scaled Exponential Linear
    Unit* ([SELU](https://proceedings.neurips.cc/paper/6698-self-normalizing-neural-networks.pdf)),
    an operation commonly used in deep learning:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä¹‹å‰æ‰€è§£é‡Šçš„ï¼ŒJAXä½¿å¾—æ“ä½œèƒ½å¤Ÿä½¿ç”¨ç›¸åŒçš„ä»£ç åœ¨CPU/GPU/TPUä¸Šæ‰§è¡Œã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªè®¡ç®—*ç¼©æ”¾æŒ‡æ•°çº¿æ€§å•å…ƒ*ï¼ˆ[SELU](https://proceedings.neurips.cc/paper/6698-self-normalizing-neural-networks.pdf)ï¼‰çš„ä¾‹å­ï¼Œè¿™æ˜¯æ·±åº¦å­¦ä¹ ä¸­å¸¸ç”¨çš„æ“ä½œï¼š
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code above is sending one operation at a time to the accelerator. This limits
    the ability of the XLA compiler to optimize our functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä»£ç ä¸€æ¬¡åªå‘é€ä¸€ä¸ªæ“ä½œåˆ°åŠ é€Ÿå™¨ã€‚è¿™é™åˆ¶äº†XLAç¼–è¯‘å™¨ä¼˜åŒ–æˆ‘ä»¬å‡½æ•°çš„èƒ½åŠ›ã€‚
- en: Naturally, what we want to do is give the XLA compiler as much code as possible,
    so it can fully optimize it. For this purpose, JAX provides the `jax.jit()` transformation,
    which will JIT compile a JAX-compatible function. The example below shows how
    to use JIT to speed up the previous function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å°½å¯èƒ½å¤šåœ°å‘XLAç¼–è¯‘å™¨æä¾›ä»£ç ï¼Œä»¥ä¾¿å®ƒèƒ½å¤Ÿå®Œå…¨ä¼˜åŒ–å®ƒã€‚ä¸ºæ­¤ï¼ŒJAXæä¾›äº†`jax.jit()`è½¬æ¢ï¼Œå®ƒå°†å³æ—¶ç¼–è¯‘ä¸€ä¸ªä¸JAXå…¼å®¹çš„å‡½æ•°ã€‚ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨JITåŠ é€Ÿå‰è¿°å‡½æ•°ã€‚
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Hereâ€™s what just happened:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åˆšåˆšå‘ç”Ÿäº†ä»€ä¹ˆäº‹ï¼š
- en: We defined `selu_jit` as the compiled version of `selu`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®šä¹‰äº†`selu_jit`ä½œä¸º`selu`çš„ç¼–è¯‘ç‰ˆæœ¬ã€‚
- en: We called `selu_jit` once on `x`. This is where JAX does its tracing â€“ it needs
    to have some inputs to wrap in tracers, after all. The jaxpr is then compiled
    using XLA into very efficient code optimized for your GPU or TPU. Finally, the
    compiled code is executed to satisfy the call. Subsequent calls to `selu_jit`
    will use the compiled code directly, skipping the python implementation entirely.
    (If we didnâ€™t include the warm-up call separately, everything would still work,
    but then the compilation time would be included in the benchmark. It would still
    be faster, because we run many loops in the benchmark, but it wouldnâ€™t be a fair
    comparison.)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨`x`ä¸Šè°ƒç”¨äº†`selu_jit`ä¸€æ¬¡ã€‚è¿™æ˜¯JAXè¿›è¡Œå…¶è¿½è¸ªçš„åœ°æ–¹ - å®ƒéœ€è¦ä¸€äº›è¾“å…¥æ¥åŒ…è£…æˆè¿½è¸ªå™¨ã€‚ç„¶åï¼Œjaxprä½¿ç”¨XLAç¼–è¯‘æˆéå¸¸é«˜æ•ˆçš„ä»£ç ï¼Œé’ˆå¯¹æ‚¨çš„GPUæˆ–TPUè¿›è¡Œä¼˜åŒ–ã€‚æœ€åï¼Œç¼–è¯‘çš„ä»£ç è¢«æ‰§è¡Œä»¥æ»¡è¶³è°ƒç”¨ã€‚åç»­å¯¹`selu_jit`çš„è°ƒç”¨å°†ç›´æ¥ä½¿ç”¨ç¼–è¯‘åçš„ä»£ç ï¼Œè·³è¿‡Pythonå®ç°ã€‚ï¼ˆå¦‚æœæˆ‘ä»¬æ²¡æœ‰å•ç‹¬åŒ…æ‹¬é¢„çƒ­è°ƒç”¨ï¼Œä¸€åˆ‡ä»å°†æ­£å¸¸è¿è¡Œï¼Œä½†ç¼–è¯‘æ—¶é—´å°†åŒ…å«åœ¨åŸºå‡†æµ‹è¯•ä¸­ã€‚å› ä¸ºæˆ‘ä»¬åœ¨åŸºå‡†æµ‹è¯•ä¸­è¿è¡Œå¤šä¸ªå¾ªç¯ï¼Œæ‰€ä»¥ä»ä¼šæ›´å¿«ï¼Œä½†è¿™ä¸æ˜¯å…¬å¹³çš„æ¯”è¾ƒã€‚ï¼‰
- en: We timed the execution speed of the compiled version. (Note the use of `block_until_ready()`,
    which is required due to JAXâ€™s Asynchronous dispatch).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è®¡æ—¶äº†ç¼–è¯‘ç‰ˆæœ¬çš„æ‰§è¡Œé€Ÿåº¦ã€‚ï¼ˆæ³¨æ„ä½¿ç”¨`block_until_ready()`ï¼Œè¿™æ˜¯ç”±äºJAXçš„å¼‚æ­¥è°ƒåº¦æ‰€éœ€ã€‚ï¼‰
- en: Why canâ€™t we just JIT everything?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸èƒ½æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½å³æ—¶ç¼–è¯‘ï¼ˆJITï¼‰å‘¢ï¼Ÿ
- en: After going through the example above, you might be wondering whether we should
    simply apply `jax.jit()` to every function. To understand why this is not the
    case, and when we should/shouldnâ€™t apply `jit`, letâ€™s first check some cases where
    JIT doesnâ€™t work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œä½ å¯èƒ½ä¼šæƒ³çŸ¥é“æˆ‘ä»¬æ˜¯å¦åº”è¯¥ç®€å•åœ°å¯¹æ¯ä¸ªå‡½æ•°åº”ç”¨`jax.jit()`ã€‚è¦ç†è§£ä¸ºä»€ä¹ˆä¸æ˜¯è¿™æ ·ï¼Œå¹¶ä¸”ä½•æ—¶éœ€è¦/ä¸éœ€è¦åº”ç”¨`jit`ï¼Œè®©æˆ‘ä»¬é¦–å…ˆæ£€æŸ¥ä¸€äº›`jit`ä¸é€‚ç”¨çš„æƒ…å†µã€‚
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The problem in both cases is that we tried to condition the trace-time flow
    of the program using runtime values. Traced values within JIT, like `x` and `n`
    here, can only affect control flow via their static attributes: such as `shape`
    or `dtype`, and not via their values. For more detail on the interaction between
    Python control flow and JAX, see [ğŸ”ª JAX - The Sharp Bits ğŸ”ª: Control Flow](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#control-flow).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å°è¯•ä½¿ç”¨è¿è¡Œæ—¶å€¼æ¥æ¡ä»¶è¿½è¸ªæ—¶é—´æµç¨‹ã€‚åœ¨JITä¸­è¿½è¸ªçš„å€¼ï¼Œä¾‹å¦‚è¿™é‡Œçš„`x`å’Œ`n`ï¼Œåªèƒ½é€šè¿‡å®ƒä»¬çš„é™æ€å±æ€§ï¼ˆå¦‚`shape`æˆ–`dtype`ï¼‰å½±å“æ§åˆ¶æµï¼Œè€Œä¸èƒ½é€šè¿‡å®ƒä»¬çš„å€¼ã€‚æœ‰å…³Pythonæ§åˆ¶æµä¸JAXäº¤äº’çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§[ğŸ”ª
    JAX - The Sharp Bits ğŸ”ª: Control Flow](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#control-flow)ã€‚'
- en: 'One way to deal with this problem is to rewrite the code to avoid conditionals
    on value. Another is to use special Control flow operators like `jax.lax.cond()`.
    However, sometimes that is not possible or practical. In that case, you can consider
    JIT-compiling only part of the function. For example, if the most computationally
    expensive part of the function is inside the loop, we can JIT-compile just that
    inner part (though make sure to check the next section on caching to avoid shooting
    yourself in the foot):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¤„ç†è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯é‡å†™ä»£ç ï¼Œé¿å…åœ¨å€¼æ¡ä»¶ä¸Šä½¿ç”¨æ¡ä»¶è¯­å¥ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ç‰¹æ®Šçš„æ§åˆ¶æµæ“ä½œç¬¦ï¼Œä¾‹å¦‚`jax.lax.cond()`ã€‚ç„¶è€Œï¼Œæœ‰æ—¶è¿™å¹¶ä¸å¯è¡Œæˆ–å®é™…ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥è€ƒè™‘åªå¯¹å‡½æ•°çš„éƒ¨åˆ†è¿›è¡ŒJITç¼–è¯‘ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå‡½æ•°ä¸­æœ€æ¶ˆè€—è®¡ç®—èµ„æºçš„éƒ¨åˆ†åœ¨å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬å¯ä»¥åªå¯¹å†…éƒ¨çš„é‚£éƒ¨åˆ†è¿›è¡ŒJITç¼–è¯‘ï¼ˆä½†åŠ¡å¿…æŸ¥çœ‹å…³äºç¼“å­˜çš„ä¸‹ä¸€èŠ‚ï¼Œä»¥é¿å…å‡ºç°é—®é¢˜ï¼‰ï¼š
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Marking arguments as static
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å°†å‚æ•°æ ‡è®°ä¸ºé™æ€çš„
- en: If we really need to JIT-compile a function that has a condition on the value
    of an input, we can tell JAX to help itself to a less abstract tracer for a particular
    input by specifying `static_argnums` or `static_argnames`. The cost of this is
    that the resulting jaxpr and compiled artifact depends on the particular value
    passed, and so JAX will have to re-compile the function for every new value of
    the specified static input. It is only a good strategy if the function is guaranteed
    to see a limited set of static values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦å¯¹å…·æœ‰è¾“å…¥å€¼æ¡ä»¶çš„å‡½æ•°è¿›è¡ŒJITç¼–è¯‘ï¼Œæˆ‘ä»¬å¯ä»¥å‘Šè¯‰JAXé€šè¿‡æŒ‡å®š`static_argnums`æˆ–`static_argnames`æ¥å¸®åŠ©è‡ªå·±è·å–ç‰¹å®šè¾“å…¥çš„è¾ƒå°‘æŠ½è±¡çš„è¿½è¸ªå™¨ã€‚è¿™æ ·åšçš„æˆæœ¬æ˜¯ç”Ÿæˆçš„jaxprå’Œç¼–è¯‘çš„å·¥ä»¶ä¾èµ–äºä¼ é€’çš„ç‰¹å®šå€¼ï¼Œå› æ­¤JAXå°†ä¸å¾—ä¸é’ˆå¯¹æŒ‡å®šé™æ€è¾“å…¥çš„æ¯ä¸ªæ–°å€¼é‡æ–°ç¼–è¯‘å‡½æ•°ã€‚åªæœ‰åœ¨å‡½æ•°ä¿è¯çœ‹åˆ°æœ‰é™çš„é™æ€å€¼é›†æ—¶ï¼Œè¿™æ‰æ˜¯ä¸€ä¸ªå¥½ç­–ç•¥ã€‚
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To specify such arguments when using `jit` as a decorator, a common pattern
    is to use pythonâ€™s [`functools.partial()`](https://docs.python.org/3/library/functools.html#functools.partial
    "(in Python v3.12)"):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨`jit`ä½œä¸ºè£…é¥°å™¨æ—¶ï¼Œè¦æŒ‡å®šè¿™äº›å‚æ•°çš„ä¸€ç§å¸¸è§æ¨¡å¼æ˜¯ä½¿ç”¨Pythonçš„[`functools.partial()`](https://docs.python.org/3/library/functools.html#functools.partial
    "(åœ¨Python v3.12ä¸­)")ï¼š
- en: '[PRE20]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: JIT and caching
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JITå’Œç¼“å­˜
- en: With the compilation overhead of the first JIT call, understanding how and when
    `jax.jit()` caches previous compilations is key to using it effectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ç¬¬ä¸€æ¬¡JITè°ƒç”¨çš„ç¼–è¯‘å¼€é”€ï¼Œäº†è§£`jax.jit()`å¦‚ä½•ä»¥åŠä½•æ—¶ç¼“å­˜å…ˆå‰çš„ç¼–è¯‘æ˜¯æœ‰æ•ˆä½¿ç”¨å®ƒçš„å…³é”®ã€‚
- en: Suppose we define `f = jax.jit(g)`. When we first invoke `f`, it will get compiled,
    and the resulting XLA code will get cached. Subsequent calls of `f` will reuse
    the cached code. This is how `jax.jit` makes up for the up-front cost of compilation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬å®šä¹‰`f = jax.jit(g)`ã€‚å½“æˆ‘ä»¬é¦–æ¬¡è°ƒç”¨`f`æ—¶ï¼Œå®ƒä¼šè¢«ç¼–è¯‘ï¼Œå¹¶ä¸”ç”Ÿæˆçš„XLAä»£ç å°†è¢«ç¼“å­˜ã€‚åç»­è°ƒç”¨`f`å°†é‡ç”¨ç¼“å­˜çš„ä»£ç ã€‚è¿™å°±æ˜¯`jax.jit`å¦‚ä½•å¼¥è¡¥ç¼–è¯‘çš„å‰æœŸæˆæœ¬ã€‚
- en: If we specify `static_argnums`, then the cached code will be used only for the
    same values of arguments labelled as static. If any of them change, recompilation
    occurs. If there are many values, then your program might spend more time compiling
    than it would have executing ops one-by-one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æŒ‡å®šäº†`static_argnums`ï¼Œé‚£ä¹ˆç¼“å­˜çš„ä»£ç å°†ä»…åœ¨æ ‡è®°ä¸ºé™æ€çš„å‚æ•°å€¼ç›¸åŒæ—¶ä½¿ç”¨ã€‚å¦‚æœå®ƒä»¬ä¸­ä»»ä½•ä¸€ä¸ªå‘ç”Ÿæ›´æ”¹ï¼Œå°†é‡æ–°ç¼–è¯‘ã€‚å¦‚æœå­˜åœ¨è®¸å¤šå€¼ï¼Œåˆ™æ‚¨çš„ç¨‹åºå¯èƒ½ä¼šèŠ±è´¹æ›´å¤šæ—¶é—´è¿›è¡Œç¼–è¯‘ï¼Œè€Œä¸æ˜¯é€ä¸ªæ‰§è¡Œæ“ä½œã€‚
- en: 'Avoid calling `jax.jit()` on temporary functions defined inside loops or other
    Python scopes. For most cases, JAX will be able to use the compiled, cached function
    in subsequent calls to `jax.jit()`. However, because the cache relies on the hash
    of the function, it becomes problematic when equivalent functions are redefined.
    This will cause unnecessary compilation each time in the loop:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: é¿å…åœ¨å¾ªç¯æˆ–å…¶ä»–Pythonä½œç”¨åŸŸå†…å®šä¹‰çš„ä¸´æ—¶å‡½æ•°ä¸Šè°ƒç”¨`jax.jit()`ã€‚å¯¹äºå¤§å¤šæ•°æƒ…å†µï¼ŒJAXèƒ½å¤Ÿåœ¨åç»­è°ƒç”¨`jax.jit()`æ—¶ä½¿ç”¨ç¼–è¯‘å’Œç¼“å­˜çš„å‡½æ•°ã€‚ç„¶è€Œï¼Œç”±äºç¼“å­˜ä¾èµ–äºå‡½æ•°çš„å“ˆå¸Œå€¼ï¼Œåœ¨é‡æ–°å®šä¹‰ç­‰ä»·å‡½æ•°æ—¶ä¼šå¼•å‘é—®é¢˜ã€‚è¿™å°†å¯¼è‡´æ¯æ¬¡åœ¨å¾ªç¯ä¸­ä¸å¿…è¦åœ°é‡æ–°ç¼–è¯‘ï¼š
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
