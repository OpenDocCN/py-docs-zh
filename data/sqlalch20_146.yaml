- en: What’s New in SQLAlchemy 0.9?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.9中的新功能是什么？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_09.html](https://docs.sqlalchemy.org/en/20/changelog/migration_09.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_09.html](https://docs.sqlalchemy.org/en/20/changelog/migration_09.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.8, undergoing maintenance
    releases as of May, 2013, and SQLAlchemy version 0.9, which had its first production
    release on December 30, 2013.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了SQLAlchemy版本0.8与版本0.9之间的变化，截至2013年5月，0.8版本正在进行维护，而0.9版本在2013年12月30日首次发布。
- en: 'Document last updated: June 10, 2015'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档最后更新日期：2015年6月10日
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.9, and also documents
    changes which affect users migrating their applications from the 0.8 series of
    SQLAlchemy to 0.9.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy版本0.9中的新功能，还记录了影响将应用程序从SQLAlchemy 0.8系列迁移到0.9的用户的更改。
- en: Please carefully review [Behavioral Changes - ORM](#behavioral-changes-orm-09)
    and [Behavioral Changes - Core](#behavioral-changes-core-09) for potentially backwards-incompatible
    changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看[行为变化 - ORM](#behavioral-changes-orm-09)和[行为变化 - 核心](#behavioral-changes-core-09)，以了解可能导致不兼容的变化。
- en: Platform Support
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在，Python 2.6及以上版本的目标是，Python 3不再需要2to3
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9版本的第一个成就是移除对Python 3兼容性的2to3工具的依赖。为了更直接，现在目标最低的Python版本是2.6，它具有与Python 3广泛的交叉兼容性。现在，所有SQLAlchemy模块和单元测试都可以在从2.6开始的任何Python解释器上等效地解释，包括3.1和3.2解释器。
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
- en: C Extensions Supported on Python 3
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C扩展在Python 3上得到支持
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C扩展已被移植以支持Python 3，现在在Python 2和Python 3环境中均可构建。
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
- en: '## Behavioral Changes - ORM'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '## 行为变化 - ORM'
- en: '### Composite attributes are now returned as their object form when queried
    on a per-attribute basis'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当按属性查询时，现在会返回组合属性的对象形式'
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")与组合属性结合使用时，会返回由该组合维护的对象类型，而不是被拆分为个别列。使用在[组合列类型](../orm/composites.html#mapper-composite)中设置的映射：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变与期望个别属性扩展为个别列的代码不兼容。要获得该行为，请使用`.clauses`访问器：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column Bundles for ORM queries](#change-2824)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM查询的列捆绑](#change-2824)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")不再将子句应用于相应的实体'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的版本中，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")方法已经被广泛应用，作为控制[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象“选择自”的第一件事的手段，通常用于控制JOIN的渲染方式。
- en: 'Consider the following example against the usual `User` mapping:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下例子与通常的`User`映射对比：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above statement predictably renders SQL like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句可预见地生成类似以下的SQL：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要颠倒JOIN的左右元素的顺序，文档会让我们相信可以使用[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")来实现：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在0.8版本及更早版本中，上述对[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")的使用会将`select_stmt`应用于**替换**`User`实体，因为它选择了与`User`兼容的`user`表：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句混乱不堪，ON子句引用了`anon_1.id = anon_1.id`，我们的WHERE子句也被替换为`anon_1`。
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是完全有意的，但与已经变得流行的[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")有不同的用例。上述行为现在可以通过一个名为`Query.select_entity_from()`的新方法来实现。这是一个较少使用的行为，在现代SQLAlchemy中大致相当于从自定义的[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造中选择：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在SQLAlchemy 0.9中，我们从`select_stmt`选择的查询会产生我们期望的SQL：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.select_entity_from()`方法将在SQLAlchemy **0.8.2**中可用，因此依赖旧行为的应用程序可以首先过渡到这种方法，确保所有测试继续正常运行，然后无问题地升级到0.9。'
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` on
    `relationship()` prevents history from taking effect'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` on
    `relationship()` prevents history from taking effect'
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上的`viewonly`标志被应用于防止对目标属性的更改在刷新过程中产生任何影响。这是通过在刷新过程中排除属性来实现的。然而，直到现在，对属性的更改仍然会将父对象标记为“脏”，并触发潜在的刷新。改变是`viewonly`标志现在也阻止为目标属性设置历史记录。像反向引用和用户定义事件这样的属性事件仍然会正常工作。
- en: 'The change is illustrated as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 改变如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### Association Proxy
    SQL Expression Improvements and Fixes'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### 关联代理SQL表达式改进和修复'
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联代理实现的`==`和`!=`运算符，引用标量关系上的标量值，现在会产生更完整的SQL表达式，旨在考虑当比较对象为`None`时“关联”行是否存在。
- en: 'Consider this mapping:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下映射：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Up through 0.8, a query like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8之前，像下面这样的查询：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'would produce:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In 0.9, it now produces:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9中，现在会产生：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，它不仅检查 `b.value`，还检查 `a` 是否根本没有关联到任何 `b` 行。对于使用这种类型比较的系统，一些父行没有关联行，这将与之前的版本返回不同的结果。
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更为关键的是，对于 `A.b_value != None`，会发出正确的表达式。在 0.8 中，对于没有 `b` 的 `A` 行，这将返回 `True`：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 0.9 中，检查已经重新设计，以确保 A.b_id 行存在，另外 `B.value` 不为 NULL：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`has()` 操作符得到增强，使得你可以只针对标量列值调用它，而无需任何条件，它将生成检查关联行是否存在的条件：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于 `A.b.has()`，但允许直接针对 `b_value` 进行查询。
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### Association Proxy
    Missing Scalar returns None'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### 关联代理缺失标量返回 None'
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从标量属性到标量的关联代理现在如果被代理对象不存在将返回 `None`。这与 SQLAlchemy 中缺少多对一关系返回 None 的事实一致，因此代理值也应该如此。例如：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()
    will query from the DB by default if value not present'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()
    默认情况下将从数据���查询如果值不存在'
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了关于[`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history")的 bug，允许基于列的属性向数据库查询未加载的值，假设 `passive`
    标志保持默认值 `PASSIVE_OFF`。之前，此标志不会被遵守。此外，新增了一个方法[`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history")来补充[`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")属性，它将为未加载的属性发出加载器可调用。
- en: 'This is a small change demonstrated as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小改变的示例：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ## Behavioral Changes
    - Core'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ## 行为变更 - 核心'
- en: Type objects no longer accept ignored keyword arguments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型对象不再接受被忽略的关键字参数
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 系列中，大多数类型对象接受任意关键字参数，这些参数会被静默忽略：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常古老的 bug，为此在 0.8 系列中添加了一个弃用警告，但因为几乎没有人使用带有“-W”标志的 Python，所以几乎从未见过：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0.9 系列开始，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 中的“catch all” 构造函数被移除，这些无意义的参数不再被接受。
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方言特定参数如 `storage_format` 和 `display_width` 的正确方法是使用适当的方言特定类型：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们还需要方言无关的类型时呢？我们使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 方法：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 并不是新的，它是在 SQLAlchemy 0.7.2 中添加的。所以可以将在
    0.8 系列上运行的代码修改为使用这种方法，并在升级到 0.9 之前进行测试。'
- en: '`None` can no longer be used as a “partial AND” constructor'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`None` 不再能够被用作 “部分 AND” 构造函数'
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 不再能够被用作逐步形成 AND 条件的 “后备”。即使一些 SQLAlchemy 内部使用了这种模式，但这种模式并没有被记录在案：'
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 上，当 `conditions` 不为空时，将产生 `SELECT .. WHERE <condition> AND NULL`。`None`
    不再被隐式忽略，而是与在其他上下文中解释 `None` 时一致。
- en: 'The correct code for both 0.8 and 0.9 should read:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8 和 0.9 的正确代码应该是：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变体，在 0.9 上对所有后端都有效，但在 0.8 上仅在支持布尔常量的后端上有效：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 上，这将生成一个始终在 WHERE 子句中具有 `AND true` 的 SELECT 语句，这是不被不支持布尔常量的后端（MySQL，MSSQL）接受的。在
    0.9 上，`true` 常量将在 `and_()` 连接中被删除。
- en: See also
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量、NULL 常量、连接词的渲染已经得到改进
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '### `create_engine()` 的 “password” 部分不再将 `+` 号视为已编码的空格'
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不知何故，Python 函数 `unquote_plus()` 被应用于 URL 的 “password” 字段，这是对 [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt)
    中描述的编码规则的错误应用，因为它将空格转义为加号。URL 的字符串化现在只编码 “:”，“@” 或 “/”，不编码其他任何字符，并且现在应用于 `username`
    和 `password` 字段（以前只应用于密码）。在解析时，编码字符会被转换，但加号和空格会原样传递：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### The precedence rules
    for COLLATE have been changed'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### COLLATE 的优先规则已经更改'
- en: 'Previously, an expression like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，类似以下的表达式：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'would produce an expression like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生这样的表达式：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况被 MSSQL 误解，通常不是任何数据库建议的语法。现在该表达式将生成大多数数据库文档所示的语法：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 操作符被应用于右侧列，则会出现潜在的不向后兼容的更改，如下所示：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In 0.8, this produces:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 中，这将产生：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 0.9 中，现在将产生更准确的，但可能不是您想要的形式：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 运算符现在在`ORDER BY`表达式中的使用更加恰当，因为给`ASC`和`DESC`运算符指定了特定的优先级，这将再次确保不生成括号：'
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM now applies quoting to values'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM 现在对值应用引号'
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    类型现在将对枚举值中的单引号符号应用转义：'
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 已经转义单引号符号的现有解决方法需要进行修改，否则它们现在会双重转义。
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
- en: New Features
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: '### Event Removal API'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '### 事件移除 API'
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")或[`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for")建立的事件现在可以使用新的[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")函数进行移除。传递给[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")的`target`、`identifier`和`fn`参数需要与监听时发送的完全匹配，并且事件将从其已建立的所有位置中移除：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，设置了`propagate=True`标志。这意味着`my_before_insert()`被建立为`MyClass`以及`MyClass`的所有子类的监听器。系统跟踪到`my_before_insert()`监听函数在此调用的结果中被放置的所有位置，并在调用[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")时将其移除。
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 移除系统使用注册表将传递给[`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")的参数与事件监听器的集合相关联，这些监听器在许多情况下是原始用户提供的函数的包装版本。此注册表大量使用弱引用，以允许所有包含的内容（如监听器目标）在其超出范围时被垃圾收集。
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### New Query Options
    API; `load_only()` option'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### 新查询选项 API; `load_only()`
    选项'
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项的系统，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")、[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")等，都建立在一个称为[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")的新系统之上。[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")提供了一种“方法链式”（又称[生成式](../glossary.html#term-generative)）的加载器选项方法，因此不再需要使用点号或多个属性名称将长路径连接在一起，而是为每个路径提供明确的加载器样式。
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新方式稍微更冗长，但更容易理解，因为在应用哪些选项到哪些路径上没有歧义；它简化了选项的方法签名，并为基于列的选项提供了更大的灵活性。旧系统将一直保持功能，并且所有样式都可以混合使用。
- en: '**Old Way**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方式**'
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多元素路径中的每个链接上设置特定的加载样式，必须使用`_all()`选项：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**New Way**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方式**'
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载器选项是可链式的，因此相同的`joinedload(x)`方法等同地应用于每个链接，无需在[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和`joinedload_all()`之间保持清晰：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Old Way**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方式**'
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于子类的路径上设置选项需要将路径中的所有链接拼写为类绑定属性，因为需要调用[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**New Way**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方式**'
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只有路径中实际需要[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")的元素需要设置为类绑定属性，之后可以恢复使用基于字符串的名称：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Old Way**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方式**'
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在长路径中设置加载器选项的最后一个链接使用的语法看起来很像应该为路径中的所有链接设置选项，导致混淆：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**New Way**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方式**'
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用[`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")来明确指定路径，其中现有的加载器样式不应更改。更冗长但意图更清晰：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以利用点��样式，特别是在跳过几个路径元素的情况下：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Old Way**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方式**'
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径上需要为每一列拼写完整路径的 [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 选项：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**New Way**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方式**'
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个到达目标路径的单个 [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") 对象可以反复调用 [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer")：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The Load Class
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载类
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    类可以直接用于提供“绑定”目标，特别是当存在多个父实体时：'
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Load Only
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅加载
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新选项 [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 实现了“除了延迟加载其他所有内容”的加载方式，仅加载给定列并推迟其余内容：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Class-specific Wildcards
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类特定的通配符
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")，可以使用通配符来设置给定实体上所有关系（或者列）的加载方式，而不影响其他实体：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### New `text()` Capabilities'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### 新的 `text()` 功能'
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    构造获得了新的方法：'
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") 允许灵活设置绑定参数类型和值：'
- en: '[PRE48]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 取代了 [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 的 `typemap` 选项，返回一个新的构造 `TextAsFrom`：'
- en: '[PRE49]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### INSERT from SELECT'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### 从 SELECT 插入'
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几乎多年的毫无意义的拖延，这个相对较小的语法特性已经被添加，并且也被回溯到了 0.8.3，所以在技术上并不是 0.9 中的“新”特性。可以将一个 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造或其他兼容的构造传递给新方法 [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")，它将用于渲染一个 `INSERT .. SELECT` 构造：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该构造足够智能，也可以适应诸如类和 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象等 ORM 对象：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'rendering:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### New FOR UPDATE support
    on `select()`, `Query()`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### `select()`、`Query()`
    上的新 FOR UPDATE 支持'
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 试图简化 Core 和 ORM 中对 `SELECT` 语句上的 `FOR UPDATE` 子句的规范，并支持 PostgreSQL 和 Oracle
    支持的 `FOR UPDATE OF` SQL。
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心 [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")，可以单独指定 `FOR SHARE`
    和 `NOWAIT` 等选项，而不是链接到任意字符串代码：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'On Posgtresql the above statement might render like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Posgtresql 上述语句可能会呈现为：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.  ### Floating Point String-Conversion
    Precision Configurable for Native Floating Point Types'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象获得了一个类似的方法 [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")，其行为方式相同。这个方法取代了现有的 `Query.with_lockmode()`
    方法，该方法使用不同的系统翻译 `FOR UPDATE` 子句。目前，“lockmode” 字符串参数仍然被 [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法接受。### 可配置原生浮点类型的浮点字符串转换精度'
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 DBAPI 返回一个要转换为 Python `Decimal()` 的 Python 浮点类型时，SQLAlchemy 都会进行转换，这必然涉及将浮点值转换为字符串的中间步骤。此字符串转换的比例以前是硬编码为
    10，现在可以配置。这个设置在 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 和 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 类型以及所有 SQL 和方言特定的后代类型上都可用，使用参数 `decimal_return_scale`。如果类型支持
    `.scale` 参数，比如 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    和一些浮点类型如 `DOUBLE`，如果没有另外指定，`.scale` 的值将作为 `.decimal_return_scale` 的默认值。如果 `.scale`
    和 `.decimal_return_scale` 都不存在，则默认值为 10。例如：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### Column Bundles for
    ORM queries'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### ORM 查询的列捆绑'
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    允许查询一组列，然后将它们分组为查询返回的元组下的一个名称。 [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") 的初始目的是 1\. 允许将“复合”ORM列作为列式结果集中的单个值返回，而不是将它们展开为单独的列，以及
    2\. 允许在 ORM 中创建自定义结果集构造，使用临时列和返回类型，而不涉及映射类的更重量级机制。'
- en: See also
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[组合属性现在在按属性查询时以其对象形式返回](#migration-2824)'
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Bundles 对选定属性进行分组](../orm/queryguide/select.html#bundles)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
- en: Server Side Version Counting
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端版本计数
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的版本控制功能（现在也在[配置版本计数器](../orm/versioning.html#mapper-version-counter)中有文档）现在可以利用服务器端的版本计数方案，例如由触发器或数据库系统列生成的方案，以及版本_id_counter
    函数之外的条件编程方案。 通过向 `version_id_generator` 参数提供值 `False`，ORM 将使用已设置的版本标识符，或者在发出 INSERT
    或 UPDATE 时同时从每行获取版本标识符。 当使用服务器生成的版本标识符时，强烈建议仅在具有强大 RETURNING 支持的后端上使用此功能（PostgreSQL、SQL
    Server；Oracle 也支持 RETURNING，但 cx_oracle 驱动程序仅具有有限的支持），否则额外的 SELECT 语句将增加显着的性能开销。
    在[服务器端版本计数器](../orm/versioning.html#server-side-version-counter)提供的示例中说明了使用 PostgreSQL
    的 `xmin` 系统列以将其与 ORM 的版本控制功能集成。
- en: See also
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[服务器端版本计数器](../orm/versioning.html#server-side-version-counter)'
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
- en: '### `include_backrefs=False` option for `@validates`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '### `include_backrefs=False` 选项用于 `@validates`'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")
    函数现在接受一个选项 `include_backrefs=True`，这将绕过为从 backref 发起的事件触发验证器的情况：'
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
- en: PostgreSQL JSON Type
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL JSON 类型
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在具有一个 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 类型，以补充 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 类型。
- en: See also
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
- en: '### Automap Extension'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '### Automap 扩展'
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **0.9.1** 中添加了一个名为 [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") 的新扩展。 这是一个 **实验性** 扩展，它扩展了声明性的功能以及 [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") 类的功能。 本质上，该扩展提供了一个基类 [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")，根据给定的表元数据自动生成映射类和它们之间的关系。
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    可能是通过反射生成的，但不要求使用反射。 最基本的用法说明了 [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") 如何根据反射模式提供映射类，包括关系：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 类是一个声明基类，并支持所有声明所支持的功能。 “自动映射”功能可用于现有的、明确声明的模式，以仅生成关系和缺失类。
    命名方案和关系生成例程可以通过可调用函数添加。
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 希望 [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 系统提供了一个快速和现代化的解决方案，解决了非常著名的 [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    也试图解决的问题，即从现有数据库快速生成一个简单的对象模型。 通过严格在映射器配置级别解决问题，并与现有的声明类技术完全集成，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") 试图提供一个与问题紧密集成的方法，以便快速生成临时映射。
- en: See also
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](../orm/extensions/automap.html)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[Automap](../orm/extensions/automap.html)'
- en: Behavioral Improvements
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为改进
- en: Improvements that should produce no compatibility issues except in exceedingly
    rare and unusual hypothetical cases, but are good to be aware of in case there
    are unexpected issues.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 应该产生没有兼容性问题的改进，除非在极为罕见和异常的假设情况下，但最好知道这些改进，以防出现意外问题。
- en: '### Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped in
    (SELECT * FROM ..) AS ANON_1'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '### 许多 JOIN 和 LEFT OUTER JOIN 表达式将不再被包装在 (SELECT * FROM ..) AS ANON_1 中'
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，SQLAlchemy ORM 一直无法将 JOIN 嵌套在现有 JOIN 的右侧（通常是 LEFT OUTER JOIN，因为 INNER JOIN
    总是可以被展平）：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 SQLite 直到版本 **3.7.16** 都无法解析上述格式的语句：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '右外连接当然是解决右侧括号化的另一种方法；这将变得非常复杂和视觉上不愉快，但幸运的是 SQLite 也不支持 RIGHT OUTER JOIN :):'
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 早在 2005 年，不清楚其他数据库是否有问题，但今天似乎很明显，除 SQLite 外，每个经过测试的数据库都支持它（Oracle 8，一个非常古老的数据库，根本不支持
    JOIN 关键字，但 SQLAlchemy 一直对 Oracle 的语法有一个简单的重写方案）。更糟糕的是，SQLAlchemy 通常的解决方法是在像 PostgreSQL
    和 MySQL 这样的平台上应用 SELECT 通常会降低性能：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类似上面形式的 JOIN 在处理连接表继承结构时很常见；每当使用 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 从某个父类连接到一个连接表子类，或者类似地使用 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，SQLAlchemy 的 ORM 总是确保不会渲染嵌套的 JOIN，以免查询无法在 SQLite
    上运行。尽管 Core 一直支持更紧凑形式的 JOIN，ORM 必须避免使用它。
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 ON 子句中存在特殊条件时，通过多对多关系生成连接时会出现另一个问题。考虑以下急加载连接：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设从 `Order` 到 `Item` 的多对多实际上指的是一个子类，如 `Subitem`，上述情况的 SQL 如下所示：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询有什么问题？基本上，它将加载许多 `order` / `order_item` 行，其中 `item.type == 'subitem'` 的条件不成立。
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 0.9 开始，采取了一种全新的方法。ORM 不再担心将 JOIN 嵌套在封闭 JOIN 的右侧，现在它会尽可能地渲染这些 JOIN，同时仍然返回正确的结果。当
    SQL 语句被传递进行编译时，**方言编译器**会根据目标后端进行 **重写 JOIN**，如果该后端已知不支持右嵌套 JOIN（目前只有 SQLite -
    如果其他后端有此问题，请告诉我们！）。
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常规的 `query(Parent).join(Subclass)` 现在通常会产生一个更简单的表达式：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 `query(Parent).options(joinedload(Parent.subclasses))` 的连接急加载将对各个表进行别名处理，而不是包装在
    `ANON_1` 中：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多连接和急加载将右嵌套“secondary”和“right”表：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些连接，当使用[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句渲染时，该语句明确指定`use_labels=True`，这对ORM发出的所有查询都是真实的，都是“连接重写”的候选对象，这是将所有这些右嵌套连接重写为嵌套的SELECT语句的过程，同时保持[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")使用的相同标签。因此，SQLite，即使在2013年，也不支持这种非常常见的SQL语法，也要自己承担额外的复杂性，以上查询被重写为：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLAlchemy 1.1开始，此功能中存在的SQLite的解决方法将在检测到SQLite版本**3.7.16**或更高版本时自动禁用自身，因为SQLite已修复了对右嵌套连接的支持。
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join.alias()`，[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")和[`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数现在支持一个新参数`flat=True`，用于构建别名的连接表实体，而不嵌入到SELECT中。默认情况下，此标志未启用，以帮助向后兼容性
    - 但现在可以将“多态”可选择地作为目标连接，而不生成任何子查询：'
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Generates (everywhere except SQLite):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 生成（除了SQLite）：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    Right-nested inner joins available in joined eager loads'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    可在连接的急切加载中使用右嵌套内连接'
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本0.9.4开始，在连接的急切加载情况下，可以启用上述提到的右嵌套连接，其中“外部”连接与右侧的“内部”连接相关联。
- en: 'Normally, a joined eager load chain like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像下面这样的连接急切加载链：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不会产生内连接；由于从user->order的LEFT OUTER JOIN，连接的急切加载无法使用从order->items到INNER join，而不更改返回的用户行，并且会忽略“链接”`innerjoin=True`指令。0.9.0应该交付的是，而不是：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“右嵌套连接是可以的”逻辑将启动，我们将得到：
- en: '[PRE72]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们错过了这一点，为了避免进一步的退化，我们通过向[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")指定字符串`"nested"`来添加上述功能：
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This feature is new in 0.9.4.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能是0.9.4中的新功能。
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM可以使用RETURNING高效地获取刚生成的INSERT/UPDATE默认值
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    长期以来一直支持一个名为 `eager_defaults=True` 的未记录的标志。此标志的作用是，当进行 INSERT 或 UPDATE 操作时，如果知道行具有由服务器生成的默认值，则会立即跟随一个
    SELECT 来“急切地”加载这些新值。通常，服务器生成的列会在对象上标记为“过期”，因此除非应用程序在刷新后立即访问这些列，否则不会产生任何开销。因此，`eager_defaults`
    标志并不是很有用，因为它只会降低性能，并且只存在于支持需要默认值在刷新过程中立即可用的奇特事件方案的情况下。'
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 版本中，由于版本 ID 的增强，`eager_defaults` 现在可以为这些值发出 RETURNING 子句，因此在具有强大 RETURNING
    支持的后端，特别是 PostgreSQL 上，ORM 可以在 INSERT 或 UPDATE 中内联获取新生成的默认和 SQL 表达式值。当启用 `eager_defaults`
    时，将自动使用 RETURNING，当目标后端和 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 支持“隐式返回”时。
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对于某些查询，子查询预加载将在最内层的 SELECT 上应用 DISTINCT'
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及到一对多关系时，子查询预加载可能会生成重复行的数量，因此当连接目标列不包含主键时，会对最内层的 SELECT 应用 DISTINCT 关键字，例如在沿着一对多加载时。
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在从 A->B 的一对多子查询加载时：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `a.b_id` 是一个非唯一的外键，所以会应用 DISTINCT，以消除冗余的 `a.b_id`。此行为可以通过为特定的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 设置标志 `distinct_target_key` 来无条件地打开或关闭，将值设置为 `True`
    表示无条件打开，`False` 表示无条件关闭，`None` 表示当目标 SELECT 针对不包含完整主键的列时生效。在 0.9 版本中，`None` 是默认值。
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项也被回溯到了 0.8 版本，其中 `distinct_target_key` 选项的默认值为 `False`。
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此处的功能旨在通过消除重复行来帮助性能，但 SQL 中的 DISTINCT 关键字本身可能会对性能产生负面影响。如果 SELECT 中的列没有索引，则
    DISTINCT 可能会对行集执行 ORDER BY，这可能会很昂贵。通过将此功能限制在外键上，希望外键无论如何都已被索引，可以预期新的默认值是合理的。
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能也不能消除每种可能的重复行情况；如果在连接链中的其他地方存在多对一关系，重复行可能仍然存在。
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### Backref handlers
    can now propagate more than one level deep'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### 反向引用处理程序现在可以传播多于一级的深度'
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件传递其“发起者”的机制已经发生了变化；不再传递`AttributeImpl`，而是传递一个新的对象`Event`；该对象引用`AttributeImpl`以及一个“操作令牌”，表示操作是追加、移除还是替换操作。
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件系统不再查看这个“发起者”对象以阻止递归系列的属性事件。相反，防止由于相互依赖的反向引用处理程序而导致无限递归的系统已经移动到了ORM反向引用事件处理程序中，这些处理程序现在负责确保相互依赖事件链（例如向集合A.bs追加，响应中设置多对一属性B.a）不会进入无限递归流。这里的理念是，反向引用系统，通过更详细和控制事件传播，最终可以允许超过一级深度的操作发生；典型情况是集合追加导致多对一替换操作，进而应导致项目从先前的集合中移除的情况：
- en: '[PRE75]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之前，`c1`对象仍然会存在于`p1.children`中，即使它同时也存在于`p2.children`中；反向引用处理程序会停止在用`p2`替换`c1.parent`而不是`p1`的操作上。在0.9版本中，使用更详细的`Event`对象以及让反向引用处理程序对这些对象做出更详细的决策，传播可以继续进行，从而将`c1`从`p1.children`中移除，同时保持检查以防止传播进入无限递归循环。
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set")、[`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") 或 [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") 事件的终端用户代码可能需要修改，以防止递归循环，因为在缺少反向引用事件处理程序的情况下，属性系统不再阻止事件链无限传播。此外，依赖于
    `initiator` 值的代码将需要调整到新的 API，并且还必须准备好 `initiator` 值在一系列反向引用引发的事件中从其原始值更改，因为现在反向引用处理程序可能会为某些操作交换一个新的
    `initiator` 值。
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### The typing system
    now handles the task of rendering “literal bind” values'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### 类型系统现在处理呈现“字面绑定”值的任务'
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    和 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    分别添加了新的方法 [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") 和 [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")，它们负责呈现所谓的“内联字面参数” - 由于编译器配置的原因，这些参数通常呈现为“绑定”值，但实际上是被内联呈现到
    SQL 语句中。此功能用于生成诸如 [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") 这样的结构的 DDL，以及当使用诸如 `op.inline_literal()`
    这样的结构时，Alembic 会使用它。以前，一个简单的“isinstance”检查检查了一些基本类型，并且“绑定处理器”被无条件使用，导致字符串过早编码为
    utf-8 的问题。'
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 编写的自定义类型应继续在“内联文字”场景中工作，因为 [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") 默认会回退到 [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")，因为这些方法通常处理的是数据操作，而不是数据如何呈现给数据库。[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") 可以被指定为明确产生一个表示如何将值渲染成内联DDL语句的字符串。
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### Schema identifiers
    now carry along their own quoting information'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### 模式标识符现在携带其自身的引号信息'
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改简化了 Core 对所谓的“引号”标志的使用，比如传递给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 和 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的 `quote` 标志。该标志现在内部化在字符串名称本身中，现在表示为 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 的一个实例，即一个字符串子类。 [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") 现在仅依赖于由 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 对象报告的引号首选项，而不是在大多数情况下检查任何显式的 `quote`
    标志。这里解决的问题包括，各种区分大小写的方法（例如 `Engine.has_table()` 以及方言内部的类似方法）现在能够以显式引号的名称正确地运行，而不需要复杂化或引入与引号标志的细节不兼容的更改到这些API（其中许多是第三方的）
    - 特别是，更广泛范围的标识符现在能够与所谓的“大写”后端（像 Oracle、Firebird 和 DB2 这样的后端）正确地工作，这些后端使用全部大写存储和报告不区分大小写的名称的表和列名。
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 内部根据需要使用 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 对象；但是，如果其他关键字需要固定的引号首选项，则该类是公开可用的。
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### Improved rendering
    of Boolean constants, NULL constants, conjunctions'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### 改进布尔常量、NULL常量、连接词的渲染'
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能已添加到 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    和 [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    常量中，特别是与 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    和 [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    函数以及 WHERE/HAVING 子句与这些类型、整体布尔类型和 [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") 常量的行为结合使用时。
- en: 'Starting with a table such as this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从这样的表开始：
- en: '[PRE76]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在不具有 `true`/`false` 常量行为的后端上，选择构造现在将布尔列渲染为二进制表达式：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    和 [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    构造现在将表现出准“短路”行为，即在存在 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") 或 [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") 常量时截断渲染表达式：'
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    可以用作构建表达式的基础：'
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    和 [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    本身渲染为 `0 = 1` 和 `1 = 1`，对于没有布尔常量的后端：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 的解释，虽然不是特别有效的 SQL，但至少现在是一致的：'
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### Label constructs
    can now render as their name alone in an ORDER BY'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### 标签构造现在可以��� ORDER
    BY 中仅呈现为其名称'
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELECT 的列子句和 ORDER BY 子句中都使用 [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") 的情况下，标签将仅在 ORDER BY 子句中呈现为其名称，假设底层方言报告支持此功能。
- en: 'E.g. an example like:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像这样的示例：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Prior to 0.9 would render as:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 之前将渲染为：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And now renders as:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将渲染为：
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ORDER BY 仅在标签未在 ORDER BY 中进一步嵌入到表达式中时呈现标签，除了简单的 `ASC` 或 `DESC`。
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在所有经过测试的数据库上都有效，但可能与旧数据库版本（MySQL 4？Oracle 8？等）存在兼容性问题。根据用户报告，我们可以添加规则，根据数据库版本检测禁用该功能。
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy` now has
    tuple-sorting behavior'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy`现在具有元组排序行为'
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`对象的行为很像一个元组，但直到现在，如果使用`sorted()`对它们的列表进行排序，它们不会像元组一样排序。现在，`__eq__()`方法将两侧都作为元组进行比较，并且还添加了一个`__lt__()`方法：'
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### A bindparam() construct
    with no type gets upgraded via copy when a type is available'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### 当`bindparam()`构造没有类型时，通过复制进行升级，当有类型可用时'
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: “升级”[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造以采用封闭表达式类型的逻辑已经通过两种方式得到改进。首先，在分配新类型之前，[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")对象会被**复制**，以便给定的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")不会就地突变。其次，在编译[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造时，通过[`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values")方法设置的“values”在语句中也会发生相同的操作。
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '如果给定一个无类型的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If we use this parameter as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像下面这样使用这个参数：
- en: '[PRE87]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`bp`的类型仍然是`NullType`，但是如果`mytable.c.col`的类型是`String`，那么二元表达式的右侧`expr.right`将采用`String`类型。以前，`bp`本身会被就地更改为具有`String`类型。'
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个操作也会在[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")中发生：
- en: '[PRE88]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`bp`保持不变，但在执行语句时将使用`String`类型，我们可以通过检查`binds`字典来看到这一点：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能允许自定义类型在INSERT/UPDATE语句中产生预期效果，而无需在每个[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")表达式中显式指定这些类型。
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可能向后兼容的更改涉及两种不太可能的情况。由于绑定参数是**克隆**的，用户不应该依赖于对一旦创建的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造进行就地更改。此外，使用[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")在依赖于[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")未根据分配给的列进行类型化的事实的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")语句的代码将不再以这种方式运行。
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### Columns can reliably
    get their type from a column referred to via ForeignKey'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### 列可以可靠地从通过外键引用的列中获取其类型'
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个长期存在的行为，即可以声明没有类型的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，只要该[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")被[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")引用，并且引用列的类型将被复制到此列中。问题在于这个功能从来没有很好地工作过，也没有得到维护。核心问题是[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象不知道它引用的目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")是什么，直到被询问，通常是第一次使用外键来构造[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")时。因此，在那个时候，父[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")将没有类型，或更具体地说，它将具有默认类型[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")。
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管花费了很长时间，重新组织[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象初始化的工作已经完成，使得这个功能最终可以正常工作。这个改变的核心是[`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column")属性不再延迟初始化目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的位置；这个系统的问题在于拥有的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")会一直被固定为[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")类型，直到[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")被使用。
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本中，[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")通过内部附加事件与最终引用的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")协调，因此一旦引用的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联，所有引用它的[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象都会收到一条消息，告诉它们需要初始化其父列。这个系统更加复杂，但更加稳固；作为奖励，现在已经为各种[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")配置场景设置了测试，并且错误消息已经改进，对不少于七种不同的错误条件进行了非常具体的描述。
- en: 'Scenarios which now work correctly include:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正确工作的场景包括：
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")与相同的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联时，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")上的类型会立即出现；无论哪一边先配置都可以：
- en: '[PRE90]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统现在也可以使用[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")：
- en: '[PRE91]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它甚至适用于“多跳” - 即，一个指向另一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"):'
- en: '[PRE92]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
- en: Dialect Changes
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言更改
- en: Firebird `fdb` is now the default Firebird dialect.
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 现在是默认的 Firebird 方言。
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建引擎时没有指定方言，则现在使用 `fdb` 方言，即 `firebird://`。`fdb` 是一个与 `kinterbasdb` 兼容的 DBAPI，根据
    Firebird 项目的说法，现在是他们官方的 Python 驱动程序。
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 和 `kinterbasdb` 默认设置 `retaining=False`
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdb` 和 `kinterbasdb` DBAPI 都支持一个标志 `retaining=True`，可以传递给其连接的 `commit()` 和
    `rollback()` 方法。文档中对这个标志的理由是，DBAPI 可以重用内部事务状态进行后续事务，以提高性能。然而，更新的文档提到了 Firebird
    的“垃圾回收”分析，表明这个标志可能对数据库处理清理任务的能力产生负面影响，并因此被报告为*降低*性能。'
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些信息，目前不清楚这个标志实际上如何可用，而且由于它似乎只是一个性能增强功能，现在默认值为 `False`。可以通过向 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 调用传递标志 `retaining=True` 来控制该值。这是一个新标志，从 0.8.2 版本开始添加，因此在
    0.8.2 版本的应用程序可以根据需要将其设置为 `True` 或 `False`。
- en: See also
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`sqlalchemy.dialects.firebird.fdb`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.fdb`'
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.kinterbasdb`'
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - 有关“保留”标志的信息。'
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
- en: Introduction
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.9, and also documents
    changes which affect users migrating their applications from the 0.8 series of
    SQLAlchemy to 0.9.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 0.9 中的新功能，并记录了影响用户将其应用程序从 SQLAlchemy 0.8 系列迁移到 0.9 的变化。
- en: Please carefully review [Behavioral Changes - ORM](#behavioral-changes-orm-09)
    and [Behavioral Changes - Core](#behavioral-changes-core-09) for potentially backwards-incompatible
    changes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看[行为变化 - ORM](#behavioral-changes-orm-09)和[行为变化 - Core](#behavioral-changes-core-09)，可能存在不兼容的变化。
- en: Platform Support
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在针对 Python 2.6 及更高版本，Python 3 不再需要 2to3
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 0.9 版本的成就是移除了对 Python 3 兼容性的 2to3 工具的依赖。为了使这更加直观，现在目标最低的 Python 发布版本是 2.6，它具有与
    Python 3 广泛的交叉兼容性。所有 SQLAlchemy 模块和单元测试现在都能在任何从 2.6 开始的 Python 解释器上同样良好地解释，包括
    3.1 和 3.2 解释器。
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
- en: C Extensions Supported on Python 3
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C 扩展在 Python 3 上受支持
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: C 扩展已被移植以支持 Python 3，并且现在在 Python 2 和 Python 3 环境中都构建。
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在目标是 Python 2.6 及更高版本，Python 3 不再需要 2to3
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 0.9 版本的成就是移除了对 Python 3 兼容性的 2to3 工具的依赖。为了使这更加直观，现在目标最低的 Python 发布版本是 2.6，它具有与
    Python 3 广泛的交叉兼容性。所有 SQLAlchemy 模块和单元测试现在都能在任何从 2.6 开始的 Python 解释器上同样良好地解释，包括
    3.1 和 3.2 解释器。
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
- en: C Extensions Supported on Python 3
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C 扩展在 Python 3 上受支持
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: C 扩展已被移植以支持 Python 3，并且现在在 Python 2 和 Python 3 环境中都构建。
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
- en: '## Behavioral Changes - ORM'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '## 行为变更 - ORM'
- en: '### Composite attributes are now returned as their object form when queried
    on a per-attribute basis'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当按属性查询时，现在会以它们的对象形式返回复合属性'
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    与复合属性一起，会返回该复合属性维护的对象类型，而不是拆分为各个列。使用在 [复合列类型](../orm/composites.html#mapper-composite)
    中设置的映射：
- en: '[PRE93]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改与期望将各个属性扩展为各个列的代码不兼容。要获得该行为，请使用 `.clauses` 访问器：
- en: '[PRE94]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: See also
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column Bundles for ORM queries](#change-2824)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询的列捆绑](#change-2824)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 不再将该子句应用于对应的实体'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 近期版本中，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 方法已被广泛使用，作为控制 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象“选择的第一件事”的手段，通常是为了控制 JOIN 如何渲染。
- en: 'Consider the following example against the usual `User` mapping:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常的 `User` 映射相比，请考虑以下示例：
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The above statement predictably renders SQL like the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明可预期地渲染为以下 SQL：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要颠倒 JOIN 的左右元素的顺序，文档会让我们相信可以使用[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")来实现：
- en: '[PRE97]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 0.8 版本及更早版本中，上述对[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")的使用会将`select_stmt`应用于**替换**`User`实体，因为它选择了与`User`兼容的`user`表：
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句很混乱，ON 子句引用了`anon_1.id = anon_1.id`，我们的 WHERE 子句也被`anon_1`替换了。
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是完全有意的，但与已经流行的[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")的用例不同。上述行为现在可以通过一个名为`Query.select_entity_from()`的新方法实现。这是一个较少使用的行为，在现代的
    SQLAlchemy 中大致相当于从自定义[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造中选择：
- en: '[PRE99]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 SQLAlchemy 0.9 中，我们从`select_stmt`选择的查询产生了我们期望的 SQL：
- en: '[PRE100]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.select_entity_from()` 方法将在 SQLAlchemy **0.8.2** 中可用，因此依赖旧行为的应用程序可以首先过渡到该方法，确保所有测试继续正常运行，然后无问题地升级到
    0.9。'
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` on
    `relationship()` prevents history from taking effect'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` 在
    `relationship()` 上阻止历史记录生效'
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上的`viewonly`标志被应用于防止对目标属性的更改在刷新过程中产生任何影响。这是通过在刷新过程中排除属性来实现的。然而，直到现在，对属性的更改仍然会将父对象标记为“脏”，并触发潜在的刷新。更改是`viewonly`标志现在还阻止为目标属性设置历史记录。像反向引用和用户定义事件之类的属性事件仍然正常运行。
- en: 'The change is illustrated as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如下所示：
- en: '[PRE101]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### Association Proxy
    SQL Expression Improvements and Fixes'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### 关联代理 SQL 表达式改进和修复'
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过关联代理实现的`==`和`!=`运算符，引用标量关系上的标量值，现在产生更完整的 SQL 表达式，旨在考虑“关联”行是否存在，当比较为`None`时。
- en: 'Consider this mapping:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个映射：
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Up through 0.8, a query like the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 0.8 版本，像下面这样的查询：
- en: '[PRE103]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'would produce:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE104]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In 0.9, it now produces:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 中，现在产生：
- en: '[PRE105]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，它不仅检查`b.value`，还检查`a`是否根本没有引用任何`b`行。对于使用这种类型比较的系统，一些父行没有关联行，这将与先前版本产生不同的结果。
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 更为关键的是，对于`A.b_value != None`，会发出正确的表达式。在0.8版本中，对于没有`b`的`A`行，这将返回`True`：
- en: '[PRE106]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在0.9版本中，检查已经重新设计，以确保A.b_id行存在，另外`B.value`不为NULL：
- en: '[PRE107]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`has()`操作符得到增强，使您可以只针对标量列值调用它，而不需要任何条件，它将生成检查关联行是否存在的条件：
- en: '[PRE108]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE109]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于`A.b.has()`，但允许直接针对`b_value`进行查询。
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### Association Proxy
    Missing Scalar returns None'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### 关联代理缺失标量返回None'
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 从标量属性到标量的关联代理现在如果被代理的对象不存在将返回`None`。这与SQLAlchemy中缺失的一对多关联返回None的事实一致，因此代理值也应该如此。例如：
- en: '[PRE110]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()
    will query from the DB by default if value not present'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()如果值不存在，默认情况下将从数据库查询'
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history")的修复bug允许基于列的属性查询到数据库中未加载的值，假设`passive`标志保持默认的`PASSIVE_OFF`。以前，此标志将不被尊重。此外，添加了一个新方法[`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history")来补充[`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")属性，它将为未加载的属性发出加载器可调用。
- en: 'This is a small change demonstrated as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小改变的演示如下：
- en: '[PRE111]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ### Composite attributes
    are now returned as their object form when queried on a per-attribute basis'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ### 当按属性基础查询时，复合属性现在以其对象形式返回'
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与复合属性一起使用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")现在返回由该复合属性维护的对象类型，而不是分解为单独列。使用在[复合列类型](../orm/composites.html#mapper-composite)设置的映射：
- en: '[PRE112]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变与期望将单个属性扩展为单独列的代码不兼容。要获得该行为，请使用`.clauses`访问器：
- en: '[PRE113]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See also
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column Bundles for ORM queries](#change-2824)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM查询的列捆绑](#change-2824)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
- en: '### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")不再将子句应用于相应的实体'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 近期版本中，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")方法已经变得流行，作为控制[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象“选择自”的一种方式，通常用于控制JOIN的渲染方式。
- en: 'Consider the following example against the usual `User` mapping:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例与通常的`User`映射相对比：
- en: '[PRE114]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The above statement predictably renders SQL like the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句可预见地生成类似以下的SQL：
- en: '[PRE115]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要颠倒JOIN的左右元素的顺序，文档会让我们相信可以使用[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")来实现：
- en: '[PRE116]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在0.8版本及之前，上述对[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")的使用会将`select_stmt`应用于**替换**`User`实体，因为它选择自与`User`兼容的`user`表：
- en: '[PRE117]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句是一团糟，ON子句引用了`anon_1.id = anon_1.id`，我们的WHERE子句也被替换为`anon_1`。
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是完全有意的，但与[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")变得流行的用例不同。上述行为现在可以通过一个名为`Query.select_entity_from()`的新方法来实现。这是一个较少使用的行为，在现代的SQLAlchemy中大致相当于从自定义的[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造中选择：
- en: '[PRE118]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在SQLAlchemy 0.9中，我们的从`select_stmt`选择的查询会产生我们期望的SQL：
- en: '[PRE119]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.select_entity_from()`方法将在SQLAlchemy **0.8.2**中可用，因此依赖旧行为的应用程序可以首先过渡到这种方法，确保所有测试继续正常运行，然后无问题地升级到0.9。'
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)'
- en: '### `viewonly=True` on `relationship()` prevents history from taking effect'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在`relationship()`上使用`viewonly=True`会阻止历史记录生效'
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上的`viewonly`标志被应用以防止对目标属性的更改在刷新过程中产生任何影响。这是通过在刷新过程中不考虑该属性来实现的。然而，直到现在，对属性的更改仍会将父对象注册为“脏”，并触发潜在的刷新。改变是，`viewonly`标志现在也阻止为目标属性设置历史记录。像反向引用和用户定义事件这样的属性事件仍然正常运行。
- en: 'The change is illustrated as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 改变如下所示：
- en: '[PRE120]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)'
- en: '### Association Proxy SQL Expression Improvements and Fixes'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关联代理SQL表达式改进和修复'
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个关联代理实现的`==`和`!=`运算符，它引用标量关系上的标量值，现在会产生一个更完整的SQL表达式，旨在考虑“关联”行在与`None`比较时是否存在。
- en: 'Consider this mapping:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下映射：
- en: '[PRE121]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Up through 0.8, a query like the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 直到0.8版本，像下面这样的查询：
- en: '[PRE122]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'would produce:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE123]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In 0.9, it now produces:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9中，现在产生：
- en: '[PRE124]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，它不仅检查`b.value`，还检查`a`是否根本没有指向任何`b`行。这将与先前版本产生不同的结果，对于使用这种类型比较的系统，其中一些父行没有关联行。
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 更为关键的是，对于`A.b_value != None`，现在会生成正确的表达式。在0.8中，对于没有`b`的`A`行，这将返回`True`：
- en: '[PRE125]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在0.9版本中，检查已经重新设计，以确保`A.b_id`行存在，另外`B.value`不为NULL：
- en: '[PRE126]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`has()`运算符得到增强，使您可以只针对标量列值调用它，而不需要任何条件，它将生成检查关联行是否存在的条件：
- en: '[PRE127]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'output:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE128]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于`A.b.has()`，但允许直接针对`b_value`进行查询。
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)'
- en: '### Association Proxy Missing Scalar returns None'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关联代理缺失标量返回None'
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 从标量属性到标量的关联代理现在如果代理对象不存在将返回`None`。这与SQLAlchemy中缺少多对一关系返回None的事实一致，所以代理值也应该如此。例如：
- en: '[PRE129]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)'
- en: '### attributes.get_history() will query from the DB by default if value not
    present'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '### attributes.get_history()如果值不存在将默认从数据库查询'
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history")的修复允许基于列的属性查询数据库中未加载的值，假设`passive`标志保持默认值`PASSIVE_OFF`。以前，这个标志不会被遵守。此外，新增了一个新方法[`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history")来补充[`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")属性，该属性将为未加载的属性发出加载器可调用。
- en: 'This is a small change demonstrated as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小改变的示例：
- en: '[PRE130]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)'
- en: '## Behavioral Changes - Core'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '## 行为变化 - 核心'
- en: Type objects no longer accept ignored keyword arguments
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型对象不再接受被忽略的关键字参数
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8系列之前，大多数类型对象接受任意关键字参数，这些参数会被静默忽略：
- en: '[PRE131]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常古老的bug，为此在0.8系列中添加了一个弃用警告，但因为没有人会使用“-W”标志来运行Python，所以几乎从未被看到：
- en: '[PRE132]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从0.9系列开始，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")中的“catch
    all”构造函数被移除，这些无意义的参数不再被接受。
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 利用方言特定参数如`storage_format`和`display_width`的正确方式是使用适当的方言特定类型：
- en: '[PRE133]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们也想要方言无关的类型时怎么办？我们使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")方法：
- en: '[PRE134]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")并不是新功能，它是在SQLAlchemy 0.7.2中添加的。因此，在0.8系列上运行的代码可以校正为使用这种方法，并在升级到0.9之前进行测试。'
- en: '`None` can no longer be used as a “partial AND” constructor'
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`None`不再能被用作“部分AND”构造函数'
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`不再能被用作“后备”来逐步形成AND条件。即使一些SQLAlchemy内部使用了这种模式，这种模式也没有被记录在案：'
- en: '[PRE135]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当`conditions`不为空时，上述序列在0.9上会产生`SELECT .. WHERE <condition> AND NULL`。`None`不再被隐式忽略，而是与在其他上下文中解释`None`时保持一致。
- en: 'The correct code for both 0.8 and 0.9 should read:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8和0.9的正确代码应该是：
- en: '[PRE136]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在0.9上适用于所有后端的变体，在0.8上只适用于支持布尔常量的后端：
- en: '[PRE137]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 版本中，这将生成一个 SELECT 语句，其 WHERE 子句中始终包含`AND true`，这不被不支持布尔常量的后端所接受（MySQL、MSSQL）。在
    0.9 版本中，`true`常量将在`and_()`连接中被删除。
- en: See also
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[改进的布尔常量、NULL常量、连接词的呈现方式](#migration-2804)'
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '### `create_engine()` 的“password”部分不再将`+`号视为编码空格。'
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，Python 函数`unquote_plus()`被应用于 URL 的“password”字段，这是对[RFC 1738](https://www.ietf.org/rfc/rfc1738.txt)中描述的编码规则的错误应用，因为它将空格转义为加号。现在
    URL 的字符串化仅编码“:”、“@”或“/”，不再应用于`username`和`password`字段（以前仅应用于密码）。在解析时，编码字符被转换，但加号和空格保持不变：
- en: '[PRE138]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### The precedence rules
    for COLLATE have been changed'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### COLLATE 的优先规则已更改'
- en: 'Previously, an expression like the following:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，类似以下的表达式：
- en: '[PRE139]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'would produce an expression like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 将会产生如下表达式：
- en: '[PRE140]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容被 MSSQL 误解，通常不是任何数据库建议的语法。该表达式现在将产生大多数数据库文档所示的语法：
- en: '[PRE141]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 操作符被应用于右侧列，则可能会出现潜在的不兼容更改：
- en: '[PRE142]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In 0.8, this produces:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 版本中，会产生：
- en: '[PRE143]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 然而在 0.9 版本中，将会产生更准确的，但可能不是您想要的形式：
- en: '[PRE144]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 操作符现在在`ORDER BY`表达式中更为适当地工作，因为`ASC`和`DESC`操作符已被赋予特定的优先级，这将再次确保不会生成括号：'
- en: '[PRE145]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM now applies quoting to values'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM 现在对值应用引号'
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    类型现在将对枚举值中的单引号符号进行转义：'
- en: '[PRE146]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 已经转义单引号符号的现有解决方法需要进行修改，否则它们现在将会双重转义。
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
- en: Type objects no longer accept ignored keyword arguments
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型对象不再接受被忽略的关键字参数
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 0.8 系列，大多数类型对象接受任意关键字参数，这些参数被静默忽略：
- en: '[PRE147]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常古老的 bug，已经在 0.8 系列中添加了弃用警告，但因为几乎没有人使用“-W”标志来运行 Python，所以几乎从未被看到：
- en: '[PRE148]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 从0.9系列开始，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")中的“catch
    all”构造函数已被移除，这些无意义的参数不再被接受。
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方言特定参数（如`storage_format`和`display_width`）的正确方法是使用适当的方言特定类型：
- en: '[PRE149]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想要方言不可知的类型怎么办？我们使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")方法：
- en: '[PRE150]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")并不是新功能，它是在SQLAlchemy 0.7.2中添加的。因此，在0.8系列上运行的代码可以根据需要使用这种方法进行更正并在升级到0.9之前进行测试。'
- en: '`None` can no longer be used as a “partial AND” constructor'
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`None`不再能够被用作“部分AND”构造函数'
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`不再能够被用作逐步形成AND条件的“后备”。尽管一些SQLAlchemy内部使用了这种模式，但这种模式并未被记录：'
- en: '[PRE151]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 上述序列在`conditions`非空时，将在0.9上产生`SELECT .. WHERE <condition> AND NULL`。`None`不再被隐式忽略，而是与在其他上下文中解释`None`时保持一致。
- en: 'The correct code for both 0.8 and 0.9 should read:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 对于0.8和0.9的正确代码应该是：
- en: '[PRE152]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变体在0.9上适用于所有后端，但在0.8上仅适用于支持布尔常量的后端：
- en: '[PRE153]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8上，这将产生一个SELECT语句，在WHERE子句中始终有`AND true`，这不被不支持布尔常量的后端（MySQL、MSSQL）接受。在0.9上，`true`常量将在`and_()`连接中被删除。
- en: See also
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[布尔常量、NULL常量、连接的改进渲染](#migration-2804)'
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '### `create_engine()`的“password”部分不再将`+`号视为编码空格'
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，Python函数`unquote_plus()`被应用于URL的“password”字段，这是对[RFC 1738](https://www.ietf.org/rfc/rfc1738.txt)中描述的编码规则的错误应用，因为它将空格转义为加号。现在，URL的字符串化仅编码“:”、“@”或“/”，而不再应用于`username`和`password`字段（以前仅应用于密码）。在解析时，编码字符被转换，但加号和空格保持不变：
- en: '[PRE154]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)'
- en: '### The precedence rules for COLLATE have been changed'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '### COLLATE的优先规则已更改'
- en: 'Previously, an expression like the following:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，类似以下的表达式：
- en: '[PRE155]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'would produce an expression like this:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生如下表达式：
- en: '[PRE156]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法被MSSQL误解，通常不是任何数据库建议的语法。现在该表达式将产生大多数数据库文档所示的语法：
- en: '[PRE157]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 操作符应用于右列，则可能会出现潜在的不兼容变化，如下所示：
- en: '[PRE158]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In 0.8, this produces:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.8 中，这将产生：
- en: '[PRE159]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 0.9 中，现在将产生更准确的，但可能不是您想要的形式：
- en: '[PRE160]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 操作符现在在 `ORDER BY` 表达式中更合适地工作，因为给了
    `ASC` 和 `DESC` 操作符一个特定的优先级，这将再次确保不生成括号：'
- en: '[PRE161]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)'
- en: '### PostgreSQL CREATE TYPE <x> AS ENUM now applies quoting to values'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL CREATE TYPE <x> AS ENUM 现在对值应用引用'
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    类型现在将在枚举值中应用转义到单引号符：'
- en: '[PRE162]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 已经转义单引号的现有解决方法将需要修改，否则它们将会双重转义。
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
- en: New Features
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: '### Event Removal API'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '### 事件移除 API'
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")
    或 [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for "sqlalchemy.event.listens_for")
    建立的事件现在可以使用新的 [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    函数进行移除。传递给 [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    的 `target`、`identifier` 和 `fn` 参数需要与用于监听的参数完全匹配，事件将从所有已建立的位置移除：
- en: '[PRE163]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，设置了 `propagate=True` 标志。这意味着 `my_before_insert()` 被建立为 `MyClass` 及其所有子类的监听器。系统跟踪了
    `my_before_insert()` 监听器函数作为此调用的结果放置的所有位置，并作为调用 [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") 的结果将其移除。
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 移除系统使用注册表将传递给 [`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")
    的参数与事件监听器的集合相关联，这些事件监听器在许多情况下是原始用户提供的函数的包装版本。该注册表大量使用弱引用，以允许所有包含的内容（例如监听器目标）在超出范围时被垃圾回收。
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### New Query Options
    API; `load_only()` option'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### 新查询选项 API；`load_only()`
    选项'
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项系统，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")、[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")等，都建立在一个名为[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")的新系统之上。[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")提供了一种“方法链式”（又名[生成式](../glossary.html#term-generative)）的加载器选项方法，因此，不再需要使用点号或多个属性名称将长路径连接在一起，而是为每个路径明确指定加载器样式。
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新方法稍微更冗长，但更容易理解，因为对哪些路径应用了哪些选项没有歧义；它简化了选项的方法签名，并为基于列的选项提供了更大的灵活性。旧系统将继续无限期保持功能，并且所有样式都可以混合使用。
- en: '**Old Way**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多元素路径中的每个链接上设置某种加载样式，必须使用`_all()`选项：
- en: '[PRE164]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '**New Way**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载器选项是可链接的，因此相同的`joinedload(x)`方法等同地应用于每个链接，无需在[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和`joinedload_all()`之间保持清晰：
- en: '[PRE165]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '**Old Way**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于子类的路径上设置一个选项需要将路径中的所有链接拼写为类绑定属性，因为[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法需要被调用：
- en: '[PRE166]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '**New Way**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 只有那些实际需要[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")的路径中的元素需要被设置为类绑定属性，之后可以恢复基于字符串的名称：
- en: '[PRE167]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '**Old Way**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在长路径中的最后一个链接上设置加载器选项使用的语法看起来很像应该为路径中的所有链接设置选项，导致混淆：
- en: '[PRE168]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '**New Way**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用[`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")为路径中的条目拼写出路径，其中现有的加载器样式不应更改。更冗长但意图更清晰：
- en: '[PRE169]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以利用点号样式，特别是在跳过几个路径元素的情况下：
- en: '[PRE170]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '**Old Way**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径上使用[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")选项需要为每个列明确指定完整路径：
- en: '[PRE171]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '**New Way**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方式**'
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 到达目标路径的单个[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象可以反复调用[`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer")：
- en: '[PRE172]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The Load Class
  id: totrans-600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Load类
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")类可以直接用于提供“绑定”目标，特别是当存在多个父实体时：'
- en: '[PRE173]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Load Only
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅加载
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新选项[`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")实现了“除了延迟加载一切之外”的加载方式，仅加载给定的列，并延迟其余部分：
- en: '[PRE174]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Class-specific Wildcards
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类特定的通配符
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")，可以使用通配符为给定实体上的所有关系（或者列）设置加载方式，而不影响其他实体：
- en: '[PRE175]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### New `text()` Capabilities'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### 新的`text()`功能'
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")构造获得了新的方法：'
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams")允许灵活设置绑定参数类型和值：'
- en: '[PRE176]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")取代了[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")的`typemap`选项，返回一个新的构造`TextAsFrom`：'
- en: '[PRE177]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### INSERT from SELECT'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### 从SELECT中插入'
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几乎多年的毫无意义的拖延，这个相对较小的语法特性已经被添加，并且也被回溯到0.8.3，所以在技术上在0.9中并不是“新”的。一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造或其他兼容的构造可以传递给新方法[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")，在那里它将被用于渲染一个`INSERT .. SELECT`构造：
- en: '[PRE178]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构足够智能，也可以适应ORM对象，比如类和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象：
- en: '[PRE179]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'rendering:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE180]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### New FOR UPDATE support
    on `select()`, `Query()`'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### `select()`、`Query()`上的新FOR
    UPDATE支持'
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试简化在 Core 和 ORM 中对 `SELECT` 语句中的 `FOR UPDATE` 子句的规范，并支持 PostgreSQL 和 Oracle
    支持的 `FOR UPDATE OF` SQL。
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心[`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")，可以单独指定`FOR SHARE`和`NOWAIT`等选项，而不是链接到任意字符串代码：
- en: '[PRE181]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'On Posgtresql the above statement might render like:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Posgtresql 上，上述语句可能会呈现如下：
- en: '[PRE182]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.  ### Floating Point String-Conversion
    Precision Configurable for Native Floating Point Types'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象获得了类似的方法 [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")，其行为方式相同。该方法取代了现有的 `Query.with_lockmode()`
    方法，该方法使用不同的系统翻译 `FOR UPDATE` 子句。目前，“lockmode”字符串参数仍然被 [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法接受。  ### 本机浮点字符串转换精度可配置的浮点类型'
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 DBAPI 返回要转换为 Python `Decimal()` 的 Python 浮点类型时，SQLAlchemy 所做的转换必然涉及将浮点值转换为字符串的中间步骤。此字符串转换的比例以前是硬编码为
    10，现在可配置。该设置可用于 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 以及 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 类型，以及所有 SQL 和方言特定的后代类型，使用参数 `decimal_return_scale`。如果类型支持
    `.scale` 参数，例如 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    和一些浮点类型如 `DOUBLE`，则如果未另行指定，`.scale` 的值将用作 `.decimal_return_scale` 的默认值。如果 `.scale`
    和 `.decimal_return_scale` 都不存在，则默认值为 10。例如：
- en: '[PRE183]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### Column Bundles for
    ORM queries'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### ORM 查询的列捆绑'
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    允许查询一组列，然后将它们分组为查询返回的元组下的一个名称。[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") 的最初目的是 1\. 允许将“复合”ORM列作为列式结果集中的单个值返回，而不是将它们扩展为单独的列，以及
    2\. 允许在ORM中创建自定义结果集构造，使用临时列和返回类型，而不涉及映射类的更重量级机制。'
- en: See also
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[当按属性基础查询时，复合属性现在以其对象形式返回](#migration-2824)'
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Bundles 分组选定属性](../orm/queryguide/select.html#bundles)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
- en: Server Side Version Counting
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端版本计数
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的版本控制功能（现在也在[配置版本计数器](../orm/versioning.html#mapper-version-counter)中记录）现在可以利用服务器端版本计数方案，例如由触发器或数据库系统列生成的方案，以及版本_id_counter
    函数本身之外的条件编程方案。通过向 `version_id_generator` 参数提供值 `False`，ORM 将使用已设置的版本标识符，或者在发出
    INSERT 或 UPDATE 时同时从每行获取版本标识符。当使用服务器生成的版本标识符时，强烈建议仅在具有强大 RETURNING 支持的后端上使用此功能（PostgreSQL、SQL
    Server；Oracle 也支持 RETURNING，但 cx_oracle 驱动程序仅支持有限），否则额外的 SELECT 语句将增加显著的性能开销。[服务器端版本计数器](../orm/versioning.html#server-side-version-counter)提供的示例说明了如何使用
    PostgreSQL 的 `xmin` 系统列将其与 ORM 的版本控制功能集成。
- en: See also
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '[服务器端版本计数器](../orm/versioning.html#server-side-version-counter)'
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
- en: '### `include_backrefs=False` option for `@validates`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '### `include_backrefs=False` 选项用于 `@validates`'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")
    函数现在接受一个选项 `include_backrefs=True`，这将跳过为从反向引用发起的事件触发验证器的情况：'
- en: '[PRE184]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
- en: PostgreSQL JSON Type
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL JSON 类型
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在具有一个 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 类型，以补充 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 类型。
- en: See also
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
- en: '### Automap Extension'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动映射扩展'
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 新的扩展在**0.9.1**中添加，称为[`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap")。这是一个**实验性**扩展，它扩展了声明式的功能以及[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类的功能。基本上，该扩展提供了一个基类[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")，根据给定的表元数据自动生成映射类和它们之间的关系。
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 正常使用的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")可能是通过反射生成的，但不要求使用反射。最基本的用法说明了[`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap")如何根据反射模式提供映射类，包括关系：
- en: '[PRE185]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")类是一个声明性基类，并支持所有声明性的功能。可以使用“自动映射”功能与现有的明确定义的模式一起使用，仅生成关系和缺失类。命名方案和关系生成例程可以使用可调用函数来插入。
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 期望[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")系统提供了一个快速且现代化的解决方案，解决了非常著名的[SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)也尝试解决的问题，即从现有数据库动态生成快速和简陋的对象模型的问题。通过严格在映射器配置级别解决该问题，并与现有的声明式类技术完全集成，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")旨在为快速自动生成临时映射的问题提供一个良好集成的方法。
- en: See also
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](../orm/extensions/automap.html)  ### Event Removal API'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动映射](../orm/extensions/automap.html)  ### 事件移除 API'
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")或[`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for")建立的事件现在可以使用新的[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")函数进行移除。发送给[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")的`target`、`identifier`和`fn`参数需要与用于监听的参数完全匹配，并且事件将从建立的所有位置中移除：
- en: '[PRE186]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，设置了`propagate=True`标志。这意味着`my_before_insert()`被建立为`MyClass`以及`MyClass`的所有子类的监听器。系统跟踪了`my_before_insert()`监听函数作为此调用的结果放置的所有位置，并在调用[`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove")后将其移除。
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 移除系统使用注册表将传递给[`listen()`](../core/event.html#sqlalchemy.event.listen "sqlalchemy.event.listen")的参数与事件监听器集合关联，这些事件监听器在许多情况下是原始用户提供的函数的包装版本。该注册表大量使用弱引用，以允许所有包含的内容（如监听器目标）在超出范围时被垃圾回收。
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)'
- en: '### New Query Options API; `load_only()` option'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新查询选项 API；`load_only()` 选项'
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项系统，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")、[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")等，都建立在一个名为[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")的新系统之上。[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")提供了一种“方法链式”（又名[生成式](../glossary.html#term-generative)）的加载器选项方法，因此不再需要使用点号或多个属性名称连接长路径，而是为每个路径指定明确的加载器样式。
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法虽然稍微冗长，但更容易理解，因为对应哪些路径应用了哪些选项没有歧义；它简化了选项的方法签名，并为基于列的选项提供了更大的灵活性。旧系统将永远保持功能，并且所有样式都可以混合使用。
- en: '**Old Way**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多元素路径中的每个链接上设置特定的加载样式，必须使用`_all()`选项：
- en: '[PRE187]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '**New Way**'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项现在可以链式调用，因此相同的`joinedload(x)`方法同样适用于每个链接，无需在[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和`joinedload_all()`之间保持清晰：
- en: '[PRE188]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '**Old Way**'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于子类的路径上设置选项需要将路径中的所有链接拼写为类绑定属性，因为需要调用[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法：
- en: '[PRE189]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '**New Way**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 只有实际需要[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")的路径元素需要��置为类绑定属性，之后可以恢复基于字符串的名称：
- en: '[PRE190]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '**Old Way**'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在长路径中设置加载器选项的最后一个链接使用的语法看起来很像应该为路径中的所有链接设置选项，导致混淆：
- en: '[PRE191]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '**New Way**'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用[`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")来拼写路径，其中现有的加载器样式应保持不变。更冗长但意图更清晰：
- en: '[PRE192]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 点线样式仍然可以被充分利用，特别是在跳过多个路径元素的情况下：
- en: '[PRE193]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '**Old Way**'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧方法**'
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 需要为路径上的每个列拼写出完整路径的[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项：
- en: '[PRE194]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '**New Way**'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**新方法**'
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 到达目标路径的单个[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象可以反复调用[`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer")：
- en: '[PRE195]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The Load Class
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载类
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")类可以直接用于提供“绑定”目标，特别是当存在多个父实体时：'
- en: '[PRE196]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Load Only
  id: totrans-696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅加载
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 新选项[`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")实现了“除了加载之外的一切都延迟”的加载方式，仅加载给定列并推迟其余部分：
- en: '[PRE197]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Class-specific Wildcards
  id: totrans-699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类特定通配符
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")，可以使用通配符为给定实体上的所有关系（或可能列）设置加载，而不影响其他实体：
- en: '[PRE198]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
- en: The Load Class
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载类
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")类可以直接用于提供“绑定”目标，特别是当存在多个父实体时：'
- en: '[PRE199]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Load Only
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅加载
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 新选项[`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")实现了“除了加载之外的一切都延迟加载”的加载方式，仅加载给定的列并推迟其余的列：
- en: '[PRE200]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Class-specific Wildcards
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类特定的通配符
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")，可以使用通配符为给定实体上的所有关系（或可能是列）设置加载，而不影响其他实体：
- en: '[PRE201]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
- en: '### New `text()` Capabilities'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的`text()`功能'
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")构造获得了新方法：'
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams")允许灵活设置绑定参数类型和值：'
- en: '[PRE202]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")取代了[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")的`typemap`选项，返回一个新的构造`TextAsFrom`：'
- en: '[PRE203]'
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)'
- en: '### INSERT from SELECT'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从SELECT插入'
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几乎多年的毫无意义的拖延，这个相对较小的语法特性已经被添加，并且也被回溯到了0.8.3版本，所以在技术上在0.9版本中并不是“新”功能。可以将[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造或其他兼容的构造传递给新方法[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")，其中它将被用于渲染`INSERT .. SELECT`构造：
- en: '[PRE204]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 该构造足够智能，也可以适应ORM对象，如类和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象：
- en: '[PRE205]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'rendering:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE206]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[#722](https://www.sqlalchemy.org/trac/ticket/722)'
- en: '### New FOR UPDATE support on `select()`, `Query()`'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '### `select()`，`Query()`上的新的FOR UPDATE支持'
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试简化在Core和ORM中制作`SELECT`语句时`FOR UPDATE`子句的规范，并支持PostgreSQL和Oracle支持的`FOR UPDATE
    OF` SQL。
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心[`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")，可以单独指定选项，如`FOR SHARE`和`NOWAIT`，而不是链接到任意字符串代码：
- en: '[PRE207]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'On Posgtresql the above statement might render like:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在Posgtresql上述语句可能会呈现如下：
- en: '[PRE208]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象获得了一个类似的方法 [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")，其行为方式相同。该方法取代了现有的 `Query.with_lockmode()`
    方法，该方法使用不同的系统翻译 `FOR UPDATE` 子句。目前，“lockmode” 字符串参数仍然被 [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法接受。'
- en: '### Floating Point String-Conversion Precision Configurable for Native Floating
    Point Types'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '### 本机浮点字符串转换精度可配置'
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 每当DBAPI返回一个要转换为Python `Decimal()` 的Python浮点类型时，SQLAlchemy所做的转换必然涉及一个中间步骤，将浮点值转换为字符串。用于此字符串转换的标度以前是硬编码为10，现在是可配置的。该设置在
    [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    以及 [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    类型上都可用，以及所有SQL和特定方言的后代类型，使用参数 `decimal_return_scale`。如果类型支持 `.scale` 参数，如 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 和一些浮点类型如 `DOUBLE`，则如果未另行指定，则 `.scale` 的值将用作 `.decimal_return_scale`
    的默认值。如果 `.scale` 和 `.decimal_return_scale` 都不存在，则默认值为10。例如：
- en: '[PRE209]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)'
- en: '### Column Bundles for ORM queries'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM 查询的列捆绑'
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    允许查询一组列，然后将它们分组为查询返回的元组下的一个名称。[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") 的最初目的是 1\. 允许将“复合”ORM列作为列结果集中的单个值返回，而不是将它们展开为单独的列，以及
    2\. 允许在ORM中创建自定义结果集构造，使用临时列和返回类型，而不涉及映射类的更重量级机制。'
- en: See also
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[当按属性基础查询时，复合属性现在以其对象形式返回](#migration-2824)'
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用捆绑组合选定属性](../orm/queryguide/select.html#bundles)'
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
- en: Server Side Version Counting
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端版本计数
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的版本控制功能（现在还在 [配置版本计数器](../orm/versioning.html#mapper-version-counter) 中有文档记录）现在可以利用服务器端的版本计数方案，例如由触发器或数据库系统列生成的方案，以及版本_id_counter
    函数本身之外的条件编程方案。通过向 `version_id_generator` 参数提供值 `False`，ORM 将使用已设置的版本标识符，或者在发出
    INSERT 或 UPDATE 时同时从每一行获取版本标识符。当使用服务器生成的版本标识符时，强烈建议仅在具有强大 RETURNING 支持的后端上使用此功能（PostgreSQL、SQL
    Server；Oracle 也支持 RETURNING，但 cx_oracle 驱动程序仅具有有限的支持），否则额外的 SELECT 语句将增加显著的性能开销。在
    [服务器端版本计数器](../orm/versioning.html#server-side-version-counter) 提供的示例中说明了使用 PostgreSQL
    `xmin` 系统列将其与 ORM 的版本控制功能集成的用法。
- en: See also
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[服务器端版本计数器](../orm/versioning.html#server-side-version-counter)'
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
- en: '### `include_backrefs=False` option for `@validates`'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '### `include_backrefs=False` 选项用于 `@validates`'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")
    函数现在接受一个选项 `include_backrefs=True`，将为从反向引用发起事件的情况跳过触发器：'
- en: '[PRE210]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
- en: PostgreSQL JSON Type
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL JSON 类型
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在具有 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 类型，以补充 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 类型。
- en: See also
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
- en: '### Automap Extension'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '### Automap 扩展'
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '**0.9.1** 版本新增了一个名为[`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap")的扩展。这是一个**实验性**扩展，它扩展了声明式以及[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类的功能。本质上，该扩展提供了一个基类[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")，根据给定的表元数据自动生成映射类和它们之间的关系。'
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")通常可能是通过反射生成的，但不要求使用反射。最基本的用法说明了[`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap")如何能够根据反射模式提供映射类，包括关系：
- en: '[PRE211]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")类是一个声明基类，并支持声明的所有功能。可以将“自动映射”功能用于现有的、明确声明的模式，以仅生成关系和缺失类。可以使用可调用函数添加命名方案和关系生成例程。
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 希望[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")系统提供了一个快速且现代化的解决方案，解决了非常著名的[SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)也试图解决的问题，即从现有数据库快速生成一个简单的对象模型。通过严格在映射器配置级别解决该问题，并与现有的声明类技术完全集成，[`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase")旨在提供一个完全集成的方法来解决迅速自动生成临时映射的问题。
- en: See also
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](../orm/extensions/automap.html)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动映射](../orm/extensions/automap.html)'
- en: Behavioral Improvements
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为改进
- en: Improvements that should produce no compatibility issues except in exceedingly
    rare and unusual hypothetical cases, but are good to be aware of in case there
    are unexpected issues.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 改进应该不会产生兼容性问题，除非在极为罕见和不寻常的假设情况下，但如果有意外问题，了解这些改进是很好的。
- en: '### Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped in
    (SELECT * FROM ..) AS ANON_1'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '### 许多 JOIN 和 LEFT OUTER JOIN 表达式将不再包含在 (SELECT * FROM ..) AS ANON_1 中'
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，SQLAlchemy ORM 一直无法在现有 JOIN 的右侧嵌套 JOIN（通常是 LEFT OUTER JOIN），因为内部 JOIN 通常可以被展平：
- en: '[PRE212]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 SQLite 直到版本**3.7.16**都无法解析上述格式的语句：
- en: '[PRE213]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 右外连接当然是解决右侧括号化的另一种方法；这将显着复杂化并且视觉上不美观，但幸运的是 SQLite 也不支持 RIGHT OUTER JOIN :)：
- en: '[PRE214]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 早在 2005 年，其他数据库是否有问题尚不清楚，但今天看来，除 SQLite 外的每个测试数据库都支持它（Oracle 8 是一个非常老的数据库，根本不支持
    JOIN 关键字，但 SQLAlchemy 一直为 Oracle 的语法制定了一个简单的重写方案）。更糟糕的是，SQLAlchemy 常规的解决方法在诸如
    PostgreSQL 和 MySQL 等平台上应用 SELECT 通常会降低性能：
- en: '[PRE215]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用联接表继承结构时，像上面的 JOIN 形式是司空见惯的；每当使用[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")从某个父类连接到联接表子类，或者类似地使用[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，SQLAlchemy 的 ORM 总是确保不会渲染嵌套 JOIN，以免查询无法在 SQLite 上运行。即使
    Core 一直支持更紧凑形式的 JOIN，ORM 也必须避免它。
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 当在跨多对多关系上生成连接时，如果 ON 子句中存在特殊条件，将会出现另一个问题。考虑下面这样的 eager load 连接：
- en: '[PRE216]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 假设从`Order`到`Item`的多对多关系实际上指的是一个子类`Subitem`，上述情况的 SQL 如下所示：
- en: '[PRE217]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询有什么问题？基本上，它会加载许多`order` / `order_item`行，其中`item.type == 'subitem'`的条件不成立。
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 0.9 开始，采取了全新的方法。ORM 不再担心将 JOIN 嵌套在连接 JOIN 的右侧，现在会尽可能地渲染这些 JOIN，同时仍然返回正确的结果。当
    SQL 语句被传递进行编译时，**方言编译器**将会**重写 JOIN**以适应目标后端，如果该后端已知不支持右嵌套 JOIN（目前只有 SQLite -
    如果其他后端也有此问题，请告诉我们！）。
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，现在通常会生成一个更简单的表达式： '
- en: '[PRE218]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`query(Parent).options(joinedload(Parent.subclasses))`这样的 eager loads 会给每个表起别名，而不是包装在`ANON_1`中：
- en: '[PRE219]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多连接和 eagerloads 将会将“secondary”和“right”表右嵌套：
- en: '[PRE220]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些连接，当与明确指定`use_labels=True`的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句一起渲染时，这对于 ORM 发出的所有查询都是真实的，都是“连接重写”的候选对象，这是将所有这些右嵌套连接重写为嵌套的
    SELECT 语句的过程，同时保持[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")使用的相同标签。因此，SQLite，即在 2013 年仍不支持这种非常常见的 SQL
    语法的数据库，自身承担了额外的复杂性，上述查询被重写为：
- en: '[PRE221]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Note
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 1.1 开始，此功能中存在的针对 SQLite 的解决方法将在检测到 SQLite 版本**3.7.16**或更高版本时自动禁用，因为
    SQLite 已修复了对右嵌套连接的支持。
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join.alias()`，[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")和[`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数现在支持一个新参数，`flat=True`，用于构建别名的连接表实体而不嵌入到SELECT中。这个标志默认情况下是关闭的，以帮助向后兼容
    - 但现在一个“多态”可选择可以作为目标连接而不生成任何子查询：'
- en: '[PRE222]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Generates (everywhere except SQLite):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 生成（除了SQLite之外的所有地方）：
- en: '[PRE223]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    Right-nested inner joins available in joined eager loads'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    右嵌套内连接在连接的急切加载中可用'
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本0.9.4开始，上述提到的右嵌套连接可以在连接的急切加载中启用，在这种情况下，一个“外部”连接链接到右侧的“内部”连接。
- en: 'Normally, a joined eager load chain like the following:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像下面这样的连接急切加载链：
- en: '[PRE224]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 不会产生内连接；因为从用户->订单的LEFT OUTER JOIN，连接的急切加载不能使用从订单->项目的INNER join，而不更改返回的用户行，并且会忽略“链接”`innerjoin=True`指令。0.9.0应该交付的是，而不是：
- en: '[PRE225]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“右嵌套连接是可以的”逻辑会启动，我们会得到：
- en: '[PRE226]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们错过了这一点，为了避免进一步的退化，我们通过将字符串`"nested"`指定给[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")来添加上述功能：
- en: '[PRE227]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: This feature is new in 0.9.4.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能是在0.9.4中新增的。
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM可以高效地使用RETURNING获取刚生成的INSERT/UPDATE默认值
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")长期以来支持一个名为`eager_defaults=True`的未记录标志。这个标志的效果是，当进行INSERT或UPDATE时，如果知道行具有服务器生成的默认值，那么会立即跟随一个SELECT以“急切地”加载这些新值。通常，服务器生成的列会在对象上标记为“过期”，因此除非应用程序在刷新后立即访问这些列，否则不会产生任何开销。因此，`eager_defaults`标志并没有太大用处，因为它只会降低性能，并且只存在于支持需要默认值在刷新过程中立即可用的奇特事件方案中。'
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9版本中，由于版本id增强，`eager_defaults`现在可以为这些值发出一个RETURNING子句，因此在具有强大RETURNING支持的后端，特别是PostgreSQL中，ORM可以在INSERT或UPDATE中内联获取新生成的默认值和SQL表达式值。当启用`eager_defaults`时，当目标后端和[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")支持“隐式返回”时，会自动使用RETURNING。
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '### 子查询急加载将对某些查询的最内层SELECT应用DISTINCT'
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少在涉及到多对一关系时子查询急加载可能生成的重复行数，当连接的目标是不包含主键的列时，将在最内层的SELECT中应用DISTINCT关键字，就像在加载多对一关系时一样。
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在从A->B进行子查询加载时：
- en: '[PRE228]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a.b_id`是一个非唯一的外键，所以应用了DISTINCT以消除冗余的`a.b_id`。可以针对特定的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")使用`distinct_target_key`标志来无条件地打开或关闭此行为，将值设置为`True`表示无条件打开，`False`表示无条件关闭，`None`表示当目标SELECT针对不包含完整主键的列时才生效。在0.9版本中，`None`是默认值。
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项也被回溯到了0.8版本，其中`distinct_target_key`选项的默认值为`False`。
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此功能旨在通过消除重复行来提高性能，但SQL中的`DISTINCT`关键字本身可能会对性能产生负面影响。如果SELECT中的列没有索引，`DISTINCT`可能会对行集执行`ORDER
    BY`，这可能是昂贵的。通过将该功能限制在希望在任何情况下都具有索引的外键上，预计新的默认值是合理的。
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能也不能消除每种可能的重复行情况；如果在连接链中的其他地方存在多对一关系，则可能仍然存在重复行。
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### Backref handlers
    can now propagate more than one level deep'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### Backref处理程序现在可以传播超过一层'
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件沿着它们的“发起者”传递的机制已经发生了变化；不再传递`AttributeImpl`，而是传递一个新的对象`Event`；这个对象同时指向`AttributeImpl`和一个“操作令牌”，表示操作是追加、删除还是替换操作。
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件系统不再查看这个“initiator”对象以阻止一系列递归属性事件。相反，防止由于相互依赖的返回处理程序而导致无限递归的系统已经移动到了ORM返回事件处理程序中，这些处理程序现在接管了确保一系列相互依赖事件（例如向集合A.bs添加，响应中设置多对一属性B.a）不会进入无限递归流的角色。这里的理念是，给予返回系统更多的细节和对事件传播的控制，最终可以允许操作深于一个级别的发生；典型情况是集合追加导致多对一替换操作，然后应该导致从以前的集合中移除该项：
- en: '[PRE229]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，在此更改之前，`c1`对象仍然存在于`p1.children`中，即使它同时也存在于`p2.children`中；返回处理程序将停止替换`c1.parent`为`p2`而不是`p1`。在0.9版本中，使用更详细的`Event`对象以及让返回处理程序对这些对象做出更详细的决策，传播可以继续到从`p1.children`中移除`c1`，同时保持对传播进入无限递归循环的检查。
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set")、[`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") 或 [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") 事件的最终用户代码，并且作为这些事件的结果启动进一步的属性修改操作的可能需要进行修改，以防止递归循环，因为在没有返回事件处理程序的情况下，属性系统不再阻止一系列事件无休止地传播。此外，依赖于`initiator`值的代码将需要调整到新的API，并且必须准备好在一系列由返回引发的事件中，`initiator`的值从其原始值更改为其他值，因为返回处理程序现在可能会为某些操作替换新的`initiator`值。
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### The typing system
    now handles the task of rendering “literal bind” values'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### 类型系统现在处理呈现“文字绑定”值的任务'
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的方法被添加到[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")以及[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")，用于处理所谓的“内联文字参数” - 通常呈现为“绑定”值的参数，但由于编译器配置的原因而被内联渲染到
    SQL 语句中。此功能在生成构造如[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")的 DDL 时使用，以及当使用像 `op.inline_literal()` 这样的构造时，由
    Alembic 使用。之前，一个简单的“isinstance”检查仅检查了几种基本类型，并且“绑定处理器”无条件地被使用，导致诸如字符串过早编码为 utf-8
    等问题。
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")编写的自定义类型应继续在“内联文字”场景中工作，因为[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")默认情况下回退到[`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")，因为这些方法通常处理数据操作，而不是数据如何呈现给数据库。
    [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")可以被指定为特别生成表示值应该如何呈现为内联
    DDL 语句的字符串。
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### Schema identifiers
    now carry along their own quoting information'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### 架构标识符现在携带其自身的引号信息'
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改简化了核心对所谓的“引号”标志的使用，例如传递给[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的`quote`标志。该标志现在内部化在字符串名称本身中，现在表示为[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name")的实例，一个字符串子类。[`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer")现在仅依赖于由[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name")对象报告的引号偏好，而不再在大多数情况下检查任何显式的`quote`标志。此处解决的问题包括各种区分大小写的方法，如`Engine.has_table()`以及方言内的类似方法现在可以使用显式带引号的名称正常工作，而无需复杂化或引入与引号标志的细节相关的不兼容更改到这些API（其中许多是第三方）-
    特别是，更广泛范围的标识符现在可以与所谓的“大写”后端（如Oracle、Firebird和DB2等后端，这些后端使用全大写存储和报告表和列名称以用于不区分大小写的名称）正确地运行。
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name")对象根据需要在内部使用；但是，如果其他关键字需要固定引号偏好，则该类可公开使用。'
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### Improved rendering
    of Boolean constants, NULL constants, conjunctions'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### 改进的布尔常量、NULL常量、连接的渲染'
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能已添加到[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")和[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")常量中，特别是与[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_")和[`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_")函数以及与这些类型、布尔类型总体以及[`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null")常量一起使用的WHERE/HAVING子句的行为。
- en: 'Starting with a table such as this:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 从这样的表格开始：
- en: '[PRE230]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持`true`/`false`常量行为的后端上，选择构造现在将布尔列呈现为二进制表达式：
- en: '[PRE231]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")和[`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_")构造现在将表现出准“短路”行为，即当存在[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true")或[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")常量时，截断呈现的表达式：'
- en: '[PRE232]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")可以用作构建表达式的基础：'
- en: '[PRE233]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")和[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")本身在没有布尔常量的后端上呈现为`0 = 1`和`1 = 1`：
- en: '[PRE234]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`的解释，虽然不是特别有效的SQL，但至少现在是一致的：'
- en: '[PRE235]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### Label constructs
    can now render as their name alone in an ORDER BY'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### 标签构造现在可以仅在ORDER BY中呈现为它们的名称'
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在SELECT的列子句和ORDER BY子句中都使用[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label")的情况，假设底层方言报告支持此功能，则标签将仅在ORDER BY子句中呈现为其名称。
- en: 'E.g. an example like:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 例如一个示例如：
- en: '[PRE236]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Prior to 0.9 would render as:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9之前将呈现为：
- en: '[PRE237]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'And now renders as:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE238]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当标签未进一步嵌入到ORDER BY中的表达式中时，ORDER BY才会呈现标签，除了简单的`ASC`或`DESC`。
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在所有经过测试的数据库上都有效，但可能与旧数据库版本（MySQL 4？Oracle 8？等）存在兼容性问题。根据用户报告，我们可以添加规则，根据数据库版本检测禁用该功能。
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy` now has
    tuple-sorting behavior'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy`现在具有元组排序行为'
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`对象的行为很像元组，但直到现在，如果使用`sorted()`对它们的列表进行排序，它们不会像元组一样排序。现在`__eq__()`方法将两侧都作为元组进行比较，还添加了一个`__lt__()`方法：'
- en: '[PRE239]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### A bindparam() construct
    with no type gets upgraded via copy when a type is available'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### 当类型可用时，没有类型的bindparam()构造会通过复制进行升级'
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 将“升级”[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造以采用封闭表达式类型的逻辑已经以两种方式得到改进。首先，在分配新类型之前，会**复制**[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")对象，以便给定的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")不会在原地改变。其次，在编译[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造时，会对通过[`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values")方法在语句中设置的“values”进行相同的操作。
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定一个未指定类型的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")：
- en: '[PRE240]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'If we use this parameter as follows:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像下面这样使用这个参数：
- en: '[PRE241]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`bp`的类型仍然是`NullType`，但是如果`mytable.c.col`的类型是`String`，那么`expr.right`，即二进制表达式的右侧，将采用`String`类型。以前，`bp`本身会被直接更改为`String`类型。
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个操作发生在[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")中：
- en: '[PRE242]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`bp`保持不变，但当语句执行时将使用`String`类型，我们可以通过检查`binds`字典来看到这一点：
- en: '[PRE243]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能允许自定义类型在INSERT/UPDATE语句中发挥其预期效果，而无需在每个[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")表达式中显式指定这些类型。
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的向后兼容更改涉及两种不太可能的情况。由于绑定参数是**克隆**的，用户不应该依赖于对创建后的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造进行原地更改。此外，使用[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")语句中的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")的代码，如果依赖于[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")不根据分配给的列进行类型化，则不再以这种方式运行。
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### Columns can reliably
    get their type from a column referred to via ForeignKey'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### Columns can reliably
    get their type from a column referred to via ForeignKey'
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个长期存在的行为，它规定可以声明一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")而不需要类型，只要这个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")被一个[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")所引用，并且被引用的列的类型会被复制到这个列中。问题在于，这个特性从来没有很好地工作过，并且没有得到维护。核心问题是[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象在被询问之前不知道它引用的目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")是哪一个，通常是第一次使用外键来构造一个[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")时。因此，在那之前，父[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")将没有类型，或者更具体地说，它将具有一个[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")的默认类型。
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然花费了很长时间，重新组织[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象的初始化工作已经完成，以便使这一功能最终能够令人满意地运行。这一变化的核心是，[`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column")属性不再延迟初始化目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的位置；这一系统的问题在于，拥有的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")会一直被固定为[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")类型，直到[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")被使用。
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本中，[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")通过内部附加事件与最终将引用的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")协调，因此一旦引用的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联，所有引用它的[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象都将收到一条消息，告诉它们需要初始化其父列。这一系统更加复杂，但更加稳固；作为奖励，现在已经为各种[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")配置场景设置了测试，并且错误消息已经改进，以便非常具体地指出不少于七种不同的错误条件。
- en: 'Scenarios which now work correctly include:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以正确工作的场景包括：
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")与相同的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")上的类型立即存在；无论哪一侧首先配置，这都能正常工作：
- en: '[PRE244]'
  id: totrans-880
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统现在也与[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")一起工作：
- en: '[PRE245]'
  id: totrans-882
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它甚至适用于“多跳” - 也就是，一个[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")指向一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")再指向另一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")：
- en: '[PRE246]'
  id: totrans-884
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)  ### Many JOIN and LEFT
    OUTER JOIN expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)  ### 许多JOIN和LEFT OUTER
    JOIN表达式将不再被包装在(SELECT * FROM ..) AS ANON_1中'
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，SQLAlchemy ORM一直无法将JOIN嵌套在现有JOIN的右侧（通常是LEFT OUTER JOIN，因为INNER JOIN始终可以被展平）：
- en: '[PRE247]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为SQLite直到版本**3.7.16**之前无法解析上述格式的语句：
- en: '[PRE248]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '右外连接当然是另一种解决右侧括号化的方法；这将会显著复杂化并且视觉上不愉快去实现，但幸运的是SQLite也不支持RIGHT OUTER JOIN :):'
- en: '[PRE249]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2005年，其他数据库是否有问题这种形式并不清楚，但今天看来，除了SQLite之外的每个测试过的数据库现在都支持它（Oracle 8，一个非常古老的数据库，根本不支持JOIN关键字，但SQLAlchemy一直对Oracle的语法有一个简单的重写方案）。更糟糕的是，SQLAlchemy通常的解决方法，即应用SELECT，通常会降低像PostgreSQL和MySQL这样的平台的性能：
- en: '[PRE250]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 像上述形式的JOIN在处理联接表继承结构时很常见；每当使用[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")从某个父类连接到联接表子类，或者类似地使用[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")时，SQLAlchemy的ORM总是确保不会呈现嵌套的JOIN，以免查询无法在SQLite上运行。即使Core始终支持更紧凑形式的JOIN，ORM也必须避免使用它。
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ON子句中存在特殊条件时，跨多对多关系生成连接时会出现另一个问题。考虑像下面这样的急切加载连接：
- en: '[PRE251]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 假设从`Order`到`Item`的多对多实际上指的是像`Subitem`这样的子类，上述情况的SQL将如下所示：
- en: '[PRE252]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询有什么问题？基本上，它将加载许多`order` / `order_item`行，其中`item.type == 'subitem'`的条件不成立。
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 0.9 开始，采取了一种全新的方法。ORM 不再担心在封闭连接的右侧嵌套 JOIN，并且现在将尽可能经常地呈现这些，同时仍然返回正确的结果。当
    SQL 语句被传递进行编译时，**方言编译器**将会**重写连接**以适应目标后端，如果该后端已知不支持右嵌套 JOIN（目前只有 SQLite - 如果其他后端有此问题，请告诉我们！）。
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常规的 `query(Parent).join(Subclass)` 现在通常会产生一个更简单的表达式：
- en: '[PRE253]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `query(Parent).options(joinedload(Parent.subclasses))` 这样的连接急切加载将为各个表创建别名，而不是包装在
    `ANON_1` 中：
- en: '[PRE254]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多连接和急切加载将右嵌套“次要”和“右”表：
- en: '[PRE255]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些连接，当与明确指定 `use_labels=True` 的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 语句一起呈现时，这对于 ORM 发出的所有查询都是真实的，都是“连接重写”的候选对象，这是将所有这些右嵌套连接重写为嵌套的
    SELECT 语句的过程，同时保持与 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 使用的相同标签。因此，SQLite，即使在 2013 年，仍然不支持这种非常常见的
    SQL 语法，也要承担额外的复杂性，以上查询被重写为：
- en: '[PRE256]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Note
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 1.1 开始，此功能中存在的针对 SQLite 的解决方法将在检测到 SQLite 版本 **3.7.16** 或更高版本时自动禁用自身，因为
    SQLite 已修复了对右嵌套连接的支持。
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join.alias()`，[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 和 [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") 函数现在支持一个新参数 `flat=True`，用于构建连接表实体的别名而不嵌入到 SELECT
    中。这个标志默认情况下是关闭的，以帮助向后兼容性 - 但现在一个“多态”可选择可以作为目标连接而不生成任何子查询：'
- en: '[PRE257]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Generates (everywhere except SQLite):'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 生成（除了 SQLite 之外的所有地方）：
- en: '[PRE258]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)'
- en: '### Right-nested inner joins available in joined eager loads'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '### 右嵌套内连接在连接的急切加载中可用'
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 0.9.4 开始，在连接的急切加载情况下，可以启用上述提到的右嵌套连接，其中“外部”连接链接到右侧的“内部”连接。
- en: 'Normally, a joined eager load chain like the following:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像下面这样的连接急切加载链：
- en: '[PRE259]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 不会产生内连接；由于从user->order的LEFT OUTER JOIN，连接的急切加载无法使用从order->items的INNER join而不更改返回的用户行，并且会忽略“链接”的`innerjoin=True`指令。0.9.0应该交付的是，而不是：
- en: '[PRE260]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“右嵌套连接是可以的”逻辑将启动，我们将得到：
- en: '[PRE261]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们错过了这一点，为了避免进一步的退化，我们通过将字符串`"nested"`指定给[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")来添加了上述功能：
- en: '[PRE262]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: This feature is new in 0.9.4.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能是在0.9.4中新增的。
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM可以使用RETURNING高效地获取刚生成的INSERT/UPDATE默认值
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")长期以来支持一个名为`eager_defaults=True`的未记录标志。此标志的效果是，当进行INSERT或UPDATE时，并且已知该行具有服务器生成的默认值时，将立即跟随SELECT以“急切地”加载这些新值。通常，服务器生成的列会在对象上标记为“过期”，因此除非应用程序在刷新后立即访问这些列，否则不会产生任何开销。因此，`eager_defaults`标志实际上没有太大用处，因为它只会降低性能，并且仅用于支持需要默认值在刷新过程中立即可用的奇特事件方案。'
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9版本由于版本ID增强，`eager_defaults`现在可以为这些值发出一个RETURNING子句，因此在具有强大RETURNING支持的后端，特别是PostgreSQL上，ORM可以在INSERT或UPDATE中内联获取新生成的默认值和SQL表达式值。`eager_defaults`在启用时，当目标后端和[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")支持“隐式返回”时，会自动使用RETURNING。
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '### 子查询急切加载将对某些查询的最内部SELECT应用DISTINCT'
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少涉及多对一关系时子查询急切加载可能生成的重复行数，当连接针对不包括主键的列时，将在最内部SELECT中应用DISTINCT关键字，例如在沿着多对一加载时。
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当在A->B的多对一上进行子查询加载时：
- en: '[PRE263]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a.b_id`是一个非唯一的外键，因此应用了DISTINCT，以消除冗余的`a.b_id`。可以通过在特定的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上设置`distinct_target_key`标志来无条件地打开或关闭此行为，将值设置为`True`表示无条件打开，`False`表示无条件关闭，`None`表示当目标SELECT针对不包含完整主键的列时，该特性生效。在0.9版本中，`None`是默认值。
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项也被回溯到了0.8版本，其中`distinct_target_key`选项的默认值为`False`。
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特性旨在通过消除重复行来提高性能，但SQL中的`DISTINCT`关键字本身可能会对性能产生负面影响。如果SELECT中的列没有索引，`DISTINCT`可能会对行集执行`ORDER
    BY`，这可能是昂贵的。通过将该特性限制在希望在任何情况下都有索引的外键上，预计新的默认值是合理的。
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性也不会消除每种可能的重复行情况；如果在连接链中的其他地方存在多对一关系，则可能仍然存在重复行。
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)'
- en: '### Backref handlers can now propagate more than one level deep'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '### 反向引用处理程序现在可以传播超过一级深度'
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件传递其“发起者”的机制已经发生了变化；不再传递`AttributeImpl`，而是传递一个新对象`Event`；这个对象同时指向`AttributeImpl`和一个“操作令牌”，表示操作是追加、移除还是替换操作。
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件系统不再查看这个“发起者”对象以阻止属性事件的递归系列。相反，为了防止由于相互依赖的反向引用处理程序而导致的无限递归，现在将这一系统移动到了ORM反向引用事件处理程序中，这些处理程序现在负责确保一系列相互依赖的事件（例如向集合A.bs追加，在响应中设置多对一属性B.a）不会进入无限递归流。这里的理念是，反向引用系统，通过更详细和控制事件传播，最终可以允许超过一级深度的操作发生；典型情况是，当集合追加导致多对一替换操作时，这反过来应该导致项目从先前的集合中移除：
- en: '[PRE264]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之前，`c1` 对象仍然会存在于`p1.children`中，即使它同时也存在于`p2.children`中；回引处理程序会在替换`c1.parent`为`p2`而不是`p1`时停止。在
    0.9 版本中，使用更详细的`Event`对象，让回引处理程序对这些对象做出更详细的决策，传播可以继续删除`p1.children`中的`c1`，同时保持检查以防止传播进入无限递归循环。
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 终端用户代码，a. 使用[`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set")、[`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append")或[`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove")事件，并且 b. 由于这些事件导致进一步的属性修改操作，可能需要修改以防止递归循环，因为在缺少回引事件处理程序的情况下，属性系统不再阻止事件链无限传播。此外，依赖于`initiator`值的代码将需要调整到新的
    API，并且必须准备好`initiator`值在一系列由回引引发的事件中从其原始值更改，因为回引处理程序现在可能会为某些操作交换新的`initiator`值。
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)'
- en: '### The typing system now handles the task of rendering “literal bind” values'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '### 类型系统现在处理呈现“文字绑定”值的任务'
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 为[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")添加了一个新方法[`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")以及[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")用于[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，它们负责呈现所谓的“内联文字参数” - 通常呈现为“绑定”值的参数，但由于编译器配置的原因而被内联呈现到
    SQL 语句中。此功能用于生成诸如[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")等结构的 DDL，以及在使用诸如`op.inline_literal()`之类的结构时，被
    Alembic 使用。以前，一个简单的“isinstance”检查检查了一些基本类型，并且“绑定处理程序”无条件地被使用，导致诸如字符串过早编码为 utf-8
    等问题。
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 编写的自定义类型应继续在“内联文字”场景中工作，因为 [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") 默认情况下会退回到 [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")，因为这些方法通常处理数据操作，而不是数据如何呈现给数据库。[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") 可以指定特定地生成一个表示值应如何呈现为内联
    DDL 语句的字符串。
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)'
- en: '### Schema identifiers now carry along their own quoting information'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '### 现在模式标识符携带自己的引号信息'
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改简化了 Core 对所谓的“引号”标志的使用，例如传递给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 和 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的 `quote` 标志。该标志现在内部化在字符串名称本身中，现在表示为 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 的实例，一个字符串子类。[`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") 现在仅依赖于由 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 对象报告的引号偏好，而不是在大多数情况下检查任何显式的 `quote` 标志。此处解决的问题包括，各种区分大小写的方法，如
    `Engine.has_table()` 以及方言内的类似方法现在可以使用显式引号名称正常工作，而无需复杂化或引入对这些 API（其中许多是第三方的）的引号标志的变更。特别是，更广泛范围的标识符现在可以与所谓的“大写”后端（如
    Oracle、Firebird 和 DB2）正确地工作，这些后端使用全大写存储和报告不区分大小写的名称的表和列名称。
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 对象在需要时在内部使用；然而，如果其他关键字需要固定引号偏好，该类是公开可用的。'
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)'
- en: '### Improved rendering of Boolean constants, NULL constants, conjunctions'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进的布尔常量、NULL 常量、连接的���现'
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能已添加到[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")和[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")常量中，特别是与[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_")和[`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_")函数以及与这些类型、布尔类型总体以及[`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null")常量一起使用时的WHERE/HAVING子句的行为。
- en: 'Starting with a table such as this:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 从这样的表开始：
- en: '[PRE265]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在不具有`true`/`false`常量行为的后端上，select构造现在将将布尔列呈现为二进制表达式：
- en: '[PRE266]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")和[`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_")构造现在将表现出准“短路”行为，即当存在[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true")或[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")常量时，将截断呈现的表达式：'
- en: '[PRE267]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")可以用作构建表达式的基础：'
- en: '[PRE268]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")和[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")本身在没有布尔常量的后端上呈现为`0 = 1`和`1 = 1`：
- en: '[PRE269]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 对`None`的解释，虽然不是特别有效的SQL，但至少现在是一致的：
- en: '[PRE270]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)'
- en: '### Label constructs can now render as their name alone in an ORDER BY'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '### Label构造现在可以在ORDER BY中仅呈现为其名称'
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在SELECT的列子句和ORDER BY子句中都使用[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label")的情况，假设底层方言报告支持此功能，则标签将仅在ORDER BY子句中呈现为其名称。
- en: 'E.g. an example like:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个示例：
- en: '[PRE271]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Prior to 0.9 would render as:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9之前会呈现为：
- en: '[PRE272]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'And now renders as:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE273]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当标签未进一步嵌入到ORDER BY中的表达式中时，ORDER BY才会呈现标签，除了简单的`ASC`或`DESC`。
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在所有经过测试的数据库上都有效，但可能与旧版本数据库（MySQL 4？Oracle 8？等）存在兼容性问题。根据用户报告，我们可以添加规则，根据数据库版本检测来禁用该功能。
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)'
- en: '### `RowProxy` now has tuple-sorting behavior'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '### `RowProxy`现在具有元组排序行为'
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`对象的行为很像元组，但直到现在，如果使用`sorted()`对它们的列表进行排序，它们将不会作为元组进行排序。现在，`__eq__()`方法会将两边都作为元组进行比较，同时还添加了一个`__lt__()`方法：'
- en: '[PRE274]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)'
- en: '### A bindparam() construct with no type gets upgraded via copy when a type
    is available'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当类型可用时，`bindparam()`构造不带类型的通过复制进行升级'
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造升级为采用封闭表达式类型的逻辑已经有了两方面的改进。首先，在分配新类型之前，[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")对象会被**复制**，以便给定的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")不会在原地改变。其次，当编译[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造时，通过[`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values")方法在语句中设置的“values”也会发生相同的操作。
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定一个未类型化的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")：
- en: '[PRE275]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'If we use this parameter as follows:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个参数如下：
- en: '[PRE276]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`bp`的类型仍然是`NullType`，但是如果`mytable.c.col`是`String`类型，则`expr.right`，即二进制表达式的右侧，将采用`String`类型。以前，`bp`本身会被直接更改为具有`String`类型。
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个操作发生在[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")中：
- en: '[PRE277]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`bp`保持不变，但当语句执行时将使用`String`类型，我们可以通过检查`binds`字典来看到这一点：
- en: '[PRE278]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能允许自定义类型在INSERT/UPDATE语句中产生预期效果，而无需在每个[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")表达式中显式指定这些类型。
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的向后兼容更改涉及两种不太可能的情况。由于绑定参数是**克隆**的，用户不应该依赖于对一旦创建的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")构造进行就地更改。此外，使用[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")的代码在[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")或[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")语句中，依赖于[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")未根据分配给的列进行类型化的事实，将不再以这种方式运行。
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)'
- en: '### Columns can reliably get their type from a column referred to via ForeignKey'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '### 列可以可靠地从通过ForeignKey引用的列获取其类型'
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个长期存在的行为，即可以声明不带类型的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，只要该[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")被[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")引用，并且引用列的类型将被复制到此列中。问题在于，这个功能从未很好地工作过，并且没有得到维护。核心问题在于，[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")对象在被要求之前不知道它引用的目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，通常是第一次外键用于构造[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")时。因此，在那之前，父[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")将没有类型，或者更具体地说，它将具有默认类型[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")。
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然花了很长时间，但重新组织 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 对象初始化的工作已经完成，以便这个功能最终可以令人满意地工作。 这个变化的核心是 [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") 属性不再延迟初始化目标 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的位置；这个系统的问题是拥有的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 会被困在 [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") 作为其类型，直到 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 被使用。
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本中，[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    与最终将引用的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    协调使用内部附加事件，因此一旦引用的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    与 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    关联，所有引用它的 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 对象都会收到一条消息，告诉它们需要初始化其父列。 这个系统更复杂，但更可靠；作为奖励，现在已经为各种
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    配置方案设置了测试，并且错误消息已经改进为非常具体，涵盖了不少于七种不同的错误条件。
- en: 'Scenarios which now work correctly include:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正确工作的场景包括：
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  id: totrans-1004
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    上的类型会在目标 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    与相同的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    关联后立即出现；无论哪一边先配置都可以：'
- en: '[PRE279]'
  id: totrans-1005
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  id: totrans-1006
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统现在也可以与 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 一起工作：
- en: '[PRE280]'
  id: totrans-1007
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-1008
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它甚至适用于“多次跳跃” - 即，一个[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")指向一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，该列指向另一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
- en: '[PRE281]'
  id: totrans-1009
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
- en: Dialect Changes
  id: totrans-1011
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言变更
- en: Firebird `fdb` is now the default Firebird dialect.
  id: totrans-1012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 现在是默认的 Firebird 方言。
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建引擎时没有指定方言，即 `firebird://`，则现在使用 `fdb` 方言。`fdb` 是一个兼容 `kinterbasdb` 的 DBAPI，根据
    Firebird 项目，现在是他们官方的 Python 驱动程序。
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  id: totrans-1015
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 和 `kinterbasdb` 默认设置 `retaining=False`。
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdb` 和 `kinterbasdb` DBAPI 都支持一个标志 `retaining=True`，可以传递给其连接的 `commit()` 和
    `rollback()` 方法。文档中对此标志的解释是，DBAPI 可以重新使用内部事务状态进行后续事务，以提高性能。但是，较新的文档提到了 Firebird
    的“垃圾收集”的分析，表明此标志可能对数据库的处理清理任务的能力产生负面影响，并且因此报告了性能的*降低*。'
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此信息，目前不清楚此标志实际上如何可用，并且由于它似乎仅是一种性能增强功能，因此现在默认设置为 `False`。可以通过向[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")调用传递标志 `retaining=True` 来控制值。这是从 0.8.2 开始添加的新标志，因此在
    0.8.2 上的应用程序可以根据需要将其设置为 `True` 或 `False`。
- en: See also
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '`sqlalchemy.dialects.firebird.fdb`'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.fdb`'
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.kinterbasdb`'
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - 有关“保留”标志的信息。'
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
- en: Firebird `fdb` is now the default Firebird dialect.
  id: totrans-1023
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 现在是默认的 Firebird 方言。
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建引擎时没有指定方言，即 `firebird://`，则现在使用 `fdb` 方言。`fdb` 是一个兼容 `kinterbasdb` 的 DBAPI，根据
    Firebird 项目，现在是他们官方的 Python 驱动程序。
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  id: totrans-1026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird `fdb` 和 `kinterbasdb` 默认设置 `retaining=False`。
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdb`和`kinterbasdb`两个DBAPI都支持一个名为`retaining=True`的标志，可以传递给其连接的`commit()`和`rollback()`方法。文档中对这个标志的理由是，DBAPI可以重用内部事务状态以用于后续事务，以提高性能。然而，更新的文档提到了对Firebird的“垃圾回收”的分析，表明这个标志可能会对数据库处理清理任务的能力产生负面影响，并因此被报告为*降低*性能。'
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些信息，目前尚不清楚如何实际使用这个标志，而且由于它似乎只是一个性能增强功能，现在默认值为`False`。可以通过在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")调用中传递标志`retaining=True`来控制该值。这是一个新标志，从0.8.2版本开始添加，因此在0.8.2上的应用程序可以根据需要将其设置为`True`或`False`。
- en: See also
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`sqlalchemy.dialects.firebird.fdb`'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.fdb`'
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.firebird.kinterbasdb`'
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - 有关“retaining”标志的信息。'
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
