- en: What’s New in SQLAlchemy 1.1?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: What’s New in SQLAlchemy 1.1?
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_11.html](https://docs.sqlalchemy.org/en/20/changelog/migration_11.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_11.html](https://docs.sqlalchemy.org/en/20/changelog/migration_11.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: About this Document
- en: This document describes changes between SQLAlchemy version 1.0 and SQLAlchemy
    version 1.1.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了SQLAlchemy版本1.0和版本1.1之间的变化。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Introduction
- en: This guide introduces what’s new in SQLAlchemy version 1.1, and also documents
    changes which affect users migrating their applications from the 1.0 series of
    SQLAlchemy to 1.1.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy 1.1版本的新功能，并记录了影响用户将其应用程序从SQLAlchemy 1.0系列迁移到1.1系列的变化。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看关于行为变化的部分，可能存在与旧版本不兼容的行为变化。
- en: Platform / Installer Changes
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台/安装程序变更
- en: Setuptools is now required for install
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Setuptools is now required for install
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的`setup.py`文件多年来一直支持安装Setuptools或不安装Setuptools两种方式；支持“回退”模式，即使用普通的Distutils。由于现在几乎不再听说不安装Setuptools的Python环境了，并且为了更全面地支持Setuptools的特性集，特别是支持py.test与其集成以及诸如“extras”之类的功能，`setup.py`现在完全依赖于Setuptools。
- en: See also
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: See also
- en: '[Installation Guide](../intro.html#installation)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装指南](../intro.html#installation)'
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
- en: Enabling / Disabling C Extension builds is only via environment variable
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅通过环境变量启用/禁用C扩展构建
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在安装时构建C扩展，只要可能。要禁用C扩展构建，从SQLAlchemy 0.8.6 / 0.9.4开始，可使用`DISABLE_SQLALCHEMY_CEXT`环境变量。之前使用`--without-cextensions`参数的方法已被移除，因为它依赖于已弃用的setuptools功能。
- en: See also
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: See also
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建Cython扩展](../intro.html#c-extensions)'
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
- en: New Features and Improvements - ORM
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: '### New Session lifecycle events'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的会话生命周期事件'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")长期以来一直支持事件，允许在某种程度上跟踪对象状态的变化，包括[`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach")、[`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach")和[`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")。Session文档还在[快速对象状态介绍](../orm/session_state_management.html#session-object-states)中记录了主要的对象状态。然而，过去从未有过专门跟踪对象经过这些转换的系统。此外，“已删除”对象的状态一直比较模糊，因为这些对象的行为介于“持久”和“分离”状态之间。'
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理这个领域并使会话状态转换的范围完全透明化，已添加了一系列新事件，旨在涵盖对象可能在状态之间转换的每种可能方式，而且还给“已删除”状态在会话对象状态领域内赋予了自己的正式状态名称。
- en: New State Transition Events
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新状态转换事件
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对象所有状态之间的转换，如[persistent](../glossary.html#term-persistent)、[pending](../glossary.html#term-pending)等，现在都可以通过会话级事件的方式进行拦截，以涵盖特定的转换。当对象进入
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")、从
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    移出，甚至当使用 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 回滚事务时发生的所有转换都明确出现在 [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents
    "sqlalchemy.orm.SessionEvents") 接口中。
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有**十个新事件**。这些事件的摘要在新编写的文档部分[对象生命周期事件](../orm/session_events.html#session-lifecycle-events)中。
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加了新的对象状态“deleted”，已删除的对象不再“persistent”
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的[persistent](../glossary.html#term-persistent)状态一直以来都被记录为具有有效的数据库标识；然而，对于在 flush
    中被删除的对象，它们一直处于一个灰色地带，在这个地带中，它们并没有真正“分离”出 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为它们仍然可以在回滚时恢复，但它们并不真正“persistent”，因为它们的数据库标识已被删除，而且它们不在标识映射中。
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这一新事件中的灰色地带，引入了一个新的对象状态[删除](../glossary.html#term-deleted)。此状态存在于“持久”状态和“分离”状态之间。通过
    [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记为删除的对象保持在“持久”状态，直到刷新进行为止；在那时，它将从身份映射中删除，转移到“已删除”状态，并调用 [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") 钩子。如果 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务被回滚，则对象将被恢复为持久状态；将调用 [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") 转换。否则，如果 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务被提交，则调用 [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") 转换。
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，[`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") 访问器**不再返回 True**，表示对象处于新的“已删除”状态；相反，增强了
    [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 访问器以可靠地报告此新状态。当对象分离时，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 返回 False，并且 [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") 访问器为 True。要确定对象是否在当前事务或上一个事务中被删除，请使用
    [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") 访问器。
- en: Strong Identity Map is Deprecated
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强身份映射已被弃用。
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新系列过渡事件的灵感之一是为了实现对象在进出标识映射时的无泄漏跟踪，以便维护“强引用”，反映对象在此映射中进出的情况。有了这种新能力，就不再需要 [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") 参数和相应的 `StrongIdentityMap` 对象。这个选项在 SQLAlchemy 中已经存在多年，因为“强引用”行为曾经是唯一可用的行为，许多应用程序都被写成假定这种行为。长期以来，一直建议对象的强引用跟踪不是
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的固有工作，而是一个应用级别的构造，根据应用程序的需要构建；新的事件模型甚至允许复制强标识映射的确切行为。查看 [会话引用行为](../orm/session_state_management.html#session-referencing-behavior)
    以获取一个新的示例，说明如何替换强标识映射。
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### New init_scalar()
    event intercepts default values at ORM level'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### 新的 init_scalar()
    事件拦截 ORM 级别的默认值'
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次访问未设置的属性时，ORM 会为非持久化对象生成一个值为 `None`：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用例是为了在对象持久化之前，使得 Python 中的值与 Core 生成的默认值对应。为了适应这种用例，添加了一个新的事件 [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar")。在 [属性仪器化](../orm/examples.html#examples-instrumentation)
    中的新示例 `active_column_defaults.py` 说明了一个示例用法，因此效果可以是：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### Changes regarding
    “unhashable” types, impacts deduping of ORM rows'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### 关于“不可哈希”类型的更改，影响
    ORM 行的去重'
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象具有“去重”返回行的良好行为，其中包含至少一个 ORM 映射实体（例如，一个完全映射的对象，而不是单独的列值）。这样做的主要目的是为了使实体的处理与标识映射顺利配合，包括适应通常在连接式急加载中表示的重复实体，以及在使用连接来过滤其他列时。'
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种去重依赖于行内元素的可哈希性。随着PostgreSQL的特殊类型如[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")和[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")的引入，行内类型被标记为不可哈希并在这里遇到问题的经验比以前更普遍。
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，SQLAlchemy自版本0.8以来在被标记为“unhashable”的数据类型上包含了一个标志，然而这个标志在内置类型上并没有一致使用。正如[ARRAY和JSON类型现在正确指定“unhashable”](#change-3499-postgresql)中所描述的，这个标志现在对所有PostgreSQL的“结构”类型一致设置。
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “unhashable”标志也设置在[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")类型上，因为[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")用于引用任何未知类型的表达式。
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")应用于大多数`func`的用法，因为`func`实际上在大多数情况下并不知道给定的函数名称，**使用func()通常会禁用行去重，除非应用了显式类型**。以下示例说明了将`func.substr()`应用于字符串表达式，以及将`func.date()`应用于日期时间表达式；这两个示例将由于连接的急加载而返回重复行，除非应用了显式类型：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above examples, in order to retain deduping, should be specified as:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留去重，上述示例应该指定为：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，所谓的“unhashable”类型的处理与以前的版本略有不同；在内部，我们使用`id()`函数从这些结构中获取“哈希值”，就像我们对待任何普通映射对象一样。这取代了以前将计数器应用于对象的方法。
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Specific checks added
    for passing mapped classes, instances as SQL literals'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### 为传递映射类、实例作为SQL文字添加了特定检查'
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型系统对于在本应被处理为字面值的上下文中传递SQLAlchemy“可检查”对象具有特定检查。任何SQLAlchemy内置对象，如果作为SQL值传递是合法的（而不是已经是[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")实例），都包括一个`__clause_element__()`方法，该方法为该对象提供有效的SQL表达式。对于不提供此方法的SQLAlchemy对象，例如映射类、映射器和映射实例，会发出更具信息性的错误消息，而不是允许DBAPI接收对象并稍后失败。下面举例说明了一个情况，其中基于字符串的属性`User.name`与`User()`的完整实例进行比较，而不是与字符串值进行比较：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较`User.name == some_user`时，异常现在会立即发生。以前，像上面这样的比较会产生一个SQL表达式，只有在解析为DBAPI执行调用时才会失败；映射的`User`对象最终会变成一个被DBAPI拒绝的绑定参数。
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，表达式失败是因为`User.name`是一个基于字符串的（例如基于列的）属性。这种变化*不会*影响通常情况下将多对一关系属性与对象进行比较的情况，这种情况会被单独处理：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### New Indexable ORM
    extension'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### 新的可索引ORM扩展'
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html) 扩展是混合属性功能的扩展，允许构建引用“可索引”数据类型的特定元素的属性，例如数组或JSON字段：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`name`属性将从JSON列`data`中读取/写入字段`"name"`，在初始化为空字典后：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当修改属性时，该扩展还会触发一个更改事件，因此无需使用[`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict")来跟踪此更改。
- en: See also
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Indexable](../orm/extensions/indexable.html)  ### New options allowing explicit
    persistence of NULL over a default'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html)  ### 新选项允许显式持久化NULL值而不是默认值'
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PostgreSQL 中新增的 JSON-NULL 支持相关，作为 [JSON “null” 在 ORM 操作中被插入时的预期行为，当不存在时被省略](#change-3514)
    的一部分，基础 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    类现在支持一个方法 [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none")，允许将属性上的 `None` 值设置为 NULL，而不是在 INSERT
    语句中省略列，这会导致使用列级默认值的效果。这允许在映射器级别配置现有的对象级技术，将 [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") 分配给属性。
- en: See also
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[强制在具有默认值的列上使用 NULL](../orm/persistence_techniques.html#session-forcing-null)'
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### Further Fixes to
    single-table inheritance querying'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### 进一步修复单表继承查询'
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 继续从 1.0 的 [使用 from_self(), count() 时对单表继承条件的更改](migration_10.html#migration-3177)，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 在查询针对子查询表达式时，如 exists 时，不应再不适当地添加“单一继承”条件：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Produces:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 里面的 IN 子句是适当的，以限制为 FooWidget 对象，但以前 IN 子句也会在子查询之外生成第二次。
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### Improved Session
    state when a SAVEPOINT is cancelled by the database'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### 当数据库取消 SAVEPOINT
    时改进了会话状态'
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 的一个常见情况是在事务中发生死锁时取消 SAVEPOINT。[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 已经被修改，以更为优雅地处理这种失败模式，使得外部的非 SAVEPOINT 事务仍然可用：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是 [#2696](https://www.sqlalchemy.org/trac/ticket/2696) 的延续，我们发出警告，以便在 Python
    2 上运行时可以看到原始错误，即使 SAVEPOINT 异常优先。在 Python 3 上，异常被链接在一起，因此两个失败都会被单独报告。
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### Erroneous “new instance
    X conflicts with persistent instance Y” flush errors fixed'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### 修复了错误的“新实例 X 与持久实例
    Y 冲突”刷新错误'
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法负责删除在数据库中插入的对象，例如在那个现在回滚的事务中从挂起状态移动到持久状态。进行此状态更改的对象在一个弱引用集合中被跟踪，如果一个对象从该集合中被垃圾回收，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")不再关心它（否则对于在事务中插入许多新对象的操作不会扩展）。然而，如果应用程序在事务中重新加载相同的被垃圾回收的行，在回滚发生之前会出现问题；如果对这个对象的强引用保留到下一个事务中，那么这个对象未被插入并应该被删除的事实将丢失，并且flush将不正确地引发错误：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The above program would raise:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序将引发：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: bug在于当上述异常被触发时，工作单元正在操作原始对象，假设它是一个活动行，而实际上对象已过期，并在测试中发现它已经消失。修复现在测试这种情况，因此在SQL日志中我们看到：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，工作单元现在为我们即将报告为冲突的行执行SELECT，看到它不存在，并正常进行。只有在我们本来会在任何情况下错误地引发异常时，才会发生这个SELECT的开销。
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### passive_deletes feature
    for joined-inheritance mappings'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### 联接继承映射的passive_deletes功能'
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，联接表继承映射可能允许DELETE继续进行，作为[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")的结果，该方法仅为基表发出DELETE，而不是子类表，从而允许配置的ON DELETE CASCADE发生在配置的外键上。这是使用`mapper.passive_deletes`选项配置的：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，`mapper.passive_deletes`选项在基本映射器上配置；它对于所有具有设置选项的祖先映射器的非基本映射器生效。对于类型为`B`的对象的DELETE不再需要检索`b_table_id`的主键值（如果未加载），也不需要为表本身发出DELETE语句：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Will emit SQL as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的SQL如下：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，目标数据库必须具有启用ON DELETE CASCADE的外键支持。
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### Same-named backrefs
    will not raise an error when applied to concrete inheritance subclasses'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### 同名反向引用应用于具体继承子类时不会引发错误'
- en: 'The following mapping has always been possible without issue:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下映射一直是可能的而没有问题：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，即使类`A`和类`A1`有一个名为`b`的关系，也不会出现冲突警告或错误，因为类`A1`被标记为“具体”。
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果关系配置反过来，就会出现错误：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修复增强了反向引用功能，以便不发出错误，并在映射器逻辑内部进行额外检查，以跳过替换属性的警告。
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### Same-named relationships
    on inheriting mappers no longer warn'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### 继承映射器上的同名关系不再发出警告'
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承场景中创建两个映射器时，在两者上都放置同名关系会发出警告“映射器`<name>`上的关系‘<name>’取代了继承映射器‘<name>`上的相同关系；这可能在刷新期间引起依赖问题”。示例如下：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告可以追溯到2007年的0.4系列，基于一个自那时完全重写的工作单元代码版本。目前，没有关于在基类和子类上放置同名关系的已知问题，因此警告被取消。但是，请注意，由于警告，这种用例在现实世界中可能不常见。虽然为这种用例添加了基本的测试支持，但可能会发现这种模式的一些新问题。
- en: New in version 1.1.0b3.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.0b3版本中新增。
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### Hybrid properties
    and methods now propagate the docstring as well as .info'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### 混合属性和方法现在也传播文档字符串以及`.info`'
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，混合方法或属性将反映原始文档字符串中存在的`__doc__`值：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`A.some_name.__doc__`的上述值被尊重：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了实现这一点，混合属性的机制必然变得更加复杂。以前，混合的类级访问器将是一个简单的传递，也就是说，这个测试将成功：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着变化，`A.some_name`返回的表达式被包装在自己的`QueryableAttribute`包装器内：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了大量测试，以确保此包装器正常工作，包括对[自定义值对象](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)配方等复杂方案的测试，但我们将继续查看用户是否出现其他退化情况。
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，`hybrid_property.info`集合现在也从混合描述符本身传播，而不是从底层表达式传播。也就是说，访问`A.some_name.info`现在返回与`inspect(A).all_orm_descriptors['some_name'].info`相同的字典：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个`.info`字典**独立**于混合描述符可能直接代理的映射属性的字典；这是从1.0开始的行为变化。包装器仍将代理镜像属性的其他有用属性，如`QueryableAttribute.property`和`QueryableAttribute.class_`。
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge resolves
    pending conflicts the same as persistent'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge解决挂起冲突与持久性相同'
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge")方法现在将跟踪图中给定对象的标识，以维护主键的唯一性，然后再发出INSERT。当遇到相同标识的重复对象时，非主键属性会被**覆盖**，因为对象被遇到时是基本上是非确定性的。这种行为与持久对象的行为相匹配，也就是通过主键已经位于数据库中的对象，因此这种行为更具内部一致性。'
- en: 'Given:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将一个`User`对象与三个新的`Order`对象合并，每个对象都指向一个不同的`Address`对象，但是它们都具有相同的主键。[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge")的当前行为是在标识映射中查找这个`Address`对象，并将其用作目标。如果对象存在，意味着数据库已经有一个带有主键“1”的`Address`行，我们可以看到`Address`的`email_address`字段将在这种情况下被覆盖三次，分别为a，b和最后是c。
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果主键“1”对应的`Address`行不存在，[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge")将创建三个单独的`Address`实例，然后在INSERT时会出现主键冲突。新行为是，这些`Address`对象的拟议主键被跟踪在一个单独的字典中，以便我们将三个拟议的`Address`对象的状态合并到一个要插入的`Address`对象上。
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始情况下发出某种警告，表明在单个合并树中存在冲突数据可能更好，但是对于持久情况，多年来非确定性合并值一直是行为方式；现在对于挂起情况也是如此。警告存在冲突值的功能仍然对于两种情况都是可行的，但是会增加相当大的性能开销，因为在合并过程中每个列值都必须进行比较。
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### Fix involving many-to-one
    object moves with user-initiated foreign key manipulations'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### 修复涉及用户发起的外键操作的多对一对象移动'
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 已修复了涉及用另一个对象替换多对一引用机制的 bug。在属性操作期间，先前引用的对象位置现在使用数据库提交的外键值，而不是当前外键值。修复的主要效果是，当进行多对一更改时，即使在手动将外键属性移动到新值之前，也会更准确地触发向集合的
    backref 事件。假设类 `Parent` 和 `SomeClass` 的映射，其中 `SomeClass.parent` 指向 `Parent`，`Parent.items`
    指向 `SomeClass` 对象的集合：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们创建了一个待处理对象 `some_object`，将其外键指向 `Parent`，*然后*我们实际设置了关系。在修复错误之前，backref
    不会被触发：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的修复是，当我们试图定位 `some_object.parent` 的先前值时，我们忽略了手动设置的父 id，并寻找数据库提交的值。在这种情况下，它是
    None，因为对象是待处理的，所以事件系统将 `some_object.parent` 记录为净变化：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不鼓励操作由关系管理的外键属性，但对于这种用例有有限的支持。为了允许加载继续进行，经常会使用 [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") 和 `RelationshipProperty.load_on_pending`
    功能，这些功能会导致基于内存中未持久化的外键值发出延迟加载的关系。无论是否使用这些功能，这种行为改进现在都会显而易见。
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### Improvements to the
    Query.correlate method with polymorphic entities'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### 改进了具有多态实体的 Query.correlate
    方法'
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的 SQLAlchemy 版本中，许多形式的“多态”查询生成的 SQL 比以前更“扁平化”，不再无条件地将多个表的 JOIN 捆绑到子查询中。为了适应这一点，[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") 方法现在从这样的多态可选择中提取各个表，并确保所有表都是子查询的“correlate”
    的一部分。假设映射文档中的 `Person/Manager/Engineer->Company` 设置，使用 with_polymorphic：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The above query now produces:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询现在产生：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复之前，对 `correlate(Person)` 的调用会错误地尝试将 `Person`、`Engineer` 和 `Manager` 的连接作为单个单元进行关联，因此
    `Person` 不会被关联：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对多态映射使用相关子查询仍然存在一些未完善的地方。例如，如果`Person`被多态链接到所谓的“具体多态联合”查询，上述子查询可能无法正确引用这个子查询。在所有情况下，完全引用“多态”实体的一种方法是首先从中创建一个[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造保证了“多态可选择性”被包裹在子查询中。通过在相关子查询中明确引用它，多态形式被正确使用。'
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### Stringify of Query
    will consult the Session for the correct dialect'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### 查询的字符串化将向会话查询正确的方言'
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象调用`str()`将向[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")查询正确的“绑定”，以便渲染将传递给数据库的 SQL。特别是，这允许引用特定于方言的 SQL 构造的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")可呈现，假设[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")与适当的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。以前，只有当映射关联到目标[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")才会生效。
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")或[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")都没有与任何绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联，则将使用“默认”方言回退生成 SQL 字符串。
- en: See also
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[“友好”地将核心 SQL 构造字符串化而不使用方言](#change-3631)'
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### Joined eager loading
    where the same entity is present multiple times in one row'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### 在一行中多次出现相同实体的连接急加载'
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 已经修复了一个情况，即使实体已经从不包括属性的不同“路径”上的行加载，也将通过连接的急加载加载属性。这是一个难以复现的深层用例，但一般思路如下：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The above query emits SQL like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询生成的 SQL 如下：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`c`表被两次选择；一次在`A.b.c -> c_alias_1`的上下文中，另一次在`A.c -> c_alias_2`的上下文中。此外，我们可以看到对于单个行，`C`标识很可能对于`c_alias_1`和`c_alias_2`是**相同**的，这意味着一行中的两组列导致只向标识映射中添加一个新对象。
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询选项仅要求在`c_alias_1`的上下文中加载属性`C.d`，而不是`c_alias_2`。因此，我们在标识映射中得到的最终`C`对象是否具有加载的`C.d`属性取决于映射如何遍历，虽然不是完全随机，但基本上是不确定的。修复方法是，即使对于它们都引用相同标识的单个行，`c_alias_1`的加载程序在`c_alias_2`的加载程序之后处理，`C.d`元素仍将被加载。以前，加载程序不寻求修改已通过不同路径加载的实体的加载。首先到达实体的加载程序一直是不确定的，因此在某些情况下，此修复可能可检测为行为变化，而在其他情况下则不会。
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 修复包括对“多个路径指向一个实体”的两个变体的测试，并且修复应该希望覆盖此类其他情况。
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的MutableList和MutableSet辅助程序已添加到变异跟踪扩展中
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 新的辅助类[`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList")和[`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet")已添加到[Mutation Tracking](../orm/extensions/mutable.html)扩展中，以补充现有的[`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict")辅助程序。
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
- en: '### New “raise” / “raise_on_sql” loader strategies'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的“raise” / “raise_on_sql”加载策略'
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止在加载一系列对象后发生不必要的延迟加载，可以将新的“lazy='raise'”和“lazy='raise_on_sql'”策略及相应的加载程序选项[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")应用于关系属性，当尝试读取非急切加载的属性时，将导致引发`InvalidRequestError`。这两个变体测试任何类型的延迟加载，包括那些只会返回None或从标识映射中检索的延迟加载：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or a lazy load only where SQL would be emitted:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者仅在需要发出 SQL 时进行延迟加载：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by is
    deprecated'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by 已弃用'
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自 SQLAlchemy 最早版本的旧参数是 ORM 的原始设计的一部分，其中包括[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象作为公共查询结构。这个角色早已被[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象取代，我们使用[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")来指示结果的排序方式，这种方式对于任何组合的 SELECT 语句、实体和 SQL 表达式都能保持一致。有许多情况下[`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper")不能按预期工作（或者预期的结果不清楚），比如当查询组合成联合时；这些情况不受支持。
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
- en: New Features and Improvements - Core
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - 核心
- en: '### Engines now invalidate connections, run error handlers for BaseException'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '### Engines 现在作废连接，运行 BaseException 的错误处理程序'
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能在版本 1.1 中新增：这个变化是在 1.1 系列最终版本之前的一个晚期添加，不包含在 1.1 beta 版本中。
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python `BaseException` 类位于`Exception`之下，但是是系统级异常的可识别基类，例如`KeyboardInterrupt`，`SystemExit`，以及特别是`GreenletExit`异常，这些异常被
    eventlet 和 gevent 使用。这个异常类现在被[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的异常处理例程拦截，并包括由`ConnectionEvents.handle_error()`事件处理。在系统级异常不是`Exception`的子类的情况下，默认情况下[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")现在被**作废**，因为假定操作被中断，连接可能处于不可用状态。这个变化主要针对 MySQL
    驱动程序，但是这个变化适用于所有的 DBAPIs。
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在作废时，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")使用的即时 DBAPI 连接被释放，如果在异常抛出后仍在使用[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，则在下次使用时将使用新的 DBAPI 连接进行后续操作；然而，正在进行的任何事务的状态将丢失，并且必须在重新使用之前调用适当的`.rollback()`方法（如果适用）。
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别这种变化，当这些异常发生在连接执行工作过程中时，很容易展示一个 pymysql 或 mysqlclient / MySQL-Python 连接进入损坏状态；连接将被返回到连接池，随后的使用将失败，甚至在返回到池之前会导致调用`.rollback()`的上下文管理器中出现次要故障。这里的行为预期将减少
    MySQL 错误“commands out of sync”的发生率，以及在 MySQL 驱动程序未能正确报告`cursor.description`时可能发生的`ResourceClosedError`，在绿色线程条件下运行时，绿色线程被终止，或者处理`KeyboardInterrupt`异常而不完全退出程序时。
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与通常的自动失效功能不同，它不假设后端数据库本身已关闭或重新启动；它不像通常的 DBAPI 断开连接异常那样重新生成整个连接池。
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化应该对所有用户都是一个净改进，除了**任何当前拦截``KeyboardInterrupt``或``GreenletExit``并希望在同一事务中继续工作的应用程序**。对于不受`KeyboardInterrupt`影响的其他
    DBAPIs，如 psycopg2，这样的操作在理论上是可能的。对于这些 DBAPIs，以下解决方法将禁用特定异常的连接被回收：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE Support for INSERT,
    UPDATE, DELETE'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE 支持 INSERT、UPDATE、DELETE'
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛请求的功能之一是支持与 INSERT、UPDATE、DELETE 一起工作的通用表达式（CTE），现在已经实现。INSERT/UPDATE/DELETE
    可以从位于 SQL 顶部的 WITH 子句中提取，也可以作为更大语句上下文中的 CTE 自身使用。
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个变化的一部分，包含 CTE 的 SELECT 插入现在将在整个语句的顶部呈现 CTE，而不像在 1.0 版本中嵌套在 SELECT 语句中。
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个将 UPDATE、INSERT 和 SELECT 全部放在一个语句中的示例：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### Support for RANGE
    and ROWS specification within window functions'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### 支持窗口函数中的 RANGE 和
    ROWS 规范'
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") 和 [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") 参数允许为窗口函数使用 RANGE 和 ROWS 表达式：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") 和 [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") 被指定为 2 元组，表示特定范围的负值和正值，“CURRENT ROW” 为 0，UNBOUNDED
    为 None。'
- en: See also
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用窗口函数](../tutorial/data_select.html#tutorial-window-functions)'
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### Support for the SQL
    LATERAL keyword'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### 支持 SQL `LATERAL`
    关键字'
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`LATERAL` 关键字目前仅被 PostgreSQL 9.3 及更高版本支持，然而由于它是 SQL 标准的一部分，对于该关键字的支持已经添加到 Core
    中。[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") 的实现采用了特殊逻辑，不仅仅是渲染 `LATERAL` 关键字，还允许对从相同
    `FROM` 子句派生的表进行相关性，例如，侧向相关性：'
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[侧向相关性](../tutorial/data_select.html#tutorial-lateral-correlation)'
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### Support for TABLESAMPLE'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### 支持 TABLESAMPLE'
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 标准的 TABLESAMPLE 可以使用 [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") 方法呈现，该方法返回一个类似于别名的 [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") 构造。
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `people` 有一个列 `people_id`，上述语句将渲染为：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### The `.autoincrement`
    directive is no longer implicitly enabled for a composite primary key column'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### 对于复合主键列，`.autoincrement`
    指令不再隐式启用'
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 一直具有为单列整数主键启用后端数据库的“自增”功能的便利特性；通过“自增”，我们指的是数据库列将包括数据库提供的任何 DDL 指令，以指示自增整数标识符，例如
    PostgreSQL 上的 SERIAL 关键字或 MySQL 上的 AUTO_INCREMENT，并且方言还将通过使用适合该后端的技术从执行 [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") 构造中接收这些生成的值。
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 发生变化的是，这个特性不再自动为*复合*主键打开；以前，表定义如下：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 只有因为它是主键列列表中的第一个列，才会对`'x'`列应用“autoincrement”语义。为了禁用这个，必须关闭所有列上的`autoincrement`：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的行为，组合主键将不具有自动增量语义，除非列明确标记为`autoincrement=True`：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预见一些潜在的不兼容情况，[`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert")构造将对没有设置自动增量的复合主键列上缺失的主键值执行更彻底的检查；给定这样一个表：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个表没有提供值的INSERT将产生此警告：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从服务器端默认值或触发器等不太常见的东西接收主键值的列，可以使用[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")指示存在值生成器：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于极少情况下实际上意图在其列中存储NULL的复合主键（仅在SQLite和MySQL上支持），请使用`nullable=True`指定列：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，`autoincrement`标志可以设置为True，对于具有客户端或服务器端默认值的列。这通常不会对INSERT期间列的行为产生太大影响。
- en: See also
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[不再为具有AUTO_INCREMENT的复合主键生成隐式KEY](#change-mysql-3216)'
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### Support for IS DISTINCT
    FROM and IS NOT DISTINCT FROM'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### 支持IS DISTINCT FROM和IS
    NOT DISTINCT FROM'
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 新操作符[`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from")和[`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from")允许进行IS DISTINCT
    FROM和IS NOT DISTINCT FROM sql操作：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Handling is provided for NULL, True and False:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 处理NULL、True和False：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLite，它没有这个运算符，“IS” / “IS NOT”会被渲染，在SQLite上可以处理NULL，不像其他后端：
- en: '[PRE52]  ### Core and ORM support for FULL OUTER JOIN'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE52]  ### 核心和ORM对FULL OUTER JOIN的支持'
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 新标志[`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin")，在核心和ORM级别可用，指示编译器在通常渲染`LEFT
    OUTER JOIN`的地方渲染`FULL OUTER JOIN`：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The flag also works at the ORM level:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志也适用于ORM级别：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet column
    matching enhancements; positional column setup for textual SQL'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet列匹配增强；文本SQL的位置列设置'
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 系列中对`ResultProxy`系统进行了一系列改进，作为[#918](https://www.sqlalchemy.org/trac/ticket/918)的一部分，重新组织内部以按位置匹配游标绑定的结果列与表/ORM元数据，而不是通过匹配名称，用于包含有关要返回的结果行的完整信息的编译
    SQL 构造。这样可以大大节省 Python 的开销，并且在将 ORM 和 Core SQL 表达式链接到结果行时具有更高的准确性。在 1.1 版本中，这种重新组织在内部进一步进行了，并且还通过最近添加的[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法对纯文本 SQL 构造进行了提供。
- en: TextAsFrom.columns() now works positionally
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TextAsFrom.columns() 现在按位置工作
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法在 0.9 版本中添加，接受基于列的参数按位置传递；在
    1.1 版本中，当所有列按位置传递时，这些列与最终结果集的关联也按位置执行。这里的关键优势在于，现在可以将文本 SQL 与 ORM 级别的结果集链接起来，而无需处理模糊或重复的列名，也无需将标签方案与
    ORM 级别的标签方案匹配。现在只需要在文本 SQL 中的列顺序与传递给[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")的列参数中保持一致即可：'
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的文本 SQL 中，“id”列出现了三次，这通常会产生歧义。使用新功能，我们可以直接应用来自`User`和`Address`类的映射列，甚至可以将`Address.user_id`列链接到文本
    SQL 中的`users.id`列，以供娱乐，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将按需接收正确可定位的行，包括用于急加载。
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变与将列按照与文本语句中不同顺序传递给方法的代码**不兼容**。希望由于这个方法一直以来都是按照文本 SQL 语句中列的顺序传递的，即使内部没有检查这一点，因此影响会很小。这个方法只是在
    0.9 版本中添加的，可能还没有广泛使用。关于如何处理使用该方法的应用程序的行为变化的详细说明，请参见[TextClause.columns() will
    match columns positionally, not by name, when passed positionally](#behavior-change-3501)。
- en: See also
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用文本列表达式进行选择](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当传递位置参数时，[TextClause.columns()](#behavior-change-3501) 将按位置匹配列，而不是按名称匹配 - 向后兼容性说明
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对于 Core/ORM SQL 构造，基于位置的匹配比基于名称的匹配更可靠
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化的另一个方面是，对于已编译的 SQL 构造，匹配列的规则也已经修改为更完全地依赖于“位置”匹配。考虑到如下语句：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The above statement will compile to:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将被编译为：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版中，执行上述语句时，将会根据位置匹配与其原始编译构造相匹配，但是由于语句中包含了重复的 `'user_id'` 标签，因此“模糊列”规则仍然会介入并阻止从行中提取列。从
    1.1 版开始，“模糊列”规则不会影响从列构造到 SQL 列的精确匹配，这是 ORM 用于获取列的方法：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Much less likely to get an “ambiguous column” error message
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 很少出现“模糊列”错误消息
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，错误消息 `Ambiguous column name '<name>' in result set! try 'use_labels'
    option on select statement.` 的措辞已经被减弱；因为当使用 ORM 或 Core 编译的 SQL 构造时，这个消息现在应该非常少见，它仅仅陈述了
    `Ambiguous column name '<name>' in result set column descriptions`，并且只有在从实际上是模糊的字符串名称检索结果列时才会出现，例如在上面的示例中
    `row['user_id']`。它现在还引用了来自呈现的 SQL 语句本身的实际模糊名称，而不是指示用于获取的构造本地的键或名称。
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### Support for Python’s
    native `enum` type and compatible forms'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### 支持 Python 的原生 `enum`
    类型和兼容形式'
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    类型现在可以使用任何符合 PEP-435 的枚举类型构造。在使用此模式时，输入值和返回值是实际的枚举对象，而不是字符串/整数等值：'
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Enum.enums` collection is now a list instead of a tuple
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Enum.enums` 集合现在是列表，而不是元组'
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    的更改的一部分，元素的 `Enum.enums` 集合现在是列表，而不是元组。这是因为列表适用于长度可变的同类项序列，其中元素的位置不具有语义上的重要性。
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### Negative integer
    indexes accommodated by Core result rows'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### 核心结果行支持负整数索引'
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy` 对象现在支持单个负整数索引，就像普通的 Python 序列一样，在纯 Python 和 C 扩展版本中都可以使用。之前，负值只能在切片中起作用：'
- en: '[PRE60]  ### The `Enum` type now does in-Python validation of values'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 【PRE60】### 现在，`Enum` 类型在 Python 中对值进行验证
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应Python本地枚举对象，以及诸如在ARRAY中使用非本地ENUM类型且CHECK约束不可行等边缘情况，当使用[`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum")标志时，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型现在在Python中对输入值进行验证（1.1.0b2）：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下关闭此验证，因为已经确定了用户不希望进行此类验证的用例（例如字符串比较）。对于非字符串类型，它在所有情况下都必须进行。当从数据库返回值时，结果处理方面也无条件地进行检查。
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证是在使用非本地枚举类型时创建CHECK约束的现有行为之外的。现在可以使用新的[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum")标志来禁用此CHECK约束的创建。
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### Non-native boolean
    integer values coerced to zero/one/None in all cases'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### 非本地布尔整数值在所有情况下被强制为零/一/None'
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")数据类型将Python布尔值强制转换为整数值，用于没有本地布尔类型的后端，例如SQLite和MySQL。在这些后端上，通常设置一个CHECK约束，以确保数据库中的值实际上是这两个值之一。但是，MySQL忽略CHECK约束，该约束是可选的，并且现有数据库可能没有此约束。已修复[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型，使得已经是整数值的Python端值被强制转换为零或一，而不仅仅是传递原样；此外，结果的int-to-boolean处理器的C扩展版本现在使用与Python布尔值解释相同的值，而不是断言确切的一或零值。这现在与纯Python的int-to-boolean处理器一致，并且对数据库中已有的数据更宽容。None/NULL的值与以前一样保留为None/NULL。'
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变产生了一个意外的副作用，即非整数值（如字符串）的解释也发生了变化，例如字符串值`"0"`将被解释为“true”，但仅在没有本地布尔数据类型的后端上
    - 在像PostgreSQL这样的“本地布尔”后端上，字符串值`"0"`将直接传递给驱动程序，并被解释为“false”。这是一个之前实现中没有发生的不一致性。值得注意的是，将字符串或任何其他值传递给[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型之外的`None`、`True`、`False`、`1`、`0`是**不受支持**的，版本1.2将对此场景引发错误（或可能���是发出警告，待定）。另请参阅[#4102](https://www.sqlalchemy.org/trac/ticket/4102)。
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### Large parameter and
    row values are now truncated in logging and exception displays'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### 在日志和异常显示中现在截断了大参数和行值'
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句中作为绑定参数的大值，以及结果行中存在的大值，现在在日志记录、异常报告以及`repr()`中的显示时将被截断：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### JSON support added
    to Core'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### 核心中添加了JSON支持'
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MySQL现在除了PostgreSQL JSON数据类型外还有JSON数据类型，核心现在获得了一个[`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")数据类型，这是这两种数据类型的基础。使用这种类型允许以一种跨越PostgreSQL和MySQL的方式访问“getitem”操作符和“getpath”操作符。
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据类型还对NULL值的处理以及表达式处理进行了一系列改进。
- en: See also
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[MySQL JSON Support](#change-3547)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL JSON 支持](#change-3547)'
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#### JSON “null” 在ORM操作中被插入，当不存在时被省略'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")类型及其派生类型[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")有一个标志[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")，当设置为True时，表示Python值`None`应该转换为SQL NULL而不是JSON NULL值。该标志默认为False，这意味着Python值`None`应该导致JSON
    NULL值。'
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，此逻辑将失败，并已得到纠正：
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当列还包含默认值或 server_default 值时，对于期望持久化 JSON “null”的映射属性上的正值 `None` 仍将触发列级默认值，替换
    `None` 值：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当列*没有*包含默认值或 server_default 值时，对于配置了 none_as_null=False 的 JSON 列的缺失值仍然会呈现为
    JSON NULL，而不是回退到不插入任何值，与所有其他数据类型的行为不一致：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为变更，对于依赖此功能将缺失值默认为 JSON null 的应用程序来说是不兼容的。这实际上确立了**缺失值与存在的 None 值有所区别**。详细信息请参见[如果未提供值且未设置默认值，则
    JSON 列将不插入 JSON NULL](#behavior-change-3514)。
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当使用 [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 方法时，`None` 在所有情况下都会被忽略：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型现在实现了 [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") 标志，指示此处不应忽略 `None`；它会根据 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 的值自动配置。感谢 [#3061](https://www.sqlalchemy.org/trac/ticket/3061)，我们可以区分用户主动设置的值
    `None` 与根本未设置的情况。'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### 新增 JSON.NULL 常量'
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序始终可以在值级别上完全控制一个 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")、[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 列是否接收 SQL NULL 或 JSON `"null"` 值，已添加了常量
    [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")，它与
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    结合使用可以完全确定 SQL NULL 和 JSON `"null"` 之间的差别，无论 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 设置为什么：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其后代类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Array support added
    to Core; new ANY and ALL operators'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Core 添加了数组支持；新的 ANY
    和 ALL 运算符'
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对 PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型的增强描述在 [Correct SQL Types are Established
    from Indexed Access of ARRAY, JSON, HSTORE](#change-3503) 中，[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型的基类本身已经移动到 Core 中，成为一个新的类 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")。
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 SQL 标准的一部分，还有一些面向数组的函数，如 `array_agg()` 和 `unnest()`。为了支持这些构造，不仅仅是 PostgreSQL，未来可能还包括其他支持数组的后端，如
    DB2，大部分 SQL 表达式的数组逻辑现在都在 Core 中。然而，[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 类型仍**只在 PostgreSQL 上工作**，但它可以直接使用，支持特殊的数组用例，如索引访问，以及支持
    ANY 和 ALL：
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持ANY和ALL，[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")类型保留了与PostgreSQL类型相同的[`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any")和[`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all")方法，但也将这些操作导出为新的独立运算符函数[`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_")和[`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_")。这两个函数以更传统的SQL方式工作，允许右侧表达式形式，如下：
- en: '[PRE68]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL特定的运算符“contains”、“contained_by”和“overlaps”，应继续直接使用[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")类型，该类型还提供了[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")类型的所有功能。
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")和[`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_")运算符在核心级别是开放式的，但是后端数据库对它们的解释是有限的。在PostgreSQL后端，这两个运算符**只接受数组值**。而在MySQL后端，它们**只接受子查询值**。在MySQL中，可以使用如下表达式：'
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### New Function features,
    “WITHIN GROUP”, array_agg and set aggregate functions'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### 新功能特性，“WITHIN GROUP”，array_agg和set聚合函数'
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")类型，我们还可以实现一个预定义函数，用于返回数组的`array_agg()`
    SQL函数，现在可以使用[`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg")：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by")，为聚合ORDER BY添加了一个PostgreSQL元素：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Producing:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: PG方言本身还提供了一个[`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg")包装器，以确保[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")类型：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，像`percentile_cont()`、`percentile_disc()`、`rank()`、`dense_rank()`等需要通过`WITHIN
    GROUP (ORDER BY <expr>)`进行排序的函数现在可以通过[`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group")修饰符来使用：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The above statement would produce SQL similar to:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将生成类似于的 SQL：
- en: '[PRE75]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为这些函数提供了正确返回类型的占位符，包括[`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont")、[`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc")、[`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank")、[`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank")、[`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode")、[`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank")和[`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist")。
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator 现在自动与 Enum、Boolean、“schema” 类型配合工作'
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    类型包括诸如[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")和[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")等类型，除了对应数据库类型外，还会生成一个 CHECK 约束或在 PostgreSQL ENUM 的情况下生成一个新的
    CREATE TYPE 语句，现在会自动与[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")配方一起工作。以前，对于[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")的[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")必须像这样：'
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")现在会传播这些额外的事件，因此可以像处理其他类型一样处理：'
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### Multi-Tenancy Schema
    Translation for Table objects'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### 多租户模式下的表对象翻译'
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持一个应用程序使用相同一组[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象在许多模式中的用例，比如每个用户一个模式，添加了一个新的执行选项[`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options")。 使用这个映射，一组[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象可以在每个连接基础上指向任何一组模式，而不是它们被分配到的[`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table")。 翻译适用于DDL和SQL生成，以及ORM。
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`User`类被分配了模式“per_user”：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求上，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以设置为每次引用不同的模式：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[模式名称的翻译](../core/connections.html#schema-translating)'
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### “Friendly” stringification
    of Core SQL constructs without a dialect'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### Core SQL构造的“友好”字符串化，没有方言'
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对核心SQL构造调用`str()`现在会在更多情况下生成一个字符串，支持各种通常不在默认SQL中出现的SQL构造，如RETURNING、数组索引和非标准数据类型：
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数现在调用一个完全独立的方言/编译器，专门用于纯字符串打印，没有设置特定方言，因此当出现更多“只是显示给��一个字符串！”的情况时，可以将这些情况添加到这个方言/编译器中，而不会影响真实方言上的行为。'
- en: See also
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询的字符串化将查询会话以获取正确的方言](#change-3081)'
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### The type_coerce function
    is now a persistent SQL element'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### type_coerce函数现在是一个持久的SQL元素'
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 函数以前会返回一个[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 或 [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") 类型的对象，取决于输入。 这样做的一个影响是，在使用表达式转换的情况下，比如将元素从[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 转换为[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")，这对于ORM级别的延迟加载至关重要，类型强制转换信息将不会被使用，因为它已经丢失了。'
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这种行为，该函数现在返回一个围绕给定表达式的持久[`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce")容器，该表达式本身保持不变；这个构造显式地由SQL编译器评估。这允许内部表达式的强制转换保持不变，无论语句如何修改，包括如果包含的元素被替换为不同的元素，这在ORM的延迟加载功能中很常见。
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 用于说明效果的测试用例利用了异构主连接条件与自定义类型和延迟加载。给定一个应用CAST作为“绑定表达式”的自定义类型：
- en: '[PRE81]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个映射，我们将一个表上的字符串“id”列与另一个表上的整数“id”列进行等价：
- en: '[PRE82]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")表达式中，我们使用[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")来处理通过延迟加载传递的绑定参数作为整数，因为我们已经知道这些将来自我们的`StringAsInt`类型，该类型在Python中将值保持为整数。然后我们使用[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，以便作为SQL表达式，VARCHAR“id”列将被CAST为整数，用于常规非转换连接，如[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")或[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")。也就是说，`.pets`的joinedload看起来像：
- en: '[PRE83]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接的ON子句中没有CAST，像PostgreSQL这样的强类型数据库将拒绝隐式比较整数并失败。
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pets`的延迟加载情况依赖于在加载时用一个绑定参数替换`Person.id`列，该参数接收一个Python加载的值。这种替换特别是我们[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数意图会丢失的地方。在更改之前，这种延迟加载如下所示：'
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到我们在Python中的值`5`首先被转换为VARCHAR，然后再转换回SQL中的INTEGER；这是一个双重转换，虽然有效，但并不是我们要求的。
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更改，[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数在列被替换为绑定参数后仍保持一个包装器，现在查询看起来像：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部 CAST，即我们的主要连接，仍然生效，但是在 `StringAsInt` 自定义类型的一部分中不必要的 CAST 被 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 函数按预期移除了。
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
- en: Key Behavioral Changes - ORM
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键行为变化 - ORM
- en: '### JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '### JSON 列如果没有提供值且没有默认值，则不会插入 JSON NULL'
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514) 中所述，[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 如果完全缺少值，则不会渲染 JSON “null” 值。为了防止 SQL NULL，应设置默认值。给定以下映射：
- en: '[PRE86]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The following flush operation will fail with an integrity error:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下刷新操作将失败并引发完整性错误：
- en: '[PRE87]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列的默认值应为 JSON NULL，则在列上设置它：
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Or, ensure the value is present on the object:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，确保对象上存在该值：
- en: '[PRE89]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为默认值设置 `None` 与完全省略它是相同的；[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 标志不影响传递给 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 或 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的 `None` 的值：
- en: '[PRE90]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: See also
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### Columns no longer added redundantly with DISTINCT
    + ORDER BY'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### DISTINCT + ORDER BY 不再冗余添加列'
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如下查询现在仅增广缺少于 SELECT 列表中的列，而不会出现重复：
- en: '[PRE91]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Produces:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE92]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Previously, it would produce:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，它会产生：
- en: '[PRE93]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，不必要地添加了 `user.name` 列。结果不会受影响，因为额外的列无论如何都不包含在结果中，但是这些列是不必要的。
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，当通过向 [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct") 传递表达式来使用 PostgreSQL DISTINCT ON 格式时，上述“添加列”逻辑将被完全禁用。
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询被捆绑成子查询以进行连接式快速加载时，“增广列列表”规则必须更加积极，以便仍然可以满足 ORDER BY，因此这种情况保持不变。
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### Same-named @validates
    decorators will now raise an exception'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### 同名的 @validates 装饰器现在会引发异常'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")
    装饰器仅打算对于特定属性名称的类创建一次。现在创建多于一个会引发错误，而以前则会静默选择最后定义的验证器：'
- en: '[PRE94]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Will raise:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发：
- en: '[PRE95]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
- en: Key Behavioral Changes - Core
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - 核心
- en: '### TextClause.columns() will match columns positionally, not by name, when
    passed positionally'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当通过位置传递时，TextClause.columns()将按位置匹配列，而不是按名称匹配'
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法的新行为，该方法本身是最近在0.9系列中添加的，是，当列通过位置传递而没有任何额外的关键字参数时，它们与最终结果集列位置相关联，而不再根据名称。希望这种变化的影响很小，因为该方法始终以文档形式说明传递的列与文本SQL语句的顺序相同，这似乎是直观的，即使内部部件不检查这一点也是如此。'
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法通过位置传递[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象的应用程序必须确保这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的位置与文本SQL中这些列声明的位置相匹配。
- en: 'E.g., code like the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像下面这样的代码：
- en: '[PRE96]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将不再按预期工作；给定列的顺序现在很重要：
- en: '[PRE97]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Possibly more likely, a statement that worked like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更有可能的是，一个像这样工作的声明：
- en: '[PRE98]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在稍微有点冒险，因为“*”规范通常会按照它们在表中出现的顺序传递列。如果表的结构因模式更改而更改，则此排序可能不再相同。因此，在使用[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")时，建议在文本SQL中明确列出所需的列，尽管在文本SQL中不再需要担心列名本身。
- en: See also
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)  ### String server_default now literal quoted'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[ResultSet列匹配增强；文本SQL的位置列设置](#change-3501)  ### 字符串server_default现在是文字引用'
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 作为普通Python字符串传递给[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")的服务器默认值现在通过字面引用系统传递：
- en: '[PRE99]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，引用将直接呈现。对于具有此类用例并且正在解决此问题的应用程序，此更改可能是向后不兼容的。
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### A UNION or similar
    of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes the embedded selects'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### 一个带有LIMIT/OFFSET/ORDER
    BY的UNION或类似的SELECT现在将嵌入的SELECT括起来'
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题，像其他问题一样，长期以来受SQLite功能不足的驱动，现在已经增强，可以在所有支持的后端上工作。我们指的是一个查询，它是SELECT语句的UNION，这些语句本身包含行限制或排序功能，其中包括LIMIT、OFFSET和/或ORDER
    BY：
- en: '[PRE100]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询需要在每个子选择中使用括号以正确分组子结果。在SQLAlchemy Core中生成上述语句的方式如下：
- en: '[PRE101]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，上述结构不会为内部的SELECT语句生成括号，导致查询在所有后端上都失败。
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在SQLite上**仍将失败**；此外，包含ORDER BY但不包含LIMIT/SELECT的格式在Oracle上**仍将失败**。这不是一个不兼容的更改，因为没有括号的查询也会失败；通过修复，查询至少在所有其他数据库上能够正常工作。
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，为了生成一个在SQLite上也能正常工作并且在所有情况下在Oracle上也能正常工作的有限SELECT语句的UNION，子查询必须是一个ALIAS的SELECT：
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方法适用于所有SQLAlchemy版本。在ORM中，它看起来像：
- en: '[PRE103]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为与SQLAlchemy 0.9中引入的“连接重写”行为有许多相似之处，详见[许多JOIN和LEFT OUTER JOIN表达式将不再被包装在（SELECT
    * FROM ..）AS ANON_1中](migration_09.html#feature-joins-09)；然而，在这种情况下，我们选择不添加新的重写行为来适应SQLite的情况。现有的重写行为已经非常复杂，而带有括号的SELECT语句的UNION情况比该功能的“右嵌套连接”用例要少得多。
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - PostgreSQL
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持INSERT..ON CONFLICT（DO UPDATE | DO NOTHING）'
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 从PostgreSQL 9.5版本开始添加到`INSERT`的`ON CONFLICT`子句现在可以使用`sqlalchemy.dialects.postgresql.dml.insert()`的PostgreSQL特定版本的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")对象来支持。这个[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")子类添加了两个新方法`Insert.on_conflict_do_update()`和`Insert.on_conflict_do_nothing()`，它们实现了PostgreSQL
    9.5在这个领域支持的完整语法：
- en: '[PRE104]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The above will render:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 上述将呈现：
- en: '[PRE105]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: See also
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON CONFLICT（Upsert）](../dialects/postgresql.html#postgresql-insert-on-conflict)'
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY and JSON types
    now correctly specify “unhashable”'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY和JSON类型现在正确指定为“不可哈希”'
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如[关于“不可哈希”类型的更改，影响ORM行的去重](#change-3499)所述，当查询的选定实体混合了完整的ORM实体和列表达式时，ORM依赖于能够为列值生成哈希函数。现在，对于PG的所有“数据结构”类型，包括[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")和[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")，`hashable=False`标志已正确设置。[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")和[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")类型已经包含了这个标志。对于[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")，这取决于[`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY")标志，但是现在不再需要设置此标志以使数组值出现在组合的ORM行中。
- en: See also
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于“不可哈希”类型的更改，影响ORM行的去重](#change-3499)'
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[从ARRAY、JSON、HSTORE的索引访问中建立正确的SQL类型](#change-3503)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Correct SQL Types
    are Established from Indexed Access of ARRAY, JSON, HSTORE'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### 从ARRAY、JSON、HSTORE的索引访问中建立正确的SQL类型'
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")三者，通过索引访问返回的表达式的SQL类型，例如`col[someindex]`，在所有情况下都应正确。
- en: 'This includes:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括：
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于通过索引访问[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")的SQL类型将考虑配置的维度数量。具有三个维度的[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")将返回一个维度少一的[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")类型的SQL表达式。给定类型为`ARRAY(Integer, dimensions=3)`的列，我们现在可以执行以下表达式：
- en: '[PRE106]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，对于`col[5]`的索引访问会返回一个类型为[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")的表达式，在这种情况下，除非我们使用[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")或者[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")，否则我们无法对剩余的维度进行索引访问。
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")和[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")类型现在反映了PostgreSQL本身对于索引访问的处理方式。这意味着对于[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")或[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")类型的所有索引访问都会返回一个表达式，该表达式本身*始终*是[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")或[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")本身，除非使用了[`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext")修饰符。这意味着无论JSON结构的索引访问最终是引用字符串、列表、数字还是其他JSON结构，PostgreSQL始终将其视为JSON本身，除非明确以不同方式进行转换。就像[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")类型一样，现在可以直接生成具有多层索引访问的JSON表达式：'
- en: '[PRE107]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")进行索引访问返回的“文本”类型，以及通过与[`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext")修饰符结合使用对[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")进行索引访问返回的“文本”类型现在是可配置的；在这两种情况下，默认为[`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")，但可以使用[`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON")或[`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE")参数将其设置为用户定义的类型。
- en: See also
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON cast()操作现在需要显式调用.astext](#change-3503-cast)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    The JSON cast() operation now requires `.astext` is called explicitly'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    JSON cast()操作现在需要显式调用`.astext`'
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[从ARRAY、JSON、HSTORE的索引访问中正确建立SQL类型的更改](#change-3503)的一部分，[`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast")操作符在[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")上不再隐式调用[`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext")修饰符；PostgreSQL的JSON/JSONB类型支持彼此之间的CAST操作而无需“astext”方面。
- en: 'This means that in most cases, an application that was doing this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在大多数情况下，执行此操作的应用程序：
- en: '[PRE108]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Will now need to change to this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要更改为：
- en: '[PRE109]  ### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE109]  ### 带有ENUM的ARRAY现在将发出ENUM的CREATE TYPE'
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下的表定义现在将按预期发出CREATE TYPE：
- en: '[PRE110]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'emits:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 发出：
- en: '[PRE111]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
- en: Check constraints now reflect
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查约束现在反映
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在支持反射 CHECK 约束，方法包括 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 和 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 反射中的 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合。
- en: “Plain” and “Materialized” views can be inspected separately
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可以单独检查“普通”和“物化”视图
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数 `PGInspector.get_view_names.include` 允许指定应返回哪些视图子类型：
- en: '[PRE112]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
- en: Added tablespace option to Index
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Index 中添加了 tablespace 选项
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    对象现在接受参数 `postgresql_tablespace`，以指定 TABLESPACE，与 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象接受的方式相同。'
- en: See also
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引存储参数](../dialects/postgresql.html#postgresql-index-storage)'
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
- en: Support for PyGreSQL
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 PyGreSQL 的支持
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI 现在得到支持。'
- en: The “postgres” module is removed
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “postgres” 模块已被移除
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 长期弃用的 `sqlalchemy.dialects.postgres` 模块已被移除；多年来一直发出警告，项目应该调用 `sqlalchemy.dialects.postgresql`。形式为
    `postgres://` 的 Engine URLs 仍将继续运行。
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE 的支持
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数 [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") 和 [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") 在 Core 和 ORM 中都对
    PostgreSQL 后端的 “SELECT…FOR UPDATE” 或 “SELECT…FOR SHARE” 查询应用修改：
- en: 'SELECT FOR NO KEY UPDATE:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择 FOR NO KEY UPDATE:'
- en: '[PRE113]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择 FOR UPDATE SKIP LOCKED:'
- en: '[PRE114]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'SELECT FOR KEY SHARE:'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择 FOR KEY SHARE:'
- en: '[PRE115]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - MySQL
- en: '### MySQL JSON Support'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL JSON 支持'
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言新增了一个类型 [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")，支持 MySQL 5.7 新增的 JSON 类型。该类型既提供 JSON 的持久性，又在内部使用
    `JSON_EXTRACT` 函数进行基本的索引访问。通过使用 MySQL 和 PostgreSQL 共同支持的 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，可以实现跨 MySQL 和 PostgreSQL 的可索引 JSON 列。
- en: See also
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[JSON support added to Core](#change-3619)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[Core添加了JSON支持](#change-3619)'
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### Added support for
    AUTOCOMMIT “isolation level”'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### 添加了对AUTOCOMMIT“隔离级别”的支持'
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言现在接受值“AUTOCOMMIT”用于[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")和[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")参数：
- en: '[PRE116]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别利用了大多数MySQL DBAPI提供的各种“自动提交”属性。
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### No more generation
    of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### 不再为带有AUTO_INCREMENT的复合主键生成隐式KEY'
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言的行为是，如果InnoDB表上的复合主键中有AUTO_INCREMENT的列不是第一列，则如下所示：
- en: '[PRE117]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'DDL such as the following would be generated:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成DDL，例如以下内容：
- en: '[PRE118]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面带有自动生成名称的“KEY”；这是很多年前为了解决AUTO_INCREMENT在InnoDB上否则会失败而添加到方言中的一个变更。
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法已被移除，并替换为更好的系统，即在主键中**首先**声明AUTO_INCREMENT列：
- en: '[PRE119]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式控制主键列的顺序，请显式使用[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")构造（1.1.0b2）（以及根据MySQL需要为自动递增列添加KEY），例如：
- en: '[PRE120]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变更[不再为复合主键列隐式启用.autoincrement指令](#change-3216)外，现在更容易指定具有或不具有自动递增的复合主键；[`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column")现在默认为值`"auto"`，不再需要`autoincrement=False`指令：
- en: '[PRE121]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQLite
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQLite版本3.7.16取消了右嵌套连接的解决方法'
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9版本中，由[Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped
    in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)引入的功能经历了大量努力，以支持在SQLite上重写连接以始终使用子查询以实现“right-nested-join”效果，因为SQLite多年来一直不支持此语法。具有讽刺意味的是，在该迁移说明中指出的SQLite版本3.7.15.2实际上是*最后*一个实际存在此限制的SQLite版本！下一个发布版本是3.7.16，支持右嵌套连接被悄悄地添加。在1.1中，对特定SQLite版本和源提交进行了识别，其中进行了此更改（SQLite的更改日志将其称为“增强查询优化器以利用传递连接约束”，而没有链接到任何问题编号、更改编号或进一步解释），并且当DBAPI报告版本3.7.16或更高版本生效时，此更改中存在的解决方法现在已经被取消。
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### Dotted column names
    workaround lifted for SQLite version 3.10.0'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### SQLite版本3.10.0解决了带点列名的问题'
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言长期以来一直存在一个问题的解决方法，即数据库驱动程序在某些SQL结果集中未报告正确的列名，特别是在使用UNION时。解决方法详见[Dotted
    Column Names](../dialects/sqlite.html#sqlite-dotted-column-names)，并要求SQLAlchemy假定任何带有点的列名实际上是通过这种错误行为传递的`tablename.columnname`组合，可以通过`sqlite_raw_colnames`执行选项关闭此选项。
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLite版本3.10.0开始，UNION和其他查询中的bug已经修复；就像[Right-nested join workaround lifted
    for SQLite version 3.7.16](#change-3634)中描述的更改一样，SQLite的更改日志只将其神秘地标识为“为sqlite3_module.xBestIndex方法添加了colUsed字段”，但是SQLAlchemy对这些带点列名的翻译在此版本中不再需要，因此当检测到版本3.10.0或更高版本时会关闭。
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，截至1.0系列，SQLAlchemy的`ResultProxy`在为Core和ORM SQL构造交付结果时，对结果集中的列名依赖要少得多，因此这个问题的重要性在任何情况下已经降低了。
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### Improved Support
    for Remote Schemas'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### 改进对远程模式的支持'
- en: 'The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.  ###
    Reflection of the name of PRIMARY KEY constraints'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言现在实现了[`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names")方法，并且对从远程模式创建和反射的表和索引提供了改进的支持，在SQLite中，远程模式是通过`ATTACH`语句分配名称的数据库；以前，``CREATE
    INDEX`` DDL对于绑定模式的表无法正常工作，并且[`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")方法现在将在结果中指示给定的模式。不支持跨模式外键。###
    主键约束名称的反射
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite后端现在利用SQLite的“sqlite_master”视图来从原始DDL中提取表的主键约束名称，就像最近的SQLAlchemy版本中为外键约束所实现的方式一样。
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
- en: Check constraints now reflect
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在反映检查约束
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言现在支持在方法[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")以及在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")反射中的[`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints")集合中反映检查约束。
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ON DELETE和ON UPDATE外键短语现在反映
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")现在将包括SQLite方言上的外键约束的ON DELETE和ON UPDATE短语，并且作为[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的一部分反映的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象也将指示这些短语。'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQL Server
- en: '### Added transaction isolation level support for SQL Server'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为SQL Server添加了事务隔离级别支持'
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SQL Server方言都支持通过[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")和[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")参数设置事务隔离级别。支持四个标准级别以及`SNAPSHOT`：
- en: '[PRE122]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: See also
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[事务隔离级别](../dialects/mssql.html#mssql-isolation-level)'
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### String / varlength
    types no longer represent “max” explicitly on reflection'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### 字符串/可变长度类型在反射中不再明确表示“max”'
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当反射类型如[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")、[`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")等包含长度时，在SQL Server下，一个“无长度”的类型会将“length”参数复制为值`"max"`：
- en: '[PRE123]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型中的“length”参数预期只能是整数值或None；None表示无界长度，SQL Server方言将其解释为“max”。因此，修复这些长度为None，以便类型对象在非SQL
    Server上下文中工作：
- en: '[PRE124]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一直依赖于将“length”值直接与字符串“max”进行比较的应用程序应该考虑将`None`的值视为相同。
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在主键上“非聚集”以允许在其他地方进行聚集
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")、[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")上现在默认为`None`的`mssql_clustered`标志，可以设置为False，这将特别为主键渲染NONCLUSTERED关键字，允许使用不同的索引作为“clustered”。'
- en: See also
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[聚集索引支持](../dialects/mssql.html#mssql-indexes)'
- en: '### The legacy_schema_aliasing flag is now set to False'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '### legacy_schema_aliasing标志现在设置为False'
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.0.5引入了`legacy_schema_aliasing`标志到MSSQL方言，允许关闭所谓的“传统模式”别名。这种别名试图将模式限定的表转换为别名；给定一个表如下：
- en: '[PRE125]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 传统行为模式将尝试将模式限定的表名转换为别名：
- en: '[PRE126]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种别名已被证明是不必要的，在许多情况下会产生不正确的SQL。
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.1中，`legacy_schema_aliasing`标志现在默认为False，禁用这种行为模式，允许MSSQL方言正常处理模式限定的表。对于可能依赖于此行为的应用程序，请将标志设置回True。
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - Oracle
- en: Support for SKIP LOCKED
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持SKIP LOCKED
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数[`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")在Core和ORM中都会为“SELECT…FOR
    UPDATE”或“SELECT.. FOR SHARE”查询生成“SKIP LOCKED”后缀。
- en: Introduction
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.1, and also documents
    changes which affect users migrating their applications from the 1.0 series of
    SQLAlchemy to 1.1.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy 1.1版本的新功能，并记录了影响从SQLAlchemy 1.0系列迁移应用程序的用户的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看关于行为变更的部分，可能会有影响向后不兼容的行为变更。
- en: Platform / Installer Changes
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台/安装程序更改
- en: Setuptools is now required for install
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在安装需要Setuptools
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，SQLAlchemy的`setup.py`文件一直支持安装Setuptools和不安装Setuptools两种操作方式；支持一种使用纯Distutils的“回退”模式。由于现在几乎听不到没有安装Setuptools的Python环境了，并且为了更充分地支持Setuptools的功能集，特别是为了支持py.test与其集成以及诸如“extras”之类的功能，`setup.py`现在完全依赖于Setuptools。
- en: See also
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Installation Guide](../intro.html#installation)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装指南](../intro.html#installation)'
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
- en: Enabling / Disabling C Extension builds is only via environment variable
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅通过环境变量启用/禁用C扩展构建
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在安装过程中会构建C扩展，只要可能。要禁用C扩展构建，从SQLAlchemy 0.8.6 / 0.9.4版本开始，可以使用`DISABLE_SQLALCHEMY_CEXT`环境变量。以前使用`--without-cextensions`参数的方法已被移除，因为它依赖于setuptools的已弃用功能。
- en: See also
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建Cython扩展](../intro.html#c-extensions)'
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
- en: Setuptools is now required for install
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在安装需要Setuptools
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，SQLAlchemy的`setup.py`文件一直支持安装Setuptools和不安装Setuptools两种操作方式；支持一种使用纯Distutils的“回退”模式。由于现在几乎听不到没有安装Setuptools的Python环境了，并且为了更充分地支持Setuptools的功能集，特别是为了支持py.test与其集成以及诸如“extras”之类的功能，`setup.py`现在完全依赖于Setuptools。
- en: See also
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Installation Guide](../intro.html#installation)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装指南](../intro.html#installation)'
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
- en: Enabling / Disabling C Extension builds is only via environment variable
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅通过环境变量启用/禁用C扩展构建
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在安装过程中会构建C扩展，只要可能。要禁用C扩展构建，从SQLAlchemy 0.8.6 / 0.9.4版本开始，可以使用`DISABLE_SQLALCHEMY_CEXT`环境变量。以前使用`--without-cextensions`参数的方法已被移除，因为它依赖于setuptools的已弃用功能。
- en: See also
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建Cython扩展](../intro.html#c-extensions)'
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
- en: New Features and Improvements - ORM
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: '### New Session lifecycle events'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的会话生命周期事件'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")长期以来一直支持事件，允许在对象状态变化方面进行一定程度的跟踪，包括[`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach")、[`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach")和[`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")。会话文档还在[快速介绍对象状态](../orm/session_state_management.html#session-object-states)中记录了主要对象状态。然而，从未有过一种系统来跟踪对象特别是当它们通过这些转换时。此外，“已删除”对象的状态历来是模糊的，因为对象在“持久”状态和“分离”状态之间的行为之间存在某种程度的不确定性。'
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理这个领域并使会话状态转换的领域完全透明，已经添加了一系列新事件，旨在涵盖对象可能在状态之间转换的每种可能方式，并且“已删除”状态还在会话对象状态领域内被赋予了自己的官方状态名称。
- en: New State Transition Events
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新状态转换事件
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以拦截对象的所有状态之间的转换，例如[持久](../glossary.html#term-persistent)、[挂起](../glossary.html#term-pending)等，以便覆盖特定转换的会话级事件。对象进入[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")、离开[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")以及甚至在使用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")回滚事务时发生的所有转换都明确地出现在[`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents
    "sqlalchemy.orm.SessionEvents")的接口中。
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有**十个新事件**。这些事件的摘要在新编写的文档部分[对象生命周期事件](../orm/session_events.html#session-lifecycle-events)中。
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新对象状态“已删除”已添加，已删除对象不再是“持久”状态。
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中对象的[持久](../glossary.html#term-persistent)状态一直被记录为具有有效的数据库标识的对象；然而，在刷新中被删除的对象的情况下，它们一直处于一个灰色地带，它们并不真正“分离”于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为它们仍然可以在回滚中恢复，但也不真正“持久”，因为它们的数据库标识已被删除，并且它们不在标识映射中。
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种灰色地带的新事件，引入了一个新的对象状态[deleted](../glossary.html#term-deleted)。这种状态存在于“持久”和“分离”状态之间。通过[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")标记为删除的对象将保持在“持久”状态，直到进行刷新；在那时，它将从标识映射中移除，转移到“已删除”状态，并调用[`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted")钩子。如果[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的事务被回滚，对象将恢复为持久状态；将调用[`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent")转换。否则，如果[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的事务被提交，将调用[`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached")转换。
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent")访问器**不再返回True**，表示对象处于新的“已删除”状态；相反，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")访问器已经增强，可可靠地报告这种新状态。当对象被分离时，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")返回False，而[`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached")访问器返回True。要确定对象是在当前事务中还是在以前的事务中被删除，请使用[`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted")访问器。
- en: Strong Identity Map is Deprecated
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强身份映射已被弃用
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 新系列过渡事件的灵感之一是实现对物体的无泄漏跟踪，使其在身份映射中进出时可以保持“强引用”，从而反映物体在此映射中的移动。有了这种新功能，不再需要[`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session")参数和相应的`StrongIdentityMap`对象。这个选项在SQLAlchemy中已经存在多年，因为“强引用”行为曾经是唯一可用的行为，许多应用程序都假定了这种行为。长期以来，强引用跟踪对象不应该是[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的固有工作，而应该是应用程序级别的构造，根据应用程序的需要构建；新的事件模型甚至允许复制强身份映射的确切行为。查看[Session
    Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)以获取一个新的示例，说明如何替换强身份映射。
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### New init_scalar()
    event intercepts default values at ORM level'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### 新的init_scalar()事件在ORM级别拦截默认值'
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次访问未设置的属性时，ORM会为非持久对象产生一个值为`None`的值：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在对象持久化之前，这种在 Python 中的值与 Core 生成的默认值对应的用例也是存在的。为了适应这种用例，新增了一个名为 [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") 的事件。在 [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    中的新示例 `active_column_defaults.py` 展示了一个样例用法，所以效果可以是：
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### Changes regarding
    “unhashable” types, impacts deduping of ORM rows'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### 关于“不可哈希”类型的更改，影响
    ORM 行的去重'
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象具有“去重”返回的行的良好行为，其中包含至少一个 ORM 映射实体（例如，一个完全映射的对象，而不是单个列值）。这主要是为了确保实体的处理与标识映射一起顺利进行，包括在连接的急加载中通常表示的重复实体，以及当用于过滤附加列时使用连接时。'
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这种去重依赖于行中元素的可哈希性。随着 PostgreSQL 的特殊类型（如 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 和 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")）的引入，行内类型不可哈希并在这里遇到问题的经历比以前更加普遍。
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，自 SQLAlchemy 版本 0.8 起，已经在被标记为“不可哈希”的数据类型上包含了一个标志，然而这个标志在内置类型上并不一致。如 [ARRAY
    和 JSON 类型现在正确指定“不可哈希”](#change-3499-postgresql) 中描述的那样，现在这个标志已经一致地设置在了所有 PostgreSQL
    的“结构”类型上。
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    类型上也设置了“不可哈希”标志，因为 [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") 用于指代任何未知类型的表达式。'
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数使用 `func` 的地方都应用了 [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")，因为在大多数情况下，`func` 实际上并不了解给定的函数名称，**使用 func() 通常会禁用行去重，除非显式类型化**。以下示例说明了将
    `func.substr()` 应用于字符串表达式和将 `func.date()` 应用于日期时间表达式；两个示例都将由于连接的急加载而返回重复行，除非应用了显式类型化：
- en: '[PRE129]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The above examples, in order to retain deduping, should be specified as:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留去重，上述示例应指定为：
- en: '[PRE130]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对所谓的“不可哈希”类型的处理与之前的版本略有不同；在内部，我们使用`id()`函数从这些结构中获取“哈希值”，就像我们对待任何普通的映射对象一样。这取代了之前将计数器应用于对象的方法。
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Specific checks added
    for passing mapped classes, instances as SQL literals'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### 添加了针对传递映射类、实例作为SQL字面值的特定检查'
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型系统对在上下文中传递SQLAlchemy“可检查”对象进行了特定检查，否则它们将被处理为字面值。任何SQLAlchemy内置对象，只要作为SQL值传递是合法的（不是已经是[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")实例），都包括一个方法`__clause_element__()`，为该对象提供有效的SQL表达式。对于不提供此方法的SQLAlchemy对象，如映射类、映射器和映射实例，会发出更具信息性的错误消息，而不是允许DBAPI接收对象并稍后失败。下面举例说明，其中基于字符串的属性`User.name`与`User()`的完整实例进行比较，而不是与字符串值进行比较：
- en: '[PRE131]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行`User.name == some_user`比较时，异常现在是立即的。以前，类似上面的比较会产生一个SQL表达式，只有在解析为DBAPI执行调用时才会失败；映射的`User`对象最终会成为一个被DBAPI拒绝的绑定参数。
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，表达式失败是因为`User.name`是基于字符串的（例如基于列的）属性。此更改*不会*影响将多对一关系属性与对象进行比较的常规情况，这是另外处理的：
- en: '[PRE132]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### New Indexable ORM
    extension'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### 新的可索引ORM扩展'
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html)扩展是混合属性功能的一个扩展，允许构建引用“可索引”数据类型（如数组或JSON字段）特定元素的属性：'
- en: '[PRE133]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`name`属性将读取/写入JSON列`data`中的字段`"name"`，在初始化为空字典后：
- en: '[PRE134]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展还在修改属性时触发更改事件，因此无需使用[`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict")来跟踪此更改。
- en: See also
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Indexable](../orm/extensions/indexable.html)  ### New options allowing explicit
    persistence of NULL over a default'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html)  ### 新选项允许显式持久化NULL覆盖默认值'
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 与PostgreSQL中添加的新JSON-NULL支持相关，作为[JSON “null”在ORM操作中如预期般插入，当不存在时被省略](#change-3514)的一部分，基础[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类现在支持一个方法[`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none")，允许将属性上的`None`值的正值集合持久化为NULL，而不是从INSERT语句中省略列，这会导致使用列级默认值。这允许对现有对象级技术分配[`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null")到属性的映射器级配置。
- en: See also
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[强制在具有默认值的列上使用NULL](../orm/persistence_techniques.html#session-forcing-null)'
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### Further Fixes to
    single-table inheritance querying'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### 进一步修复了单表继承查询问题'
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 继续从1.0的[在使用from_self()，count()时更改单表继承条件](migration_10.html#migration-3177)，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")在查询针对子查询表达式时，如exists时，不应再不当地添加“单一继承”条件：
- en: '[PRE135]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Produces:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE136]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的IN子句是合适的，以限制为FooWidget对象，但以前IN子句也会在子查询的外部生成第二次。
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### Improved Session
    state when a SAVEPOINT is cancelled by the database'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### 当数据库取消SAVEPOINT时改进的Session状态'
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的一个常见情况是，在事务中发生死锁时，SAVEPOINT被取消。[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")已经修改以更优雅地处理这种失败模式，使得外部的非SAVEPOINT事务仍然可用：
- en: '[PRE137]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是[#2696](https://www.sqlalchemy.org/trac/ticket/2696)的延续，在Python 2上运行时我们发出警告，即使SAVEPOINT异常优先。在Python
    3上，异常被链接，因此两个失败都会被单独报告。
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### Erroneous “new instance
    X conflicts with persistent instance Y” flush errors fixed'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### 修复了错误的“新实例X与持久实例Y冲突”刷新错误'
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法负责移除在数据库中被 INSERT 的对象，例如在那个现在被回滚的事务中从挂起状态移动到持久状态的对象。进行此状态更改的对象在一个弱引用集合中被跟踪，如果一个对象从该集合中被垃圾回收，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将不再关心它（否则对于在事务中插入许多新对象的操作不会扩展）。然而，如果应用程序在回滚发生之前重新加载了同一被垃圾回收的行，那么会出现问题；如果对这个对象的强引用仍然存在于下一个事务中，那么这个对象未被插入且应该被移除的事实将丢失，并且
    flush 将错误地引发错误：'
- en: '[PRE138]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The above program would raise:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序将引发：
- en: '[PRE139]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于当引发上述异常时，工作单元正在处理原始对象，假设它是一个活动行，而实际上该对象已过期，并在测试中显示它已经消失。修复现在测试这个条件，因此在 SQL
    日志中我们看到：
- en: '[PRE140]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，工作单元现在会为我们即将报告为冲突的行执行一个 SELECT，看到它不存在，然后正常进行。这个 SELECT 的开销只在我们本来会在任何情况下错误地引发异常时才会发生。
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### passive_deletes feature
    for joined-inheritance mappings'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### 被动删除功能用于连接继承映射'
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个连接表继承映射现在可以允许 DELETE 操作继续进行，作为 [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 的结果，它只为基本表发出 DELETE，而不是子类表，允许配置的 ON DELETE CASCADE
    为配置的外键发生。这是使用 `mapper.passive_deletes` 选项配置的：
- en: '[PRE141]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，`mapper.passive_deletes` 选项在基本映射器上进行配置；它对所有具有该选项设置的映射器的非基本映射器生效。对于类型为
    `B` 的对象的 DELETE 不再需要检索 `b_table_id` 的主键值（如果未加载），也不需要为表本身发出 DELETE 语句：
- en: '[PRE142]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Will emit SQL as:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的 SQL 如下：
- en: '[PRE143]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，目标数据库必须支持启用 ON DELETE CASCADE 的外键支持。
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### Same-named backrefs
    will not raise an error when applied to concrete inheritance subclasses'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### 同名反向引用应用于具体继承子类时不会引发错误'
- en: 'The following mapping has always been possible without issue:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 以下映射一直是可以无问题地进行的：
- en: '[PRE144]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，即使类 `A` 和类 `A1` 有一个名为 `b` 的关系，也不会出现冲突警告或错误，因为类 `A1` 被标记为“具体”。
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果关系配置反过来，将会出现错误：
- en: '[PRE145]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 修复增强了反向引用功能，以便不会发出错误，同时在映射器逻辑中增加了额外的检查，以避免替换属性时发出警告。
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### Same-named relationships
    on inheriting mappers no longer warn'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### 不再对继承映射器上的同名关系发出警告'
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承场景中创建两个映射器时，在两者上都放置同名关系会发出警告“关系'<name>'在映射器<name>上取代了继承映射器'<name>'上的相同关系；这可能会在刷新期间引起依赖问题”。示例如下：
- en: '[PRE146]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告可以追溯到2007年的0.4系列，基于一个自那时起已完全重写的工作单元代码版本。目前，没有关于在基类和派生类上放置同名关系的已知问题，因此警告已被取消。但是，请注意，由于警告，这种用例在现实世界中可能并不常见。虽然为这种用例添加了基本的测试支持，但可能会发现这种模式的一些新问题。
- en: New in version 1.1.0b3.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1.0b3版本中新增。
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### Hybrid properties
    and methods now propagate the docstring as well as .info'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### 混合属性和方法现在也传播文档字符串以及.info'
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，混合方法或属性将反映原始文档字符串中存在的`__doc__`值：
- en: '[PRE147]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`A.some_name.__doc__`的上述值将被尊重：
- en: '[PRE148]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了实现这一点，混合属性的机制必然变得更加复杂。以前，混合的类级访问器将是一个简单的传递，也就是说，这个测试将成功：
- en: '[PRE149]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化，`A.some_name`返回的表达式现在被包装在自己的`QueryableAttribute`包装器中：
- en: '[PRE150]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个包装器能够正确工作，进行了大量测试，包括对[自定义值对象](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)配方的复杂方案，但我们将继续关注用户是否出现其他退化情况。
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，`hybrid_property.info`集合现在也从混合描述符本身传播，而不是从底层表达式传播。也就是说，访问`A.some_name.info`现在返回与`inspect(A).all_orm_descriptors['some_name'].info`相同的字典：
- en: '[PRE151]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个`.info`字典**独立**于可能直接代理的混合描述符的映射属性的字典；这是从1.0版本开始的行为变化。包装器仍将代理镜像属性的其他有用属性，如`QueryableAttribute.property`和`QueryableAttribute.class_`。
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge resolves
    pending conflicts the same as persistent'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge解决挂起冲突与持久性相同'
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge")
    方法现在将跟踪给定图中对象的标识，以在发出 INSERT 之前维护主键唯一性。当遇到相同标识的重复对象时，非主键属性会在遇到对象时被**覆盖**，这本质上是非确定性的。这种行为与持久对象的处理方式相匹配，即通过主键已经位于数据库中的对象，因此这种行为更具内部一致性。'
- en: 'Given:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：
- en: '[PRE152]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将一个`User`对象与三个新的`Order`对象合并，每个对象都引用一个不同的`Address`对象，但每个对象都具有相同的主键。[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") 的当前行为是在标识映射中查找这个`Address`对象，并将其用作目标。如果对象存在，意味着数据库已经有了主键为“1”的`Address`行，我们可以看到`Address`的`email_address`字段将被覆盖三次，在这种情况下分别为a、b和最后是c。
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果主键为“1”的`Address`行不存在，[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") 将创建三个单独的`Address`实例，然后在插入时会出现主键冲突。新的行为是，这些`Address`对象的拟议主键被跟踪在一个单独的字典中，以便我们将三个拟议的`Address`对象的状态合并到一个要插入的`Address`对象上。
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始情况发出某种警告，表明单个合并树中存在冲突数据可能更好，然而多年来，对于持久情况，值的非确定性合并一直是行为；现在对于挂起情况也是如此。警告存在冲突值的功能仍然对于两种情况都是可行的，但会增加相当大的性能开销，因为在合并过程中每个列值都必须进行比较。
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### Fix involving many-to-one
    object moves with user-initiated foreign key manipulations'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### 修复涉及用户发起的外键操作的多对一对象移动问题'
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 已修复涉及用另一个对象替换对对象的多对一引用的机制的错误。在属性操作期间，先前引用的对象的位置现在使用数据库提交的外键值，而不是当前的外键值。修复的主要效果是，当进行多对一更改时，向集合发出的反向引用事件将更准确地触发，即使在之前手动将外键属性移动到新值。假设类`Parent`和`SomeClass`的映射，其中`SomeClass.parent`指向`Parent`，`Parent.items`指向`SomeClass`对象的集合：
- en: '[PRE153]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个待处理的对象`some_object`，将其外键指向`Parent`以引用它，*然后*我们实际设置了关系。在修复错误之前，反向引用不会触发：
- en: '[PRE154]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的修复是，当我们试图定位`some_object.parent`的先前值时，我们忽略了先前手动设置的父id，并寻找数据库提交的值。在这种情况下，它是None，因为对象是待处理的，所以事件系统将`some_object.parent`记录为净变化：
- en: '[PRE155]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不鼓励操纵由关系管理的外键属性，但对于这种用例有有限的支持。为了允许加载继续进行，经常会使用[`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading")和`RelationshipProperty.load_on_pending`功能，这些功能会导致基于内存中未持久化的外键值发出惰性加载的关系。无论是否使用这些功能，这种行为改进现在将变得明显。
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### Improvements to the
    Query.correlate method with polymorphic entities'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### 改进Query.correlate方法与多态实体'
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的SQLAlchemy版本中，许多形式的“多态”查询生成的SQL比以前更“扁平化”，其中多个表的JOIN不再无条件地捆绑到子查询中。为了适应这一变化，[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate")方法现在从这样的多态可选择中提取各个表，并确保它们都是子查询的“相关”部分。假设映射文档中的`Person/Manager/Engineer->Company`设置，使用`with_polymorphic`：
- en: '[PRE156]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The above query now produces:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询现在会产生：
- en: '[PRE157]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复之前，调用`correlate(Person)`会无意中尝试将`Person`、`Engineer`和`Manager`的连接作为一个单元进行关联，因此`Person`不会被关联：
- en: '[PRE158]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 对多态映射使用相关子查询仍然存在一些未完善的地方。例如，如果`Person`多态链接到所谓的“具体多态联合”查询，上述子查询可能无法正确引用此子查询。在所有情况下，完全引用“多态”实体的一种方法是首先从中创建一个[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象：
- en: '[PRE159]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造保证了“多态可选择”被包装在一个子查询中。通过在相关子查询中明确引用它，多态形式将被正确使用。'
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### Stringify of Query
    will consult the Session for the correct dialect'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### 查询的字符串化将查询会话以获取正确的方言'
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象调用`str()`将会查询[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")以获取正确的“绑定”，以便渲染将传递给数据库的SQL。特别是，这允许引用特定于方言的SQL构造的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")可呈现，假设[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")与适当的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。以前，只有当映射关联到的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")本身绑定到目标[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")时，此行为才会生效。
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")或[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")都未与任何绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联，则将使用“默认”方言回退来生成SQL字符串。
- en: See also
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[“友好”的核心SQL构造的字符串化，没有方言](#change-3631)'
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### Joined eager loading
    where the same entity is present multiple times in one row'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### 在一行中多次出现相同实体的连接贪婪加载'
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 已修复了一个情况，即通过连接贪婪加载加载属性，即使实体已经从不包括属性的不同“路径”上的行加载。这是一个难以复现的深层用例，但一般思路如下：
- en: '[PRE160]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The above query emits SQL like this:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询生成的SQL如下：
- en: '[PRE161]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`c`表被选择两次；一次在`A.b.c -> c_alias_1`的上下文中，另一次在`A.c -> c_alias_2`的上下文中。此外，我们可以看到对于单行来说，`C`标识很可能对于`c_alias_1`和`c_alias_2`是**相同**的，这意味着一行中的两组列导致只有一个新对象被添加到标识映射中。
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询选项仅要求在`c_alias_1`的上下文中加载属性`C.d`，而不是`c_alias_2`。因此，我们在标识映射中得到的最终`C`对象是否加载了`C.d`属性取决于映射如何遍历，尽管不完全是随机的，但基本上是不确定的。修复的方法是，即使对于它们都引用相同标识的单行，`c_alias_1`的加载器在`c_alias_2`的加载器之后处理，`C.d`元素仍将被加载。以前，加载器不寻求修改已通过不同路径加载的实体的加载。首先到达实体的加载器一直是不确定的，因此在某些情况下，这种修复可能会被检测为行为变化，而在其他情况下则不会。
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 修复包括两种“多条路径到一个实体”的情况的测试，并且修复应该希望覆盖所有其他类似情况。
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  id: totrans-687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新增了对变异跟踪扩展的MutableList和MutableSet助手
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 新的助手类[`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList")和[`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet")已添加到[变异跟踪](../orm/extensions/mutable.html)扩展中，以补充现有的[`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict")助手。
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
- en: '### New “raise” / “raise_on_sql” loader strategies'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的“raise” / “raise_on_sql”加载策略'
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止一系列对象加载后发生不必要的延迟加载，可以将新的“lazy='raise'”和“lazy='raise_on_sql'”策略以及相应的加载器选项[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")应用于关系属性，当访问非急切加载属性进行读取时，将引发`InvalidRequestError`。这两个变体测试任何类型的延迟加载，包括那些只会返回None或从标识映射中检索的延迟加载：
- en: '[PRE162]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Or a lazy load only where SQL would be emitted:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 或仅在SQL会被发出的情况下进行延迟加载：
- en: '[PRE163]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by is
    deprecated'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by已弃用'
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自SQLAlchemy最早版本的旧参数是ORM的原始设计的一部分，其中包括[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象作为一个公共查询结构。这个角色早已被[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象取代，我们使用[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")来指示结果的排序方式，这种方式对于任何组合的SELECT语句、实体和SQL表达式都能一致工作。有许多情况下[`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper")不按预期工作（或者预期的结果不清楚），比如当查询组合成联合时；这些情况不受支持。
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)  ### New Session lifecycle
    events'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)  ### 新的会话生命周期事件'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")长期以来一直支持事件，允许在某种程度上跟踪对象状态的变化，包括[`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach")、[`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach")和[`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")。会话文档还记录了主要对象状态在[对象状态快速入门](../orm/session_state_management.html#session-object-states)。然而，从来没有一种系统可以跟踪对象特别是当它们通过这些转换时。此外，“已删除”对象的状态历来是模糊的，因为对象在“持久”状态和“分离”状态之间的行为。'
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理这个领域并使会话状态转换的领域完全透明，已经添加了一系列新的事件，旨在涵盖对象可能在状态之间转换的每种可能方式，此外，“已删除”状态已在会话对象状态领域内被赋予了自己的官方状态名称。
- en: New State Transition Events
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的状态转换事件
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以拦截对象的所有状态之间的转换，比如[persistent](../glossary.html#term-persistent)、[pending](../glossary.html#term-pending)等，以便覆盖特定转换的会话级事件。对象进入[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")、离开[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，甚至在使用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")回滚事务时发生的所有转换都明确地出现在[`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents
    "sqlalchemy.orm.SessionEvents")的接口中。
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有**十个新事件**。这些事件的摘要在新编写的文档部分[对象生命周期事件](../orm/session_events.html#session-lifecycle-events)中。
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加了新的对象状态“deleted”，被删除的对象不再是“persistent”。
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的[persistent](../glossary.html#term-persistent)状态一直被记录为具有有效的数据库标识的对象；然而，在刷新时被删除的对象的情况下，它们一直处于一个灰色地带，因为它们并没有真正“分离”出[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为它们仍然可以在回滚时恢复，但又不真正“持久”，因为它们的数据库标识已被删除，而且它们不在标识映射中。
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个新事件所带来的灰色地带，引入了一个新的对象状态 [deleted](../glossary.html#term-deleted)。此状态存在于“持久”状态和“分离”状态之间。通过
    [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记为删除的对象将保持在“持久”状态，直到进行刷新为止；在那时，它将从标识映射中移除，转移到“已删除”状态，并调用 [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") 钩子。如果 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务被回滚，则对象将被恢复为持久状态；将调用 [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") 过渡。否则，如果 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务被提交，则调用 [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") 过渡。
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，[`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") 访问器**不再返回True**以表示处于新“已删除”状态的对象；相反，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 访问器已经增强，可可靠地报告此新状态。当对象被分离时，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 返回False，而 [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") 访问器则返回True。要确定对象是在当前事务中还是在以前的事务中被删除，请使用
    [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") 访问器。
- en: Strong Identity Map is Deprecated
  id: totrans-707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强身份映射已不推荐使用。
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 新系列转换事件的灵感之一是实现对象在进出标识映射时的无泄漏跟踪，以便维护一个“强引用”，反映对象在此映射中的进出情况。有了这种新的功能，就不再需要[`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session")参数和相应的`StrongIdentityMap`对象。多年来，此选项一直保留在SQLAlchemy中，因为“强引用”行为曾经是唯一可用的行为，并且许多应用程序都是根据这种行为编写的。长期以来，已建议不要将对象的强引用跟踪作为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的内在工作，并且应该作为应用程序需要时由应用程序构建的构造体；新的事件模型甚至允许复制强标识映射的确切行为。请参阅[会话引用行为](../orm/session_state_management.html#session-referencing-behavior)以了解如何替换强标识映射的新方法。
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
- en: New State Transition Events
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的状态转换事件
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象状态之间的转换，如[persistent](../glossary.html#term-persistent)、[pending](../glossary.html#term-pending)等，现在都可以通过会话级事件进行拦截，以涵盖特定转换。对象转换为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，移出[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，甚至在使用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")回滚事务时发生的所有转换，在[`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents
    "sqlalchemy.orm.SessionEvents")的接口中都明确存在。
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有**十个新事件**。这些事件的摘要在新编写的文档部分[对象生命周期事件](../orm/session_events.html#session-lifecycle-events)中。
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加了新的对象状态“已删除”，已删除的对象不再“持久”。
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的[持久](../glossary.html#term-persistent)状态一直被记录为具有有效的数据库标识符；然而，在被删除的对象的情况下，在刷新时它们一直处于一个灰色地带，它们并不真正“分离”于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为它们仍然可以在回滚中恢复，但并不真正“持久”，因为它们的数据库标识已被删除，并且不在标识映射中。
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个灰色地带，引入了一个新的对象状态[删除](../glossary.html#term-deleted)。这种状态存在于“持久”和“分离”状态之间。通过[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")标记为删除的对象将保持在“持久”状态，直到刷新进行；在那时，它将从标识映射中移除，转移到“删除”状态，并调用[`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted")钩子。如果[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的事务被回滚，对象将恢复为持久状态；调用[`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent")转换。否则，如果[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的事务被提交，将调用[`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached")转换。
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent")访问器**不再返回True**，用于处于新“已删除”状态的对象；相反，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")访问器已经增强，可可靠地报告这种新状态。当对象被分离时，[`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")返回False，而[`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached")访问器返回True。要确定对象是在当前事务中删除还是在以前的事务中删除，使用[`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted")访问器。
- en: Strong Identity Map is Deprecated
  id: totrans-717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强标识映射已弃用
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 新系列过渡事件的灵感之一是为了实现对象在进出标识映射时的无泄漏跟踪，以便维护“强引用”，反映对象在此映射中进出的情况。有了这种新能力，就不再需要[`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session")参数和相应的`StrongIdentityMap`对象。这个选项在SQLAlchemy中已经存在多年，因为“强引用”行为曾经是唯一可用的行为，许多应用程序都假定了这种行为。长期以来，强引用跟踪对象不是[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的固有工作，而是一个应用程序级别的构造，根据应用程序的需要构建；新的事件模型甚至允许复制强标识映射的确切行为。查看[Session
    Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)以获取一个新的示例，说明如何替换强标识映射。
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
- en: '### New init_scalar() event intercepts default values at ORM level'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的`init_scalar()`事件在ORM级别拦截默认值'
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次访问未设置的属性时，ORM会为非持久对象生成一个值为`None`：
- en: '[PRE164]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象持久化之前，有一个用例是使此Python值对应于Core生成的默认值。为了适应这种用例，添加了一个新的事件[`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar")。在[属性仪器化](../orm/examples.html#examples-instrumentation)中的新示例`active_column_defaults.py`说明了一个示例用法，因此效果可以是：
- en: '[PRE165]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)'
- en: '### Changes regarding “unhashable” types, impacts deduping of ORM rows'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关于“不可哈希”类型的更改，影响ORM行的去重'
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象具有“去重”返回行的良好行为，其中包含至少一个ORM映射实体（例如，完全映射对象，而不是单独的列值）。这主要是为了使实体的处理与标识映射平滑配合，包括适应通常在连接的急加载中表示的重复实体，以及在使用连接以过滤其他列的目的时。'
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 此去重依赖于行内元素的可哈希性。随着PostgreSQL引入特殊类型如[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")和[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")，行内类型不可哈希且在此遇到问题的情况比以往更普遍。
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，自SQLAlchemy版本0.8以来，已经在被标记为“不可哈希”的数据类型上包含了一个标志，然而这个标志在内置类型上并没有一致使用。正如[ARRAY和JSON类型现在正确指定“不可哈希”](#change-3499-postgresql)所述，这个标志现在已经为所有PostgreSQL的“结构”类型一致设置。
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: “不可哈希”标志也设置在[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")类型上，因为[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")用于引用任何未知类型的表达式。
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")应用于大多数`func`的用法，因为`func`实际上并不知道在大多数情况下给定的函数名称，**使用func()通常会禁用行去重，除非应用了显式类型**。以下示例说明了将`func.substr()`应用于字符串表达式，以及将`func.date()`应用于日期时间表达式；这两个示例将由于连接的急加载而返回重复行，除非应用了显式类型：
- en: '[PRE166]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The above examples, in order to retain deduping, should be specified as:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留去重，上面的示例应指定为：
- en: '[PRE167]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，对于所谓的“不可哈希”类型的处理略有不同，与之前的发布版本有些不同；在内部，我们使用 `id()` 函数从这些结构中获取“哈希值”，就像我们对任何普通映射对象一样。这取代了以前的方法，该方法对对象应用了一个计数器。
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
- en: '### Specific checks added for passing mapped classes, instances as SQL literals'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加了用于传递映射类、实例作为 SQL 文字的特定检查'
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型系统对于在否则会被处理为文字值的上下文中传递 SQLAlchemy “可检查”对象具有特定检查。任何可以作为 SQL 值传递的 SQLAlchemy
    内置对象（它不是已经是 [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") 实例的对象）都包含一个方法 `__clause_element__()`，该方法为该对象提供一个有效的
    SQL 表达式。对于不提供此功能的 SQLAlchemy 对象，例如映射类、映射器和映射实例，将发出更详细的错误消息，而不是允许 DBAPI 接收对象并稍后失败。下面举例说明了一个示例，其中将字符串属性
    `User.name` 与 `User()` 的完整实例进行比较，而不是与字符串值进行比较：
- en: '[PRE168]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当比较`User.name == some_user`时，异常立即发生。以前，类似上述的比较会产生一个 SQL 表达式，只有在解析为 DBAPI
    执行调用时才会失败；映射的 `User` 对象最终会变成一个被 DBAPI 拒绝的绑定参数。
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，表达式失败是因为 `User.name` 是基于字符串的（例如列导向）属性。此更改*不会*影响通常情况下将多对一关系属性与对象进行比较的情况，这是单独处理的：
- en: '[PRE169]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)'
- en: '### New Indexable ORM extension'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的可索引 ORM 扩展'
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html) 扩展是对混合属性功能的扩展，它允许构建引用特定元素的属性，这些元素属于“可索引”数据类型，例如数组或
    JSON 字段：'
- en: '[PRE170]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`name` 属性将从 JSON 列 `data` 读取/写入字段 `"name"`，在将其初始化为空字典之后：
- en: '[PRE171]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展还在修改属性时触发更改事件，因此无需使用 [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") 来跟踪此更改。
- en: See also
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Indexable](../orm/extensions/indexable.html)'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '[可索引](../orm/extensions/indexable.html)'
- en: '### New options allowing explicit persistence of NULL over a default'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新选项允许明确持久化 NULL 覆盖默认值'
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PostgreSQL 中新增的 JSON-NULL 支持相关，作为 [JSON “null” is inserted as expected with
    ORM operations, omitted when not present](#change-3514) 的一部分，基础 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 类现在支持一个方法 [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none")，允许将属性上的 `None` 值设置为 NULL，而不是在 INSERT
    语句中省略该列，这会导致使用列级默认值。这允许在映射器级别配置现有的对象级别将 [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") 分配给属性的技术。
- en: See also
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '[强制在具有默认值的列上使用 NULL](../orm/persistence_techniques.html#session-forcing-null)'
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)'
- en: '### Further Fixes to single-table inheritance querying'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '### 进一步修复单表继承查询'
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 继续从 1.0 的 [Change to single-table-inheritance criteria when using from_self(),
    count()](migration_10.html#migration-3177) 中，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 在查询针对子查询表达式（如 exists）时不应再不适当地添加“单一继承”条件：
- en: '[PRE172]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Produces:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE173]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的 IN 子句是适当的，以限制为 FooWidget 对象，但以前 IN 子句也会在子查询的外部生成第二次。
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)'
- en: '### Improved Session state when a SAVEPOINT is cancelled by the database'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当数据库取消 SAVEPOINT 时改进的 Session 状态'
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 的一个常见情况是在事务中发生死锁时取消 SAVEPOINT。[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 已经修改以更优雅地处理这种失败模式，使得外部的非 SAVEPOINT 事务仍然可用：
- en: '[PRE174]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是 [#2696](https://www.sqlalchemy.org/trac/ticket/2696) 的延续，在 Python 2 上运行时我们发出警告，以便可以看到原始错误，即使
    SAVEPOINT 异常优先。在 Python 3 上，异常被链接在一起，因此两个失败都会被单独报告。
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)'
- en: '### Erroneous “new instance X conflicts with persistent instance Y” flush errors
    fixed'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '### 修复了错误的“新实例 X 与持久实例 Y 冲突”刷新错误'
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法负责移除在数据库中被插入的对象，例如从挂起状态移动到持久状态的对象，在被回滚的事务中。使得这种状态改变的对象被跟踪在一个弱引用集合中，如果一个对象从该集合中被垃圾回收，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 就不再关心它（否则对于在事务中插入许多新对象的操作来说，这种方式不会扩展）。然而，如果在回滚发生之前，应用程序重新加载了同一个被垃圾回收的行；如果对这个对象仍然存在强引用到下一个事务中，那么这个对象没有被插入并且应该被移除的事实将会丢失，刷新将会错误地引发一个错误：'
- en: '[PRE175]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The above program would raise:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序将引发：
- en: '[PRE176]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 是当上述异常被引发时，工作单元正在处理原始对象，假设它是一个活动行，而实际上该对象已过期，并在测试中显示它已经消失。修复现在测试这个条件，所以在
    SQL 日志中我们看到：
- en: '[PRE177]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '上面，工作单元现在对我们即将报告���冲突的行进行 SELECT，看到它不存在，然后正常进行。这个 SELECT 的开销只在我们本来会错误地引发异常的情况下才会发生。 '
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)'
- en: '### passive_deletes feature for joined-inheritance mappings'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '### 联接继承映射的被动删除功能'
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 一个联接表继承映射现在可能允许一个 DELETE 操作继续进行，作为 [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 的结果，它只对基表发出 DELETE，而不是子类表，允许配置的 ON DELETE CASCADE
    为配置的外键发生。这是使用 `mapper.passive_deletes` 选项进行配置的：
- en: '[PRE178]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述映射中，`mapper.passive_deletes` 选项被配置在基本映射器上；它对于所有具有该选项设置的映射器的非基本映射器生效。对于类型为
    `B` 的对象的 DELETE 不再需要检索 `b_table_id` 的主键值（如果未加载），也不需要为表本身发出 DELETE 语句：
- en: '[PRE179]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Will emit SQL as:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 将会发出 SQL 语句：
- en: '[PRE180]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，目标数据库必须支持启用 ON DELETE CASCADE 的外键支持。
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)'
- en: '### Same-named backrefs will not raise an error when applied to concrete inheritance
    subclasses'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '### 同名反向引用应用于具体继承子类时不会引发错误'
- en: 'The following mapping has always been possible without issue:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 以下映射一直以来都是可能的而没有问题：
- en: '[PRE181]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，即使类 `A` 和类 `A1` 有一个名为 `b` 的关系，也不会发生冲突警告或错误，因为类 `A1` 被标记为“具体”。
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果关系被配置为另一种方式，将会发生错误：
- en: '[PRE182]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 此修复增强了 backref 特性，以便不发出错误，以及在映射器逻辑中进一步检查是否应该绕过替换属性的警告。
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)'
- en: '### Same-named relationships on inheriting mappers no longer warn'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在继承映射器上具有相同名称的关系不再发出警告'
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承情景中创建两个映射器时，在两者上放置具有相同名称的关系将发出警告：“关系'<name>'在映射器<name>上取代了继承的映射器'<name>'上的相同关系；这可能会在刷新时引起依赖问题”。示例如下：
- en: '[PRE183]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告可以追溯到 2007 年的 0.4 系列，基于一个自那时完全重写的工作单元代码版本。目前，将同名关系放置在基类和派生类上没有已知问题，因此警告已解除。然而，请注意，由于警告，这种用例在现实世界中可能并不普遍。尽管为此用例添加了基本的测试支持，但可能会发现这种模式的一些新问题。
- en: New in version 1.1.0b3.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.1.0b3 中的新功能。
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)'
- en: '### Hybrid properties and methods now propagate the docstring as well as .info'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '### 现在混合属性和方法也会传播文档字符串以及.info'
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 现在混合方法或属性将反映原始文档字符串中存在的`__doc__`值：
- en: '[PRE184]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 上述值`A.some_name.__doc__`现在被尊重：
- en: '[PRE185]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了实现这一点，混合属性的机制必然变得更加复杂。以前，混合的类级访问器是一个简单的透传，也就是说，这个测试会成功：
- en: '[PRE186]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 随着变化，由`A.some_name`返回的表达式现在被包装在其自己的`QueryableAttribute`包装器中：
- en: '[PRE187]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 已经进行了大量测试，以确保此包装器能够正常工作，包括对[自定义值对象](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)配方的复杂方案，但我们将继续关注用户是否出现其他退化。
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个改变的一部分，`hybrid_property.info`集合现在也从混合描述符本身传播，而不是从底层表达式传播。也就是说，现在访问`A.some_name.info`会返回与`inspect(A).all_orm_descriptors['some_name'].info`相同的字典：
- en: '[PRE188]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此`.info`字典**与**由混合描述符可能直接代理的映射属性的字典**不同**；这是从 1.0 开始的行为变更。包装器仍将代理来自镜像属性的其他有用属性，例如`QueryableAttribute.property`和`QueryableAttribute.class_`。
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)'
- en: '### Session.merge resolves pending conflicts the same as persistent'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '### Session.merge 解决未解决的冲突与持久性相同'
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge")方法将跟踪给定图中对象的标识，以维护主键的唯一性，然后再发出INSERT。当遇到相同标识的重复对象时，非主键属性会被**覆盖**，因为对象被遇到时，这基本上是非确定性的。这种行为与持久对象的处理方式相匹配，即通过主键已经位于数据库中的对象，因此这种行为更加内部一致。
- en: 'Given:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：
- en: '[PRE189]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将一个`User`对象与三个新的`Order`对象合并，每个对象都引用一个不同的`Address`对象，但每个对象都具有相同的主键。[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge")的当前行为是在标识映射中查找这个`Address`对象，并将其用作目标。如果对象存在，意味着数据库已经有一个主键为“1”的`Address`行，我们可以看到`Address`的`email_address`字段将在这种情况下被三次覆盖，分别为值a、b和最后的c。
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果主键“1”对应的`Address`行不存在，[`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge")将会创建三个独立的`Address`实例，然后在插入时会出现主键冲突。新的行为是，这些`Address`对象的拟议主键被跟踪在一个单独的字典中，这样我们就可以将三个拟议的`Address`对象的状态合并到一个要插入的`Address`对象上。
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始情况下发出某种警告，指出在单个合并树中存在冲突数据可能更好，然而，多年来，对于持久情况，非确定性值的合并一直是行为，现在也适用于挂起情况。警告存在冲突值的功能仍然适用于两种情况，但会增加相当大的性能开销，因为在合并过程中必须比较每个列值。
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)'
- en: '### Fix involving many-to-one object moves with user-initiated foreign key
    manipulations'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '### 修复涉及用户发起的外键操作的多对一对象移动'
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了涉及将对对象的多对一引用替换为另一个对象的机制的错误。在属性操作期间，先前引用的对象的位置现在使用数据库提交的外键值，而不是当前的外键值。修复的主要效果是，当进行多对一更改时，即使在之前手动将外键属性移动到新值之前，也将更准确地触发对集合的backref事件。假设类`Parent`和`SomeClass`的映射，其中`SomeClass.parent`指向`Parent`，而`Parent.items`指向`SomeClass`对象的集合：
- en: '[PRE190]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们创建了一个待处理的对象`some_object`，并将其外键指向`Parent`以引用它，*然后*我们实际设置了关系。在修复错误之前，backref不会被触发：
- en: '[PRE191]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修复的问题是，当我们试图定位`some_object.parent`的先前值时，我们会忽略手动设置的父id，并寻找数据库提交的值。在这种情况下，它是None，因为对象是待处理的，所以事件系统将`some_object.parent`记录为净变化：
- en: '[PRE192]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不鼓励操纵由关系管理的外键属性，但对于这种用例有一定的支持。为了允许加载继续进行，经常会使用[`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading")和`RelationshipProperty.load_on_pending`功能，这会导致基于内存中尚未持久化的外键值的惰性加载关系。无论是否使用了这些功能，这种行为改进现在都会显而易见。
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)'
- en: '### Improvements to the Query.correlate method with polymorphic entities'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进查询中的Query.correlate方法与多态实体'
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的SQLAlchemy版本中，许多形式的“多态”查询生成的SQL比以前更“扁平化”，其中多个表的JOIN不再无条件地捆绑到子查询中。为了适应这一点，[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate")方法现在会从这样一个多态可选择的地方提取各个表，并确保它们都是子查询的“相关部分”。假设从映射文档中的`Person/Manager/Engineer->Company`设置开始，使用`with_polymorphic`：
- en: '[PRE193]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The above query now produces:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询现在会产生：
- en: '[PRE194]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复之前，调用`correlate(Person)`会错误地尝试将`Person`，`Engineer`和`Manager`的连接作为一个单元进行关联，因此`Person`不会被关联：
- en: '[PRE195]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 对多态映射使用相关子查询仍然存在一些未完善的地方。例如，如果`Person`多态链接到所谓的“具体多态联合”查询，上述子查询可能无法正确引用此子查询。在所有情况下，完全引用“多态”实体的一种方法是首先从中创建一个[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象：
- en: '[PRE196]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造保证了“多态可选择性”被包裹在子查询中。通过在相关子查询中明确引用它，多态形式被正确使用。'
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)'
- en: '### Stringify of Query will consult the Session for the correct dialect'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '### 查询的字符串化将向会话咨询正确的方言'
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象调用`str()`将向[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")咨询要使用的正确“绑定”，以便呈现将传递给数据库的SQL。特别是，这允许引用特定于方言的SQL结构的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")可呈现，假设[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")与适当的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。以前，只有当映射关联到的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")本身绑定到目标[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")时，此行为才会生效。
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")或[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")都没有与任何绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联，则会使用“默认”方言回退以生成SQL字符串。
- en: See also
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '[没有方言的核心SQL结构的“友好”字符串化](#change-3631)'
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)'
- en: '### Joined eager loading where the same entity is present multiple times in
    one row'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在一行中多次出现相同实体的连接式预加载'
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 已对通过连接式预加载加载属性的情况进行了修复，即使实体已经从不包括属性的不同“路径”上的行加载。这是一个难以复现的深层用例，但一般思路如下：
- en: '[PRE197]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The above query emits SQL like this:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询生成的SQL如下：
- en: '[PRE198]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `c` 表被选中了两次；一次是在 `A.b.c -> c_alias_1` 的上下文中，另一次是在 `A.c -> c_alias_2`
    的上下文中。此外，我们可以看到对于单个行来说，`C` 的标识很可能对于 `c_alias_1` 和 `c_alias_2` 是**相同**的，这意味着一行中的两组列只会导致将一个新对象添加到标识映射中。
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询选项只要求在 `c_alias_1` 的上下文中加载属性 `C.d`，而不是在 `c_alias_2` 中加载。因此，我们在标识映射中得到的最终
    `C` 对象是否加载了 `C.d` 属性取决于映射是如何遍历的，虽然不是完全随机的，但基本上是不确定的。修复方法是，即使对于已通过不同路径加载的实体，加载器也会对
    `C.d` 元素进行加载。先到达实体的加载器一直是不确定的，所以这个修复在某些情况下可能会被检测到是一种行为上的改变，而在其他情况下则不会。
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 修复包括两种“多个路径指向一个实体”的情况的测试，并且修复希望能够涵盖此类其他场景的问题。
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新增了 MutableList 和 MutableSet 辅助类到变化跟踪扩展
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '[变化跟踪](../orm/extensions/mutable.html)扩展中新增了新的辅助类[`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList")和[`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet")，以补充现有的[`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict")助手。'
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
- en: '### New “raise” / “raise_on_sql” loader strategies'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的“raise”/“raise_on_sql”加载策略'
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止在加载一系列对象后发生不需要的惰性加载，可以将新的“lazy=’raise’”和“lazy=’raise_on_sql’”策略及相应的加载器选项[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")应用于关系属性，这将导致在读取非急切加载的属性时引发`InvalidRequestError`。两种变体测试任何类型的惰性加载，包括那些只返回
    None 或从标识映射中检索的加载：
- en: '[PRE199]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Or a lazy load only where SQL would be emitted:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 或者只有在会发出 SQL 时才进行惰性加载：
- en: '[PRE200]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)'
- en: '### Mapper.order_by is deprecated'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '### Mapper.order_by 已弃用'
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是SQLAlchemy最初版本的一部分，它是ORM的原始设计的一部分，其中包含[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象作为公共面向的查询结构。这个角色早已被[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象取代，我们在这里使用[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")来指示结果的排序方式，这种方式对于任何组合的SELECT语句、实体和SQL表达式都是一致的。有许多情况下，[`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper")不像预期那样工作（或者预期的结果不清楚），比如当查询组合成联合时；这些情况是不受支持的。
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
- en: New Features and Improvements - Core
  id: totrans-870
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性和改进 - 核心
- en: '### Engines now invalidate connections, run error handlers for BaseException'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '### Engines现在使连接无效，并为BaseException运行错误处理程序'
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.1中的新内容：此更改是在1.1系列的1.1 final版本之前的最后添加，不包含在1.1 beta版本中。
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`BaseException`类位于`Exception`之下，但是是诸如`KeyboardInterrupt`、`SystemExit`等系统级异常的可识别基类，特别是`GreenletExit`异常，该异常由eventlet和gevent使用。这个异常类现在被[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的异常处理例程拦截，并且包括由`ConnectionEvents.handle_error()`事件处理。在不是`Exception`子类的系统级异常的情况下，默认情况下，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") **被失效**，因为假定操作被中断并且连接可能处于不可用状态。这个变化主要针对MySQL驱动程序，但是这个变化适用于所有的DBAPIs。
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在失效时，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")所使用的即时DBAPI连接被处理，并且如果在异常抛出后仍然在使用[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，则在下次使用时将使用新的DBAPI连接进行后续操作；但是，正在进行中的任何事务的状态都会丢失，并且在重新使用之前，必须调用适当的`.rollback()`方法（如果适用）。
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别这种变化，很容易证明当这些异常发生在连接正在执行其工作时，一个pymysql或mysqlclient/MySQL-Python连接会进入一种已损坏的状态；然后，连接将被返回到连接池，在那里后续使用会失败，甚至在返回到池之前，在异常捕获时调用`.rollback()`的上下文管理器中会导致次要失败。这里的行为预计将减少MySQL错误“commands
    out of sync”的发生率，以及在MySQL驱动程序未能正确报告`cursor.description`时发生的`ResourceClosedError`，当在杀死greenlet的条件下运行时，在处理`KeyboardInterrupt`异常时不完全退出程序。
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为与通常的自动失效功能不同，它不假设后端数据库本身已关闭或重新启动；对于通常的DBAPI断开异常情况，它不会重新循环整个连接池。
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改应该对所有用户都是净改进，**除了当前拦截`KeyboardInterrupt`或`GreenletExit`并希望在同一事务中继续工作的任何应用程序**。这样的操作在其他不受`KeyboardInterrupt`影响的DBAPI（如psycopg2）中理论上是可能的。对于这些DBAPI，以下解决方法将禁用特定异常时的连接重新循环：
- en: '[PRE201]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE Support for INSERT,
    UPDATE, DELETE'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE支持INSERT、UPDATE、DELETE'
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛请求的功能之一是支持与INSERT、UPDATE、DELETE一起工作的通用表达式（CTE），现在已实现。INSERT/UPDATE/DELETE可以从SQL顶部陈述的WITH子句中获取，也可以作为更大语句上下文中的CTE本身使用。
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一更改的一部分，包含CTE的INSERT FROM SELECT现在将在整个语句的顶部呈现CTE，而不是像1.0版本中的SELECT语句中嵌套CTE那样。
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，它在一条语句中呈现了UPDATE、INSERT和SELECT：
- en: '[PRE202]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### Support for RANGE
    and ROWS specification within window functions'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### 对窗口函数内的RANGE和ROWS规范的支持'
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 新的[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over")和[`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over")参数允许RANGE和ROWS表达式用于窗口函数：
- en: '[PRE203]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") 和 [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") 被指定为 2 元组，表示特定范围的负值和正值，0 表示“当前行”，None 表示无限制。'
- en: See also
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用窗口函数](../tutorial/data_select.html#tutorial-window-functions)'
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### Support for the SQL
    LATERAL keyword'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### 支持 SQL 的 LATERAL
    关键字'
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: LATERAL 关键字目前仅被 PostgreSQL 9.3 及更高版本支持，但由于它是 SQL 标准的一部分，因此在 Core 中增加了对此关键字的支持。
    [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") 的实现除了仅呈现 LATERAL 关键字之外，还采用了特殊逻辑，以允许从与可选择器相同的
    FROM 子句派生的表进行相关联，例如横向相关性：
- en: '[PRE204]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: See also
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### Support for TABLESAMPLE'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### 对 TABLESAMPLE 的支持'
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 标准的 TABLESAMPLE 可以使用 [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") 方法呈现，该方法返回一个类似于别名的 [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") 构造：
- en: '[PRE205]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `people` 有一个列 `people_id`，上述语句将渲染为：
- en: '[PRE206]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### The `.autoincrement`
    directive is no longer implicitly enabled for a composite primary key column'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### 对于复合主键列，不再隐式启用 `.autoincrement`
    指令'
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 一直以来都具有便利功能，可以为单列整数主键启用后端数据库的“自动增量”功能；所谓“自动增量”是指数据库列将包括数据库提供的任何 DDL
    指令，以指示自增长整数标识符，例如 PostgreSQL 上的 SERIAL 关键字或 MySQL 上的 AUTO_INCREMENT，并且此外，方言将使用适合于该后端的技术从执行
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    构造中接收这些生成的值。
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 发生变化的是，此功能不再自动为 *复合* 主键打开；以前，表定义如下：
- en: '[PRE207]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 只会将“autoincrement”语义应用于`'x'`列，仅因为它是主键列列表中的第一个。为了禁用这个，必须关闭所有列上的`autoincrement`：
- en: '[PRE208]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新行为，除非列明确标记为`autoincrement=True`，否则复合主键不会具有自动增量语义：
- en: '[PRE209]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预见一些潜在的不兼容情况，[`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert")构造将对没有设置自动增量的复合主键列上缺失的主键值执行更彻底的检查；给定这样一个表：
- en: '[PRE210]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 当对此表进行无值插入时，会产生以下警告：
- en: '[PRE211]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从服务器端默认值或者更少见的情况如触发器接收主键值的列，可以使用[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")来指示值生成器的存在：
- en: '[PRE212]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 对于极少数情况下，复合主键实际上打算在其中一个或多个列中存储NULL的情况（仅在SQLite和MySQL上支持），请使用`nullable=True`指定列：
- en: '[PRE213]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，`autoincrement`标志可以设置为True，用于具有客户端或服务器端默认值的列。这通常不会对插入期间列的行为产生太大影响。
- en: See also
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '[不再为具有AUTO_INCREMENT的复合主键生成隐式KEY](#change-mysql-3216)'
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### Support for IS DISTINCT
    FROM and IS NOT DISTINCT FROM'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### 支持IS DISTINCT FROM和IS
    NOT DISTINCT FROM'
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 新操作符[`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from")和[`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from")允许IS DISTINCT
    FROM和IS NOT DISTINCT FROM sql操作：
- en: '[PRE214]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Handling is provided for NULL, True and False:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 处理NULL、True和False：
- en: '[PRE215]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLite，它没有这个运算符，“IS” / “IS NOT”会被渲染，这在SQLite上可以用于NULL，不像其他后端：
- en: '[PRE216]  ### Core and ORM support for FULL OUTER JOIN'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE216]  ### Core和ORM支持FULL OUTER JOIN'
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 新标志[`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin")，在Core和ORM级别可用，指示编译器在通常渲染`LEFT
    OUTER JOIN`的地方渲染`FULL OUTER JOIN`：
- en: '[PRE217]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The flag also works at the ORM level:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志也适用于ORM级别：
- en: '[PRE218]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet column
    matching enhancements; positional column setup for textual SQL'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet列匹配增强；文本SQL的位置列设置'
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 系列中对 `ResultProxy` 系统进行了一系列改进，作为 [#918](https://www.sqlalchemy.org/trac/ticket/918)
    的一部分，它重新组织了内部，使游标绑定的结果列与表/ORM 元数据按位置匹配，而不是按名称匹配，用于包含有关要返回的结果行的完整信息的编译 SQL 构造。这允许大大节省
    Python 开销，并且在将 ORM 和 Core SQL 表达式链接到结果行时具有更高的准确性。在 1.1 版本中，此重新组织已进一步在内部进行，并且还通过最近添加的
    [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法可用于纯文本 SQL 构造。
- en: TextAsFrom.columns() now works positionally
  id: totrans-934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TextAsFrom.columns() 现在按位置工作
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法在 0.9 版本中新增，接受基于列的参数位置；在 1.1
    版本中，当所有列都按位置传递时，这些列与最终结果集的关联也将按位置执行。这里的关键优势在于，现在可以将文本 SQL 链接到 ORM 级别的结果集，而无需处理模糊或重复的列名称，也无需匹配标签方案到
    ORM 级别的标签方案。现在所需的只是在文本 SQL 中以及传递给 [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 的列参数内部的相同列顺序：'
- en: '[PRE219]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的文本 SQL 中，“id” 列重复出现了三次，这通常是不明确的。使用新功能，我们可以直接应用来自 `User` 和 `Address` 类的映射列，甚至将
    `Address.user_id` 列链接到文本 SQL 中的 `users.id` 列以供娱乐，而 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象将收到正确的可按需定位的行，包括用于急加载。
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改与使用不同顺序将列传递给方法的代码**不兼容**。希望由于这种方法一直以来都是按照文本 SQL 语句中列的相同顺序传递列的方式来记录的，因此其影响将会很小，即使内部未进行此检查也是如此。无论如何，该方法仅从
    0.9 版本开始添加，可能尚未被广泛使用。有关如何处理使用此方法的应用程序的行为更改的详细说明，请参见[当传递列位置性地传递时，TextClause.columns()
    将不按名称匹配列](#behavior-change-3501)。
- en: See also
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用文本列表达式进行选择](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[当传递位置参数时，`TextClause.columns()`将按位置而不是按名称匹配列](#behavior-change-3501) - 向后兼容说明'
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  id: totrans-942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位置匹配优先于基于名称的匹配用于 Core/ORM SQL 构造
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改的另一个方面是对于编译后的 SQL 构造，匹配列的规则也已经修改，更充分地依赖于“位置”匹配。给定以下语句：
- en: '[PRE220]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'The above statement will compile to:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将编译为：
- en: '[PRE221]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 中，当执行上述语句时，将使用位置匹配来匹配其原始编译结构，但是因为该语句包含重复的`'user_id'`标签，所以“模糊列”规则仍然会涉及并阻止从行中获取列。从
    1.1 开始，“模糊列”规则不会影响从列构造到 SQL 列的精确匹配，这是 ORM 用于获取列的方式：
- en: '[PRE222]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Much less likely to get an “ambiguous column” error message
  id: totrans-949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 很少会收到“模糊列”错误消息
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此更改的一部分，错误消息`结果集中的模糊列名'<name>'！尝试在 select 语句上使用 'use_labels' 选项。`的措辞已经有所减少；因为现在当使用
    ORM 或 Core 编译后的 SQL 构造时，这个消息应该极其罕见，所以它只是简单地陈述了`结果集列描述中的模糊列名'<name>'`，仅当使用实际模糊的名称从渲染的
    SQL 语句中检索结果列时，例如上面的`row['user_id']`。它现在还引用了来自渲染的 SQL 语句本身的实际模糊名称，而不是指示用于获取的构造本地的键或名称。
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### Support for Python’s
    native `enum` type and compatible forms'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### 支持 Python 的原生`enum`类型及兼容形式'
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")类型现在可以使用任何符合
    PEP-435 的枚举类型构造。在使用此模式时，输入值和返回值是实际的枚举对象，而不是字符串/整数等值：'
- en: '[PRE223]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The `Enum.enums` collection is now a list instead of a tuple
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Enum.enums`集合现在是一个列表而不是一个元组'
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    的更改的一部分，`Enum.enums`元素的集合现在是一个列表而不是一个元组。这是因为列表适用于长度可变的同类项序列，其中元素的位置没有语义上的重要性。
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### Negative integer
    indexes accommodated by Core result rows'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### 核心结果行支持负整数索引'
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`对象现在像常规的 Python 序列一样支持单个负整数索引，无论是在纯 Python 版本还是在 C 扩展版本中。以前，负值仅在切片中起作用：'
- en: '[PRE224]  ### The `Enum` type now does in-Python validation of values'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE224]  ### `Enum`类型现在在 Python 中对值进行验证'
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应Python本机枚举对象，以及诸如在ARRAY中使用非本地ENUM类型且CHECK约束不可行等边缘情况，当使用[`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum")标志时，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型现在在Python端验证输入值（1.1.0b2）：
- en: '[PRE225]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此验证是关闭的，因为已经确定了用户不希望进行此类验证的用例（如字符串比较）。对于非字符串类型，它在所有情况下必须进行。当从数据库返回值时，结果处理方面的检查也是无条件发生的。
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证是在使用非本地枚举类型时创建CHECK约束的现有行为之外的。现在可以使用新的[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum")标志禁用此CHECK约束的创建。
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### Non-native boolean
    integer values coerced to zero/one/None in all cases'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### 非本地布尔整数值在所有情况下被强制转换为零/一/None'
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")数据类型将Python布尔值强制转换为整数值，用于那些没有本地布尔类型的后端，如SQLite和MySQL。在这些后端，通常设置一个CHECK约束，以确保数据库中的值实际上是这两个值之一。然而，MySQL忽略CHECK约束，该约束是可选的，现有数据库可能没有这个约束。[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型已修复，使得已经是整数值的Python端值被强制转换为零或一，而不仅仅是原样传递；此外，结果的C扩展版本的整数到布尔处理器现在使用与Python布尔值解释相同的值，而不是断言一个确切的一或零值。这现在与纯Python整数到布尔处理器一致，并且对数据库中已有的数据更宽容。None/NULL值仍然保留为None/NULL。'
- en: Note
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改意外地导致非整数值（例如字符串）的解释行为也发生了更改，使得字符串值 `"0"` 被解释为“true”，但仅适用于没有本机布尔数据类型的后端 -
    在“本机布尔”后端（如 PostgreSQL）上，字符串值 `"0"` 直接传递给驱动程序，并解释为“false”。这是以前实现中没有发生的不一致性。应注意，将字符串或任何其他值传递给
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    数据类型外的值 `None`、`True`、`False`、`1`、`0` 是 **不受支持** 的，版本 1.2 将为此场景引发错误（或可能只是发出警告，待定）。另请参阅
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102)。
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### Large parameter and
    row values are now truncated in logging and exception displays'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### 在日志和异常显示中，现在会截断大参数和行值'
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 语句的绑定参数中存在大值，以及在结果行中存在大值，现在在日志记录、异常报告以及行本身的 `repr()` 中都将被截断显示：
- en: '[PRE226]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### JSON support added
    to Core'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### Core 添加了 JSON 支持'
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MySQL 现在除了 PostgreSQL JSON 数据类型外还有 JSON 数据类型，核心现在获得了一个 [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，它是这两者的基础。使用此类型允许以 PostgreSQL 和 MySQL 通用的方式访问“getitem”操作符和“getpath”操作符。
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据类型还对 NULL 值的处理以及表达式处理进行了一系列改进。
- en: See also
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[MySQL JSON Support](#change-3547)'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL JSON 支持](#change-3547)'
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用 ORM 操作时，“null” 会如预期地插入，当不存在时则被省略'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其子类型 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 具有一个标志 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")，当设置为 True 时表示 Python 值 `None` 应该转换为 SQL NULL 而不是 JSON
    NULL 值。此标志默认为 False，这意味着 Python 值 `None` 应该导致 JSON NULL 值。'
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，此逻辑将失败，现在已进行更正：
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当列还包含默认值或`server_default`值时，对预期持久化 JSON “null” 的映射属性上的`None`的正值仍将触发列级默认值，替换`None`值：
- en: '[PRE227]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当列*没有*包含默认值或`server_default`值时，在配置了`none_as_null=False`的 JSON 列上的缺失值仍将呈现
    JSON NULL，而不是回退到不插入任何值，这与所有其他数据类型的行为不一致：
- en: '[PRE228]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种行为变更，对于依赖此行为将缺失值默认为 JSON null 的应用程序而言，这是不兼容的。这基本上表明**缺失值与存在的`None`值是有区别的**。有关更多详细信息，请参见[JSON
    Columns will not insert JSON NULL if no value is supplied and no default is established](#behavior-change-3514)。
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当使用[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")方法时，无论何种情况下都会忽略`None`：
- en: '[PRE229]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")类型现在实现了[`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none")标志，指示此处不应忽略`None`；它会根据[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")的值自动配置。感谢 [#3061](https://www.sqlalchemy.org/trac/ticket/3061)，我们可以区分用户主动设置`None`值和根本没有设置的情况。'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性同样适用于新的基本[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")类型及其后代类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### 新增 JSON.NULL 常量'
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序始终可以完全控制一个 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")、[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 列是否接收 SQL NULL 或 JSON `"null"` 值，添加了常量
    [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")，它与
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    结合使用，可以完全确定 SQL NULL 和 JSON `"null"` 之间的区别，不管 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 设置为何值：
- en: '[PRE230]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Array support added
    to Core; new ANY and ALL operators'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Core 中添加了数组支持；新的
    ANY 和 ALL 运算符'
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对 PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型所做的增强描述在 [通过数组、JSON、HSTORE 的索引访问建立正确的
    SQL 类型](#change-3503) 中，[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 的基类本身已经移动到 Core 中，成为一个新的类 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")。
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 SQL 标准的一部分，还有一些面向数组的函数，比如 `array_agg()` 和 `unnest()`。为了支持这些构造不仅仅是针对 PostgreSQL，还有可能是未来其他支持数组的后端，比如
    DB2，现在大部分 SQL 表达式的数组逻辑都在 Core 中。[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 类型仍然**只在 PostgreSQL 上工作**，但可以直接使用，支持特殊的数组用例，比如索引访问，以及支持
    ANY 和 ALL：
- en: '[PRE231]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 ANY 和 ALL，[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    类型保留了与 PostgreSQL 类型相同的 [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") 和 [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") 方法，但也将这些操作导出为新的独立运算符函数 [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") 和 [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_")。这两个函数以更传统的 SQL 方式工作，允许右侧表达式形式，如：
- en: '[PRE232]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL 特定的运算符“contains”，“contained_by” 和 “overlaps”，应继续直接使用 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型，该类型还提供了 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 类型的所有功能。
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '[`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    和 [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    运算符在核心层面是开放的，但是后端数据库对它们的解释是有限的。在 PostgreSQL 后端，这两个运算符**只接受数组值**。而在 MySQL 后端，它们**只接受子查询值**。在
    MySQL 中，可以使用如下表达式：'
- en: '[PRE233]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### New Function features,
    “WITHIN GROUP”, array_agg and set aggregate functions'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### 新功能特性，“WITHIN GROUP”，array_agg
    和 set 聚合函数'
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    类型，我们还可以实现一个预定义的函数，用于返回一个数组的 `array_agg()` SQL 函数，现在可以使用 [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg")：
- en: '[PRE234]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") 还添加了一个用于聚合 ORDER BY 的 PostgreSQL
    元素��
- en: '[PRE235]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Producing:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE236]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: PG 方言本身还提供了一个 [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") 包装器，以确保 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型：
- en: '[PRE237]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像 `percentile_cont()`、`percentile_disc()`、`rank()`、`dense_rank()` 等需要通过 `WITHIN
    GROUP (ORDER BY <expr>)` 进行排序的函数现在可以通过 [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") 修改器使用：
- en: '[PRE238]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The above statement would produce SQL similar to:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句会产生类似于以下 SQL：
- en: '[PRE239]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为这些函数提供了正确返回类型的占位符，并包括 [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont")、[`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc")、[`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank")、[`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank")、[`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode")、[`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank") 和 [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist")。
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator 现在自动与 Enum、Boolean、“schema” 类型一起工作'
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    类型包括诸如 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    和 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    等类型，除了对应数据库类型外，还会自动生成 CHECK 约束或者在 PostgreSQL ENUM 的情况下生成新的 CREATE TYPE 语句，现在可以自动与
    [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    配方一起使用了。以前，`ENUM` 的 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 需要像这样：'
- en: '[PRE240]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 现在传播这些额外的事件，所以它可以像任何其他类型一样进行操作：'
- en: '[PRE241]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### Multi-Tenancy Schema
    Translation for Table objects'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### 多租户模式下的 Table 对象的架构翻译'
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持一个应用程序使用许多模式中相同的一组 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象的用例，例如每个用户一个模式，添加了一个新的执行选项 [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options")。 使用这个映射，一组 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象可以在每个连接基础上被制作，以引用任何一组模式，而不是它们被分配到的 [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table")。 该翻译适用于 DDL 和 SQL 生成，以及与 ORM 一起使用。
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `User` 类被分配了模式“per_user”：
- en: '[PRE242]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求上，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以设置为每次引用不同的模式：
- en: '[PRE243]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: See also
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '[模式名称的翻译](../core/connections.html#schema-translating)'
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### “Friendly” stringification
    of Core SQL constructs without a dialect'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### “友好”的 Core SQL 构造的字符串化，没有方言'
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Core SQL 构造调用 `str()` 现在会在更多情况下产生一个字符串，支持各种通常不在默认 SQL 中出现的 SQL 构造，如 RETURNING、数组索引和非标准数据类型：
- en: '[PRE244]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 函数现在调用一个完全独立的方言/编译器，仅用于普通字符串打印而没有特定的方言设置，因此当出现更多“只是显示给我一个字符串！”的情况时，这些可以添加到这个方言/编译器中，而不会影响真实方言上的行为。'
- en: See also
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询的字符串化将咨询 Session 获取正确的方言](#change-3081)'
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### The type_coerce function
    is now a persistent SQL element'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### `type_coerce` 函数现在是一个持久的
    SQL 元素'
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 函数以前会返回一个对象，要么是类型为 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")，要么是类型为 [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label")，取决于输入。 这将产生的影响是，在使用表达式转换的情况下，例如将元素从 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 转换为 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")，这对 ORM 级别的延迟加载至关重要，类型强制转换信息将不会被使用，因为它已经丢失了。'
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这种行为，该函数现在返回一个围绕给定表达式的持久[`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce")容器，该表达式本身保持不变；这个结构会被 SQL 编译器显式评估。这样可以确保内部表达式的强制转换在语句如何修改时都能保持不变，包括如果包含的元素被替换为另一个元素，这在
    ORM 的延迟加载功能中很常见。
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 展示效果的测试案例利用了异构的 primaryjoin 条件，结合自定义类型和延迟加载。给定一个应用 CAST 作为“绑定表达式”的自定义类型：
- en: '[PRE245]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个映射，我们将一个表上的字符串 “id” 列与另一个表上的整数 “id” 列进行等价比较：
- en: '[PRE246]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 表达式中，我们使用 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 处理通过延迟加载传递的绑定参数作为整数，因为我们已经知道这些参数将来自我们的
    `StringAsInt` 类型，该类型在 Python 中保持为整数值。然后我们使用 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，以便作为 SQL 表达式，VARCHAR “id” 列将被 CAST 为整数，用于常规非转换连接，如
    [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join")
    或 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")。也就是说，`.pets` 的 joinedload 如下所示：
- en: '[PRE247]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接的 ON 子句中没有 CAST，像 PostgreSQL 这样的强类型数据库将拒绝隐式比较整数并失败。
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pets` 的延迟加载情况依赖于在加载时用绑定参数替换 `Person.id` 列，该参数接收一个 Python 加载的值。这种替换是我们的 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 函数意图会丢失的具体地方。在更改之前，这种延迟加载如下所示：'
- en: '[PRE248]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到我们在 Python 中的值 `5` 首先被 CAST 为 VARCHAR，然后在 SQL 中再次被 CAST 为 INTEGER；这是一个双重
    CAST，虽然有效，但并不是我们要求的。
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化，[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数在列被替换为绑定参数后仍保持一个包装器，查询现在看起来像这样：
- en: '[PRE249]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要连接中的外部 CAST 仍然生效，但是`StringAsInt`自定义类型的不必要的 CAST 部分已经被[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数按预期移除。
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)  ### Engines now invalidate
    connections, run error handlers for BaseException'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)  ### 引擎现在使连接无效，运行 BaseException
    的错误处理程序'
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.1 中新增：这个变化是在 1.1 最终版本之前的 1.1 系列中添加的，不包含在 1.1 beta 版本中。
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `BaseException` 类位于 `Exception` 之下，但是是系统级异常（如`KeyboardInterrupt`、`SystemExit`，尤其是由
    eventlet 和 gevent 使用的`GreenletExit`异常）的可识别基类。现在，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 的异常处理例程拦截了这个异常类，并包括由 `ConnectionEvents.handle_error()`
    事件处理。在不是`Exception`子类的系统级异常的情况下，默认情况下现在会**使连接无效**，因为假定操作被中断，连接可能处于不可用状态。这个变化主要针对
    MySQL 驱动程序，但是这个变化适用于所有 DBAPI。
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 在无效化时，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    使用的即时 DBAPI 连接会被释放，如果在异常抛出后仍在使用 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，则在下次使用时会使用新的 DBAPI 连接进行后续操作；然而，任何正在进行中的事务状态都会丢失，必须在重新使用之前调用适当的`.rollback()`方法（如果适用）。
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别这种变化，很容易证明当这些异常发生在连接正在工作时，pymysql 或 mysqlclient / MySQL-Python 连接会进入损坏状态；然后连接将被返回到连接池，后续使用将失败，甚至在返回到池之前会导致在调用`.rollback()`的上下文管理器中引发次要故障。这里的行为预期将减少
    MySQL 错误“commands out of sync”的发生，以及在 MySQL 驱动程序未能正确报告`cursor.description`时可能发生的`ResourceClosedError`，当在
    greenlet 条件下运行时，其中 greenlets 被终止，或者处理`KeyboardInterrupt`异常而不完全退出程序时。
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与通常的自动失效功能不同，它不假设后端数据库本身已关闭或重新启动；它不像通常的DBAPI断开异常那样重新生成整个连接池。
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变应该对所有用户都是一个净改进，除了**任何当前拦截``KeyboardInterrupt``或``GreenletExit``并希望在同一事务中继续工作的应用程序**。对于那些理论上不受`KeyboardInterrupt`影响的其他DBAPIs，比如psycopg2，这样的操作是可能的。对于这些DBAPIs，以下解决方法将禁用特定异常的连接被回收：
- en: '[PRE250]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)'
- en: '### CTE Support for INSERT, UPDATE, DELETE'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持INSERT、UPDATE、DELETE的CTE'
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛请求的功能之一是支持与INSERT、UPDATE、DELETE一起工作的通用表达式（CTE），现在已经实现。INSERT/UPDATE/DELETE可以从位于SQL顶部的WITH子句中提取，也可以作为更大语句上下文中的CTE使用。
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个改变的一部分，包含CTE的INSERT FROM SELECT现在将在整个语句的顶部呈现CTE，而不是像1.0中那样嵌套在SELECT语句中。
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在一个语句中呈现UPDATE、INSERT和SELECT的示例：
- en: '[PRE251]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)'
- en: '### Support for RANGE and ROWS specification within window functions'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持窗口函数中的RANGE和ROWS规范'
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 新的[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over")和[`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over")参数允许窗口函数使用RANGE和ROWS表达式：
- en: '[PRE252]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over")和[`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over")被指定为2元组，表示特定范围的负值和正值，“CURRENT ROW”为0，UNBOUNDED为None。'
- en: See also
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用窗口函数](../tutorial/data_select.html#tutorial-window-functions)'
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)'
- en: '### Support for the SQL LATERAL keyword'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持SQL的LATERAL关键字'
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: LATERAL关键字目前只被已知支持PostgreSQL 9.3及更高版本，然而，由于它是SQL标准的一部分，因此Core添加了对该关键字的支持。[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")的实现采用了特殊逻辑，不仅仅是呈现LATERAL关键字，还允许来自与可选择器相同FROM子句派生的表的相关性，例如，侧向相关性：
- en: '[PRE253]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: See also
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)'
- en: '### Support for TABLESAMPLE'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持TABLESAMPLE'
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: SQL标准的TABLESAMPLE可以使用[`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample")方法呈现，该方法返回一个类似于别名的[`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample")构造：
- en: '[PRE254]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`people`有一个列`people_id`，上述语句会被渲染为：
- en: '[PRE255]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)'
- en: '### The `.autoincrement` directive is no longer implicitly enabled for a composite
    primary key column'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对于复合主键列，`.autoincrement`指令不再隐式启用'
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直以来都有一个方便的特性，即为单列整数主键启用后端数据库的“自增”功能；所谓的“自增”，是指数据库列将包含任何DDL指令，以指示自增长整数标识符，例如在PostgreSQL上的SERIAL关键字或在MySQL上的AUTO_INCREMENT，并且此外，方言将通过执行[`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert")构造使用适合于该后端的技术来接收这些生成的值。
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的是，此功能不再自动应用于*复合*主键；以前，表定义如下：
- en: '[PRE256]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为它在主键列列表中排在第一位，因此会应用于`'x'`列的“自增”语义。为了禁用此功能，必须关闭所有列上的`autoincrement`：
- en: '[PRE257]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的行为，除非列被明确地标记为`autoincrement=True`，否则复合主键将不具有自增语义：
- en: '[PRE258]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测一些潜在的不向后兼容的情况，[`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert")构造将对没有设置自增的复合主键列上的缺失主键值执行更彻底的检查；给定一个表，如下所示：
- en: '[PRE259]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个表没有提供任何值的INSERT将会产生警告：
- en: '[PRE260]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从服务器端默认值或者触发器等不太常见的情况下接收主键值的列，可以使用[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")来指示存在值生成器：
- en: '[PRE261]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于极少情况下实际上意图在其列中存储 NULL 的复合主键（仅在 SQLite 和 MySQL 上支持），请使用 `nullable=True` 指定列：
- en: '[PRE262]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，可以在具有客户端或服务器端默认值的列上将 `autoincrement` 标志设置为 True。这通常不会对插入时列的行为产生太大影响。
- en: See also
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '[不再为具有 AUTO_INCREMENT 的复合主键生成隐式 KEY](#change-mysql-3216)'
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)'
- en: '### Support for IS DISTINCT FROM and IS NOT DISTINCT FROM'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 IS DISTINCT FROM 和 IS NOT DISTINCT FROM'
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 新运算符 [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") 和 [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") 允许 IS DISTINCT
    FROM 和 IS NOT DISTINCT FROM sql 操作：
- en: '[PRE263]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Handling is provided for NULL, True and False:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 NULL、True 和 False：
- en: '[PRE264]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不具有此运算符的 SQLite，将渲染“IS” / “IS NOT”，在 SQLite 上与其他后端不同，对 NULL 有效：
- en: '[PRE265]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '### Core and ORM support for FULL OUTER JOIN'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '### 完全外连接的核心和ORM支持'
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 新标志 [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin")，在核心和ORM级别可用，指示编译器在通常渲染 `LEFT
    OUTER JOIN` 的地方渲染 `FULL OUTER JOIN`：
- en: '[PRE266]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The flag also works at the ORM level:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志也适用于ORM级别：
- en: '[PRE267]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)'
- en: '### ResultSet column matching enhancements; positional column setup for textual
    SQL'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '### ResultSet列匹配增强；文本SQL的位置列设置'
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 系列中对 `ResultProxy` 系统进行了一系列改进，作为 [#918](https://www.sqlalchemy.org/trac/ticket/918)
    的一部分，重新组织了内部结构，以便通过位置而不是通过匹配名称将游标绑定的结果列与表/ORM元数据进行匹配，用于包含有关要返回的结果行的完整信息的编译SQL构造。这样可以大大节省
    Python 的开销，同时在将ORM和Core SQL表达式与结果行链接时提供更高的准确性。在 1.1 中，这种重新组织在内部进一步进行了，并且还通过最近添加的
    [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法可用于纯文本SQL构造。
- en: TextAsFrom.columns() now works positionally
  id: totrans-1124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TextAsFrom.columns() 现在按位置工作
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法是在0.9版中添加的，接受基于列的参数位置；在1.1版中，当所有列被位置传递时，这些列与最终结果集的关联也将按位置执行。这里的关键优势在于，现在可以将文本SQL链接到ORM级别的结果集，而无需处理模糊或重复的列名，也无需将标签方案与ORM级别的标签方案进行匹配。现在所需要的只是在文本SQL中的列的顺序与传递给[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")的列参数相同：'
- en: '[PRE268]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述文本SQL中，“id”列出现了三次，这通常会产生歧义。使用新功能，我们可以直接应用来自`User`和`Address`类的映射列，甚至可以将文本SQL中的`Address.user_id`列链接到`users.id`列，以供娱乐之用，而[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将接收到正确的可定位行，包括用于及早加载。
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改与通过不同顺序将列传递给该方法的代码不兼容。希望由于这种方法一直以来都是以与文本SQL语句相同的顺序传递列而被记录的，这种影响将会很小，尽管内部并未检查此顺序。无论如何，该方法仅在0.9版中才被添加，并且可能尚未广泛使用。有关如何处理使用该方法的应用程序的行为更改的详细说明，请参阅[TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501)。
- en: See also
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用文本列表达式进行选择](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - 向后兼容性说明'
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  id: totrans-1132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对于Core/ORM SQL构造，基于位置的匹配比基于名称的匹配更受信任
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改的另一个方面是，匹配列的规则也已经修改，以更充分地依赖于编译后SQL结构中的“位置”匹配。考虑到以下语句：
- en: '[PRE269]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'The above statement will compile to:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将编译为：
- en: '[PRE270]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中，上述语句在执行时将通过位置匹配与其原始编译结构相匹配，但由于语句中包含重复的 `'user_id'` 标签，因此“模糊列”规则仍然会介入并阻止从行中获取列。从
    1.1 版开始，“模糊列”规则不会影响从列构造到 SQL 列的精确匹配，这是 ORM 用于获取列的方法：
- en: '[PRE271]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: Much less likely to get an “ambiguous column” error message
  id: totrans-1139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 几乎不太可能出现“模糊列”错误消息
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一更改的一部分，错误消息 `Ambiguous column name '<name>' in result set! try 'use_labels'
    option on select statement.` 的措辞已经有所减少；由于使用 ORM 或 Core 编译的 SQL 结构时，此消息现在应该极为罕见，因此它仅在检索使用实际上具有歧义的字符串名称的结果列时才会说明
    `Ambiguous column name '<name>' in result set column descriptions`。它还现在引用了来自渲染的
    SQL 语句本身的实际模糊名称，而不是指示用于获取的构造体的键或名称。
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
- en: TextAsFrom.columns() now works positionally
  id: totrans-1142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`TextAsFrom.columns()` 现在按位置工作'
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法在 0.9 版中添加了，它接受基于列的参数按位置排列；在
    1.1 版中，当所有列按位置传递时，这些列与最终结果集的相关性也按位置执行。这里的关键优势是，现在可以将文本 SQL 链接到 ORM 级别的结果集，而无需处理模糊或重复的列名，也无需将标签方案与
    ORM 级别的标签方案进行匹配。现在所需的是文本 SQL 中的列顺序与传递给 [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 的列参数的相同顺序：'
- en: '[PRE272]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述文本 SQL 中，“id” 列出现三次，这通常会是模糊的。使用新功能，我们可以直接应用来自 `User` 和 `Address` 类的映射列，甚至可以将
    `Address.user_id` 列链接到文本 SQL 中的 `users.id` 列以供娱乐，并且 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象将接收到正确可用的行，包括用于急加载。
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化与将列以与文本语句中的顺序不同的顺序传递给方法的代码不兼容。希望由于这个方法一直以来都是以与文本 SQL 语句相同的顺序传递列而被记录的，因此这种影响将会很小，即使内部没有检查这一点。无论如何，该方法仅在
    0.9 版本中添加，并且可能尚未广泛使用。有关如何处理使用它的应用程序的这种行为变化的详细说明，请参阅 [TextClause.columns() will
    match columns positionally, not by name, when passed positionally](#behavior-change-3501)。
- en: See also
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用文本列表达式进行选择](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[当按位置传递时，TextClause.columns() 将按位置而不是按名称匹配列](#behavior-change-3501) - 向后兼容性说明'
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  id: totrans-1150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对于核心/ORM SQL 构造，位置匹配比基于名称的匹配更可靠
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化的另一个方面是，匹配列的规则也已经修改，更充分地依赖“位置”匹配来编译 SQL 构造。给定如下语句：
- en: '[PRE273]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The above statement will compile to:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将编译为：
- en: '[PRE274]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中，上述语句在执行时将使用位置匹配与其原始编译构造相匹配，但是因为该语句包含了重复的 `'user_id'` 标签，所以“模糊列”规则仍然会介入并阻止从行中获取列。从
    1.1 版本开始，“模糊列”规则不会影响从列构造到 SQL 列的精确匹配，这是 ORM 用于获取列的方法：
- en: '[PRE275]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Much less likely to get an “ambiguous column” error message
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 很少出现“模糊列”错误消息
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此更改的一部分，错误消息 `Ambiguous column name '<name>' in result set! try 'use_labels'
    option on select statement.` 的措辞已经减弱；因为使用 ORM 或核心编译 SQL 构造时，此消息现在应该极为罕见，它只是简单地说明了
    `Ambiguous column name '<name>' in result set column descriptions`，仅当通过实际模糊的字符串名称检索结果列时，例如在上面的示例中使用
    `row['user_id']`。它现在还引用了来自渲染的 SQL 语句本身的实际模糊名称，而不是指示用于获取的构造的键或名称。
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
- en: '### Support for Python’s native `enum` type and compatible forms'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 Python 的本机 `enum` 类型和兼容形式'
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    类型现在可以使用任何符合 PEP-435 的枚举类型来构造。在使用此模式时，输入值和返回值是实际的枚举对象，而不是字符串/整数等值：'
- en: '[PRE276]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: The `Enum.enums` collection is now a list instead of a tuple
  id: totrans-1163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Enum.enums` 集合现在是列表而不是元组'
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")的更改的一部分，`Enum.enums`元素集合现在是一个列表而不是元组。这是因为列表适用于元素的长度可变的同质项序列，其中元素的位置在语义上不重要。
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
- en: The `Enum.enums` collection is now a list instead of a tuple
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Enum.enums`集合现在是一个列表而不是元组'
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")的更改的一部分，`Enum.enums`元素集合现在是一个列表而不是元组。这是因为列表适用于元素的长度可变的同质项序列，其中元素的位置在语义上不重要。
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
- en: '### Negative integer indexes accommodated by Core result rows'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '### Core结果行容纳负整数索引'
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`对象现在像常规Python序列一样容纳单个负整数索引，无论是在纯Python版本还是C扩展版本中。以前，负值只能在切片中起作用：'
- en: '[PRE277]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '### The `Enum` type now does in-Python validation of values'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '### `Enum`类型现在对值进行Python内部验证'
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '为了适应Python本机枚举对象，以及诸如在数组中使用非本地ENUM类型且CHECK约束不可行等边缘情况，当使用[`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum")标志时，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型现在对输入值进行Python内部验证（1.1.0b2）:'
- en: '[PRE278]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证默认关闭，因为已经确定存在用户不希望进行此类验证的用例（例如字符串比较）。对于非字符串类型，它在所有情况下都必须进行。当从数据库返回值时，检查也会无条件地发生在结果处理方面。
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证是在使用非本地枚举类型时创建CHECK约束的现有行为之外的。现在可以使用新的[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum")标志来禁用此CHECK约束的创建。
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)'
- en: '### Non-native boolean integer values coerced to zero/one/None in all cases'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '### 所有情况下将非本地布尔整数值强制转换为零/一/None'
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    数据类型将 Python 布尔值强制转换为整数值，以用于没有本地布尔类型的后端，例如 SQLite 和 MySQL。在这些后端上，通常设置一个 CHECK
    约束，以确保数据库中的值实际上是这两个值之一。但是，MySQL 忽略 CHECK 约束，该约束是可选的，并且现有数据库可能没有此约束。已修复[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") 数据类型，使得已经是整数值的 Python 端值被强制转换为零或一，而不仅仅是传递原样；此外，结果的
    C 扩展版本的整数到布尔处理器现在使用与 Python 布尔值解释相同的值，而不是断言确切的一或零值。这现在与纯 Python 的整数到布尔处理器一致，并且更容忍数据库中已有的数据。值为
    None/NULL 仍然保留为 None/NULL。'
- en: Note
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改导致了一个意外的副作用，即非整数值（如字符串）的解释也发生了变化，使得字符串值`"0"`被解释为“true”，但仅在没有本地布尔数据类型的后端上
    - 在像 PostgreSQL 这样的“本地布尔”后端上，字符串值`"0"`直接传递给驱动程序，并被解释为“false”。这是以前的实现中没有发生的不一致性。应注意，将字符串或任何其他值传递给[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") 数据类型之外的`None`、`True`、`False`、`1`、`0`是**不受支持**的，版本
    1.2 将对此场景引发错误（或可能只是发出警告，待定）。另请参阅[#4102](https://www.sqlalchemy.org/trac/ticket/4102)。
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)'
- en: '### Large parameter and row values are now truncated in logging and exception
    displays'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在日志和异常显示中现在截断大的��数和行值'
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 SQL 语句的绑定参数以及结果行中存在的大值现在在日志记录、异常报告以及行本身的`repr()`中显示时将被截断：
- en: '[PRE279]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)'
- en: '### JSON support added to Core'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '### 核心添加了 JSON 支持'
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MySQL 现在除了 PostgreSQL JSON 数据类型外还有 JSON 数据类型，核心现在获得了一个[`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，这是这两种数据类型的基础。使用这种类型可以在 PostgreSQL 和 MySQL 之间以一种不可知的方式访问“getitem”运算符和“getpath”运算符。
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据类型还对 NULL 值的处理以及表达式处理进行了一系列改进。
- en: See also
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[MySQL JSON Support](#change-3547)'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL JSON 支持](#change-3547)'
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 与ORM操作一起插入JSON“null”时，如预期那样插入，当不存在时则被省略'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")类型及其后代类型[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")有一个标志[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")，当设置为True时，表示Python值`None`应该转换为SQL NULL而不是JSON NULL值。此标志默认为False，这意味着Python值`None`应该导致JSON
    NULL值。'
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，此逻辑将失败，并已得到纠正：
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当列还包含默认值或服务器默认值时，对于期望持久化JSON“null”的映射属性上的`None`正值仍会触发列级默认值，替换`None`值：
- en: '[PRE280]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当列*没有*包含默认值或服务器默认值时，配置为none_as_null=False的JSON列上的缺失值仍会呈现JSON NULL，而不是回退到不插入任何值，与所有其他数据类型的行为不一致：
- en: '[PRE281]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为变更，对于依赖此默认缺失值为JSON null的应用程序来说是不兼容的。这基本上确立了**缺失值与存在的None值有所区别**。有关更多详细信息，请参见[JSON列如果未提供任何值且未建立默认值，则不会插入JSON
    NULL](#behavior-change-3514)。
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当使用[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")方法时，在所有情况下都会忽略`None`：
- en: '[PRE282]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")类型现在实现了[`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none")标志，指示此处不应忽略`None`；它会根据[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")的值自动配置。感谢[#3061](https://www.sqlalchemy.org/trac/ticket/3061)，我们可以区分用户主动设置的`None`值与根本未设置的情况。'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### 新增了 JSON.NULL 常量'
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保应用程序始终可以完全控制 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")、[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 列在值级别是否应接收 SQL NULL 或 JSON `"null"` 值，已添加了常量
    [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")，它与
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    结合使用，可以完全确定 SQL NULL 和 JSON `"null"` 之间的区别，而不受 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 的设置影响：
- en: '[PRE283]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### JSON “null” is inserted
    as expected with ORM operations, omitted when not present'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### 在 ORM 操作中插入 JSON
    “null” 时会被预期地插入，当未出现时会被省略'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 具有一个标志 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")，当设置为 True 时，表示 Python 值 `None` 应转换为 SQL NULL 而不是 JSON
    NULL 值。该标志默认为 False，这意味着 Python 值 `None` 应导致 JSON NULL 值。'
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，此逻辑将失败，并已纠正：
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当列还包含默认值或 server_default 值时，在期望持久化 JSON “null”的映射属性上的正值 `None` 仍会触发列级默认值，替换
    `None` 值：
- en: '[PRE284]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当列*不*包含默认值或 server_default 值时，针对配置了 none_as_null=False 的 JSON 列上的缺失值仍会呈现
    JSON NULL 而不是回退到不插入任何值，与所有其他数据类型的行为不一致：
- en: '[PRE285]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为变更，对于依赖默认将缺失值设为 JSON null 的应用程序来说，这是不兼容的。这实际上确立了**缺失值与存在的 None 值有所区别**。详细信息请参见
    [如果未提供值且未设置默认值，则 JSON 列将不插入 JSON NULL](#behavior-change-3514)。
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当使用 [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 方法时，`None` 在所有情况下都会被忽略：
- en: '[PRE286]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型现在实现了 [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") 标志，指示此处不应忽略 `None`；它会根据 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 的值自动配置。感谢 [#3061](https://www.sqlalchemy.org/trac/ticket/3061)，我们可以区分用户主动设置的值
    `None` 与根本未设置的值。'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
- en: '#### New JSON.NULL Constant Added'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 新增 JSON.NULL 常量'
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序始终可以在值级别上完全控制 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")、[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 列是否应接收 SQL NULL 或 JSON `"null"` 值，已添加常量
    [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")，它与
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    结合使用，可以完全确定 SQL NULL 和 JSON `"null"` 之间的区别，而不受 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 的设置影响：
- en: '[PRE287]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能同样适用于新的基础 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型及其派生类型。
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
- en: '### Array support added to Core; new ANY and ALL operators'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '### Core 添加了数组支持；新增 ANY 和 ALL 运算符'
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 [Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)
    中描述的 PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型的增强功能外，[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 的基类本身已经移动到核心中的一个新类 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 中。
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 SQL 标准的一部分，还有一些面向数组的函数，如 `array_agg()` 和 `unnest()`。为了支持这些构造，不仅仅是针对 PostgreSQL，还有可能是将来其他支持数组的后端，如
    DB2，现在大部分 SQL 表达式的数组逻辑都在核心中。[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 类型仍然**只在 PostgreSQL 上工作**，但可以直接使用，支持特殊的数组用例，如索引访问，以及对
    ANY 和 ALL 的支持：
- en: '[PRE288]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 ANY 和 ALL，[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    类型保留了与 PostgreSQL 类型相同的 [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") 和 [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") 方法，但也将这些操作导出到新的独立运算符函数 [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") 和 [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_") 中。这两个函数以更传统的 SQL 方式工作，允许右侧表达式形式，如：
- en: '[PRE289]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL 特定的运算符“contains”、“contained_by” 和 “overlaps”，应继续直接使用 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型，该类型还提供了 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 类型的所有功能。
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '[`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    和 [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    运算符在核心层面是开放的，但是后端数据库对它们的解释是有限的。在 PostgreSQL 后端，这两个运算符**只接受数组值**。而在 MySQL 后端，它们**只接受子查询值**。在
    MySQL 中，可以使用如下表达式：'
- en: '[PRE290]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)'
- en: '### New Function features, “WITHIN GROUP”, array_agg and set aggregate functions'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新功能特性���“WITHIN GROUP”，array_agg 和 set 聚合函数'
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    类型，我们还可以实现一个预先类型化的函数，用于返回一个数组的 `array_agg()` SQL 函数，现在可以使用 [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") 进行调用：
- en: '[PRE291]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加了一个 PostgreSQL 元素，用于聚合 ORDER BY，通过[`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by")：
- en: '[PRE292]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Producing:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE293]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: PG 方言本身还提供了一个 [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") 包装器，以确保 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型：
- en: '[PRE294]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，像`percentile_cont()`、`percentile_disc()`、`rank()`、`dense_rank()`等函数，需要通过`WITHIN
    GROUP (ORDER BY <expr>)`进行排序，现在可以通过[`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group")修饰符进行使用：
- en: '[PRE295]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'The above statement would produce SQL similar to:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将生成类似于以下的 SQL：
- en: '[PRE296]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为这些函数提供了正确返回类型的占位符，包括 [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont")、[`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc")、[`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank")、[`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank")、[`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode")、[`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank") 和 [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist")。
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)'
- en: '### TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '### TypeDecorator 现在自动与 Enum、Boolean、“schema” 类型一起工作'
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    类型包括诸如[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    和[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    这样的类型，除了对应于数据库类型外，还会生成一个 CHECK 约束或在 PostgreSQL ENUM 的情况下生成一个新的 CREATE TYPE 语句，现在将自动与[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 配方一起工作。以前，[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") 的[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 必须像这样：'
- en: '[PRE297]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 现在传播这些额外的事件，因此可以像任何其他类型一样完成：'
- en: '[PRE298]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)'
- en: '### Multi-Tenancy Schema Translation for Table objects'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用于表对象的多租户模式翻译'
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持一个应用程序使用许多模式中相同的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的用例，例如每个用户一个模式，添加了一个新的执行选项[`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options")。使用此映射，一组[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象可以在每个连接基础上被制作，以引用任何一组模式，而不是它们被分配到的[`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table")。翻译适用于 DDL 和 SQL 生成，以及 ORM。
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `User` 类被分配到模式“per_user”：
- en: '[PRE299]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求上，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以设置为每次引用不同的模式：
- en: '[PRE300]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: See also
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '[模式名称的翻译](../core/connections.html#schema-translating)'
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)'
- en: '### “Friendly” stringification of Core SQL constructs without a dialect'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '### “友好”地将 Core SQL 构造字符串化而不使用方言'
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Core SQL 构造调用 `str()` 现在会在更多情况下生成字符串，支持各种通常不在默认 SQL 中出现的 SQL 构造，如 RETURNING、数组索引和非标准数据类型：
- en: '[PRE301]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 函数现在调用一个完全独立的方言/编译器，仅用于普通字符串打印而没有设置特定方言，因此随着更多“只是显示给我一个字符串！”的情况出现，这些可以添加到此方言/编译器中，而不会影响真实方言上的行为。'
- en: See also
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询的字符串化将询问会话以获取正确的方言](#change-3081)'
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)'
- en: '### The type_coerce function is now a persistent SQL element'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '### type_coerce 函数现在是一个持久的 SQL 元素'
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 函数之前会返回一个类型为 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 或 [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") 的对象，取决于输入。这样做的效果是，如果使用了表达式转换，例如将元素从 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 转换为 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 的过程对 ORM 级别的延迟加载至关重要，那么类型强制信息将不会被使用，因为它已经丢失了。'
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这种行为，该函数现在返回一个持久的 [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") 容器，该容器围绕给定表达式自身保持不受影响；此构造由 SQL 编译器显式评估。这允许内部表达式的强制转换得以保持，无论语句如何修改，包括如果所包含的元素被替换为不同的元素，这在
    ORM 的延迟加载功能中是常见的。
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 展示效果的测试案例利用了异构的 primaryjoin 条件与自定义类型和延迟加载。给定一个将 CAST 应用为“绑定表达式”的自定义类型：
- en: '[PRE302]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，一个映射，我们将一个表上的字符串 “id” 列与另一个表上的整数 “id” 列进行等同：
- en: '[PRE303]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 表达式中，我们使用 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 处理通过延迟加载传递的绑定参数，因为我们已经知道这些参数将来自于我们的 `StringAsInt`
    类型，该类型在 Python 中将值维护为整数。然后，我们使用 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") ，以便作为 SQL 表达式，VARCHAR “id” 列将在常规的非转换连接中被 CAST
    为整数，如 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 或 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")。也就是说，`.pets` 的 joinedload 看起来像这样：
- en: '[PRE304]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接的ON子句中没有CAST，像PostgreSQL这样的强类型数据库将拒绝隐式比较整数并失败。
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pets`的lazyload情况依赖于在加载时用绑定参数替换`Person.id`列，该参数接收Python加载的值。这种替换特别是我们的[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数意图会丢失的地方。在更改之前，这种延迟加载如下：'
- en: '[PRE305]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到我们在Python中的值`5`首先被CAST为VARCHAR，然后在SQL中再次被CAST为INTEGER；这是一个双重的CAST，虽然有效，但并不是我们要求的。
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 随着变化，[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数在列被替换为绑定参数后仍保持包装，查询现在如下所示：
- en: '[PRE306]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部CAST仍然起作用，但是`StringAsInt`自定义类型中不必要的CAST已被[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")函数按照意图移除。
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
- en: Key Behavioral Changes - ORM
  id: totrans-1294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '### 如果没有提供值且没有建立默认值，JSON列将不会插入JSON NULL'
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 如[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)中详细说明，如果值完全缺失，[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")将不会呈现JSON“null”值。为了防止SQL NULL，应该设置一个默认值。给定以下映射：
- en: '[PRE307]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'The following flush operation will fail with an integrity error:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下刷新操作将由于完整性错误而失败：
- en: '[PRE308]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列的默认值应为JSON NULL，请在列上设置此值：
- en: '[PRE309]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'Or, ensure the value is present on the object:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，确保对象上存在该值：
- en: '[PRE310]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为默认值设置`None`与完全省略它相同；[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON")标志不影响传递给[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")或[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")的`None`值：
- en: '[PRE311]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: See also
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### Columns no longer added redundantly with DISTINCT
    + ORDER BY'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### 列不再通过DISTINCT + ORDER BY冗余添加'
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类似以下的查询将仅增加那些在SELECT列表中缺失的列，而不会重复：
- en: '[PRE312]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Produces:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE313]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Previously, it would produce:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，它会产生：
- en: '[PRE314]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`user.name` 列被不必要地添加。结果不会受影响，因为额外的列在任何情况下都不包含在结果中，但这些列是不必要的。
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当通过向 [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct") 传递表达式来使用 PostgreSQL DISTINCT ON 格式时，上述“添加列”逻辑将被完全禁用。
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询被捆绑到子查询中以实现连接的急加载时，"增强列列表"规则必须更加积极，以便仍然可以满足 ORDER BY，因此此情况保持不变。
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### Same-named @validates
    decorators will now raise an exception'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### 相同名称的 @validates
    装饰器现在将引发异常'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")
    装饰器只打算为特定属性名称的每个类创建一次。创建多个现在会引发错误，而以前会悄悄地选择最后定义的验证器：'
- en: '[PRE315]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Will raise:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发：
- en: '[PRE316]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)  ### JSON Columns will
    not insert JSON NULL if no value is supplied and no default is established'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)  ### 如果未提供值且未建立默认值，则 JSON
    列将不插入 JSON NULL'
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [JSON “null” 在 ORM 操作中如预期地插入，当不存在时被省略](#change-3514) 中详细说明的，[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 如果完全缺少值，则不会呈现 JSON “null” 值。为了防止 SQL NULL，应设置默认值。给定以下映射：
- en: '[PRE317]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'The following flush operation will fail with an integrity error:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下刷新操作将因完整性错误而失败：
- en: '[PRE318]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列的默认值应为 JSON NULL，请在 Column 上设置此值：
- en: '[PRE319]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Or, ensure the value is present on the object:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，确保对象上存在该值：
- en: '[PRE320]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为默认设置 `None` 与完全省略它相同；[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 标志不影响传递给 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 或 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的 `None` 的值：
- en: '[PRE321]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: See also
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON “null” 在 ORM 操作中如预期地插入，当不存在时被省略](#change-3514)'
- en: '### Columns no longer added redundantly with DISTINCT + ORDER BY'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 DISTINCT + ORDER BY 不再冗余添加列'
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询现在只会增补那些在 SELECT 列表中缺失的列，而不会重复：
- en: '[PRE322]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'Produces:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE323]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'Previously, it would produce:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，它会产生：
- en: '[PRE324]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`user.name` 列被不必要地添加。结果不会受影响，因为额外的列在任何情况下都不包含在结果中，但这些列是不必要的。
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当通过将表达式传递给[`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct")来使用PostgreSQL DISTINCT ON格式时，上述“添加列”逻辑将完全禁用。
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询被捆绑到子查询中以进行连接式贪婪加载时，“增补列列表”规则必须更加积极，以便仍然可以满足ORDER BY，因此这种情况保持不变。
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)'
- en: '### Same-named @validates decorators will now raise an exception'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '### 相同名称的@validates装饰器现在将引发异常'
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '[`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates "sqlalchemy.orm.validates")装饰器只打算为特定属性名称的类创建一次。现在创建多个会引发错误，而以前它会悄悄地选择最后定义的验证器：'
- en: '[PRE325]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'Will raise:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发：
- en: '[PRE326]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
- en: Key Behavioral Changes - Core
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心的关键行为变化
- en: '### TextClause.columns() will match columns positionally, not by name, when
    passed positionally'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '### TextClause.columns()将按位置匹配列，而不是按名称匹配'
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法的新行为，它本身是在0.9系列中最近添加的，是当列按位置传递而没有任何额外的关键字参数时，它们与最终结果集的列按位置链接，而不再按名称。希望这种变化的影响会很小，因为该方法一直以来都有文档说明传递的列与文本SQL语句的顺序相同，这似乎是直观的，即使内部没有检查这一点。'
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象按位置传递给该方法的应用程序必须确保这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的位置与这些列在文本SQL中声明的位置相匹配。
- en: 'E.g., code like the following:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像下面这样的代码：
- en: '[PRE327]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再按预期工作；给定列的顺序现在很重要：
- en: '[PRE328]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Possibly more likely, a statement that worked like this:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更有可能的是，像这样工作的语句：
- en: '[PRE329]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在略有风险，因为“*”规范通常会按照表本身中的顺序提供列。如果表的结构因模式更改而更改，则此顺序可能不再相同。因此，在使用[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")时，建议在文本SQL中明确列出所需的列，尽管在文本SQL中不再需要担心列名本身。
- en: See also
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)  ### String server_default now literal quoted'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)  ### 字符串 server_default 现在以文本引号引用'
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 作为纯 Python 字符串传递给 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的服务器默认值现在通过文本引用系统传递：
- en: '[PRE330]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的引用会直接渲染。对于存在此类用例并且正在解决此问题的应用程序，此更改可能不兼容。
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### A UNION or similar
    of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes the embedded selects'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### 具有 LIMIT/OFFSET/ORDER
    BY 的 SELECT 的 UNION 或类似结构现在会对嵌入的 SELECT 进行括号化'
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题，就像其他问题一样，长期以来受 SQLite 缺乏功能的驱动，现在已经增强以在所有支持的后端上工作。我们指的是一个查询，它是 SELECT 语句的
    UNION，这些语句本身包含了包含 LIMIT、OFFSET 和/或 ORDER BY 的行限制或排序功能：
- en: '[PRE331]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询需要在每个子查询中加上括号，以便正确地对子结果进行分组。在 SQLAlchemy 核心中生成上述语句的形式如下：
- en: '[PRE332]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，上述结构不会为内部 SELECT 语句产生括号化，从而产生一个在所有后端上都失败的查询。
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在 SQLite 上**仍然会失败**；此外，包含 ORDER BY 但不包含 LIMIT/SELECT 的格式在 Oracle 上**仍然会失败**。这不是一个向后不兼容的更改，因为查询如果没有括号也会失败；有了修复，查询至少在所有其他数据库上可以工作。
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，为了产生一个在 SQLite 上和在所有情况下在 Oracle 上都有效的有限 SELECT 语句的 UNION，子查询必须是一个 ALIAS
    的 SELECT：
- en: '[PRE333]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法适用于所有 SQLAlchemy 版本。在 ORM 中，它的形式如下：
- en: '[PRE334]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为与 SQLAlchemy 0.9 中引入的“join 重写”行为有许多相似之处[许多 JOIN 和 LEFT OUTER JOIN 表达式将不再被包装在
    (SELECT * FROM ..) AS ANON_1 中](migration_09.html#feature-joins-09)；然而，在这种情况下，我们选择不添加新的重写行为以适应
    SQLite 的情况。现有的重写行为已经非常复杂了，而具有带括号的 SELECT 语句的 UNION 的情况比该功能的“右嵌套连接”用例要少得多。
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)  ### TextClause.columns()
    will match columns positionally, not by name, when passed positionally'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)  ### `TextClause.columns()`
    将按位置匹配列，而不是按名称匹配'
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 方法的新行为，它本身是最近添加的0.9系列的一部分，是当列被以位置传递且没有任何额外的关键字参数时，它们链接到最终结果集的列的位置，而不再是按名称。希望由于该方法始终被记录为说明列按照文本SQL语句的相同顺序传递，这个更改的影响会很小，尽管内部并没有检查这一点。'
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的应用程序通过按位置传递 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象来确保这些 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的位置与文本SQL中这些列的位置相匹配。
- en: 'E.g., code like the following:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像下面的代码：
- en: '[PRE335]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 将不再按预期工作；给出的列的顺序现在很重要：
- en: '[PRE336]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Possibly more likely, a statement that worked like this:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 更有可能的是，像这样工作的语句：
- en: '[PRE337]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在稍微有风险，因为“*”规范通常会按照它们在表本身中出现的顺序传送列。如果表的结构因模式更改而更改，则此顺序可能不再相同。因此，在使用 [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") 时，建议在文本SQL中明确列出所需的列，尽管在文本SQL中不再需要担心列名本身。
- en: See also
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '[ResultSet列匹配增强；文本SQL的位置列设置](#change-3501)'
- en: '### String server_default now literal quoted'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '### 字符串 server_default 现在是字面引用'
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的服务器默认值，作为一个带有引号的普通Python字符串，现在通过字面引用系统传递：
- en: '[PRE338]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 以前引号会直接呈现。此更改对于具有这种用例并围绕此问题进行工作的应用程序可能不兼容。
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)'
- en: '### A UNION or similar of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes
    the embedded selects'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '### UNION 或类似 SELECT 的带有 LIMIT/OFFSET/ORDER BY 的现在括号化嵌入式 SELECTs'
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他问题一样，长期受SQLite能力不足的驱动，现在已经增强以在所有支持的后端上工作。我们指的是一个查询，它是SELECT语句的UNION，这些语句本身包含行限制或排序功能，包括LIMIT、OFFSET和/或ORDER
    BY：
- en: '[PRE339]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询要求每个子选择中都要有括号，以便正确分组子结果。在SQLAlchemy Core中生成上述语句如下：
- en: '[PRE340]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，上述结构不会为内部 SELECT 语句产生括号，导致在所有后端上都失败的查询。
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式在 SQLite 上**仍将失败**；此外，包含 ORDER BY 但没有 LIMIT/SELECT 的格式在 Oracle 上**仍将失败**。这不是一个不兼容的更改，因为即使没有括号，查询也会失败；通过修复，查询至少在所有其他数据库上都能正常工作。
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，为了生成一个在 SQLite 上和在所有情况下在 Oracle 上都能正常工作的有限 SELECT 语句的 UNION，子查询必须是一个
    ALIAS 的 SELECT：
- en: '[PRE341]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方法适用于所有 SQLAlchemy 版本。在 ORM 中，它看起来像：
- en: '[PRE342]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为与 SQLAlchemy 0.9 中引入的“连接重写”行为有许多相似之处，[许多 JOIN 和 LEFT OUTER JOIN 表达式将不再被包装在
    (SELECT * FROM ..) AS ANON_1 中](migration_09.html#feature-joins-09)；然而，在这种情况下，我们选择不添加新的重写行为来适应
    SQLite 的情况。现有的重写行为已经非常复杂，而带有括号的 SELECT 语句的 UNION 情况比该功能的“右嵌套连接”用例要少得多。
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-1410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - PostgreSQL
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 自 PostgreSQL 9.5 版本起添加的 `INSERT` 的 `ON CONFLICT` 子句现在可以使用 PostgreSQL 特定版本的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 对象来支持，通过 `sqlalchemy.dialects.postgresql.dml.insert()`。这个
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    子类添加了两个新方法 `Insert.on_conflict_do_update()` 和 `Insert.on_conflict_do_nothing()`，实现了
    PostgreSQL 9.5 在这个领域支持的完整语法：
- en: '[PRE343]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'The above will render:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容将呈现为：
- en: '[PRE344]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: See also
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY and JSON types
    now correctly specify “unhashable”'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY 和 JSON 类型现在正确指定为“不可哈希”'
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [关于“不可哈希”类型的更改，影响 ORM 行的去重](#change-3499) 中描述的，ORM 在查询的选择实体混合了完整的 ORM 实体和列表达式时，依赖于能够为列值生成哈希函数。`hashable=False`
    标志现在已正确设置在 PG 的“数据结构”类型上，包括 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 和 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")。[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 和 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 类型已经包含了此标志。对于 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")，这取决于 [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") 标志，但是现在不再需要设置此标志以使数组值出现在组合的 ORM 行中。
- en: See also
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于“不可哈希”类型的更改，影响 ORM 行的去重](#change-3499)'
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '[从 ARRAY、JSON、HSTORE 的索引访问正确地建立 SQL 类型](#change-3503)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Correct SQL Types
    are Established from Indexed Access of ARRAY, JSON, HSTORE'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### 从 ARRAY、JSON、HSTORE
    的索引访问正确地建立 SQL 类型'
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有三种类型 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")，通过索引访问返回的表达式的 SQL 类型，例如 `col[someindex]`，在所有情况下都应正确。
- en: 'This includes:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 包括：
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于索引访问的 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")，分配的 SQL 类型将考虑配置的维度数量。一个具有三个维度的 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 将返回一个类型为 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 的 SQL 表达式，维度减少一个。给定类型为 `ARRAY(Integer,
    dimensions=3)` 的列，现在我们可以执行以下表达式：
- en: '[PRE345]'
  id: totrans-1427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  id: totrans-1428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，对于 `col[5]` 的索引访问将返回一个 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") 类型的表达式，我们无法再对剩余维度进行索引访问，除非使用 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") 或 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")。
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  id: totrans-1429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")
    和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    类型现在与 PostgreSQL 本身对于索引访问的操作一致。这意味着对于 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 类型的所有索引访问都会返回一个表达式，该表达式本身*始终*是 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 本身，除非使用了 [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符。这意味着，无论 JSON 结构的索引访问最终指向字符串、列表、数字还是其他
    JSON 结构，PostgreSQL 总是将其视为 JSON 本身，除非明确进行了不同的类型转换。与 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型类似，现在可以轻松地生成具有多层索引访问的 JSON 表达式：'
- en: '[PRE346]'
  id: totrans-1430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE346]'
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 的索引访问返回的“文本”类型，以及与[`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符一起返回的[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 的“文本”类型现在是可配置的；在这两种情况下，默认为 [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")，但可以使用 [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") 或 [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") 参数将其设置为用户定义的类型。
- en: See also
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON cast() 操作现在需要显式调用 .astext](#change-3503-cast)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    The JSON cast() operation now requires `.astext` is called explicitly'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    JSON cast() 操作现在需要显式调用 `.astext`'
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[从数组、JSON、HSTORE的索引访问中正确建立SQL类型的更改](#change-3503)的一部分，[`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") 操作符在 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 上不再隐式调用 [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符；PostgreSQL的 JSON/JSONB
    类型支持彼此之间的CAST操作，无需“astext”方面。
- en: 'This means that in most cases, an application that was doing this:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在大多数情况下，一个应用程序正在执行这个操作：
- en: '[PRE347]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'Will now need to change to this:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要更改为：
- en: '[PRE348]  ### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE348]  ### 带有ENUM的数组现在将发出ENUM的CREATE TYPE'
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 表定义如下将会按预期发出CREATE TYPE：
- en: '[PRE349]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'emits:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 发出：
- en: '[PRE350]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
- en: Check constraints now reflect
  id: totrans-1445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查约束现在反映
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在支持检索 CHECK 约束，方法包括 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 和 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 反射中的 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合。
- en: “Plain” and “Materialized” views can be inspected separately
  id: totrans-1447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “Plain” 和 “Materialized” 视图可以分别检查
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数 `PGInspector.get_view_names.include` 允许指定应返回哪些视图子类型：
- en: '[PRE351]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
- en: Added tablespace option to Index
  id: totrans-1451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Index 添加 tablespace 选项
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    对象现在接受参数 `postgresql_tablespace`，以指定 TABLESPACE，与 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象所接受的方式相同。'
- en: See also
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
- en: Support for PyGreSQL
  id: totrans-1456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyGreSQL 的支持
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI 现在得到支持。'
- en: The “postgres” module is removed
  id: totrans-1458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “postgres” 模块已被移除
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.dialects.postgres` 模块，长期弃用，已被移除；多年来一直发出警告，项目应调用 `sqlalchemy.dialects.postgresql`。形式为
    `postgres://` 的 Engine URLs 仍将继续运行。'
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  id: totrans-1460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数 [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") 和 [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") ��� Core 和 ORM 中都应用于
    PostgreSQL 后端的 “SELECT…FOR UPDATE” 或 “SELECT…FOR SHARE” 查询的修改：
- en: 'SELECT FOR NO KEY UPDATE:'
  id: totrans-1462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR NO KEY UPDATE:'
- en: '[PRE352]'
  id: totrans-1463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR UPDATE SKIP LOCKED:'
- en: '[PRE353]'
  id: totrans-1465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'SELECT FOR KEY SHARE:'
  id: totrans-1466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR KEY SHARE:'
- en: '[PRE354]'
  id: totrans-1467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT` 的 `ON CONFLICT` 子句，自 PostgreSQL 版本 9.5 起添加，现在可使用 PostgreSQL 特定版本的
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    对象支持，通过 `sqlalchemy.dialects.postgresql.dml.insert()`。这个 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 子类添加了两个新方法 `Insert.on_conflict_do_update()`
    和 `Insert.on_conflict_do_nothing()`，实现了 PostgreSQL 9.5 在这个领域支持的完整语法：'
- en: '[PRE355]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'The above will render:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容将渲染为：
- en: '[PRE356]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: See also
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)'
- en: '### ARRAY and JSON types now correctly specify “unhashable”'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '### ARRAY 和 JSON 类型现在正确指定“不可哈希”'
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '如[关于“不可哈希”类型的变更，影响了 ORM 行的去重](#change-3499)所述，ORM 在查询的选定实体中混合全 ORM 实体与列表达式时，依赖于能够为列值产生哈希函数。现在，`hashable=False`
    标志已正确设置在所有 PG 的“数据结构”类型上，包括[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")和[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")。[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")和[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 类型已经包括了这个标志。对于[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")，这取决于[`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") 标志，然而，现在应该不再需要设置这个标志，以便在组合的 ORM 行中具有数组值。  '
- en: See also
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于“不可哈希”类型的变更，影响了 ORM 行的去重](#change-3499)'
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '[从 ARRAY、JSON、HSTORE 的索引访问正确建立 SQL 类型](#change-3503)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
- en: '### Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从 ARRAY、JSON、HSTORE 的索引访问正确建立 SQL 类型'
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")、[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")三者，通过索引访问返回的表达式所分配的 SQL 类型，例如 `col[someindex]`，在所有情况下都应该是正确的。
- en: 'This includes:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括：
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")的索引访问所分配的 SQL 类型将考虑到配置的维度数量。一个具有三个维度的[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")将返回一个维度少一的[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")的 SQL 表达式类型。给定一个类型为 `ARRAY(Integer, dimensions=3)`
    的列，我们现在可以执行这个表达式：
- en: '[PRE357]'
  id: totrans-1486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE357]'
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  id: totrans-1487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，对于 `col[5]` 的索引访问将返回一个 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") 类型的表达式，我们无法再对剩余维度进行索引访问，除非使用 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") 或 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")。
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  id: totrans-1488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")
    和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    类型现在与 PostgreSQL 本身对于索引访问的操作一致。这意味着对于 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 类型的所有索引访问都会返回一个表达式，该表达式本身*始终*是 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 或 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 本身，除非使用了 [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符。这意味着，无论 JSON 结构的索引访问最终指向字符串、列表、数字还是其他
    JSON 结构，PostgreSQL 总是将其视为 JSON 本身，除非明确进行了不同的类型转换。与 [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型类似，现在可以轻松地生成具有多层索引访问的 JSON 表达式：'
- en: '[PRE358]'
  id: totrans-1489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE358]'
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  id: totrans-1490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对 [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") 的索引访问返回的“文本”类型，以及通过对 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 的索引访问返回的“文本”类型，再结合 [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符，现在是可配置的；在这两种情况下，默认为
    [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")，但可以使用
    [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") 或 [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") 参数将其设置为用户定义的类型。
- en: See also
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '[JSON cast() 操作现在需要显式调用 .astext](#change-3503-cast)'
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)'
- en: '### The JSON cast() operation now requires `.astext` is called explicitly'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '### JSON cast() 操作现在需要显式调用 `.astext`'
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [从数组、JSON、HSTORE 的索引访问正确建立 SQL 类型的更改](#change-3503) 的一部分，[`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") 操作在 [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") 和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") 上不再隐式调用 [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") 修饰符；PostgreSQL 的 JSON/JSONB
    类型支持彼此之间的 CAST 操作，无需 "astext" 方面。
- en: 'This means that in most cases, an application that was doing this:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在大多数情况下，一个应用程序如果在做这个操作：
- en: '[PRE359]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Will now need to change to this:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要更改为：
- en: '[PRE360]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: '### 带有 ENUM 的数组现在会发出 CREATE TYPE 用于 ENUM'
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下的表定义现在会按预期发出 CREATE TYPE：
- en: '[PRE361]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'emits:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 发出：
- en: '[PRE362]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
- en: Check constraints now reflect
  id: totrans-1506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查约束现在反映
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 方言现在支持反射 CHECK 约束，方法包括 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 以及 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 反射中的 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合。
- en: “Plain” and “Materialized” views can be inspected separately
  id: totrans-1508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可以单独检查“普通”和“物化”视图
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数 `PGInspector.get_view_names.include` 允许指定应返回哪些视图子类型：
- en: '[PRE363]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
- en: Added tablespace option to Index
  id: totrans-1512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 Index 添加 tablespace 选项
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    对象现在接受参数 `postgresql_tablespace`，以指定 TABLESPACE，与 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象接受的方式相同。'
- en: See also
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引存储参数](../dialects/postgresql.html#postgresql-index-storage)'
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
- en: Support for PyGreSQL
  id: totrans-1517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 PyGreSQL 的支持
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI 现在受支持。'
- en: The “postgres” module is removed
  id: totrans-1519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “postgres” 模块已移除
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 长期弃用的 `sqlalchemy.dialects.postgres` 模块已被移除；多年来一直发出警告，项目应该调用 `sqlalchemy.dialects.postgresql`。形式为
    `postgres://` 的 Engine URLs 仍将继续运行。
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  id: totrans-1521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: Core 和 ORM 中的新参数 [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") 和 [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") 在 PostgreSQL 后端上对
    “SELECT…FOR UPDATE” 或 “SELECT…FOR SHARE” 查询应用修改：
- en: 'SELECT FOR NO KEY UPDATE:'
  id: totrans-1523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR NO KEY UPDATE:'
- en: '[PRE364]'
  id: totrans-1524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  id: totrans-1525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR UPDATE SKIP LOCKED:'
- en: '[PRE365]'
  id: totrans-1526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'SELECT FOR KEY SHARE:'
  id: totrans-1527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELECT FOR KEY SHARE:'
- en: '[PRE366]'
  id: totrans-1528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE366]'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-1529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - MySQL
- en: '### MySQL JSON Support'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL JSON 支持'
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 新类型 [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    已添加到 MySQL 方言，支持 MySQL 5.7 新增的 JSON 类型。该类型提供 JSON 的持久性以及内部使用 `JSON_EXTRACT` 函数进行基本索引访问。通过使用
    MySQL 和 PostgreSQL 共同的 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，可以实现跨 MySQL 和 PostgreSQL 的可索引 JSON 列。
- en: See also
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[JSON support added to Core](#change-3619)'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '[核心中添加的 JSON 支持](#change-3619)'
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### Added support for
    AUTOCOMMIT “isolation level”'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### 增加了对 AUTOCOMMIT “隔离级别”的支持'
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言现在接受值“AUTOCOMMIT”作为 [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") 和 [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") 参数：
- en: '[PRE367]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别利用大多数 MySQL DBAPI 提供的各种“autocommit”属性。
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### No more generation
    of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### 不再为具有 AUTO_INCREMENT
    的复合主键生成隐式 KEY'
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言的行为是，如果 InnoDB 表上的复合主键中的一个列具有 AUTO_INCREMENT 但不是第一列，例如：
- en: '[PRE368]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'DDL such as the following would be generated:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 会生成如下的 DDL：
- en: '[PRE369]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上述带有自动生成名称的“KEY”；这是多年前针对 AUTO_INCREMENT 在 InnoDB 上否则会失败的问题而进入方言的变更。
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法已被移除，并替换为更好的系统，即在主键中仅将 AUTO_INCREMENT 列 *放在第一位*：
- en: '[PRE370]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确控制主键列的排序，请显式使用 [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") 构造（1.1.0b2）（以及根据 MySQL 要求的自动增量列的 KEY），例如：
- en: '[PRE371]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变更 [不再为复合主键列隐式启用 .autoincrement 指令](#change-3216) 外，现在更容易指定具有或不具有自动增量的复合主键；[`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") 现在默认为值 `"auto"`，不再需要 `autoincrement=False` 指令：
- en: '[PRE372]  ### MySQL JSON Support'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE372]  ### MySQL JSON 支持'
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言现在支持新增于 MySQL 5.7 的 JSON 类型，为此添加了一种新类型 [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")。该类型提供了 JSON 的持久性以及内部使用 `JSON_EXTRACT` 函数进行基本索引访问。通过使用在
    MySQL 和 PostgreSQL 中通用的 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，可以实现跨 MySQL 和 PostgreSQL 的可索引 JSON 列。
- en: See also
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[JSON support added to Core](#change-3619)'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: '[核心中添加的 JSON 支持](#change-3619)'
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)'
- en: '### Added support for AUTOCOMMIT “isolation level”'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '### 增加了对 AUTOCOMMIT “隔离级别”的支持'
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言现在接受值“AUTOCOMMIT”作为[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")和[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")参数：
- en: '[PRE373]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别利用大多数MySQL DBAPI提供的各种“autocommit”属性。
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)'
- en: '### No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '### 不再为具有AUTO_INCREMENT的复合主键生成隐式KEY'
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言的行为是，如果InnoDB表上的复合主键中的一个列具有AUTO_INCREMENT且不是第一列，例如：
- en: '[PRE374]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'DDL such as the following would be generated:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下DDL：
- en: '[PRE375]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上述带有自动生成名称的“KEY”；这是多年前为了解决AUTO_INCREMENT在InnoDB上否则会失败的问题而引入的方言变化。
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方法已被移除，并用更好的系统替代，即在主键中首先声明AUTO_INCREMENT列：
- en: '[PRE376]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确控制主键列的顺序，请显式使用[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")构造（1.1.0b2）（以及MySQL所需的自动增量列的KEY），例如：
- en: '[PRE377]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随着变化[.autoincrement指令不再隐式启用复合主键列](#change-3216)，现在更容易指定具有或不具有自动增量的复合主键；[`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column")现在默认为值`"auto"`，不再需要`autoincrement=False`指令：
- en: '[PRE378]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-1571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQLite
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQLite版本3.7.16解决的右嵌套连接问题'
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 版本中，由 [许多 JOIN 和 LEFT OUTER JOIN 表达式将不再被包装在 (SELECT * FROM ..) AS ANON_1
    中](migration_09.html#feature-joins-09) 引入的功能经历了大量努力，以支持在 SQLite 上重写连接以始终使用子查询以实现“右嵌套连接”效果，因为多年来
    SQLite 并不支持这种语法。具有讽刺意味的是，在该迁移说明中指出的 SQLite 版本 3.7.15.2，实际上是 SQLite 最后一个具有这种限制的版本！下一个版本是
    3.7.16，支持右嵌套连接被悄悄地添加了进去。在 1.1 版本中，已经完成了识别特定 SQLite 版本和源提交的工作，这个变化的解决方案现在在 SQLite
    报告版本 3.7.16 或更高版本时被取消。
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### Dotted column names
    workaround lifted for SQLite version 3.10.0'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### 取消 SQLite 版本 3.10.0
    中的带点列名变通方法'
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 方言长期以来一直存在一个问题的变通方法，即数据库驱动程序在某些 SQL 结果集中没有报告正确的列名，特别是在使用 UNION 时。这个变通方法在
    [带点的列名](../dialects/sqlite.html#sqlite-dotted-column-names) 中有详细说明，并要求 SQLAlchemy
    假定任何带有点的列名实际上是通过这种错误行为传递的 `tablename.columnname` 组合，可以通过 `sqlite_raw_colnames`
    执行选项关闭这个选项。
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 SQLite 版本 3.10.0，UNION 和其他查询中的错误已经修复；就像 [SQLite 版本 3.7.16 中取消右嵌套连接的变通方法](#change-3634)
    中描述的变化一样，SQLite 的变更日志只将其神秘地标识为“为 sqlite3_module.xBestIndex 方法添加了 colUsed 字段”，但是
    SQLAlchemy 对这些带点的列名的转换在这个版本中不再需要，因此当检测到版本 3.10.0 或更高版本时会关闭这个功能。
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，截至 1.0 系列，SQLAlchemy 的 `ResultProxy` 在为 Core 和 ORM SQL 结构提供结果时，对列名的依赖要少得多，因此这个问题的重要性在任何情况下都已经降低了。
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### Improved Support
    for Remote Schemas'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### 改进对远程模式的支持'
- en: 'The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.  ###
    Reflection of the name of PRIMARY KEY constraints'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 方言现在实现了 [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names")，并且对于从远程模式创建和反映的表和索引提供了改进的支持，在
    SQLite 中，远程模式是通过 `ATTACH` 语句分配名称的数据库；先前，``CREATE INDEX`` DDL 对于模式绑定表不起作用，并且 [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") 方法现在将在结果中指示给定的模式。不支持跨模式外键。###
    主键约束名称的反射
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 后端现在利用 SQLite 的“sqlite_master”视图来提取表的原始 DDL 中主键约束的名称，这与 SQLAlchemy 的最新版本中用于提取外键约束的方式相同。
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
- en: Check constraints now reflect
  id: totrans-1582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查约束现在反映
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 方言现在支持检查约束的反射，包括在方法 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 内以及在 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 反映中的 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合内。
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  id: totrans-1584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ON DELETE 和 ON UPDATE 外键短语现在反映
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 现在将包括来自 SQLite 方言的外键约束的 ON DELETE 和
    ON UPDATE 短语，并且作为 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的一部分反映的 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象也将指示这些短语。'
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '### 右嵌套连接解决方案针对 SQLite 版本 3.7.16 解除'
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 0.9 中，由 [许多 JOIN 和 LEFT OUTER JOIN 表达式将不再被包裹在 (SELECT * FROM ..) AS ANON_1
    中](migration_09.html#feature-joins-09) 引入的功能经历了大量努力，以支持在 SQLite 上重写连接以始终使用子查询以实现“右嵌套连接”效果，因为
    SQLite 多年来一直不支持这种语法。具有讽刺意味的是，在迁移说明中指出的 SQLite 版本 3.7.15.2 实际上是 SQLite 最后一个具有这种限制的版本！下一个发布版本是
    3.7.16，支持右嵌套连接被悄悄地添加了进去。在 1.1 中，已经完成了识别特定 SQLite 版本和源提交的工作，其中进行了这一更改（SQLite 的更改日志用神秘的短语“增强查询优化器以利用传递连接约束”来指称，没有链接到任何问题编号、更改编号或进一步解释），并且当
    DBAPI 报告版本 3.7.16 或更高版本生效时，此更改中存在的变通方法现在已经被取消了。
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)'
- en: '### Dotted column names workaround lifted for SQLite version 3.10.0'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '### 取消 SQLite 版本 3.10.0 中的带点列名变通方法'
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 方言长期以来一直有一个解决方案，用于解决数据库驱动程序在某些 SQL 结果集中未报告正确列名的问题，特别是在使用 UNION 时。这个解决方案在
    [带点列名](../dialects/sqlite.html#sqlite-dotted-column-names) 中有详细说明，并要求 SQLAlchemy
    假定任何带有点的列名实际上是通过这种错误行为传递的 `tablename.columnname` 组合，可以通过 `sqlite_raw_colnames`
    执行选项关闭这个选项。
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 SQLite 版本 3.10.0，UNION 和其他查询中的错误已经修复；就像 [SQLite 版本 3.7.16 中取消右嵌套连接变通方法](#change-3634)
    中描述的更改一样，SQLite 的更改日志只将其神秘地标识为“为 sqlite3_module.xBestIndex 方法添加了 colUsed 字段”，然而
    SQLAlchemy 对这些带点的列名的转换在此版本中不再需要，因此当检测到版本 3.10.0 或更高版本时，将其关闭。
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在 1.0 系列中的 SQLAlchemy `ResultProxy` 在为 Core 和 ORM SQL 结构提供结果时，对列名的依赖要少得多，因此这个问题的重要性在任何情况下已经降低了。
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)'
- en: '### Improved Support for Remote Schemas'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进对远程模式的支持'
- en: The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言现在实现了[`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names")，并且对于从远程模式创建和反映的表和索引提供了改进的支持，在SQLite中，远程模式是通过`ATTACH`语句分配名称的数据库；以前，``CREATE
    INDEX`` DDL对于绑定模式表的情况无法正确工作，而[`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")方法现在将在结果中指示给定的模式。不支持跨模式外键。
- en: '### Reflection of the name of PRIMARY KEY constraints'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '### 反映主键约束的名称'
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite后端现在利用SQLite的“sqlite_master”视图，以从原始DDL中提取表的主键约束的名称，就像最近SQLAlchemy版本中为外键约束所实现的方式一样。
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
- en: Check constraints now reflect
  id: totrans-1599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查约束现在反映
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言现在支持在方法[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")以及在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")反映中的[`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints")集合中反映CHECK约束。
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  id: totrans-1601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ON DELETE和ON UPDATE外键短语现在反映
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")现在将包括SQLite方言上外键约束的ON DELETE和ON UPDATE短语，并且作为[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的一部分反映的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象也将指示这些短语。'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-1603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - SQL Server
- en: '### Added transaction isolation level support for SQL Server'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为SQL Server添加了事务隔离级别支持'
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SQL Server方言都支持通过[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")和[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")参数设置事务隔离级别。四个标准级别以及`SNAPSHOT`都受支持：
- en: '[PRE379]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: See also
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '[事务隔离级别](../dialects/mssql.html#mssql-isolation-level)'
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### String / varlength
    types no longer represent “max” explicitly on reflection'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### 反射时字符串/可变长度类型不再明确表示“max”'
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 当反射诸如[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")、[`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")等包含长度的类型时，在 SQL Server 下，“无长度”类型将复制“length”参数作为值`"max"`：
- en: '[PRE380]'
  id: totrans-1611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型中的“length”参数预期只能是整数值或`None`；`None`表示无限长度，SQL Server 方言将其解释为“max”。修复方法是将这些长度输出为`None`，以便类型对象在非
    SQL Server 上下文中正常工作：
- en: '[PRE381]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一直依赖于将“length”值直接与字符串“max”进行比较的应用程序应该考虑将值设为`None`表示相同的含义。
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  id: totrans-1616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在主键上使用“非聚集”以允许在其他地方进行聚集
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")、[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 上可用的 `mssql_clustered` 标志现在默认为 `None`，可以设置为 False，这将特别为主键渲染
    `NONCLUSTERED` 关键字，允许使用不同的索引作为“聚集”。'
- en: See also
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '[聚集索引支持](../dialects/mssql.html#mssql-indexes)'
- en: '### The legacy_schema_aliasing flag is now set to False'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '### `legacy_schema_aliasing` 标志现在设置为 False'
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.0.5 引入了 `legacy_schema_aliasing` 标志到 MSSQL 方言，允许关闭所谓的“传统模式”别名。这种别名尝试将模式限定的表转换为别名；给定一个表如下：
- en: '[PRE382]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 传统行为模式将尝试将模式限定的表名转换为别名：
- en: '[PRE383]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，已经证明这种别名是不必要的，在许多情况下会产生不正确的 SQL。
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 1.1 中，`legacy_schema_aliasing` 标志现在默认为 False，禁用此行为模式，并允许 MSSQL
    方言以模式限定的表正常运行。对于可能依赖此行为的应用程序，请将标志设置回 True。
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)  ### Added transaction
    isolation level support for SQL Server'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)  ### 为 SQL Server 添加了事务隔离级别支持'
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SQL Server方言都支持通过[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")和[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")参数设置事务隔离级别。四个标准级别都受支持，以及`SNAPSHOT`：
- en: '[PRE384]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: See also
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '[事务隔离级别](../dialects/mssql.html#mssql-isolation-level)'
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)'
- en: '### String / varlength types no longer represent “max” explicitly on reflection'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '### 字符串/可变长度类型不再在反射时显式表示“max”'
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 当反射像[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")、[`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")等包含长度的类型时，SQL Server下的“无长度”类型会将“长度”参数复制为值`"max"`：
- en: '[PRE385]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型中的“长度”参数预期只是一个整数值或仅为None；None表示无界长度，而SQL Server方言将其解释为“max”。因此修复这些长度为None，以便类型对象在非SQL
    Server上下文中工作：
- en: '[PRE386]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 可能已经依赖将“长度”值直接与字符串“max”进行比较的应用程序应考虑将值`None`视为相同的含义。
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  id: totrans-1640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在其他地方集群化以允许主键上的“非聚集”
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")、[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")上可用的`mssql_clustered`标志默认为`None`，并且可以设置为False，这将在特定情况下渲染NONCLUSTERED关键字用于主键，允许使用不同的索引作为“集群化”。
- en: See also
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '[集群索引支持](../dialects/mssql.html#mssql-indexes)'
- en: '### The legacy_schema_aliasing flag is now set to False'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '### `legacy_schema_aliasing`标志现在设置为False'
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.0.5引入了`legacy_schema_aliasing`标志到MSSQL方言中，允许所谓的“遗留模式”别名化被关闭。这种别名化试图将架构限定的表转换为别名；给定这样一个表：
- en: '[PRE387]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 行为的遗留模式将尝试将架构限定的表名转换为别名：
- en: '[PRE388]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种别名化已被证明是不必要的，并且在许多情况下会产生不正确的SQL。
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 1.1 中，`legacy_schema_aliasing`标志现在默认为 False，禁用此行为模式，允许 MSSQL 方言与模式限定的表正常运行。对于可能依赖此行为的应用程序，请将标志设置回
    True。
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-1652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - Oracle
- en: Support for SKIP LOCKED
  id: totrans-1653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 SKIP LOCKED
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Core 和 ORM 中的新参数[`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")将为“SELECT…FOR UPDATE”或“SELECT..
    FOR SHARE”查询生成“SKIP LOCKED”后缀。
- en: Support for SKIP LOCKED
  id: totrans-1655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 SKIP LOCKED
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Core 和 ORM 中的新参数[`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update")将为“SELECT…FOR UPDATE”或“SELECT..
    FOR SHARE”查询生成“SKIP LOCKED”后缀。
