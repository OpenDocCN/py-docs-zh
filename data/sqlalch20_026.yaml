- en: Mapping Class Inheritance Hierarchies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类继承层次结构
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/inheritance.html](https://docs.sqlalchemy.org/en/20/orm/inheritance.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/inheritance.html](https://docs.sqlalchemy.org/en/20/orm/inheritance.html)
- en: 'SQLAlchemy supports three forms of inheritance:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 支持三种继承形式：
- en: '**single table inheritance** – several types of classes are represented by
    a single table;'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单表继承** – 几种类别的类别由单个表表示；'
- en: '**concrete table inheritance** – each type of class is represented by independent
    tables;'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体表继承** – 每种类别的类别都由独立的表表示；'
- en: '**joined table inheritance** – the class hierarchy is broken up among dependent
    tables. Each class represented by its own table that only includes those attributes
    local to that class.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联接表继承** – 类层次结构在依赖表之间分解。每个类由其自己的表表示，该表仅包含该类本地的属性。'
- en: The most common forms of inheritance are single and joined table, while concrete
    inheritance presents more configurational challenges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的继承形式是单一和联接表，而具体继承则提出了更多的配置挑战。
- en: When mappers are configured in an inheritance relationship, SQLAlchemy has the
    ability to load elements [polymorphically](../glossary.html#term-polymorphically),
    meaning that a single query can return objects of multiple types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射器配置在继承关系中时，SQLAlchemy 有能力以[多态方式](../glossary.html#term-polymorphically)加载元素，这意味着单个查询可以返回多种类型的对象。
- en: See also
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html#loading-joined-inheritance)
    - in the [ORM Querying Guide](queryguide/index.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[为继承映射编写 SELECT 语句](queryguide/inheritance.html#loading-joined-inheritance)
    - 在 [ORM 查询指南](queryguide/index.html) 中'
- en: '[Inheritance Mapping Recipes](examples.html#examples-inheritance) - complete
    examples of joined, single and concrete inheritance'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[继承映射示例](examples.html#examples-inheritance) - 联接、单一和具体继承的完整示例'
- en: '## Joined Table Inheritance'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '## 联接表继承'
- en: In joined table inheritance, each class along a hierarchy of classes is represented
    by a distinct table. Querying for a particular subclass in the hierarchy will
    render as a SQL JOIN along all tables in its inheritance path. If the queried
    class is the base class, the base table is queried instead, with options to include
    other tables at the same time or to allow attributes specific to sub-tables to
    load later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在联接表继承中，沿着类层次结构的每个类都由一个不同的表表示。对类层次结构中特定子类的查询将作为 SQL JOIN 在其继承路径上的所有表之间进行。如果查询的类是基类，则查询基表，同时可以选择包含其他表或允许后续加载特定于子表的属性的选项。
- en: In all cases, the ultimate class to instantiate for a given row is determined
    by a [discriminator](../glossary.html#term-discriminator) column or SQL expression,
    defined on the base class, which will yield a scalar value that is associated
    with a particular subclass.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，对于给定行要实例化的最终类由基类上定义的[鉴别器](../glossary.html#term-discriminator)列或 SQL
    表达式确定，该列将生成与特定子类关联的标量值。
- en: 'The base class in a joined inheritance hierarchy is configured with additional
    arguments that will indicate to the polymorphic discriminator column, and optionally
    a polymorphic identifier for the base class itself:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 联接继承层次结构中的基类将配置具有指示多态鉴别器列以及可选地为基类本身配置的多态标识符的其他参数：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the above example, the discriminator is the `type` column, whichever is configured
    using the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter. This parameter accepts a column-oriented expression,
    specified either as a string name of the mapped attribute to use or as a column
    expression object such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，鉴别器是 `type` 列，可以使用 [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") 参数进行配置。该参数接受一个面向列的表达式，可以指定为要使用的映射属性的字符串名称，也可以指定为列表达式对象，如
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    或 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造。
- en: The discriminator column will store a value which indicates the type of object
    represented within the row. The column may be of any datatype, though string and
    integer are the most common. The actual data value to be applied to this column
    for a particular row in the database is specified using the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter, described below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴别器列将存储指示行内表示的对象类型的值。该列可以是任何数据类型，但字符串和整数是最常见的。要为数据库中的特定行应用到该列的实际数据值是使用下面描述的
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") 参数指定的。
- en: While a polymorphic discriminator expression is not strictly necessary, it is
    required if polymorphic loading is desired. Establishing a column on the base
    table is the easiest way to achieve this, however very sophisticated inheritance
    mappings may make use of SQL expressions, such as a CASE expression, as the polymorphic
    discriminator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多态鉴别器表达式不是严格必需的，但如果需要多态加载，则需要它。在基础表上建立列是实现这一点的最简单方法，然而非常复杂的继承映射可能会使用 SQL 表达式，例如
    CASE 表达式，作为多态鉴别器。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, **only one discriminator column or SQL expression may be configured
    for the entire inheritance hierarchy**, typically on the base- most class in the
    hierarchy. “Cascading” polymorphic discriminator expressions are not yet supported.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**整个继承层次结构只能配置一个鉴别器列或 SQL 表达式**，通常在层次结构中最基本的类上。暂时不支持“级联”多态鉴别器表达式。
- en: 'We next define `Engineer` and `Manager` subclasses of `Employee`. Each contains
    columns that represent the attributes unique to the subclass they represent. Each
    table also must contain a primary key column (or columns), as well as a foreign
    key reference to the parent table:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义 `Engineer` 和 `Manager` 的 `Employee` 子类。每个类包含代表其所代表的子类的唯一属性的列。每个表还必须包含一个主键列（或列），以及对父表的外键引用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above example, each mapping specifies the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter within its mapper arguments. This value populates
    the column designated by the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter established on the base mapper. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter should be unique to each mapped class across
    the whole hierarchy, and there should only be one “identity” per mapped class;
    as noted above, “cascading” identities where some subclasses introduce a second
    identity are not supported.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，每个映射都在其映射器参数中指定了[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数。此值填充了基础映射器上建立的[`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper")参数指定的列。每个映射类的[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数应在整个层次结构中是唯一的，并且每个映射类应只有一个“标识”；如上所述，“级联”标识不支持一些子类引入第二个标识的情况。
- en: The ORM uses the value set up by [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") in order to determine which class a row belongs towards
    when loading rows polymorphically. In the example above, every row which represents
    an `Employee` will have the value `'employee'` in its `type` column; similarly,
    every `Engineer` will get the value `'engineer'`, and each `Manager` will get
    the value `'manager'`. Regardless of whether the inheritance mapping uses distinct
    joined tables for subclasses as in joined table inheritance, or all one table
    as in single table inheritance, this value is expected to be persisted and available
    to the ORM when querying. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter also applies to concrete table inheritance,
    but is not actually persisted; see the later section at [Concrete Table Inheritance](#concrete-inheritance)
    for details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ORM使用由[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")设置的值来确定加载行的多态时行属于哪个类。在上面的示例中，每个代表`Employee`的行将在其`type`列中具有值`'employee'`；类似地，每个`Engineer`将获得值`'engineer'`，每个`Manager`将获得值`'manager'`。无论继承映射是否为子类使用不同的连接表（如连接表继承）或所有一个表（如单表继承），这个值都应该被持久化并在查询时对ORM可用。[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数也适用于具体表继承，但实际上并没有持久化；有关详细信息，请参阅后面的[具体表继承](#concrete-inheritance)部分。
- en: In a polymorphic setup, it is most common that the foreign key constraint is
    established on the same column or columns as the primary key itself, however this
    is not required; a column distinct from the primary key may also be made to refer
    to the parent via foreign key. The way that a JOIN is constructed from the base
    table to subclasses is also directly customizable, however this is rarely necessary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在多态设置中，最常见的是外键约束建立在与主键本身相同的列或列上，但这并非必需；也可以使与主键不同的列引用到父级的外键。从基表到子类的JOIN的构建方式也是可直接自定义的，但这很少是必要的。
- en: With the joined inheritance mapping complete, querying against `Employee` will
    return a combination of `Employee`, `Engineer` and `Manager` objects. Newly saved
    `Engineer`, `Manager`, and `Employee` objects will automatically populate the
    `employee.type` column with the correct “discriminator” value in this case `"engineer"`,
    `"manager"`, or `"employee"`, as appropriate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接继承映射完成后，针对`Employee`的查询将返回`Employee`、`Engineer`和`Manager`对象的组合。新保存的`Engineer`、`Manager`和`Employee`对象在这种情况下将自动填充`employee.type`列中的正确“识别器”值，如`"engineer"`、`"manager"`或`"employee"`。
- en: Relationships with Joined Inheritance
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用连接继承的关系
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接表继承完全支持关系。涉及连接继承类的关系应该针对在层次结构中也对应于外键约束的类；在下面的示例中，由于`employee`表有一个回到`company`表的外键约束，因此关系被设置在`Company`和`Employee`之间：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外键约束在对应于子类的表上，关系应该指向该子类。在下面的示例中，有一个从`manager`到`company`的外键约束，因此关系建立在`Manager`和`Company`类之间：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Manager`类将有一个`Manager.company`属性；`Company`将有一个`Company.managers`属性，总是对`employee`和`manager`表一起加载。
- en: Loading Joined Inheritance Mappings
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载连接继承映射
- en: 'See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.  ## Single
    Table Inheritance'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[编写继承映射的SELECT语句](queryguide/inheritance.html)部分，了解关于继承加载技术的背景，包括在映射器配置时间和查询时间配置要查询的表。##
    单表继承
- en: Single table inheritance represents all attributes of all subclasses within
    a single table. A particular subclass that has attributes unique to that class
    will persist them within columns in the table that are otherwise NULL if the row
    refers to a different kind of object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承在单个表中表示所有子类的所有属性。具有唯一于该类的属性的特定子类将在表中的列中保留它们，如果行引用了不同类型的对象，则这些列将为空。
- en: Querying for a particular subclass in the hierarchy will render as a SELECT
    against the base table, which will include a WHERE clause that limits rows to
    those with a particular value or values present in the discriminator column or
    expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中查询特定子类将呈现为针对基表的SELECT查询，其中将包括一个WHERE子句，该子句限制行为具有鉴别器列或表达式中存在的特定值或值的行。
- en: Single table inheritance has the advantage of simplicity compared to joined
    table inheritance; queries are much more efficient as only one table needs to
    be involved in order to load objects of every represented class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承相对于联接表继承具有简单性的优势；查询要高效得多，因为只需要涉及一个表来加载每个表示类的对象。
- en: Single-table inheritance configuration looks much like joined-table inheritance,
    except only the base class specifies `__tablename__`. A discriminator column is
    also required on the base table so that classes can be differentiated from each
    other.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承配置看起来很像联接表继承，除了只有基类指定了`__tablename__`。还需要在基表上有一个鉴别器列，以便类可以彼此区分。
- en: 'Even though subclasses share the base table for all of their attributes, when
    using Declarative, [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects may still be specified on subclasses,
    indicating that the column is to be mapped only to that subclass; the [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be applied to the same base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使子类共享所有属性的基表，在使用声明性时，仍然可以在子类上指定[`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")对象，指示该列仅映射到该子类；[`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")将应用于相同的基本[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the mappers for the derived classes Manager and Engineer omit the
    `__tablename__`, indicating they do not have a mapped table of their own. Additionally,
    a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with `nullable=True` is included; as the Python types declared for these
    classes do not include `Optional[]`, the column would normally be mapped as `NOT
    NULL`, which would not be appropriate as this column only expects to be populated
    for those rows that correspond to that particular subclass.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，派生类Manager和Engineer的映射器省略了`__tablename__`，这表明它们没有自己的映射表。另外，包含了一个带有`nullable=True`的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令；由于为这些类声明的Python类型不包括`Optional[]`，因此该列通常被映射为`NOT
    NULL`，这对于该列只期望被填充为那些对应于该特定子类的行并不合适。
- en: '### Resolving Column Conflicts with `use_existing_column`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用`use_existing_column`解决列冲突'
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上一节中，`manager_name`和`engineer_info`列被“上移”以应用于`Employee.__table__`，因为它们在没有自己的表的子类上声明。当两个子类想要指定*相同*的列时，就会出现一个棘手的情况，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，在`Engineer`和`Manager`上声明的`start_date`列将导致错误：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景对声明式映射系统存在一种模糊性，可以通过在[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")上使用[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")参数来解决，该参数指示[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")在存在继承的超类时查找并使用已经映射的列，如果已经存在，则映射一个新列：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子中，当 `Manager` 被映射时，`start_date` 列已经存在于 `Employee` 类中，已经由 `Engineer` 映射提供。[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")参数指示 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 应首先在 `Employee` 的映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中查找请求的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，如果存在，则保持该现有映射。如果不存在，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")将正常映射列，将其添加为由 `Employee` 超类引用的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中的列之一。
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.0.0b4 中新增：- 添加了[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")，提供了一种在继承子类上有条件地映射列的 2.0 兼容方法。之前的方法结合了 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 和对父类 `.__table__` 的查找，仍然可以正常工作，但缺乏[**PEP 484**](https://peps.python.org/pep-0484/)的类型支持。
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似的概念来定义特定系列的列和/或其他可重复使用的混合类中的映射属性（请参阅[使用混合类组合映射层次结构](declarative_mixins.html)）：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Relationships with Single Table Inheritance
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单表继承关系
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关系完全支持单表继承。配置方式与连接继承的方式相同；外键属性应该在关系的“外键”一侧的同一类上：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于连接继承的情况，我们可以创建涉及特定子类的关系。在查询时，SELECT 语句将包括一个 WHERE 子句，将类选择限制为该子类或子类：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Manager`类将具有`Manager.company`属性；`Company`将具有一个`Company.managers`属性，该属性始终针对`employee`加载，并附加一个WHERE子句，限制行为具有`type
    = 'manager'`的行。
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用`polymorphic_abstract`构建更深层次的层次结构'
- en: New in version 2.0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中新增。
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何类型的继承层次结构时，映射类可以包括设置为`True`的[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")参数，这表明该类应该被正常映射，但不希望直接实例化，并且不包括[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。然后可以声明这个映射类的子类，这些子类本身可以包括一个[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")，因此可以正常使用。这允许一系列子类被一个通用的基类引用，该基类在层次结构中被视为“抽象”，在查询和[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")声明中都是如此。这种用法与在 Declarative 中使用[__abstract__](declarative_config.html#declarative-abstract)属性不同，后者将目标类完全取消映射，因此无法单独作为映射类使用。[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")可以应用于层次结构中的任何类或类，包括同时应用于多个级别的类。
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`Manager`和`Principal`都被分类到一个超类`Executive`，而`Engineer`和`Sysadmin`被分类到一个超类`Technologist`。`Executive`和`Technologist`都不会被实例化，因此没有[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。可以使用[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")来配置这些类，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，新的类 `Technologist` 和 `Executive` 都是普通的映射类，并且还指示要添加到超类的新列 `executive_background`
    和 `competencies`。然而，它们都缺少对 [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") 的设置；这是因为不希望直接实例化 `Technologist` 或 `Executive`；我们总是会有
    `Manager`、`Principal`、`Engineer` 或 `SysAdmin` 中的一个。然而，我们可以查询 `Principal` 和 `Technologist`
    角色，并且让它们成为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的目标。下面的示例演示了对 `Technologist` 对象的 SELECT 语句：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Technologist` 和 `Executive` 的抽象映射类也可以作为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射的目标，就像任何其他映射类一样。我们可以扩展上面的示例，包括 `Company`，其中包含单独的集合
    `Company.technologists` 和 `Company.principals`：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，我们可以分别跨 `Company.technologists` 和 `Company.executives` 使用联接和关系加载技术：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[__abstract__](declarative_config.html#declarative-abstract) - 声明参数，允许在继承层次结构中完全取消映射声明的类，同时仍然继承自映射的超类。'
- en: Loading Single Inheritance Mappings
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载单表继承映射
- en: 'The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.  ##
    Concrete Table Inheritance'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承的加载技术与连接表继承的加载技术大部分相同，并且提供了这两种映射类型之间的高度抽象，因此很容易在它们之间切换，以及在单个继承层次结构中混合使用它们（只需从要单继承的子类中省略
    `__tablename__`）。请参阅[编写用于继承映射的 SELECT 语句](queryguide/inheritance.html)和[单表继承映射的
    SELECT 语句](queryguide/inheritance.html#loading-single-inheritance)章节，了解有关继承加载技术的文档，包括在映射器配置时间和查询时间配置要查询的类。##
    具体表继承
- en: Concrete inheritance maps each subclass to its own distinct table, each of which
    contains all columns necessary to produce an instance of that class. A concrete
    inheritance configuration by default queries non-polymorphically; a query for
    a particular class will only query that class’ table and only return instances
    of that class. Polymorphic loading of concrete classes is enabled by configuring
    within the mapper a special SELECT that typically is produced as a UNION of all
    the tables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承将每个子类映射到其自己的独立表，每个表包含产生该类实例所需的所有列。具体继承配置默认以非多态方式查询；对于特定类的查询将仅查询该类的表，并且仅返回该类的实例。通过在映射器内配置特殊的
    SELECT，通常会将所有表的 UNION 作为结果来启用具体类的多态加载。
- en: Warning
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Concrete table inheritance is **much more complicated** than joined or single
    table inheritance, and is **much more limited in functionality** especially pertaining
    to using it with relationships, eager loading, and polymorphic loading. When used
    polymorphically it produces **very large queries** with UNIONS that won’t perform
    as well as simple joins. It is strongly advised that if flexibility in relationship
    loading and polymorphic loading is required, that joined or single table inheritance
    be used if at all possible. If polymorphic loading isn’t required, then plain
    non-inheriting mappings can be used if each class refers to its own table completely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 具体表继承比连接或单表继承**复杂得多**，在使用关系、急加载和多态加载方面**功能受限**，尤其是与其一起使用时。当以多态方式使用时，会生成**非常大的查询**，其中包含不会像简单连接那样执行得好的UNION。强烈建议如果需要关系加载和多态加载的灵活性，尽量使用连接或单表继承。如果不需要多态加载，则每个类完全引用自己的表时可以使用普通的非继承映射。
- en: Whereas joined and single table inheritance are fluent in “polymorphic” loading,
    it is a more awkward affair in concrete inheritance. For this reason, concrete
    inheritance is more appropriate when **polymorphic loading is not required**.
    Establishing relationships that involve concrete inheritance classes is also more
    awkward.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于连接和单表继承在“多态”加载方面更为流畅，具体继承在这方面更为麻烦。因此，当**不需要多态加载**时，具体继承更为合适。建立涉及具体继承类的关系也更为麻烦。
- en: 'To establish a class as using concrete inheritance, add the [`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper") parameter within the `__mapper_args__`. This indicates
    to Declarative as well as the mapping that the superclass table should not be
    considered as part of the mapping:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类标记为使用具体继承，需要在`__mapper_args__`中添加[`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper")参数。这表示对于声明式和映射来说，超类表不应被视为映射的一部分：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Two critical points should be noted:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意两个关键点：
- en: We must **define all columns explicitly** on each subclass, even those of the
    same name. A column such as `Employee.name` here is **not** copied out to the
    tables mapped by `Manager` or `Engineer` for us.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在每个子类上**明确定义所有列**，即使是同名的列也是如此。例如此处的`Employee.name`列**不会**被复制到`Manager`或`Engineer`映射的表中。
- en: while the `Engineer` and `Manager` classes are mapped in an inheritance relationship
    with `Employee`, they still **do not include polymorphic loading**. Meaning, if
    we query for `Employee` objects, the `manager` and `engineer` tables are not queried
    at all.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`Engineer`和`Manager`类与`Employee`之间有映射关系，但它们**不包括多态加载**。这意味着，如果我们查询`Employee`对象，`manager`和`engineer`表根本不会被查询。
- en: '### Concrete Polymorphic Loading Configuration'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具体多态加载配置'
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承的多态加载要求针对应具有多态加载的每个基类配置一个专门的 SELECT。此 SELECT 需要能够单独访问所有映射的表，并且通常是使用 SQLAlchemy
    助手[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union "sqlalchemy.orm.polymorphic_union")构造的
    UNION 语句。
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如[为继承映射编写 SELECT 语句](queryguide/inheritance.html)中所讨论的，任何类型的映射继承配置都可以配置为默认从特殊可选中加载，使用[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数。当前的公共 API 要求在首次构造`Mapper`时设置此参数。
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在使用 Declarative 的情况下，映射器和被映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")同时创建，一旦定义了映射的类。这意味着由于尚未定义对应于子类的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，因此暂时无法提供[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数。
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可用的策略来解决这个循环，但是 Declarative 提供了处理此问题的助手类[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")和[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")。
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")，我们可以几乎以与其他形式的继承映射相同的方式设置我们的具体映射：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，Declarative 在映射器“初始化”时为`Employee`类设置了多态可选项；这是解决其他依赖映射器的延迟配置步骤。[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")助手使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")函数在设置了所有其他类后创建所有具体映射表的 UNION，并然后使用已经存在的基类映射器配置此语句。
- en: 'Upon select, the polymorphic union produces a query like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择时，多态联合会产生这样的查询：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 UNION 查询需要为每个子表制造“NULL”列，以适应那些不是特定子类成员的列。
- en: See also
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### Abstract Concrete Classes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### 抽象具体类'
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所示的具体映射同时显示了子类和基类分别映射到各自的表中。在具体继承用例中，通常基类在数据库中不会被表示，只有子类。换句话说，基类是“抽象的”。
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当想要将两个不同的子类映射到各自的表中，并且将基类保持未映射时，这可以很容易地实现。在使用 Declarative 时，只需使用`__abstract__`指示符声明基类：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们实际上并没有使用SQLAlchemy的继承映射功能；我们可以正常加载和持久化`Manager`和`Engineer`的实例。然而，当我们需要**多态查询**时，情况就会发生变化，也就是说，我们希望发出`select(Employee)`并返回`Manager`和`Engineer`实例的集合。这将我们带回到具体继承的领域，我们必须针对`Employee`构建一个特殊的映射器才能实现这一点。
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改我们的具体继承示例，以说明一个能够进行多态加载的“抽象”基类，我们将只有一个`engineer`和一个`manager`表，没有`employee`表，但是`Employee`映射器将直接映射到“多态联合”，而不是在[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数中本地指定它。
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，Declarative提供了一种名为[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")的[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")类的变体，它可以自动实现这一点：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，调用了[`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure")方法，这将触发实际映射`Employee`类；在配置步骤之前，类没有映射，因为它将从中查询的子表尚未定义。此过程比[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")更复杂，因为必须延迟基类的整个映射，直到所有子类都已声明。使用像上面的映射，只能持久化`Manager`和`Engineer`的实例；对`Employee`类进行查询将始终产生`Manager`和`Engineer`对象。
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，可以根据`Employee`类和在其上本地声明的任何属性生成查询，例如`Employee.name`：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数指示 `Employee` 类应直接映射仅属于 `Employee`
    类的属性，如本例中的 `Employee.name` 属性。其他属性，如 `Manager.manager_data` 和 `Engineer.engineer_info`，仅存在于其相应的子类中。当未设置
    [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 时，所有子类属性（如 `Manager.manager_data`
    和 `Engineer.engineer_info`）都将映射到基类 `Employee`。这是一种传统的使用模式，可能更方便查询，但其效果是所有子类共享整个层次结构的完整属性集；在上述示例中，不使用
    [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 将导致生成非实用的 `Engineer.manager_name`
    和 `Manager.engineer_info` 属性。'
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 新版2.0中：新增了 [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数到 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 中，以产生更清晰的映射；默认值为 False，以允许继续使用旧版1.x版本中的传统映射。
- en: See also
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典和半经典具体多态配置
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") 和 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 说明的声明性配置相当于另外两种使用 [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") 显式的配置形式。 这些配置形式明确使用 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，以便首先创建“多态联合”，然后将其应用于映射。 这些示例旨在澄清 [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") 函数在映射中的作用。
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**半经典映射**利用声明性，但分别建立 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") 生成 UNION：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象，可以使用“半经典”样式生成映射，在此样式中，我们与 `__table__` 参数一起使用声明性；我们上面的多态联合通过 `__mapper_args__`
    传递给 [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") 参数：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以完全以“经典”风格使用相同的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，而不使用声明性。 构造函数与声明性提供的类似，如下所示：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"抽象" 示例也可以使用“半经典”或“经典”风格进行映射。 不同之处在于，我们不再将“多态联合”应用于 [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") 参数，而是直接将其作为我们最基本的映射器上的映射选择。 半经典映射如下所示：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们与以前一样使用 [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")，只是省略了`employee`表。
- en: See also
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[命令式映射](mapping_styles.html#orm-imperative-mapping) - 有关命令式或“经典”映射的背景信息'
- en: Relationships with Concrete Inheritance
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具体继承关系
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体继承场景中，映射关系是具有挑战性的，因为不同的类不共享一个表。如果关系只涉及特定类，例如我们之前示例中的`Company`和`Manager`之间的关系，那么不需要特殊步骤，因为这只是两个相关表。
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`Company`要与`Employee`建立一对多关系，表示集合可能包括`Engineer`和`Manager`对象，这意味着`Employee`必须具有多态加载能力，并且要关联的每个表都必须有一个外键返回到`company`表。这种配置的示例如下：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承和关系的下一个复杂性涉及当我们希望`Employee`、`Manager`和`Engineer`中的一个或全部自身引用`Company`时。对于这种情况，SQLAlchemy
    在 `Employee` 上放置一个与 `Company` 相关的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 时，在实例级别执行时不适用于 `Manager` 和 `Engineer` 类，而必须对每个类应用一个不同的
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")。为了实现三个独立关系的双向行为，这些关系作为
    `Company.employees` 的相反关系，使用了 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 参数：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制与当前实现相关，包括具体继承类不共享超类的任何属性，因此需要设置不同的关系。
- en: Loading Concrete Inheritance Mappings
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载具体继承映射
- en: 'The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.  ## Joined Table Inheritance'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '具体继承加载选项有限；通常，如果在映射器上配置了多态加载，使用其中一个声明性具体混合类，就不能在当前 SQLAlchemy 版本中在查询时修改它。通常，[`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") 函数应该能够覆盖具体使用的加载样式，但由于当前限制，这还不受支持。  ## 连接表继承'
- en: In joined table inheritance, each class along a hierarchy of classes is represented
    by a distinct table. Querying for a particular subclass in the hierarchy will
    render as a SQL JOIN along all tables in its inheritance path. If the queried
    class is the base class, the base table is queried instead, with options to include
    other tables at the same time or to allow attributes specific to sub-tables to
    load later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接表继承中，类层次结构中的每个类都由一个不同的表表示。在层次结构中查询特定子类将作为 SQL JOIN 渲染其继承路径上的所有表。如果查询的类是基类，则将查询基表，同时可以选择包括其他表或允许特定于子表的属性稍后加载。
- en: In all cases, the ultimate class to instantiate for a given row is determined
    by a [discriminator](../glossary.html#term-discriminator) column or SQL expression,
    defined on the base class, which will yield a scalar value that is associated
    with a particular subclass.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，给定行的最终实例化类由基类上定义的[鉴别器](../glossary.html#term-discriminator)列或SQL表达式确定，该列将产生与特定子类关联的标量值。
- en: 'The base class in a joined inheritance hierarchy is configured with additional
    arguments that will indicate to the polymorphic discriminator column, and optionally
    a polymorphic identifier for the base class itself:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 连接继承层次结构中的基类将配置具有指示多态鉴别器列的额外参数，以及可选的基类自身的多态标识符：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the above example, the discriminator is the `type` column, whichever is configured
    using the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter. This parameter accepts a column-oriented expression,
    specified either as a string name of the mapped attribute to use or as a column
    expression object such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，鉴别器是`type`列，可以使用[`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper")参数进行配置。该参数接受一个基于列的表达式，可以指定为要使用的映射属性的字符串名称，也可以指定为列表达式对象，如[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造。
- en: The discriminator column will store a value which indicates the type of object
    represented within the row. The column may be of any datatype, though string and
    integer are the most common. The actual data value to be applied to this column
    for a particular row in the database is specified using the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter, described below.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴别器列将存储一个值，该值指示行中表示的对象类型。该列可以是任何数据类型，但字符串和整数最常见。为数据库中的特定行应用于此列的实际数据值是使用[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数指定的，如下所述。
- en: While a polymorphic discriminator expression is not strictly necessary, it is
    required if polymorphic loading is desired. Establishing a column on the base
    table is the easiest way to achieve this, however very sophisticated inheritance
    mappings may make use of SQL expressions, such as a CASE expression, as the polymorphic
    discriminator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多态鉴别器表达式不是严格必需的，但如果需要多态加载，则需要。在基表上建立一个列是实现此目的的最简单方法，但是非常复杂的继承映射可能会使用SQL表达式，例如CASE表达式，作为多态鉴别器。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, **only one discriminator column or SQL expression may be configured
    for the entire inheritance hierarchy**, typically on the base- most class in the
    hierarchy. “Cascading” polymorphic discriminator expressions are not yet supported.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**整个继承层次结构仅可以配置一个鉴别器列或SQL表达式**，通常在层次结构中最基本的类上。目前不支持“级联”多态鉴别器表达式。
- en: 'We next define `Engineer` and `Manager` subclasses of `Employee`. Each contains
    columns that represent the attributes unique to the subclass they represent. Each
    table also must contain a primary key column (or columns), as well as a foreign
    key reference to the parent table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义`Engineer`和`Manager`作为`Employee`的子类。每个子类包含代表其所代表子类的唯一属性的列。每个表还必须包含主键列（或列）以及对父表的外键引用：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the above example, each mapping specifies the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter within its mapper arguments. This value populates
    the column designated by the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter established on the base mapper. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter should be unique to each mapped class across
    the whole hierarchy, and there should only be one “identity” per mapped class;
    as noted above, “cascading” identities where some subclasses introduce a second
    identity are not supported.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，每个映射在其映射器参数中指定了[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数。此值填充了由基本映射器上建立的[`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper")参数指定的列。[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数应该对整个层次结构中的每个映射类是唯一的，并且每个映射类只应有一个“标识”；如上所述，不支持一些子类引入第二个标识的“级联”标识。
- en: The ORM uses the value set up by [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") in order to determine which class a row belongs towards
    when loading rows polymorphically. In the example above, every row which represents
    an `Employee` will have the value `'employee'` in its `type` column; similarly,
    every `Engineer` will get the value `'engineer'`, and each `Manager` will get
    the value `'manager'`. Regardless of whether the inheritance mapping uses distinct
    joined tables for subclasses as in joined table inheritance, or all one table
    as in single table inheritance, this value is expected to be persisted and available
    to the ORM when querying. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter also applies to concrete table inheritance,
    but is not actually persisted; see the later section at [Concrete Table Inheritance](#concrete-inheritance)
    for details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ORM使用[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")设置的值来确定加载行时行属于哪个类。在上面的示例中，每个代表`Employee`的行在其`type`列中将有值`'employee'`；同样，每个`Engineer`将获得值`'engineer'`，每个`Manager`将获得值`'manager'`。无论继承映射使用不同的联接表作为子类（如联合表继承）还是所有一个表作为单表继承，这个值都应该被持久化并在查询时对ORM可用。[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")参数也适用于具体表继承，但实际上并没有被持久化；有关详细信息，请参阅后面的[具体表继承](#concrete-inheritance)部分。
- en: In a polymorphic setup, it is most common that the foreign key constraint is
    established on the same column or columns as the primary key itself, however this
    is not required; a column distinct from the primary key may also be made to refer
    to the parent via foreign key. The way that a JOIN is constructed from the base
    table to subclasses is also directly customizable, however this is rarely necessary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在多态设置中，最常见的是外键约束建立在与主键本身相同的列或列上，但这并非必需；一个与主键不同的列也可以通过外键指向父类。从基本表到子类构建JOIN的方式也是可以直接自定义的，但这很少是必要的。
- en: With the joined inheritance mapping complete, querying against `Employee` will
    return a combination of `Employee`, `Engineer` and `Manager` objects. Newly saved
    `Engineer`, `Manager`, and `Employee` objects will automatically populate the
    `employee.type` column with the correct “discriminator” value in this case `"engineer"`,
    `"manager"`, or `"employee"`, as appropriate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完成联合继承映射后，针对`Employee`的查询将返回`Employee`、`Engineer`和`Manager`对象的组合。新保存的`Engineer`、`Manager`和`Employee`对象将自动填充`employee.type`列，此时正确的“鉴别器”值为`"engineer"`、`"manager"`或`"employee"`。
- en: Relationships with Joined Inheritance
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有联合继承关系
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与联合表继承完全支持关系。涉及联合继承类的关系应该针对与外键约束对应的层次结构中的类；在下面的示例中，由于`employee`表有一个指向`company`表的外键约束，关系被建立在`Company`和`Employee`之间：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外键约束在对应于子类的表上，则关系应该指向该子类。在下面的示例中，从`manager`到`company`有一个外键约束，因此建立了`Manager`和`Company`类之间的关系：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`Manager`类将具有`Manager.company`属性；`Company`将具有`Company.managers`属性，总是针对`employee`和`manager`表一起加载的连接进行加载。
- en: Loading Joined Inheritance Mappings
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载连接继承映射
- en: See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[编写用于继承映射的SELECT语句](queryguide/inheritance.html)部分，了解继承加载技术的背景，包括在映射器配置时间和查询时间配置要查询的表。
- en: Relationships with Joined Inheritance
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有连接继承的关系
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与连接表继承完全支持关系。涉及连接继承类的关系应该指向与外键约束对应的层次结构中的类；在下面的示例中，由于`employee`表有一个指向`company`表的外键约束，因此在`Company`和`Employee`之间建立了关系：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外键约束在对应于子类的表上，则关系应该指向该子类。在下面的示例中，从`manager`到`company`有一个外键约束，因此建立了`Manager`和`Company`类之间的关系：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`Manager`类将具有`Manager.company`属性；`Company`将具有`Company.managers`属性，总是针对`employee`和`manager`表一起加载的连接进行加载。
- en: Loading Joined Inheritance Mappings
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载连接继承映射
- en: See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[编写用于继承映射的SELECT语句](queryguide/inheritance.html)部分，了解继承加载技术的背景，包括在映射器配置时间和查询时间配置要查询的表。
- en: '## Single Table Inheritance'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '## 单表继承'
- en: Single table inheritance represents all attributes of all subclasses within
    a single table. A particular subclass that has attributes unique to that class
    will persist them within columns in the table that are otherwise NULL if the row
    refers to a different kind of object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承将所有子类的所有属性表示为单个表中的内容。具有特定类别属性的特定子类将在表中的列中保留它们，如果行引用不同类型的对象，则列中将为空。
- en: Querying for a particular subclass in the hierarchy will render as a SELECT
    against the base table, which will include a WHERE clause that limits rows to
    those with a particular value or values present in the discriminator column or
    expression.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中查询特定子类将呈现为针对基表的SELECT，其中将包括一个WHERE子句，该子句将限制行为具有鉴别器列或表达式中存在的特定值或值。
- en: Single table inheritance has the advantage of simplicity compared to joined
    table inheritance; queries are much more efficient as only one table needs to
    be involved in order to load objects of every represented class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承相对于连接表继承具有简单性的优势；查询效率更高，因为只需要涉及一个表来加载每个表示类的对象。
- en: Single-table inheritance configuration looks much like joined-table inheritance,
    except only the base class specifies `__tablename__`. A discriminator column is
    also required on the base table so that classes can be differentiated from each
    other.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承配置看起来很像连接表继承，只是基类指定了`__tablename__`。基表还需要一个鉴别器列，以便类之间可以区分开来。
- en: 'Even though subclasses share the base table for all of their attributes, when
    using Declarative, [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects may still be specified on subclasses,
    indicating that the column is to be mapped only to that subclass; the [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be applied to the same base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 即使子类共享所有属性的基本表，当使用 Declarative 时，仍然可以在子类上指定 [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 对象，指示该列仅映射到该子类；[`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 将应用于相同的基本 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the mappers for the derived classes Manager and Engineer omit the
    `__tablename__`, indicating they do not have a mapped table of their own. Additionally,
    a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with `nullable=True` is included; as the Python types declared for these
    classes do not include `Optional[]`, the column would normally be mapped as `NOT
    NULL`, which would not be appropriate as this column only expects to be populated
    for those rows that correspond to that particular subclass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到派生类 Manager 和 Engineer 的映射器省略了 `__tablename__`，表明它们没有自己的映射表。此外，还包括一个带有 `nullable=True`
    的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    指令；由于为这些类声明的 Python 类型不包括 `Optional[]`，该列通常会被映射为 `NOT NULL`，这对于只期望为对应于特定子类的那些行填充的列来说是不合适的。
- en: '### Resolving Column Conflicts with `use_existing_column`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `use_existing_column` 解决列冲突'
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前一节中，`manager_name` 和 `engineer_info` 列被“上移”应用到 `Employee.__table__`，因为它们在没有自己表的子类上声明。当两个子类想要指定*相同*列时，就会出现一个棘手的情况，如下所示：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，在 `Engineer` 和 `Manager` 上声明的 `start_date` 列将导致错误：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况对 Declarative 映射系统提出了一个模棱两可的问题，可以通过在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 上使用 [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") 参数来解决，该参数指示 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 查找并使用已经映射的继承超类上的列，如果已经存在，否则映射一个新列：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，当`Manager`被映射时，`start_date`列已经存在于`Employee`类上，已经由`Engineer`映射提供。[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")参数指示[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")应该首先在`Employee`的映射[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上查找请求的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，如果存在，则保持该现有映射。如果不存在，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")将正常映射该列，将其添加为`Employee`超类引用的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")中的列之一。
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.0b4版本中新增：- 添加了[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")，提供了一种符合2.0版本的方式来有条件地映射继承子类上的列。之前的方法结合了[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")和对父类`.__table__`的查找仍然有效，但缺乏[**PEP 484**](https://peps.python.org/pep-0484/)类型支持。
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的概念可以与混合类一起使用（参见[使用混合类组合映射层次结构](declarative_mixins.html)）来定义一系列特定的列和/或其他可重用混合类中的映射属性：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Relationships with Single Table Inheritance
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与单表继承的关系
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与单表继承完全支持关系。配置方式与连接继承相同；外键属性应该在与关系的“外键”一侧相同的类上：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与连接继承的情况类似，我们可以创建涉及特定子类的关系。在查询时，SELECT语句将包含一个WHERE子句，将类选择限制为该子类或子类：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Manager`类将具有`Manager.company`属性；`Company`将具有`Company.managers`属性，始终针对具有额外WHERE子句的`employee`加载，该子句将行限制为`type
    = 'manager'`的行。
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用`polymorphic_abstract`构建更深层次的层次结构'
- en: New in version 2.0.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中新增。
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何继承层次结构时，一个映射类可以设置[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")参数为`True`，这表示该类应该被正常映射，但不希望直接实例化，并且不包含[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。然后可以声明这个映射类的子类，这些子类可以包含[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")，因此可以被正常使用。这允许一系列子类被一个公共基类引用，该基类在层次结构中被认为是“抽象的”，无论是在查询中还是在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")声明中。这种用法与在Declarative中使用[__abstract__](declarative_config.html#declarative-abstract)属性的用法不同，后者将目标类完全未映射，因此不能单独作为映射类使用。[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")可以应用于层次结构中的任何类或类，包括同时在多个级别上应用。
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设`Manager`和`Principal`都被分类到一个超类`Executive`下，而`Engineer`和`Sysadmin`被分类到一个超类`Technologist`下。`Executive`和`Technologist`都不会被实例化，因此没有[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。这些类可以通过[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")进行配置如下：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，新的类`Technologist`和`Executive`都是普通的映射类，并且指示要添加到超类中的新列`executive_background`和`competencies`。然而，它们都缺少[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")的设置；这是因为不希望直接实例化`Technologist`或`Executive`；我们总是会有`Manager`、`Principal`、`Engineer`或`SysAdmin`中的一个。但是我们可以查询`Principal`和`Technologist`角色，并且让它们成为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的目标。下面的示例演示了针对`Technologist`对象的SELECT语句：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Technologist`和`Executive`抽象映射类也可以成为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射的目标，就像任何其他映射类一样。我们可以扩展上面的例子，包括`Company`，有单独的集合`Company.technologists`和`Company.principals`：'
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，我们可以分别跨`Company.technologists`和`Company.executives`使用连接和关系加载技术：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[__abstract__](declarative_config.html#declarative-abstract) - 声明性参数，允许声明性类在层次结构中完全取消映射，同时仍然从映射的超类扩展。'
- en: Loading Single Inheritance Mappings
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载单一继承映射
- en: The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承的加载技术与联接表继承的加载技术基本相同，并且在这两种映射类型之间提供了高度的抽象，使得很容易在它们之间进行切换，以及在单个层次结构中混合使用它们（只需从要单继承的子类中省略
    `__tablename__`）。请参阅 [编写继承映射的 SELECT 语句](queryguide/inheritance.html) 和 [单一继承映射的
    SELECT 语句](queryguide/inheritance.html#loading-single-inheritance) 部分，了解有关继承加载技术的文档，包括在映射器配置时间和查询时间配置要查询的类。
- en: '### Resolving Column Conflicts with `use_existing_column`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `use_existing_column` 解决列冲突'
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中注意到，`manager_name`和`engineer_info`列被“上移”，应用于`Employee.__table__`，因为它们在没有自己的表的子类上声明。当两个子类想要指定*相同*列时会出现棘手的情况，如下所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，同时在`Engineer`和`Manager`上声明的`start_date`列将导致错误：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情景对声明性映射系统存在一种模糊性，可以通过在[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")上使用[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")参数来解决，该参数指示[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")查找继承的超类，并使用已经存在的列，如果已经存在，则映射新列：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，当 `Manager` 被映射时，`start_date` 列已经存在于 `Employee` 类中，已经由之前的 `Engineer` 映射提供。[`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") 参数指示给 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，它应该首先查找映射到 `Employee` 的映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 上的请求的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，如果存在，则保持该现有映射。如果不存在，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 将正常映射列，将其添加为 `Employee` 超类引用的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中的列之一。
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0b4 中新增：- 添加了 [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column")，它提供了一个与 2.0 兼容的方法，以条件地映射继承子类上的列。先前的方法结合了 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 与对父类 `.__table__` 的查找，仍然有效，但缺少了 [**PEP 484**](https://peps.python.org/pep-0484/)
    类型支持。
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的概念可以与 mixin 类一起使用（参见 [Composing Mapped Hierarchies with Mixins](declarative_mixins.html)）来定义来自可重用
    mixin 类的特定系列列和/或其他映射属性：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Relationships with Single Table Inheritance
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单表继承的关系
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关系在单表继承中得到充分支持。配置方式与联接继承的方式相同；外键属性应位于与关系的“外部”一侧相同的类上：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于联接继承的情况，我们也可以创建涉及特定子类的关系。当查询时，SELECT 语句将包含一个 WHERE 子句，将类的选择限制为该子类或子类：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中，`Manager` 类将具有一个 `Manager.company` 属性；`Company` 将具有一个 `Company.managers`
    属性，该属性始终加载针对具有附加 WHERE 子句的 `employee`，限制行为具有 `type = 'manager'` 的行。
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `polymorphic_abstract` 构建更深层次的层次结构'
- en: New in version 2.0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中新增。
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何类型的继承层次结构时，映射类可以包含设置为`True`的[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")参数，表示该类应该正常映射，但不期望直接实例化，并且不包括[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。然后可以声明这个映射类的子类，这些子类本身可以包含[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")，因此可以正常使用。这允许一系列子类被一个被认为是层次结构内“抽象”的公共基类引用，无论是在查询中还是在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")声明中。这种用法与在Declarative中使用[__abstract__](declarative_config.html#declarative-abstract)属性的用法不同，后者使目标类完全未映射，因此不能作为一个映射类单独使用。[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")可以应用于层次结构中的任何类或类，包括一次在多个级别上。
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设要将`Manager`和`Principal`都归类到一个超类`Executive`下，而`Engineer`和`Sysadmin`则归类到一个超类`Technologist`下。`Executive`和`Technologist`都不会被实例化，因此没有[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")。可以使用[`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper")来配置这些类，如下所示：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，新类`Technologist`和`Executive`都是普通的映射类，并指示要添加到超类中的新列`executive_background`和`competencies`。然而，它们都缺少[`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper")的设置；这是因为不期望直接实例化`Technologist`或`Executive`；我们总是会有`Manager`、`Principal`、`Engineer`或`SysAdmin`中的一个。然而，我们可以查询`Principal`和`Technologist`角色，并使它们成为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的目标。下面的示例演示了用于`Technologist`对象的SELECT语句：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象映射的`Technologist`和`Executive`抽象映射类也可以成为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射的目标，就像任何其他映射类一样。我们可以扩展上述示例以包括`Company`，并分别添加`Company.technologists`和`Company.principals`两个集合：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，我们可以分别在`Company.technologists`和`Company.executives`之间使用连接和关系加载技术：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[__abstract__](declarative_config.html#declarative-abstract) - 声明性参数，允许在层次结构中完全取消映射Declarative类，同时仍从映射的超类扩展。'
- en: Loading Single Inheritance Mappings
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载单继承映射
- en: The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 单表继承的加载技术大部分与用于连接表继承的技术相同，并且在这两种映射类型之间提供了很高程度的抽象，因此很容易在它们之间进行切换以及在单个层次结构中混合使用它们（只需从要单继承的子类中省略`__tablename__`）。请参阅[编写继承映射的SELECT语句](queryguide/inheritance.html)和[单继承映射的SELECT语句](queryguide/inheritance.html#loading-single-inheritance)章节，了解有关继承加载技术的文档，包括在映射器配置时间和查询时间配置要查询的类。
- en: '## Concrete Table Inheritance'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '## 具体表继承'
- en: Concrete inheritance maps each subclass to its own distinct table, each of which
    contains all columns necessary to produce an instance of that class. A concrete
    inheritance configuration by default queries non-polymorphically; a query for
    a particular class will only query that class’ table and only return instances
    of that class. Polymorphic loading of concrete classes is enabled by configuring
    within the mapper a special SELECT that typically is produced as a UNION of all
    the tables.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 具体表继承将每个子类映射到其自己的独立表格，每个表格包含产生该类实例所需的所有列。具体继承配置默认情况下进行非多态查询；对于特定类的查询只会查询该类的表格，并且只返回该类的实例。具体类的多态加载通过在映射器内配置一个特殊的SELECT来启用，该SELECT通常被生成为所有表的UNION。
- en: Warning
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Concrete table inheritance is **much more complicated** than joined or single
    table inheritance, and is **much more limited in functionality** especially pertaining
    to using it with relationships, eager loading, and polymorphic loading. When used
    polymorphically it produces **very large queries** with UNIONS that won’t perform
    as well as simple joins. It is strongly advised that if flexibility in relationship
    loading and polymorphic loading is required, that joined or single table inheritance
    be used if at all possible. If polymorphic loading isn’t required, then plain
    non-inheriting mappings can be used if each class refers to its own table completely.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 具体表继承比连接或单表继承**更加复杂**，在功能上**更加受限**，特别是在使用关系、急加载和多态加载方面。当以多态方式使用时，会产生**非常庞大的查询**，其中包含的UNION操作不会像简单的连接那样执行良好。强烈建议如果需要灵活性的关系加载和多态加载，尽可能使用连接或单表继承。如果不需要多态加载，则可以使用普通的非继承映射，如果每个类都完全引用其自己的表格。
- en: Whereas joined and single table inheritance are fluent in “polymorphic” loading,
    it is a more awkward affair in concrete inheritance. For this reason, concrete
    inheritance is more appropriate when **polymorphic loading is not required**.
    Establishing relationships that involve concrete inheritance classes is also more
    awkward.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然联接和单表继承在“多态”加载方面很流畅，但在具体继承中却是一种更笨拙的事情。因此，当**不需要多态加载**时，具体继承更为适用。建立涉及具体继承类的关系也更加麻烦。
- en: 'To establish a class as using concrete inheritance, add the [`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper") parameter within the `__mapper_args__`. This indicates
    to Declarative as well as the mapping that the superclass table should not be
    considered as part of the mapping:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类建立为使用具体继承，请在`__mapper_args__`中添加[`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper")参数。这既表示对声明式以及映射，超类表不应被视为映射的一部分：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Two critical points should be noted:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键点需要注意：
- en: We must **define all columns explicitly** on each subclass, even those of the
    same name. A column such as `Employee.name` here is **not** copied out to the
    tables mapped by `Manager` or `Engineer` for us.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须**在每个子类上显式定义所有列**，甚至是同名的列。例如，此处的`Employee.name`列**不会**被复制到由我们映射的`Manager`或`Engineer`表中。
- en: while the `Engineer` and `Manager` classes are mapped in an inheritance relationship
    with `Employee`, they still **do not include polymorphic loading**. Meaning, if
    we query for `Employee` objects, the `manager` and `engineer` tables are not queried
    at all.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`Engineer`和`Manager`类在与`Employee`的继承关系中被映射，但它们**仍然不包括多态加载**。也就是说，如果我们查询`Employee`对象，`manager`和`engineer`表根本不会被查询。
- en: '### Concrete Polymorphic Loading Configuration'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具体多态加载配置'
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 具有具体继承的多态加载要求针对应该具有多态加载的每个基类配置专门的 SELECT。此 SELECT 需要能够单独访问所有映射的表，并且通常是使用 SQLAlchemy
    辅助程序[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")构造的 UNION 语句。
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如[编写继承映射的 SELECT 语句](queryguide/inheritance.html)所述，任何类型的映射器继承配置都可以使用[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数默认配置从特殊的可选项中加载。当前公共 API 要求在首次构造[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")时设置此参数。
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在声明式的情况下，映射器和被映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")同时创建，即在定义映射类的那一刻。这意味着暂时无法提供[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数，因为子类对应的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象尚未定义。
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些可用的策略来解决这个循环，然而声明性提供了帮助类[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") 和 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")，它们在幕后处理这个问题。
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")，我们几乎可以以与其他形式的继承映射相同的方式设置我们的具体映射：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，声明性在映射器“初始化”时为`Employee`类设置了多态可选择项；这是解析其他依赖映射器的映射器的后配置步骤。[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") 帮助程序使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")函数在设置了其他所有类之后创建所有具体映射表的UNION，然后使用已经存在的基类映射器配置此语句。
- en: 'Upon select, the polymorphic union produces a query like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择时，多态联合产生这样的查询：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 UNION 查询需要为每个子表制造“NULL”列，以容纳那些不属于特定子类的列。
- en: See also
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### Abstract Concrete Classes'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### 抽象具体类'
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所示的具体映射同时显示了子类和基类映射到各自的表中。在具体继承用例中，常见的是基类在数据库中没有表示，只有子类。换句话说，基类是“抽象的”。
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个人想要将两个不同的子类映射到各自的表中，并且保留基类未映射时，这可以非常容易地实现。在使用声明性时，只需使用`__abstract__`指示器声明基类：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们实际上没有利用SQLAlchemy的继承映射功能；我们可以正常加载和持久化`Manager`和`Engineer`的实例。然而，当我们需要**多态地查询**时，也就是说，我们想要发出`select(Employee)`并返回`Manager`和`Engineer`实例的集合时，情况就会发生变化。这让我们重新进入具体继承的领域，我们必须针对`Employee`构建一个特殊的映射器才能实现这一点。
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改我们的具体继承示例以说明一个能够进行多态加载的“抽象”基类，我们将只有一个 `engineer` 和一个 `manager` 表，没有 `employee`
    表，但是 `Employee` 映射器将直接映射到“多态联合”，而不是在 [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") 参数中本地指定它。
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现这一点，声明性提供了一个名为 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 的 [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") 类的变体，它可以自动实现这一点：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，调用了 [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") 方法，这将触发 `Employee` 类实际上被映射；在配置步骤之前，由于尚未定义将从中查询的子表，因此该类没有映射。这个过程比
    [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") 更复杂，因为整个基类的映射必须延迟到所有子类都声明完毕。有了上述的映射，只有
    `Manager` 和 `Engineer` 的实例才能被持久化；对 `Employee` 类进行查询将始终产生 `Manager` 和 `Engineer`
    对象。
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述的映射，可以根据 `Employee` 类和在其上局部声明的任何属性生成查询，例如 `Employee.name`：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数表示 `Employee` 类应直接映射仅属于 `Employee`
    类本身的属性，例如 `Employee.name` 属性。其他属性如 `Manager.manager_data` 和 `Engineer.engineer_info`
    仅存在于它们各自的子类中。当未设置 [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 时，所有子类的属性如 `Manager.manager_data`
    和 `Engineer.engineer_info` 都会映射到基类 `Employee` 中。这是一种遗留模式，对于查询可能更方便，但会导致所有子类共享整个层次结构的完整属性集；在上述示例中，如果不使用
    [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase")，将会生成无用的 `Engineer.manager_name`
    和 `Manager.engineer_info` 属性。'
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：增加了 [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数到 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")，以生成更清晰的映射；默认值为 False，以允许遗留映射在
    1.x 版本中继续正常工作。
- en: See also
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典和半经典具体多态配置
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")和[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")说明的声明性配置等同于另外两种明确使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")的配置形式。这些配置形式明确使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，以便首先创建“多态联合”，然后应用到映射中。这些例子旨在澄清[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")函数在映射中的作用。
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**半经典映射**利用了声明性，但是单独建立了[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")生成UNION：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，可以使用“半经典”风格生成映射，在这种风格中，我们将声明性与`__table__`参数结合使用；我们上面的多态联合通过`__mapper_args__`传递给[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以完全以“经典”风格使用相同的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，而不使用声明性。与声明性提供的类似的构造函数如下所示：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: “抽象”示例也可以使用“半经典”或“经典”风格进行映射。不同之处在于，我们将“多态联合”应用于[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数的方式，而是将其直接应用于我们基本映射器上的映射可选项。半经典映射如下所示：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们像以前一样使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")，只是省略了`employee`表。
- en: See also
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[命令式映射](mapping_styles.html#orm-imperative-mapping) - 命令式或“经典”映射的背景信息'
- en: Relationships with Concrete Inheritance
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具体继承的关系
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体继承的情况下，映射关系是具有挑战性的，因为不同的类不共享表格。如果关系仅涉及特定类，例如在我们先前的示例中`Company`和`Manager`之间的关系，那么不需要特殊步骤，因为这只是两个相关的表。
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`Company`要对`Employee`有一对多的关系，表明集合可能包含`Engineer`和`Manager`对象，那么这意味着`Employee`必须具有多态加载功能，并且要与`company`表关联的每个表都必须有一个外键。这种配置的示例如下：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承和关系的下一个复杂性涉及当我们希望`Employee`、`Manager`和`Engineer`中的一个或全部自己参考`Company`时。对于这种情况，SQLAlchemy具有特殊行为，即在`Employee`上放置到`Company`的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在实例级别时**不适用**于`Manager`和`Engineer`类。相反，必须对每个类应用不同的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。为了在三个单独的关系中实现与`Company.employees`相反的双向行为，使用了[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制与当前的实现相关，其中具体继承类不共享超类的任何属性，因此需要设置不同的关系。
- en: Loading Concrete Inheritance Mappings
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载具体继承映射
- en: The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承的加载选项有限；一般来说，如果使用声明性具体混合类型之一在映射器上配置多态加载，那么在当前SQLAlchemy版本中无法在查询时修改它。通常，[`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数应该能够覆盖具体使用的加载方式，但由于当前的限制，这尚不受支持。
- en: '### Concrete Polymorphic Loading Configuration'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具体多态加载配置'
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 具有具体继承的多态加载要求针对应该具有多态加载的每个基类配置一个专用的SELECT。这个SELECT需要能够单独访问所有映射的表，并且通常是使用SQLAlchemy助手[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")构造的UNION语句。
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如[为继承映射编写 SELECT 语句](queryguide/inheritance.html)所讨论的，任何类型的映射器继承配置都可以使用[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数默认配置从特殊的可选项加载。当前的公共 API 要求在首次构造[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")时设置此参数。
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在声明式编程中，映射器和被映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")同时创建，即在定义映射类的时候。这意味着[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数还不能提供，因为对应于子类的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象尚未定义。
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种策略可用于解决这种循环，然而，声明式提供了处理此问题的助手类[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")和[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")。
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")，我们可以几乎与其他形式的继承映射方式相同地设置我们的具体映射：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，声明式在映射器“初始化”时为`Employee`类设置多态可选项；这是为解析其他依赖映射器而进行的映射器的后期配置步骤。[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")助手使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")函数在设置完所有其他类之后创建所有具体映射表的联合，然后使用已经存在的基类映射器配置此语句。
- en: 'Upon select, the polymorphic union produces a query like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择时，多态联合产生类似这样的查询：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 UNION 查询需要为每个子表制造“NULL”列，以适应那些不是特定子类成员的列。
- en: See also
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")'
- en: '### Abstract Concrete Classes'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '### 抽象具体类'
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所示的具体映射显示了子类以及基类映射到单独的表中。在具体继承用例中，常见的情况是基类在数据库中不表示，只有子类。换句话说，基类是“抽象的”。
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个人想要将两个不同的子类映射到单独的表中，并且保留基类未映射时，这可以非常容易地实现。当使用声明式时，只需使用`__abstract__`指示符声明基类：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们实际上没有使用SQLAlchemy的继承映射功能；我们可以正常加载和持久化`Manager`和`Engineer`的实例。然而，当我们需要进行**多态查询**时，情况就会发生变化，也就是说，我们希望发出`select(Employee)`并返回一组`Manager`和`Engineer`实例。这将我们带回到具体继承的领域，我们必须构建一个针对`Employee`的特殊映射器才能实现这一点。
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改我们的具体继承示例，以说明能够进行多态加载的“抽象”基类，我们将只有一个`engineer`和一个`manager`表，而没有`employee`表，但`Employee`映射器将直接映射到“多态联合”，而不是将其局部指定给[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数。
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，Declarative提供了一种名为[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")的[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")类的变体，可以自动实现这一点：
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，调用了[`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure")方法，这将触发`Employee`类实际映射；在配置步骤之前，该类没有映射，因为它将从中查询的子表尚未定义。这个过程比[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")的过程更复杂，因为必须延迟基类的整个映射，直到所有的子类都已声明。通过像上面这样的映射，只能持久化`Manager`和`Engineer`的实例；对`Employee`类进行查询将始终生成`Manager`和`Engineer`对象。
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，可以按照`Employee`类和在其上本地声明的任何属性生成查询，例如`Employee.name`：
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数指示 `Employee` 类应直接映射仅属于 `Employee`
    类的本地属性，即 `Employee.name` 属性。其他属性，如 `Manager.manager_data` 和 `Engineer.engineer_info`，仅存在于其对应的子类中。当未设置
    [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 时，所有子类属性，如 `Manager.manager_data`
    和 `Engineer.engineer_info`，都映射到基类 `Employee`。这是一种传统的使用模式，可能更方便查询，但其效果是所有子类共享整个层次结构的完整属性集；在上述示例中，不使用
    [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 将导致生成不必要的 `Engineer.manager_name`
    和 `Manager.engineer_info` 属性。'
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本新增：增加了 [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 参数到 [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 中，以产生更清晰的映射；默认值为 False，以允许传统映射继续像
    1.x 版本中那样工作。
- en: See also
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典和半经典具有多态性的具体配置
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 用[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")和[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")说明的声明性配置等同于另外两种明确使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")的配置形式。这些配置形式明确使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，以便首先创建“多态联合”，然后应用于映射。这里举例说明了这些配置形式，以阐明[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")函数在映射方面的作用。
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**半经典映射**的例子利用了声明性，但是单独建立了[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象：
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")生成UNION：
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，可以使用“半经典”风格生成映射，其中我们与`__table__`参数一起使用声明性；我们上面的多态联合通过`__mapper_args__`传递给[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数：
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，完全可以使用完全“经典”风格，而根本不使用声明性，使用与声明性提供的类似的构造函数：
- en: '[PRE76]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: “抽象”示例也可以使用“半经典”或“经典”风格进行映射。不同之处在于，我们不是将“多态联合”应用于[`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper")参数，而是直接将其应用为我们最基本的映射器上的映射选择器。下面是半经典映射的示例：
- en: '[PRE77]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们像以前一样使用[`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union")，只是省略了`employee`表。
- en: See also
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[命令式映射](mapping_styles.html#orm-imperative-mapping) - 关于命令式或“经典”映射的背景信息'
- en: Relationships with Concrete Inheritance
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具体继承关系
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体继承的情况下，映射关系是具有挑战性的，因为不同的类不共享一个表。如果关系只涉及特定的类，比如我们之前示例中的 `Company` 和 `Manager`
    之间的关系，那么不需要特殊步骤，因为这只是两个相关的表。
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `Company` 要与 `Employee` 有一对多的关系，表明集合可能包括 `Engineer` 和 `Manager` 对象，这意味着
    `Employee` 必须具有多态加载能力，并且每个相关的表都必须有一个外键返回到 `company` 表。这样的配置示例如下：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承和关系的下一个复杂性涉及当我们希望 `Employee`、`Manager` 和 `Engineer` 中的一个或全部自身参考 `Company`
    时。对于这种情况，SQLAlchemy 在 `Employee` 上有特殊的行为，即一个链接到 `Company` 的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 放置在 `Employee` 上，当在实例级别执行时，**不适用**于 `Manager` 和
    `Engineer` 类。相反，必须对每个类应用不同的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。为了实现作为 `Company.employees` 的相反的三个单独关系的双向行为，使用了
    [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 参数：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制与当前实现相关，包括具体继承类不共享超类的任何属性，因此需要设置不同的关系。
- en: Loading Concrete Inheritance Mappings
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载具体继承映射
- en: The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 具体继承加载选项有限；一般来说，如果在映射器上配置了多态加载，使用其中一个声明性的具体混合类，那么在当前的 SQLAlchemy 版本中它就不能在查询时进行修改。通常，[`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") 函数应该能够覆盖具体加载使用的样式，然而由于当前的限制，这还不被支持。
