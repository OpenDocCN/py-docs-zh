- en: jax.Array migration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`jax.Array` è¿ç§»'
- en: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/jax_array_migration.html`](https://jax.readthedocs.io/en/latest/jax_array_migration.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/jax_array_migration.html`](https://jax.readthedocs.io/en/latest/jax_array_migration.html)
- en: '**yashkatariya@**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**yashkatariya@**'
- en: TL;DR
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TL;DR
- en: JAX switched its default array implementation to the new `jax.Array` as of version
    0.4.1. This guide explains the reasoning behind this, the impact it might have
    on your code, and how to (temporarily) switch back to the old behavior.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JAX å°†å…¶é»˜è®¤æ•°ç»„å®ç°åˆ‡æ¢ä¸ºæ–°çš„ `jax.Array` è‡ªç‰ˆæœ¬ 0.4.1 èµ·ã€‚æœ¬æŒ‡å—è§£é‡Šäº†è¿™ä¸€å†³å®šçš„èƒŒæ™¯ï¼Œå®ƒå¯èƒ½å¯¹æ‚¨çš„ä»£ç äº§ç”Ÿçš„å½±å“ï¼Œä»¥åŠå¦‚ä½•ï¼ˆä¸´æ—¶ï¼‰åˆ‡æ¢å›æ—§è¡Œä¸ºã€‚
- en: Whatâ€™s going on?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ
- en: '`jax.Array` is a unified array type that subsumes `DeviceArray`, `ShardedDeviceArray`,
    and `GlobalDeviceArray` types in JAX. The `jax.Array` type helps make parallelism
    a core feature of JAX, simplifies and unifies JAX internals, and allows us to
    unify jit and pjit. If your code doesnâ€™t mention `DeviceArray` vs `ShardedDeviceArray`
    vs `GlobalDeviceArray`, no changes are needed. But code that depends on details
    of these separate classes may need to be tweaked to work with the unified jax.Array'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.Array` æ˜¯ JAX ä¸­ç»Ÿä¸€çš„æ•°ç»„ç±»å‹ï¼ŒåŒ…æ‹¬ `DeviceArray`ã€`ShardedDeviceArray` å’Œ `GlobalDeviceArray`
    ç±»å‹ã€‚`jax.Array` ç±»å‹æœ‰åŠ©äºä½¿å¹¶è¡Œæˆä¸º JAX çš„æ ¸å¿ƒç‰¹æ€§ï¼Œç®€åŒ–å’Œç»Ÿä¸€äº† JAX çš„å†…éƒ¨ç»“æ„ï¼Œå¹¶å…è®¸æˆ‘ä»¬ç»Ÿä¸€ `jit` å’Œ `pjit`ã€‚å¦‚æœä½ çš„ä»£ç æ²¡æœ‰æ¶‰åŠåˆ°
    `DeviceArray`ã€`ShardedDeviceArray` å’Œ `GlobalDeviceArray` çš„åŒºåˆ«ï¼Œé‚£å°±ä¸éœ€è¦è¿›è¡Œä»»ä½•æ›´æ”¹ã€‚ä½†æ˜¯ä¾èµ–äºè¿™äº›å•ç‹¬ç±»ç»†èŠ‚çš„ä»£ç å¯èƒ½éœ€è¦è¿›è¡Œè°ƒæ•´ä»¥é€‚é…ç»Ÿä¸€çš„
    `jax.Array`ã€‚'
- en: After the migration is complete `jax.Array` will be the only type of array in
    JAX.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: è¿ç§»å®Œæˆåï¼Œ`jax.Array` å°†æˆä¸º JAX ä¸­å”¯ä¸€çš„æ•°ç»„ç±»å‹ã€‚
- en: This doc explains how to migrate existing codebases to `jax.Array`. For more
    information on using `jax.Array` and JAX parallelism APIs, see the [Distributed
    arrays and automatic parallelization](https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html)
    tutorial.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡ä»‹ç»äº†å¦‚ä½•å°†ç°æœ‰ä»£ç åº“è¿ç§»åˆ° `jax.Array`ã€‚æœ‰å…³å¦‚ä½•ä½¿ç”¨ `jax.Array` å’Œ JAX å¹¶è¡Œ API çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [Distributed
    arrays and automatic parallelization](https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html)
    æ•™ç¨‹ã€‚
- en: How to enable jax.Array?
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚ä½•å¯ç”¨ `jax.Array`ï¼Ÿ
- en: 'You can enable `jax.Array` by:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å¯ç”¨ `jax.Array`ï¼š
- en: setting the shell environment variable `JAX_ARRAY` to something true-like (e.g.,
    `1`);
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¾ç½® shell ç¯å¢ƒå˜é‡ `JAX_ARRAY` ä¸ºçœŸå€¼ï¼ˆä¾‹å¦‚ `1`ï¼‰ï¼›
- en: setting the boolean flag `jax_array` to something true-like if your code parses
    flags with absl;
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çš„ä»£ç ä½¿ç”¨ absl è§£ææ ‡å¿—ï¼Œå¯ä»¥å°†å¸ƒå°”æ ‡å¿— `jax_array` è®¾ç½®ä¸ºçœŸå€¼ï¼›
- en: 'using this statement at the top of your main file:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½ çš„ä¸»æ–‡ä»¶é¡¶éƒ¨åŠ å…¥ä»¥ä¸‹å£°æ˜ï¼š
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How do I know if jax.Array broke my code?
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚ä½•åˆ¤æ–­ `jax.Array` æ˜¯å¦ç ´åäº†æˆ‘çš„ä»£ç ï¼Ÿ
- en: The easiest way to tell if `jax.Array` is responsible for any problems is to
    disable `jax.Array` and see if the issues go away.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç®€å•çš„æ–¹æ³•æ˜¯ç¦ç”¨ `jax.Array`ï¼Œçœ‹çœ‹é—®é¢˜æ˜¯å¦è§£å†³ã€‚
- en: How can I disable jax.Array for now?
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æˆ‘å¦‚ä½•æš‚æ—¶ç¦ç”¨ `jax.Array`ï¼Ÿ
- en: 'Through **March 15, 2023** it will be possible to disable jax.Array by:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ **2023å¹´3æœˆ15æ—¥**ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ç¦ç”¨ `jax.Array`ï¼š
- en: setting the shell environment variable `JAX_ARRAY` to something falsey (e.g.,
    `0`);
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è®¾ç½® shell ç¯å¢ƒå˜é‡ `JAX_ARRAY` ä¸ºå‡å€¼ï¼ˆä¾‹å¦‚ `0`ï¼‰ï¼›
- en: setting the boolean flag `jax_array` to something falsey if your code parses
    flags with absl;
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çš„ä»£ç ä½¿ç”¨ absl è§£ææ ‡å¿—ï¼Œå¯ä»¥å°†å¸ƒå°”æ ‡å¿— `jax_array` è®¾ç½®ä¸ºå‡å€¼ï¼›
- en: 'using this statement at the top of your main file:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä½ çš„ä¸»æ–‡ä»¶é¡¶éƒ¨åŠ å…¥ä»¥ä¸‹å£°æ˜ï¼š
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why create jax.Array?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆåˆ›å»º `jax.Array`ï¼Ÿ
- en: Currently JAX has three types; `DeviceArray`, `ShardedDeviceArray` and `GlobalDeviceArray`.
    `jax.Array` merges these three types and cleans up JAXâ€™s internals while adding
    new parallelism features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‰ JAX æœ‰ä¸‰ç§ç±»å‹ï¼š`DeviceArray`ã€`ShardedDeviceArray` å’Œ `GlobalDeviceArray`ã€‚`jax.Array`
    åˆå¹¶äº†è¿™ä¸‰ç§ç±»å‹ï¼Œå¹¶æ¸…ç†äº† JAX çš„å†…éƒ¨ç»“æ„ï¼ŒåŒæ—¶å¢åŠ äº†æ–°çš„å¹¶è¡Œç‰¹æ€§ã€‚
- en: We also introduce a new `Sharding` abstraction that describes how a logical
    Array is physically sharded out across one or more devices, such as TPUs or GPUs.
    The change also upgrades, simplifies and merges the parallelism features of `pjit`
    into `jit`. Functions decorated with `jit` will be able to operate over sharded
    arrays without copying data onto a single device.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¼•å…¥äº†ä¸€ä¸ªæ–°çš„ `Sharding` æŠ½è±¡ï¼Œæè¿°äº†é€»è¾‘æ•°ç»„å¦‚ä½•åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªè®¾å¤‡ï¼ˆå¦‚TPUæˆ–GPUï¼‰ä¸Šç‰©ç†åˆ†ç‰‡ã€‚è¿™ä¸€å˜æ›´è¿˜å‡çº§ã€ç®€åŒ–å¹¶å°† `pjit`
    çš„å¹¶è¡Œæ€§ç‰¹æ€§åˆå¹¶åˆ° `jit` ä¸­ã€‚ä½¿ç”¨ `jit` è£…é¥°çš„å‡½æ•°å°†èƒ½å¤Ÿåœ¨åˆ†ç‰‡æ•°ç»„ä¸Šæ“ä½œï¼Œè€Œæ— éœ€å°†æ•°æ®å¤åˆ¶åˆ°å•ä¸ªè®¾å¤‡ä¸Šã€‚
- en: 'Features you get with `jax.Array`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `jax.Array` å¯ä»¥è·å¾—çš„åŠŸèƒ½ï¼š
- en: C++ `pjit` dispatch path
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ `pjit` åˆ†æ´¾è·¯å¾„
- en: Op-by-op parallelism (even if the array distributed across multiple devices
    across multiple hosts)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€æ“ä½œå¹¶è¡Œæ€§ï¼ˆå³ä½¿æ•°ç»„åˆ†å¸ƒåœ¨å¤šå°è®¾å¤‡ä¸Šï¼Œè·¨å¤šä¸ªä¸»æœºï¼‰
- en: Simpler batch data parallelism with `pjit`/`jit`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `pjit`/`jit` æ›´ç®€å•çš„æ‰¹æ•°æ®å¹¶è¡Œæ€§ã€‚
- en: Ways to create `Sharding`s that are not necessarily consisting of a mesh and
    partition spec. Can fully utilize the flexibility of OpSharding if you want or
    any other Sharding that you want.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯ä»¥å®Œå…¨åˆ©ç”¨ OpSharding çš„çµæ´»æ€§ï¼Œæˆ–è€…ä»»ä½•æ‚¨æƒ³è¦çš„å…¶ä»–åˆ†ç‰‡æ–¹å¼æ¥åˆ›å»ºä¸ä¸€å®šåŒ…å«ç½‘æ ¼å’Œåˆ†åŒºè§„èŒƒçš„ `Sharding`ã€‚
- en: and many more
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç­‰ç­‰
- en: 'Example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ï¼š
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What issues can arise when jax.Array is switched on?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åˆ‡æ¢åˆ° `jax.Array` åå¯èƒ½ä¼šå‡ºç°å“ªäº›é—®é¢˜ï¼Ÿ
- en: New public type named jax.Array
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ–°å…¬å…±ç±»å‹å‘½åä¸º `jax.Array`ã€‚
- en: All `isinstance(..., jnp.DeviceArray)` or `isinstance(.., jax.xla.DeviceArray)`
    and other variants of `DeviceArray` should be switched to using `isinstance(...,
    jax.Array)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰ `isinstance(..., jnp.DeviceArray)` æˆ– `isinstance(.., jax.xla.DeviceArray)`
    ä»¥åŠå…¶ä»– `DeviceArray` çš„å˜ä½“åº”è¯¥åˆ‡æ¢åˆ°ä½¿ç”¨ `isinstance(..., jax.Array)`ã€‚
- en: 'Since `jax.Array` can represent DA, SDA and GDA, you can differentiate those
    3 types in `jax.Array` via:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `jax.Array` å¯ä»¥è¡¨ç¤º DAã€SDA å’Œ GDAï¼Œæ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼åœ¨ `jax.Array` ä¸­åŒºåˆ†è¿™ä¸‰ç§ç±»å‹ï¼š
- en: '`x.is_fully_addressable and len(x.sharding.device_set) == 1` â€“ this means that
    `jax.Array` is like a DA'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x.is_fully_addressable and len(x.sharding.device_set) == 1` â€“ è¿™æ„å‘³ç€ `jax.Array`
    ç±»ä¼¼äº DAã€‚'
- en: '`x.is_fully_addressable and (len(x.sharding.device_set) > 1` â€“ this means that
    `jax.Array` is like a SDA'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x.is_fully_addressable and (len(x.sharding.device_set) > 1` â€“ è¿™æ„å‘³ç€ `jax.Array`
    ç±»ä¼¼äº SDAã€‚'
- en: '`not x.is_fully_addressable` â€“ this means that `jax.Array` is like a GDA and
    spans across multiple processes'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not x.is_fully_addressable` â€“ è¿™æ„å‘³ç€ `jax.Array` ç±»ä¼¼äº GDAï¼Œå¹¶è·¨å¤šä¸ªè¿›ç¨‹ã€‚'
- en: For `ShardedDeviceArray`, you can move `isinstance(..., pxla.ShardedDeviceArray)`
    to `isinstance(..., jax.Array) and x.is_fully_addressable and len(x.sharding.device_set)
    > 1`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº `ShardedDeviceArray`ï¼Œå¯ä»¥å°† `isinstance(..., pxla.ShardedDeviceArray)` è½¬ç§»åˆ° `isinstance(...,
    jax.Array) and x.is_fully_addressable and len(x.sharding.device_set) > 1`ã€‚
- en: In general it is not possible to differentiate a `ShardedDeviceArray` on 1 device
    from any other kind of single-device Array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æ— æ³•åŒºåˆ†å•è®¾å¤‡æ•°ç»„ä¸Šçš„ `ShardedDeviceArray` ä¸ä»»ä½•å…¶ä»–ç±»å‹çš„å•è®¾å¤‡æ•°ç»„ã€‚
- en: GDAâ€™s API name changes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GDA çš„ API åç§°å˜æ›´
- en: GDAâ€™s `local_shards` and `local_data` have been deprecated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GDA çš„ `local_shards` å’Œ `local_data` å·²ç»è¢«å¼ƒç”¨ã€‚
- en: Please use `addressable_shards` and `addressable_data` which are compatible
    with `jax.Array` and `GDA`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·ä½¿ç”¨ä¸ `jax.Array` å’Œ `GDA` å…¼å®¹çš„ `addressable_shards` å’Œ `addressable_data`ã€‚
- en: Creating jax.Array
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åˆ›å»º `jax.Array`ã€‚
- en: All JAX functions will output `jax.Array` when the `jax_array` flag is True.
    If you were using `GlobalDeviceArray.from_callback` or `make_sharded_device_array`
    or `make_device_array` functions to explicitly create the respective JAX data
    types, you will need to switch them to use `jax.make_array_from_callback()` or
    `jax.make_array_from_single_device_arrays()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ `jax_array` æ ‡å¿—ä¸ºçœŸæ—¶ï¼Œæ‰€æœ‰ JAX å‡½æ•°å°†è¾“å‡º `jax.Array`ã€‚å¦‚æœæ‚¨æ›¾ä½¿ç”¨ `GlobalDeviceArray.from_callback`ã€`make_sharded_device_array`
    æˆ– `make_device_array` å‡½æ•°æ˜¾å¼åˆ›å»ºç›¸åº”çš„ JAX æ•°æ®ç±»å‹ï¼Œåˆ™éœ€è¦åˆ‡æ¢ä¸ºä½¿ç”¨ `jax.make_array_from_callback()`
    æˆ– `jax.make_array_from_single_device_arrays()`ã€‚
- en: '**For GDA:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¯¹äº GDAï¼š**'
- en: '`GlobalDeviceArray.from_callback(shape, mesh, pspec, callback)` can become
    `jax.make_array_from_callback(shape, jax.sharding.NamedSharding(mesh, pspec),
    callback)` in a 1:1 switch.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalDeviceArray.from_callback(shape, mesh, pspec, callback)` å¯ä»¥ä¸€å¯¹ä¸€åœ°åˆ‡æ¢ä¸º `jax.make_array_from_callback(shape,
    jax.sharding.NamedSharding(mesh, pspec), callback)`ã€‚'
- en: 'If you were using the raw GDA constructor to create GDAs, then do this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æ›¾ä½¿ç”¨åŸå§‹çš„ GDA æ„é€ å‡½æ•°æ¥åˆ›å»º GDAsï¼Œåˆ™æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
- en: '`GlobalDeviceArray(shape, mesh, pspec, buffers)` can become `jax.make_array_from_single_device_arrays(shape,
    jax.sharding.NamedSharding(mesh, pspec), buffers)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlobalDeviceArray(shape, mesh, pspec, buffers)` å¯ä»¥å˜æˆ `jax.make_array_from_single_device_arrays(shape,
    jax.sharding.NamedSharding(mesh, pspec), buffers)`ã€‚'
- en: '**For SDA:**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¯¹äº SDAï¼š**'
- en: '`make_sharded_device_array(aval, sharding_spec, device_buffers, indices)` can
    become `jax.make_array_from_single_device_arrays(shape, sharding, device_buffers)`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_sharded_device_array(aval, sharding_spec, device_buffers, indices)` å¯ä»¥å˜æˆ
    `jax.make_array_from_single_device_arrays(shape, sharding, device_buffers)`ã€‚'
- en: 'To decide what the sharding should be, it depends on why you were creating
    the SDAs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¦å†³å®šåˆ†ç‰‡åº”è¯¥æ˜¯ä»€ä¹ˆï¼Œå–å†³äºæ‚¨åˆ›å»º SDA çš„åŸå› ï¼š
- en: 'If it was created to give as an input to `pmap`, then sharding can be: `jax.sharding.PmapSharding(devices,
    sharding_spec)`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒè¢«åˆ›å»ºä¸º `pmap` çš„è¾“å…¥ï¼Œåˆ™åˆ†ç‰‡å¯ä»¥æ˜¯ï¼š`jax.sharding.PmapSharding(devices, sharding_spec)`ã€‚
- en: If it was created to give as an input to `pjit`, then sharding can be `jax.sharding.NamedSharding(mesh,
    pspec)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå®ƒè¢«åˆ›å»ºä¸º pjit çš„è¾“å…¥ï¼Œåˆ™åˆ†ç‰‡å¯ä»¥æ˜¯ `jax.sharding.NamedSharding(mesh, pspec)`ã€‚
- en: Breaking change for pjit after switching to jax.Array for host local inputs
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åˆ‡æ¢åˆ° `jax.Array` åå¯¹äºä¸»æœºæœ¬åœ°è¾“å…¥çš„ pjit æœ‰ç ´åæ€§å˜æ›´ã€‚
- en: '**If you are exclusively using GDA arguments to pjit, you can skip this section!
    ğŸ‰**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¦‚æœæ‚¨å®Œå…¨ä½¿ç”¨ GDA å‚æ•°ä½œä¸º pjit çš„è¾“å…¥ï¼Œåˆ™å¯ä»¥è·³è¿‡æ­¤éƒ¨åˆ†ï¼ ğŸ‰**'
- en: With `jax.Array` enabled, all inputs to `pjit` must be globally shaped. This
    is a breaking change from the previous behavior where `pjit` would concatenate
    process-local arguments into a global value; this concatenation no longer occurs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ç”¨`jax.Array`åï¼Œæ‰€æœ‰ä¼ é€’ç»™`pjit`çš„è¾“å…¥å¿…é¡»æ˜¯å…¨å±€å½¢çŠ¶çš„ã€‚è¿™æ˜¯ä¸ä¹‹å‰è¡Œä¸ºä¸å…¼å®¹çš„å˜åŒ–ï¼Œä¹‹å‰çš„`pjit`ä¼šå°†è¿›ç¨‹æœ¬åœ°çš„å‚æ•°è¿æ¥æˆä¸€ä¸ªå…¨å±€å€¼ï¼›ç°åœ¨ä¸å†è¿›è¡Œæ­¤è¿æ¥ã€‚
- en: Why are we making this breaking change? Each array now says explicitly how its
    local shards fit into a global whole, rather than leaving it implicit. The more
    explicit representation also unlocks additional flexibility, for example the use
    of non-contiguous meshes with `pjit` which can improve efficiency on some TPU
    models.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦è¿›è¡Œè¿™ä¸ªçªç ´æ€§çš„å˜åŒ–ï¼Ÿç°åœ¨æ¯ä¸ªæ•°ç»„éƒ½æ˜ç¡®è¯´æ˜äº†å®ƒçš„æœ¬åœ°åˆ†ç‰‡å¦‚ä½•é€‚åˆå…¨å±€æ•´ä½“ï¼Œè€Œä¸æ˜¯ç•™ä¸‹éšå«çš„æƒ…å†µã€‚æ›´æ˜ç¡®çš„è¡¨ç¤ºæ–¹å¼è¿˜å¯ä»¥è§£é”é¢å¤–çš„çµæ´»æ€§ï¼Œä¾‹å¦‚åœ¨æŸäº›TPUæ¨¡å‹ä¸Šå¯ä»¥æé«˜æ•ˆç‡çš„éè¿ç»­ç½‘æ ¼ä½¿ç”¨`pjit`ã€‚
- en: 'Running **multi-process pjit computation** and passing host-local inputs when
    `jax.Array` is enabled can lead to an error similar to this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¯ç”¨`jax.Array`æ—¶ï¼Œè¿è¡Œ**å¤šè¿›ç¨‹pjitè®¡ç®—**å¹¶åœ¨ä¼ é€’ä¸»æœºæœ¬åœ°è¾“å…¥æ—¶å¯èƒ½ä¼šå¯¼è‡´ç±»ä¼¼ä»¥ä¸‹é”™è¯¯ï¼š
- en: 'Example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ï¼š
- en: 'Mesh = `{''x'': 2, ''y'': 2, ''z'': 2}` and host local input shape == `(4,)`
    and pspec = `P((''x'', ''y'', ''z''))`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mesh = {''x'': 2, ''y'': 2, ''z'': 2}` å’Œä¸»æœºæœ¬åœ°è¾“å…¥å½¢çŠ¶ == `(4,)` ä»¥åŠ`pspec = P((''x'',
    ''y'', ''z''))`'
- en: 'Since `pjit` doesnâ€™t lift host local shapes to global shapes with `jax.Array`,
    you get the following error:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º`pjit`ä¸ä¼šå°†ä¸»æœºæœ¬åœ°å½¢çŠ¶æå‡ä¸ºå…¨å±€å½¢çŠ¶ï¼Œæ‰€ä»¥æ‚¨ä¼šæ”¶åˆ°ä»¥ä¸‹é”™è¯¯ï¼š
- en: 'Note: You will only see this error if your host local shape is smaller than
    the shape of the mesh.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šåªæœ‰å½“æ‚¨çš„ä¸»æœºæœ¬åœ°å½¢çŠ¶å°äºç½‘æ ¼çš„å½¢çŠ¶æ—¶ï¼Œæ‰ä¼šçœ‹åˆ°æ­¤é”™è¯¯ã€‚
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The error makes sense because you canâ€™t shard dimension 0, 8 ways when the value
    on dimension `0` is `4`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: é”™è¯¯å‡ºç°æ˜¯å› ä¸ºå½“ç»´åº¦`0`ä¸Šçš„å€¼ä¸º`4`æ—¶ï¼Œæ— æ³•å°†å…¶åˆ†ç‰‡æˆ8ä»½ã€‚
- en: 'How can you migrate if you still pass host local inputs to `pjit`? We are providing
    transitional APIs to help you migrate:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»ç„¶å°†ä¸»æœºæœ¬åœ°è¾“å…¥ä¼ é€’ç»™`pjit`ï¼Œå¦‚ä½•è¿ç§»ï¼Ÿæˆ‘ä»¬æä¾›äº†è¿‡æ¸¡APIæ¥å¸®åŠ©æ‚¨è¿ç§»ï¼š
- en: 'Note: You donâ€™t need these utilities if you run your pjitted computation on
    a single process.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šå¦‚æœæ‚¨åœ¨å•è¿›ç¨‹ä¸Šè¿è¡Œ`pjit`è®¡ç®—ï¼Œåˆ™ä¸éœ€è¦è¿™äº›å®ç”¨ç¨‹åºã€‚
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`host_local_array_to_global_array` is a type cast that looks at a value with
    only local shards and changes its local shape to the shape that `pjit` would have
    previously assumed if that value was passed before the change.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`host_local_array_to_global_array`æ˜¯ä¸€ç§ç±»å‹è½¬æ¢ï¼Œå®ƒæŸ¥çœ‹å…·æœ‰ä»…æœ¬åœ°åˆ†ç‰‡çš„å€¼ï¼Œå¹¶å°†å…¶æœ¬åœ°å½¢çŠ¶æ›´æ”¹ä¸ºåœ¨æ›´æ”¹ä¹‹å‰å¦‚æœä¼ é€’è¯¥å€¼`pjit`ä¼šå‡å®šçš„å½¢çŠ¶ã€‚'
- en: Passing in fully replicated inputs i.e. same shape on each process with `P(None)`
    as `in_axis_resources` is still supported. In this case you do not have to use
    `host_local_array_to_global_array` because the shape is already global.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æ”¯æŒå®Œå…¨å¤åˆ¶çš„è¾“å…¥ï¼Œå³æ¯ä¸ªè¿›ç¨‹ä¸Šå…·æœ‰ç›¸åŒå½¢çŠ¶ï¼Œå¹¶ä¸”`in_axis_resources`ä¸º`P(None)`çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨æ— éœ€ä½¿ç”¨`host_local_array_to_global_array`ï¼Œå› ä¸ºå½¢çŠ¶å·²ç»æ˜¯å…¨å±€çš„ã€‚
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: FROM_GDA and jax.Array
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`FROM_GDA`å’Œ`jax.Array`'
- en: If you were using `FROM_GDA` in `in_axis_resources` argument to `pjit`, then
    with `jax.Array` there is no need to pass anything to `in_axis_resources` as `jax.Array`
    will follow **computation follows sharding** semantics.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åœ¨`in_axis_resources`å‚æ•°ä¸­ä½¿ç”¨`FROM_GDA`æ¥ä¼ é€’ç»™`pjit`ï¼Œé‚£ä¹ˆåœ¨ä½¿ç”¨`jax.Array`æ—¶ï¼Œæ— éœ€å‘`in_axis_resources`ä¼ é€’ä»»ä½•å†…å®¹ï¼Œå› ä¸º`jax.Array`å°†éµå¾ª**è®¡ç®—éµå¾ªåˆ†ç‰‡**çš„è¯­ä¹‰ã€‚
- en: 'For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼š
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have PartitionSpecs mixed in with `FROM_GDA` for inputs like numpy arrays,
    etc, then use `host_local_array_to_global_array` to convert them to `jax.Array`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çš„è¾“å…¥ä¸­æ··åˆäº†`PartitionSpecs`å’Œ`FROM_GDA`ï¼Œä¾‹å¦‚numpyæ•°ç»„ç­‰ï¼Œåˆ™ä½¿ç”¨`host_local_array_to_global_array`å°†å®ƒä»¬è½¬æ¢ä¸º`jax.Array`ã€‚
- en: 'For example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼š
- en: 'If you had this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æœ‰è¿™æ ·çš„æƒ…å†µï¼š
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'then you can replace it with:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæ‚¨å¯ä»¥å°†å…¶æ›¿æ¢ä¸ºï¼š
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: live_buffers replaced with live_arrays
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`live_buffers`æ›¿æ¢ä¸º`live_arrays`ã€‚'
- en: '`live_buffers` attribute on jax `Device` has been deprecated. Please use `jax.live_arrays()`
    instead which is compatible with `jax.Array`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: jax `Device`ä¸Šçš„`live_buffers`å±æ€§å·²è¢«å¼ƒç”¨ã€‚è¯·æ”¹ç”¨ä¸`jax.Array`å…¼å®¹çš„`jax.live_arrays()`ã€‚
- en: Handling of host local inputs to pjit like batch, etc
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¤„ç†å‘`pjit`ä¼ é€’çš„ä¸»æœºæœ¬åœ°è¾“å…¥ï¼Œä¾‹å¦‚æ‰¹æ¬¡ç­‰ã€‚
- en: If you are passing host local inputs to `pjit` in a **multi-process environment**,
    then please use `multihost_utils.host_local_array_to_global_array` to convert
    the batch to a global `jax.Array` and then pass that to `pjit`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåœ¨**å¤šè¿›ç¨‹ç¯å¢ƒ**ä¸­å‘`pjit`ä¼ é€’ä¸»æœºæœ¬åœ°è¾“å…¥ï¼Œè¯·ä½¿ç”¨`multihost_utils.host_local_array_to_global_array`å°†æ‰¹æ¬¡è½¬æ¢ä¸ºå…¨å±€`jax.Array`ï¼Œç„¶åå°†å…¶ä¼ é€’ç»™`pjit`ã€‚
- en: The most common example of such a host local input is a **batch of input data**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ä¸»æœºæœ¬åœ°è¾“å…¥æœ€å¸¸è§çš„ä¾‹å­æ˜¯**è¾“å…¥æ•°æ®æ‰¹æ¬¡**ã€‚
- en: This will work for any host local input (not just a batch of input data).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹ä»»ä½•ä¸»æœºæœ¬åœ°è¾“å…¥éƒ½æœ‰æ•ˆï¼ˆä¸ä»…ä»…æ˜¯è¾“å…¥æ•°æ®æ‰¹æ¬¡ï¼‰ã€‚
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See the pjit section above for more details about this change and more examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºè¿™ç§å˜åŒ–ä»¥åŠæ›´å¤šç¤ºä¾‹ï¼Œè¯·å‚é˜…ä¸Šé¢çš„pjitéƒ¨åˆ†ã€‚
- en: 'RecursionError: Recursively calling jit'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RecursionErrorï¼šé€’å½’è°ƒç”¨ jit æ—¶å‘ç”Ÿçš„é”™è¯¯ã€‚
- en: This happens when some part of your code has `jax.Array` disabled and then you
    enable it only for some other part. For example, if you use some third_party code
    which has `jax.Array` disabled and you get a `DeviceArray` from that library and
    then you enable `jax.Array` in your library and pass that `DeviceArray` to JAX
    functions, it will lead to a RecursionError.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ çš„ä»£ç çš„æŸéƒ¨åˆ†ç¦ç”¨äº† `jax.Array`ï¼Œç„¶åä½ ä»…åœ¨å…¶ä»–éƒ¨åˆ†å¯ç”¨å®ƒæ—¶ä¼šå‡ºç°è¿™ç§æƒ…å†µã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨æŸäº›ç¬¬ä¸‰æ–¹ä»£ç ï¼Œè¯¥ä»£ç å·²ç¦ç”¨äº† `jax.Array`
    å¹¶ä»è¯¥åº“è·å¾—ä¸€ä¸ª `DeviceArray`ï¼Œç„¶ååœ¨ä½ çš„åº“ä¸­å¯ç”¨ `jax.Array` å¹¶å°†è¯¥ `DeviceArray` ä¼ é€’ç»™ JAX å‡½æ•°ï¼Œå°±ä¼šå¯¼è‡´
    RecursionErrorã€‚
- en: This error should go away when `jax.Array` is enabled by default so that all
    libraries return `jax.Array` unless they explicitly disable it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ `jax.Array` é»˜è®¤å¯ç”¨æ—¶ï¼Œæ‰€æœ‰åº“éƒ½è¿”å› `jax.Array`ï¼Œé™¤éæ˜¾å¼ç¦ç”¨å®ƒï¼Œè¿™ä¸ªé”™è¯¯å°±åº”è¯¥æ¶ˆå¤±ã€‚
