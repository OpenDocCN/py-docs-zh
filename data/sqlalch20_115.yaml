- en: Connections / Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接 / 引擎
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/connections.html](https://docs.sqlalchemy.org/en/20/faq/connections.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/faq/connections.html](https://docs.sqlalchemy.org/en/20/faq/connections.html)
- en: '[How do I configure logging?](#how-do-i-configure-logging)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我如何配置日志记录？](#how-do-i-configure-logging)'
- en: '[How do I pool database connections? Are my connections pooled?](#how-do-i-pool-database-connections-are-my-connections-pooled)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我如何池化数据库连接？我的连接被池化了吗？](#how-do-i-pool-database-connections-are-my-connections-pooled)'
- en: '[How do I pass custom connect arguments to my database API?](#how-do-i-pass-custom-connect-arguments-to-my-database-api)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我如何传递自定义连接参数给我的数据库 API？](#how-do-i-pass-custom-connect-arguments-to-my-database-api)'
- en: '[“MySQL Server has gone away”](#mysql-server-has-gone-away)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“MySQL 服务器已断开连接”](#mysql-server-has-gone-away)'
- en: '[“Commands out of sync; you can’t run this command now” / “This result object
    does not return rows. It has been closed automatically”](#commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“命令不同步；您现在无法运行此命令” / “此结果对象不返回行。它已被自动关闭”](#commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically)'
- en: '[How Do I “Retry” a Statement Execution Automatically?](#how-do-i-retry-a-statement-execution-automatically)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何自动“重试”语句执行？](#how-do-i-retry-a-statement-execution-automatically)'
- en: '[Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect](#using-dbapi-autocommit-allows-for-a-readonly-version-of-transparent-reconnect)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 DBAPI 自动提交允许透明重连的只读版本](#using-dbapi-autocommit-allows-for-a-readonly-version-of-transparent-reconnect)'
- en: '[Why does SQLAlchemy issue so many ROLLBACKs?](#why-does-sqlalchemy-issue-so-many-rollbacks)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么 SQLAlchemy 发出那么多回滚？](#why-does-sqlalchemy-issue-so-many-rollbacks)'
- en: '[I’m on MyISAM - how do I turn it off?](#i-m-on-myisam-how-do-i-turn-it-off)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用 MyISAM - 如何关闭它？](#i-m-on-myisam-how-do-i-turn-it-off)'
- en: '[I’m on SQL Server - how do I turn those ROLLBACKs into COMMITs?](#i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用 SQL Server - 如何将那些回滚变成提交？](#i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits)'
- en: '[I am using multiple connections with a SQLite database (typically to test
    transaction operation), and my test program is not working!](#i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用 SQLite 数据库的多个连接（通常用于测试事务操作），但我的测试程序不起作用！](#i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working)'
- en: '[How do I get at the raw DBAPI connection when using an Engine?](#how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在使用引擎时如何获取原始 DBAPI 连接？](#how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine)'
- en: '[Accessing the underlying connection for an asyncio driver](#accessing-the-underlying-connection-for-an-asyncio-driver)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[访问 asyncio 驱动程序的底层连接](#accessing-the-underlying-connection-for-an-asyncio-driver)'
- en: '[How do I use engines / connections / sessions with Python multiprocessing,
    or os.fork()?](#how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在 Python 多进程或 os.fork() 中使用引擎 / 连接 / 会话？](#how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork)'
- en: How do I configure logging?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何配置日志记录？
- en: See [Configuring Logging](../core/engines.html#dbengine-logging).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [配置日志记录](../core/engines.html#dbengine-logging)。
- en: How do I pool database connections? Are my connections pooled?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何池化数据库连接？我的连接被池化了吗？
- en: SQLAlchemy performs application-level connection pooling automatically in most
    cases. For all included dialects (except SQLite when using a “memory” database),
    a [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object refers to a [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as a source of connectivity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在大多数情况下会自动执行应用程序级别的连接池。对于所有包含的方言（除了在使用“内存”数据库时的 SQLite 外），[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象都指向 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") 作为连接的来源。
- en: For more detail, see [Engine Configuration](../core/engines.html) and [Connection
    Pooling](../core/pooling.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请参阅 [引擎配置](../core/engines.html) 和 [连接池](../core/pooling.html)。
- en: How do I pass custom connect arguments to my database API?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何传递自定义连接参数给我的数据库 API？
- en: 'The [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    call accepts additional arguments either directly via the `connect_args` keyword
    argument:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    调用可以通过 `connect_args` 关键字参数直接接受附加参数：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or for basic string and integer arguments, they can usually be specified in
    the query string of the URL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于基本的字符串和整数参数，它们通常可以在 URL 的查询字符串中指定：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Custom DBAPI connect() arguments / on-connect routines](../core/engines.html#custom-dbapi-args)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义 DBAPI connect() 参数 / 连接时例程](../core/engines.html#custom-dbapi-args)'
- en: “MySQL Server has gone away”
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “MySQL 服务器已断开连接”
- en: The primary cause of this error is that the MySQL connection has timed out and
    has been closed by the server. The MySQL server closes connections which have
    been idle a period of time which defaults to eight hours. To accommodate this,
    the immediate setting is to enable the [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") setting, which will ensure that a connection which
    is older than a set amount of seconds will be discarded and replaced with a new
    connection when it is next checked out.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误的主要原因是 MySQL 连接已超时并已被服务器关闭。 MySQL 服务器会关闭空闲了一段时间（默认为八小时）的连接。 为了适应此情况，可立即设置为启用
    [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") 设置，这将确保比一定时间旧的连接在下次检出时将被丢弃并替换为新连接。
- en: For the more general case of accommodating database restarts and other temporary
    loss of connectivity due to network issues, connections that are in the pool may
    be recycled in response to more generalized disconnect detection techniques. The
    section [Dealing with Disconnects](../core/pooling.html#pool-disconnects) provides
    background on both “pessimistic” (e.g. pre-ping) and “optimistic” (e.g. graceful
    recovery) techniques. Modern SQLAlchemy tends to favor the “pessimistic” approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更一般的情况，如适应数据库重新启动和由于网络问题而导致的临时连接丢失，池中的连接可能会在响应更广泛的断开连接检测技术时进行回收利用。 章节 [处理断开连接](../core/pooling.html#pool-disconnects)
    提供了关于“悲观”（例如预检）和“乐观”（例如优雅恢复）技术的背景。 现代 SQLAlchemy 倾向于采用“悲观”方法。
- en: See also
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dealing with Disconnects](../core/pooling.html#pool-disconnects)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理断开连接](../core/pooling.html#pool-disconnects)'
- en: '## “Commands out of sync; you can’t run this command now” / “This result object
    does not return rows. It has been closed automatically”'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '## “命令不同步；您现在无法运行此命令” / “此结果对象不返回行。 它已被自动关闭”'
- en: The MySQL drivers have a fairly wide class of failure modes whereby the state
    of the connection to the server is in an invalid state. Typically, when the connection
    is used again, one of these two error messages will occur. The reason is because
    the state of the server has been changed to one in which the client library does
    not expect, such that when the client library emits a new statement on the connection,
    the server does not respond as expected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 驱动程序存在一类失败模式，其中与服务器的连接状态处于无效状态。 通常，当再次使用连接时，将出现这两种错误消息之一。 原因是服务器的状态已更改为客户端库不期望的状态，因此当客户端库在连接上发出新语句时，服务器不会如预期地响应。
- en: In SQLAlchemy, because database connections are pooled, the issue of the messaging
    being out of sync on a connection becomes more important, since when an operation
    fails, if the connection itself is in an unusable state, if it goes back into
    the connection pool, it will malfunction when checked out again. The mitigation
    for this issue is that the connection is **invalidated** when such a failure mode
    occurs so that the underlying database connection to MySQL is discarded. This
    invalidation occurs automatically for many known failure modes and can also be
    called explicitly via the [`Connection.invalidate()`](../core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，由于数据库连接是池化的，连接上的消息不同步的问题变得更加重要，因为当操作失败时，如果连接本身处于不可用状态，如果它再次返回到连接池中，那么在再次检出时将会发生故障。
    对此问题的缓解措施是当发生这种故障模式时连接被**作废**，以便底层 MySQL 数据库连接被丢弃。 对于许多已知的故障模式，此作废会自动发生，也可以通过
    [`Connection.invalidate()`](../core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") 方法显式调用。
- en: There is also a second class of failure modes within this category where a context
    manager such as `with session.begin_nested():` wants to “roll back” the transaction
    when an error occurs; however within some failure modes of the connection, the
    rollback itself (which can also be a RELEASE SAVEPOINT operation) also fails,
    causing misleading stack traces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类别中还存在第二类故障模式，其中上下文管理器（例如`with session.begin_nested():`）希望在发生错误时“回滚”事务； 但是在某些连接的故障模式中，回滚本身（也可以是RELEASE
    SAVEPOINT操作）也会失败，导致误导性的堆栈跟踪。
- en: 'Originally, the cause of this error used to be fairly simple, it meant that
    a multithreaded program was invoking commands on a single connection from more
    than one thread. This applied to the original “MySQLdb” native-C driver that was
    pretty much the only driver in use. However, with the introduction of pure Python
    drivers like PyMySQL and MySQL-connector-Python, as well as increased use of tools
    such as gevent/eventlet, multiprocessing (often with Celery), and others, there
    is a whole series of factors that has been known to cause this problem, some of
    which have been improved across SQLAlchemy versions but others which are unavoidable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，此错误的原因相当简单，它意味着多线程程序从多个线程调用单个连接上的命令。 这适用于原始的“MySQLdb”本机C驱动程序，这几乎是唯一使用的驱动程序。
    但是，随着纯Python驱动程序（如PyMySQL和MySQL-connector-Python）的引入，以及诸如gevent/eventlet、多处理（通常与Celery一起使用）等工具的增加使用，已知有一整套因素会导致这个问题，其中一些因素已经在SQLAlchemy的不同版本中得到改进，但其他因素是无法避免的：
- en: '**Sharing a connection among threads** - This is the original reason these
    kinds of errors occurred. A program used the same connection in two or more threads
    at the same time, meaning multiple sets of messages got mixed up on the connection,
    putting the server-side session into a state that the client no longer knows how
    to interpret. However, other causes are usually more likely today.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线程之间共享连接** - 这是这类错误发生的最初原因。 程序在同一时间在两个或多个线程中使用同一个连接，这意味着多组消息在连接上混合在一起，将服务器端会话置于客户端不再知道如何解释的状态。
    但是，如今通常更有可能出现其他原因。'
- en: '**Sharing the filehandle for the connection among processes** - This usually
    occurs when a program uses `os.fork()` to spawn a new process, and a TCP connection
    that is present in th parent process gets shared into one or more child processes.
    As multiple processes are now emitting messages to essentially the same filehandle,
    the server receives interleaved messages and breaks the state of the connection.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在进程之间共享连接的文件句柄** - 这通常发生在程序使用`os.fork()`生成新进程时，父进程中存在的TCP连接被共享到一个或多个子进程。
    由于多个进程现在向本质上是相同文件句柄的服务器发送消息，因此服务器接收到交错的消息并破坏连接的状态。'
- en: This scenario can occur very easily if a program uses Python’s “multiprocessing”
    module and makes use of an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that was created in the parent process. It’s common
    that “multiprocessing” is in use when using tools like Celery. The correct approach
    should be either that a new [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is produced when a child process first starts, discarding
    any [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that came down from the parent process; or, the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that’s inherited from the parent process can have
    it’s internal pool of connections disposed by calling [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose").
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果程序使用Python的“multiprocessing”模块，并使用在父进程中创建的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，则此场景可能非常容易发生。 使用工具如Celery时通常会使用“multiprocessing”。
    正确的方法应该是在子进程首次启动时生成一个新的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，丢弃从父进程传递下来的任何[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")； 或者，从父进程继承的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")可以通过调用[`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose")来处理其内部连接池。
- en: '**Greenlet Monkeypatching w/ Exits** - When using a library like gevent or
    eventlet that monkeypatches the Python networking API, libraries like PyMySQL
    are now working in an asynchronous mode of operation, even though they are not
    developed explicitly against this model. A common issue is that a greenthread
    is interrupted, often due to timeout logic in the application. This results in
    the `GreenletExit` exception being raised, and the pure-Python MySQL driver is
    interrupted from its work, which may have been that it was receiving a response
    from the server or preparing to otherwise reset the state of the connection. When
    the exception cuts all that work short, the conversation between client and server
    is now out of sync and subsequent usage of the connection may fail. SQLAlchemy
    as of version 1.1.0 knows how to guard against this, as if a database operation
    is interrupted by a so-called “exit exception”, which includes `GreenletExit`
    and any other subclass of Python `BaseException` that is not also a subclass of
    `Exception`, the connection is invalidated.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Greenlet Monkeypatching w/ Exits** - 当使用像gevent或eventlet这样的库对Python网络API进行monkeypatch时，像PyMySQL这样的库现在以异步模式运行，即使它们并没有明确针对这种模型开发。一个常见问题是greenthread被中断，通常是由于应用程序中的超时逻辑。这导致引发`GreenletExit`异常，并且纯Python
    MySQL驱动程序被中断了其工作，可能是正在接收来自服务器的响应或准备以其他方式重置连接状态。当异常中断所有这些工作时，客户端和服务器之间的对话现在不同步，后续使用连接可能会失败。从版本1.1.0开始，SQLAlchemy知道如何防范这种情况，如果数据库操作被所谓的“退出异常”中断，其中包括`GreenletExit`和任何不是`Exception`的Python
    `BaseException`的子类，连接将被作废。'
- en: '**Rollbacks / SAVEPOINT releases failing** - Some classes of error cause the
    connection to be unusable within the context of a transaction, as well as when
    operating in a “SAVEPOINT” block. In these cases, the failure on the connection
    has rendered any SAVEPOINT as no longer existing, yet when SQLAlchemy, or the
    application, attempts to “roll back” this savepoint, the “RELEASE SAVEPOINT” operation
    fails, typically with a message like “savepoint does not exist”. In this case,
    under Python 3 there will be a chain of exceptions output, where the ultimate
    “cause” of the error will be displayed as well. Under Python 2, there are no “chained”
    exceptions, however recent versions of SQLAlchemy will attempt to emit a warning
    illustrating the original failure cause, while still throwing the immediate error
    which is the failure of the ROLLBACK.  ## How Do I “Retry” a Statement Execution
    Automatically?'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚/SAVEPOINT释放失败** - 某些类别的错误导致连接在事务上下文中无法使用，以及在“SAVEPOINT”块中操作时。在这些情况下，连接上的失败使任何SAVEPOINT不再存在，但当SQLAlchemy或应用程序尝试“回滚”此保存点时，“RELEASE
    SAVEPOINT”操作失败，通常会显示类似“savepoint does not exist”的消息。在这种情况下，在Python 3下会输出一系列异常，其中最终的错误“原因”也将被显示。在Python
    2下，没有“链接”异常，但是最近的SQLAlchemy版本将尝试发出警告，说明原始失败原因，同时仍会抛出立即错误，即ROLLBACK的失败。## 如何自动“重试”语句执行？'
- en: The documentation section [Dealing with Disconnects](../core/pooling.html#pool-disconnects)
    discusses the strategies available for pooled connections that have been disconnected
    since the last time a particular connection was checked out. The most modern feature
    in this regard is the [`create_engine.pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pre_ping
    "sqlalchemy.create_engine") parameter, which allows that a “ping” is emitted on
    a database connection when it’s retrieved from the pool, reconnecting if the current
    connection has been disconnected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文档部分[处理断开连接](../core/pooling.html#pool-disconnects)讨论了对已自上次检查特定连接以来已断开的连接可用的策略。在这方面最现代的功能是[`create_engine.pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pre_ping
    "sqlalchemy.create_engine")参数，它允许在从池中检索数据库连接时发出“ping”，如果当前连接已断开，则重新连接。
- en: It’s important to note that this “ping” is only emitted **before** the connection
    is actually used for an operation. Once the connection is delivered to the caller,
    per the Python [DBAPI](../glossary.html#term-DBAPI) specification it is now subject
    to an **autobegin** operation, which means it will automatically BEGIN a new transaction
    when it is first used that remains in effect for subsequent statements, until
    the DBAPI-level `connection.commit()` or `connection.rollback()` method is invoked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，“ping” 仅在连接实际用于操作之前发出。一旦连接交付给调用方，根据 Python [DBAPI](../glossary.html#term-DBAPI)
    规范，它现在将受到 **自动启动** 操作的影响，这意味着当首次使用连接时将自动开始一个新事务，该事务将在后续语句中保持有效，直到调用 DBAPI 级别的
    `connection.commit()` 或 `connection.rollback()` 方法。
- en: In modern use of SQLAlchemy, a series of SQL statements are always invoked within
    this transactional state, assuming [DBAPI autocommit mode](../core/connections.html#dbapi-autocommit)
    is not enabled (more on that in the next section), meaning that no single statement
    is automatically committed; if an operation fails, the effects of all statements
    within the current transaction will be lost.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 的现代用法中，一系列 SQL 语句始终在这个事务状态下调用，假设未启用 [DBAPI 自动提交模式](../core/connections.html#dbapi-autocommit)（关于此后面会有更多介绍），这意味着没有单个语句会自动提交；如果操作失败，当前事务中所有语句的效果将丢失。
- en: The implication that this has for the notion of “retrying” a statement is that
    in the default case, when a connection is lost, **the entire transaction is lost**.
    There is no useful way that the database can “reconnect and retry” and continue
    where it left off, since data is already lost. For this reason, SQLAlchemy does
    not have a transparent “reconnection” feature that works mid-transaction, for
    the case when the database connection has disconnected while being used. The canonical
    approach to dealing with mid-operation disconnects is to **retry the entire operation
    from the start of the transaction**, often by using a custom Python decorator
    that will “retry” a particular function several times until it succeeds, or to
    otherwise architect the application in such a way that it is resilient against
    transactions that are dropped that then cause operations to fail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于“重试”语句的概念意味着在默认情况下，当连接丢失时，**整个事务都将丢失**。数据库无法“重新连接和重试”并继续之前的操作，因为数据已经丢失。因此，SQLAlchemy
    没有一个在事务中途重新连接的透明“重连”功能。处理中途断开连接的操作的标准方法是**从事务开始处重新尝试整个操作**，通常通过使用一个自定义的 Python
    装饰器，该装饰器会多次“重试”特定函数直到成功，或以其他方式设计应用程序以使其能够抵御因事务断开而导致操作失败。
- en: There is also the notion of extensions that can keep track of all of the statements
    that have proceeded within a transaction and then replay them all in a new transaction
    in order to approximate a “retry” operation. SQLAlchemy’s [event system](../core/events.html)
    does allow such a system to be constructed, however this approach is also not
    generally useful as there is no way to guarantee that those [DML](../glossary.html#term-DML)
    statements will be working against the same state, as once a transaction has ended
    the state of the database in a new transaction may be totally different. Architecting
    “retry” explicitly into the application at the points at which transactional operations
    begin and commit remains the better approach since the application-level transactional
    methods are the ones that know best how to re-run their steps.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个扩展概念，可以跟踪事务中执行的所有语句，然后在新事务中重播它们以近似“重试”操作。SQLAlchemy 的 [事件系统](../core/events.html)
    确实允许构建这样一个系统，但这种方法通常也不太有用，因为无法保证这些 [DML](../glossary.html#term-DML) 语句是否针对相同的状态进行操作，一旦事务结束，新事务中的数据库状态可能完全不同。在事务操作开始和提交的地方显式地构建“重试”到应用程序中仍然是更好的方法，因为应用程序级别的事务方法最了解如何重新运行它们的步骤。
- en: Otherwise, if SQLAlchemy were to provide a feature that transparently and silently
    “reconnected” a connection mid-transaction, the effect would be that data is silently
    lost. By trying to hide the problem, SQLAlchemy would make the situation much
    worse.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果 SQLAlchemy 提供了一个在事务中途自动且悄无声息地“重新连接”连接的功能，那么效果将是数据被悄无声息地丢失。通过试图隐藏问题，SQLAlchemy
    将使情况变得更糟。
- en: However, if we are **not** using transactions, then there are more options available,
    as the next section describes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们 **不** 使用事务，那么就会有更多的选项可用，下一节将描述这些选项。
- en: '### Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用DBAPI自动提交允许透明重新连接的只读版本'
- en: With the rationale for not having a transparent reconnection mechanism stated,
    the preceding section rests upon the assumption that the application is in fact
    using DBAPI-level transactions. As most DBAPIs now offer [native “autocommit”
    settings](../core/connections.html#dbapi-autocommit), we can make use of these
    features to provide a limited form of transparent reconnect for **read only, autocommit
    only operations**. A transparent statement retry may be applied to the `cursor.execute()`
    method of the DBAPI, however it is still not safe to apply to the `cursor.executemany()`
    method of the DBAPI, as the statement may have consumed any portion of the arguments
    given.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在说明不具有透明重新连接机制的基础上，上一节假设应用实际上正在使用DBAPI级别的事务。由于大多数DBAPI现在提供了[本机的“自动提交”设置](../core/connections.html#dbapi-autocommit)，我们可以利用这些特性为**只读，仅自动提交操作**提供有限的透明重新连接形式。可以将透明语句重试应用于DBAPI的`cursor.execute()`方法，但是仍然不安全应用于DBAPI的`cursor.executemany()`方法，因为语句可能已经消耗了给定参数的任何部分。
- en: Warning
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The following recipe should **not** be used for operations that write data.
    Users should carefully read and understand how the recipe works and test failure
    modes very carefully against the specifically targeted DBAPI driver before making
    production use of this recipe. The retry mechanism does not guarantee prevention
    of disconnection errors in all cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不应将以下方案用于编写数据的操作。用户应该仔细阅读并了解该方案的工作原理，并在将该方案投入生产使用之前对特定的目标DBAPI驱动程序非常仔细地测试故障模式。重试机制不能保证在所有情况下防止断开连接错误。
- en: 'A simple retry mechanism may be applied to the DBAPI level `cursor.execute()`
    method by making use of the [`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute") and [`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params") hooks, which will be able
    to intercept disconnections during statement executions. It will **not** intercept
    connection failures during result set fetch operations, for those DBAPIs that
    don’t fully buffer result sets. The recipe requires that the database support
    DBAPI level autocommit and is **not guaranteed** for particular backends. A single
    function `reconnecting_engine()` is presented which applies the event hooks to
    a given [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, returning an always-autocommit version that enables DBAPI-level autocommit.
    A connection will transparently reconnect for single-parameter and no-parameter
    statement executions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过利用[`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute")和[`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params")钩子向DBAPI级别的`cursor.execute()`方法应用简单的重试机制，该机制将能够在语句执行期间拦截断开连接。它将**不会**拦截在结果集获取操作期间的连接失败，对于那些不完全缓冲结果集的DBAPI。该方案要求数据库支持DBAPI级别的自动提交，并且**不能保证**适用于特定的后端。提供了一个名为`reconnecting_engine()`的单一函数，它将事件钩子应用于给定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象，返回一个总是自动提交的版本，该版本支持DBAPI级别的自动提交。连接将在单参数和无参数语句执行时自动重新连接：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Given the above recipe, a reconnection mid-transaction may be demonstrated
    using the following proof of concept script. Once run, it will emit a `SELECT
    1` statement to the database every five seconds:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定上述方案，可以使用以下概念验证脚本演示事务中的重新连接。运行一次后，它将每五秒向数据库发出一个`SELECT 1`语句：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Restart the database while the script runs to demonstrate the transparent reconnect
    operation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行时重新启动数据库，以演示透明重新连接操作：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above recipe is tested for SQLAlchemy 1.4.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方案已针对SQLAlchemy 1.4进行了测试。
- en: Why does SQLAlchemy issue so many ROLLBACKs?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么SQLAlchemy会发出那么多的ROLLBACK？
- en: SQLAlchemy currently assumes DBAPI connections are in “non-autocommit” mode
    - this is the default behavior of the Python database API, meaning it must be
    assumed that a transaction is always in progress. The connection pool issues `connection.rollback()`
    when a connection is returned. This is so that any transactional resources remaining
    on the connection are released. On a database like PostgreSQL or MSSQL where table
    resources are aggressively locked, this is critical so that rows and tables don’t
    remain locked within connections that are no longer in use. An application can
    otherwise hang. It’s not just for locks, however, and is equally critical on any
    database that has any kind of transaction isolation, including MySQL with InnoDB.
    Any connection that is still inside an old transaction will return stale data,
    if that data was already queried on that connection within isolation. For background
    on why you might see stale data even on MySQL, see [https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html](https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy目前假定DBAPI连接处于“非自动提交”模式 - 这是Python数据库API的默认行为，这意味着必须假定事务始终在进行中。当连接返回时，连接池会发出`connection.rollback()`。这样可以释放连接上剩余的任何事务资源。在像PostgreSQL或MSSQL这样的数据库中，表资源会被积极锁定，这一点至关重要，以防止行和表在不再使用的连接中保持锁定。否则应用程序可能会挂起。然而，这不仅仅是为了锁定，对于任何具有任何类型事务隔离的数据库，包括具有InnoDB的MySQL，这同样至关重要。如果任何连接仍在旧事务中，那么该连接返回的数据将是过时的，如果在隔离中已经在该连接上查询了该数据。有关为什么甚至在MySQL上可能看到过时数据的背景，请参阅[https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html](https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html)
- en: I’m on MyISAM - how do I turn it off?
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我在MyISAM上 - 如何关闭它？
- en: 'The behavior of the connection pool’s connection return behavior can be configured
    using `reset_on_return`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池的连接返回行为的行为可以使用`reset_on_return`进行配置：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I’m on SQL Server - how do I turn those ROLLBACKs into COMMITs?
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我在SQL Server上 - 如何将那些ROLLBACKs转换为COMMITs？
- en: '`reset_on_return` accepts the values `commit`, `rollback` in addition to `True`,
    `False`, and `None`. Setting to `commit` will cause a COMMIT as any connection
    is returned to the pool:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_on_return`接受`commit`，`rollback`的值，以及`True`，`False`和`None`。设置为`commit`将导致任何连接返回到池时进行COMMIT：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I am using multiple connections with a SQLite database (typically to test transaction
    operation), and my test program is not working!
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在使用SQLite数据库的多个连接（通常用于测试事务操作），但我的测试程序不起作用！
- en: 'If using a SQLite `:memory:` database the default connection pool is the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"), which maintains exactly one SQLite connection
    per thread. So two connections in use in the same thread will actually be the
    same SQLite connection. Make sure you’re not using a :memory: database so that
    the engine will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") (the default for non-memory databases in current
    SQLAlchemy versions).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用SQLite的`:memory:`数据库，默认连接池是[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，每个线程保持一个SQLite连接。因此，在同一线程中使用两个连接实际上是相同的SQLite连接。确保您不使用`:memory:`数据库，以便引擎将使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")（当前SQLAlchemy版本中非内存数据库的默认值）。
- en: See also
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)
    - info on PySQLite’s behavior.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[线程/池行为](../dialects/sqlite.html#pysqlite-threading-pooling) - 有关PySQLite行为的信息。'
- en: '## How do I get at the raw DBAPI connection when using an Engine?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '## 当使用引擎时，如何访问原始DBAPI连接？'
- en: 'With a regular SA engine-level Connection, you can get at a pool-proxied version
    of the DBAPI connection via the [`Connection.connection`](../core/connections.html#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") attribute on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and for the really-real DBAPI connection you
    can call the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute on that. On
    regular sync drivers there is usually no need to access the non-pool-proxied DBAPI
    connection, as all methods are proxied through:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规的 SA 引擎级 Connection，您可以通过[`Connection.connection`](../core/connections.html#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection")属性在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上获取一个经过池代理的 DBAPI 连接版本，并且对于真正的 DBAPI 连接，您可以在其上调用[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")属性。在常规的同步驱动程序中，通常不需要访问非经过池代���的
    DBAPI 连接，因为所有方法都经过代理：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Changed in version 1.4.24: Added the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute, which supersedes
    the previous `PoolProxiedConnection.connection` attribute which still remains
    available; this attribute always provides a pep-249 synchronous style connection
    object. The [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attribute is also added
    which will always refer to the real driver-level connection regardless of what
    API it presents.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.4.24起发生了变化：添加了[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")属性，取代了先前的`PoolProxiedConnection.connection`属性，但该属性仍然可用；该属性始终提供一个符合
    pep-249 同步风格的连接对象。还添加了[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性，它将始终引用真实的驱动程序级连接，无论它展示了什么
    API。
- en: Accessing the underlying connection for an asyncio driver
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 asyncio 驱动程序的基础连接
- en: 'When an asyncio driver is in use, there are two changes to the above scheme.
    The first is that when using an [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection"), the [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") must be accessed using the awaitable
    method [`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection"). The returned [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") in this case retains a sync-style pep-249
    usage pattern, and the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute refers to
    a a SQLAlchemy-adapted connection object which adapts the asyncio connection to
    a sync style pep-249 API, in other words there are *two* levels of proxying going
    on when using an asyncio driver. The actual asyncio connection is available from
    the `driver_connection` attribute. To restate the previous example in terms of
    asyncio looks like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 asyncio 驱动程序时，上述方案有两个变化。首先是当使用[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")时，必须使用可等待方法[`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection")来访问[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")。在这种情况下返回的[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")保留了一个同步风格的 pep-249 使用模式，而[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")属性指的是一个将 asyncio 连接适配为同步风格
    pep-249 API 的 SQLAlchemy 适配连接对象，换句话说，在使用 asyncio 驱动程序时会有*两层*代理。实际的 asyncio 连接可以从`driver_connection`属性中获取。以
    asyncio 方式重新表述前面的示例如下：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Changed in version 1.4.24: Added the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attributes to allow
    access to pep-249 connections, pep-249 adaption layers, and underlying driver
    connections using a consistent interface.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4.24开始更改：添加了[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")和[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性，以允许通过一致的接口访问pep-249连接、pep-249适配层和底层驱动程序连接。
- en: When using asyncio drivers, the above “DBAPI” connection is actually a SQLAlchemy-adapted
    form of connection which presents a synchronous-style pep-249 style API. To access
    the actual asyncio driver connection, which will present the original asyncio
    API of the driver in use, this can be accessed via the [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attribute of [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection"). For a standard pep-249 driver, [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") are synonymous.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用asyncio驱动程序时，上述“DBAPI”连接实际上是一个经过SQLAlchemy适配的连接形式，它呈现同步风格的pep-249风格API。要访问实际的asyncio驱动程序连接，可以通过[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")的[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性进行访问。对于标准的pep-249驱动程序，[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")和[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")是同义词。
- en: You must ensure that you revert any isolation level settings or other operation-specific
    settings on the connection back to normal before returning it to the pool.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将连接返回到池之前，您必须确保将任何隔离级别设置或其他特定操作设置恢复为正常状态。
- en: 'As an alternative to reverting settings, you can call the [`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach") method on either [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or the proxied connection, which will de-associate
    the connection from the pool such that it will be closed and discarded when [`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") is called:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为恢复设置的替代方法，您可以在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")或代理连接上调用[`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach")方法，这将使连接与池解除关联，从而在调用[`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close")时关闭并丢弃连接：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How do I use engines / connections / sessions with Python multiprocessing, or
    os.fork()?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在Python多进程或os.fork()中使用引擎/连接/会话？
- en: This is covered in the section [Using Connection Pools with Multiprocessing
    or os.fork()](../core/pooling.html#pooling-multiprocessing).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[使用连接池与多进程或os.fork()](../core/pooling.html#pooling-multiprocessing)一节中有所涉及。
- en: How do I configure logging?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何配置日志记录？
- en: See [Configuring Logging](../core/engines.html#dbengine-logging).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[配置日志记录](../core/engines.html#dbengine-logging)。
- en: How do I pool database connections? Are my connections pooled?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何池化数据库连接？我的连接是否被池化了？
- en: SQLAlchemy performs application-level connection pooling automatically in most
    cases. For all included dialects (except SQLite when using a “memory” database),
    a [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object refers to a [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as a source of connectivity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在大多数情况下会自动执行应用程序级别的连接池。对于所有包含的方言（除了使用“内存”数据库的 SQLite），[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象指的是一个 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") 作为连接的来源。
- en: For more detail, see [Engine Configuration](../core/engines.html) and [Connection
    Pooling](../core/pooling.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息，请参阅 [引擎配置](../core/engines.html) 和 [连接池](../core/pooling.html)。
- en: How do I pass custom connect arguments to my database API?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何向我的数据库 API 传递自定义连接参数？
- en: 'The [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    call accepts additional arguments either directly via the `connect_args` keyword
    argument:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    调用可以通过 `connect_args` 关键字参数直接接受附加参数：'
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or for basic string and integer arguments, they can usually be specified in
    the query string of the URL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于基本的字符串和整数参数，它们通常可以在 URL 的查询字符串中指定：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Custom DBAPI connect() arguments / on-connect routines](../core/engines.html#custom-dbapi-args)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义 DBAPI connect() 参数 / 连接时例程](../core/engines.html#custom-dbapi-args)'
- en: “MySQL Server has gone away”
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “MySQL 服务器已关闭连接”
- en: The primary cause of this error is that the MySQL connection has timed out and
    has been closed by the server. The MySQL server closes connections which have
    been idle a period of time which defaults to eight hours. To accommodate this,
    the immediate setting is to enable the [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") setting, which will ensure that a connection which
    is older than a set amount of seconds will be discarded and replaced with a new
    connection when it is next checked out.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误的主要原因是 MySQL 连接已超时并已被服务器关闭。MySQL 服务器会关闭空闲一段时间（默认为八小时）的连接。为了适应这一点，立即设置是启用
    [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") 设置，这将确保超过一定秒数的连接在下次检出时被丢弃并替换为新连接。
- en: For the more general case of accommodating database restarts and other temporary
    loss of connectivity due to network issues, connections that are in the pool may
    be recycled in response to more generalized disconnect detection techniques. The
    section [Dealing with Disconnects](../core/pooling.html#pool-disconnects) provides
    background on both “pessimistic” (e.g. pre-ping) and “optimistic” (e.g. graceful
    recovery) techniques. Modern SQLAlchemy tends to favor the “pessimistic” approach.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更一般的情况，即适应数据库重新启动和由于网络问题导致的临时连接丢失，池中的连接可能会根据更广义的断开连接检测技术进行回收。章节 [处理断开连接](../core/pooling.html#pool-disconnects)
    提供了关于“悲观”（例如，预先 ping）和“乐观”（例如，优雅恢复）技术的背景。现代 SQLAlchemy 倾向于采用“悲观”方法。
- en: See also
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dealing with Disconnects](../core/pooling.html#pool-disconnects)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理断开连接](../core/pooling.html#pool-disconnects)'
- en: '## “Commands out of sync; you can’t run this command now” / “This result object
    does not return rows. It has been closed automatically”'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '## “命令不同步；您现在无法运行此命令” / “此结果对象不返回行。它已被自动关闭”'
- en: The MySQL drivers have a fairly wide class of failure modes whereby the state
    of the connection to the server is in an invalid state. Typically, when the connection
    is used again, one of these two error messages will occur. The reason is because
    the state of the server has been changed to one in which the client library does
    not expect, such that when the client library emits a new statement on the connection,
    the server does not respond as expected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 驱动程序存在一类相当广泛的故障模式，其中与服务器的连接状态处于无效状态。通常情况下，当再次使用连接时，将出现以下两个错误消息之一。原因是因为服务器的状态已更改为客户端库不期望的状态，因此当客户端库在连接上发出新语句时，服务器不会如预期地响应。
- en: In SQLAlchemy, because database connections are pooled, the issue of the messaging
    being out of sync on a connection becomes more important, since when an operation
    fails, if the connection itself is in an unusable state, if it goes back into
    the connection pool, it will malfunction when checked out again. The mitigation
    for this issue is that the connection is **invalidated** when such a failure mode
    occurs so that the underlying database connection to MySQL is discarded. This
    invalidation occurs automatically for many known failure modes and can also be
    called explicitly via the [`Connection.invalidate()`](../core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，由于数据库连接是池化的，连接上的消息不同步的问题变得更加重要，因为当一个操作失败时，如果连接本身处于不可用状态，如果它重新进入连接池，当再次检出时将发生故障。对于这个问题的缓解措施是，当出现这种故障模式时，连接被**作废**，以便底层数据库连接到MySQL被丢弃。这种作废对于许多已知的故障模式会自动发生，也可以通过[`Connection.invalidate()`](../core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate")方法显式调用。
- en: There is also a second class of failure modes within this category where a context
    manager such as `with session.begin_nested():` wants to “roll back” the transaction
    when an error occurs; however within some failure modes of the connection, the
    rollback itself (which can also be a RELEASE SAVEPOINT operation) also fails,
    causing misleading stack traces.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中还有第二类故障模式，其中上下文管理器（如`with session.begin_nested():`）在发生错误时希望“回滚”事务；然而在某些连接的故障模式中，回滚本身（也可以是一个RELEASE
    SAVEPOINT操作）也会失败，导致误导性的堆栈跟踪。
- en: 'Originally, the cause of this error used to be fairly simple, it meant that
    a multithreaded program was invoking commands on a single connection from more
    than one thread. This applied to the original “MySQLdb” native-C driver that was
    pretty much the only driver in use. However, with the introduction of pure Python
    drivers like PyMySQL and MySQL-connector-Python, as well as increased use of tools
    such as gevent/eventlet, multiprocessing (often with Celery), and others, there
    is a whole series of factors that has been known to cause this problem, some of
    which have been improved across SQLAlchemy versions but others which are unavoidable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这种错误的原因通常很简单，意味着一个多线程程序从多个线程调用单个连接上的命令。这适用于最初几乎是唯一使用的原始“MySQLdb”本机C驱动程序。然而，随着纯Python驱动程序（如PyMySQL和MySQL-connector-Python）的引入，以及诸如gevent/eventlet、多进程（通常与Celery一起使用）等工具的增加使用，已知存在一整套因素会导致这个问题，其中一些已经在SQLAlchemy版本中得到改进，但另一些是不可避免的：
- en: '**Sharing a connection among threads** - This is the original reason these
    kinds of errors occurred. A program used the same connection in two or more threads
    at the same time, meaning multiple sets of messages got mixed up on the connection,
    putting the server-side session into a state that the client no longer knows how
    to interpret. However, other causes are usually more likely today.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线程之间共享连接** - 这是这类错误发生的最初原因。程序在两个或多个线程中同时使用相同的连接，意味着多组消息在连接上混在一起，使得服务器端会话进入一个客户端不再知道如何解释的状态。然而，今天通常更可能出现其他原因。'
- en: '**Sharing the filehandle for the connection among processes** - This usually
    occurs when a program uses `os.fork()` to spawn a new process, and a TCP connection
    that is present in th parent process gets shared into one or more child processes.
    As multiple processes are now emitting messages to essentially the same filehandle,
    the server receives interleaved messages and breaks the state of the connection.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在进程之间共享连接的文件句柄** - 这通常发生在程序使用`os.fork()`生成新进程时，父进程中存在的TCP连接被共享到一个或多个子进程中。由于多个进程现在向基本上相同的文件句柄发送消息，服务器接收到交错的消息并破坏连接的状态。'
- en: This scenario can occur very easily if a program uses Python’s “multiprocessing”
    module and makes use of an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that was created in the parent process. It’s common
    that “multiprocessing” is in use when using tools like Celery. The correct approach
    should be either that a new [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is produced when a child process first starts, discarding
    any [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that came down from the parent process; or, the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that’s inherited from the parent process can have
    it’s internal pool of connections disposed by calling [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose").
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果程序使用 Python 的“multiprocessing”模块，并且使用了在父进程中创建的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，则可能会很容易发生此情况。在使用 Celery 等工具时，使用“multiprocessing”是很常见的。正确的方法应该是在子进程第一次启动时生成一个新的
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")，丢弃从父进程继承下来的任何
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")；或者，从父进程继承的
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    可以通过调用 [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") 来处理其内部的连接池。
- en: '**Greenlet Monkeypatching w/ Exits** - When using a library like gevent or
    eventlet that monkeypatches the Python networking API, libraries like PyMySQL
    are now working in an asynchronous mode of operation, even though they are not
    developed explicitly against this model. A common issue is that a greenthread
    is interrupted, often due to timeout logic in the application. This results in
    the `GreenletExit` exception being raised, and the pure-Python MySQL driver is
    interrupted from its work, which may have been that it was receiving a response
    from the server or preparing to otherwise reset the state of the connection. When
    the exception cuts all that work short, the conversation between client and server
    is now out of sync and subsequent usage of the connection may fail. SQLAlchemy
    as of version 1.1.0 knows how to guard against this, as if a database operation
    is interrupted by a so-called “exit exception”, which includes `GreenletExit`
    and any other subclass of Python `BaseException` that is not also a subclass of
    `Exception`, the connection is invalidated.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Exit 的 Greenlet Monkeypatching** - 当使用类似 gevent 或 eventlet 的库对 Python
    网络 API 进行 monkeypatch 时，像 PyMySQL 这样的库现在以异步模式运行，即使它们并没有明确针对此模型开发。一个常见问题是 greenthread
    被中断，通常是由于应用程序中的超时逻辑。这导致引发`GreenletExit`异常，并且纯 Python MySQL 驱动程序被中断了其工作，可能是正在接收来自服务器的响应或准备重新设置连接的状态。当异常中断了所有这些工作时，客户端和服务器之间的对话现在不再同步，连接的后续使用可能会失败。截至版本
    1.1.0，SQLAlchemy 知道如何防范这种情况，因为如果数据库操作被所谓的“退出异常”中断，这包括`GreenletExit`和任何不是也是`Exception`子类的
    Python `BaseException`的子类，则连接将无效。'
- en: '**Rollbacks / SAVEPOINT releases failing** - Some classes of error cause the
    connection to be unusable within the context of a transaction, as well as when
    operating in a “SAVEPOINT” block. In these cases, the failure on the connection
    has rendered any SAVEPOINT as no longer existing, yet when SQLAlchemy, or the
    application, attempts to “roll back” this savepoint, the “RELEASE SAVEPOINT” operation
    fails, typically with a message like “savepoint does not exist”. In this case,
    under Python 3 there will be a chain of exceptions output, where the ultimate
    “cause” of the error will be displayed as well. Under Python 2, there are no “chained”
    exceptions, however recent versions of SQLAlchemy will attempt to emit a warning
    illustrating the original failure cause, while still throwing the immediate error
    which is the failure of the ROLLBACK.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚 / SAVEPOINT 释放失败** - 某些类别的错误会导致连接在事务上下文中无法使用，以及在“SAVEPOINT”块中操作时无法使用。在这些情况下，连接上的故障使任何
    SAVEPOINT 都不再存在，然而当 SQLAlchemy 或应用程序尝试“回滚”此 savepoint 时，“RELEASE SAVEPOINT”操作会失败，通常会出现“savepoint
    不存在”的消息。在这种情况下，在 Python 3 下将输出一系列异常，其中最终的错误“原因”也将被显示出来。在 Python 2 下，没有“链接”异常，但是
    SQLAlchemy 的最新版本将尝试发出警告，说明原始故障原因，同时仍然抛出 ROLLBACK 失败的立即错误。'
- en: '## How Do I “Retry” a Statement Execution Automatically?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何自动“重试”语句执行？'
- en: The documentation section [Dealing with Disconnects](../core/pooling.html#pool-disconnects)
    discusses the strategies available for pooled connections that have been disconnected
    since the last time a particular connection was checked out. The most modern feature
    in this regard is the [`create_engine.pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pre_ping
    "sqlalchemy.create_engine") parameter, which allows that a “ping” is emitted on
    a database connection when it’s retrieved from the pool, reconnecting if the current
    connection has been disconnected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文档部分 [处理断开连接](../core/pooling.html#pool-disconnects) 讨论了对已经断开连接的池化连接可用的策略。在这方面最现代的特性是
    [`create_engine.pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pre_ping
    "sqlalchemy.create_engine") 参数，它允许在从池中检索数据库连接时发出“ping”，如果当前连接已断开，则重新连接。
- en: It’s important to note that this “ping” is only emitted **before** the connection
    is actually used for an operation. Once the connection is delivered to the caller,
    per the Python [DBAPI](../glossary.html#term-DBAPI) specification it is now subject
    to an **autobegin** operation, which means it will automatically BEGIN a new transaction
    when it is first used that remains in effect for subsequent statements, until
    the DBAPI-level `connection.commit()` or `connection.rollback()` method is invoked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，此“ping”仅在连接实际用于操作之前发出。一旦连接被提供给调用者，根据 Python [DBAPI](../glossary.html#term-DBAPI)
    规范，它现在已经受到**autobegin**操作的影响，这意味着当首次使用时，它将自动开始一个新事务，该事务在后续语句中仍然有效，直到调用 DBAPI 级别的
    `connection.commit()` 或 `connection.rollback()` 方法。
- en: In modern use of SQLAlchemy, a series of SQL statements are always invoked within
    this transactional state, assuming [DBAPI autocommit mode](../core/connections.html#dbapi-autocommit)
    is not enabled (more on that in the next section), meaning that no single statement
    is automatically committed; if an operation fails, the effects of all statements
    within the current transaction will be lost.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代使用 SQLAlchemy 中，一系列 SQL 语句总是在事务状态下调用，假设[未启用 DBAPI 自动提交模式](../core/connections.html#dbapi-autocommit)（下一节将详细介绍），这意味着没有单个语句会自动提交；如果操作失败，当前事务内所有语句的影响都将丢失。
- en: The implication that this has for the notion of “retrying” a statement is that
    in the default case, when a connection is lost, **the entire transaction is lost**.
    There is no useful way that the database can “reconnect and retry” and continue
    where it left off, since data is already lost. For this reason, SQLAlchemy does
    not have a transparent “reconnection” feature that works mid-transaction, for
    the case when the database connection has disconnected while being used. The canonical
    approach to dealing with mid-operation disconnects is to **retry the entire operation
    from the start of the transaction**, often by using a custom Python decorator
    that will “retry” a particular function several times until it succeeds, or to
    otherwise architect the application in such a way that it is resilient against
    transactions that are dropped that then cause operations to fail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“重试”语句的含义是，默认情况下，当连接丢失时，**整个事务都将丢失**。数据库无法以有用的方式“重新连接和重试”，并继续上次执行的位置，因为数据已经丢失。因此，SQLAlchemy
    没有一个能在事务进行中工作时透明地进行“重新连接”的功能，以处理数据库连接在使用过程中断开的情况。处理中途断开连接的规范方法是**从事务开始处重试整个操作**，通常通过使用自定义
    Python 装饰器多次“重试”特定函数直到成功，或者以其他方式设计应用程序，使其能够抵御事务被中断而导致操作失败的情况。
- en: There is also the notion of extensions that can keep track of all of the statements
    that have proceeded within a transaction and then replay them all in a new transaction
    in order to approximate a “retry” operation. SQLAlchemy’s [event system](../core/events.html)
    does allow such a system to be constructed, however this approach is also not
    generally useful as there is no way to guarantee that those [DML](../glossary.html#term-DML)
    statements will be working against the same state, as once a transaction has ended
    the state of the database in a new transaction may be totally different. Architecting
    “retry” explicitly into the application at the points at which transactional operations
    begin and commit remains the better approach since the application-level transactional
    methods are the ones that know best how to re-run their steps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个概念，即扩展程序可以跟踪事务中已经执行的所有语句，然后在新事务中重新执行它们，以近似实现“重试”操作。SQLAlchemy 的[事件系统](../core/events.html)确实允许构建这样一个系统，但这种方法通常也不实用，因为没有办法保证这些
    [DML](../glossary.html#term-DML) 语句将针对相同的状态进行操作，一旦事务结束，数据库在新事务中的状态可能会完全不同。在事务操作开始和提交的点明确将“重试”架构化到应用程序中仍然是更好的方法，因为应用程序级别的事务方法最了解如何重新运行它们的步骤。
- en: Otherwise, if SQLAlchemy were to provide a feature that transparently and silently
    “reconnected” a connection mid-transaction, the effect would be that data is silently
    lost. By trying to hide the problem, SQLAlchemy would make the situation much
    worse.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果 SQLAlchemy 提供了一个透明且静默地在事务中重新连接连接的功能，则效果将是数据被静默丢失。通过试图隐藏问题，SQLAlchemy 将使情况变得更糟。
- en: However, if we are **not** using transactions, then there are more options available,
    as the next section describes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们**不**使用事务，则会有更多的选择，如下一节所述。
- en: '### Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 DBAPI 自动提交允许只读版本的透明重新连接'
- en: With the rationale for not having a transparent reconnection mechanism stated,
    the preceding section rests upon the assumption that the application is in fact
    using DBAPI-level transactions. As most DBAPIs now offer [native “autocommit”
    settings](../core/connections.html#dbapi-autocommit), we can make use of these
    features to provide a limited form of transparent reconnect for **read only, autocommit
    only operations**. A transparent statement retry may be applied to the `cursor.execute()`
    method of the DBAPI, however it is still not safe to apply to the `cursor.executemany()`
    method of the DBAPI, as the statement may have consumed any portion of the arguments
    given.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有透明的重新连接机制的理由已经说明，上一节建立在这样一个假设之上，即应用程序实际上正在使用 DBAPI 级别的事务。由于大多数 DBAPI 现在提供了[本地的“自动提交”设置](../core/connections.html#dbapi-autocommit)，我们可以利用这些特性来为**只读、自动提交的操作**提供有限形式的透明重新连接。可以将透明的语句重试应用于
    DBAPI 的`cursor.execute()`方法，但仍然不安全应用于 DBAPI 的`cursor.executemany()`方法，因为该语句可能已经消耗了给定参数的任何部分。
- en: Warning
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The following recipe should **not** be used for operations that write data.
    Users should carefully read and understand how the recipe works and test failure
    modes very carefully against the specifically targeted DBAPI driver before making
    production use of this recipe. The retry mechanism does not guarantee prevention
    of disconnection errors in all cases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的方法**不**应用于写入数据的操作。用户应该仔细阅读和理解该方法的工作原理，并仔细针对具体目标的 DBAPI 驱动程序测试故障模式，然后再在生产中使用该方法。重试机制不能保证在所有情况下都防止断开连接错误。
- en: 'A simple retry mechanism may be applied to the DBAPI level `cursor.execute()`
    method by making use of the [`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute") and [`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params") hooks, which will be able
    to intercept disconnections during statement executions. It will **not** intercept
    connection failures during result set fetch operations, for those DBAPIs that
    don’t fully buffer result sets. The recipe requires that the database support
    DBAPI level autocommit and is **not guaranteed** for particular backends. A single
    function `reconnecting_engine()` is presented which applies the event hooks to
    a given [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, returning an always-autocommit version that enables DBAPI-level autocommit.
    A connection will transparently reconnect for single-parameter and no-parameter
    statement executions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过利用[`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute")和[`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params")钩子来应用于DBAPI级别的`cursor.execute()`方法的简单重试机制，这将能够在语句执行期间拦截断开连接。对于那些不完全缓冲结果集的DBAPI，它**不会**拦截在结果集获取操作期间的连接故障。该配方要求数据库支持DBAPI级别的自动提交，并且对于特定后端**不能保证**。提供了一个名为`reconnecting_engine()`的单个函数，它将事件钩子应用于给定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象，返回一个始终自动提交的版本，该版本启用了DBAPI级别的自动提交。连接将透明地重新连接以进行单参数和无参数语句执行：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Given the above recipe, a reconnection mid-transaction may be demonstrated
    using the following proof of concept script. Once run, it will emit a `SELECT
    1` statement to the database every five seconds:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定上述配方，可以使用以下概念验证脚本演示事务中的重新连接。运行后，它将每五秒向数据库发出一个`SELECT 1`语句：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Restart the database while the script runs to demonstrate the transparent reconnect
    operation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行时重新启动数据库以演示透明重连接操作：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The above recipe is tested for SQLAlchemy 1.4.  ### Using DBAPI Autocommit
    Allows for a Readonly Version of Transparent Reconnect'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配方已在SQLAlchemy 1.4中进行了测试。### 使用DBAPI自动提交允许透明重连接的只读版本
- en: With the rationale for not having a transparent reconnection mechanism stated,
    the preceding section rests upon the assumption that the application is in fact
    using DBAPI-level transactions. As most DBAPIs now offer [native “autocommit”
    settings](../core/connections.html#dbapi-autocommit), we can make use of these
    features to provide a limited form of transparent reconnect for **read only, autocommit
    only operations**. A transparent statement retry may be applied to the `cursor.execute()`
    method of the DBAPI, however it is still not safe to apply to the `cursor.executemany()`
    method of the DBAPI, as the statement may have consumed any portion of the arguments
    given.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在未说明透明重连接机制的理由的情况下，前一节基于这样一种假设，即应用程序实际上正在使用DBAPI级别的事务。由于大多数DBAPI现在提供[本地“自动提交”设置](../core/connections.html#dbapi-autocommit)，我们可以利用这些特性为**只读，仅自动提交操作**提供一种有限形式的透明重连接。透明语句重试可以应用于DBAPI的`cursor.execute()`方法，但是仍然不安全应用于DBAPI的`cursor.executemany()`方法，因为该语句可能已经消耗了给定参数的任何部分。
- en: Warning
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The following recipe should **not** be used for operations that write data.
    Users should carefully read and understand how the recipe works and test failure
    modes very carefully against the specifically targeted DBAPI driver before making
    production use of this recipe. The retry mechanism does not guarantee prevention
    of disconnection errors in all cases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不应将以下配方用于写入数据的操作。用户应仔细阅读和理解配方的工作原理，并在生产使用此配方之前针对特定的DBAPI驱动程序非常仔细地测试故障模式。重试机制不能保证在所有情况下防止断开连接错误。
- en: 'A simple retry mechanism may be applied to the DBAPI level `cursor.execute()`
    method by making use of the [`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute") and [`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params") hooks, which will be able
    to intercept disconnections during statement executions. It will **not** intercept
    connection failures during result set fetch operations, for those DBAPIs that
    don’t fully buffer result sets. The recipe requires that the database support
    DBAPI level autocommit and is **not guaranteed** for particular backends. A single
    function `reconnecting_engine()` is presented which applies the event hooks to
    a given [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, returning an always-autocommit version that enables DBAPI-level autocommit.
    A connection will transparently reconnect for single-parameter and no-parameter
    statement executions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用[`DialectEvents.do_execute()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute
    "sqlalchemy.events.DialectEvents.do_execute")和[`DialectEvents.do_execute_no_params()`](../core/events.html#sqlalchemy.events.DialectEvents.do_execute_no_params
    "sqlalchemy.events.DialectEvents.do_execute_no_params")钩子向 DBAPI 级别的 `cursor.execute()`
    方法应用简单的重试机制，这些钩子将能够在语句执行期间拦截断开连接。对于那些不完全缓冲结果集的 DBAPI，它将**不会**拦截结果集获取操作期间的连接故障。该方案要求数据库支持
    DBAPI 级别的自动提交，并且**不能保证**适用于特定的后端。提供了一个名为 `reconnecting_engine()` 的单个函数，它将事件钩子应用于给定的
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    对象，返回一个始终启用 DBAPI 级别自动提交的版本。连接将自动重新连接以用于单参数和无参数语句执行：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Given the above recipe, a reconnection mid-transaction may be demonstrated
    using the following proof of concept script. Once run, it will emit a `SELECT
    1` statement to the database every five seconds:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述方案，可以使用以下概念证明脚本演示事务中重新连接。运行一次后，它将每五秒向数据库发出一个`SELECT 1`语句：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Restart the database while the script runs to demonstrate the transparent reconnect
    operation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行时重新启动数据库以演示透明的重新连接操作：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The above recipe is tested for SQLAlchemy 1.4.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方案已经在 SQLAlchemy 1.4 上进行了测试。
- en: Why does SQLAlchemy issue so many ROLLBACKs?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么 SQLAlchemy 发出了那么多个 ROLLBACK？
- en: SQLAlchemy currently assumes DBAPI connections are in “non-autocommit” mode
    - this is the default behavior of the Python database API, meaning it must be
    assumed that a transaction is always in progress. The connection pool issues `connection.rollback()`
    when a connection is returned. This is so that any transactional resources remaining
    on the connection are released. On a database like PostgreSQL or MSSQL where table
    resources are aggressively locked, this is critical so that rows and tables don’t
    remain locked within connections that are no longer in use. An application can
    otherwise hang. It’s not just for locks, however, and is equally critical on any
    database that has any kind of transaction isolation, including MySQL with InnoDB.
    Any connection that is still inside an old transaction will return stale data,
    if that data was already queried on that connection within isolation. For background
    on why you might see stale data even on MySQL, see [https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html](https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 目前假设 DBAPI 连接处于“非自动提交”模式 - 这是 Python 数据库 API 的默认行为，这意味着必须假定事务始终在进行中。连接池在连接返回时发出
    `connection.rollback()`。这是为了释放连接上仍然存在的任何事务资源。在像 PostgreSQL 或 MSSQL 这样的数据库上，表资源被积极地锁定，这一点至关重要，以确保行和表不会在不再使用的连接中保持锁定状态。否则，应用程序可能会挂起。然而，这不仅仅是为了锁定，并且在具有任何类型的事务隔离的任何数据库上同样关键，包括具有
    InnoDB 的 MySQL。如果在隔离内在连接上已经查询了该数据，任何仍然处于旧事务中的连接将返回陈旧的数据。有关为什么即使在 MySQL 上也可能看到陈旧数据的背景，请参阅[https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html](https://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html)
- en: I’m on MyISAM - how do I turn it off?
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我使用的是 MyISAM - 如何关闭它？
- en: 'The behavior of the connection pool’s connection return behavior can be configured
    using `reset_on_return`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池的连接返回行为的行为可以使用 `reset_on_return` 进行配置：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I’m on SQL Server - how do I turn those ROLLBACKs into COMMITs?
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我使用的是 SQL Server - 如何将那些 ROLLBACKs 转换为 COMMITs？
- en: '`reset_on_return` accepts the values `commit`, `rollback` in addition to `True`,
    `False`, and `None`. Setting to `commit` will cause a COMMIT as any connection
    is returned to the pool:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_on_return` 接受值 `commit`、`rollback`，除了 `True`、`False` 和 `None`。设置为 `commit`
    将导致任何连接返回到池时进行 COMMIT：'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I’m on MyISAM - how do I turn it off?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我正在使用 MyISAM - 如何关闭它？
- en: 'The behavior of the connection pool’s connection return behavior can be configured
    using `reset_on_return`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `reset_on_return` 配置连接池的连接返回行为：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I’m on SQL Server - how do I turn those ROLLBACKs into COMMITs?
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我正在使用 SQL Server - 如何将那些 ROLLBACKs 转换为 COMMITs？
- en: '`reset_on_return` accepts the values `commit`, `rollback` in addition to `True`,
    `False`, and `None`. Setting to `commit` will cause a COMMIT as any connection
    is returned to the pool:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_on_return` 接受值 `commit`、`rollback`，除了 `True`、`False` 和 `None`。设置为 `commit`
    将导致任何连接返回到池时进行 COMMIT：'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I am using multiple connections with a SQLite database (typically to test transaction
    operation), and my test program is not working!
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在使用 SQLite 数据库的多个连接（通常用于测试事务操作），但我的测试程序不起作用！
- en: 'If using a SQLite `:memory:` database the default connection pool is the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"), which maintains exactly one SQLite connection
    per thread. So two connections in use in the same thread will actually be the
    same SQLite connection. Make sure you’re not using a :memory: database so that
    the engine will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") (the default for non-memory databases in current
    SQLAlchemy versions).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 SQLite 的 `:memory:` 数据库，默认连接池是 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，它每个线程维护一个 SQLite 连接。因此，在同一线程中使用两个连接实际上是相同的
    SQLite 连接。确保您不是使用 `:memory:` 数据库，以便引擎将使用 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")（当前 SQLAlchemy 版本中非内存数据库的默认值）。
- en: See also
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)
    - info on PySQLite’s behavior.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[线程/池行为](../dialects/sqlite.html#pysqlite-threading-pooling) - 有关 PySQLite
    行为的信息。'
- en: '## How do I get at the raw DBAPI connection when using an Engine?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在使用 Engine 时如何访问原始的 DBAPI 连接？'
- en: 'With a regular SA engine-level Connection, you can get at a pool-proxied version
    of the DBAPI connection via the [`Connection.connection`](../core/connections.html#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") attribute on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and for the really-real DBAPI connection you
    can call the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute on that. On
    regular sync drivers there is usually no need to access the non-pool-proxied DBAPI
    connection, as all methods are proxied through:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规的 SA 引擎级 Connection，您可以通过 [`Connection.connection`](../core/connections.html#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") 属性获取到一个池代理版本的 DBAPI 连接，并且对于真正的 DBAPI
    连接，您可以在此调用 [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") 属性。在常规的同步驱动程序中，通常不需要访问非池代理的
    DBAPI 连接，因为所有方法都是通过代理的：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Changed in version 1.4.24: Added the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute, which supersedes
    the previous `PoolProxiedConnection.connection` attribute which still remains
    available; this attribute always provides a pep-249 synchronous style connection
    object. The [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attribute is also added
    which will always refer to the real driver-level connection regardless of what
    API it presents.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1.4.24 中更改：添加了 [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") 属性，它取代了以前的 `PoolProxiedConnection.connection`
    属性，后者仍然可用；此属性始终提供 pep-249 同步风格的连接对象。还添加了 [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") 属性，它将始终引用真正的驱动程序级连接，无论它呈现什么
    API。
- en: Accessing the underlying connection for an asyncio driver
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 asyncio 驱动程序的底层连接
- en: 'When an asyncio driver is in use, there are two changes to the above scheme.
    The first is that when using an [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection"), the [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") must be accessed using the awaitable
    method [`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection"). The returned [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") in this case retains a sync-style pep-249
    usage pattern, and the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute refers to
    a a SQLAlchemy-adapted connection object which adapts the asyncio connection to
    a sync style pep-249 API, in other words there are *two* levels of proxying going
    on when using an asyncio driver. The actual asyncio connection is available from
    the `driver_connection` attribute. To restate the previous example in terms of
    asyncio looks like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 asyncio 驱动程序时，上述方案有两个变化。首先是在使用[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")时，必须使用可等待方法[`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection")来访问[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")。在这种情况下返回的[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")保留了同步风格的 pep-249 使用模式，而[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")属性指的是一个将 asyncio 连接适配为同步风格
    pep-249 API 的 SQLAlchemy 适配连接对象，换句话说，在使用 asyncio 驱动程序时存在*两层*代理。实际的 asyncio 连接可以从`driver_connection`属性中获取。将上述示例重新阐述为
    asyncio 的形式如下：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Changed in version 1.4.24: Added the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attributes to allow
    access to pep-249 connections, pep-249 adaption layers, and underlying driver
    connections using a consistent interface.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.4.24起更改：添加了[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")和[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性，以允许通过一致的接口访问 pep-249
    连接、pep-249 适配层和底层驱动程序连接。
- en: When using asyncio drivers, the above “DBAPI” connection is actually a SQLAlchemy-adapted
    form of connection which presents a synchronous-style pep-249 style API. To access
    the actual asyncio driver connection, which will present the original asyncio
    API of the driver in use, this can be accessed via the [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attribute of [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection"). For a standard pep-249 driver, [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") are synonymous.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 asyncio 驱动程序时，上述“DBAPI”连接实际上是 SQLAlchemy 适配的连接形式，它呈现了同步风格的 pep-249 风格 API。要访问实际的
    asyncio 驱动程序连接，可以通过[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性来访问[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")。对于标准的 pep-249 驱动程序，[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection")和[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")是同义词。
- en: You must ensure that you revert any isolation level settings or other operation-specific
    settings on the connection back to normal before returning it to the pool.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在将连接返回到池之前，必须确保将连接上的任何隔离级别设置或其他操作特定设置恢复为正常状态。
- en: 'As an alternative to reverting settings, you can call the [`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach") method on either [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or the proxied connection, which will de-associate
    the connection from the pool such that it will be closed and discarded when [`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") is called:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为恢复设置的替代方案，您可以在 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 或代理连接上调用 [`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach") 方法，这将使连接与池解除关联，从而在调用 [`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") 时关闭和丢弃它：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Accessing the underlying connection for an asyncio driver
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 asyncio 驱动程序访问底层连接
- en: 'When an asyncio driver is in use, there are two changes to the above scheme.
    The first is that when using an [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection"), the [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") must be accessed using the awaitable
    method [`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection"). The returned [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") in this case retains a sync-style pep-249
    usage pattern, and the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") attribute refers to
    a a SQLAlchemy-adapted connection object which adapts the asyncio connection to
    a sync style pep-249 API, in other words there are *two* levels of proxying going
    on when using an asyncio driver. The actual asyncio connection is available from
    the `driver_connection` attribute. To restate the previous example in terms of
    asyncio looks like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 asyncio 驱动程序时，对上述方案有两个变化。首先是当使用 [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 时，必须使用可等待方法 [`AsyncConnection.get_raw_connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.get_raw_connection") 访问 [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")。在这种情况下返回的 [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection") 保留了同步样式 pep-249 使用模式，并且 [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") 属性指向一个 SQLAlchemy 适配的连接对象，将
    asyncio 连接适配为同步样式 pep-249 API，换句话说，当使用 asyncio 驱动程序时会有*两层*代理。实际的 asyncio 连接可以从
    `driver_connection` 属性获得。在 asyncio 方面重新表述上一个示例如下：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Changed in version 1.4.24: Added the [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attributes to allow
    access to pep-249 connections, pep-249 adaption layers, and underlying driver
    connections using a consistent interface.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.4.24 开始更改：添加了 [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") 和 [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") 属性，以允许使用一致的接口访问 pep-249
    连接、pep-249 适配层和底层驱动程序连接。
- en: When using asyncio drivers, the above “DBAPI” connection is actually a SQLAlchemy-adapted
    form of connection which presents a synchronous-style pep-249 style API. To access
    the actual asyncio driver connection, which will present the original asyncio
    API of the driver in use, this can be accessed via the [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") attribute of [`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection"). For a standard pep-249 driver, [`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") and [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") are synonymous.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 asyncio 驱动程序时，上述“DBAPI”连接实际上是一个经过 SQLAlchemy 适配的连接形式，它呈现了一个同步风格的 pep-249
    风格 API。要访问实际的 asyncio 驱动程序连接，它将呈现所使用驱动程序的原始 asyncio API，可以通过[`PoolProxiedConnection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection
    "sqlalchemy.pool.PoolProxiedConnection")的[`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection")属性进行访问。对于标准的 pep-249
    驱动程序，[`PoolProxiedConnection.dbapi_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.dbapi_connection
    "sqlalchemy.pool.PoolProxiedConnection.dbapi_connection") 和 [`PoolProxiedConnection.driver_connection`](../core/pooling.html#sqlalchemy.pool.PoolProxiedConnection.driver_connection
    "sqlalchemy.pool.PoolProxiedConnection.driver_connection") 是同义词。
- en: You must ensure that you revert any isolation level settings or other operation-specific
    settings on the connection back to normal before returning it to the pool.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在将连接返回到池之前，您必须确保将任何隔离级别设置或其他特定操作设置恢复为正常状态。
- en: 'As an alternative to reverting settings, you can call the [`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach") method on either [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or the proxied connection, which will de-associate
    the connection from the pool such that it will be closed and discarded when [`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") is called:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为恢复设置的替代方案，您可以在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")或代理连接上调用[`Connection.detach()`](../core/connections.html#sqlalchemy.engine.Connection.detach
    "sqlalchemy.engine.Connection.detach")方法，这将使连接与池解除关联，从而在调用[`Connection.close()`](../core/connections.html#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close")时关闭并丢弃连接：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How do I use engines / connections / sessions with Python multiprocessing, or
    os.fork()?
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何在 Python 多进程或 os.fork() 中使用引擎/连接/会话？
- en: This is covered in the section [Using Connection Pools with Multiprocessing
    or os.fork()](../core/pooling.html#pooling-multiprocessing).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[使用连接池与多进程或 os.fork()](../core/pooling.html#pooling-multiprocessing)一节中有详细介绍。
