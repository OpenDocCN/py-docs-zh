- en: Relationship Loading Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系加载技术
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This section presents an in-depth view of how to load related objects. Readers
    should be familiar with [Relationship Configuration](../relationships.html) and
    basic use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了如何加载相关对象。读者应熟悉[关系配置](../relationships.html)和基本用法。
- en: Most examples here assume the “User/Address” mapping setup similar to the one
    illustrated at [setup for selects](_plain_setup.html).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数示例假定“用户/地址”映射设置类似于在[选择设置](_plain_setup.html)中所示的设置。
- en: A big part of SQLAlchemy is providing a wide range of control over how related
    objects get loaded when querying. By “related objects” we refer to collections
    or scalar associations configured on a mapper using [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This behavior can be configured at mapper construction
    time using the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter to the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") function, as well as by using **ORM loader options**
    with the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的一个重要部分是在查询时提供对相关对象加载方式的广泛控制。所谓“相关对象”是指在映射器上使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")配置的集合或标量关联。这种行为可以在映射器构造时使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")函数的[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数进行配置，以及通过使用**ORM 加载选项**与[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造函数一起使用。
- en: The loading of relationships falls into three categories; **lazy** loading,
    **eager** loading, and **no** loading. Lazy loading refers to objects that are
    returned from a query without the related objects loaded at first. When the given
    collection or reference is first accessed on a particular object, an additional
    SELECT statement is emitted such that the requested collection is loaded.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关系加载分为三类：**延迟**加载、**急切**加载和**无**加载。延迟加载指的是从查询返回的对象，相关对象一开始并未加载。当在特定对象上首次访问给定集合或引用时，会发出额外的
    SELECT 语句，以加载请求的集合。
- en: Eager loading refers to objects returned from a query with the related collection
    or scalar reference already loaded up front. The ORM achieves this either by augmenting
    the SELECT statement it would normally emit with a JOIN to load in related rows
    simultaneously, or by emitting additional SELECT statements after the primary
    one to load collections or scalar references at once.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 急切加载是指从查询返回的对象中，相关集合或标量引用已经提前加载。ORM 实现这一点要么通过增加通常会发出的 SELECT 语句以加载相关行，要么通过在主要语句之后发出额外的
    SELECT 语句以一次性加载集合或标量引用。
- en: “No” loading refers to the disabling of loading on a given relationship, either
    that the attribute is empty and is just never loaded, or that it raises an error
    when it is accessed, in order to guard against unwanted lazy loads.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “无”加载指的是在给定关系上禁用加载，要么属性为空且从不加载，要么在访问时引发错误，以防止不必要的延迟加载。
- en: Summary of Relationship Loading Styles
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系加载样式总结
- en: 'The primary forms of relationship loading are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关系加载的主要形式包括：
- en: '**lazy loading** - available via `lazy=''select''` or the [`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option, this is the form of loading that emits a SELECT
    statement at attribute access time to lazily load a related reference on a single
    object at a time. Lazy loading is the **default loading style** for all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs that don’t otherwise indicate the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option. Lazy loading is detailed at [Lazy Loading](#lazy-loading).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性加载** - 可通过`lazy=''select''`或[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")选项使用，这是一种加载形式，它在属性访问时发出SELECT语句，以惰性加载单个对象上的相关引用。惰性加载是所有未明示[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")选项的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造的**默认加载方式**。惰性加载详见[惰性加载](#lazy-loading)。'
- en: '**select IN loading** - available via `lazy=''selectin''` or the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") option, this form of loading emits a second (or
    more) SELECT statement which assembles the primary key identifiers of the parent
    objects into an IN clause, so that all members of related collections / scalar
    references are loaded at once by primary key. Select IN loading is detailed at
    [Select IN loading](#selectin-eager-loading).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择IN加载** - 可通过`lazy=''selectin''`或[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")选项使用，这种加载形式会发出第二个（或更多）SELECT语句，将父对象的主键标识符组装到一个IN子句中，以便通过主键一次加载所有相关集合/标量引用。选择IN加载详见[选择IN加载](#selectin-eager-loading)。'
- en: '**joined loading** - available via `lazy=''joined''` or the [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option, this form of loading applies a JOIN to the
    given SELECT statement so that related rows are loaded in the same result set.
    Joined eager loading is detailed at [Joined Eager Loading](#joined-eager-loading).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联加载** - 可通过`lazy=''joined''`或[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")选项使用，这种加载方式会在给定的SELECT语句上应用JOIN，以便相关行在同一结果集中加载。关联的及时加载详见[关联的及时加载](#joined-eager-loading)。'
- en: '**raise loading** - available via `lazy=''raise''`, `lazy=''raise_on_sql''`,
    or the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option,
    this form of loading is triggered at the same time a lazy load would normally
    occur, except it raises an ORM exception in order to guard against the application
    making unwanted lazy loads. An introduction to raise loading is at [Preventing
    unwanted lazy loads using raiseload](#prevent-lazy-with-raiseload).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引发加载** - 可通过`lazy=''raise''`、`lazy=''raise_on_sql''`或[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项使用，这种加载形式在通常会发生惰性加载的时候被触发，但它会引发一个ORM异常，以防止应用程序进行不必要的惰性加载。引发加载的简介详见[使用
    raiseload 防止不想要的惰性加载](#prevent-lazy-with-raiseload)。'
- en: '**subquery loading** - available via `lazy=''subquery''` or the [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") option, this form of loading emits a second SELECT
    statement which re-states the original query embedded inside of a subquery, then
    JOINs that subquery to the related table to be loaded to load all members of related
    collections / scalar references at once. Subquery eager loading is detailed at
    [Subquery Eager Loading](#subquery-eager-loading).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子查询加载** - 可通过`lazy=''subquery''`或[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")选项使用，这种加载方式会发出第二个SELECT语句，该语句重新陈述了原始查询嵌入到子查询中，然后将该子查询与要加载的相关表JOIN起来，以一次加载所有相关集合/标量引用的成员。子查询的及时加载详见[子查询的及时加载](#subquery-eager-loading)。'
- en: '**write only loading** - available via `lazy=''write_only''`, or by annotating
    the left side of the [`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") object using the [`WriteOnlyMapped`](../large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation. This collection-only loader style
    produces an alternative attribute instrumentation that never implicitly loads
    records from the database, instead only allowing [`WriteOnlyCollection.add()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add"), [`WriteOnlyCollection.add_all()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") and [`WriteOnlyCollection.remove()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") methods. Querying the collection
    is performed by invoking a SELECT statement which is constructed using the [`WriteOnlyCollection.select()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method. Write only loading is discussed
    at [Write Only Relationships](../large_collections.html#write-only-relationship).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅写入加载** - 可通过`lazy=''write_only''`获得，或通过在[`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship")对象的左侧使用[`WriteOnlyMapped`](../large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped")注解来标注。这种仅限集合的加载方式产生了一种替代的属性装载机制，从不隐式地从数据库加载记录，而是仅允许使用[`WriteOnlyCollection.add()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add")、[`WriteOnlyCollection.add_all()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all")和[`WriteOnlyCollection.remove()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove")方法。查询集合是通过调用使用[`WriteOnlyCollection.select()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select")方法构建的SELECT语句来执行的。仅写入加载在[仅写入关系](../large_collections.html#write-only-relationship)中进行了讨论。'
- en: '**dynamic loading** - available via `lazy=''dynamic''`, or by annotating the
    left side of the [`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") object using the [`DynamicMapped`](../large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation. This is a legacy collection-only loader
    style which produces a [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object when the collection is accessed, allowing custom SQL to be emitted against
    the collection’s contents. However, dynamic loaders will implicitly iterate the
    underlying collection in various circumstances which makes them less useful for
    managing truly large collections. Dynamic loaders are superseded by [“write only”](../large_collections.html#write-only-relationship)
    collections, which will prevent the underlying collection from being implicitly
    loaded under any circumstances. Dynamic loaders are discussed at [Dynamic Relationship
    Loaders](../large_collections.html#dynamic-relationship).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态加载** - 可通过`lazy=''dynamic''`获得，或通过在[`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship")对象的左侧使用[`DynamicMapped`](../large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped")注解来标注。这是一种传统的仅限集合的加载样式，当访问集合时会产生一个[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象，允许针对集合的内容发出自定义SQL。然而，动态加载器在各种情况下将隐式迭代底层集合，这使它们对管理真正大型集合不太有用。动态加载器已被[“仅写入”](../large_collections.html#write-only-relationship)集合取代，后者将阻止在任何情况下隐式加载底层集合。动态加载器在[动态关系加载器](../large_collections.html#dynamic-relationship)中进行了讨论。'
- en: '## Configuring Loader Strategies at Mapping Time'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在映射时配置加载策略'
- en: The loader strategy for a particular relationship can be configured at mapping
    time to take place in all cases where an object of the mapped type is loaded,
    in the absence of any query-level options that modify it. This is configured using
    the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); common values for this parameter include `select`,
    `selectin` and `joined`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 特定关系的加载策略可以在映射时配置，以在加载映射类型的对象的所有情况下发生，即使没有修改它的任何查询级别选项。这是使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数进行配置的；此参数的常见值包括`select`、`selectin`和`joined`。
- en: 'The example below illustrates the relationship example at [One To Many](../basic_relationships.html#relationship-patterns-o2m),
    configuring the `Parent.children` relationship to use [Select IN loading](#selectin-eager-loading)
    when a SELECT statement for `Parent` objects is emitted:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了在[一对多](../basic_relationships.html#relationship-patterns-o2m)关系模式下的关系示例，配置了`Parent.children`关系以在发出`Parent`对象的SELECT语句时使用[选择IN加载](#selectin-eager-loading)：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, whenever a collection of `Parent` objects are loaded, each `Parent` will
    also have its `children` collection populated, using the `"selectin"` loader strategy
    that emits a second query.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，每当加载`Parent`对象集合时，每个`Parent`也将其`children`集合填充，使用`"selectin"`加载策略发出第二个查询。
- en: 'The default value of the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") argument is `"select"`, which indicates [Lazy Loading](#lazy-loading).  ##
    Relationship Loading with Loader Options'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数的默认值是`"select"`，表示[延迟加载](#lazy-loading)。## 使用加载器选项进行关系加载'
- en: 'The other, and possibly more common way to configure loading strategies is
    to set them up on a per-query basis against specific attributes using the [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method. Very detailed control over
    relationship loading is available using loader options; the most common are [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") and [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload").
    The option accepts a class-bound attribute referring to the specific class/attribute
    that should be targeted:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种，可能更常见的配置加载策略的方式是在针对特定属性的每个查询上设置它们，使用[`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options")方法。使用加载器选项可以对关系加载进行非常详细的控制；最常见的是[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")和[`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")。该选项接受一个类绑定的属性，指示应针对特定类/属性进行定位：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The loader options can also be “chained” using **method chaining** to specify
    how loading should occur further levels deep:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项也可以使用**方法链接**进行“链接”，以指定进一步深层次的加载方式：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Chained loader options can be applied against a “lazy” loaded collection. This
    means that when a collection or association is lazily loaded upon access, the
    specified option will then take effect:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的加载器选项可以应用于“延迟”加载的集合。这意味着当在访问时惰性加载集合或关联时，指定的选项将生效：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, the query will return `Parent` objects without the `children` collections
    loaded. When the `children` collection on a particular `Parent` object is first
    accessed, it will lazy load the related objects, but additionally apply eager
    loading to the `subelements` collection on each member of `children`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的查询中，将返回未加载`children`集合的`Parent`对象。当首次访问特定`Parent`对象上的`children`集合时，它将延迟加载相关对象，并且还将对每个`children`成员的`subelements`集合应用急加载。
- en: '### Adding Criteria to loader options'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### 向加载器选项添加条件'
- en: 'The relationship attributes used to indicate loader options include the ability
    to add additional filtering criteria to the ON clause of the join that’s created,
    or to the WHERE criteria involved, depending on the loader strategy. This can
    be achieved using the [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method which will pass through an option
    such that loaded results are limited to the given filter criteria:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指示加载器选项的关系属性包括向创建的连接的ON子句添加额外的过滤条件，或者根据加载器策略涉及到的WHERE条件添加过滤条件的能力。这可以通过使用[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")方法来实现，该方法将通过一个选项传递，以便加载的结果被限制为给定的过滤条件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When using limiting criteria, if a particular collection is already loaded
    it won’t be refreshed; to ensure the new criteria takes place, apply the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用限制条件时，如果特定的集合已经加载，则不会刷新；为了确保新的条件生效，请应用[现有填充](api.html#orm-queryguide-populate-existing)执行选项：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to add filtering criteria to all occurrences of an entity throughout
    a query, regardless of loader strategy or where it occurs in the loading process,
    see the [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在查询中添加对实体的所有出现的过滤条件，无论加载策略如何或它在加载过程中的位置如何，参见 [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 函数。
- en: 'New in version 1.4.  ### Specifying Sub-Options with Load.options()'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4 中新增。### 使用 Load.options() 指定子选项
- en: 'Using method chaining, the loader style of each link in the path is explicitly
    stated. To navigate along a path without changing the existing loader style of
    a particular attribute, the [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    method/function may be used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链，路径中每个链接的加载器样式都明确说明。要沿着路径导航而不更改特定属性的现有加载器样式，请使用 [`defaultload()`](#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") 方法/函数：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A similar approach can be used to specify multiple sub-options at once, using
    the [`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法可以用来一次指定多个子选项，使用 [`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    方法：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using load_only() on related objects and collections](columns.html#orm-queryguide-load-only-related)
    - illustrates examples of combining relationship and column-oriented loader options.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[在相关对象和集合上使用 load_only()](columns.html#orm-queryguide-load-only-related) -
    演示了结合关系和基于列的加载器选项的示例。'
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The loader options applied to an object’s lazy-loaded collections are **“sticky”**
    to specific object instances, meaning they will persist upon collections loaded
    by that specific object for as long as it exists in memory. For example, given
    the previous example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于对象的延迟加载集合的加载器选项对于特定对象实例是**“粘性的”**，这意味着它们将在内存中存在的对象加载的集合上持续存在。例如，给定前面的示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'if the `children` collection on a particular `Parent` object loaded by the
    above query is expired (such as when a [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s transaction is committed or rolled back, or
    [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") is used), when the `Parent.children` collection
    is next accessed in order to re-load it, the `Child.subelements` collection will
    again be loaded using subquery eager loading. This stays the case even if the
    above `Parent` object is accessed from a subsequent query that specifies a different
    set of options. To change the options on an existing object without expunging
    it and re-loading, they must be set explicitly in conjunction using the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述查询加载的特定 `Parent` 对象上的 `children` 集合过期（例如当 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务提交或回滚时，或使用了 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")），当下次访问 `Parent.children` 集合以重新加载时，`Child.subelements`
    集合将再次使用子查询急加载。即使上述 `Parent` 对象是从指定了不同选项集的后续查询中访问的，这种情况仍然存在。要在不清除对象并重新加载的情况下更改现有对象上的选项，必须使用
    [Populate Existing](api.html#orm-queryguide-populate-existing) 执行选项显式设置它们：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the objects loaded above are fully cleared from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), such as due to garbage collection or that [`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") were used, the “sticky” options will also
    be gone and the newly created objects will make use of new options if loaded again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面加载的对象被 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    完全清除，例如由于垃圾回收或使用了 [`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")，那么“粘性”选项也将消失，如果再次加载新创建的对象，则会使用新选项。
- en: 'A future SQLAlchemy release may add more alternatives to manipulating the loader
    options on already-loaded objects.  ## Lazy Loading'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 发布版本可能会添加更多的选择来操作已加载对象上的加载器选项。## 延迟加载
- en: 'By default, all inter-object relationships are **lazy loading**. The scalar
    or collection attribute associated with a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") contains a trigger which fires the first time the
    attribute is accessed. This trigger typically issues a SQL call at the point of
    access in order to load the related object or objects:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有对象之间的关系都是**延迟加载**的。与[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")关联的标量或集合属性包含一个触发器，在第一次访问属性时触发。这个触发器通常在访问点发出SQL调用，以加载相关的对象或对象：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The one case where SQL is not emitted is for a simple many-to-one relationship,
    when the related object can be identified by its primary key alone and that object
    is already present in the current [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For this reason, while lazy loading can be expensive
    for related collections, in the case that one is loading lots of objects with
    simple many-to-ones against a relatively small set of possible target objects,
    lazy loading may be able to refer to these objects locally without emitting as
    many SELECT statements as there are parent objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的情况是不发出SQL的情况是简单的多对一关系，当相关对象仅可以通过其主键单独标识，并且该对象已经存在于当前[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中时。因此，虽然对相关集合进行延迟加载可能很昂贵，但在加载许多对象与相对较小的可能目标对象集合的情况下，延迟加载可能能够在本地引用这些对象，而无需发出与父对象数量相同数量的SELECT语句。
- en: This default behavior of “load upon attribute access” is known as “lazy” or
    “select” loading - the name “select” because a “SELECT” statement is typically
    emitted when the attribute is first accessed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“根据属性访问加载”的默认行为称为“延迟”或“选择”加载 - 名称“选择”是因为在首次访问属性时通常会发出“SELECT”语句。
- en: 'Lazy loading can be enabled for a given attribute that is normally configured
    in some other way using the [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")
    loader option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")加载器选项来启用通常以其他方式配置的给定属性的延迟加载：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '### Preventing unwanted lazy loads using raiseload'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用raiseload防止不需要的延迟加载'
- en: 'The [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") strategy
    produces an effect that is one of the most common issues referred to in object
    relational mapping; the [N plus one problem](../../glossary.html#term-N-plus-one-problem),
    which states that for any N objects loaded, accessing their lazy-loaded attributes
    means there will be N+1 SELECT statements emitted. In SQLAlchemy, the usual mitigation
    for the N+1 problem is to make use of its very capable eager load system. However,
    eager loading requires that the attributes which are to be loaded be specified
    with the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") up front. The problem of code that may access
    other attributes that were not eagerly loaded, where lazy loading is not desired,
    may be addressed using the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")
    strategy; this loader strategy replaces the behavior of lazy loading with an informative
    error being raised:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")策略产生的效果是对象关系映射中最常见的问题之一；[N加一问题](../../glossary.html#term-N-plus-one-problem)，它指出对于任何加载的N个对象，访问其惰性加载的属性意味着会发出N+1个SELECT语句。在SQLAlchemy中，解决N+1问题的通常方法是利用其非常强大的急加载系统。然而，急加载要求事先使用[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")指定要加载的属性。可能访问其他未急加载的属性的代码问题，不希望延迟加载，可以使用[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")策略来解决；这个加载器策略用引发一个具有信息性错误的方式替换了惰性加载的行为：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Above, a `User` object loaded from the above query will not have the `.addresses`
    collection loaded; if some code later on attempts to access this attribute, an
    ORM exception is raised.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，从上述查询加载的`User`对象将不会加载`.addresses`集合；如果稍后的一些代码尝试访问此属性，则会引发ORM异常。
- en: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") may be
    used with a so-called “wildcard” specifier to indicate that all relationships
    should use this strategy. For example, to set up only one attribute as eager loading,
    and all the rest as raise:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用所谓的“通配符”指示符将[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")用于表示所有关系都应该使用这种策略。例如，设置仅一个属性为急加载，并将其余全部设置为raise：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above wildcard will apply to **all** relationships not just on `Order`
    besides `items`, but all those on the `Item` objects as well. To set up [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") for only the `Order` objects, specify a full path
    with [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load"):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述通配符将适用于**所有**关系，而不仅适用于`items`，还适用于`Item`对象上的所有关系。要仅为`Order`对象设置[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")，请指定具有[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")的完整路径：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Conversely, to set up the raise for just the `Item` objects:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要为仅`Item`对象设置提升：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option
    applies only to relationship attributes. For column-oriented attributes, the [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") option supports the [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") option which works in the same way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")选项仅适用于关系属性。对于基于列的属性，[`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项支持[`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")选项，其工作方式相同。'
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The “raiseload” strategies **do not apply** within the [unit of work](../../glossary.html#term-unit-of-work)
    flush process. That means if the [`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") process needs to load a collection in order to
    finish its work, it will do so while bypassing any [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") directives.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload”策略在[工作单元](../../glossary.html#term-unit-of-work)刷新过程中**不适用**。这意味着如果[`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")过程需要加载集合以完成其工作，则会在绕过任何[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")指令的情况下执行此操作。
- en: See also
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Wildcard Loading Strategies](#wildcard-loader-strategies)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[通配符加载策略](#wildcard-loader-strategies)'
- en: '[Using raiseload to prevent deferred column loads](columns.html#orm-queryguide-deferred-raiseload)  ##
    Joined Eager Loading'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用raiseload防止延迟列加载](columns.html#orm-queryguide-deferred-raiseload)  ## 连接预加载'
- en: Joined eager loading is the oldest style of eager loading included with the
    SQLAlchemy ORM. It works by connecting a JOIN (by default a LEFT OUTER join) to
    the SELECT statement emitted, and populates the target scalar/collection from
    the same result set as that of the parent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 连接预加载是包含在SQLAlchemy ORM中的最古老的预加载样式。它通过将JOIN（默认为LEFT OUTER join）连接到发出的SELECT语句，并且从与父级相同的结果集中填充目标标量/集合来工作。
- en: 'At the mapping level, this looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射级别，看起来像这样：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Joined eager loading is usually applied as an option to a query, rather than
    as a default loading option on the mapping, in particular when used for collections
    rather than many-to-one-references. This is achieved using the [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loader option:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 连接预加载通常作为查询的选项应用，而不是作为映射的默认加载选项，特别是在用于集合而不是多对一引用时。可以使用[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")加载器选项来实现这一点：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When including [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    in reference to a one-to-many or many-to-many collection, the [`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method must be applied to the returned result,
    which will uniquify the incoming rows by primary key that otherwise are multiplied
    out by the join. The ORM will raise an error if this is not present.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当参考一对多或多对多集合时包括[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")时，必须对返回的结果应用[`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique")方法，该方法将通过否则由连接相乘出的主键使传入的行不重复。如果未提供此项，则ORM将引发错误。
- en: This is not automatic in modern SQLAlchemy, as it changes the behavior of the
    result set to return fewer ORM objects than the statement would normally return
    in terms of number of rows. Therefore SQLAlchemy keeps the use of [`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") explicit, so there’s no ambiguity that the
    returned objects are being uniqified on primary key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这在现代SQLAlchemy中不是自动的，因为它会更改结果集的行为，使其返回的ORM对象比语句通常返回的行数少。因此，SQLAlchemy保持了对[`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique")的使用是显式的，因此返回的对象是在主键上唯一的，没有任何歧义。
- en: 'The JOIN emitted by default is a LEFT OUTER JOIN, to allow for a lead object
    that does not refer to a related row. For an attribute that is guaranteed to have
    an element, such as a many-to-one reference to a related object where the referencing
    foreign key is NOT NULL, the query can be made more efficient by using an inner
    join; this is available at the mapping level via the [`relationship.innerjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") flag:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下发出的 JOIN 是 LEFT OUTER JOIN，以允许不引用相关行的主对象。对于保证具有元素的属性，例如引用相关对象的多对一引用，其中引用外键不为
    NULL，可以通过使用内连接使查询更有效；这在映射级别通过 [`relationship.innerjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") 标志可用：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the query option level, via the [`joinedload.innerjoin`](#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") flag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询选项级别，通过 [`joinedload.innerjoin`](#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") 标志：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The JOIN will right-nest itself when applied in a chain that includes an OUTER
    JOIN:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于包含 OUTER JOIN 的链时，JOIN 会向右嵌套自身：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If using database row locking techniques when emitting the SELECT, meaning the
    [`Select.with_for_update()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update
    "sqlalchemy.sql.expression.Select.with_for_update") method is being used to emit
    SELECT..FOR UPDATE, the joined table may be locked as well, depending on the behavior
    of the backend in use. It’s not recommended to use joined eager loading at the
    same time as SELECT..FOR UPDATE for this reason.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在发出 `SELECT` 时使用数据库行锁定技术，即意味着正在使用 [`Select.with_for_update()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update
    "sqlalchemy.sql.expression.Select.with_for_update") 方法发出 `SELECT..FOR UPDATE`，则根据使用的后端的行为，可能会锁定连接的表。出于这个原因，不建议同时使用连接的急切加载和
    `SELECT..FOR UPDATE`。
- en: '### The Zen of Joined Eager Loading'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '### 连接急切加载的禅意'
- en: Since joined eager loading seems to have many resemblances to the use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), it often produces confusion as to when
    and how it should be used. It is critical to understand the distinction that while
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is used to alter the results of a query,
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") goes
    through great lengths to **not** alter the results of the query, and instead hide
    the effects of the rendered join to only allow for related objects to be present.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接的急切加载似乎与使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 的方式有很多相似之处，因此人们经常困惑于何时以及如何使用它。至关重要的是要理解这样的区别，即虽然
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 用于更改查询的结果，但 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 费尽心思地**不**更改查询的结果，而是隐藏所渲染的连接的效果，仅允许相关对象存在。
- en: The philosophy behind loader strategies is that any set of loading schemes can
    be applied to a particular query, and *the results don’t change* - only the number
    of SQL statements required to fully load related objects and collections changes.
    A particular query might start out using all lazy loads. After using it in context,
    it might be revealed that particular attributes or collections are always accessed,
    and that it would be more efficient to change the loader strategy for these. The
    strategy can be changed with no other modifications to the query, the results
    will remain identical, but fewer SQL statements would be emitted. In theory (and
    pretty much in practice), nothing you can do to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would make it load a different set of primary
    or related objects based on a change in loader strategy.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器策略背后的理念是，任何一组加载方案都可以应用于特定查询，*结果不会改变* - 只有用于完全加载相关对象和集合所需的 SQL 语句数量会改变。一个特定的查询可能首先使用所有惰性加载。在上下文中使用后，可能会发现总是访问特定属性或集合，并且更改这些属性的加载策略更有效。该策略可以更改而不必对查询进行其他修改，结果将保持不变，但会发出更少的
    SQL 语句。理论上（实际上基本如此），对 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 所做的任何操作都不会使其根据加载器策略的更改而加载不同的主对象或相关对象集。
- en: 'How [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    in particular achieves this result of not impacting entity rows returned in any
    way is that it creates an anonymous alias of the joins it adds to your query,
    so that they can’t be referenced by other parts of the query. For example, the
    query below uses [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to create a LEFT OUTER JOIN from `users` to `addresses`, however the `ORDER BY`
    added against `Address.email_address` is not valid - the `Address` entity is not
    named in the query:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")是如何实现不以任何方式影响返回的实体行的结果的，这是因为它为添加到查询中的连接创建了一个匿名别名，因此它们不能被查询的其他部分引用。例如，下面的查询使用[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")来创建从`users`到`addresses`的 LEFT OUTER JOIN，但是针对`Address.email_address`添加的`ORDER
    BY`是无效的 - 查询中未命名实体`Address`：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Above, `ORDER BY addresses.email_address` is not valid since `addresses` is
    not in the FROM list. The correct way to load the `User` records and order by
    email address is to use [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`ORDER BY addresses.email_address` 是无效的，因为`addresses`不在 FROM 列表中。加载`User`记录并按电子邮件地址排序的正确方法是使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The statement above is of course not the same as the previous one, in that
    the columns from `addresses` are not included in the result at all. We can add
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") back
    in, so that there are two joins - one is that which we are ordering on, the other
    is used anonymously to load the contents of the `User.addresses` collection:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句当然与先前的语句不同，因为从`addresses`中提取的列根本没有包含在结果中。我们可以重新添加[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，这样就有两个连接 - 一个是我们正在排序的连接，另一个是匿名使用的连接，用于加载`User.addresses`集合的内容：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we see above is that our usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to supply JOIN clauses we’d like to
    use in subsequent query criterion, whereas our usage of [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") only concerns itself with the loading of the `User.addresses`
    collection, for each `User` in the result. In this case, the two joins most probably
    appear redundant - which they are. If we wanted to use just one JOIN for collection
    loading as well as ordering, we use the [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option, described in [Routing Explicit Joins/Statements
    into Eagerly Loaded Collections](#contains-eager) below. But to see why [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") does what it does, consider if we were **filtering**
    on a particular `Address`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的是我们对[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的用法是提供我们希望在随后的查询条件中使用的 JOIN 子句，而我们对[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")的用法只涉及加载结果中每个`User`的`User.addresses`集合。在这种情况下，这两个连接很可能看起来是多余的
    - 它们就是。如果我们只想使用一个 JOIN 来加载集合并进行排序，我们可以使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项，下面将介绍如何将显式的 JOIN/语句路由到急加载的集合中。但要了解[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")为什么会产生这样的结果，考虑一下如果我们在特定的`Address`上进行**过滤**：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Above, we can see that the two JOINs have very different roles. One will match
    exactly one row, that of the join of `User` and `Address` where `Address.email_address=='someaddress@foo.com'`.
    The other LEFT OUTER JOIN will match *all* `Address` rows related to `User`, and
    is only used to populate the `User.addresses` collection, for those `User` objects
    that are returned.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们可以看到这两个 JOIN 的作用非常不同。一个将完全匹配一个行，即`User`和`Address`的连接，其中`Address.email_address=='someaddress@foo.com'`。另一个
    LEFT OUTER JOIN 将匹配与`User`相关的所有`Address`行，并且仅用于为返回的那些`User`对象填充`User.addresses`集合。
- en: 'By changing the usage of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to another style of loading, we can change how the collection is loaded completely
    independently of SQL used to retrieve the actual `User` rows we want. Below we
    change [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    into [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload"):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变 [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    的使用方式到另一种加载样式，我们可以完全独立于用于检索实际想要的 `User` 行的 SQL 改变集合的加载方式。以下我们将 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 改变为 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When using joined eager loading, if the query contains a modifier that impacts
    the rows returned externally to the joins, such as when using DISTINCT, LIMIT,
    OFFSET or equivalent, the completed statement is first wrapped inside a subquery,
    and the joins used specifically for joined eager loading are applied to the subquery.
    SQLAlchemy’s joined eager loading goes the extra mile, and then ten miles further,
    to absolutely ensure that it does not affect the end result of the query, only
    the way collections and related objects are loaded, no matter what the format
    of the query is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用联接式的急加载时，如果查询包含影响联接外返回的行的修改器，比如使用 DISTINCT、LIMIT、OFFSET 或等效的修改器时，完成的语句首先被包裹在一个子查询中，并且专门用于联接式的急加载的联接应用于子查询。SQLAlchemy
    的联接式急加载会走出额外的一步，然后再走出额外的十步，绝对确保它不会影响查询的最终结果，只会影响集合和相关对象的加载方式，无论查询的格式如何。
- en: See also
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)
    - using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")  ##
    Select IN loading'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[将显式联接/语句路由到急加载集合](#contains-eager) - 使用 [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")  ## 选择 IN 加载'
- en: In most cases, selectin loading is the most simple and efficient way to eagerly
    load collections of objects. The only scenario in which selectin eager loading
    is not feasible is when the model is using composite primary keys, and the backend
    database does not support tuples with IN, which currently includes SQL Server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，选择 IN 加载是急加载对象集合的最简单和最有效的方式。唯一一个不可行的情况是当模型使用复合主键，并且后端数据库不支持具有 IN 的元组时，这目前包括
    SQL Server。
- en: '“Select IN” eager loading is provided using the `"selectin"` argument to [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") or by using the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This style of loading emits a SELECT
    that refers to the primary key values of the parent object, or in the case of
    a many-to-one relationship to the those of the child objects, inside of an IN
    clause, in order to load related associations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `"selectin"` 参数提供了“选择 IN”急加载，或者通过使用 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 加载器选项。这种加载样式发出一个 SELECT，该 SELECT 引用父对象的主键值，或者在一对多关系的情况下引用子对象的主键值，以便在
    IN 子句中加载相关联的关系：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Above, the second SELECT refers to `addresses.user_id IN (5, 7)`, where the
    “5” and “7” are the primary key values for the previous two `User` objects loaded;
    after a batch of objects are completely loaded, their primary key values are injected
    into the `IN` clause for the second SELECT. Because the relationship between `User`
    and `Address` has a simple primary join condition and provides that the primary
    key values for `User` can be derived from `Address.user_id`, the statement has
    no joins or subqueries at all.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，第二个 SELECT 是指 `addresses.user_id IN (5, 7)`，其中的 “5” 和 “7” 是之前加载的前两个 `User`
    对象的主键值；在一批对象完全加载后，它们的主键值被注入到第二个 SELECT 的 `IN` 子句中。因为 `User` 和 `Address` 之间的关系有一个简单的主键连接条件，并且提供了
    `User` 的主键值可以从 `Address.user_id` 派生出来，所以语句根本没有联接或子查询。
- en: 'For simple many-to-one loads, a JOIN is also not needed as the foreign key
    value from the parent object is used:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的一对多加载，也不需要使用 JOIN，因为会使用父对象的外键值：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: by “simple” we mean that the [`relationship.primaryjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition expresses an equality comparison between
    the primary key of the “one” side and a straight foreign key of the “many” side,
    without any additional criteria.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“简单”我们指的是 [`relationship.primaryjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 条件表达了“一”侧的主键与“多”侧的直接外键之间的相等比较，没有任何额外的条件。
- en: Select IN loading also supports many-to-many relationships, where it currently
    will JOIN across all three tables to match rows from one side to the other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Select IN 加载还支持多对多关系，其中它当前将跨越所有三个表进行 JOIN，以将一侧的行与另一侧的行匹配。
- en: 'Things to know about this kind of loading include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种加载方式需要知道的事情包括：
- en: The strategy emits a SELECT for up to 500 parent primary key values at a time,
    as the primary keys are rendered into a large IN expression in the SQL statement.
    Some databases like Oracle have a hard limit on how large an IN expression can
    be, and overall the size of the SQL string shouldn’t be arbitrarily large.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该策略每次会发出一个 SELECT 查询，最多查询 500 个父主键值，因为这些主键值会被渲染成 SQL 语句中的一个大型 IN 表达式。一些数据库，比如
    Oracle，在 IN 表达式的大小上有一个硬限制，总体上 SQL 字符串的大小不应该是任意大的。
- en: 'As “selectin” loading relies upon IN, for a mapping with composite primary
    keys, it must use the “tuple” form of IN, which looks like `WHERE (table.column_a,
    table.column_b) IN ((?, ?), (?, ?), (?, ?))`. This syntax is not currently supported
    on SQL Server and for SQLite requires at least version 3.15\. There is no special
    logic in SQLAlchemy to check ahead of time which platforms support this syntax
    or not; if run against a non-supporting platform, the database will return an
    error immediately. An advantage to SQLAlchemy just running the SQL out for it
    to fail is that if a particular database does start supporting this syntax, it
    will work without any changes to SQLAlchemy (as was the case with SQLite).  ##
    Subquery Eager Loading'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于“selectin”加载依赖于 IN，在具有复合主键的映射中，它必须使用“元组”形式的 IN，看起来像 `WHERE (table.column_a,
    table.column_b) IN ((?, ?), (?, ?), (?, ?))`。这种语法目前不受 SQL Server 支持，对于 SQLite
    需要至少版本 3.15。SQLAlchemy 中没有特殊逻辑来提前检查哪些平台支持这种语法，如果运行在不支持的平台上，数据库将立即返回错误。SQLAlchemy
    只需运行 SQL 语句以使其失败的一个优点是，如果某个特定数据库开始支持这种语法，它将无需对 SQLAlchemy 进行任何更改即可工作（就像 SQLite
    的情况一样）。## 子查询急加载
- en: Legacy Feature
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传统特性
- en: The [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    eager loader is mostly legacy at this point, superseded by the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") strategy which is of much simpler design, more
    flexible with features such as [Yield Per](api.html#orm-queryguide-yield-per),
    and emits more efficient SQL statements in most cases. As [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") relies upon re-interpreting the original SELECT
    statement, it may fail to work efficiently when given very complex source queries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    预加载器在这一点上主要是传统的，已被 [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    策略取代，后者设计更简单，更灵活，具有诸如 [Yield Per](api.html#orm-queryguide-yield-per) 等功能，并在大多数情况下发出更有效的
    SQL 语句。由于 [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    依赖于重新解释原始的 SELECT 语句，当给定非常复杂的源查询时，可能无法有效地工作。'
- en: '[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    may continue to be useful for the specific case of an eager loaded collection
    for objects that use composite primary keys, on the Microsoft SQL Server backend
    that continues to not have support for the “tuple IN” syntax.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用复合主键的对象的急加载集合的特定情况，[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    可能仍然有用，因为 Microsoft SQL Server 后端仍然不支持“元组 IN”语法。
- en: Subquery loading is similar in operation to selectin eager loading, however
    the SELECT statement which is emitted is derived from the original statement,
    and has a more complex query structure as that of selectin eager loading.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询加载在操作上类似于 selectin 急加载，但发出的 SELECT 语句是从原始语句派生的，并且具有更复杂的查询结构，类似于 selectin
    急加载。
- en: Subquery eager loading is provided using the `"subquery"` argument to [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") or by using the [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") loader option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 中使用 `"subquery"` 参数或使用 [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") 加载器选项提供子查询急加载。
- en: 'The operation of subquery eager loading is to emit a second SELECT statement
    for each relationship to be loaded, across all result objects at once. This SELECT
    statement refers to the original SELECT statement, wrapped inside of a subquery,
    so that we retrieve the same list of primary keys for the primary object being
    returned, then link that to the sum of all the collection members to load them
    at once:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询急加载的操作是为要加载的每个关系发出第二个 SELECT 语句，跨所有结果对象一次性加载。此 SELECT 语句引用原始 SELECT 语句，该语句包装在子查询中，以便我们检索要返回的主对象的相同主键列表，然后将其与要一次性加载的所有集合成员的总和链接起来：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Things to know about this kind of loading include:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种加载方式需要知道的事项包括：
- en: The SELECT statement emitted by the “subquery” loader strategy, unlike that
    of “selectin”, requires a subquery, and will inherit whatever performance limitations
    are present in the original query. The subquery itself may also incur performance
    penalties based on the specifics of the database in use.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载策略发出的 SELECT 语句（与“selectin”的不同之处在于）需要一个子查询，并将继承原始查询中存在的任何性能限制。子查询本身也可能因为所使用的数据库的具体情况而产生性能惩罚。
- en: '“subquery” loading imposes some special ordering requirements in order to work
    correctly. A query which makes use of [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") in conjunction with a limiting modifier such as
    [`Select.limit()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit"), or [`Select.offset()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") should **always** include [`Select.order_by()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") against unique column(s) such as
    the primary key, so that the additional queries emitted by [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") include the same ordering as used by the parent
    query. Without it, there is a chance that the inner query could return the wrong
    rows:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载在正确工作时会施加一些特殊的排序要求。使用 [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") 与诸如 [`Select.limit()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 或 [`Select.offset()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 这样的限定修饰符的查询应该**始终**包含针对唯一列（如主键）的 [`Select.order_by()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")，以便由 [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") 发出的附加查询包含与父查询使用的相同排序。否则，内部查询可能会返回错误的行：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Why is ORDER BY recommended with LIMIT (especially with subqueryload())?](../../faq/ormconfiguration.html#faq-subqueryload-limit-sort)
    - detailed example'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[为什么建议在 LIMIT 中使用 ORDER BY（特别是在 subqueryload() 中）？](../../faq/ormconfiguration.html#faq-subqueryload-limit-sort)
    - 详细示例'
- en: “subquery” loading also incurs additional performance / complexity issues when
    used on a many-levels-deep eager load, as subqueries will be nested repeatedly.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在许多级别的深层急加载上使用时，“子查询”加载还会带来额外的性能/复杂性问题，因为子查询将被重复嵌套。
- en: “subquery” loading is not compatible with the “batched” loading supplied by
    [Yield Per](api.html#orm-queryguide-yield-per), both for collection and scalar
    relationships.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载与由 [Yield Per](api.html#orm-queryguide-yield-per) 提供的“批量”加载（对集合和标量关系均适用）不兼容。
- en: For the above reasons, the “selectin” strategy should be preferred over “subquery”.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出于上述原因，“selectin”策略应优先于“子查询”。
- en: See also
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Select IN loading](#selectin-eager-loading)  ## What Kind of Loading to Use
    ?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](#selectin-eager-loading)  ## 何种加载方式？'
- en: Which type of loading to use typically comes down to optimizing the tradeoff
    between number of SQL executions, complexity of SQL emitted, and amount of data
    fetched.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种加载方式通常涉及到优化 SQL 执行次数、所发出 SQL 的复杂度以及获取的数据量之间的权衡。
- en: '**One to Many / Many to Many Collection** - The [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is generally the best loading strategy to use.
    It emits an additional SELECT that uses as few tables as possible, leaving the
    original statement unaffected, and is most flexible for any kind of originating
    query. Its only major limitation is when using a table with composite primary
    keys on a backend that does not support “tuple IN”, which currently includes SQL
    Server and very old SQLite versions; all other included backends support it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**一对多 / 多对多集合** - [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    通常是最佳的加载策略。它会发出额外的 SELECT 查询，尽可能使用少量的表，不影响原始语句，并且对于任何类型的原始查询都非常灵活。它唯一的主要限制是在使用不支持“tuple
    IN”的后端的复合主键表时，目前包括 SQL Server 和非常旧的 SQLite 版本；所有其他包含的后端都支持它。'
- en: '**Many to One** - The [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    strategy is the most general purpose strategy. In special cases, the [`immediateload()`](#sqlalchemy.orm.immediateload
    "sqlalchemy.orm.immediateload") strategy may also be useful, if there are a very
    small number of potential related values, as this strategy will fetch the object
    from the local [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    without emitting any SQL if the related object is already present.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**多对一** - [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    策略是最通用的策略。在特殊情况下，如果潜在相关值数量很少，也可以使用[`immediateload()`](#sqlalchemy.orm.immediateload
    "sqlalchemy.orm.immediateload") 策略，因为如果相关对象已经存在，则该策略将从本地[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")获取对象，而不发出任何 SQL。'
- en: Polymorphic Eager Loading
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态急加载
- en: Specification of polymorphic options on a per-eager-load basis is supported.
    See the section [Eager Loading of Polymorphic Subtypes](inheritance.html#eagerloading-polymorphic-subtypes)
    for examples of the [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method in conjunction with the [`with_polymorphic()`](inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 支持按急加载基础上的每个急加载选项进行多态选项的指定。参见[Eager Loading of Polymorphic Subtypes](inheritance.html#eagerloading-polymorphic-subtypes)部分中与[`with_polymorphic()`](inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数配合使用的[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法的示例。
- en: '## Wildcard Loading Strategies'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '## 通配符加载策略'
- en: 'Each of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload"),
    [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload"),
    [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"), [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload"),
    and [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") can
    be used to set the default style of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") loading for a particular query, affecting all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") -mapped attributes not otherwise specified in the
    statement. This feature is available by passing the string `''*''` as the argument
    to any of these options:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")、[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")、[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")、[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")
    和[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 中的每一个都可以用于为特定查询设置[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")加载的默认样式，影响除了在语句中另有规定的所有 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") -映射属性。通过将字符串 `''*''` 作为这些选项中的任何一个的参数传递，可以使用此功能：'
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Above, the `lazyload('*')` option will supersede the `lazy` setting of all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs in use for that query, with the exception
    of those that use `lazy='write_only'` or `lazy='dynamic'`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`lazyload('*')` 选项将取代该查询中所有正在使用的所有 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的 `lazy` 设置，但不包括那些使用 `lazy='write_only'` 或 `lazy='dynamic'`
    的构造。
- en: If some relationships specify `lazy='joined'` or `lazy='selectin'`, for example,
    using `lazyload('*')` will unilaterally cause all those relationships to use `'select'`
    loading, e.g. emit a SELECT statement when each attribute is accessed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些关系指定了`lazy='joined'`或`lazy='selectin'`，例如，使用`lazyload('*')`将单方面地导致所有这些关系使用`'select'`加载，例如，当访问每个属性时发出SELECT语句。
- en: 'The option does not supersede loader options stated in the query, such as [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"), etc. The query below will still use joined loading
    for the `widget` relationship:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项不会取代查询中声明的加载选项，例如[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")，[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")等。下面的查询仍将使用`widget`关系的joined加载：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While the instruction for [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    above will take place regardless of whether it appears before or after the [`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option, if multiple options that each included `"*"`
    were passed, the last one will take effect.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")的指令会发生，无论它出现在[`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")选项之前还是之后，但如果传递了每个包含`"*"`的多个选项，则最后一个将生效。
- en: '### Per-Entity Wildcard Loading Strategies'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '### 按实体的通配符加载策略'
- en: 'A variant of the wildcard loader strategy is the ability to set the strategy
    on a per-entity basis. For example, if querying for `User` and `Address`, we can
    instruct all relationships on `Address` to use lazy loading, while leaving the
    loader strategies for `User` unaffected, by first applying the [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object, then specifying the `*` as a chained option:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符加载策略的变体是能够根据每个实体设置策略的能力。例如，如果查询`User`和`Address`，我们可以指示`Address`上的所有关系使用延迟加载，同时通过首先应用[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象，然后指定`*`作为链接选项，保持对`User`的加载策略不受影响：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Above, all relationships on `Address` will be set to a lazy load.  ## Routing
    Explicit Joins/Statements into Eagerly Loaded Collections'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '上面，`Address`上的所有关系都将设置为延迟加载。  ## 将显式连接/语句路由到急加载集合'
- en: The behavior of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    is such that joins are created automatically, using anonymous aliases as targets,
    the results of which are routed into collections and scalar references on loaded
    objects. It is often the case that a query already includes the necessary joins
    which represent a particular collection or scalar reference, and the joins added
    by the joinedload feature are redundant - yet you’d still like the collections/references
    to be populated.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")的行为是自动创建连接，使用匿名别名作为目标，其结果被路由到加载对象上的集合和标量引用中。通常情况下，查询已经包括表示特定集合或标量引用的必要连接，并且joinedload功能添加的连接是多余的
    - 但您仍希望填充集合/引用。'
- en: 'For this SQLAlchemy supplies the [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is used in the same manner
    as the [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    option except it is assumed that the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object will explicitly include the appropriate
    joins, typically using methods like [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"). Below, we specify a join between `User`
    and `Address` and additionally establish this as the basis for eager loading of
    `User.addresses`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对此，SQLAlchemy提供了[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")选项。此选项的使用方式与[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")选项相同，不同之处在于假定[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象将明确包含适当的连接，通常使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")等方法。下面，我们指定了`User`和`Address`之间的连接，并将其另外建立为`User.addresses`的急加载的基础：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the “eager” portion of the statement is “aliased”, the path should be specified
    using [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type"), which allows the specific [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct to be passed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句的“eager”部分是“aliased”，则应使用[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 指定路径，这允许传递特定的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The path given as the argument to [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") needs to be a full path from the starting entity.
    For example if we were loading `Users->orders->Order->items->Item`, the option
    would be used as:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数给出的路径[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    需要是从起始实体开始的完整路径。例如，如果我们正在加载 `Users->orders->Order->items->Item` ，则选项将如下使用：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using contains_eager() to load a custom-filtered collection result
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 contains_eager() 加载自定义过滤的集合结果
- en: When we use [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    *we* are constructing ourselves the SQL that will be used to populate collections.
    From this, it naturally follows that we can opt to **modify** what values the
    collection is intended to store, by writing our SQL to load a subset of elements
    for collections or scalar attributes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    时，*我们*正在构造用于填充集合的 SQL。由此自然地可以选择**修改**要存储在集合中的值，通过编写 SQL 来加载集合或标量属性的子集。
- en: Tip
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: SQLAlchemy now has a **much simpler way to do this**, by allowing WHERE criteria
    to be added directly to loader options such as [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") using [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_"). See the section [Adding Criteria to loader
    options](#loader-option-criteria) for examples.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 现在有一种**更简单的方法**来做到这一点，它允许将 WHERE 条件直接添加到加载器选项中，例如[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 和 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") ，使用[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")。参见[添加条件到加载器选项](#loader-option-criteria)部分的示例。
- en: The techniques described here still apply if the related collection is to be
    queried using SQL criteria or modifiers more complex than a simple WHERE clause.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此处描述的技术仍然适用于使用 SQL 条件或修饰符查询相关集合，而不仅仅是简单的 WHERE 子句。
- en: 'As an example, we can load a `User` object and eagerly load only particular
    addresses into its `.addresses` collection by filtering the joined data, routing
    it using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    also using [Populate Existing](api.html#orm-queryguide-populate-existing) to ensure
    any already-loaded collections are overwritten:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以加载一个 `User` 对象，并通过过滤连接数据来将只特定地址急切地加载到其 `.addresses` 集合中，使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 路由，还使用[Populate Existing](api.html#orm-queryguide-populate-existing)
    确保任何已加载的集合都被覆盖：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The above query will load only `User` objects which contain at least `Address`
    object that contains the substring `'aol.com'` in its `email` field; the `User.addresses`
    collection will contain **only** these `Address` entries, and *not* any other
    `Address` entries that are in fact associated with the collection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将仅加载包含至少一个在其 `email` 字段中包含子字符串`'aol.com'`的 `Address` 对象的 `User` 对象；`User.addresses`
    集合将仅包含这些 `Address` 条目，并且不包含实际与集合关联的任何其他 `Address` 条目。
- en: Tip
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In all cases, the SQLAlchemy ORM does **not overwrite already loaded attributes
    and collections** unless told to do so. As there is an [identity map](../../glossary.html#term-identity-map)
    in use, it is often the case that an ORM query is returning objects that were
    in fact already present and loaded in memory. Therefore, when using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate a collection in an alternate way,
    it is usually a good idea to use [Populate Existing](api.html#orm-queryguide-populate-existing)
    as illustrated above so that an already-loaded collection is refreshed with the
    new data. The `populate_existing` option will reset **all** attributes that were
    already present, including pending changes, so make sure all data is flushed before
    using it. Using the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with its default behavior of [autoflush](../session_basics.html#session-flushing)
    is sufficient.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，SQLAlchemy ORM **不会覆盖已加载的属性和集合**，除非有指示要这样做。由于正在使用一个[身份映射](../../glossary.html#term-identity-map)，通常情况下，ORM
    查询返回的对象实际上已经存在并加载到内存中。因此，当使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")以另一种方式填充集合时，通常最好像上面示例中所示那样使用[填充现有](api.html#orm-queryguide-populate-existing)，以便已加载的集合使用新数据进行刷新。`populate_existing`
    选项将重置已经存在的**所有**属性，包括待处理的更改，因此在使用它之前确保所有数据都已刷新。使用带有其默认行为的[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，默认行为为[自动刷新](../session_basics.html#session-flushing)，已足够。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The customized collection we load using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") is not “sticky”; that is, the next time this
    collection is loaded, it will be loaded with its usual default contents. The collection
    is subject to being reloaded if the object is expired, which occurs whenever the
    [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit"),
    [`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    methods are used assuming default session settings, or the [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") methods are used.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")加载的定制集合不是“粘性”的；也就是说，下次加载此集合时，它将使用其通常的默认内容加载。如果对象过期，则该集合可能会重新加载，这在默认会话设置下发生，即每当使用
    [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法时，或者使用 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 或 [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法。
- en: See also
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Adding Criteria to loader options](#loader-option-criteria) - modern API allowing
    WHERE criteria directly within any relationship loader option'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[将条件添加到加载器选项](#loader-option-criteria) - 现代 API 允许在任何关系加载器选项中直接添加 WHERE 条件'
- en: Relationship Loader API
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系加载器 API
- en: '| Object Name | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [contains_eager](#sqlalchemy.orm.contains_eager)(*keys, **kw) | Indicate
    that the given attribute should be eagerly loaded from columns stated manually
    in the query. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| [contains_eager](#sqlalchemy.orm.contains_eager)(*keys, **kw) | 指示给定属性应通过手动在查询中声明的列进行急加载。
    |'
- en: '| [defaultload](#sqlalchemy.orm.defaultload)(*keys) | Indicate an attribute
    should load using its predefined loader style. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| [defaultload](#sqlalchemy.orm.defaultload)(*keys) | 指示属性应使用其预定义的加载器样式加载。
    |'
- en: '| [immediateload](#sqlalchemy.orm.immediateload)(*keys, [recursion_depth])
    | Indicate that the given attribute should be loaded using an immediate load with
    a per-attribute SELECT statement. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| [immediateload](#sqlalchemy.orm.immediateload)(*keys, [recursion_depth])
    | 指示给定属性应使用立即加载，并使用每个属性的 SELECT 语句。 |'
- en: '| [joinedload](#sqlalchemy.orm.joinedload)(*keys, **kw) | Indicate that the
    given attribute should be loaded using joined eager loading. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| [joinedload](#sqlalchemy.orm.joinedload)(*keys, **kw) | 指示给定属性应使用连接的急加载。
    |'
- en: '| [lazyload](#sqlalchemy.orm.lazyload)(*keys) | Indicate that the given attribute
    should be loaded using “lazy” loading. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| [lazyload](#sqlalchemy.orm.lazyload)(*keys) | 指示给定属性应使用“懒”加载。 |'
- en: '| [Load](#sqlalchemy.orm.Load) | Represents loader options which modify the
    state of a ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or a legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to affect how various mapped attributes are loaded.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| [Load](#sqlalchemy.orm.Load) | 表示加载器选项，可修改ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的状态，以影响如何加载各种映射属性。 |'
- en: '| [noload](#sqlalchemy.orm.noload)(*keys) | Indicate that the given relationship
    attribute should remain unloaded. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| [noload](#sqlalchemy.orm.noload)(*keys) | 表示给定关系属性应该保持未加载状态。 |'
- en: '| [raiseload](#sqlalchemy.orm.raiseload)(*keys, **kw) | Indicate that the given
    attribute should raise an error if accessed. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| [raiseload](#sqlalchemy.orm.raiseload)(*keys, **kw) | 表示访问给定属性时应引发错误。 |'
- en: '| [selectinload](#sqlalchemy.orm.selectinload)(*keys, [recursion_depth]) |
    Indicate that the given attribute should be loaded using SELECT IN eager loading.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| [selectinload](#sqlalchemy.orm.selectinload)(*keys, [recursion_depth]) |
    表示给定属性应该使用SELECT IN急加载加载。 |'
- en: '| [subqueryload](#sqlalchemy.orm.subqueryload)(*keys) | Indicate that the given
    attribute should be loaded using subquery eager loading. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| [subqueryload](#sqlalchemy.orm.subqueryload)(*keys) | 表示给定属性应该使用子查询急加载加载。
    |'
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Indicate that the given attribute should be eagerly loaded from columns stated
    manually in the query.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应该从查询中手动声明的列急加载给定属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链和独立操作。
- en: 'The option is used in conjunction with an explicit join that loads the desired
    rows, i.e.:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与加载所需行的显式连接一起使用，即：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The above query would join from the `Order` entity to its related `User` entity,
    and the returned `Order` objects would have the `Order.user` attribute pre-populated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将从`Order`实体连接到其相关的`User`实体，并且返回的`Order`对象将预先填充`Order.user`属性。
- en: 'It may also be used for customizing the entries in an eagerly loaded collection;
    queries will normally want to use the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option assuming the primary collection of parent objects may already
    have been loaded:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可用于自定义急加载集合中的条目；查询通常会希望使用[Populate Existing](api.html#orm-queryguide-populate-existing)执行选项，假设父对象的主要集合可能已经被加载：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See the section [Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)
    for complete usage details.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整使用详细信息，请参阅[将显式连接/语句路由到急加载集合](#contains-eager)部分。
- en: See also
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Relationship Loading Techniques](#)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到急加载集合](#contains-eager)'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Indicate an attribute should load using its predefined loader style.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表示属性应该使用其预定义的加载器样式加载。
- en: The behavior of this loading option is to not change the current loading style
    of the attribute, meaning that the previously configured one is used or, if no
    previous style was selected, the default loading will be used.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此加载选项的行为是不更改属性的当前加载样式，这意味着将使用先前配置的样式，或者如果没有选择先前的样式，则将使用默认加载。
- en: 'This method is used to link to other loader options further into a chain of
    attributes without altering the loader style of the links along the chain. For
    example, to set joined eager loading for an element of an element:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于进一步链接到属性链中的其他加载器选项，而不更改沿链的链接的加载器样式。例如，要为元素的元素设置连接的急加载：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    is also useful for setting column-level options on a related class, namely that
    of [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") and [`undefer()`](columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer"):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    也对于在相关类上设置列级选项很有用，即[`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")和[`undefer()`](columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")的选项：'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Specifying Sub-Options with Load.options()](#orm-queryguide-relationship-sub-options)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Load.options()指定子选项](#orm-queryguide-relationship-sub-options)'
- en: '[`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")'
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Indicate that the given attribute should be loaded using an immediate load with
    a per-attribute SELECT statement.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定属性应使用具有每个属性SELECT语句的立即加载进行加载。
- en: The load is achieved using the “lazyloader” strategy and does not fire off any
    additional eager loaders.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 加载是使用“lazyloader”策略实现的，并且不会触发任何其他急加载器。
- en: The [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    option is superseded in general by the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") option, which performs the same task more efficiently
    by emitting a SELECT for all loaded objects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    选项一般被[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    选项取代，后者通过为所有加载的对象发出一个 SELECT 更有效地执行相同的任务。'
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: 'Parameters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**recursion_depth** –'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归深度** –'
- en: optional int; when set to a positive integer in conjunction with a self-referential
    relationship, indicates “selectin” loading will continue that many levels deep
    automatically until no items are found.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的整数；当与自引用关系一起设置为正整数时，表示“选择加载”将自动继续到没有找到项目为止的那么多级别深度。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload") option currently supports only self-referential
    relationships. There is not yet an option to automatically traverse recursive
    structures with more than one relationship involved.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload") 选项当前仅支持自引用关系。目前还没有选项可以自动遍历具有多个涉及的关系的递归结构。'
- en: Warning
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This parameter is new and experimental and should be treated as “alpha” status
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数是新的实验性参数，应视为“alpha”状态
- en: 'New in version 2.0: added [`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload")'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 新版 2.0 中新增 [`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload")
- en: See also
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联加载技术](#)'
- en: '[Select IN loading](#selectin-eager-loading)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](#selectin-eager-loading)'
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Indicate that the given attribute should be loaded using joined eager loading.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定属性应使用连接式急加载进行加载。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: 'examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Parameters:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**innerjoin** –'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**innerjoin** –'
- en: 'if `True`, indicates that the joined eager load should use an inner join instead
    of the default of left outer join:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为 `True`，则表示连接式急加载应使用内部连接而不是默认的左外连接：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In order to chain multiple eager joins together where some may be OUTER and
    others INNER, right-nested joins are used to link them:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将多个急加载连接在一起，其中一些可能是 OUTER 而其他是 INNER，使用右嵌套连接将它们链接起来：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The above query, linking A.bs via “outer” join and B.cs via “inner” join would
    render the joins as “a LEFT OUTER JOIN (b JOIN c)”. When using older versions
    of SQLite (< 3.7.16), this form of JOIN is translated to use full subqueries as
    this syntax is otherwise not directly supported.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询，通过“outer”连接链接 A.bs 和通过“inner”连接链接 B.cs，会呈现为“a LEFT OUTER JOIN (b JOIN c)”
    的连接。当使用较旧版本的 SQLite (< 3.7.16) 时，此 JOIN 形式将转换为使用完整子查询，因为否则不直接支持此语法。
- en: 'The `innerjoin` flag can also be stated with the term `"unnested"`. This indicates
    that an INNER JOIN should be used, *unless* the join is linked to a LEFT OUTER
    JOIN to the left, in which case it will render as LEFT OUTER JOIN. For example,
    supposing `A.bs` is an outerjoin:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerjoin` 标志也可以用术语 `"unnested"` 表示。这表示应使用 INNER JOIN，*除非*连接链接到左边的 LEFT OUTER
    JOIN，此时它将呈现为 LEFT OUTER JOIN。例如，假设 `A.bs` 是一个 outerjoin：'
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The above join will render as “a LEFT OUTER JOIN b LEFT OUTER JOIN c”, rather
    than as “a LEFT OUTER JOIN (b JOIN c)”.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述连接将呈现为“a LEFT OUTER JOIN b LEFT OUTER JOIN c”，而不是“a LEFT OUTER JOIN (b JOIN
    c)”。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “unnested” flag does **not** affect the JOIN rendered from a many-to-many
    association table, e.g. a table configured as [`relationship.secondary`](../relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"), to the target table; for correctness of results,
    these joins are always INNER and are therefore right-nested if linked to an OUTER
    join.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: “unnested”标志**不会**影响从多对多关联表（例如，配置为[`relationship.secondary`](../relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")的表）到目标表的JOIN；为了结果的正确性，这些JOIN始终是INNER JOIN，因此如果与OUTER
    JOIN相关联，则为右嵌套。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The joins produced by [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    are **anonymously aliased**. The criteria by which the join proceeds cannot be
    modified, nor can the ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") refer to these joins in any way, including ordering. See
    [The Zen of Joined Eager Loading](#zen-of-eager-loading) for further detail.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")生成的JOIN是**匿名别名**的。
    JOIN进行的标准无法修改，也无法通过ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统的[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")以任何方式引用这些JOIN，包括排序。有关详细信息，请参阅[关联及时加载的禅意](#zen-of-eager-loading)。'
- en: To produce a specific SQL JOIN which is explicitly available, use [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"). To combine explicit JOINs with eager loading of
    collections, use [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager");
    see [Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成明确可用的特定SQL JOIN，请使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")。要将明确的JOIN与集合的及时加载结合使用，请使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")；参见[将明确的JOIN/语句路由到及时加载的集合中](#contains-eager)。
- en: See also
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Joined Eager Loading](#joined-eager-loading)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联及时加载](#joined-eager-loading)'
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Indicate that the given attribute should be loaded using “lazy” loading.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表明给定的属性应该使用“懒加载”。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: See also
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Lazy Loading](#lazy-loading)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[懒加载](#lazy-loading)'
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Represents loader options which modify the state of a ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or a legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to affect how various mapped attributes are loaded.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代表修改ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统的[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")状态以影响加载各种映射属性的加载器选项。
- en: The [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object is in most cases
    used implicitly behind the scenes when one makes use of a query option like [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer"),
    or similar. It typically is not instantiated directly except for in some very
    specific cases.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用查询选项如[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")、[`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")或类似选项时，[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象在大多数情况下会在幕后隐式使用。除了一些非常特殊的情况外，通常不会直接实例化它。
- en: See also
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Per-Entity Wildcard Loading Strategies](#orm-queryguide-relationship-per-entity-wildcard)
    - illustrates an example where direct use of [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    may be useful'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[每个实体通配符加载策略](#orm-queryguide-relationship-per-entity-wildcard) - 演示了直接使用[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")可能有用的一个示例'
- en: '**Members**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[contains_eager()](#sqlalchemy.orm.Load.contains_eager), [defaultload()](#sqlalchemy.orm.Load.defaultload),
    [defer()](#sqlalchemy.orm.Load.defer), [get_children()](#sqlalchemy.orm.Load.get_children),
    [immediateload()](#sqlalchemy.orm.Load.immediateload), [inherit_cache](#sqlalchemy.orm.Load.inherit_cache),
    [joinedload()](#sqlalchemy.orm.Load.joinedload), [lazyload()](#sqlalchemy.orm.Load.lazyload),
    [load_only()](#sqlalchemy.orm.Load.load_only), [noload()](#sqlalchemy.orm.Load.noload),
    [options()](#sqlalchemy.orm.Load.options), [process_compile_state()](#sqlalchemy.orm.Load.process_compile_state),
    [process_compile_state_replaced_entities()](#sqlalchemy.orm.Load.process_compile_state_replaced_entities),
    [propagate_to_loaders](#sqlalchemy.orm.Load.propagate_to_loaders), [raiseload()](#sqlalchemy.orm.Load.raiseload),
    [selectin_polymorphic()](#sqlalchemy.orm.Load.selectin_polymorphic), [selectinload()](#sqlalchemy.orm.Load.selectinload),
    [subqueryload()](#sqlalchemy.orm.Load.subqueryload), [undefer()](#sqlalchemy.orm.Load.undefer),
    [undefer_group()](#sqlalchemy.orm.Load.undefer_group), [with_expression()](#sqlalchemy.orm.Load.with_expression)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[contains_eager()](#sqlalchemy.orm.Load.contains_eager)，[defaultload()](#sqlalchemy.orm.Load.defaultload)，[defer()](#sqlalchemy.orm.Load.defer)，[get_children()](#sqlalchemy.orm.Load.get_children)，[immediateload()](#sqlalchemy.orm.Load.immediateload)，[inherit_cache](#sqlalchemy.orm.Load.inherit_cache)，[joinedload()](#sqlalchemy.orm.Load.joinedload)，[lazyload()](#sqlalchemy.orm.Load.lazyload)，[load_only()](#sqlalchemy.orm.Load.load_only)，[noload()](#sqlalchemy.orm.Load.noload)，[options()](#sqlalchemy.orm.Load.options)，[process_compile_state()](#sqlalchemy.orm.Load.process_compile_state)，[process_compile_state_replaced_entities()](#sqlalchemy.orm.Load.process_compile_state_replaced_entities)，[propagate_to_loaders](#sqlalchemy.orm.Load.propagate_to_loaders)，[raiseload()](#sqlalchemy.orm.Load.raiseload)，[selectin_polymorphic()](#sqlalchemy.orm.Load.selectin_polymorphic)，[selectinload()](#sqlalchemy.orm.Load.selectinload)，[subqueryload()](#sqlalchemy.orm.Load.subqueryload)，[undefer()](#sqlalchemy.orm.Load.undefer)，[undefer_group()](#sqlalchemy.orm.Load.undefer_group)，[with_expression()](#sqlalchemy.orm.Load.with_expression)'
- en: '**Class signature**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") (`sqlalchemy.orm.strategy_options._AbstractLoad`)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.orm.Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") (`sqlalchemy.orm.strategy_options._AbstractLoad`)
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.contains_eager`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.contains_eager` *方法的*
    `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    option applied.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个应用了[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")选项的新[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    for usage examples.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有关用法示例，请参见[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")。
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.defaultload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.defaultload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option applied.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个应用了[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")选项的新[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    for usage examples.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关用法示例，请参见[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")。
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.defer`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.defer` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") option
    applied.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个应用了[`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")选项的新[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") for
    usage examples.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关用法示例，请参见[`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")。
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*inherited from the* `HasTraverseInternals.get_children()` *method of* `HasTraverseInternals`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `HasTraverseInternals.get_children()` *方法的* `HasTraverseInternals`'
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此`HasTraverseInternals`的直接子`HasTraverseInternals`元素。
- en: This is used for visit traversal.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问遍历。
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**kw可能包含更改返回集合的标志，例如返回子集以减少更大的遍历，或者返回来自不同上下文的子项（例如模式级集合而不是子句级集合）。'
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.immediateload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.immediateload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    option applied.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")选项应用于生成新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    for usage examples.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")以获取用法示例。
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*inherited from the* `HasCacheKey.inherit_cache` *attribute of* [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey")'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey")的`HasCacheKey.inherit_cache` *属性*'
- en: Indicate if this [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 指示此[`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey")实例是否应使用其直接超类使用的缓存键生成方案。
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性默认为`None`，表示构造尚未考虑是否适合参与缓存；这在功能上等同于将值设置为`False`，只是还会发出警告。
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与对象对应的SQL不基于本类的本地属性而是基于其超类，则可以在特定类上将此标志设置为`True`。
- en: See also
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Enabling Caching Support for Custom Constructs](../../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[为自定义构造启用缓存支持](../../core/compiler.html#compilerext-caching) - 为第三方或用户定义的SQL构造设置[`HasCacheKey.inherit_cache`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache")属性的一般指南。'
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.joinedload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.joinedload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") option
    applied.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")选项应用于生成新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    for usage examples.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")以获取用法示例。
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.lazyload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.lazyload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") option
    applied.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")选项应用于生成新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") for usage
    examples.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")以获取用法示例。
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.load_only`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.load_only` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    option applied.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已应用了 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    选项的新 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象。
- en: See [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    for usage examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用示例，请参见 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")。
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.noload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.noload` 方法 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") option applied.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已应用了 [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") 选项的新 [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") 对象。
- en: See [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") for usage examples.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用示例，请参见 [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")。
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Apply a series of options as sub-options to this [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列选项应用为此 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象的子选项。
- en: 'E.g.:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Parameters:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '***opts** – A series of loader option objects (ultimately [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") objects) which should be applied to the path specified
    by this [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '***opts** – 应用于此 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象指定路径的一系列加载器选项对象（最终为
    [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象）。'
- en: New in version 1.3.6.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3.6 新增。
- en: See also
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")'
- en: '[Specifying Sub-Options with Load.options()](#orm-queryguide-relationship-sub-options)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Load.options() 指定子选项](#orm-queryguide-relationship-sub-options)'
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state`
    方法 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Apply a modification to a given `ORMCompileState`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的 `ORMCompileState` 应用修改。
- en: This method is part of the implementation of a particular `CompileStateOption`
    and is only invoked internally when an ORM query is compiled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是特定 `CompileStateOption` 实现的一部分，并且仅在编译 ORM 查询时内部调用。
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state_replaced_entities`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state_replaced_entities`
    方法 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Apply a modification to a given `ORMCompileState`, given entities that were
    replaced by with_only_columns() or with_entities().
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的 `ORMCompileState` 应用修改，给定了由 with_only_columns() 或 with_entities() 替换的实体。
- en: This method is part of the implementation of a particular `CompileStateOption`
    and is only invoked internally when an ORM query is compiled.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是特定 `CompileStateOption` 实现的一部分，并且仅在编译 ORM 查询时内部调用。
- en: New in version 1.4.19.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.4.19 新增。
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.propagate_to_loaders`
    *attribute of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.propagate_to_loaders`
    的属性 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: if True, indicate this option should be carried along to “secondary” SELECT
    statements that occur for relationship lazy loaders as well as attribute load
    / refresh operations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为 True，则指示此选项应该随着“次要”SELECT语句一起传递，这些语句会出现在关系惰性加载器以及属性加载/刷新操作中。
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.raiseload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.raiseload` 方法 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option
    applied.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已应用了 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")
    选项的新 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象。
- en: See [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") for
    usage examples.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用示例，请参见 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")。
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.selectin_polymorphic`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.selectin_polymorphic`
    方法 `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") option applied.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") 选项。
- en: See [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") for usage examples.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") 以获取使用示例。
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.selectinload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.selectinload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    option applied.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 选项。
- en: See [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    for usage examples.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    以获取使用示例。
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.subqueryload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.subqueryload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    option applied.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") 选项。
- en: See [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    for usage examples.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    以获取使用示例。
- en: '[PRE70]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    option applied.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`undefer()`](columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") 选项。
- en: See [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    for usage examples.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    以获取使用示例。
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer_group`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer_group` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")
    option applied.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group") 选项。
- en: See [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")
    for usage examples.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")
    以获取使用示例。
- en: '[PRE72]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.with_expression`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.with_expression` *方法的*
    `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    option applied.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 对象，并应用 [`with_expression()`](columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 选项。
- en: See [`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    for usage examples.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    以获取使用示例。
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Indicate that the given relationship attribute should remain unloaded.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 指示给定的关系属性应保持未加载状态。
- en: The relationship attribute will return `None` when accessed without producing
    any loading effect.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问关系属性而不产生任何加载效果时，关系属性将返回 `None`。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，并支持方法链式和独立操作。
- en: '[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") applies to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") attributes only.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") 仅适用于 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 属性。'
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Setting this loading strategy as the default strategy for a relationship using
    the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter may cause issues with flushes, such if
    a delete operation needs to load related objects and instead `None` was returned.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将此加载策略设置为使用 [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 参数的默认策略可能会导致刷新时出现问题，比如删除操作需要加载相关对象，而返回的却是 `None`。
- en: See also
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[PRE74]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Indicate that the given attribute should raise an error if accessed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 表示如果访问将引发错误的给定属性。
- en: A relationship attribute configured with [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") will raise an [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") upon access. The typical way this is useful
    is when an application is attempting to ensure that all relationship attributes
    that are accessed in a particular context would have been already loaded via eager
    loading. Instead of having to read through SQL logs to ensure lazy loads aren’t
    occurring, this strategy will cause them to raise immediately.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 配置的关系属性在访问时会引发
    [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")。此方法通常有用的方式是，当应用程序试图确保在特定上下文中访问的所有关系属性都已通过激进加载加载时。而不是必须阅读
    SQL 日志以确保不发生懒加载，此策略将立即导致它们引发。
- en: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") applies
    to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    attributes only. In order to apply raise-on-SQL behavior to a column-based attribute,
    use the [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") parameter on the [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") loader option.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 仅适用于
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    属性。要将 raise-on-SQL 行为应用于基于列的属性，请在 [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 加载选项的 [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") 参数上使用。'
- en: 'Parameters:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**sql_only** – if True, raise only if the lazy load would emit SQL, but not
    if it is only checking the identity map, or determining that the related value
    should just be None due to missing keys. When False, the strategy will raise for
    all varieties of relationship loading.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**sql_only** – 如果为 True，则仅在懒加载将发出 SQL 时引发，但如果仅检查标识映射或确定由于缺少键而相关值应为 None，则不会引发。当为
    False 时，该策略将引发所有类型的关系加载。'
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，并支持方法链和独立操作。
- en: See also
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Preventing unwanted lazy loads using raiseload](#prevent-lazy-with-raiseload)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 避免不必要的懒加载](#prevent-lazy-with-raiseload)'
- en: '[Using raiseload to prevent deferred column loads](columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 避免延迟列加载](columns.html#orm-queryguide-deferred-raiseload)'
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Indicate that the given attribute should be loaded using SELECT IN eager loading.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定属性应使用 SELECT IN 激进加载。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，并支持方法链和独立操作。
- en: 'examples:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Parameters:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**recursion_depth** –'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**recursion_depth** –'
- en: optional int; when set to a positive integer in conjunction with a self-referential
    relationship, indicates “selectin” loading will continue that many levels deep
    automatically until no items are found.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 可选整数；与自引用关系结合设置为正整数时，指示“选择加载”将自动继续加载到没有找到项目为止的那么多级。
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") option currently supports only self-referential
    relationships. There is not yet an option to automatically traverse recursive
    structures with more than one relationship involved.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") 选项目前仅支持自引用关系。目前还没有自动遍历涉及多个关系的递归结构的选项。'
- en: Additionally, the [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") parameter is new and experimental and should be
    treated as “alpha” status for the 2.0 series.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") 参数是新的实验性参数，应该在 2.0 系列中视为“alpha”状态。
- en: 'New in version 2.0: added [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload")'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本新增：添加了[`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload")
- en: See also
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Select IN loading](#selectin-eager-loading)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](#selectin-eager-loading)'
- en: '[PRE77]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Indicate that the given attribute should be loaded using subquery eager loading.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应使用子查询急加载加载给定属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: 'examples:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE78]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: See also
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Subquery Eager Loading](#subquery-eager-loading)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[子查询急加载](#subquery-eager-loading)'
- en: Summary of Relationship Loading Styles
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系加载样式总结
- en: 'The primary forms of relationship loading are:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 关系加载的主要形式包括：
- en: '**lazy loading** - available via `lazy=''select''` or the [`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option, this is the form of loading that emits a SELECT
    statement at attribute access time to lazily load a related reference on a single
    object at a time. Lazy loading is the **default loading style** for all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs that don’t otherwise indicate the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option. Lazy loading is detailed at [Lazy Loading](#lazy-loading).'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟加载** - 通过`lazy=''select''`或[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")
    选项可用，这是在属性访问时发出 SELECT 语句以延迟加载单个对象上的相关引用的加载形式。延迟加载是所有未指示[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 选项的所有[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的**默认加载样式**。延迟加载详细信息请参阅[延迟加载](#lazy-loading)。'
- en: '**select IN loading** - available via `lazy=''selectin''` or the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") option, this form of loading emits a second (or
    more) SELECT statement which assembles the primary key identifiers of the parent
    objects into an IN clause, so that all members of related collections / scalar
    references are loaded at once by primary key. Select IN loading is detailed at
    [Select IN loading](#selectin-eager-loading).'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择 IN 加载** - 通过`lazy=''selectin''`或[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 选项可用，此加载形式发出第二个（或更多）SELECT 语句，将父对象的主键标识符组装成一个 IN
    子句，以便通过主键一次加载所有相关集合/标量引用的成员。选择 IN 加载详细信息请参阅[选择 IN 加载](#selectin-eager-loading)。'
- en: '**joined loading** - available via `lazy=''joined''` or the [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option, this form of loading applies a JOIN to the
    given SELECT statement so that related rows are loaded in the same result set.
    Joined eager loading is detailed at [Joined Eager Loading](#joined-eager-loading).'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接加载** - 通过`lazy=''joined''`或[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 选项可用，此加载形式将 JOIN 应用于给定的 SELECT 语句，以便相关行在同一结果集中加载。连接急加载详细信息请参阅[连接急加载](#joined-eager-loading)。'
- en: '**raise loading** - available via `lazy=''raise''`, `lazy=''raise_on_sql''`,
    or the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option,
    this form of loading is triggered at the same time a lazy load would normally
    occur, except it raises an ORM exception in order to guard against the application
    making unwanted lazy loads. An introduction to raise loading is at [Preventing
    unwanted lazy loads using raiseload](#prevent-lazy-with-raiseload).'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出加载** - 可通过`lazy=''raise''`、`lazy=''raise_on_sql''`或[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项使用，这种加载方式在通常发生惰性加载的同时触发，但会引发ORM异常，以防止应用程序进行不必要的惰性加载。关于抛出加载的介绍请参阅[使用raiseload防止不必要的惰性加载](#prevent-lazy-with-raiseload)。'
- en: '**subquery loading** - available via `lazy=''subquery''` or the [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") option, this form of loading emits a second SELECT
    statement which re-states the original query embedded inside of a subquery, then
    JOINs that subquery to the related table to be loaded to load all members of related
    collections / scalar references at once. Subquery eager loading is detailed at
    [Subquery Eager Loading](#subquery-eager-loading).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子查询加载** - 可通过`lazy=''subquery''`或[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")选项使用，这种加载方式会发出第二个SELECT语句，该语句重新陈述原始查询嵌入到子查询中，然后将该子查询与相关表进行JOIN，以一次加载所有相关集合/标量引用的成员。子查询急切加载的详细信息请参阅[子查询急切加载](#subquery-eager-loading)。'
- en: '**write only loading** - available via `lazy=''write_only''`, or by annotating
    the left side of the [`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") object using the [`WriteOnlyMapped`](../large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation. This collection-only loader style
    produces an alternative attribute instrumentation that never implicitly loads
    records from the database, instead only allowing [`WriteOnlyCollection.add()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add"), [`WriteOnlyCollection.add_all()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") and [`WriteOnlyCollection.remove()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") methods. Querying the collection
    is performed by invoking a SELECT statement which is constructed using the [`WriteOnlyCollection.select()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method. Write only loading is discussed
    at [Write Only Relationships](../large_collections.html#write-only-relationship).'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅写加载** - 可通过`lazy=''write_only''`使用，或者通过使用[`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship")对象的左侧进行注释，并使用[`WriteOnlyMapped`](../large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped")注解。这种仅限集合加载样式会产生一种替代的属性仪器，从不从数据库隐式加载记录，而是仅允许[`WriteOnlyCollection.add()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add")、[`WriteOnlyCollection.add_all()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all")和[`WriteOnlyCollection.remove()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove")方法。通过调用使用[`WriteOnlyCollection.select()`](../large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select")方法构造的SELECT语句来查询集合。关于仅写加载的讨论请参阅[仅写关系](../large_collections.html#write-only-relationship)。'
- en: '**dynamic loading** - available via `lazy=''dynamic''`, or by annotating the
    left side of the [`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") object using the [`DynamicMapped`](../large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation. This is a legacy collection-only loader
    style which produces a [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object when the collection is accessed, allowing custom SQL to be emitted against
    the collection’s contents. However, dynamic loaders will implicitly iterate the
    underlying collection in various circumstances which makes them less useful for
    managing truly large collections. Dynamic loaders are superseded by [“write only”](../large_collections.html#write-only-relationship)
    collections, which will prevent the underlying collection from being implicitly
    loaded under any circumstances. Dynamic loaders are discussed at [Dynamic Relationship
    Loaders](../large_collections.html#dynamic-relationship).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态加载** - 通过`lazy=''dynamic''`可用，或者通过使用[`DynamicMapped`](../large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped")注释来注释[`Relationship`](../internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship")对象的左侧。这是一种传统的仅集合加载器样式，当访问集合时会生成一个[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象，允许针对集合内容发出自定义SQL。然而，动态加载器在各种情况下会隐式迭代底层集合，这使得它们对于管理真正大型集合不太有用。动态加载器被[“仅写入”](../large_collections.html#write-only-relationship)集合取代，这将阻止在任何情况下隐式加载底层集合。动态加载器在[动态关系加载器](../large_collections.html#dynamic-relationship)中讨论。'
- en: '## Configuring Loader Strategies at Mapping Time'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在映射时间配置加载策略'
- en: The loader strategy for a particular relationship can be configured at mapping
    time to take place in all cases where an object of the mapped type is loaded,
    in the absence of any query-level options that modify it. This is configured using
    the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); common values for this parameter include `select`,
    `selectin` and `joined`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 特定关系的加载策略可以在映射时间配置，以在加载映射类型的对象的所有情况下发生，没有任何修改它的查询级选项的情况下。这是使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数进行配置的；该参数的常见值包括`select`、`selectin`和`joined`。
- en: 'The example below illustrates the relationship example at [One To Many](../basic_relationships.html#relationship-patterns-o2m),
    configuring the `Parent.children` relationship to use [Select IN loading](#selectin-eager-loading)
    when a SELECT statement for `Parent` objects is emitted:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了在[一对多](../basic_relationships.html#relationship-patterns-o2m)关系示例中，配置`Parent.children`关系以在发出`Parent`对象的SELECT语句时使用[Select
    IN loading](#selectin-eager-loading)：
- en: '[PRE79]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Above, whenever a collection of `Parent` objects are loaded, each `Parent` will
    also have its `children` collection populated, using the `"selectin"` loader strategy
    that emits a second query.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，每当加载一组`Parent`对象时，每个`Parent`对象的`children`集合也会被填充，使用“selectin”加载策略会发出第二个查询。
- en: The default value of the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") argument is `"select"`, which indicates [Lazy Loading](#lazy-loading).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数的默认值是`"select"`，表示[懒加载](#lazy-loading)。'
- en: '## Relationship Loading with Loader Options'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用加载器选项加载关系'
- en: 'The other, and possibly more common way to configure loading strategies is
    to set them up on a per-query basis against specific attributes using the [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method. Very detailed control over
    relationship loading is available using loader options; the most common are [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") and [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload").
    The option accepts a class-bound attribute referring to the specific class/attribute
    that should be targeted:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 配置加载策略的另一种，可能更常见的方式是针对特定属性在每个查询上设置它们，使用 [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") 方法。使用加载器选项可以对关系加载进行非常详细的控制；最常见的是 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    和 [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")。该选项接受一个类绑定的属性，引用应该被定位的特定类/属性：
- en: '[PRE80]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The loader options can also be “chained” using **method chaining** to specify
    how loading should occur further levels deep:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器选项也可以使用 **方法链** 进行“链接”，以指定加载应如何进行更深层次的操作：
- en: '[PRE81]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Chained loader options can be applied against a “lazy” loaded collection. This
    means that when a collection or association is lazily loaded upon access, the
    specified option will then take effect:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将链接的加载器选项应用于“惰性”加载的集合。这意味着当在访问时惰性加载集合或关联时，指定的选项将立即生效：
- en: '[PRE82]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Above, the query will return `Parent` objects without the `children` collections
    loaded. When the `children` collection on a particular `Parent` object is first
    accessed, it will lazy load the related objects, but additionally apply eager
    loading to the `subelements` collection on each member of `children`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询将返回未加载 `Parent` 对象的 `children` 集合。当首次访问特定 `Parent` 对象上的 `children` 集合时，它将惰性加载相关对象，但还将对
    `children` 中的每个成员的 `subelements` 集合应用急切加载。
- en: '### Adding Criteria to loader options'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '### 向加载器选项添加条件'
- en: 'The relationship attributes used to indicate loader options include the ability
    to add additional filtering criteria to the ON clause of the join that’s created,
    or to the WHERE criteria involved, depending on the loader strategy. This can
    be achieved using the [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method which will pass through an option
    such that loaded results are limited to the given filter criteria:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指示加载器选项的关系属性包括向创建的联接的 ON 子句或涉及的 WHERE 条件添加额外的筛选条件的能力，具体取决于加载器策略。这可以通过使用 [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") 方法来实现，该方法将通过一个选项，使加载的结果限制为给定的筛选条件：
- en: '[PRE83]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When using limiting criteria, if a particular collection is already loaded
    it won’t be refreshed; to ensure the new criteria takes place, apply the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用限制条件时，如果特定集合已加载，则不会刷新；为了确保新条件生效，请应用 [Populate Existing](api.html#orm-queryguide-populate-existing)
    执行选项：
- en: '[PRE84]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In order to add filtering criteria to all occurrences of an entity throughout
    a query, regardless of loader strategy or where it occurs in the loading process,
    see the [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") function.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对查询中的所有实体的所有出现都添加筛选条件，无论加载策略如何或它在加载过程中的位置如何，请参阅 [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 函数。
- en: 'New in version 1.4.  ### Specifying Sub-Options with Load.options()'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4 特性。### 使用 Load.options() 指定子选项
- en: 'Using method chaining, the loader style of each link in the path is explicitly
    stated. To navigate along a path without changing the existing loader style of
    a particular attribute, the [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    method/function may be used:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链，显式声明路径中每个链接的加载器样式。要沿着路径导航而不更改特定属性的现有加载器样式，可以使用 [`defaultload()`](#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") 方法/函数：
- en: '[PRE85]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'A similar approach can be used to specify multiple sub-options at once, using
    the [`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    method:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    方法一次指定多个子选项的类似方法：
- en: '[PRE86]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See also
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Using load_only() on related objects and collections](columns.html#orm-queryguide-load-only-related)
    - illustrates examples of combining relationship and column-oriented loader options.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[在相关对象和集合上使用 `load_only()`](columns.html#orm-queryguide-load-only-related)
    - 举例说明了如何结合关系和基于列的加载器选项。'
- en: Note
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The loader options applied to an object’s lazy-loaded collections are **“sticky”**
    to specific object instances, meaning they will persist upon collections loaded
    by that specific object for as long as it exists in memory. For example, given
    the previous example:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于对象的惰性加载集合的加载器选项对于特定对象实例是 **“粘性的”**，这意味着它们将在内存中存在的时间内持续存在于由该特定对象加载的集合上。例如，考虑到上一个例子：
- en: '[PRE87]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'if the `children` collection on a particular `Parent` object loaded by the
    above query is expired (such as when a [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s transaction is committed or rolled back, or
    [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") is used), when the `Parent.children` collection
    is next accessed in order to re-load it, the `Child.subelements` collection will
    again be loaded using subquery eager loading. This stays the case even if the
    above `Parent` object is accessed from a subsequent query that specifies a different
    set of options. To change the options on an existing object without expunging
    it and re-loading, they must be set explicitly in conjunction using the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述查询加载的特定 `Parent` 对象上的 `children` 集合已过期（例如当 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的事务提交或回滚时，或者使用了 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")），当下次访问 `Parent.children` 集合以重新加载时，`Child.subelements`
    集合将再次使用子查询急加载。即使上述 `Parent` 对象是从指定了不同选项集的后续查询中访问的，情况仍然如此。要在不清除并重新加载现有对象的情况下更改选项，必须使用
    [Populate Existing](api.html#orm-queryguide-populate-existing) 执行选项显式设置它们：
- en: '[PRE88]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If the objects loaded above are fully cleared from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), such as due to garbage collection or that [`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") were used, the “sticky” options will also
    be gone and the newly created objects will make use of new options if loaded again.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面加载的对象被完全从 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中清除，例如由于垃圾回收或使用了 [`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")，则 “粘性” 选项也将消失，并且新创建的对象将在再次加载时使用新选项。
- en: 'A future SQLAlchemy release may add more alternatives to manipulating the loader
    options on already-loaded objects.  ### Adding Criteria to loader options'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 版本可能会增加更多操作已加载对象的加载器选项的替代方法。### 向加载器选项添加条件
- en: 'The relationship attributes used to indicate loader options include the ability
    to add additional filtering criteria to the ON clause of the join that’s created,
    or to the WHERE criteria involved, depending on the loader strategy. This can
    be achieved using the [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method which will pass through an option
    such that loaded results are limited to the given filter criteria:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指示加载器选项的关系属性包括在创建的联接的 ON 子句或涉及的 WHERE 条件中添加附加过滤条件的能力，具体取决于加载器策略。这可以通过使用 [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") 方法来实现，该方法将通过选项传递，从而将加载的结果限制为给定的过滤条件：
- en: '[PRE89]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When using limiting criteria, if a particular collection is already loaded
    it won’t be refreshed; to ensure the new criteria takes place, apply the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用限制条件时，如果特定集合已经加载，它将不会被刷新；为了确保新的条件生效，应用 [Populate Existing](api.html#orm-queryguide-populate-existing)
    执行选项：
- en: '[PRE90]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In order to add filtering criteria to all occurrences of an entity throughout
    a query, regardless of loader strategy or where it occurs in the loading process,
    see the [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") function.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向查询中的实体的所有出现添加过滤条件，无论加载策略如何或出现在加载过程中的位置如何，请参阅 [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 函数。
- en: New in version 1.4.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 版本中的新功能。
- en: '### Specifying Sub-Options with Load.options()'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 Load.options() 指定子选项'
- en: 'Using method chaining, the loader style of each link in the path is explicitly
    stated. To navigate along a path without changing the existing loader style of
    a particular attribute, the [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    method/function may be used:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链时，路径中每个链接的加载器样式都会明确说明。要沿着路径导航而不更改特定属性的现有加载器样式，可以使用[`defaultload()`](#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")方法/函数：
- en: '[PRE91]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'A similar approach can be used to specify multiple sub-options at once, using
    the [`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    method:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")方法一次性指定多个子选项的类似方法：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See also
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using load_only() on related objects and collections](columns.html#orm-queryguide-load-only-related)
    - illustrates examples of combining relationship and column-oriented loader options.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[在相关对象和集合上使用load_only()](columns.html#orm-queryguide-load-only-related) - 展示了结合关系和基于列的加载器选项的示例。'
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The loader options applied to an object’s lazy-loaded collections are **“sticky”**
    to specific object instances, meaning they will persist upon collections loaded
    by that specific object for as long as it exists in memory. For example, given
    the previous example:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的延迟加载集合上应用的加载器选项是**“粘性”的**，即它们将持续存在于内存中的特定对象实例上加载的集合上。例如，给定上面的例子：
- en: '[PRE93]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'if the `children` collection on a particular `Parent` object loaded by the
    above query is expired (such as when a [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object’s transaction is committed or rolled back, or
    [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") is used), when the `Parent.children` collection
    is next accessed in order to re-load it, the `Child.subelements` collection will
    again be loaded using subquery eager loading. This stays the case even if the
    above `Parent` object is accessed from a subsequent query that specifies a different
    set of options. To change the options on an existing object without expunging
    it and re-loading, they must be set explicitly in conjunction using the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述查询加载的特定`Parent`对象上的`children`集合过期（例如，当[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的事务被提交或回滚，或使用[`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")时），当下次访问`Parent.children`集合以重新加载时，`Child.subelements`集合将再次使用子查询的急加载。即使从指定了不同选项集的后续查询中访问了上述`Parent`对象，这种情况也会保持不变。要在不清除并重新加载对象的情况下更改现有对象上的选项，必须结合使用[填充现有](api.html#orm-queryguide-populate-existing)执行选项显式设置它们：
- en: '[PRE94]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If the objects loaded above are fully cleared from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), such as due to garbage collection or that [`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") were used, the “sticky” options will also
    be gone and the newly created objects will make use of new options if loaded again.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面加载的对象完全从[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中清除，例如由于垃圾回收或使用[`Session.expunge_all()`](../session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")，那么“粘性”选项也将消失，如果再次加载，则新创建的对象将使用新选项。
- en: A future SQLAlchemy release may add more alternatives to manipulating the loader
    options on already-loaded objects.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的SQLAlchemy版本可能会添加更多的选择来操作已加载对象的加载器选项。
- en: '## Lazy Loading'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '## 延迟加载'
- en: 'By default, all inter-object relationships are **lazy loading**. The scalar
    or collection attribute associated with a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") contains a trigger which fires the first time the
    attribute is accessed. This trigger typically issues a SQL call at the point of
    access in order to load the related object or objects:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有对象间的关系都是**延迟加载**的。与[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")相关的标量或集合属性包含一个触发器，第一次访问属性时触发。这个触发器通常在访问点发出SQL调用，以加载相关的对象：
- en: '[PRE95]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The one case where SQL is not emitted is for a simple many-to-one relationship,
    when the related object can be identified by its primary key alone and that object
    is already present in the current [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For this reason, while lazy loading can be expensive
    for related collections, in the case that one is loading lots of objects with
    simple many-to-ones against a relatively small set of possible target objects,
    lazy loading may be able to refer to these objects locally without emitting as
    many SELECT statements as there are parent objects.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一个不发出 SQL 的情况是简单的多对一关系，当相关对象仅可通过其主键标识且该对象已经存在于当前 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中时。因此，尽管延迟加载对于相关集合可能很昂贵，在加载许多对象与相对较小的可能目标对象集合相比，如果一个对象加载了很多对象，则可能可以在本地引用这些对象，而不像有多少父对象就发出多少
    SELECT 语句。
- en: This default behavior of “load upon attribute access” is known as “lazy” or
    “select” loading - the name “select” because a “SELECT” statement is typically
    emitted when the attribute is first accessed.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: “在属性访问时加载”的默认行为称为“延迟”或“选择”加载 - 名称“选择”是因为通常在首次访问属性时会发出“SELECT”语句。
- en: 'Lazy loading can be enabled for a given attribute that is normally configured
    in some other way using the [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")
    loader option:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") 加载器选项为通常以其他方式配置的给定属性启用延迟加载：
- en: '[PRE96]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '### Preventing unwanted lazy loads using raiseload'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 raiseload 防止不必要的延迟加载'
- en: 'The [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") strategy
    produces an effect that is one of the most common issues referred to in object
    relational mapping; the [N plus one problem](../../glossary.html#term-N-plus-one-problem),
    which states that for any N objects loaded, accessing their lazy-loaded attributes
    means there will be N+1 SELECT statements emitted. In SQLAlchemy, the usual mitigation
    for the N+1 problem is to make use of its very capable eager load system. However,
    eager loading requires that the attributes which are to be loaded be specified
    with the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") up front. The problem of code that may access
    other attributes that were not eagerly loaded, where lazy loading is not desired,
    may be addressed using the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")
    strategy; this loader strategy replaces the behavior of lazy loading with an informative
    error being raised:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") 策略产生的效果是对象关系映射中最常见的问题之一；[N
    加一问题](../../glossary.html#term-N-plus-one-problem)，即对于加载的任何 N 个对象，访问它们的延迟加载属性意味着将会发出
    N+1 个 SELECT 语句。在 SQLAlchemy 中，解决 N 加一问题的常规方法是利用其非常强大的急切加载系统。然而，急切加载要求提前使用 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 指定要加载的属性。对于可能访问未急切加载的其他属性的代码，不希望进行延迟加载，可以使用
    [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 策略来解决；此加载器策略将延迟加载的行为替换为引发信息性错误：'
- en: '[PRE97]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Above, a `User` object loaded from the above query will not have the `.addresses`
    collection loaded; if some code later on attempts to access this attribute, an
    ORM exception is raised.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，从上述查询加载的 `User` 对象不会加载 `.addresses` 集合；如果稍后的某些代码尝试访问此属性，则会引发 ORM 异常。
- en: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") may be
    used with a so-called “wildcard” specifier to indicate that all relationships
    should use this strategy. For example, to set up only one attribute as eager loading,
    and all the rest as raise:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 可以与所谓的“通配符”说明符一起使用，以指示所有关系应使用此策略。例如，只设置一个属性为急切加载，而所有其他属性都为提升：'
- en: '[PRE98]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The above wildcard will apply to **all** relationships not just on `Order`
    besides `items`, but all those on the `Item` objects as well. To set up [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") for only the `Order` objects, specify a full path
    with [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load"):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 上述通配符将适用于**所有**关系，不仅限于除 `items` 外的 `Order`，还包括 `Item` 对象上的所有关系。要为仅 `Order` 对象设置
    [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")，请使用 [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") 指定完整路径：
- en: '[PRE99]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Conversely, to set up the raise for just the `Item` objects:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要为 `Item` 对象设置提升：
- en: '[PRE100]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option
    applies only to relationship attributes. For column-oriented attributes, the [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") option supports the [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") option which works in the same way.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 选项仅适用于关系属性。对于面向列的属性，[`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 选项支持 [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") 选项，其工作方式相同。'
- en: Tip
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The “raiseload” strategies **do not apply** within the [unit of work](../../glossary.html#term-unit-of-work)
    flush process. That means if the [`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") process needs to load a collection in order to
    finish its work, it will do so while bypassing any [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") directives.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload”策略**不适用**于[工作单元](../../glossary.html#term-unit-of-work)刷新过程中。这意味着如果
    [`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    过程需要加载集合以完成其工作，它将在绕过任何 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")
    指令的情况下执行此操作。
- en: See also
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Wildcard Loading Strategies](#wildcard-loader-strategies)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[通配符加载策略](#wildcard-loader-strategies)'
- en: '[Using raiseload to prevent deferred column loads](columns.html#orm-queryguide-deferred-raiseload)  ###
    Preventing unwanted lazy loads using raiseload'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止延迟列加载](columns.html#orm-queryguide-deferred-raiseload)  ###
    使用 raiseload 防止不需要的延迟加载'
- en: 'The [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") strategy
    produces an effect that is one of the most common issues referred to in object
    relational mapping; the [N plus one problem](../../glossary.html#term-N-plus-one-problem),
    which states that for any N objects loaded, accessing their lazy-loaded attributes
    means there will be N+1 SELECT statements emitted. In SQLAlchemy, the usual mitigation
    for the N+1 problem is to make use of its very capable eager load system. However,
    eager loading requires that the attributes which are to be loaded be specified
    with the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") up front. The problem of code that may access
    other attributes that were not eagerly loaded, where lazy loading is not desired,
    may be addressed using the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")
    strategy; this loader strategy replaces the behavior of lazy loading with an informative
    error being raised:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") 策略产生了一个最常见的对象关系映射中提到的问题之一的效果；[N加一问题](../../glossary.html#term-N-plus-one-problem)，它说明对于加载的任何N个对象，访问它们的延迟加载属性意味着会有N+1个SELECT语句被发送。在SQLAlchemy中，对N+1问题的常规缓解方法是利用其非常强大的急切加载系统。然而，急切加载要求在前面指定要加载的属性。对于不希望进行延迟加载的其他属性的代码问题，可以使用
    [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 策略来解决；此加载器策略用具有信息性错误引发替换了延迟加载的行为：'
- en: '[PRE101]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Above, a `User` object loaded from the above query will not have the `.addresses`
    collection loaded; if some code later on attempts to access this attribute, an
    ORM exception is raised.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，从上述查询中加载的`User`对象不会加载`.addresses`集合；如果稍后的一些代码尝试访问此属性，则会引发ORM异常。
- en: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") may be
    used with a so-called “wildcard” specifier to indicate that all relationships
    should use this strategy. For example, to set up only one attribute as eager loading,
    and all the rest as raise:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 与所谓的“通配符”指示符一起使用，以指示所有关系都应使用此策略。例如，要设置仅一个属性作为急切加载，而其他所有属性都作为
    raise：
- en: '[PRE102]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The above wildcard will apply to **all** relationships not just on `Order`
    besides `items`, but all those on the `Item` objects as well. To set up [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") for only the `Order` objects, specify a full path
    with [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load"):'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 上述通配符将适用于**所有**关系，而不仅限于 `Order` 除 `items` 之外，还包括 `Item` 对象上的所有关系。要仅为 `Order`
    对象设置 [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")，请指定带有
    [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 的完整路径：
- en: '[PRE103]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Conversely, to set up the raise for just the `Item` objects:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要仅为 `Item` 对象设置 raise：
- en: '[PRE104]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option
    applies only to relationship attributes. For column-oriented attributes, the [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") option supports the [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") option which works in the same way.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")选项仅适用于关系属性。对于面向列的属性，[`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项支持[`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")选项，其工作方式相同。'
- en: Tip
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The “raiseload” strategies **do not apply** within the [unit of work](../../glossary.html#term-unit-of-work)
    flush process. That means if the [`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") process needs to load a collection in order to
    finish its work, it will do so while bypassing any [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") directives.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload”策略**不适用**于[unit of work](../../glossary.html#term-unit-of-work)提交过程中。这意味着如果[`Session.flush()`](../session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")过程需要加载一个集合以完成其工作，它将通过任何[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")指令绕过这样做。
- en: See also
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Wildcard Loading Strategies](#wildcard-loader-strategies)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[通配符加载策略](#wildcard-loader-strategies)'
- en: '[Using raiseload to prevent deferred column loads](columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止延迟列加载](columns.html#orm-queryguide-deferred-raiseload)'
- en: '## Joined Eager Loading'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '## 连接式急加载'
- en: Joined eager loading is the oldest style of eager loading included with the
    SQLAlchemy ORM. It works by connecting a JOIN (by default a LEFT OUTER join) to
    the SELECT statement emitted, and populates the target scalar/collection from
    the same result set as that of the parent.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 连接式急加载是 SQLAlchemy ORM 包含的最古老的急加载样式。它通过将 JOIN（默认为 LEFT OUTER join）连接到发出的 SELECT
    语句，并从与父级相同的结果集填充目标标量/集合来工作。
- en: 'At the mapping level, this looks like:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射级别，这看起来像是：
- en: '[PRE105]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Joined eager loading is usually applied as an option to a query, rather than
    as a default loading option on the mapping, in particular when used for collections
    rather than many-to-one-references. This is achieved using the [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loader option:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 连接式急加载通常作为查询的选项应用，而不是作为映射的默认加载选项，特别是当用于集合而不是多对一引用时。这通过使用[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")加载器选项来实现：
- en: '[PRE106]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Tip
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When including [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    in reference to a one-to-many or many-to-many collection, the [`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method must be applied to the returned result,
    which will uniquify the incoming rows by primary key that otherwise are multiplied
    out by the join. The ORM will raise an error if this is not present.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到一对多或多对多集合时，包括[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")时，必须对返回的结果应用[`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique")方法，该方法将通过主键使传入的行唯一化，否则会被联接乘以。如果没有这个方法，ORM 将引发错误。
- en: This is not automatic in modern SQLAlchemy, as it changes the behavior of the
    result set to return fewer ORM objects than the statement would normally return
    in terms of number of rows. Therefore SQLAlchemy keeps the use of [`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") explicit, so there’s no ambiguity that the
    returned objects are being uniqified on primary key.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这在现代 SQLAlchemy 中不是自动的，因为它改变了结果集的行为，以返回比语句通常返回的 ORM 对象少的行数。因此，SQLAlchemy 保持了对[`Result.unique()`](../../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique")的使用明确，这样就不会产生返回的对象在主键上的唯一性。
- en: 'The JOIN emitted by default is a LEFT OUTER JOIN, to allow for a lead object
    that does not refer to a related row. For an attribute that is guaranteed to have
    an element, such as a many-to-one reference to a related object where the referencing
    foreign key is NOT NULL, the query can be made more efficient by using an inner
    join; this is available at the mapping level via the [`relationship.innerjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") flag:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下发出的JOIN是一个LEFT OUTER JOIN，以允许引用一个不存在相关行的主对象。对于保证具有元素的属性，例如对一个相关对象的多对一引用，其中引用的外键不为NULL，通过使用内连接可以使查询更有效率；这可以通过映射级别的[`relationship.innerjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship")标志来实现：
- en: '[PRE107]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'At the query option level, via the [`joinedload.innerjoin`](#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") flag:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询选项级别，通过[`joinedload.innerjoin`](#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")标志：
- en: '[PRE108]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The JOIN will right-nest itself when applied in a chain that includes an OUTER
    JOIN:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当在包含OUTER JOIN的链中应用时，JOIN将会右嵌套自身：
- en: '[PRE109]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Tip
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If using database row locking techniques when emitting the SELECT, meaning the
    [`Select.with_for_update()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update
    "sqlalchemy.sql.expression.Select.with_for_update") method is being used to emit
    SELECT..FOR UPDATE, the joined table may be locked as well, depending on the behavior
    of the backend in use. It’s not recommended to use joined eager loading at the
    same time as SELECT..FOR UPDATE for this reason.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在发出SELECT时使用数据库行锁定技术，这意味着使用[`Select.with_for_update()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update
    "sqlalchemy.sql.expression.Select.with_for_update")方法来发出SELECT..FOR UPDATE，那么根据所使用的后端的行为，连接表也可能被锁定。基于这个原因，不建议同时使用联接式急加载和SELECT..FOR
    UPDATE。
- en: '### The Zen of Joined Eager Loading'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '### 联接式急加载的禅意'
- en: Since joined eager loading seems to have many resemblances to the use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), it often produces confusion as to when
    and how it should be used. It is critical to understand the distinction that while
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is used to alter the results of a query,
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") goes
    through great lengths to **not** alter the results of the query, and instead hide
    the effects of the rendered join to only allow for related objects to be present.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联接式急加载似乎与[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的使用有很多相似之处，因此经常会产生何时以及如何使用它的混淆。重要的是要理解这样一个区别，即虽然[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")用于修改查询的结果，但[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")竭尽全力**不**修改查询的结果，而是隐藏渲染联接的效果，以便仅允许相关对象存在。
- en: The philosophy behind loader strategies is that any set of loading schemes can
    be applied to a particular query, and *the results don’t change* - only the number
    of SQL statements required to fully load related objects and collections changes.
    A particular query might start out using all lazy loads. After using it in context,
    it might be revealed that particular attributes or collections are always accessed,
    and that it would be more efficient to change the loader strategy for these. The
    strategy can be changed with no other modifications to the query, the results
    will remain identical, but fewer SQL statements would be emitted. In theory (and
    pretty much in practice), nothing you can do to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would make it load a different set of primary
    or related objects based on a change in loader strategy.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 加载策略背后的哲学是，任何一组加载方案都可以应用于特定的查询，并且*结果不会改变* - 只有用于完全加载相关对象和集合的SQL语句数量会改变。一个特定的查询可能起初使用了所有的延迟加载。在上下文中使用后，可能会发现特定的属性或集合总是被访问，更改这些属性的加载器策略将更有效率。策略可以更改而不影响查询的其他部分，结果将保持不变，但SQL语句数量会减少。理论上（而且在实践中几乎是如此），对[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")所做的任何操作都不会因为加载器策略的改变而使其基于不同的一组主对象或相关对象加载不同的集合。
- en: 'How [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    in particular achieves this result of not impacting entity rows returned in any
    way is that it creates an anonymous alias of the joins it adds to your query,
    so that they can’t be referenced by other parts of the query. For example, the
    query below uses [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to create a LEFT OUTER JOIN from `users` to `addresses`, however the `ORDER BY`
    added against `Address.email_address` is not valid - the `Address` entity is not
    named in the query:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是 [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    如何实现这一结果不以任何方式影响返回的实体行，它创建了查询中添加的连接的匿名别名，以便它们不能被查询的其他部分引用。例如，下面的查询使用 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 创建了从 `users` 到 `addresses` 的 LEFT OUTER JOIN，然而对
    `Address.email_address` 添加的 `ORDER BY` 是无效的 - 查询中没有命名 `Address` 实体：
- en: '[PRE110]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Above, `ORDER BY addresses.email_address` is not valid since `addresses` is
    not in the FROM list. The correct way to load the `User` records and order by
    email address is to use [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`ORDER BY addresses.email_address` 是无效的，因为 `addresses` 不在 FROM 列表中。加载 `User`
    记录并按电子邮件地址排序的正确方法是使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")：
- en: '[PRE111]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The statement above is of course not the same as the previous one, in that
    the columns from `addresses` are not included in the result at all. We can add
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") back
    in, so that there are two joins - one is that which we are ordering on, the other
    is used anonymously to load the contents of the `User.addresses` collection:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上面的语句与之前的语句不同，因为根本没有包含来自 `addresses` 的列在结果中。我们可以添加 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 回来，这样就有了两个连接 - 一个是我们正在排序的连接，另一个是匿名使用的，用于加载 `User.addresses`
    集合的内容：
- en: '[PRE112]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'What we see above is that our usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to supply JOIN clauses we’d like to
    use in subsequent query criterion, whereas our usage of [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") only concerns itself with the loading of the `User.addresses`
    collection, for each `User` in the result. In this case, the two joins most probably
    appear redundant - which they are. If we wanted to use just one JOIN for collection
    loading as well as ordering, we use the [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option, described in [Routing Explicit Joins/Statements
    into Eagerly Loaded Collections](#contains-eager) below. But to see why [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") does what it does, consider if we were **filtering**
    on a particular `Address`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面看到 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 的用法是提供我们希望在后续查询条件中使用的 JOIN 子句，而我们对 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 的用法只关注于为结果中的每个 `User` 加载 `User.addresses` 集合。在这种情况下，这两个连接很可能是多余的
    - 而事实上它们确实是。如果我们只想使用一个 JOIN 来加载集合并排序，我们可以使用 [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 选项，下面描述了 [将明确的 JOIN/语句路由到急切加载的集合](#contains-eager)。但要了解为什么
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") 所做的事情，请考虑如果我们**过滤**某个特定的
    `Address`：
- en: '[PRE113]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Above, we can see that the two JOINs have very different roles. One will match
    exactly one row, that of the join of `User` and `Address` where `Address.email_address=='someaddress@foo.com'`.
    The other LEFT OUTER JOIN will match *all* `Address` rows related to `User`, and
    is only used to populate the `User.addresses` collection, for those `User` objects
    that are returned.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我们可以看到，这两个 JOIN 扮演着非常不同的角色。其中一个将精确匹配一行，即 `User` 和 `Address` 的连接，其中 `Address.email_address=='someaddress@foo.com'`。另一个
    LEFT OUTER JOIN 将匹配与 `User` 相关的*所有* `Address` 行，并且仅用于填充返回的那些 `User` 对象的 `User.addresses`
    集合。
- en: 'By changing the usage of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to another style of loading, we can change how the collection is loaded completely
    independently of SQL used to retrieve the actual `User` rows we want. Below we
    change [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    into [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload"):'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    的使用方式更改为另一种加载方式，我们可以完全独立于用于检索实际所需的 `User` 行的SQL，改变集合的加载方式。以下我们将 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 改为 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")：
- en: '[PRE114]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: When using joined eager loading, if the query contains a modifier that impacts
    the rows returned externally to the joins, such as when using DISTINCT, LIMIT,
    OFFSET or equivalent, the completed statement is first wrapped inside a subquery,
    and the joins used specifically for joined eager loading are applied to the subquery.
    SQLAlchemy’s joined eager loading goes the extra mile, and then ten miles further,
    to absolutely ensure that it does not affect the end result of the query, only
    the way collections and related objects are loaded, no matter what the format
    of the query is.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用连接式贪婪加载时，如果查询包含影响外部连接返回行的修饰符，例如使用 DISTINCT、LIMIT、OFFSET 或等效操作，完成的语句首先被包装在一个子查询中，连接专门用于连接式贪婪加载被应用于子查询。SQLAlchemy
    的连接式贪婪加载额外努力，然后再努力十英里，绝对确保它不会影响查询的最终结果，只影响集合和相关对象的加载方式，无论查询的格式如何。
- en: See also
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)
    - using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")  ###
    The Zen of Joined Eager Loading'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到贪婪加载的集合](#contains-eager) - 使用 [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")  ### 连接式贪婪加载的禅意'
- en: Since joined eager loading seems to have many resemblances to the use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), it often produces confusion as to when
    and how it should be used. It is critical to understand the distinction that while
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is used to alter the results of a query,
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") goes
    through great lengths to **not** alter the results of the query, and instead hide
    the effects of the rendered join to only allow for related objects to be present.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接式贪婪加载似乎与 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 的使用方式有很多相似之处，因此在何时以及如何使用它经常会产生困惑。重要的是要理解，虽然
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 用于更改查询的结果，但 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 却极力避免更改查询的结果，而是隐藏渲染连接的效果，以允许相关对象存在。
- en: The philosophy behind loader strategies is that any set of loading schemes can
    be applied to a particular query, and *the results don’t change* - only the number
    of SQL statements required to fully load related objects and collections changes.
    A particular query might start out using all lazy loads. After using it in context,
    it might be revealed that particular attributes or collections are always accessed,
    and that it would be more efficient to change the loader strategy for these. The
    strategy can be changed with no other modifications to the query, the results
    will remain identical, but fewer SQL statements would be emitted. In theory (and
    pretty much in practice), nothing you can do to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would make it load a different set of primary
    or related objects based on a change in loader strategy.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 装载策略背后的哲学是，任何一组装载方案都可以应用于特定的查询，并且*结果不会改变*——只有完全加载相关对象和集合所需的SQL语句数量会改变。一个特定的查询可能首先使用所有的延迟加载。在上下文中使用后，可能会发现特定属性或集合总是被访问，并且更改这些的加载策略会更有效。该策略可以在不修改查询的其他部分的情况下更改，结果将保持相同，但会发出更少的SQL语句。理论上（实际上基本如此），无论你对
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    做什么修改，都不会使其根据加载策略的变化加载不同的主要或相关对象集合。
- en: 'How [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    in particular achieves this result of not impacting entity rows returned in any
    way is that it creates an anonymous alias of the joins it adds to your query,
    so that they can’t be referenced by other parts of the query. For example, the
    query below uses [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to create a LEFT OUTER JOIN from `users` to `addresses`, however the `ORDER BY`
    added against `Address.email_address` is not valid - the `Address` entity is not
    named in the query:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")来实现不影响返回的实体行的结果，它的特点是创建查询中添加的连接的匿名别名，以便其他查询的部分不能引用它们。例如，下面的查询使用[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")创建了一个从`users`到`addresses`的左外连接，但是针对`Address.email_address`添加的`ORDER
    BY`是无效的 - 查询中未命名`Address`实体：
- en: '[PRE115]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Above, `ORDER BY addresses.email_address` is not valid since `addresses` is
    not in the FROM list. The correct way to load the `User` records and order by
    email address is to use [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 上述中，`ORDER BY addresses.email_address`是无效的，因为`addresses`不在FROM列表中。加载`User`记录并按电子邮件地址排序的正确方法是使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")：
- en: '[PRE116]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The statement above is of course not the same as the previous one, in that
    the columns from `addresses` are not included in the result at all. We can add
    [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") back
    in, so that there are two joins - one is that which we are ordering on, the other
    is used anonymously to load the contents of the `User.addresses` collection:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上面的语句与前面的语句不同，因为根本没有包含来自`addresses`的列在结果中。我们可以重新添加[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，以便有两个连接 - 一个是我们正在排序的连接，另一个是匿名使用的，用于加载`User.addresses`集合的内容：
- en: '[PRE117]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'What we see above is that our usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to supply JOIN clauses we’d like to
    use in subsequent query criterion, whereas our usage of [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") only concerns itself with the loading of the `User.addresses`
    collection, for each `User` in the result. In this case, the two joins most probably
    appear redundant - which they are. If we wanted to use just one JOIN for collection
    loading as well as ordering, we use the [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option, described in [Routing Explicit Joins/Statements
    into Eagerly Loaded Collections](#contains-eager) below. But to see why [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") does what it does, consider if we were **filtering**
    on a particular `Address`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 以上我们看到，我们使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")来提供我们希望在随后的查询条件中使用的JOIN子句，而我们使用[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")只关心加载每个结果中的`User.addresses`集合。在这种情况下，这两个连接很可能是多余的
    - 它们确实是。如果我们只想使用一个JOIN来加载集合并排序，我们可以使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项，下面描述了[将显式的连接/语句路由到急加载的集合](#contains-eager)。但要看看为什么[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")会做它的工作，考虑一下如果我们**过滤**特定的`Address`：
- en: '[PRE118]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Above, we can see that the two JOINs have very different roles. One will match
    exactly one row, that of the join of `User` and `Address` where `Address.email_address=='someaddress@foo.com'`.
    The other LEFT OUTER JOIN will match *all* `Address` rows related to `User`, and
    is only used to populate the `User.addresses` collection, for those `User` objects
    that are returned.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们可以看到这两个JOIN有非常不同的角色。一个将精确匹配一个行，即`User`和`Address`的连接，其中`Address.email_address=='someaddress@foo.com'`。另一个左外连接将匹配与`User`相关的*所有*`Address`行，并且仅用于为返回的`User`对象填充`User.addresses`集合。
- en: 'By changing the usage of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    to another style of loading, we can change how the collection is loaded completely
    independently of SQL used to retrieve the actual `User` rows we want. Below we
    change [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    into [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload"):'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")的使用方式为另一种加载样式，我们可以完全独立于用于检索实际所需`User`行的
    SQL，改变集合的加载方式。以下我们将[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")改为[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")：
- en: '[PRE119]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: When using joined eager loading, if the query contains a modifier that impacts
    the rows returned externally to the joins, such as when using DISTINCT, LIMIT,
    OFFSET or equivalent, the completed statement is first wrapped inside a subquery,
    and the joins used specifically for joined eager loading are applied to the subquery.
    SQLAlchemy’s joined eager loading goes the extra mile, and then ten miles further,
    to absolutely ensure that it does not affect the end result of the query, only
    the way collections and related objects are loaded, no matter what the format
    of the query is.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用连接式急切加载时，如果查询包含影响联接外部返回的行的修饰符，例如使用 DISTINCT、LIMIT、OFFSET 或等效的修饰符，完成的语句首先包装在一个子查询中，并且专门用于连接式急切加载的联接应用于子查询。SQLAlchemy
    的连接式急切加载努力工作，然后再走十英里，绝对确保它不会影响查询的最终结果，只影响加载集合和相关对象的方式，无论查询的格式是什么。
- en: See also
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)
    - using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[将显式联接/语句路由到急切加载的集合](#contains-eager) - 使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
- en: '## Select IN loading'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '## 选择性加载'
- en: In most cases, selectin loading is the most simple and efficient way to eagerly
    load collections of objects. The only scenario in which selectin eager loading
    is not feasible is when the model is using composite primary keys, and the backend
    database does not support tuples with IN, which currently includes SQL Server.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，选择性加载是急切加载对象集合的最简单和最有效的方法。唯一不可行的选择性急切加载的情况是当模型使用复合主键，并且后端数据库不支持具有 IN
    的元组时，这种情况目前包括 SQL Server。
- en: '“Select IN” eager loading is provided using the `"selectin"` argument to [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") or by using the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This style of loading emits a SELECT
    that refers to the primary key values of the parent object, or in the case of
    a many-to-one relationship to the those of the child objects, inside of an IN
    clause, in order to load related associations:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"selectin"`参数或使用[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")加载器选项提供了“选择
    IN”急切加载。这种加载样式发出一个 SELECT，该 SELECT 引用父对象的主键值，或者在一对多关系的情况下引用子对象的主键值，位于 IN 子句中，以加载相关联的关系：
- en: '[PRE120]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Above, the second SELECT refers to `addresses.user_id IN (5, 7)`, where the
    “5” and “7” are the primary key values for the previous two `User` objects loaded;
    after a batch of objects are completely loaded, their primary key values are injected
    into the `IN` clause for the second SELECT. Because the relationship between `User`
    and `Address` has a simple primary join condition and provides that the primary
    key values for `User` can be derived from `Address.user_id`, the statement has
    no joins or subqueries at all.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，第二个 SELECT 引用了`addresses.user_id IN (5, 7)`，其中的“5”和“7”是前两个加载的`User`对象的主键值；在一批对象完全加载后，它们的主键值被注入到第二个
    SELECT 的`IN`子句中。因为`User`和`Address`之间的关系具有简单的主键连接条件，并且提供了`User`的主键值可以从`Address.user_id`派生，所以该语句根本没有联接或子查询。
- en: 'For simple many-to-one loads, a JOIN is also not needed as the foreign key
    value from the parent object is used:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的一对多加载，也不需要 JOIN，因为使用父对象的外键值即可：
- en: '[PRE121]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Tip
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: by “simple” we mean that the [`relationship.primaryjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition expresses an equality comparison between
    the primary key of the “one” side and a straight foreign key of the “many” side,
    without any additional criteria.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: “简单”是指 [`relationship.primaryjoin`](../relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 条件表达了“一”侧的主键和“多”侧的直接外键之间的相等比较，没有任何其他条件。
- en: Select IN loading also supports many-to-many relationships, where it currently
    will JOIN across all three tables to match rows from one side to the other.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 IN 加载还支持多对多的关系，在目前的情况下，它会跨越所有三个表进行 JOIN，以匹配一边到另一边的行。
- en: 'Things to know about this kind of loading include:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种加载方式需要知道的事情包括：
- en: The strategy emits a SELECT for up to 500 parent primary key values at a time,
    as the primary keys are rendered into a large IN expression in the SQL statement.
    Some databases like Oracle have a hard limit on how large an IN expression can
    be, and overall the size of the SQL string shouldn’t be arbitrarily large.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此策略每次会发出一个 SELECT，最多为 500 个父主键值，因为主键被渲染为 SQL 语句中的大型 IN 表达式。一些数据库，如 Oracle，对
    IN 表达式的大小有硬限制，总体上，SQL 字符串的大小不应该是任意大的。
- en: As “selectin” loading relies upon IN, for a mapping with composite primary keys,
    it must use the “tuple” form of IN, which looks like `WHERE (table.column_a, table.column_b)
    IN ((?, ?), (?, ?), (?, ?))`. This syntax is not currently supported on SQL Server
    and for SQLite requires at least version 3.15\. There is no special logic in SQLAlchemy
    to check ahead of time which platforms support this syntax or not; if run against
    a non-supporting platform, the database will return an error immediately. An advantage
    to SQLAlchemy just running the SQL out for it to fail is that if a particular
    database does start supporting this syntax, it will work without any changes to
    SQLAlchemy (as was the case with SQLite).
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于“选择加载”依赖于 IN，对于具有复合主键的映射，它必须使用 IN 的“元组”形式，看起来像 `WHERE (table.column_a, table.column_b)
    IN ((?, ?), (?, ?), (?, ?))`。这种语法目前不受 SQL Server 支持，对于 SQLite，需要至少 3.15 版本。SQLAlchemy
    中没有特殊的逻辑来提前检查哪些平台支持此语法；如果运行在不支持的平台上，数据库将立即返回错误。SQLAlchemy 之所以仅运行 SQL 以使其失败的优点是，如果特定的数据库确实开始支持此语法，则无需对
    SQLAlchemy 进行任何更改（就像 SQLite 的情况一样）。
- en: '## Subquery Eager Loading'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '## 子查询预加载'
- en: Legacy Feature
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 旧特性
- en: The [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    eager loader is mostly legacy at this point, superseded by the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") strategy which is of much simpler design, more
    flexible with features such as [Yield Per](api.html#orm-queryguide-yield-per),
    and emits more efficient SQL statements in most cases. As [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") relies upon re-interpreting the original SELECT
    statement, it may fail to work efficiently when given very complex source queries.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    预加载器在大多数情况下已经过时，被设计更简单、更灵活，例如 [Yield Per](api.html#orm-queryguide-yield-per) 等功能的
    [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    策略取代，并在大多数情况下发出更有效的 SQL 语句。由于 [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") 依赖于重新解释原始的 SELECT 语句，当给出非常复杂的源查询时，它可能无法有效地工作。'
- en: '[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    may continue to be useful for the specific case of an eager loaded collection
    for objects that use composite primary keys, on the Microsoft SQL Server backend
    that continues to not have support for the “tuple IN” syntax.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有复合主键的对象的预加载集合的特定情况，[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    在 Microsoft SQL Server 后端上继续没有支持“元组 IN”语法的情况下仍可能有用。
- en: Subquery loading is similar in operation to selectin eager loading, however
    the SELECT statement which is emitted is derived from the original statement,
    and has a more complex query structure as that of selectin eager loading.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询加载在操作上类似于选择加载，但是发出的 SELECT 语句是从原始语句派生的，并且查询结构比选择加载更复杂。
- en: Subquery eager loading is provided using the `"subquery"` argument to [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") or by using the [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") loader option.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")中的`"subquery"`参数提供子查询即时加载，或者使用[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")加载器选项。
- en: 'The operation of subquery eager loading is to emit a second SELECT statement
    for each relationship to be loaded, across all result objects at once. This SELECT
    statement refers to the original SELECT statement, wrapped inside of a subquery,
    so that we retrieve the same list of primary keys for the primary object being
    returned, then link that to the sum of all the collection members to load them
    at once:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询即时加载的操作是为要加载的每个关系发出第二个SELECT语句，在所有结果对象中一次完成加载。该SELECT语句引用原始SELECT语句，包装在一个子查询中，以便我们检索返回的主对象的相同主键列表，然后将其链接到加载所有集合成员的总和：
- en: '[PRE122]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Things to know about this kind of loading include:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种加载方式需要了解的事项包括：
- en: The SELECT statement emitted by the “subquery” loader strategy, unlike that
    of “selectin”, requires a subquery, and will inherit whatever performance limitations
    are present in the original query. The subquery itself may also incur performance
    penalties based on the specifics of the database in use.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载策略发出的SELECT语句，与“selectin”不同，需要一个子查询，并将继承原始查询中存在的任何性能限制。子查询本身也可能因使用的数据库的具体情况而产生性能损失。
- en: '“subquery” loading imposes some special ordering requirements in order to work
    correctly. A query which makes use of [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") in conjunction with a limiting modifier such as
    [`Select.limit()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit"), or [`Select.offset()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") should **always** include [`Select.order_by()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") against unique column(s) such as
    the primary key, so that the additional queries emitted by [`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") include the same ordering as used by the parent
    query. Without it, there is a chance that the inner query could return the wrong
    rows:'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载会对正确工作施加一些特殊的排序要求。使用[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")的查询，结合使用诸如[`Select.limit()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit")或[`Select.offset()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset")之类的限定修饰符，应**始终**包括针对唯一列（如主键）的[`Select.order_by()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")，以便由[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")发出的附加查询包含与父查询使用的相同排序。否则，内部查询可能返回错误的行：
- en: '[PRE123]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: See also
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Why is ORDER BY recommended with LIMIT (especially with subqueryload())?](../../faq/ormconfiguration.html#faq-subqueryload-limit-sort)
    - detailed example'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[为什么推荐使用 ORDER BY 与 LIMIT（特别是与 subqueryload() 一起）？](../../faq/ormconfiguration.html#faq-subqueryload-limit-sort)
    - 详细示例'
- en: “subquery” loading also incurs additional performance / complexity issues when
    used on a many-levels-deep eager load, as subqueries will be nested repeatedly.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在许多层次深的即时加载中使用“子查询”加载时，还会产生额外的性能/复杂性问题，因为子查询将被重复嵌套。
- en: “subquery” loading is not compatible with the “batched” loading supplied by
    [Yield Per](api.html#orm-queryguide-yield-per), both for collection and scalar
    relationships.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “子查询”加载与[Yield Per](api.html#orm-queryguide-yield-per)提供的“批量”加载不兼容，无论是集合还是标量关系。
- en: For the above reasons, the “selectin” strategy should be preferred over “subquery”.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，“选择”策略应优先于“子查询”。
- en: See also
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Select IN loading](#selectin-eager-loading)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](#selectin-eager-loading)'
- en: '## What Kind of Loading to Use ?'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用什么类型的加载？'
- en: Which type of loading to use typically comes down to optimizing the tradeoff
    between number of SQL executions, complexity of SQL emitted, and amount of data
    fetched.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种类型的加载通常归结为优化SQL执行次数、生成的SQL复杂度和获取的数据量之间的权衡。
- en: '**One to Many / Many to Many Collection** - The [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is generally the best loading strategy to use.
    It emits an additional SELECT that uses as few tables as possible, leaving the
    original statement unaffected, and is most flexible for any kind of originating
    query. Its only major limitation is when using a table with composite primary
    keys on a backend that does not support “tuple IN”, which currently includes SQL
    Server and very old SQLite versions; all other included backends support it.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**一对多/多对多集合** - 通常最好使用[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")加载策略。它发出一个额外的SELECT，尽可能少地使用表，不影响原始语句，并且对于任何类型的起始查询都是最灵活的。它唯一的主要限制是在使用不支持“tuple
    IN”的后端上使用具有复合主键的表，目前包括SQL Server和非常旧的SQLite版本；所有其他包含的后端都支持它。'
- en: '**Many to One** - The [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    strategy is the most general purpose strategy. In special cases, the [`immediateload()`](#sqlalchemy.orm.immediateload
    "sqlalchemy.orm.immediateload") strategy may also be useful, if there are a very
    small number of potential related values, as this strategy will fetch the object
    from the local [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    without emitting any SQL if the related object is already present.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**多对一** - [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")策略是最通用的策略。在特殊情况下，如果存在非常少量的潜在相关值，则[`immediateload()`](#sqlalchemy.orm.immediateload
    "sqlalchemy.orm.immediateload")策略也可能有用，因为如果相关对象已经存在，则此策略将从本地[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")获取对象而不发出任何SQL。'
- en: Polymorphic Eager Loading
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态急加载
- en: Specification of polymorphic options on a per-eager-load basis is supported.
    See the section [Eager Loading of Polymorphic Subtypes](inheritance.html#eagerloading-polymorphic-subtypes)
    for examples of the [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method in conjunction with the [`with_polymorphic()`](inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 支持在每个急加载基础上指定多态选项。请参见[Eager Loading of Polymorphic Subtypes](inheritance.html#eagerloading-polymorphic-subtypes)部分，了解[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法与[`with_polymorphic()`](inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数的结合示例。
- en: '## Wildcard Loading Strategies'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '## 通配符加载策略'
- en: 'Each of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload"),
    [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload"),
    [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"), [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload"),
    and [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") can
    be used to set the default style of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") loading for a particular query, affecting all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") -mapped attributes not otherwise specified in the
    statement. This feature is available by passing the string `''*''` as the argument
    to any of these options:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 每个[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")、[`subqueryload()`](#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")、[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")、[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")和[`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")都可以用于设置特定查询的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")加载的默认样式，影响所有未在语句中另行指定的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") -映射属性。通过将字符串`'*'`作为这些选项中的任何一个的参数传递，可以使用此功能：
- en: '[PRE124]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Above, the `lazyload('*')` option will supersede the `lazy` setting of all [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs in use for that query, with the exception
    of those that use `lazy='write_only'` or `lazy='dynamic'`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`lazyload('*')`选项将取代所有正在使用的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造的`lazy`设置，但不包括那些使用`lazy='write_only'`或`lazy='dynamic'`的情况。
- en: If some relationships specify `lazy='joined'` or `lazy='selectin'`, for example,
    using `lazyload('*')` will unilaterally cause all those relationships to use `'select'`
    loading, e.g. emit a SELECT statement when each attribute is accessed.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些关系指定了 `lazy='joined'` 或 `lazy='selectin'`，例如，使用 `lazyload('*')` 将单方面导致所有这些关系使用
    `'select'` 加载，例如，当访问每个属性时发出一个SELECT语句。
- en: 'The option does not supersede loader options stated in the query, such as [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"), etc. The query below will still use joined loading
    for the `widget` relationship:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项不会取代查询中指定的加载选项，例如[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")，[`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")等。下面的查询仍将对`widget`关系使用连接加载：
- en: '[PRE125]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: While the instruction for [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    above will take place regardless of whether it appears before or after the [`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option, if multiple options that each included `"*"`
    were passed, the last one will take effect.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 不管[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")指令出现在[`lazyload()`](#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")选项之前还是之后，如果传递了包含 `"*"` 的多个选项，则最后一个选项将生效。
- en: '### Per-Entity Wildcard Loading Strategies'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '### 每个实体的通配符加载策略'
- en: 'A variant of the wildcard loader strategy is the ability to set the strategy
    on a per-entity basis. For example, if querying for `User` and `Address`, we can
    instruct all relationships on `Address` to use lazy loading, while leaving the
    loader strategies for `User` unaffected, by first applying the [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object, then specifying the `*` as a chained option:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符加载策略的变体是能够按实体基础设置策略的能力。例如，如果查询`User`和`Address`，我们可以指示`Address`上的所有关系使用延迟加载，同时通过首先应用[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象，然后将 `*` 指定为链接选项：
- en: '[PRE126]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Above, all relationships on `Address` will be set to a lazy load.  ### Per-Entity
    Wildcard Loading Strategies'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，`Address`上的所有关系都将设置为延迟加载。### 每个实体的通配符加载策略
- en: 'A variant of the wildcard loader strategy is the ability to set the strategy
    on a per-entity basis. For example, if querying for `User` and `Address`, we can
    instruct all relationships on `Address` to use lazy loading, while leaving the
    loader strategies for `User` unaffected, by first applying the [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object, then specifying the `*` as a chained option:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符加载策略的变体是能够按实体基础设置策略的能力。例如，如果查询`User`和`Address`，我们可以指示`Address`上的所有关系使用延迟加载，同时通过首先应用[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象，然后将 `*` 指定为链接选项：
- en: '[PRE127]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Above, all relationships on `Address` will be set to a lazy load.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，`Address`上的所有关系都将设置为延迟加载。
- en: '## Routing Explicit Joins/Statements into Eagerly Loaded Collections'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将显式连接/语句路由到急加载集合'
- en: The behavior of [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    is such that joins are created automatically, using anonymous aliases as targets,
    the results of which are routed into collections and scalar references on loaded
    objects. It is often the case that a query already includes the necessary joins
    which represent a particular collection or scalar reference, and the joins added
    by the joinedload feature are redundant - yet you’d still like the collections/references
    to be populated.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")的行为是自动创建连接，使用匿名别名作为目标，其结果路由到加载对象上的集合和标量引用。通常情况下，查询已经包含了表示特定集合或标量引用的必要连接，而由joinedload功能添加的连接是多余的
    - 但您仍希望填充集合/引用。'
- en: 'For this SQLAlchemy supplies the [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is used in the same manner
    as the [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    option except it is assumed that the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object will explicitly include the appropriate
    joins, typically using methods like [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"). Below, we specify a join between `User`
    and `Address` and additionally establish this as the basis for eager loading of
    `User.addresses`:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，SQLAlchemy 提供了 [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    选项。该选项的使用方式与 [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    选项相同，只是假定 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象将明确包括适当的连接，通常使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 等方法。下面，我们指定了 `User` 和 `Address` 之间的连接，并额外将其作为
    `User.addresses` 的急切加载的基础：
- en: '[PRE128]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'If the “eager” portion of the statement is “aliased”, the path should be specified
    using [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type"), which allows the specific [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct to be passed:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句的“急切”部分是“别名”，则应使用 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 指定路径，这允许传递特定的 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造：
- en: '[PRE129]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The path given as the argument to [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") needs to be a full path from the starting entity.
    For example if we were loading `Users->orders->Order->items->Item`, the option
    would be used as:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数给出的路径必须是从起始实体开始的完整路径，例如，如果我们正在加载 `Users->orders->Order->items->Item`，则选项将如下使用：
- en: '[PRE130]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Using contains_eager() to load a custom-filtered collection result
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `contains_eager()` 来加载自定义过滤的集合结果。
- en: When we use [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    *we* are constructing ourselves the SQL that will be used to populate collections.
    From this, it naturally follows that we can opt to **modify** what values the
    collection is intended to store, by writing our SQL to load a subset of elements
    for collections or scalar attributes.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    时，*我们*是自己构造将用于填充集合的 SQL。由此自然而然地，我们可以选择 **修改** 集合意图存储的值，通过编写我们的 SQL 来加载集合或标量属性的元素子集。
- en: Tip
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: SQLAlchemy now has a **much simpler way to do this**, by allowing WHERE criteria
    to be added directly to loader options such as [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") using [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_"). See the section [Adding Criteria to loader
    options](#loader-option-criteria) for examples.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 现在有了一个 **更简单的方法** 来实现这一点，即允许将 WHERE 条件直接添加到加载器选项，如 [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 和 [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 使用 [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")。参见 [Adding Criteria to loader options](#loader-option-criteria)
    章节中的示例。
- en: The techniques described here still apply if the related collection is to be
    queried using SQL criteria or modifiers more complex than a simple WHERE clause.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相关的集合要使用比简单的 WHERE 子句更复杂的 SQL 条件或修饰符进行查询，这里描述的技术仍然适用。
- en: 'As an example, we can load a `User` object and eagerly load only particular
    addresses into its `.addresses` collection by filtering the joined data, routing
    it using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    also using [Populate Existing](api.html#orm-queryguide-populate-existing) to ensure
    any already-loaded collections are overwritten:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们可以加载一个`User`对象，并仅急切地加载其中特定的地址到其`.addresses`集合中，方法是通过过滤连接的数据，并使用 [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 路由它，同时还使用 [Populate Existing](api.html#orm-queryguide-populate-existing)
    确保任何已加载的集合都被覆盖：
- en: '[PRE131]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The above query will load only `User` objects which contain at least `Address`
    object that contains the substring `'aol.com'` in its `email` field; the `User.addresses`
    collection will contain **only** these `Address` entries, and *not* any other
    `Address` entries that are in fact associated with the collection.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询将仅加载包含至少一个包含子字符串`'aol.com'`的`email`字段的`Address`对象的`User`对象；`User.addresses`集合将**仅**包含这些`Address`条目，*而不包括*实际与该集合关联的任何其他`Address`条目。
- en: Tip
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In all cases, the SQLAlchemy ORM does **not overwrite already loaded attributes
    and collections** unless told to do so. As there is an [identity map](../../glossary.html#term-identity-map)
    in use, it is often the case that an ORM query is returning objects that were
    in fact already present and loaded in memory. Therefore, when using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate a collection in an alternate way,
    it is usually a good idea to use [Populate Existing](api.html#orm-queryguide-populate-existing)
    as illustrated above so that an already-loaded collection is refreshed with the
    new data. The `populate_existing` option will reset **all** attributes that were
    already present, including pending changes, so make sure all data is flushed before
    using it. Using the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with its default behavior of [autoflush](../session_basics.html#session-flushing)
    is sufficient.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，除非有明确的指示要这样做，否则 SQLAlchemy ORM **不会覆盖已加载的属性和集合**。由于正在使用[标识映射](../../glossary.html#term-identity-map)，通常情况下，ORM
    查询返回的对象实际上已经存在并加载到内存中。因此，当使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")以另一种方式填充集合时，通常最好像上面所示那样使用[填充现有](api.html#orm-queryguide-populate-existing)，以便已加载的集合使用新数据进行刷新。`populate_existing`
    选项将重置已存在的**所有**属性，包括挂起的更改，因此在使用之前请确保刷新所有数据。使用具有其默认行为的[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的 [autoflush](../session_basics.html#session-flushing)
    足以。
- en: Note
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The customized collection we load using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") is not “sticky”; that is, the next time this
    collection is loaded, it will be loaded with its usual default contents. The collection
    is subject to being reloaded if the object is expired, which occurs whenever the
    [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit"),
    [`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    methods are used assuming default session settings, or the [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") methods are used.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")加载的定制集合不是“粘性”的；也就是说，下次加载该集合时，它将以其通常的默认内容加载。如果对象过期，则集合可能会重新加载，这在使用默认会话设置时每当使用
    [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法时，或者使用 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 或 [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法时会发生。
- en: See also
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adding Criteria to loader options](#loader-option-criteria) - modern API allowing
    WHERE criteria directly within any relationship loader option'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[向加载器选项添加条件](#loader-option-criteria) - 现代 API 允许在任何关系加载器选项中直接添加 WHERE 条件'
- en: Using contains_eager() to load a custom-filtered collection result
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 contains_eager() 加载定制过滤的集合结果
- en: When we use [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    *we* are constructing ourselves the SQL that will be used to populate collections.
    From this, it naturally follows that we can opt to **modify** what values the
    collection is intended to store, by writing our SQL to load a subset of elements
    for collections or scalar attributes.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")时，*我们*正在构建用于填充集合的
    SQL。由此自然而然地，我们可以选择**修改**集合的预期存储值，通过编写我们的 SQL 以加载集合或标量属性的子集元素。
- en: Tip
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: SQLAlchemy now has a **much simpler way to do this**, by allowing WHERE criteria
    to be added directly to loader options such as [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") using [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_"). See the section [Adding Criteria to loader
    options](#loader-option-criteria) for examples.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy现在有一种**更简单的方法**来做到这一点，即允许将WHERE条件直接添加到加载器选项，例如[`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")，使用[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")。有关示例，请参见[向加载器选项添加条件](#loader-option-criteria)部分。
- en: The techniques described here still apply if the related collection is to be
    queried using SQL criteria or modifiers more complex than a simple WHERE clause.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用比简单的WHERE子句更复杂的SQL条件或修改器查询相关集合，则这里描述的技术仍然适用。
- en: 'As an example, we can load a `User` object and eagerly load only particular
    addresses into its `.addresses` collection by filtering the joined data, routing
    it using [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager"),
    also using [Populate Existing](api.html#orm-queryguide-populate-existing) to ensure
    any already-loaded collections are overwritten:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以加载一个`User`对象，并且仅通过过滤联接数据并使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")将其路由到`.addresses`集合，从而急切地加载特定地址，还使用[Populate Existing](api.html#orm-queryguide-populate-existing)确保任何已加载的集合都被覆盖：
- en: '[PRE132]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The above query will load only `User` objects which contain at least `Address`
    object that contains the substring `'aol.com'` in its `email` field; the `User.addresses`
    collection will contain **only** these `Address` entries, and *not* any other
    `Address` entries that are in fact associated with the collection.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询将仅加载包含其`email`字段中包含子字符串`'aol.com'`的`Address`对象的`User`对象；`User.addresses`集合将**仅**包含这些`Address`条目，而*不是*与集合实际相关联的任何其他`Address`条目。
- en: Tip
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In all cases, the SQLAlchemy ORM does **not overwrite already loaded attributes
    and collections** unless told to do so. As there is an [identity map](../../glossary.html#term-identity-map)
    in use, it is often the case that an ORM query is returning objects that were
    in fact already present and loaded in memory. Therefore, when using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate a collection in an alternate way,
    it is usually a good idea to use [Populate Existing](api.html#orm-queryguide-populate-existing)
    as illustrated above so that an already-loaded collection is refreshed with the
    new data. The `populate_existing` option will reset **all** attributes that were
    already present, including pending changes, so make sure all data is flushed before
    using it. Using the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with its default behavior of [autoflush](../session_basics.html#session-flushing)
    is sufficient.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，SQLAlchemy ORM **不会覆盖已加载的属性和集合**，除非被告知要这样做。由于正在使用[身份映射](../../glossary.html#term-identity-map)，通常情况下，ORM
    查询返回的对象实际上已经存在并且在内存中已加载。因此，当使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")以替代方式填充集合时，通常最好使用上面示例中所示的[Populate Existing](api.html#orm-queryguide-populate-existing)，以便已加载的集合可以用新数据刷新。`populate_existing`选项将重置已经存在的**所有**属性，包括待处理的更改，因此请确保在使用之前刷新所有数据。使用具有其默认行为的[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[autoflush](../session_basics.html#session-flushing)足以。
- en: Note
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The customized collection we load using [`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") is not “sticky”; that is, the next time this
    collection is loaded, it will be loaded with its usual default contents. The collection
    is subject to being reloaded if the object is expired, which occurs whenever the
    [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit"),
    [`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    methods are used assuming default session settings, or the [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") methods are used.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")加载的定制集合不是“粘性”的；也就是说，下次加载此集合时，它将以其通常的默认内容加载。
    如果对象过期，则可能重新加载集合，这会在使用默认会话设置时每当使用[`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，或者使用[`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 或[`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法时发生。
- en: See also
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adding Criteria to loader options](#loader-option-criteria) - modern API allowing
    WHERE criteria directly within any relationship loader option'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[向加载器选项添加条件](#loader-option-criteria) - 现代 API 允许在任何关系加载器选项中直接添加 WHERE 条件'
- en: Relationship Loader API
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系加载器 API
- en: '| Object Name | Description |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [contains_eager](#sqlalchemy.orm.contains_eager)(*keys, **kw) | Indicate
    that the given attribute should be eagerly loaded from columns stated manually
    in the query. |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| [contains_eager](#sqlalchemy.orm.contains_eager)(*keys, **kw) | 表示应从查询中手动指定的列急切加载给定属性。
    |'
- en: '| [defaultload](#sqlalchemy.orm.defaultload)(*keys) | Indicate an attribute
    should load using its predefined loader style. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| [defaultload](#sqlalchemy.orm.defaultload)(*keys) | 表示应使用预定义的加载器样式加载属性。 |'
- en: '| [immediateload](#sqlalchemy.orm.immediateload)(*keys, [recursion_depth])
    | Indicate that the given attribute should be loaded using an immediate load with
    a per-attribute SELECT statement. |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| [immediateload](#sqlalchemy.orm.immediateload)(*keys, [recursion_depth])
    | 表示应使用带有每个属性 SELECT 语句的立即加载来加载给定属性。 |'
- en: '| [joinedload](#sqlalchemy.orm.joinedload)(*keys, **kw) | Indicate that the
    given attribute should be loaded using joined eager loading. |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| [joinedload](#sqlalchemy.orm.joinedload)(*keys, **kw) | 表示应使用连接的急切加载来加载给定属性。
    |'
- en: '| [lazyload](#sqlalchemy.orm.lazyload)(*keys) | Indicate that the given attribute
    should be loaded using “lazy” loading. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| [lazyload](#sqlalchemy.orm.lazyload)(*keys) | 表示应使用“懒惰”加载来加载给定属性。 |'
- en: '| [Load](#sqlalchemy.orm.Load) | Represents loader options which modify the
    state of a ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or a legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to affect how various mapped attributes are loaded.
    |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| [Load](#sqlalchemy.orm.Load) | 代表修改 ORM 启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")状态以影响加载各种映射属性的加载器选项。 |'
- en: '| [noload](#sqlalchemy.orm.noload)(*keys) | Indicate that the given relationship
    attribute should remain unloaded. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| [noload](#sqlalchemy.orm.noload)(*keys) | 表示给定关系属性应保持未加载状态。 |'
- en: '| [raiseload](#sqlalchemy.orm.raiseload)(*keys, **kw) | Indicate that the given
    attribute should raise an error if accessed. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| [raiseload](#sqlalchemy.orm.raiseload)(*keys, **kw) | 表示给定属性在访问时应引发错误。 |'
- en: '| [selectinload](#sqlalchemy.orm.selectinload)(*keys, [recursion_depth]) |
    Indicate that the given attribute should be loaded using SELECT IN eager loading.
    |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| [selectinload](#sqlalchemy.orm.selectinload)(*keys, [recursion_depth]) |
    表示应使用 SELECT IN 急切加载来加载给定属性。 |'
- en: '| [subqueryload](#sqlalchemy.orm.subqueryload)(*keys) | Indicate that the given
    attribute should be loaded using subquery eager loading. |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| [subqueryload](#sqlalchemy.orm.subqueryload)(*keys) | 表示应使用子查询急切加载来加载给定属性。
    |'
- en: '[PRE133]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Indicate that the given attribute should be eagerly loaded from columns stated
    manually in the query.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应从查询中手动指定的列急���加载给定属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: 'The option is used in conjunction with an explicit join that loads the desired
    rows, i.e.:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与加载所需行的显式连接一起使用，即：
- en: '[PRE134]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The above query would join from the `Order` entity to its related `User` entity,
    and the returned `Order` objects would have the `Order.user` attribute pre-populated.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将从 `Order` 实体连接到其相关的 `User` 实体，并且返回的 `Order` 对象将预先填充 `Order.user` 属性。
- en: 'It may also be used for customizing the entries in an eagerly loaded collection;
    queries will normally want to use the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option assuming the primary collection of parent objects may already
    have been loaded:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以用于自定义急切加载集合中的条目；查询通常会使用 [填充现有](api.html#orm-queryguide-populate-existing)
    执行选项，假设父对象的主要集合可能已经加载：
- en: '[PRE135]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: See the section [Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)
    for complete usage details.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的使用详细信息，请参阅 [将显式连接/语句路由到急切加载的集合中](#contains-eager) 部分。
- en: See also
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Relationship Loading Techniques](#)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager)'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到急切加载的集合中](#contains-eager)'
- en: '[PRE136]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Indicate an attribute should load using its predefined loader style.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 指示属性应使用其预定义的加载器样式加载。
- en: The behavior of this loading option is to not change the current loading style
    of the attribute, meaning that the previously configured one is used or, if no
    previous style was selected, the default loading will be used.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 此加载选项的行为是不更改属性的当前加载样式，这意味着将使用先前配置的样式，或者如果没有选择先前的样式，则将使用默认加载。
- en: 'This method is used to link to other loader options further into a chain of
    attributes without altering the loader style of the links along the chain. For
    example, to set joined eager loading for an element of an element:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将其他加载器选项链接到属性链中的进一步位置，而不更改链中的链接的加载器样式。例如，要为元素的元素设置连接的急切加载：
- en: '[PRE137]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    is also useful for setting column-level options on a related class, namely that
    of [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") and [`undefer()`](columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer"):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    也可用于在相关类上设置列级选项，即 [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    和 [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")：'
- en: '[PRE138]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: See also
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Specifying Sub-Options with Load.options()](#orm-queryguide-relationship-sub-options)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Load.options() 指定子选项](#orm-queryguide-relationship-sub-options)'
- en: '[`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Load.options()`](#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")'
- en: '[PRE139]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Indicate that the given attribute should be loaded using an immediate load with
    a per-attribute SELECT statement.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 指示应使用立即加载和每个属性的 SELECT 语句加载给定属性。
- en: The load is achieved using the “lazyloader” strategy and does not fire off any
    additional eager loaders.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 加载是使用“懒加载器”策略实现的，不会触发任何额外的急切加载器。
- en: The [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    option is superseded in general by the [`selectinload()`](#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") option, which performs the same task more efficiently
    by emitting a SELECT for all loaded objects.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    选项通常被 [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    选项替代，后者通过为所有加载的对象发出 SELECT 语句来更有效地执行相同的任务。'
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，并支持方法链接和独立操作。
- en: 'Parameters:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**recursion_depth** –'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**recursion_depth** – 递归深度'
- en: optional int; when set to a positive integer in conjunction with a self-referential
    relationship, indicates “selectin” loading will continue that many levels deep
    automatically until no items are found.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 可选整数；当与自引用关系一起设置为正整数时，表示“selectin”加载将自动继续这么多级别，直到找不到任何项目为止。
- en: Note
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload") option currently supports only self-referential
    relationships. There is not yet an option to automatically traverse recursive
    structures with more than one relationship involved.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '[`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload")选项目前仅支持自引用关系。目前还没有选项可以自动遍历涉及多个关系的递归结构。'
- en: Warning
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This parameter is new and experimental and should be treated as “alpha” status
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数是新的实验性参数，应该视为“alpha”状态
- en: 'New in version 2.0: added [`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload")'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中新增：添加[`immediateload.recursion_depth`](#sqlalchemy.orm.immediateload.params.recursion_depth
    "sqlalchemy.orm.immediateload")
- en: See also
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Relationship Loading Techniques](#)'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Select IN loading](#selectin-eager-loading)'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '[Select IN加载](#selectin-eager-loading)'
- en: '[PRE140]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Indicate that the given attribute should be loaded using joined eager loading.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应该使用连接的快速加载来加载给定的属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链和独立操作。
- en: 'examples:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE141]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Parameters:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**innerjoin** –'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**innerjoin** –'
- en: 'if `True`, indicates that the joined eager load should use an inner join instead
    of the default of left outer join:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`True`，表示连接的急切加载应该使用内部连接而不是左外连接的默认值：
- en: '[PRE142]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In order to chain multiple eager joins together where some may be OUTER and
    others INNER, right-nested joins are used to link them:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 为了链接多个急切加载在一起，其中一些可能是OUTER，另一些是INNER，右嵌套连接用于链接它们：
- en: '[PRE143]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The above query, linking A.bs via “outer” join and B.cs via “inner” join would
    render the joins as “a LEFT OUTER JOIN (b JOIN c)”. When using older versions
    of SQLite (< 3.7.16), this form of JOIN is translated to use full subqueries as
    this syntax is otherwise not directly supported.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询通过“outer” join连接A.bs和通过“inner” join连接B.cs，将连接呈现为“a LEFT OUTER JOIN (b JOIN
    c)”。
- en: 'The `innerjoin` flag can also be stated with the term `"unnested"`. This indicates
    that an INNER JOIN should be used, *unless* the join is linked to a LEFT OUTER
    JOIN to the left, in which case it will render as LEFT OUTER JOIN. For example,
    supposing `A.bs` is an outerjoin:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerjoin`标志也可以用术语`"unnested"`来表示。这表示应该使用INNER JOIN，*除非*连接到左侧的LEFT OUTER JOIN，这种情况下它将呈现为LEFT
    OUTER JOIN。例如，假设`A.bs`是一个outerjoin：'
- en: '[PRE144]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The above join will render as “a LEFT OUTER JOIN b LEFT OUTER JOIN c”, rather
    than as “a LEFT OUTER JOIN (b JOIN c)”.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 上述连接将呈现为“a LEFT OUTER JOIN b LEFT OUTER JOIN c”，而不是“a LEFT OUTER JOIN (b JOIN
    c)”。
- en: Note
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “unnested” flag does **not** affect the JOIN rendered from a many-to-many
    association table, e.g. a table configured as [`relationship.secondary`](../relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"), to the target table; for correctness of results,
    these joins are always INNER and are therefore right-nested if linked to an OUTER
    join.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: “unnested”标志**不会**影响从多对多关联表（例如配置为[`relationship.secondary`](../relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")的表）到目标表的JOIN渲染；为了结果的正确性，这些连接始终是INNER的，因此如果连接到OUTER
    join，它们将是右嵌套的。
- en: Note
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The joins produced by [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    are **anonymously aliased**. The criteria by which the join proceeds cannot be
    modified, nor can the ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") refer to these joins in any way, including ordering. See
    [The Zen of Joined Eager Loading](#zen-of-eager-loading) for further detail.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")生成的连接是**匿名别名**。连接进行的条件无法修改，ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统的[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")也不能以任何方式引用这些连接，包括排序。有关详细信息，请参见[急切加载之道](#zen-of-eager-loading)。'
- en: To produce a specific SQL JOIN which is explicitly available, use [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"). To combine explicit JOINs with eager loading of
    collections, use [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager");
    see [Routing Explicit Joins/Statements into Eagerly Loaded Collections](#contains-eager).
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个明确可用的特定 SQL JOIN，请使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")。要将显式的 JOIN 与集合的急加载结合起来，请使用[`contains_eager()`](#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")；参见[将显式 JOIN/语句路由到急加载的集合](#contains-eager)。
- en: See also
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Joined Eager Loading](#joined-eager-loading)'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接急加载](#joined-eager-loading)'
- en: '[PRE145]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Indicate that the given attribute should be loaded using “lazy” loading.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应该使用“懒加载”来加载给定的属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链和独立操作。
- en: See also
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Lazy Loading](#lazy-loading)'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '[懒加载](#lazy-loading)'
- en: '[PRE146]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Represents loader options which modify the state of a ORM-enabled [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") or a legacy [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to affect how various mapped attributes are loaded.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 表示加载器选项，用于修改 ORM 启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或传统[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的状态，以影响加载各种映射属性的方式。
- en: The [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object is in most cases
    used implicitly behind the scenes when one makes use of a query option like [`joinedload()`](#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer"),
    or similar. It typically is not instantiated directly except for in some very
    specific cases.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当使用查询选项像[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")、[`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")或类似的选项时，[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象通常会在幕后隐式使用。除了一些非常特殊的情况外，通常不会直接实例化它。
- en: See also
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Per-Entity Wildcard Loading Strategies](#orm-queryguide-relationship-per-entity-wildcard)
    - illustrates an example where direct use of [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    may be useful'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '[每个实体的通配符加载策略](#orm-queryguide-relationship-per-entity-wildcard) - 演示了直接使用[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")可能有用的示例'
- en: '**Members**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[contains_eager()](#sqlalchemy.orm.Load.contains_eager), [defaultload()](#sqlalchemy.orm.Load.defaultload),
    [defer()](#sqlalchemy.orm.Load.defer), [get_children()](#sqlalchemy.orm.Load.get_children),
    [immediateload()](#sqlalchemy.orm.Load.immediateload), [inherit_cache](#sqlalchemy.orm.Load.inherit_cache),
    [joinedload()](#sqlalchemy.orm.Load.joinedload), [lazyload()](#sqlalchemy.orm.Load.lazyload),
    [load_only()](#sqlalchemy.orm.Load.load_only), [noload()](#sqlalchemy.orm.Load.noload),
    [options()](#sqlalchemy.orm.Load.options), [process_compile_state()](#sqlalchemy.orm.Load.process_compile_state),
    [process_compile_state_replaced_entities()](#sqlalchemy.orm.Load.process_compile_state_replaced_entities),
    [propagate_to_loaders](#sqlalchemy.orm.Load.propagate_to_loaders), [raiseload()](#sqlalchemy.orm.Load.raiseload),
    [selectin_polymorphic()](#sqlalchemy.orm.Load.selectin_polymorphic), [selectinload()](#sqlalchemy.orm.Load.selectinload),
    [subqueryload()](#sqlalchemy.orm.Load.subqueryload), [undefer()](#sqlalchemy.orm.Load.undefer),
    [undefer_group()](#sqlalchemy.orm.Load.undefer_group), [with_expression()](#sqlalchemy.orm.Load.with_expression)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[contains_eager()](#sqlalchemy.orm.Load.contains_eager), [defaultload()](#sqlalchemy.orm.Load.defaultload),
    [defer()](#sqlalchemy.orm.Load.defer), [get_children()](#sqlalchemy.orm.Load.get_children),
    [immediateload()](#sqlalchemy.orm.Load.immediateload), [inherit_cache](#sqlalchemy.orm.Load.inherit_cache),
    [joinedload()](#sqlalchemy.orm.Load.joinedload), [lazyload()](#sqlalchemy.orm.Load.lazyload),
    [load_only()](#sqlalchemy.orm.Load.load_only), [noload()](#sqlalchemy.orm.Load.noload),
    [options()](#sqlalchemy.orm.Load.options), [process_compile_state()](#sqlalchemy.orm.Load.process_compile_state),
    [process_compile_state_replaced_entities()](#sqlalchemy.orm.Load.process_compile_state_replaced_entities),
    [propagate_to_loaders](#sqlalchemy.orm.Load.propagate_to_loaders), [raiseload()](#sqlalchemy.orm.Load.raiseload),
    [selectin_polymorphic()](#sqlalchemy.orm.Load.selectin_polymorphic), [selectinload()](#sqlalchemy.orm.Load.selectinload),
    [subqueryload()](#sqlalchemy.orm.Load.subqueryload), [undefer()](#sqlalchemy.orm.Load.undefer),
    [undefer_group()](#sqlalchemy.orm.Load.undefer_group), [with_expression()](#sqlalchemy.orm.Load.with_expression)'
- en: '**Class signature**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") (`sqlalchemy.orm.strategy_options._AbstractLoad`)
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.orm.Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")（`sqlalchemy.orm.strategy_options._AbstractLoad`）
- en: '[PRE147]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.contains_eager`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* `sqlalchemy.orm.strategy_options._AbstractLoad.contains_eager` *方法继承* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    option applied.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个新的带有[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")选项的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")
    for usage examples.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`contains_eager()`](#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")的使用示例。
- en: '[PRE148]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.defaultload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* `sqlalchemy.orm.strategy_options._AbstractLoad.defaultload` *方法继承* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option applied.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个新的带有[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")选项的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    for usage examples.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")的使用示例。
- en: '[PRE149]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.defer`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* `sqlalchemy.orm.strategy_options._AbstractLoad.defer` *方法继承* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") option
    applied.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个新的带有[`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")选项的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer") for
    usage examples.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")的使用示例。
- en: '[PRE150]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '*inherited from the* `HasTraverseInternals.get_children()` *method of* `HasTraverseInternals`'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* `HasTraverseInternals.get_children()` *方法继承* `HasTraverseInternals`'
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此`HasTraverseInternals`的即时子项`HasTraverseInternals`。
- en: This is used for visit traversal.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问遍历。
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**kw可能包含更改返回集合的标志，例如返回子项的子集以减少较大的遍历，或者从不同上下文返回子项（例如模式级集合而不是从子句级返回的）。'
- en: '[PRE151]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.immediateload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* `sqlalchemy.orm.strategy_options._AbstractLoad.immediateload` *方法继承* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    option applied.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个新的带有[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")选项的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")
    for usage examples.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`immediateload()`](#sqlalchemy.orm.immediateload "sqlalchemy.orm.immediateload")的使用示例。
- en: '[PRE152]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '*inherited from the* `HasCacheKey.inherit_cache` *attribute of* [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey")'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey") *的* `HasCacheKey.inherit_cache` *属性继承*'
- en: Indicate if this [`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 指示此[`HasCacheKey`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey")实例是否应使用其直接超类使用的缓存键生成方案。
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性默认为`None`，表示构造尚未考虑是否适合参与缓存；这在功能上等效于将值设置为`False`，但还会发出警告。
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象对应的 SQL 不基于本类的属性而是本类的父类属性，则可以将此标志设置为`True`。
- en: See also
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Enabling Caching Support for Custom Constructs](../../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '[为自定义构造启用缓存支持](../../core/compiler.html#compilerext-caching) - 有关为第三方或用户定义的
    SQL 构造设置[`HasCacheKey.inherit_cache`](../../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache")属性的一般指南。'
- en: '[PRE153]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.joinedload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.joinedload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload") option
    applied.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    for usage examples.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[`joinedload()`](#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")以查看用法示例。
- en: '[PRE154]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.lazyload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.lazyload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") option
    applied.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload") for usage
    examples.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[`lazyload()`](#sqlalchemy.orm.lazyload "sqlalchemy.orm.lazyload")以查看用法示例。
- en: '[PRE155]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.load_only`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.load_only` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    option applied.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    for usage examples.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")以查看用法示例。
- en: '[PRE156]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.noload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.noload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") option applied.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") for usage examples.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")以查看用法示例。
- en: '[PRE157]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Apply a series of options as sub-options to this [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列选项作为此[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象的子选项应用。
- en: 'E.g.:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE158]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Parameters:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '***opts** – A series of loader option objects (ultimately [`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") objects) which should be applied to the path specified
    by this [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object.'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '***opts** – 应应用于此[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象指定路径的一系列加载器选项对象（最终为[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象）。'
- en: New in version 1.3.6.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3.6 中新增。
- en: See also
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defaultload()`](#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")'
- en: '[Specifying Sub-Options with Load.options()](#orm-queryguide-relationship-sub-options)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Load.options() 指定子选项](#orm-queryguide-relationship-sub-options)'
- en: '[PRE159]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state`
    *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Apply a modification to a given `ORMCompileState`.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的`ORMCompileState`应用修改。
- en: This method is part of the implementation of a particular `CompileStateOption`
    and is only invoked internally when an ORM query is compiled.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是特定`CompileStateOption`的实现的一部分，仅在编译ORM查询时内部调用。
- en: '[PRE160]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state_replaced_entities`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.process_compile_state_replaced_entities`
    *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Apply a modification to a given `ORMCompileState`, given entities that were
    replaced by with_only_columns() or with_entities().
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的`ORMCompileState`应用修改，给出仅由`with_only_columns()`或`with_entities()`替换的实体。
- en: This method is part of the implementation of a particular `CompileStateOption`
    and is only invoked internally when an ORM query is compiled.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是特定`CompileStateOption`的实现的一部分，仅在编译ORM查询时内部调用。
- en: New in version 1.4.19.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.19版本中的新功能。
- en: '[PRE161]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.propagate_to_loaders`
    *attribute of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.propagate_to_loaders`
    *属性的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: if True, indicate this option should be carried along to “secondary” SELECT
    statements that occur for relationship lazy loaders as well as attribute load
    / refresh operations.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为True，则表示此选项应该传递到关系懒加载器的“次要”SELECT语句，以及属性加载/刷新操作。
- en: '[PRE162]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.raiseload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.raiseload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") option
    applied.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") for
    usage examples.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")以查看用法示例。
- en: '[PRE163]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.selectin_polymorphic`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.selectin_polymorphic`
    *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") option applied.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic")选项生成一个新的[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")对象。
- en: See [`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic") for usage examples.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`selectin_polymorphic()`](inheritance.html#sqlalchemy.orm.selectin_polymorphic
    "sqlalchemy.orm.selectin_polymorphic")以查看用法示例。
- en: '[PRE164]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.selectinload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.selectinload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    option applied.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    for usage examples.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`selectinload()`](#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")以查看用法示例。
- en: '[PRE165]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.subqueryload`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.subqueryload` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    option applied.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
    for usage examples.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`subqueryload()`](#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")以查看用法示例。
- en: '[PRE166]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    option applied.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")选项生成一个新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    for usage examples.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[`undefer()`](columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")获取用法示例。
- en: '[PRE167]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer_group`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.undefer_group` *方法的* `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")
    option applied.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")选项生成新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")
    for usage examples.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[`undefer_group()`](columns.html#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")获取用法示例。
- en: '[PRE168]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '*inherited from the* `sqlalchemy.orm.strategy_options._AbstractLoad.with_expression`
    *method of* `sqlalchemy.orm.strategy_options._AbstractLoad`'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* `sqlalchemy.orm.strategy_options._AbstractLoad.with_expression` *方法的*
    `sqlalchemy.orm.strategy_options._AbstractLoad`'
- en: Produce a new [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") object with
    the [`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    option applied.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")选项生成新的[`Load`](#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load")对象。
- en: See [`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    for usage examples.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[`with_expression()`](columns.html#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")获取用法示例。
- en: '[PRE169]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Indicate that the given relationship attribute should remain unloaded.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定的关系属性应保持未加载状态。
- en: The relationship attribute will return `None` when accessed without producing
    any loading effect.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问关系属性时，关系属性将返回`None`，而不产生任何加载效果。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能是[`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链和独立操作。
- en: '[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload") applies to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") attributes only.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '[`noload()`](#sqlalchemy.orm.noload "sqlalchemy.orm.noload")仅适用于[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")属性。'
- en: Note
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Setting this loading strategy as the default strategy for a relationship using
    the [`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter may cause issues with flushes, such if
    a delete operation needs to load related objects and instead `None` was returned.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`relationship.lazy`](../relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数将此加载策略设置为关系的默认策略可能会导致刷新时出现问题，例如，如果删除操作需要加载相关对象，而返回的是`None`。
- en: See also
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Relationship Loading Techniques](#)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[PRE170]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Indicate that the given attribute should raise an error if accessed.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 表示如果访问给定的属性，应该引发错误。
- en: A relationship attribute configured with [`raiseload()`](#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") will raise an [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") upon access. The typical way this is useful
    is when an application is attempting to ensure that all relationship attributes
    that are accessed in a particular context would have been already loaded via eager
    loading. Instead of having to read through SQL logs to ensure lazy loads aren’t
    occurring, this strategy will cause them to raise immediately.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload")配置的关系属性在访问时将引发[`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")。这种方式通常很有用，当应用程序试图确保在特定上下文中访问的所有关系属性都已通过急加载加载时。这种策略将导致立即引发异常，而不必查看
    SQL 日志以确保不会发生延迟加载。
- en: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") applies
    to [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    attributes only. In order to apply raise-on-SQL behavior to a column-based attribute,
    use the [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") parameter on the [`defer()`](columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") loader option.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '[`raiseload()`](#sqlalchemy.orm.raiseload "sqlalchemy.orm.raiseload") 仅适用于
    [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    属性。为了将在基于列的属性上应用 SQL 异常处理行为，应在 [`defer()`](columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    加载器选项的 [`defer.raiseload`](columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") 参数上使用。'
- en: 'Parameters:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**sql_only** – if True, raise only if the lazy load would emit SQL, but not
    if it is only checking the identity map, or determining that the related value
    should just be None due to missing keys. When False, the strategy will raise for
    all varieties of relationship loading.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**sql_only** – 如果为 True，则仅在延迟加载会发出 SQL 时引发异常，但如果仅检查标识映射或确定相关值由于缺少键应为 None，则不会引发异常。当为
    False 时，该策略将引发所有类型的关系加载异常。'
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，支持方法链式和独立操作。
- en: See also
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Preventing unwanted lazy loads using raiseload](#prevent-lazy-with-raiseload)'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止不需要的延迟加载](#prevent-lazy-with-raiseload)'
- en: '[Using raiseload to prevent deferred column loads](columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止延迟加载列](columns.html#orm-queryguide-deferred-raiseload)'
- en: '[PRE171]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Indicate that the given attribute should be loaded using SELECT IN eager loading.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 指示应使用 SELECT IN 即时加载来加载给定的属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，支持方法链式和独立操作。
- en: 'examples:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE172]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Parameters:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**recursion_depth** –'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归深度** –'
- en: optional int; when set to a positive integer in conjunction with a self-referential
    relationship, indicates “selectin” loading will continue that many levels deep
    automatically until no items are found.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 可选整数；当与自引用关系一起设置为正整数时，表示“选择加载”将自动深入到指定的层级直到找不到任何项目。
- en: Note
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") option currently supports only self-referential
    relationships. There is not yet an option to automatically traverse recursive
    structures with more than one relationship involved.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '[`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") 选项目前仅支持自引用关系。目前还没有自动遍历多个关系的递归结构的选项。'
- en: Additionally, the [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") parameter is new and experimental and should be
    treated as “alpha” status for the 2.0 series.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload") 参数是新的实验性参数，并且应被视为 2.0 系列的“alpha”状态。
- en: 'New in version 2.0: added [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload")'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本中新增：添加 [`selectinload.recursion_depth`](#sqlalchemy.orm.selectinload.params.recursion_depth
    "sqlalchemy.orm.selectinload")
- en: See also
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Select IN loading](#selectin-eager-loading)'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](#selectin-eager-loading)'
- en: '[PRE173]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Indicate that the given attribute should be loaded using subquery eager loading.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 指示应使用子查询即时加载来加载给定的属性。
- en: This function is part of the [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    interface and supports both method-chained and standalone operation.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](#sqlalchemy.orm.Load "sqlalchemy.orm.Load") 接口的一部分，支持方法链式和独立操作。
- en: 'examples:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE174]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: See also
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](#)'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](#)'
- en: '[Subquery Eager Loading](#subquery-eager-loading)'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '[子查询即时加载](#subquery-eager-loading)'
