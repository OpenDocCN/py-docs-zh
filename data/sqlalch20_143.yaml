- en: What’s New in SQLAlchemy 1.2?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.2 中的新内容是什么？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_12.html](https://docs.sqlalchemy.org/en/20/changelog/migration_12.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_12.html](https://docs.sqlalchemy.org/en/20/changelog/migration_12.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 1.1 and SQLAlchemy
    version 1.2.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了 SQLAlchemy 1.1 版本与 SQLAlchemy 1.2 版本之间的更改。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: This guide introduces what’s new in SQLAlchemy version 1.2, and also documents
    changes which affect users migrating their applications from the 1.1 series of
    SQLAlchemy to 1.2.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 1.2 中的新功能，并记录了影响用户将其应用程序从 SQLAlchemy 1.1 系列迁移到 1.2 系列的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为更改部分，可能会出现不兼容的行为更改。
- en: Platform Support
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.7 and Up
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对 Python 2.7 及更高版本
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.2 现在将最低 Python 版本提高到 2.7，不再支持 2.6。预计会将不支持 Python 2.6 的新语言特性合并到
    1.2 系列中。对于 Python 3 的支持，SQLAlchemy 目前在版本 3.5 和 3.6 上进行了测试。
- en: New Features and Improvements - ORM
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM 中的新功能和改进
- en: '### “Baked” loading now the default for lazy loads'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '### “Baked” 加载现在是懒加载的默认设置'
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") 扩展是在 1.0 系列中首次引入的，允许构建所谓的 [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") 对象，它是一个生成 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象的对象，与表示查询结构的缓存键相结合；然后将此缓存键链接到生成的字符串 SQL 语句，以便后续使用具有相同结构的另一个
    [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery "sqlalchemy.ext.baked.BakedQuery")
    将绕过构建 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象的所有开销，构建内部的核心 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 对象，以及 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 编译为字符串，大大减少了通常与构建和发出 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象相关的函数调用开销。'
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM为惰性加载一个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造生成“懒惰”查询时，默认情况下现在使用[`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery")，例如默认的`lazy="select"`关系加载器策略。这将允许在应用程序使用惰性加载查询加载集合和相关对象的范围内显著减少函数调用。以前，此功能在1.0和1.1中通过使用全局API方法或使用`baked_select`策略可用，现在是此行为的唯一实现。该功能还得到了改进，以便对于在延迟加载后生效的具有附加加载器选项的对象仍然可以进行缓存。
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过[`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship")标志在每个关系基础上禁用缓存行为，这对于非常罕见的情况非常有用，比如使用不兼容缓存的自定义[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")实现的关系。
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### New “selectin” eager
    loading, loads all collections at once using IN'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### 新的“selectin”急切加载，使用IN一次加载所有集合'
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个名为“selectin”加载的新急切加载器，这在许多方面类似于“子查询”加载，但是生成了一个更简单的SQL语句，该语句也可以缓存并且更有效。
- en: 'Given a query as below:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下查询：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SQL将是针对`User`的查询，然后是`User.addresses`的子查询加载（注意还列出了参数）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“selectin”加载，我们得到一个SELECT语句，该语句引用在父查询中加载的实际主键值：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Produces:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The above SELECT statement includes these advantages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述SELECT语句包括以下优点：
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不使用子查询，只使用INNER JOIN，这意味着在像MySQL这样不喜欢子查询的数据库上性能会更好。
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其结构与原始查询无关；与新的[扩展的IN参数系统](#change-3953)结合，我们在大多数情况下可以使用“烘焙”查询来缓存字符串SQL，从而显著减少每个查询的开销。
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于查询仅针对给定的主键标识符列表进行，"selectin" 加载可能与 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 兼容，以便一次操作 SELECT 结果的一部分，前提是数据库驱动程序允许多个同时游标（SQLite、PostgreSQL；**不**是
    MySQL 驱动程序或 SQL Server ODBC 驱动程序）。联接式急切加载和子查询急切加载都不兼容 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")。
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: selectin 急切加载的缺点是可能产生大量的 SQL 查询，具有大量的 IN 参数列表。IN 参数列表本身被分组为每组 500 个，因此超过 500
    个主对象的结果集将有更多的额外“SELECT IN”查询。此外，对复合主键的支持取决于数据库能否使用包含 IN 的元组，例如 `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`。目前，已知 PostgreSQL 和 MySQL 兼容此语法，SQLite
    不兼容。
- en: See also
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading)'
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” polymorphic
    loading, loads subclasses using separate IN queries'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” 多态加载，使用单独的
    IN 查询加载子类'
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与刚刚描述的“selectin”关系加载功能类似的是“selectin”多态加载。这是一个专门针对联接式急切加载的多态加载功能，允许基本实体的加载通过简单的
    SELECT 语句进行，然后额外子类的属性通过额外的 SELECT 语句进行加载：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### ORM attributes that
    can receive ad-hoc SQL expressions'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### ORM 属性可以接收临时 SQL
    表达式'
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 ORM 属性类型 [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") 被添加，类似于 [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")，不同之处在于它的 SQL 表达式是在查询时确定的，使用了一个新选项 [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")；如果未指定，则属性默认为 `None`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询时 SQL 表达式作为映射属性](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM Support of multiple-table
    deletes'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM 支持多表删除'
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法支持多表条件的DELETE，就像在[支持多表条件的DELETE](#change-959)中介绍的那样。该功能的工作方式与在0.8中首次引入的UPDATE的多表条件相同，并在[Query.update()支持UPDATE..FROM](migration_08.html#change-orm-2365)中描述。
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们对`SomeEntity`执行DELETE操作，并添加一个FROM子句（或等效的，取决于后端）对`SomeOtherEntity`进行操作：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持多表条件的DELETE](#change-959)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### Support for bulk updates
    of hybrids, composites'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### 支持混合属性、复合属性的批量更新'
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在混合属性（例如[`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")）以及复合属性（[复合列类型](../orm/composites.html#mapper-composite)）在使用[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")时支持在UPDATE语句的SET子句中使用。
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混合属性，可以直接使用简单表达式，或者可以使用新的装饰器[`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression")将一个值拆分为多个列/表达式：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Above, an UPDATE can be rendered using:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，可以使用以下方式呈现UPDATE：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的功能也适用于复合属性，其中复合值将被拆分为其各个列以进行批量UPDATE：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)  ###
    Hybrid attributes support reuse among subclasses, redefinition of @getter'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[允许批量ORM更新](../orm/extensions/hybrid.html#hybrid-bulk-update)  ### 混合属性支持在子类之间重用，重新定义@getter'
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") 类现在支持在子类中多次调用诸如`@setter`、`@expression`等的变异器，并且现在提供了`@getter`变异器，以便特定的混合属性可以在子类或其他类中重新使用。这与标准
    Python 中`@property`的行为类似：'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`FirstNameOnly.name`混合属性被`FirstNameLastName`子类引用，以便将其专门用于新子类。这是通过在每次调用`@getter`、`@setter`以及所有其他变异器方法（如`@expression`）中将混合对象复制到新对象中来实现的，从而保持先前混合属性的定义不变。以前，诸如`@setter`的方法会直接修改现有的混合属性，干扰了超类的定义。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读[在子类之间重用混合属性](../orm/extensions/hybrid.html#hybrid-reuse-subclass)处的文档，了解如何覆盖[`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression")和[`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator")的重要注意事项，因为在某些情况下可能需要一个特殊的限定符[`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides")来避免与[`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute")发生名称冲突。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对`@hybrid_property`的更改意味着，当向`@hybrid_property`添加setter和其他状态时，**方法必须保留原始混合的名称**，否则具有附加状态的新混合将作为不匹配的名称存在于类中。这与标准Python的`@property`构造的行为相同：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### New bulk_replace
    event'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### 新的bulk_replace事件'
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应[A @validates method receives all values on bulk-collection set before comparison](#change-3896-validates)中描述的验证用例，添加了一个新的[`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace")方法，该方法与[`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append")和[`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove")事件一起调用。“bulk_replace”在“append”和“remove”之前调用，以便在与现有集合进行比较之前修改集合。之后，单个项目将附加到新的目标集合，触发对于集合中新项目的“append”事件，这与以前的行为相同。下面同时说明了“bulk_replace”和“append”，包括“append”将接收已由“bulk_replace”处理的对象（如果使用集合赋值）。一个新的符号`attributes.OP_BULK_REPLACE`可用于确定此“append”事件是否是批量替换的第二部分：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### New “modified” event
    handler for sqlalchemy.ext.mutable'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### 新的“modified”事件处理程序用于sqlalchemy.ext.mutable'
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新的事件处理程序[`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified")，它与对[`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified")方法的调用对应，通常从[`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable")扩展调用：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，当对`.data`字典进行原地更改时，事件处理程序将被触发。
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### Added “for update”
    arguments to Session.refresh'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### 在 Session.refresh
    中添加了“for update”参数'
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为[`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")方法添加了新参数[`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh")。当`Query.with_lockmode()`方法被弃用，而是采用[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")时，[`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")方法从未更新以反映新选项：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") 参数接受一个选项字典，该字典将作为与[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")发送的相同参数一样发送的参数：'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数取代了[`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") 参数。
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### In-place mutation
    operators work for MutableSet, MutableList'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### 原地突变操作符适用于 MutableSet、MutableList'
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为[`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet")实现了原地突变操作符`__ior__`、`__iand__`、`__ixor__`和`__isub__`，以及[`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList")的`__iadd__`。虽然这些方法以前可以成功更新集合，但它们不会正确地触发更改事件。这些操作符像以前一样突变集合，但额外地发出正确的更改事件，以便更改成为下一个刷新过程的一部分：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    any(), has(), contains() work with chained association proxies'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    的 any()、has()、contains() 方法与链式关联代理一起工作'
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssociationProxy.any()`、`AssociationProxy.has()`和`AssociationProxy.contains()`比较方法现在支持链接到一个属性，该属性本身也是[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，递归地。下面，`A.b_values`是一个关联代理，链接到`AtoB.bvalue`，而`AtoB.bvalue`本身是一个关联代理，链接到`B`：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AssociationProxy.contains()`在`A.b_values`上进行查询，以跨两个代理`A.b_values`、`AtoB.b_value`进行查询：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`AssociationProxy.any()`在`A.c_values`上进行查询，以跨两个代理`A.c_values`、`AtoB.c_value`进行查询：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### Identity key enhancements
    to support sharding'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### 身份键增强以支持分片'
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ORM使用的身份键结构包含一个额外的成员，以便来自不同上下文的两个相同的主键可以共存于同一身份映射中。
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](../orm/examples.html#examples-sharding)中的示例已更新以说明这种行为。示例展示了一个分片类`WeatherLocation`，引用一个依赖的`WeatherReport`对象，其中`WeatherReport`类映射到一个存储简单整数主键的表。来自不同数据库的两个`WeatherReport`对象可能具有相同的主键值。该示例现在说明了一个新的`identity_token`字段跟踪这种差异，以便这两个对象可以共存于同一身份映射中：'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
- en: New Features and Improvements - Core
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - 核心
- en: '### Boolean datatype now enforces strict True/False/None values'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '### 布尔数据类型现在强制使用严格的True/False/None值'
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.1版本中，描述的更改[将非本地布尔整数值强制转换为零/一/None](migration_11.html#change-3730)产生了一个意外的副作用，改变了当[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")遇到非整数值（如字符串）时的行为。特别是，先前会生成值`False`的字符串值`"0"`，现在会产生`True`。更糟糕的是，行为的改变只针对某些后端而不是其他后端，这意味着将字符串`"0"`值发送给[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")的代码在各个后端上会不一致地中断。
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最终解决方案是**不支持字符串值与布尔值**，因此在1.2版本中，如果传递了非整数/True/False/None值，将引发严格的`TypeError`。此外，只接受整数值0和1。
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应希望对布尔值有更自由解释的应用程序，应使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。下面演示了一个配方，允许对1.1版本之前的[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型进行“自由”行为：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### Pessimistic disconnection
    detection added to the connection pool'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### 连接池中添加了悲观断开检测'
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池文档长期以来一直提供了一个使用[`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect")引擎事件在检出的连接上发出简单语句以测试其活动性的方法。现在，当与适当的方言一起使用时，此配方的功能已添加到连接池本身中。使用新参数[`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine")，每个检出的连接在返回之前都将被测试是否新鲜：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“预先ping”方法会在连接池检出时增加一点延迟，但对于典型的面向事务的应用程序（包括大多数ORM应用程序），这种开销是很小的，并且消除了获取到一个过时连接会引发错误的问题，需要应用程序放弃或重试操作。
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能**不**适用于在进行中的事务或SQL操作中断开的连接。如果应用程序必须从这些错误中恢复，它需要使用自己的操作重试逻辑来预期这些错误。
- en: See also
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[断开处理 - 悲观](../core/pooling.html#pool-disconnects-pessimistic)'
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### IN / NOT IN 运算符的空集合行为现在是可配置的；默认表达式简化了'
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`column.in_([])`这样的表达式，假定为false，现在默认产生表达式`1 != 1`，而不是`column != column`。这将**改变查询结果**，比较SQL表达式或列与空集合时，产生一个布尔值false或true（对于NOT
    IN），而不是NULL。在这种情况下发出的警告也被移除了。可以使用[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")参数来[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")获取旧的行为。
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，IN和NOT IN运算符不支持与明确为空的值集合进行比较；也就是说，这种语法是非法的：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，SQLAlchemy和其他数据库库检测到这种情况，并渲染一个替代表达式，该表达式评估为false，或者在NOT IN的情况下评估为true，基于“col
    IN ()”始终为false的理论，因为“空集合”中没有任何内容。通常，为了生成一个跨数据库可移植且在WHERE子句上下文中起作用的false/true常量，通常使用简单的重言式，如`1
    != 1`评估为false，`1 = 1`评估为true（简单的常量“0”或“1”通常不能作为WHERE子句的目标）。
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在早期也采用了这种方法，但很快有人推测SQL表达式`column IN ()`如果“column”为NULL，则不会评估为false；相反，该表达式会产生NULL，因为“NULL”表示“未知”，在SQL中与NULL的比较通常产生NULL。
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个结果，SQLAlchemy从使用`1 != 1`改为使用表达式`expr != expr`来处理空的“IN”，并使用`expr = expr`来处理空的“NOT
    IN”；也就是说，我们使用表达式的实际左侧而不是固定值。如果传递的表达式左侧求值为NULL，则整体比较结果也会得到NULL结果，而不是false或true。
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用户最终抱怨说这种表达式对一些查询规划器的性能影响非常严重。在那时，当遇到空的IN表达式时，会添加警告，建议SQLAlchemy继续保持“正确”，并敦促用户避免通常可以安全省略的生成空IN谓词的代码。然而，在动态构建查询的情况下，这当然会增加负担，因为输入变量的一组值可能为空。
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最近几个月，这个决定的最初假设受到了质疑。表达式“NULL IN ()”应该返回NULL的想法只是理论上的，无法测试，因为数据库不支持该语法。然而，事实证明，实际上可以通过模拟空集合来询问关系数据库对于“NULL
    IN ()”会返回什么值：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述测试，我们看到数据库本身无法就答案达成一致。大多数人认为最“正确”的数据库PostgreSQL返回False；因为即使“NULL”代表“未知”，“空集合”意味着没有任何内容，包括所有未知值。另一方面，MySQL和MariaDB对上述表达式返回NULL，采用更常见的“所有与NULL的比较都返回NULL”的行为。
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的SQL架构比在做出此设计决定时更复杂，因此现在可以在SQL字符串编译时调用任一行为。以前，转换为比较表达式是在构造时完成的，也就是说，在调用[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")或[`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_")运算符时。使用编译时行为，可以指示方言本身调用任一方法，即“static”`1
    != 1`比较或“dynamic”`expr != expr`比较。默认已被**更改**为“static”比较，因为这与PostgreSQL在任何情况下的行为一致，这也是绝大多数用户喜欢的。这将**改变查询结果**，特别是将空表达式与空集进行比较的查询，特别是查询否定`where(~null_expr.in_([]))`，因为现在这将评估为true而不是NULL。
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用标志[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")来控制行为，其默认设置为`"static"`，但也可以设置为`"dynamic"`或`"dynamic_warn"`，其中`"dynamic_warn"`设置等同于以前发出`expr
    != expr`以及性能警告的行为。然而，预计大多数用户会喜欢“static”默认设置。
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### Late-expanded IN
    parameter sets allow IN expressions with cached statements'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### 允许使用缓存语句的延迟扩展IN参数集合'
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种名为“expanding”的新类型[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")。这用于在语句执行时将元素列表渲染为单独的绑定参数，而不是在语句编译时。这允许将单个绑定参数名称链接到多个元素的IN表达式，同时还允许使用查询缓存与IN表达式。这一新功能允许相关功能“select
    in”加载和“polymorphic in”加载利用烘焙查询扩展来减少调用开销：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The feature should be regarded as **experimental** within the 1.2 series.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能在1.2系列中应被视为**实验性**。
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### Flattened operator
    precedence for comparison operators'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### 压平比较运算符的运算符优先级'
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像IN、LIKE、equals、IS、MATCH和其他比较运算符的运算符优先级已经被压平到一个级别。当比较运算符组合在一起时，将生成更多的括号，例如：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成`(q IS NULL) != (y IS NULL)`而不是`q IS NULL != y IS NULL`。
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### Support for SQL Comments
    on Table, Column, includes DDL, reflection'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### 支持在Table、Column上的SQL注释，包括DDL、反射'
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Core接收了与表和列关联的字符串注释的支持。这些通过[`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table")和[`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column")参数指定：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的DDL将在表创建时适当地呈现，以将上述注释与模式中的表/列关联起来。当上述表被autoload或使用[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")检查时，注释将被包含在内。表注释也可以独立使用[`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment")方法获得。
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当前后端支持包括MySQL，PostgreSQL和Oracle。
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### Multiple-table criteria
    support for DELETE'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### 支持多表条件的DELETE'
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    构造现在支持多表条件，已在支持的后端实现，目前支持的后端有PostgreSQL，MySQL和Microsoft SQL Server（对目前不工作的Sybase方言也添加了支持）。该功能的工作方式与0.7和0.8系列中首次引入的UPDATE的多表条件相同。'
- en: 'Given a statement as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个语句如下：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL后端上，上述语句的生成SQL将呈现为：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[多表删除](../tutorial/data_update.html#tutorial-multi-table-deletes)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### New “autoescape” option
    for startswith(), endswith()'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### 新的“autoescape”选项用于startswith()，endswith()'
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “autoescape”参数被添加到[`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")，[`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")，[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")。当设置为`True`时，此参数将自动转义所有出现的`%`、`_`，并使用默认的转义字符，默认为斜杠`/`；转义字符本身的出现也会被转义。斜杠用于避免与诸如PostgreSQL的`standard_confirming_strings`（从PostgreSQL
    9.1开始默认值已更改）和MySQL的`NO_BACKSLASH_ESCAPES`设置等设置发生冲突。现在可以使用现有的“escape”参数来更改自动转义字符，如果需要的话。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.2.0b2的初始实现到1.2.0，此功能已更改，现在autoescape被传递为布尔值，而不是用作转义字符的特定字符。
- en: 'An expression such as:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如一个表达式：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Renders as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染为：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 参数“x_1”的值为`'total/%score'`。
- en: 'Similarly, an expression that has backslashes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个带有反斜杠的表达式：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将以相同方式渲染，参数“x_1”的值为`'total//score'`。
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### Stronger typing added
    to “float” datatypes'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### “float”数据类型的强类型化'
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列更改允许使用[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")数据类型更强烈地将自己与Python浮点值联系起来，而不是更通用的[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")。这些更改主要与确保Python浮点值不会错误地被强制转换为`Decimal()`有关，并且在需要时被强制转换为`float`，如果应用程序正在处理普通浮点数。
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给SQL表达式的普通Python“float”值现在将被拉入具有类型[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")的文字参数；以前，类型为[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")，默认情况下“asdecimal=True”标志，这意味着结果类型将强制转换为`Decimal()`。特别是，这将在SQLite上发出令人困惑的警告：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")、[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")和[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")之间的数学运算现在会保留结果表达式的类型，包括`asdecimal`标志以及类型是否应该是[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果DBAPI已知支持本机`Decimal()`模式，则[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")数据类型将无条件地将`float()`处理器应用于结果值。一些后端不总是保证浮点数以纯浮点数而不是精确数值（如MySQL）的形式返回。
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
- en: Support for GROUPING SETS, CUBE, ROLLUP
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持GROUPING SETS、CUBE、ROLLUP
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的GROUPING SETS、CUBE、ROLLUP都可以通过`func`命名空间访问。在CUBE和ROLLUP的情况下，这些函数在之前的版本中已经可以使用，但是对于GROUPING
    SETS，编译器中添加了一个占位符以便为其腾出空间。现在文档中已经命名了这三个函数：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用于具有上下文默认生成器的多值插入的参数助手'
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认生成函数，例如在[上下文敏感默认函数](../core/defaults.html#context-default-functions)中描述的函数，可以通过[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") 属性查看与语句相关的当前参数。然而，在通过[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法指定多个VALUES子句的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造中，用户定义的函数会被多次调用，每个参数集一次，但是没有办法知道[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") 中的哪些键子集适用于该列。添加了一个新函数[`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters")，其中包括一个关键字参数[`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") 默认为`True`，它执行额外的工作，提供一个[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") 的子字典，其中的名称被本地化为当前正在处理的VALUES子句：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
- en: Key Behavioral Changes - ORM
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键行为更改 - ORM
- en: '### The after_rollback() Session event now emits before the expiration of objects'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在对象过期之前，`after_rollback()` 会话事件现在会发出'
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") 事件现在可以访问对象的属性状态，而不是在它们的状态被过期之前（例如，“快照删除”）。这使得该事件与[`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") 事件的行为保持一致，后者也会在“快照”被删除之前发出：'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仍将禁止在此事件中发出 SQL；这意味着未加载的属性仍然无法在事件范围内加载。
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### Fixed issue involving
    single-table inheritance with `select_from()`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### 修复了与 `select_from()`
    结合使用单表继承的问题'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成 SQL 时，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 方法现在将遵循单表继承列鉴别器；以前，仅查询列列表中的表达式会被考虑进去。
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Manager` 是 `Employee` 的子类。像以下这样的查询：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Would generate SQL as:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的 SQL 如下：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果仅在列列表中指定了 `Manager`，而没有在 [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 中指定，那么将不会添加鉴别器：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'would generate:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成如下：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此修复，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 现在可以正确工作，我们可以得到：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可能已经通过手动提供 WHERE 子句来解决此问题的应用程序可能需要进行调整。
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### Previous collection
    is no longer mutated upon replacement'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### 替换集合时，先前的集合不再发生变化'
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射的集合成员发生更改时，ORM 会发出事件。在将集合分配给将替换先前集合的属性时，这样做的副作用是被替换的集合也将被改变，这是误导性和不必要的：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述更改之前，`previous_collection` 将已删除 “a1” 成员，对应于不再存在于新集合中的成员。
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### A @validates method
    receives all values on bulk-collection set before comparison'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### 在进行批量集合设置之前，@validates
    方法接收所有值'
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在“批量设置”操作期间，使用 `@validates` 的方法现在将接收到集合的所有成员，然后再对现有集合进行比较。
- en: 'Given a mapping as:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 给定映射如下：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，我们可以按照以下方式使用验证器，在集合附加时将传入的字典转换为 `B` 的实例：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，集合赋值将失败，因为 ORM 将假定传入的对象已经是 `B` 的实例，因此在进行集合成员比较之前，它将尝试将它们与现有集合成员进行比较，然后执行实际调用验证器的集合附加操作。这将使得批量设置操作无法适应需要提前修改的非
    ORM 对象，如需要提前修改的字典：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 新逻辑使用新的 [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") 事件确保所有值在开始时发送到 `@validates` 函数。
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此更改的一部分，这意味着验证器现在将在批量设置时接收**所有**集合成员，而不仅仅是新成员。假设一个简单的验证器如下：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Above, if we began with a collection as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，如果我们从一个集合开始：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And then, replaced the collection with one that overlaps the first:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用与第一个重叠的集合替换了该集合：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，第二个赋值将仅触发一次 `A.validate_b` 方法，对于 `b3` 对象。`b2` 对象将被视为已经存在于集合中并且不受验证。采用新行为后，`b2`
    和 `b3` 都会在传递到集合之前传递给 `A.validate_b`。因此，验证方法必须采用幂等行为以适应这种情况。
- en: See also
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[New bulk_replace event](#change-3896-event)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[新的 bulk_replace 事件](#change-3896-event)'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### Use flag_dirty()
    to mark an object as “dirty” without any attribute changing'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### 使用 flag_dirty() 将对象标记为“脏”，而不改变任何属性'
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") 函数标记一个实际未加载的属性为已修改，则现在会引发异常：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果属性在冲刷发生时仍然未出现，则刷新过程很可能无论如何都会失败。要将对象标记为“修改”，而不具体引用任何属性，以便在自定义事件处理程序（如 [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")）中考虑到刷新过程，请使用新的 [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") 函数：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### “scope” keyword removed
    from scoped_session'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### 从 scoped_session
    中删除“scope”关键字'
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老且未记录的关键字参数 `scope` 已被删除：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此关键字的目的是尝试允许可变“范围”，其中 `None` 表示“无范围”，因此将返回一个新的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。此关键字从未被文档化，并且现在如果遇到将会引发 `TypeError`。尽管不预期使用此关键字，但如果用户在测试期间报告与此相关的问题，则可以通过弃用来恢复。
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### Refinements to post_update
    in conjunction with onupdate'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### 与 onupdate 结合使用的
    post_update 的细化'
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") 功能的关系现在将更好地与设置了 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 值的列进行交互。如果对象插入了列的显式值，则在更新期间重新声明它，以便“onupdate”规则不会覆盖它：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，以前的行为是在INSERT之后发出UPDATE，从而触发“onupdate”并覆盖值“5”。现在的SQL看起来像这样：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果“updated”的值*未*设置，那么我们将会正确地在`a1.updated`上获取到新生成的值；以前，刷新或使属性过期以允许生成的值出现的逻辑不会对post-update触发。在这种情况下，当刷新flush内发生时，也会触发[`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush")事件。
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update integrates
    with ORM versioning'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update与ORM版本控制集成'
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: post_update功能，文档中记录在[指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)，涉及到对特定与关系绑定的外键的更改而发出UPDATE语句，除了针对目标行通常会发出的INSERT/UPDATE/DELETE。这个UPDATE语句现在参与版本控制功能，文档记录在[配置版本计数器](../orm/versioning.html#mapper-version-counter)。
- en: 'Given a mapping:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于一个映射：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 更新将另一个节点关联为“favorite”的节点现在也将增加版本计数器，并匹配当前版本：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这意味着一个对象在响应其他属性变化而接收到UPDATE，并且由于post_update关系变化而收到第二个UPDATE，现在将会**为一个flush接收到两次版本计数更新**。然而，如果对象在当前flush内受到INSERT，版本计数**将不会**额外增加一次，除非服务器端采用了版本控制方案。
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在讨论post_update即使对于UPDATE也会发出UPDATE的原因在[为什么post_update除了第一个UPDATE之外还会发出UPDATE？](../faq/sessions.html#faq-post-update-update)。
- en: See also
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)'
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么post_update除了第一个UPDATE之外还会发出UPDATE？](../faq/sessions.html#faq-post-update-update)'
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
- en: Key Behavioral Changes - Core
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为更改 - 核心
- en: '### The typing behavior of custom operators has been made consistent'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义运算符的类型行为已经变得一致'
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")函数即时制作用户定义的运算符。以前，针对这样的运算符的表达式的类型行为是不一致的，也是不可控的。
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 而在1.1中，以下表达式将产生没有返回类型的结果（假设`-%>`是数据库支持的某个特殊运算符）：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型将使用使用左侧类型作为返回类型的默认行为：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为大多是偶然发生的，因此行为已经与第二种形式保持一致，即默认返回类型与左侧表达式相同：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数用户定义的运算符往往是“比较”运算符，通常是由 PostgreSQL 定义的许多特殊运算符之一，[`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") 标志已经修复，遵循其文档化行为，允许返回类型在所有情况下都是 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")，包括对于 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 和 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了辅助布尔比较运算符，新增了一个新的简写方法 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")。这个方法应该优先用于即时布尔运算符：
- en: '[PRE61]  ### Percent signs in literal_column() now conditionally escaped'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE61]  ### literal_column() 中的百分号现在有条件地转义'
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 构造现在根据使用的 DBAPI 是否使用了百分号敏感的参数风格（例如‘format’或‘pyformat’）有条件地转义百分号字符。'
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，无法生成一个声明单个百分号的 [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 构造：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号现在不受未设置为使用‘format’或‘pyformat’参数风格的方言的影响；大多数 MySQL 方言等声明了其中一个参数风格的方言将继续适当地转义：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，使用像 [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")、[`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") 和 [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") 这样的运算符时，现在只在适当时才会发生加倍。
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### The column-level
    COLLATE keyword now quotes the collation name'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### 列级别的 COLLATE 关键字现在引用排序规则名称'
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了在[`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate")和[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate")函数中的一个错误，用于在语句级别提供临时列排序规则，其中区分大小写的名称不会被引用：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'now renders:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，区分大小写的名称“fr_FR”不会被引用。目前，手动引用“fr_FR”名称**不会**被检测到，因此手动引用标识符的应用程序应进行调整。请注意，此更改不影响在类型级别使用排序规则（例如在数据类型上指定的[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")在表级别），其中已经应用了引用。
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - PostgreSQL
- en: '### Support for Batch Mode / Fast Execution Helpers'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持批处理模式 / 快速执行助手'
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 已确定 psycopg2 的 `cursor.executemany()` 方法性能较差，特别是在 INSERT 语句中。为了缓解这一问题，psycopg2
    添加了[快速执行助手](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)，通过将多个
    DML 语句批量发送，将语句重新组织为更少的服务器往返次数。SQLAlchemy 1.2 现在包括对这些助手的支持，以便在 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 使用 `cursor.executemany()` 对多个参数集调用语句时，可以透明地使用这些助手。该功能默认关闭，可以通过在
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    上使用 `use_batch_mode` 参数来启用：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 目前该功能被视为��验性质，但可能在将来的版本中默认开启。
- en: See also
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2 快速执行助手](../dialects/postgresql.html#psycopg2-batch-mode)'
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### Support for fields
    specification in INTERVAL, including full reflection'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### 支持 INTERVAL 中字段规范的指定，包括完整反射'
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的 INTERVAL 数据类型中的“fields”规范允许指定要存储的间隔的字段，包括诸如“YEAR”、“MONTH”、“YEAR
    TO MONTH”等值。 [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") 数据类型现在允许指定这些值：
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在所有 INTERVAL 数据类型都可以独立于“fields”规范进行反射；数据类型本身中的“fields”参数也将存在：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - MySQL
- en: '### Support for INSERT..ON DUPLICATE KEY UPDATE'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 INSERT..ON DUPLICATE KEY UPDATE'
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 支持的 `INSERT` 的 `ON DUPLICATE KEY UPDATE` 子句现在可以使用 MySQL 特定版本的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 对象来支持，通过 `sqlalchemy.dialects.mysql.dml.insert()`。这个
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    子类添加了一个新方法 `Insert.on_duplicate_key_update()`，实现了 MySQL 的语法：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The above will render:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以上将呈现为：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - Oracle
- en: '### Major Refactor to cx_Oracle Dialect, Typing System'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '### cx_Oracle 方言、类型系统的重大重构'
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 cx_Oracle DBAPI 的 6.x 系列的引入，SQLAlchemy 的 cx_Oracle 方言已经重新设计和简化，以利用 cx_Oracle
    的最新改进，并放弃了在 cx_Oracle 的 5.x 系列之前更相关的模式支持。
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的最低 cx_Oracle 版本现在是 5.1.3；推荐使用 5.3 或最新的 6.x 系列。
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的处理已经重构。根据 cx_Oracle 的开发人员建议，`cursor.setinputsizes()` 方法不再用于除 LOB 类型之外的任何数据类型。因此，参数
    `auto_setinputsizes` 和 `exclude_setinputsizes` 已被弃用，也不再起作用。
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将 `coerce_to_decimal` 标志设置为 False 以指示不应发生具有精度和标度的数值类型到 `Decimal` 的强制转换时，仅影响未经类型化的语句（例如，没有
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    对象的普通字符串）。包含 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    类型或子类型的 Core 表达式现在将遵循该类型的十进制强制转换规则。
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “两阶段”事务支持在方言中已经在 cx_Oracle 的 6.x 系列中被删除，现在已完全移除，因为这个功能从未正确工作过，也不太可能被投入生产使用。因此，`allow_twophase`
    方言标志已被弃用，也不再起作用。
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了涉及带有 RETURNING 的列键的 bug。给定如下语句：
- en: '[PRE71]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，结果中每行的键将是 `ret_0` 和 `ret_1`，这是 cx_Oracle RETURNING 实现内部的标识符。现在键将是 `a` 和 `b`，与其他方言的预期相符。
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_Oracle 的 LOB 数据类型将返回值表示为 `cx_Oracle.LOB` 对象，这是一个与游标关联的代理，通过`.read()` 方法返回最终数据值。从历史上看，如果在消耗这些
    LOB 对象之前读取了更多行（具体来说，读取了比 cursor.arraysize 值更多的行，这会导致读取新批次的行），这些 LOB 对象将引发错误“在后续获取后
    LOB 变量不再有效”。SQLAlchemy 通过其类型系统自动调用这些 LOB 的`.read()`，以及使用特殊的 `BufferedColumnResultSet`
    来解决这个问题，该结果集将确保在使用`cursor.fetchmany()` 或 `cursor.fetchall()` 这样的调用时，这些数据被缓冲。
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方言现在使用 cx_Oracle outputtypehandler 来处理这些`.read()` 调用，以便无论获取多少行，它们始终被提前调用，因此不再会发生此错误。因此，`BufferedColumnResultSet`
    的使用，以及一些其他特定于此用例的 Core `ResultSet` 内部部分已被移除。由于类型对象不再需要处理二进制列结果，因此它们也变得更简化。
- en: 'Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.  ### Oracle Unique, Check constraints now reflected'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，cx_Oracle 6.x 已删除了发生此错误的任何情况，因此不再可能发生错误。如果在使用极少（如果有的话）使用的 `auto_convert_lobs=False`
    选项的情况下，与先前的 5.x 系列 cx_Oracle 结合使用，并且在 LOB 对象可以被消耗之前读取了更多行，则可能会在 SQLAlchemy 中发生此错误。升级到
    cx_Oracle 6.x 将���决此问题。### Oracle Unique, Check 约束现在反映出来
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: UNIQUE 和 CHECK 约束现在通过[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 和 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 反映出来。被反映的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象现在也将包括[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") 对象。有关此处行为怪癖的信息，请参阅[约束反射](../dialects/oracle.html#oracle-constraint-reflection)，包括大多数[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象仍然不会包括任何[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 对象，因为这些通常通过[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 表示。
- en: See also
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[约束反射](../dialects/oracle.html#oracle-constraint-reflection)'
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle foreign key
    constraint names are now “name normalized”'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle 外键约束名称现在是“名称标准化”'
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在表反射期间传递给 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象的外键约束名称以及在 [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") 方法中，现在将被“名称标准化”，即，以小写形式表示以进行大小写不敏感的名称，而不是
    Oracle 使用的原始大写格式：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Previously, the foreign keys result would look like:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，外键结果看起来像：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Where the above could create problems particularly with Alembic autogenerate.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述可能会特别与 Alembic autogenerate 创建问题。
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - SQL Server
- en: '### SQL Server schema names with embedded dots supported'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持带有嵌入点的 SQL Server 模式名称'
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 方言具有这样的行为，即假定具有其中一个点的模式名称是“数据库”。“所有者”标识符对，这在表和组件反射操作以及在呈现模式名称的引号时必须将这两个符号分开时会被分开。现在可以使用括号传递模式参数以手动指定此拆分发生的位置，从而允许数据库和/或所有者名称本身包含一个或多个点：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 上表将考虑“所有者”为 `MyDataBase.dbo`，在呈现时也将被引用，并且“数据库”为 None。要单独引用数据库名称和所有者，请使用两对括号：
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当传递给 SQL Server 方言的“模式”时，现在将尊重 [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") 构造；如果引号标志为 True，则给定的符号不会在点上拆分，并且将被解释为“所有者”。
- en: See also
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[多部分模式名称](../dialects/mssql.html#multipart-schema-names)'
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
- en: AUTOCOMMIT isolation level support
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AUTOCOMMIT 隔离级别支持
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 PyODBC 和 pymssql 方言都支持由 [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") 设置的“AUTOCOMMIT”隔离级别，这将在 DBAPI
    连接对象上建立正确的标志。
- en: Introduction
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.2, and also documents
    changes which affect users migrating their applications from the 1.1 series of
    SQLAlchemy to 1.2.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 1.2 中的新功能，并记录了影响从 SQLAlchemy 1.1 系列迁移其应用程序的用户的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为变化部分，可能会对行为产生不兼容的变化。
- en: Platform Support
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.7 and Up
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对 Python 2.7 及更高版本
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.2 现在将最低 Python 版本提升至 2.7，不再支持 2.6。预计将合并到 1.2 系列中的新语言特性在 Python
    2.6 中不受支持。对于 Python 3 的支持，SQLAlchemy 目前在 3.5 和 3.6 版本上进行测试。
- en: Targeting Python 2.7 and Up
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对 Python 2.7 及更高版本
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.2 现在将最低 Python 版本提升至 2.7，不再支持 2.6。预计将合并到 1.2 系列中的新语言特性在 Python
    2.6 中不受支持。对于 Python 3 的支持，SQLAlchemy 目前在 3.5 和 3.6 版本上进行测试。
- en: New Features and Improvements - ORM
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: '### “Baked” loading now the default for lazy loads'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '### “Baked” 加载现在是懒加载的默认选项'
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") 扩展首次引入于 1.0 系列，允许构建所谓的[`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery")对象，该对象与表示查询结构的缓存键一起生成[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象；然后将此缓存键链接到生成的字符串 SQL 语句，以便后续使用具有相同结构的另一个[`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery")将绕过构建[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象、构建其中的核心[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")对象，以及将[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")编译为字符串的所有开销，从而削减通常与构建和发出 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象相关的大部分函数调用开销。'
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") 现在在 ORM 默认情况下用于生成“延迟”查询，用于懒加载[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造，例如默认的`lazy="select"`关系加载策略。这将显著减少应用程序在使用懒加载查询加载集合和相关对象时的函数调用。此功能以前在
    1.0 和 1.1 中通过使用全局 API 方法或使用`baked_select`策略可用，现在是此行为的唯一实现。该功能还得到改进，使得对于具有懒加载后生效的其他加载器选项的对象仍然可以进行缓存。'
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") 标志在每个关系基础上禁用缓存行为，这对于非常罕见的情况非常有用，例如使用不兼容缓存的自定义 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 实现的关系。
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### New “selectin” eager
    loading, loads all collections at once using IN'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### 新的“selectin”急加载，一次性使用
    IN 加载所有集合'
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个名为“selectin”加载的新急加载器，这在许多方面类似于“子查询”加载，但生成的 SQL 语句更简单，可缓存且更高效。
- en: 'Given a query as below:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下查询：
- en: '[PRE76]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 将是针对 `User` 的查询，然后是 `User.addresses` 的 subqueryload（请注意还列出了参数）：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“selectin”加载，我们实际上得到了一个引用父查询中加载的实际主键值的 SELECT：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Produces:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The above SELECT statement includes these advantages:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 SELECT 语句包括以下优点：
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不使用子查询，只是一个 INNER JOIN，这意味着在像 MySQL 这样不喜欢子查询的数据库上性能会更好
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其结构独立于原始查询；与新的 [扩展 IN 参数系统](#change-3953) 结合使用，我们在大多数情况下可以使用“烘焙”查询来缓存字符串 SQL，从而显著减少每个查询的开销。
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为查询仅获取给定主键标识符列表，“selectin”加载可能与 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 兼容，以便一次处理 SELECT 结果的块，前提是数据库驱动程序允许多个同时游标（SQLite、PostgreSQL；**不**是
    MySQL 驱动程序或 SQL Server ODBC 驱动程序）。联接急加载和子查询急加载都不兼容 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")。
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 选择急加载的缺点可能是潜在的大型 SQL 查询，带有大量的 IN 参数列表。 IN 参数列表本身被分组为 500 个一组，因此超过 500 个结果对象的结果集将有更多额外的“SELECT
    IN”查询。此外，对复合主键的支持取决于数据库是否能够使用带有 IN 的元组，例如 `(table.column_one, table_column_two)
    IN ((?, ?), (?, ?) (?, ?))`。目前，已知 PostgreSQL 和 MySQL 兼容此语法，而 SQLite 不兼容。
- en: See also
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[Select IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading)'
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” polymorphic
    loading, loads subclasses using separate IN queries'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” 多态加载，使用单独的
    IN 查询加载子类'
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 与刚刚在[新“selectin” eager loading, loads all collections at once using IN](#change-3944)中描述的“selectin”关系加载功能类似的是“selectin”多态加载。这是一种专为连接式的急加载定制的多态加载功能，允许基本实体的加载通过简单的SELECT语句进行，但是额外的子类属性使用额外的SELECT语句加载：
- en: '[PRE80]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: See also
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### ORM attributes that
    can receive ad-hoc SQL expressions'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### 可接收临时 SQL 表达式的 ORM
    属性'
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了一个ORM属性类型[`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression")，与[`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")类似，但其SQL表达式在查询时确定，使用新选项[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")；如果未指定，属性默认为`None`：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: See also
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询时的 SQL 表达式作为映射属性](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM Support of multiple-table
    deletes'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM 支持多表删除'
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法支持多表条件的删除，如[多表条件支持的删除](#change-959)中所介绍的。该功能的工作方式与更新的多表条件相同，最初在0.8版本中引入，并在[Query.update()支持UPDATE..FROM](migration_08.html#change-orm-2365)中描述。
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们对`SomeEntity`发出一个DELETE请求，添加一个FROM子句（或者等效的，根据后端不同）对`SomeOtherEntity`进行操作：
- en: '[PRE82]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: See also
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[多表条件支持的删除](#change-959)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### Support for bulk updates
    of hybrids, composites'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### 支持混合、复合的批量更新'
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，混合属性（例如[`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")）以及复合属性（[复合列类型](../orm/composites.html#mapper-composite)）在使用[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")更新语句的SET子句中均得到支持。
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混合属性，可以直接使用简单的表达式，或者可以使用新的装饰器[`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression")将值拆分为多个列/表达式：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Above, an UPDATE can be rendered using:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，可以使用以下方式渲染UPDATE：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的功能也适用于复合属性，其中复合值将被拆分为其各个列以进行批量更新：
- en: '[PRE85]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See also
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)  ###
    Hybrid attributes support reuse among subclasses, redefinition of @getter'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[允许批量ORM更新](../orm/extensions/hybrid.html#hybrid-bulk-update)  ### 混合属性支持在子类之间重用，重新定义@getter'
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")类现在支持在子类之间多次调用像`@setter`、`@expression`等的变异器，并且现在提供了一个`@getter`变异器，以便特定的混合属性可以在子类或其他类之间重新使用。这与标准Python中`@property`的行为类似：'
- en: '[PRE86]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`FirstNameOnly.name`混合属性被`FirstNameLastName`子类引用，以便将其专门用于新子类。这是通过在每次调用`@getter`、`@setter`以及所有其他变异器方法像`@expression`中复制混合对象到新对象来实现的，从而保持先前混合属性的定义不变。以前，像`@setter`这样的方法会直接修改现有的混合属性，干扰了超类上的定义。
- en: Note
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读[在子类之间重用混合属性](../orm/extensions/hybrid.html#hybrid-reuse-subclass)的文档，了解如何覆盖[`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression")和[`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator")的重要注意事项，因为在某些情况下，可能需要使用特殊限定符[`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides")来避免与[`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute")发生名称冲突。
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`@hybrid_property`中的这种变化意味着，当向`@hybrid_property`添加setter和其他状态时，**方法必须保留原始混合属性的名称**，否则具有附加状态的新混合属性将以不匹配的名称存在于类中。这与标准Python中的`@property`构造的行为相同：'
- en: '[PRE87]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### New bulk_replace
    event'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### 新的bulk_replace事件'
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应[A @validates method receives all values on bulk-collection set before comparison](#change-3896-validates)中描述的验证用例，添加了一个新的[`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace")方法，该方法与[`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append")和[`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove")事件一起调用。在比较现有集合之前调用“bulk_replace”，以便可以修改集合。之后，单个项目将附加到新的目标集合，触发为集合中的新项目触发的“append”事件，这与以前的行为相同。下面同时说明了“bulk_replace”和“append”，包括如果使用集合赋值，“append”将接收到已由“bulk_replace”处理的对象。新符号`attributes.OP_BULK_REPLACE`可以用于确定此“append”事件是否是批量替换的第二部分：
- en: '[PRE88]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### New “modified” event
    handler for sqlalchemy.ext.mutable'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### 为sqlalchemy.ext.mutable添加了新的“modified”事件处理程序'
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的事件处理程序[`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified")，该处理程序在对[`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified")方法的调用时触发，通常是从[`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable")扩展调用的。
- en: '[PRE89]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 上述事件处理程序将在对`.data`字典进行就地更改时触发。
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### Added “for update”
    arguments to Session.refresh'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### 添加了对Session.refresh的“for
    update”参数'
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新参数[`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh")到[`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")方法。当`Query.with_lockmode()`方法被弃用，而倾向于[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")时，[`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")方法从未更新以反映新选项：
- en: '[PRE90]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh")参数现在接受一个选项字典，该字典将作为发送给[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")的相同参数：'
- en: '[PRE91]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数取代了[`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh")参数。
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### In-place mutation
    operators work for MutableSet, MutableList'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### 就地变异操作符适用于MutableSet、MutableList'
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet")，我们实现了就地变异操作符`__ior__`、`__iand__`、`__ixor__`和`__isub__`，以及对于[`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList")的`__iadd__`。虽然这些方法以前可以成功地更新集合，但它们不会正确地触发更改事件。这些操作符像以前一样改变集合，但额外地发出了正确的更改事件，以便更改成为下一个刷新进程的一部分：
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    any(), has(), contains() work with chained association proxies'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    any()、has()、contains()可以与链式关联代理一起使用'
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssociationProxy.any()`、`AssociationProxy.has()`和`AssociationProxy.contains()`比较方法现在支持链接到一个属性，该属性本身也是一个[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，递归地。在下面的示例中，`A.b_values`是一个关联到`AtoB.bvalue`的关联代理，它本身是一个关联到`B`的关联代理：'
- en: '[PRE93]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AssociationProxy.contains()`在`A.b_values`上进行查询，以跨越两个代理`A.b_values`，`AtoB.b_value`：
- en: '[PRE94]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`AssociationProxy.any()`在`A.c_values`上进行查询，以跨越两个代理`A.c_values`，`AtoB.c_value`：
- en: '[PRE95]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### Identity key enhancements
    to support sharding'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### 标识键增强以支持分片'
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ORM使用的标识键结构包含了一个额外的成员，以便来自不同上下文的两个相同的主键可以共存于同一个标识映射中。
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](../orm/examples.html#examples-sharding) 中的示例已更新以说明此行为。该示例显示了一个分片类 `WeatherLocation`，引用一个依赖的
    `WeatherReport` 对象，其中 `WeatherReport` 类映射到一个存储简单整数主键的表。来自不同数据库的两个 `WeatherReport`
    对象可能具有相同的主键值。该示例现在说明了一个新的 `identity_token` 字段跟踪此差异，以便这两个对象可以共存于同一标识映射中：'
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)  ### “Baked” loading now
    the default for lazy loads'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)  ### “烘焙”加载现在是延迟加载的默认设置'
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") 扩展首次在1.0系列中引入，允许构建所谓的 [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") 对象，该对象生成一个与表示查询结构的缓存键相关联的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象；然后将此缓存键链接到生成的字符串SQL语句，以便后续使用具有相同结构的另一个 [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") 将绕过构建 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象的所有开销，构建其中的核心 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 对象，以及将 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 编译为字符串，从而削减通常与构建和发出ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象相关的大部分函数调用开销。'
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM生成“延迟”查询以懒加载 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造时，默认现在使用 [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery")，例如默认的 `lazy="select"` 关系加载器策略。这将显著减少应用程序使用延迟加载查询加载集合和相关对象时的函数调用数量。以前，此功能在1.0和1.1中通过使用全局API方法或使用
    `baked_select` 策略可用，现在是此行为的唯一实现。该功能还得到改进，使得对于具有延迟加载后生效的其他加载器选项的对象仍然可以进行缓存。
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") 标志在每个关系基础上禁用缓存行为，这对于非常不寻常的情况非常有用，例如使用不兼容缓存的自定义
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    实现的关系。
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)'
- en: '### New “selectin” eager loading, loads all collections at once using IN'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 “selectin” 急切加载，一次加载所有集合使用 IN'
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个名为 “selectin” 加载的新急切加载器，从许多方面来看，它类似于 “subquery” 加载，但是生成了一个更简单的可缓存的 SQL
    语句，而且更有效率。
- en: 'Given a query as below:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下查询：
- en: '[PRE97]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 将是针对 `User` 的查询，然后是 `User.addresses` 的 subqueryload（注意还列出了参数）：
- en: '[PRE98]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 “selectin” 加载，我们得到���是一个 SELECT，它引用了在父查询中加载的实际主键值：
- en: '[PRE99]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Produces:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE100]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The above SELECT statement includes these advantages:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 SELECT 语句包括以下优点：
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不使用子查询，只是一个 INNER JOIN，这意味着在像 MySQL 这样不喜欢子查询的数据库上性能会更好
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其结构独立于原始查询；与新的 [扩展 IN 参数系统](#change-3953) 结合，我们在大多数情况下可以使用 “baked” 查询来缓存字符串
    SQL，显著减少每个查询的开销
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于查询仅为给定的主键标识符列表获取数据，“selectin” 加载可能与 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 兼容，以便一次操作 SELECT 结果的一部分，前提是数据库驱动程序允许多个同时游标（SQLite，PostgreSQL；**不**是
    MySQL 驱动程序或 SQL Server ODBC 驱动程序）。联接式急切加载和子查询急切加载都不兼容 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")。
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: selectin 急切加载的缺点是潜在的大型 SQL 查询，具有大量的 IN 参数列表。 IN 参数列表本身被分组为 500 个一组，因此超过 500
    个 lead 对象的结果集将有更多的附加 “SELECT IN” 查询。此外，对复合主键的支持取决于数据库是否能够使用带有 IN 的元组，例如 `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`。目前，已知 PostgreSQL 和 MySQL 兼容此语法，SQLite
    不兼容。
- en: See also
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading)'
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)'
- en: '### “selectin” polymorphic loading, loads subclasses using separate IN queries'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '### “selectin” 多态加载，使用单独的 IN 查询加载子类'
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 与刚刚在[新的“selectin”急加载，使用IN一次加载所有集合](#change-3944)中描述的“selectin”关系加载功能类似的是“selectin”多态加载。这是一个主要针对连接式急加载的多态加载功能，允许基本实体的加载通过简单的SELECT语句进行，然后额外子类的属性通过额外的SELECT语句进行加载：
- en: '[PRE101]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: See also
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)'
- en: '### ORM attributes that can receive ad-hoc SQL expressions'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可接收临时SQL表达式的ORM属性'
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ORM属性类型[`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression")被添加，类似于[`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")，不同之处在于其SQL表达式在查询时使用新选项[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")确定；如果未指定，则属性默认为`None`：
- en: '[PRE102]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: See also
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询时SQL表达式作为映射属性](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)'
- en: '### ORM Support of multiple-table deletes'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM支持多表删除'
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法支持多表条件的DELETE，就像在[支持多表条件的DELETE](#change-959)中介绍的那样。该功能与0.8中首次引入的UPDATE的多表条件相同，详细描述在[Query.update()支持UPDATE..FROM](migration_08.html#change-orm-2365)中。
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们对`SomeEntity`执行一个DELETE操作，添加一个FROM子句（或等效的，取决于后端）对`SomeOtherEntity`：
- en: '[PRE103]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: See also
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持多表条件的DELETE](#change-959)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
- en: '### Support for bulk updates of hybrids, composites'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持混合属性，复合属性的批量更新'
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 混合属性（例如[`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")）以及复合属性（[复合列类型](../orm/composites.html#mapper-composite)）现在都支持在使用[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")时用于UPDATE语句的SET子句中。
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混合属性，可以直接使用简单表达式，或者可以使用新的装饰器[`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression")将一个值分解为多个列/表达式：
- en: '[PRE104]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Above, an UPDATE can be rendered using:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，一个UPDATE可以使用以下方式呈现：
- en: '[PRE105]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的功能也适用于复合类型，其中复合值将被拆分为其各个列以进行批量更新：
- en: '[PRE106]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: See also
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[允许批量ORM更新](../orm/extensions/hybrid.html#hybrid-bulk-update)'
- en: '### Hybrid attributes support reuse among subclasses, redefinition of @getter'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '### 混合属性支持在子类之间重用，重新定义 @getter'
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") 类现在支持在子类之间多次调用修改器，如 `@setter`、`@expression`
    等，并且现在提供了一个 `@getter` 修改器，以便可以在子类或其他类之间重新用特定的混合属性。这与标准 Python 中 `@property` 的行为类似：'
- en: '[PRE107]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`FirstNameOnly.name` 混合属性被 `FirstNameLastName` 子类引用，以便将其专门重新用于新的子类。这是通过在每次调用
    `@getter`、`@setter` 以及所有其他修改器方法（如 `@expression`）中将混合对象复制到一个新对象中来实现的，从而保持先前混合属性的定义不变。以前，像
    `@setter` 这样的方法会就地修改现有的混合属性，干扰了超类上的定义。
- en: Note
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读[在子类之间重用混合属性](../orm/extensions/hybrid.html#hybrid-reuse-subclass)的文档，了解如何覆盖[`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") 和 [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator") 的重要注意事项，因为在某些情况下可能需要一个特殊的限定符
    [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") 来避免与 [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") 的名称冲突。
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对 `@hybrid_property` 的更改意味着，当向 `@hybrid_property` 添加 setter 和其他状态时，**方法必须保留原始混合属性的名称**，否则新的带有额外状态的混合属性将以不匹配的名称存在于类中。这与标准
    Python 中 `@property` 的行为相同：
- en: '[PRE108]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)'
- en: '### New bulk_replace event'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 bulk_replace 事件'
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 [在批量集合设置之前比较时，@validates 方法接收所有值](#change-3896-validates) 中描述的验证用例，添加了一个新的
    [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") 方法，它与 [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") 和 [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") 事件一起调用。“bulk_replace” 在 “append” 和 “remove”
    之前调用，以便在比较现有集合之前修改集合。之后，单个项目将被附加到新的目标集合，触发针对集合中新项目的 “append” 事件，就像以前的行为一样。下面同时说明了
    “bulk_replace” 和 “append”，包括如果使用集合赋值，“append” 将接收到已由 “bulk_replace” 处理过的对象的情况。新的符号
    `attributes.OP_BULK_REPLACE` 可以用于确定此 “append” 事件是否是批量替换的第二部分：
- en: '[PRE109]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
- en: '### New “modified” event handler for sqlalchemy.ext.mutable'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 sqlalchemy.ext.mutable 的“modified”事件处理器'
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 新的事件处理器 [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") 被添加了，它会在调用 [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") 方法时触发，通常这个方法是从 [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") 扩展中调用的：
- en: '[PRE110]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的事件处理程序将在对 `.data` 字典进行原位更改时触发。
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)'
- en: '### Added “for update” arguments to Session.refresh'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加了“for update”参数到 Session.refresh'
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 向 [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法添加了新参数 [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh")。当 `Query.with_lockmode()` 方法被弃用，改用 [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") 后，[`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法从未更新以反映新选项：
- en: '[PRE111]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") 参数接受一个选项字典，这些选项将作为传递给 [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") 的相同参数：'
- en: '[PRE112]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数取代了 [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") 参数。
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)'
- en: '### In-place mutation operators work for MutableSet, MutableList'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可变集合 `MutableSet` 和 可变列表 `MutableList` 支持原地变异操作符'
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 为 [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") 实现了原地变异操作符 `__ior__`、`__iand__`、`__ixor__`
    和 `__isub__`，以及为 [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") 实现了 `__iadd__`。虽然这些方法以前可以成功更新集合，但它们不会正确触发更改事件。这些操作符像以前一样改变集合，但另外会发出正确的更改事件，以便更改成为下一个刷新过程的一部分：
- en: '[PRE113]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)'
- en: '### AssociationProxy any(), has(), contains() work with chained association
    proxies'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '### `AssociationProxy` 的 `any()`、`has()` 和 `contains()` 方法可以与链式关联代理一起使用'
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssociationProxy.any()`、`AssociationProxy.has()` 和 `AssociationProxy.contains()`
    比较方法现在支持链接到一个属性，该属性本身也是一个 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，递归地。下面，`A.b_values` 是一个关联代理，链接到
    `AtoB.bvalue`，而 `AtoB.bvalue` 本身是一个关联代理，链接到 `B`：'
- en: '[PRE114]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `AssociationProxy.contains()` 在 `A.b_values` 上进行查询，以跨越两个代理 `A.b_values`、`AtoB.b_value`：
- en: '[PRE115]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用 `AssociationProxy.any()` 在 `A.c_values` 上进行查询，以跨越两个代理 `A.c_values`、`AtoB.c_value`：
- en: '[PRE116]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)'
- en: '### Identity key enhancements to support sharding'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '### 身份键增强以支持分片'
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 现在使用的身份键结构包含一个额外成员，因此来自不同上下文的两个相同主键可以共存于同一身份映射中。
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](../orm/examples.html#examples-sharding)的示例已更新以说明这种行为。示例展示了一个分片类`WeatherLocation`，它引用一个依赖的`WeatherReport`对象，其中`WeatherReport`类映射到一个存储简单整数主键的表。来自不同数据库的两个`WeatherReport`对象可能具有相同的主键值。现在的示例说明了一个新的`identity_token`字段跟踪这种差异，以便这两个对象可以共存于同一个标识映射中：'
- en: '[PRE117]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
- en: New Features and Improvements - Core
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - 核心
- en: '### Boolean datatype now enforces strict True/False/None values'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '### 布尔数据类型现在强制使用严格的True/False/None值'
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.1中，描述的更改[将非本地布尔整数值强制为零/一/无的所有情况](migration_11.html#change-3730)产生了一个意外的副作用，改变了当[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")遇到非整数值（如字符串）时的行为。特别是，先前会生成值`False`的字符串值`"0"`现在会生成`True`。更糟糕的是，行为的更改只针对某些后端而不是其他后端，这意味着将字符串`"0"`值发送给[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")的代码在不同后端上会不一致地中断。
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最终解决方案是**不支持将字符串值与布尔值一起使用**，因此在1.2中，如果传递了非整数/True/False/None值，将引发严格的`TypeError`。此外，只接受整数值0和1。
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应希望对布尔值有更自由解释的应用程序，应使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。下面说明了一个配方，将允许对1.1之前的[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型进行“自由”行为：
- en: '[PRE118]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### Pessimistic disconnection
    detection added to the connection pool'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### 悲观的断开连接检测添加到连接池'
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池文档长期以来一直提供了一个使用[`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect")引擎事件在检出的连接上发出简单语句以测试其活动性的示例。现在，当与适当的方言一起使用时，此示例的功能已添加到连接池本身中。使用新参数[`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine")，每个检出的连接在返回之前将被测试是否新鲜：
- en: '[PRE119]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“预检测”方法会在连接池检出时增加少量延迟，但对于典型的事务性应用（包括大多数ORM应用），这种开销很小，并且消除了获取到过期连接而引发错误、需要应用程序放弃或重试操作的问题。
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性**不**适用于在进行中的事务或SQL操作中断开的连接。如果应用程序必须从中恢复，它需要使用自己的操作重试逻辑来预期这些错误。
- en: See also
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[断开连接处理 - 悲观](../core/pooling.html#pool-disconnects-pessimistic)'
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### IN / NOT IN 运算符的空集合行为现在可配置；默认表达式简化'
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`column.in_([])`这样的表达式，默认情况下现在会产生表达式`1 != 1`，而不是`column != column`。这将**改变查询的结果**，该查询比较了一个在与空集合进行比较时求值为NULL的SQL表达式或列，产生了布尔值false或true（对于NOT
    IN），而不是NULL。在这种情况下发出的警告也被移除了。可以使用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")的[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")参数来获得旧行为。
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，IN和NOT IN运算符不支持显式空值集合的比较；也就是说，这种语法是非法的：
- en: '[PRE120]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，SQLAlchemy和其他数据库库检测到这种情况，并渲染一个替代表达式，该表达式求值为false，或者在NOT IN的情况下，求值为true，根据“col
    IN ()”始终为false的理论，因为“空集合中没有任何东西”。通常为了生成一个跨数据库可移植且在WHERE子句的上下文中起作用的false/true常量，会使用一个简单的重言式，比如`1
    != 1`会求值为false，`1 = 1`会求值为true（简单的常量“0”或“1”通常不能作为WHERE子句的目标）。
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在早期也采用了这种方法，但很快有人推测，如果“column”为NULL，SQL表达式`column IN ()`不会求值为false；相反，该表达式将产生NULL，因为“NULL”表示“未知”，而在SQL中与NULL的比较通常产生NULL。
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个结果，SQLAlchemy从使用`1 != 1`改为使用表达式`expr != expr`来处理空的“IN”，并使用`expr = expr`处理空的“NOT
    IN”；也就是说，我们使用表达式的实际左侧而不是固定值。如果传递的表达式左侧评估为NULL，则整体比较也会得到NULL结果，而不是false或true。
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用户最终抱怨这个表达式对一些查询规划器有非常严重的性能影响。在那时，当遇到空的IN表达式时添加了一个警告，支持SQLAlchemy继续保持“正确”，并敦促用户避免一般情况下生成空的IN谓词的代码，因为通常它们可以安全地省略。然而，在从输入变量动态构建查询的情况下，这在查询中是繁琐的，因为传入的值集可能为空。
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 最近几个月，对这个决定的最初假设进行了质疑。表达式“NULL IN ()”应该返回NULL的想法只是理论上的，无法测试，因为数据库不支持该语法。然而，事实证明，实际上可以通过模拟空集来询问关系数据库对“NULL
    IN ()”会返回什么值：
- en: '[PRE121]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述测试，我们发现数据库本身无法就答案达成一致。被大多数人认为是最“正确”的数据库PostgreSQL返回False；因为即使“NULL”代表“未知”，“空集”意味着没有任何内容，包括所有未知值。另一方面，MySQL和MariaDB对上述表达式返回NULL，采用更常见的“所有与NULL的比较都返回NULL”的行为。
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的SQL架构比最初做出这个设计决定时更复杂，因此我们现在可以在SQL字符串编译时调用任一行为。以前，转换为比较表达式是在构造时完成的，也就是说，在调用[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")或[`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_")操作符时。通过编译时行为，方言本身可以被指示调用任一方法，即“静态”的`1
    != 1`比较或“动态”的`expr != expr`比较。默认已经**更改**为“静态”比较，因为这与PostgreSQL的行为一致，而且这也是绝大多数用户喜欢的。这将**改变查询结果**，特别是对比较空表达式和空集的查询，特别是查询否定`where(~null_expr.in_([]))`，因为现在这将评估为true而不是NULL。
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用标志 [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") 控制此行为，默认为“static”设置，但也可以设置为“dynamic”或“dynamic_warn”，其中“dynamic_warn”设置等效于以前的行为，即发出
    `expr != expr` 以及性能警告。但预计大多数用户将欣赏“static”默认设置。
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### Late-expanded IN
    parameter sets allow IN expressions with cached statements'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### 支持延迟扩展的 IN 参数集，允许具有缓存语句的
    IN 表达式'
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种名为“expanding”的新类型的 [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")。这是用于 `IN` 表达式的，其中元素列表在语句执行时被渲染为单独的绑定参数，而不是在语句编译时。这允许将单个绑定参数名称链接到多个元素的
    IN 表达式，并且允许使用查询缓存与 IN 表达式。新功能允许相关功能的“select in”加载和“polymorphic in”加载利用烘焙查询扩展以减少调用开销：
- en: '[PRE122]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The feature should be regarded as **experimental** within the 1.2 series.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.2 系列中，该功能应被视为 **实验性的**。
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### Flattened operator
    precedence for comparison operators'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### 对比运算符的展开操作优先级'
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如 IN、LIKE、等于、IS、MATCH 等比较运算符的运算符优先级已被展开为一个级别。当组合比较运算符时，将生成更多的括号化效果，例如：
- en: '[PRE123]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成 `(q IS NULL) != (y IS NULL)` 而不是 `q IS NULL != y IS NULL`。
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### Support for SQL Comments
    on Table, Column, includes DDL, reflection'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### 支持对表、列的 SQL 注释，包括
    DDL、反射'
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 数据核心现支持与表和列相关联的字符串注释。这些通过 [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") 和 [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") 参数指定：
- en: '[PRE124]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 DDL 将在创建表时适当渲染，以将上述注释与模式中的表/列关联起来。当上述表以自动加载或通过 [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") 进行检查时，将包括这些注释。表注释也可以使用 [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") 方法独立获取。
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当前后端支持包括 MySQL、PostgreSQL 和 Oracle。
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### Multiple-table criteria
    support for DELETE'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### 支持 DELETE 的多表条件'
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    构造现在支持多表条件，已在支持的后端实现，目前这些后端包括 PostgreSQL、MySQL 和 Microsoft SQL Server（对当前不工作的
    Sybase 方言也添加了支持）。该功能的工作方式与 0.7 和 0.8 系列中首次引入的 UPDATE 的多表条件相同。'
- en: 'Given a statement as:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个语句如下：
- en: '[PRE125]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 后端上，上述语句生成的 SQL 将呈现为：
- en: '[PRE126]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: See also
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[多表删除](../tutorial/data_update.html#tutorial-multi-table-deletes)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### New “autoescape” option
    for startswith(), endswith()'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### 新的 “autoescape” 选项用于
    startswith()、endswith()'
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: “autoescape” 参数已添加到 [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")、[`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")、[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")。当将此参数设置为 `True` 时，将自动使用转义字符转义所有
    `%`、`_` 的出现，默认为斜杠 `/`；转义字符本身的出现也会被转义。斜杠用于避免与诸如 PostgreSQL 的 `standard_confirming_strings`、MySQL
    的 `NO_BACKSLASH_ESCAPES` 等设置发生冲突。现在可以使用现有的 “escape” 参数来更改自动转义字符，如果需要的话。
- en: Note
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.2.0 的初始实现 1.2.0b2 开始，此功能已更改，现在 autoescape 被传递为布尔值，而不是用作转义字符的特定字符。
- en: 'An expression such as:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如以下表达式：
- en: '[PRE127]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Renders as:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现为：
- en: '[PRE128]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 其中参数 “x_1” 的值为 `'total/%score'`。
- en: 'Similarly, an expression that has backslashes:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有反斜杠的表达式：
- en: '[PRE129]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 将以相同方式呈现，参数 “x_1” 的值为 `'total//score'`。
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### Stronger typing added
    to “float” datatypes'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### “float” 数据类型增加更强的类型化'
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列更改允许使用 [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    数据类型更强烈地将其与 Python 浮点值联系起来，而不是更通用的 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")。这些更改主要涉及确保 Python 浮点值不会错误地被强制转换为 `Decimal()`，并且在需要时被强制转��为
    `float`，在结果方面，如果应用程序正在处理普通浮点数。
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递给 SQL 表达式的普通 Python “float” 值现在将被拉入具有类型 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 的字面参数中；之前，该类型为 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")，带有默认的“asdecimal=True”标志，这意味着结果类型将被强制转换为 `Decimal()`。特别是，这将在
    SQLite 上发出令人困惑的警告：
- en: '[PRE130]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")、[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 和 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") 之间的数学运算现在将保留结果表达式的类型 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 或 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")，包括 `asdecimal` 标志以及类型是否应为 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")：'
- en: '[PRE131]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 DBAPI 已知支持本地 `Decimal()` 模式，则 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 数据类型将无条件地将 `float()` 处理器应用于结果值。某些后端不总是保证浮点数返回为普通浮点数，而不是诸如
    MySQL 等精度数字。
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
- en: Support for GROUPING SETS, CUBE, ROLLUP
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 GROUPING SETS、CUBE、ROLLUP 的支持
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: GROUPING SETS、CUBE、ROLLUP 三者都可以通过 `func` 命名空间使用。对于 CUBE 和 ROLLUP，在之前的版本中这些函数已经可以使用，但对于
    GROUPING SETS，在编译器中添加了一个占位符以允许空间。这三个函数现在在文档中命名：
- en: '[PRE132]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用于具有上下文默认生成器的多值插入的参数助手'
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 默认生成函数，例如在[上下文敏感的默认函数](../core/defaults.html#context-default-functions)中描述的函数，可以通过[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")属性查看与语句相关的当前参数。然而，在通过[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法指定多个VALUES子句的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造中，用户定义的函数会被多次调用，每个参数集一次，但是无法知道[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")中的哪个键子集适用于该列。添加了一个新函数[`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters")，其中包括一个关键字参数[`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters")默认为`True`，执行额外的工作，提供一个[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")的子字典，其中的名称局限于当前正在处理的VALUES子句：
- en: '[PRE133]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)  ### Boolean datatype
    now enforces strict True/False/None values'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)  ### 布尔数据类型现在强制使用严格的True/False/None值'
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.1中，[将非本地布尔整数值强制转换为零/一/None的所有情况](migration_11.html#change-3730)中描述的更改产生了一个意外的副作用，改变了当[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")遇到非整数值（如字符串）时的行为。特别是，先前会生成值`False`的字符串值`"0"`，现在会生成`True`。更糟糕的是，行为的变化只针对某些后端而不是其他后端，这意味着将字符串`"0"`值发送给[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")的代码在不同后端上会不一致地出现故障。
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最终解决方案是**不支持将字符串值与布尔值一起使用**，因此在1.2版本中，如果传递了非整数/True/False/None值，将会引发严格的`TypeError`。此外，只有整数值0和1会被接受。
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应希望对布尔值有更自由解释的应用程序，应该使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。下面演示了一个配方，可以允许在1.1版本之前的[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")数据类型的“自由”行为：
- en: '[PRE134]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)'
- en: '### Pessimistic disconnection detection added to the connection pool'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将悲观的断开检测添加到连接池'
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池文档长期以来一直提供了一个使用[`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect")引擎事件在检出的连接上发出简单语句以测试其活动性的配方。现在，当与适当的方言一起使用时，此配方的功能已经添加到连接池本身中。使用新参数[`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine")，每个检出的连接在返回之前都会被测试是否仍然有效：
- en: '[PRE135]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“预检”方法会在连接池检出时增加一小部分延迟，但对于典型的面向事务的应用程序（其中包括大多数ORM应用程序），这种开销是很小的，并且消除了获取到一个过时连接会引发错误的问题，需要应用程序放弃或重试操作。
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能**不**适用于在进行中的事务或SQL操作中断开的连接。如果应用程序必须从这些错误中恢复，它需要使用自己的操作重试逻辑来预期这些错误。
- en: See also
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[断开处理 - 悲观](../core/pooling.html#pool-disconnects-pessimistic)'
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)'
- en: '### The IN / NOT IN operator’s empty collection behavior is now configurable;
    default expression simplified'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '### IN / NOT IN 运算符的空集合行为现在是可配置的；默认表达式简化'
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`column.in_([])`这样的表达式被假定为false，默认情况下现在会产生表达式`1 != 1`，而不是`column != column`。这将**改变查询结果**，如果比较SQL表达式或列与空集合时评估为NULL，则会产生布尔值false或true（对于NOT
    IN），而不是NULL。在这种情况下发出的警告也被移除了。可以使用[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")参数来[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，以保留旧的行为。
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，IN和NOT IN运算符不支持与明确为空的值集合进行比较；也就是说，以下语法是不合法的：
- en: '[PRE136]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，SQLAlchemy和其他数据库库检测到这种情况，并生成一个替代表达式，该表达式评估为false，或者在NOT IN的情况下，根据“col
    IN ()”始终为false的理论，评估为true，因为“空集合”中没有任何内容。通常，为了生成一个跨数据库可移植且在WHERE子句上下文中起作用的false/true常量，会使用一个简单的重言式，比如`1
    != 1`评估为false，`1 = 1`评估为true（一个简单的常量“0”或“1”通常不能作为WHERE子句的目标）。
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在早期也采用了这种方法，但很快就有人推测，如果SQL表达式`column IN ()`中的“column”为NULL，则不会评估为false；相反，该表达式会产生NULL，因为“NULL”表示“未知”，而在SQL中与NULL的比较通常会产生NULL。
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个结果，SQLAlchemy从使用`1 != 1`改为使用表达式`expr != expr`来表示空的“IN”，以及使用`expr = expr`来表示空的“NOT
    IN”；也就是说，我们不再使用固定值，而是使用表达式的实际左侧。如果传递的表达式左侧评估为NULL，则比较整体也会得到NULL结果，而不是false或true。
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用户最终抱怨说这个表达式对一些查询规划器有非常严重的性能影响。在那时，当遇到空的IN表达式时，添加了一个警告，建议SQLAlchemy继续保持“正确”，并敦促用户避免生成通常可以安全省略的空IN谓词的代码。然而，在动态构建查询的情况下，这在输入变量为空时可能会带来负担。
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 近几个月来，对这个决定的原始假设受到了质疑。认为表达式“NULL IN ()”应该返回 NULL 的想法只是理论上的，无法进行测试，因为数据库不支持该语法。然而，事实证明，你确实可以询问关系数据库关于“NULL
    IN ()”将返回什么值，方法是模拟空集如下：
- en: '[PRE137]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述测试，我们发现数据库本身无法就答案达成一致。大多数人认为最“正确”的数据库 PostgreSQL 返回 False；因为即使“NULL”表示“未知”，“空集”表示什么都没有，包括所有未知的值。另一方面，MySQL
    和 MariaDB 返回上述表达式的 NULL，默认为“所有与 NULL 的比较都返回 NULL”的更常见行为。
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的 SQL 架构比最初做出这个设计决定时更复杂，因此我们现在可以在 SQL 字符串编译时调用任一行为。先前，将转换为比较表达式是在构建时完成的，也就是说，在调用
    [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 或 [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") 操作符时完成。通过编译时行为，方言本身可以被指示调用任一方法，即“static”
    `1 != 1` 比较或“dynamic” `expr != expr` 比较。默认值已经**更改**为“static”比较，因为这与 PostgreSQL
    在任何情况下的行为一致，这也是绝大多数用户喜欢的。这将**改变**查询空表达式与空集的比较结果，特别是查询否定 `where(~null_expr.in_([]))`
    的查询，因为现在这将计算为 true 而不是 NULL。
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用标志[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")来控制行为，该标志默认为“static”设置，但也可以设置为“dynamic”或“dynamic_warn”，其中“dynamic_warn”设置等效于以前的行为，即发出`expr
    != expr`以及性能警告。但预计大多数用户会喜欢“static”默认值。
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)'
- en: '### Late-expanded IN parameter sets allow IN expressions with cached statements'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '### 晚扩展的 IN 参数集允许使用缓存语句的 IN 表达式'
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一种名为“expanding”的新类型的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")。这用于在`IN`表达式中，元素列表在语句执行时被渲染为单独的绑定参数，而不是在语句编译时。这允许将单个绑定参数名称链接到多个元素的IN表达式，并允许使用查询缓存与IN表达式一起使用。新功能允许“select
    in”加载和“polymorphic in”加载相关功能利用烘焙查询扩展以减少调用开销：
- en: '[PRE138]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The feature should be regarded as **experimental** within the 1.2 series.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能应被视为**实验性**，属于1.2系列。
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)'
- en: '### Flattened operator precedence for comparison operators'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '### 比较运算符的操作符优先级已经被展开'
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IN、LIKE、equals、IS、MATCH和其他比较运算符等运算符的操作符优先级已被展开为一个级别。当比较运算符组合在一起时，将生成更多的括号，例如：
- en: '[PRE139]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成`(q IS NULL) != (y IS NULL)`而不是`q IS NULL != y IS NULL`。
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)'
- en: '### Support for SQL Comments on Table, Column, includes DDL, reflection'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持在表、列上添加SQL注释，包括DDL、反射'
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 核心支持与表和列相关的字符串注释。这些通过[`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table")和[`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column")参数指定：
- en: '[PRE140]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 上述DDL将在表创建时适当地呈现，以将上述注释与模式中的表/列关联起来。当上述表被自动加载或使用[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")检查时，注释将被包含在内。表注释也可以通过[`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment")方法独立获取。
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当前后端支持包括MySQL、PostgreSQL和Oracle。
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)'
- en: '### Multiple-table criteria support for DELETE'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '### DELETE的多表条件支持'
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")构造现在支持多表条件，已在支持的后端实现，目前这些后端是PostgreSQL、MySQL和Microsoft
    SQL Server（支持也已添加到当前不工作的Sybase方言）。该功能的工作方式与0.7和0.8系列中首次引入的UPDATE的多表条件相同。'
- en: 'Given a statement as:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 给定语句如下：
- en: '[PRE141]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL后端上，上述语句的结果SQL将呈现为：
- en: '[PRE142]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: See also
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '[多表删除](../tutorial/data_update.html#tutorial-multi-table-deletes)'
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
- en: '### New “autoescape” option for startswith(), endswith()'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的“autoescape”选项用于 startswith()，endswith()'
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: “autoescape”参数被添加到[`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")，[`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")，[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")中。当将此参数设置为`True`时，将自动使用转义字符转义所有出现的`%`、`_`，默认为斜杠`/`；转义字符本身的出现也会被转义。斜杠用于避免与诸如
    PostgreSQL 的`standard_confirming_strings`（从 PostgreSQL 9.1 开始更改默认值）和 MySQL 的`NO_BACKSLASH_ESCAPES`设置等设置发生冲突。现在可以使用现有的“escape”参数来更改自动转义字符，如果需要的话。
- en: Note
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.2.0的初始实现1.2.0b2开始，此功能已更改，现在autoescape被传递为布尔值，而不是用作转义字符的特定字符。
- en: 'An expression such as:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE143]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Renders as:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染为：
- en: '[PRE144]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 其中参数“x_1”的值为`'total/%score'`。
- en: 'Similarly, an expression that has backslashes:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有反斜杠的表达式：
- en: '[PRE145]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 将以相同方式渲染，参数“x_1”的值为`'total//score'`。
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)'
- en: '### Stronger typing added to “float” datatypes'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对“float”数据类型进行了更强的类型化'
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列更改允许使用[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")数据类型更强烈地将其与
    Python 浮点值关联起来，而不是更通用的[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")。这些更改主要涉及确保 Python 浮点值不会错误地被强制转换为`Decimal()`，并且在需要时，如果应用程序正在处理普通浮点数，则会被强制转换为`float`。
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 SQL 表达式的普通 Python“float”值现在将被拉入具有类型[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")的文字参数；以前，类型为[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")，带有默认的“asdecimal=True”标志，这意味着结果类型将强制转换为`Decimal()`。特别是，这将在
    SQLite 上发出令人困惑的警告：
- en: '[PRE146]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")、[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 和 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") 之间的数学操作现在将保留结果表达式的类型，包括 `asdecimal` 标志以及类型是否应为 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")： '
- en: '[PRE147]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    数据类型将始终将 `float()` 处理器应用于结果值，如果 DBAPI 已知支持原生 `Decimal()` 模式。一些后端并不总是保证浮点数作为普通浮点数返回，而不是像
    MySQL 这样的精度数字。'
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
- en: Support for GROUPING SETS, CUBE, ROLLUP
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 GROUPING SETS、CUBE、ROLLUP
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: GROUPING SETS、CUBE、ROLLUP 这三个功能都可以通过 `func` 命名空间来调用。在 CUBE 和 ROLLUP 的情况下，这些函数在之前的版本中已经可以使用，但是对于
    GROUPING SETS，编译器中添加了一个占位符以允许使用这个功能。现在文档中已经命名了这三个函数：
- en: '[PRE148]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '### 多值插入的参数辅助器，带有上下文默认生成器'
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 默认生成函数，例如在[上下文敏感的默认函数](../core/defaults.html#context-default-functions)中描述的函数，可以通过[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")属性查看与语句相关的当前参数。然而，在通过[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法指定多个VALUES子句的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造中，用户定义的函数会被多次调用，每个参数集一次，但是无法知道[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")中的哪些键子集适用于该列。添加了一个新函数[`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters")，其中包括一个关键字参数[`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters")默认为`True`，执行额外的工作，提供一个[`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters")的子字典，其中的名称局限于当前正在处理的VALUES子句：
- en: '[PRE149]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
- en: Key Behavioral Changes - ORM
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### The after_rollback() Session event now emits before the expiration of objects'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '### after_rollback() Session 事件现在在对象过期之前触发'
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") 事件现在可以访问对象在其状态被过期之前的属性状态（例如“快照移除”）。这使得该事件与[`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit")事件的行为保持一致，后者在“快照”被移除之前也会触发：'
- en: '[PRE150]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仍将禁止在此事件中发出 SQL；这意味着未加载的属性仍无法在事件范围内加载。
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### Fixed issue involving
    single-table inheritance with `select_from()`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### 修复了与 `select_from()`
    一起使用单表继承的问题'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成 SQL 时，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 方法现在会尊重单表继承列鉴别器；之前，只有查询列列表中的表达式会被考虑。
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Manager` 是 `Employee` 的子类。像下面这样的查询：
- en: '[PRE151]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Would generate SQL as:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 会生成如下 SQL：
- en: '[PRE152]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `Manager` 只是通过 [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 指定而不在列列表中，鉴别器将不会被添加：
- en: '[PRE153]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'would generate:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 会生成：
- en: '[PRE154]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修复，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 现在可以正常工作，我们得到：
- en: '[PRE155]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一直通过手动提供 WHERE 子句来解决此问题的应用程序可能需要进行调整。
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### Previous collection
    is no longer mutated upon replacement'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### 在替换时不再改变先前集合'
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 在映射集合成员更改时会发出事件。将集合分配给将替换先前集合的属性时，这样做的一个副作用是，被替换的集合也会被改变，这是误导性的和不必要的：
- en: '[PRE156]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改之前，`previous_collection` 将删除“a1”成员，对应于不再在新集合中的成员。
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### A @validates method
    receives all values on bulk-collection set before comparison'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### 在批量集合设置之前，@validates
    方法会接收所有值'
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@validates` 的方法现在在“批量设置”操作期间会接收集合的所有成员，然后再应用比较到现有集合上。
- en: 'Given a mapping as:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射如下：
- en: '[PRE157]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以如下使用验证器，将传入的字典转换为 `B` 的实例并在集合附加时使用：
- en: '[PRE158]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，集合赋值会失败，因为 ORM 会假定传入的对象已经是 `B` 的实例，因此在进行集合附加之前会尝试将它们与集合的现有成员进行比较，而实际上是在执行调用验证器的集合附加之前。这将使得批量设置操作无法适应需要事先修改的非
    ORM 对象，比如字典：
- en: '[PRE159]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 新逻辑使用新的 [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") 事件，以确保所有值都会被提前发送到 `@validates`
    函数。
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，这意味着验证器现在将在批量设置时接收**所有**集合成员，而不仅仅是新成员。假设一个简单的验证器如下：
- en: '[PRE160]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Above, if we began with a collection as:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始的集合如下：
- en: '[PRE161]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And then, replaced the collection with one that overlaps the first:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用与第一个重叠的集合替换了原集合：
- en: '[PRE162]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，第二次赋值只会触发一次`A.validate_b`方法，对于`b3`对象。`b2`对象将被视为已经存在于集合中且不会被验证。使用新行为，`b2`和`b3`都会在传递到集合之前传递给`A.validate_b`。因此，验证方法必须具有幂等行为以适应这种情况。
- en: See also
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New bulk_replace event](#change-3896-event)'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '[新的批量替换事件](#change-3896-event)'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### Use flag_dirty()
    to mark an object as “dirty” without any attribute changing'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### 使用flag_dirty()标记对象为“脏”而不更改任何属性'
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified")函数用于标记未加载的属性为已修改，则会引发异常：
- en: '[PRE163]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果属性在刷新发生时仍未出现，那么刷新过程很可能会失败。要将对象标记为“已修改”而不指定任何特定属性，以便在自定义事件处理程序（如[`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")）中考虑到刷新过程中，使用新的[`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty")函数：
- en: '[PRE164]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### “scope” keyword removed
    from scoped_session'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### 从scoped_session中移除“scope”关键字'
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老且未记录的关键字参数`scope`已被移除：
- en: '[PRE165]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 该关键字的目的是尝试允许变量“作用域”，其中`None`表示“无作用域”，因此会返回一个新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。该关键字从未被记录在案，如果遇到将会引发`TypeError`。预计该关键字未被使用，但如果用户在测试期间报告与此相关的问题，可以通过弃用来恢复。
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### Refinements to post_update
    in conjunction with onupdate'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### 与onupdate一起对post_update进行细化'
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship")功能的关系现在将与设置了[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")值的列更好地交互。如果插入对象时为列显式指定了值，则在UPDATE期间会重新声明该值，以便“onupdate”规则不会覆盖它：
- en: '[PRE166]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，以前的行为是 UPDATE 会在 INSERT 之后发出，从而触发“onupdate”并覆盖值“5”。现在的 SQL 如下：
- en: '[PRE167]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果“updated”的值*未*设置，则我们将正确地在`a1.updated`上获取新生成的值；以前，刷新或过期属性以允许生成的值存在的逻辑不会为
    post-update 触发。在这种情况下，当刷新中发生 flush 时，也会发出[`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush")事件。
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update integrates
    with ORM versioning'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update 与 ORM
    版本控制集成'
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: post_update 功能，文档化在[指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)，涉及对特定关系绑定外键的更改发出
    UPDATE 语句，除了针对目标行通常会发出的 INSERT/UPDATE/DELETE。此 UPDATE 语句现在参与版本控制功能，文档化在[配置版本计数器](../orm/versioning.html#mapper-version-counter)。
- en: 'Given a mapping:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE168]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 更新将另一个节点关联为“favorite”的节点的 UPDATE 现在也会增加版本计数器，并匹配当前版本：
- en: '[PRE169]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这意味着一个对象由于其他属性的更改而接收到一个 UPDATE，以及由于 post_update 关系更改而接收到第二个 UPDATE，现在将会为一个
    flush 接收到**两个版本计数器更新**。但是，如果对象在当前 flush 中受到 INSERT 的影响，则版本计数器**不会**额外增加一次，除非存在服务器端版本控制方案。
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 现在讨论 post_update 为什么即使是 UPDATE 也会发出 UPDATE 的原因在[为什么 post_update 除了第一个 UPDATE
    还会发出 UPDATE？](../faq/sessions.html#faq-post-update-update)。
- en: See also
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)'
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么 post_update 除了第一个 UPDATE 还会发出 UPDATE？](../faq/sessions.html#faq-post-update-update)'
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)  ### The after_rollback()
    Session event now emits before the expiration of objects'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)  ### 在对象过期之前，after_rollback()
    会发出 Session 事件'
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") 事件现在可以在对象状态被过期之前访问属性状态（例如“快照移除”）。这使得事件与[`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit")事件的行为一致，后者也会在“快照”被移除之前发出：'
- en: '[PRE170]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")仍将禁止在此事件中发出SQL；这意味着未加载的属性仍将无法在事件范围内加载。
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)'
- en: '### Fixed issue involving single-table inheritance with `select_from()`'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '### 修复了与`select_from()`一起使用单表继承的问题'
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")方法现在在生成SQL时尊重单表继承列鉴别器；以前，只有查询列列表中的表达式会被考虑进去。'
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Manager`是`Employee`的子类。像下面这样的查询：
- en: '[PRE171]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Would generate SQL as:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的SQL如下：
- en: '[PRE172]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`Manager`仅由[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")指定，而不在列列表中，那么鉴别器将不会被添加：
- en: '[PRE173]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'would generate:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成：
- en: '[PRE174]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修复，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")现在可以正常工作，我们得到：
- en: '[PRE175]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一直通过手动提供WHERE子句来解决此问题的应用程序可能需要进行调整。
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)'
- en: '### Previous collection is no longer mutated upon replacement'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在替换���不再改变先前集合'
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: ORM在映射集合的成员发生变化时会发出事件。将集合分配给将替换先前集合的属性时，这样做的一个副作用是，被替换的集合也会被改变，这是误导性和不必要的：
- en: '[PRE176]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，在更改之前，`previous_collection`将删除“a1”成员，对应于不再在新集合中的成员。
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)'
- en: '### A @validates method receives all values on bulk-collection set before comparison'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在比较之前，@validates方法会接收批量集合设置的所有值'
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@validates`的方法现在在“批量设置”操作期间将接收集合的所有成员，然后再将比较应用于现有集合。
- en: 'Given a mapping as:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射如下：
- en: '[PRE177]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以使用验证器如下，将传入的字典转换为`B`的实例进行集合附加：
- en: '[PRE178]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，集合赋值将失败，因为ORM会假定传入的对象已经是`B`的实例，因为它在尝试将它们与集合的现有成员进行比较之前，会执行集合附加操作，这实际上会调用验证器。这将使得批量设置操作无法容纳像需要事先修改的字典这样的非ORM对象：
- en: '[PRE179]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 新逻辑使用新的[`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace")事件，以确保所有值都被提前发送到`@validates`函数。
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，现在验证器将在批量设置时接收**所有**集合成员，而不仅仅是新成员。假设一个简单的验证器如下：
- en: '[PRE180]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Above, if we began with a collection as:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，如果我们从一个集合开始：
- en: '[PRE181]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'And then, replaced the collection with one that overlaps the first:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用一个与第一个重叠的集合替换了该集合：
- en: '[PRE182]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，第二次赋值只会触发一次`A.validate_b`方法，对于`b3`对象。`b2`对象将被视为已经存在于集合中并且不会被验证。通过新行为，`b2`和`b3`都会在传递到集合之前传递给`A.validate_b`。因此，验证方法必须采用幂等行为以适应这种情况。
- en: See also
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New bulk_replace event](#change-3896-event)'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '[新的bulk_replace事件](#change-3896-event)'
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
- en: '### Use flag_dirty() to mark an object as “dirty” without any attribute changing'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用flag_dirty()将对象标记为“dirty”而不改变任何属性'
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用[`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified")函数标记一个未加载的属性为已修改，现在会引发异常：
- en: '[PRE183]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果属性在刷新发生时仍未出现，则刷新过程很可能会失败。要将对象标记为“修改”，而不是特指任何属性，以便考虑到自定义事件处理程序（如[`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")）的刷新过程中，使用新的[`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty")函数：
- en: '[PRE184]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)'
- en: '### “scope” keyword removed from scoped_session'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从scoped_session中移除了“scope”关键字'
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老且未记录的关键字参数`scope`已被移除：
- en: '[PRE185]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 此关键字的目的是尝试允许变量“scopes”，其中`None`表示“无范围”，因此将返回一个新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。该关键字从未被记录在案，如果遇到将引发`TypeError`。预计不会使用此关键字，但如果用户在测试期间报告与此相关的问题，则可以通过弃用来恢复。
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)'
- en: '### Refinements to post_update in conjunction with onupdate'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与onupdate一起的post_update的改进'
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship")功能的关系现在将更好地与设置了[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")值的列交互。如果插入对象时为列显式指定了值，则在UPDATE期间将重新声明该值，以便“onupdate”规则不会覆盖它：
- en: '[PRE186]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，以前的行为是在插入之后会发出更新，从而触发“onupdate”，并覆盖值“5”。现在的 SQL 如下：
- en: '[PRE187]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果“updated”的值 *未* 设置，则我们将在 `a1.updated` 上正确地获得新生成的值；以前，刷新或过期属性的逻辑以允许生成的值存在将不会触发
    post-update。在此情况下，还会在刷新期间发出 [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") 事件。
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)'
- en: '### post_update integrates with ORM versioning'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '### post_update 与 ORM 版本控制集成'
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 'post_update 功能，记录在 [指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)，涉及响应特定关系绑定外键的更改而发出
    UPDATE 语句，除了为目标行正常发出的 INSERT/UPDATE/DELETE 外。此 UPDATE 语句现在参与版本控制功能，记录在 [配置版本计数器](../orm/versioning.html#mapper-version-counter)。 '
- en: 'Given a mapping:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE188]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 将另一个节点关联为“favorite”的节点进行更新将会增加版本计数器并匹配当前版本：
- en: '[PRE189]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这意味着对象在响应其他属性更改而接收到 UPDATE，并在 post_update 关系更改导致第二个 UPDATE 时，现在将收到**一次刷新两次版本计数器更新**。但是，如果对象在当前刷新中接受到
    INSERT，则版本计数器 **不会** 再次增加，除非存在服务器端版本控制方案。
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 现在讨论了 post_update 为何即使是对 UPDATE 也会发出 UPDATE 的原因 [为什么 post_update 除了第一个 UPDATE
    还会发出 UPDATE？](../faq/sessions.html#faq-post-update-update)。
- en: See also
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '[指向自身的行 / 相互依赖的行](../orm/relationship_persistence.html#post-update)'
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么 post_update 除了第一个 UPDATE 还会发出 UPDATE？](../faq/sessions.html#faq-post-update-update)'
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
- en: Key Behavioral Changes - Core
  id: totrans-812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - 核心
- en: '### The typing behavior of custom operators has been made consistent'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义运算符的类型行为已经统一'
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 函数动态创建用户定义的运算符。以前，表达式对此类运算符的类型行为不一致，也无法控制。
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 1.1 版本中，类似以下表达式将产生无返回类型的结果（假设 `-%>` 是数据库支持的某个特殊运算符）：
- en: '[PRE190]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型将使用使用左侧类型作为返回类型的默认行为：
- en: '[PRE191]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为大多是偶然发生的，因此行为已与第二种形式保持一致，即默认返回类型与左侧表达式相同：
- en: '[PRE192]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数用户定义的运算符往往是“比较”运算符，通常是由 PostgreSQL 定义的许多特殊运算符之一，[`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 标志已修复，以遵循其允许返回类型为 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") 的文档行为，包括对 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 和 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")：
- en: '[PRE193]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 为了辅助布尔比较运算符，添加了一个新的简写方法 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")。应优先使用此方法进行即时布尔运算符：
- en: '[PRE194]  ### Percent signs in literal_column() now conditionally escaped'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE194]  ### `literal_column()` 中的百分号现在有条件地转义'
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '[`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 结构现在根据使用的 DBAPI 是否使用了对百分号敏感的参数样式有条件地转义百分号字符（例如‘format’或‘pyformat’）。'
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，无法生成一个声明单个百分号的 [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 结构：
- en: '[PRE195]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未设置为使用‘format’或‘pyformat’参数样式的方言，百分号现在不受影响；大多数 MySQL 方言等声明了其中一个参数样式的方言将继续适当转义：
- en: '[PRE196]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，使用诸如 [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")、[`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") 和 [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") 等运算符时，之前出现的加倍现象也被精细化，只在适当时发生。
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### The column-level
    COLLATE keyword now quotes the collation name'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### 列级别的 COLLATE 关键字现在引用排序规则名称'
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '[`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")
    和 [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") 函数中的一个 bug，用于在语句级别提供临时列排序，已修复，其中一个大小写敏感的名称不会被引用：'
- en: '[PRE197]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'now renders:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示为：
- en: '[PRE198]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，大小写敏感的名称“fr_FR”不会被引用。目前，手动引用“fr_FR”名称**不**会被检测到，因此手动引用标识符的应用程序应进行调整。请注意，此更改不会影响类型级别的排序的使用（例如，在表级别上指定在
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    类型上的排序），其中已经应用了引用。
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)  ### The typing behavior
    of custom operators has been made consistent'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)  ### 自定义运算符的输入行为已经保持一致'
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的运算符可以使用 [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 函数动态创建。先前，针对此类运算符的表达式的输入行为是不一致的，也无法控制。
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.1中，例如以下表达式将产生一个没有返回类型的结果（假设 `-%>` 是数据库支持的某种特殊运算符）：
- en: '[PRE199]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型将使用默认行为，即使用左侧类型作为返回类型：
- en: '[PRE200]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为大多是偶然发生的，因此行为已与第二种形式保持一致，即默认返回类型与左侧表达式相同：
- en: '[PRE201]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数用户定义的运算符倾向于是“比较”运算符，通常是 PostgreSQL 定义的许多特殊运算符之一，因此已修复了 [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") 标志，使其遵循其文档化的行为，即在所有情况下允许返回类型为 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")，包括对于 [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") 和 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")：
- en: '[PRE202]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 为了辅助布尔比较运算符，添加了一个新的简写方法 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")。应优先使用此方法进行即时布尔运算：
- en: '[PRE203]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '### Percent signs in literal_column() now conditionally escaped'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '### `literal_column()` 中的百分号现在有条件地转义'
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '[`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 构造现在有条件地转义百分号字符，取决于正在使用的DBAPI是否使用了对百分号敏感的参数样式（例如‘format’或‘pyformat’）。'
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，无法生成一个声明了单个百分号的[`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 构造：
- en: '[PRE204]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未设置为使用‘format’或‘pyformat’参数样式的方言，百分号现在不受影响；大多数MySQL方言等声明了这些参数样式的方言将继续适当地进行转义：
- en: '[PRE205]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，使用[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")、[`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")和[`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")等操作符时，之前出现的加倍现象也被优化为仅在适当时发生。
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)'
- en: '### The column-level COLLATE keyword now quotes the collation name'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '### 列级别的 COLLATE 关键字现在引用了排序规则名称'
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了[`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")和[`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate")函数中的一个错误，用于在语句级别提供临时列排序规则，其中一个区分大小写的名称将不会被引用：
- en: '[PRE206]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'now renders:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE207]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，区分大小写的名称“fr_FR”将不会被引用。目前，不会检测手动引用“fr_FR”名称，因此手动引用标识符的应用程序应进行调整。请注意，此更改不影响在类型级别使用排序规则（例如在数据类型上指定的[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")在表级别），其中已经应用了引用。
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-864
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - PostgreSQL
- en: '### Support for Batch Mode / Fast Execution Helpers'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持批处理模式 / 快速执行助手'
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 的 `cursor.executemany()` 方法被认为性能较差，特别是在 INSERT 语句中。为了缓解这一问题，psycopg2
    添加了[快速执行助手](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)，通过批量发送多个
    DML 语句来减少服务器往返次数。SQLAlchemy 1.2 现在包括对这些助手的支持，可以在[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 使用 `cursor.executemany()` 对多个参数集合执行语句时透明地使用。该功能默认关闭，可以通过在
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    上使用 `use_batch_mode` 参数来启用：
- en: '[PRE208]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 目前该功能被视为实验性质，但可能在未来的版本中默认开启。
- en: See also
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2 快速执行助手](../dialects/postgresql.html#psycopg2-batch-mode)'
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### Support for fields
    specification in INTERVAL, including full reflection'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### 支持 INTERVAL 中字段规范的支持，包括完整反射'
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的 INTERVAL 数据类型中的“fields”规范允许指定要存储的间隔的哪些字段，包括“YEAR”、“MONTH”、“YEAR
    TO MONTH”等值。[`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") 数据类型现在允许指定这些值：
- en: '[PRE209]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有 INTERVAL 数据类型现在都可以独立于存在的“fields”规范进行反射；数据类型本身的“fields”参数也将存在：
- en: '[PRE210]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)  ### Support for Batch
    Mode / Fast Execution Helpers'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)  ### 支持批处理模式 / 快速执行助手'
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 的 `cursor.executemany()` 方法被认为性能较差，特别是在 INSERT 语句中。为了缓解这一问题，psycopg2
    添加了[快速执行助手](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)，通过批量发送多个
    DML 语句来减少服务器往返次数。SQLAlchemy 1.2 现在包括对这些助手的支持，可以在[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 使用 `cursor.executemany()` 对多个参数集合执行语句时透明地使用。该功能默认关闭，可以通过在
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    上使用 `use_batch_mode` 参数来启用：
- en: '[PRE211]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 目前该功能被视为实验性质，但可能在未来的版本中默认开启。
- en: See also
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2 快速执行助手](../dialects/postgresql.html#psycopg2-batch-mode)'
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)'
- en: '### Support for fields specification in INTERVAL, including full reflection'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 INTERVAL 中字段规范的支持，包括完整反射'
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的 INTERVAL 数据类型中的“fields”指定符允许指定要存储的间隔的哪些字段，包括“YEAR”、“MONTH”、“YEAR
    TO MONTH”等值。[`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") 数据类型现在允许指定这些值：
- en: '[PRE212]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在可以独立于“fields”指定符反映所有 INTERVAL 数据类型；数据类型本身的“fields”参数也将存在：
- en: '[PRE213]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-889
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - MySQL
- en: '### Support for INSERT..ON DUPLICATE KEY UPDATE'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 INSERT..ON DUPLICATE KEY UPDATE'
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 支持的 `INSERT` 的 `ON DUPLICATE KEY UPDATE` 子句现在可以使用 MySQL 特定版本的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 对象来支持，通过 `sqlalchemy.dialects.mysql.dml.insert()`。这个
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    子类添加了一个新方法 `Insert.on_duplicate_key_update()`，实现了 MySQL 的语法：
- en: '[PRE214]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'The above will render:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容将呈现为：
- en: '[PRE215]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: See also
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)  ### Support for INSERT..ON
    DUPLICATE KEY UPDATE'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)  ### 支持 INSERT..ON DUPLICATE
    KEY UPDATE'
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 支持的 `INSERT` 的 `ON DUPLICATE KEY UPDATE` 子句现在可以使用 MySQL 特定版本的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 对象来支持，通过 `sqlalchemy.dialects.mysql.dml.insert()`。这个
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    子类添加了一个新方法 `Insert.on_duplicate_key_update()`，实现了 MySQL 的语法：
- en: '[PRE216]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The above will render:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容将呈现为：
- en: '[PRE217]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: See also
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-905
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - Oracle
- en: '### Major Refactor to cx_Oracle Dialect, Typing System'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '### cx_Oracle 方言、类型系统的重大重构'
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 cx_Oracle DBAPI 的 6.x 系列的推出，SQLAlchemy 的 cx_Oracle 方言已经重新设计和简化，以利用 cx_Oracle
    的最新改进，并放弃了在 cx_Oracle 的 5.x 系列之前更相关的模式的支持。
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的最低 cx_Oracle 版本现在是 5.1.3；推荐使用 5.3 或最新的 6.x 系列。
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的处理已经重构。`cursor.setinputsizes()` 方法不再用于除 LOB 类型之外的任何数据类型，根据 cx_Oracle 的开发人员的建议。因此，参数
    `auto_setinputsizes` 和 `exclude_setinputsizes` 已被弃用，不再起作用。
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `coerce_to_decimal` 标志设置为 False 时，表示不应发生对具有精度和标度的数值类型进行到 `Decimal` 的强制转换，仅影响未定义类型（例如，没有
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    对象的普通字符串）的语句。现在，包含 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 类型或子类型的 Core 表达式将遵循该类型的十进制强制转换规则。
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “两阶段”事务支持在方言中已经在 cx_Oracle 的 6.x 系列中被删除，现在已完全移除，因为这个功能从未正确工作过，也不太可能被用于生产环境。因此，`allow_twophase`
    方言标志已被弃用，也不再起作用。
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了涉及 RETURNING 中存在的列键的错误。给定如下语句：
- en: '[PRE218]'
  id: totrans-913
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  id: totrans-914
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，结果中每行的键是 `ret_0` 和 `ret_1`，这些是 cx_Oracle RETURNING 实现内部的标识符。现在，键将是 `a` 和
    `b`，这是其他方言所期望的。
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_Oracle 的 LOB 数据类型将返回值表示为 `cx_Oracle.LOB` 对象，这是一个与游标关联的代理，通过 `.read()` 方法返回最终数据值。在历史上，如果在这些
    LOB 对象被消耗之前读取了更多行（特别是在读取了比 cursor.arraysize 值更多的行，导致读取了一批新行），这些 LOB 对象会引发错误“在后续获取后
    LOB 变量不再有效”。SQLAlchemy 通过在其类型系统内部自动调用 `.read()`，以及使用一个特殊的 `BufferedColumnResultSet`
    来解决这个问题，该对象将确保在使用 `cursor.fetchmany()` 或 `cursor.fetchall()` 这样的调用时，这些数据被缓冲。
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  id: totrans-916
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方言现在使用 cx_Oracle outputtypehandler 来处理这些 `.read()` 调用，以便无论获取多少行，它们始终被立即调用，因此不再会发生此错误。因此，`BufferedColumnResultSet`
    的使用，以及一些其他特定于此用例的 Core `ResultSet` 内部机制已被移除。类型对象也变得更简化，因为它们不再需要处理二进制列结果。
- en: 'Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.  ### Oracle Unique, Check constraints now reflected'
  id: totrans-917
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，cx_Oracle 6.x 已经删除了此错误发生的条件，因此不再可能发生此错误。在 SQLAlchemy 中，如果很少（如果有的话）使用了 `auto_convert_lobs=False`
    选项，并且在 LOB 对象可以被消耗之前读取了更多行，则可能会发生错误。升级到 cx_Oracle 6.x 将解决这个问题。### Oracle 唯一性、检查约束现在已反映。
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: UNIQUE 和 CHECK 约束现在通过 [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 和 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 反映出来。反映的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象现在也将包括 [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") 对象。有关此处行为怪癖的信息，请参阅 [约束反射](../dialects/oracle.html#oracle-constraint-reflection)，包括大多数
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象仍不会包括任何 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 对象，因为这些通常通过 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 表示。
- en: See also
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '[约束反射](../dialects/oracle.html#oracle-constraint-reflection)'
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle foreign key
    constraint names are now “name normalized”'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle 外键约束名称现在是“名称标准化”'
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 在表反射期间传递给 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象的外键约束名称以及在 [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") 方法中将会“名称标准化”，即以小写形式表示以进行大小写不敏感的命名，而不是
    Oracle 使用的原始大写格式：
- en: '[PRE219]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Previously, the foreign keys result would look like:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，外键约束的结果看起来像：
- en: '[PRE220]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Where the above could create problems particularly with Alembic autogenerate.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容可能会在特别是与 Alembic autogenerate 一起创建问题。
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)  ### Major Refactor to
    cx_Oracle Dialect, Typing System'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)  ### cx_Oracle 方言、类型系统的重大重构'
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 cx_Oracle DBAPI 推出的 6.x 系列，SQLAlchemy 的 cx_Oracle 方言已经进行了重构和简化，以利用 cx_Oracle
    的最新改进，并放弃了在 cx_Oracle 5.x 系列之前更相关的模式的支持。
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的最低 cx_Oracle 版本现在是 5.1.3；建议使用 5.3 或最新的 6.x 系列。
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型的处理已经重构。`cursor.setinputsizes()` 方法现在仅用于 LOB 类型，根据 cx_Oracle 的开发人员的建议。因此，参数
    `auto_setinputsizes` 和 `exclude_setinputsizes` 已被弃用，不再起作用。
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置为 False 时，`coerce_to_decimal` 标志表示不应进行具有精度和标度的数字类型到 `Decimal` 的强制转换，仅影响未类型化的（例如，没有
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    对象的普通字符串）语句。包含 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    类型或子类型的 Core 表达式现在将遵循该类型的十进制强制转换规则。
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方言中的“两阶段”事务支持已经在 cx_Oracle 的 6.x 系列中删除，因为这个功能从未正确工作过，并且不太可能已经投入生产使用。因此，`allow_twophase`
    方言标志已被弃用，也不再起作用。
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了涉及 RETURNING 的列键存在的错误。给定以下语句：
- en: '[PRE221]'
  id: totrans-934
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  id: totrans-935
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以前，结果中每行的键是 `ret_0` 和 `ret_1`，这是 cx_Oracle RETURNING 实现的内部标识符。现在，键将是 `a` 和 `b`，这是其他方言所期望的。
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_Oracle 的 LOB 数据类型将返回值表示为 `cx_Oracle.LOB` 对象，它是一个与游标关联的代理，通过 `.read()` 方法返回最终数据值。历史上，如果在这些
    LOB 对象被消耗之前读取了更多的行（具体来说，如果读取的行数超过了 cursor.arraysize 的值，这会导致读取一批新的行），这些 LOB 对象将引发错误“在后续获取后
    LOB 变量不再有效”。SQLAlchemy 解决了这个问题，通过在其类型系统中自动调用 `.read()` 来处理这些 LOB，并使用特殊的 `BufferedColumnResultSet`
    确保这些数据被缓冲，以防使用了 `cursor.fetchmany()` 或 `cursor.fetchall()` 这样的调用。
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  id: totrans-937
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方言现在使用 cx_Oracle 的 outputtypehandler 来处理这些 `.read()` 调用，以便无论读取多少行，它们都始终被提前调用，因此不再会发生此错误。因此，已删除了
    `BufferedColumnResultSet` 的使用，以及一些特定于此用例的 Core `ResultSet` 的其他内部内容。由于不再需要处理二进制列结果，类型对象也变得简化了。
- en: Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.
  id: totrans-938
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，cx_Oracle 6.x 已经删除了此错误在任何情况下发生的条件，因此该错误不再可能发生。在 SQLAlchemy 中，该错误可能发生在很少（如果有的话）使用了
    `auto_convert_lobs=False` 选项，并且与之前的 cx_Oracle 5.x 系列一起使用，以及在 LOB 对象可以被消耗之前读取了更多行的情况下。升级到
    cx_Oracle 6.x 将解决该问题。
- en: '### Oracle Unique, Check constraints now reflected'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '### Oracle 唯一性、检查约束现在已反映'
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一约束和检查约束现在通过 [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 和 [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 反映出来。一个反映的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象现在也将包括 [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") 对象。请参阅 [Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)
    中的注意事项，了解这里的行为怪癖，包括大多数 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象仍将不包括任何 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 对象，因为这些通常通过 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 表示。
- en: See also
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)'
- en: '### Oracle foreign key constraint names are now “name normalized”'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '### Oracle 外键约束名称现在已经“名称标准化”'
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在表反射期间传递给 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象以及在 [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") 方法内部的外键约束的名称现在将被“名称标准化”，即，以小写形式表示以便于不区分大小写的名称，而不是
    Oracle 使用的原始大写格式：
- en: '[PRE222]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Previously, the foreign keys result would look like:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，外键结果看起来像是：
- en: '[PRE223]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Where the above could create problems particularly with Alembic autogenerate.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况可能会特别在 Alembic autogenerate 方面造成问题。
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - SQL Server
- en: '### SQL Server schema names with embedded dots supported'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持具有嵌入点的 SQL Server 架构名称'
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 方言有一种行为，即假定带有点的架构名称是“数据库”。“所有者”标识符对，这在表和组件反射操作以及在呈现架构名称的引用时必须在这些单独的组件之间进行拆分，以使这两个符号分别引用。现在可以使用方括号传递架构参数以手动指定此拆分发生的位置，允许包含一个或多个点的数据库和/或所有者名称：
- en: '[PRE224]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 上表将考虑“owner”为`MyDataBase.dbo`，在呈现时也将被引用，并且“database”为 None。要分别引用数据库名称和所有者，请使用两对括号：
- en: '[PRE225]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当传递给 SQL Server 方言的“schema”时，现在会尊重[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name")构造；如果引号标志为 True，则给定的符号不会在点上拆分，并且将被解释为“owner”。
- en: See also
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '[多部分模式名称](../dialects/mssql.html#multipart-schema-names)'
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
- en: AUTOCOMMIT isolation level support
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 AUTOCOMMIT 隔离级别
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: PyODBC 和 pymssql 方言现在都支持由[`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")设置的“AUTOCOMMIT”隔离级别，这将在 DBAPI
    连接对象上建立正确的标志。
- en: '### SQL Server schema names with embedded dots supported'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持带有嵌入点的 SQL Server 模式名称'
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 方言具有这样的行为，即假定具有其中的点的模式名称是“数据库”。“所有者”标识符对，这在表和组件反射操作以及在呈现模式名称的引用时必须将这两个符号分开时发生，以便分别引用这两个符号。现在可以使用括号传递模式参数以手动指定此拆分发生的位置，允许数据库和/或所有者名称本身包含一个或多个点：
- en: '[PRE226]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 上表将考虑“owner”为`MyDataBase.dbo`，在呈现时也将被引用，并且“database”为 None。要分别引用数据库名称和所有者，请使用两对括号：
- en: '[PRE227]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当传递给 SQL Server 方言的“schema”时，现在会尊重[`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name")构造；如果引号标志为 True，则给定的符号不会在点上拆分，并且将被解释为“owner”。
- en: See also
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[多部分模式名称](../dialects/mssql.html#multipart-schema-names)'
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
- en: AUTOCOMMIT isolation level support
  id: totrans-972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 AUTOCOMMIT 隔离级别
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: PyODBC 和 pymssql 方言现在都支持由[`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")设置的“AUTOCOMMIT”隔离级别，这将在 DBAPI
    连接对象上建立正确的标志。
