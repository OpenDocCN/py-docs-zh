["```py\n>>> session.query(Vertex.start, Vertex.end).filter(Vertex.start == Point(3, 4)).all()\n[(Point(x=3, y=4), Point(x=5, y=6))]\n```", "```py\n>>> session.query(Vertex.start.clauses, Vertex.end.clauses).filter(\n...     Vertex.start == Point(3, 4)\n... ).all()\n[(3, 4, 5, 6)]\n```", "```py\nselect_stmt = select([User]).where(User.id == 7).alias()\n\nq = (\n    session.query(User)\n    .join(select_stmt, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  \"user\"  JOIN  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  ON  \"user\".id  =  anon_1.id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nq = (\n    session.query(User)\n    .select_from(select_stmt)\n    .join(User, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\n-- SQLAlchemy 0.8 and earlier...\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.name  AS  anon_1_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  anon_1.id  =  anon_1.id\nWHERE  anon_1.name  =  :name_1\n```", "```py\nselect_stmt = select([User]).where(User.id == 7)\nuser_from_stmt = aliased(User, select_stmt.alias())\n\nq = session.query(user_from_stmt).filter(user_from_stmt.name == \"ed\")\n```", "```py\n-- SQLAlchemy 0.9\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  \"user\".id  =  id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey, create_engine\nfrom sqlalchemy.orm import backref, relationship, Session\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import inspect\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    a = relationship(\"A\", backref=backref(\"bs\", viewonly=True))\n\ne = create_engine(\"sqlite://\")\nBase.metadata.create_all(e)\n\na = A()\nb = B()\n\nsess = Session(e)\nsess.add_all([a, b])\nsess.commit()\n\nb.a = a\n\nassert b in sess.dirty\n\n# before 0.9.0\n# assert a in sess.dirty\n# assert inspect(a).attrs.bs.history.has_changes()\n\n# after 0.9.0\nassert a not in sess.dirty\nassert not inspect(a).attrs.bs.history.has_changes()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    b_id = Column(Integer, ForeignKey(\"b.id\"), primary_key=True)\n    b = relationship(\"B\")\n    b_value = association_proxy(\"b\", \"value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\ns.query(A).filter(A.b_value == None).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL)\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))  OR  a.b_id  IS  NULL\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  NOT  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NOT  NULL)\n```", "```py\ns.query(A).filter(A.b_value.has()).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id)\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy.orm import *\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.associationproxy import association_proxy\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\n    bname = association_proxy(\"b\", \"name\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    name = Column(String)\n\na1 = A()\n\n# this is how m2o's always have worked\nassert a1.b is None\n\n# but prior to 0.9, this would raise AttributeError,\n# now returns None just like the proxied value.\nassert a1.bname is None\n```", "```py\nfrom sqlalchemy import Column, Integer, String, create_engine, inspect\nfrom sqlalchemy.orm import Session, attributes\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\nsess = Session(e)\n\na1 = A(data=\"a1\")\nsess.add(a1)\nsess.commit()  # a1 is now expired\n\n# history doesn't emit loader callables\nassert inspect(a1).attrs.data.history == (None, None, None)\n\n# in 0.8, this would fail to load the unloaded state.\nassert attributes.get_history(a1, \"data\") == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n\n# load_history() is now equivalent to get_history() with\n# passive=PASSIVE_OFF ^ INIT_OK\nassert inspect(a1).attrs.data.load_history() == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n```", "```py\nfrom sqlalchemy import Date, Integer\n\n# storage_format argument here has no effect on any backend;\n# it needs to be on the SQLite-specific type\nd = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\n# display_width argument here has no effect on any backend;\n# it needs to be on the MySQL-specific type\ni = Integer(display_width=5)\n```", "```py\n$ python -W always::DeprecationWarning ~/dev/sqlalchemy/test.py\n/Users/classic/dev/sqlalchemy/test.py:5: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Date'> is deprecated\n  d = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n/Users/classic/dev/sqlalchemy/test.py:9: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Integer'> is deprecated\n  i = Integer(display_width=5)\n```", "```py\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\ni = INTEGER(display_width=5)\n```", "```py\nfrom sqlalchemy import Date, Integer\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = Date().with_variant(\n    DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\"), \"sqlite\"\n)\n\ni = Integer().with_variant(INTEGER(display_width=5), \"mysql\")\n```", "```py\ncondition = None\n\nfor cond in conditions:\n    condition = condition & cond\n\nif condition is not None:\n    stmt = stmt.where(condition)\n```", "```py\nfrom sqlalchemy.sql import and_\n\nif conditions:\n    stmt = stmt.where(and_(*conditions))\n```", "```py\nfrom sqlalchemy.sql import true\n\ncondition = true()\n\nfor cond in conditions:\n    condition = cond & condition\n\nstmt = stmt.where(condition)\n```", "```py\n# password: \"pass word + other:words\"\ndbtype://user:pass word + other%3Awords@host/dbname\n\n# password: \"apples/oranges\"\ndbtype://username:apples%2Foranges@hostspec/database\n\n# password: \"apples@oranges@@\"\ndbtype://username:apples%40oranges%40%40@hostspec/database\n\n# password: '', username is \"username@\"\ndbtype://username%40:@hostspec/database\n```", "```py\nprint((column(\"x\") == \"somevalue\").collate(\"en_EN\"))\n```", "```py\n-- 0.8 behavior\n(x  =  :x_1)  COLLATE  en_EN\n```", "```py\n-- 0.9 behavior\nx  =  :x_1  COLLATE  en_EN\n```", "```py\nprint(column(\"x\") == literal(\"somevalue\").collate(\"en_EN\"))\n```", "```py\nx  =  :param_1  COLLATE  en_EN\n```", "```py\nx  =  (:param_1  COLLATE  en_EN)\n```", "```py\n>>> # 0.8\n>>> print(column(\"x\").collate(\"en_EN\").desc())\n(x  COLLATE  en_EN)  DESC\n>>> # 0.9\n>>> print(column(\"x\").collate(\"en_EN\").desc())\nx  COLLATE  en_EN  DESC \n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> type = postgresql.ENUM(\"one\", \"two\", \"three's\", name=\"myenum\")\n>>> from sqlalchemy.dialects.postgresql import base\n>>> print(base.CreateEnumType(type).compile(dialect=postgresql.dialect()))\nCREATE  TYPE  myenum  AS  ENUM  ('one','two','three''s') \n```", "```py\n@event.listens_for(MyClass, \"before_insert\", propagate=True)\ndef my_before_insert(mapper, connection, target):\n  \"\"\"listen for before_insert\"\"\"\n    # ...\n\nevent.remove(MyClass, \"before_insert\", my_before_insert)\n```", "```py\nquery(User).options(joinedload_all(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(joinedload(\"orders\").joinedload(\"items\").joinedload(\"keywords\"))\n```", "```py\nsession.query(Company).options(\n    subqueryload_all(Company.employees.of_type(Engineer), Engineer.machines)\n)\n```", "```py\nsession.query(Company).options(\n    subqueryload(Company.employees.of_type(Engineer)).subqueryload(\"machines\")\n)\n```", "```py\nquery(User).options(subqueryload(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defaultload(\"items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders.items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defer(\"orders.description\"), defer(\"orders.isopen\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defer(\"description\").defer(\"isopen\"))\n```", "```py\nfrom sqlalchemy.orm import Load\n\nquery(User, Address).options(Load(Address).joinedload(\"entries\"))\n```", "```py\nfrom sqlalchemy.orm import load_only\n\nquery(User).options(load_only(\"name\", \"fullname\"))\n\n# specify explicit parent entity\nquery(User, Address).options(Load(User).load_only(\"name\", \"fullname\"))\n\n# specify path\nquery(User).options(joinedload(User.addresses).load_only(\"email_address\"))\n```", "```py\n# lazyload all User relationships\nquery(User).options(Load(User).lazyload(\"*\"))\n\n# undefer all User columns\nquery(User).options(Load(User).undefer(\"*\"))\n\n# lazyload all Address relationships\nquery(User).options(defaultload(User.addresses).lazyload(\"*\"))\n\n# undefer all Address columns\nquery(User).options(defaultload(User.addresses).undefer(\"*\"))\n```", "```py\n    # setup values\n    stmt = text(\n        \"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\"\n    ).bindparams(name=\"ed\", timestamp=datetime(2012, 11, 10, 15, 12, 35))\n\n    # setup types and/or values\n    stmt = (\n        text(\"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\")\n        .bindparams(bindparam(\"name\", value=\"ed\"), bindparam(\"timestamp\", type_=DateTime()))\n        .bindparam(timestamp=datetime(2012, 11, 10, 15, 12, 35))\n    )\n    ```", "```py\n    # turn a text() into an alias(), with a .c. collection:\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.alias()\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n\n    # or into a cte():\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.cte(\"x\")\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n    ```", "```py\n>>> from sqlalchemy.sql import table, column\n>>> t1 = table(\"t1\", column(\"a\"), column(\"b\"))\n>>> t2 = table(\"t2\", column(\"x\"), column(\"y\"))\n>>> print(t1.insert().from_select([\"a\", \"b\"], t2.select().where(t2.c.y == 5)))\nINSERT  INTO  t1  (a,  b)  SELECT  t2.x,  t2.y\nFROM  t2\nWHERE  t2.y  =  :y_1 \n```", "```py\ns = Session()\nq = s.query(User.id, User.name).filter_by(name=\"ed\")\nins = insert(Address).from_select((Address.id, Address.email_address), q)\n```", "```py\nINSERT  INTO  addresses  (id,  email_address)\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users  WHERE  users.name  =  :name_1\n```", "```py\nstmt = select([table]).with_for_update(read=True, nowait=True, of=table)\n```", "```py\nSELECT  table.a,  table.b  FROM  table  FOR  SHARE  OF  table  NOWAIT\n```", "```py\nfrom sqlalchemy.dialects.mysql import DOUBLE\nimport decimal\n\ndata = Table(\n    \"data\",\n    metadata,\n    Column(\"double_value\", mysql.DOUBLE(decimal_return_scale=12, asdecimal=True)),\n)\n\nconn.execute(\n    data.insert(),\n    double_value=45.768392065789,\n)\nresult = conn.scalar(select([data.c.double_value]))\n\n# previously, this would typically be Decimal(\"45.7683920658\"),\n# e.g. trimmed to 10 decimal places\n\n# now we get 12, as requested, as MySQL can support this\n# much precision for DOUBLE\nassert result == decimal.Decimal(\"45.768392065789\")\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship, validates\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\n    @validates(\"bs\")\n    def validate_bs(self, key, item):\n        print(\"A.bs validator\")\n        return item\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    @validates(\"a\", include_backrefs=False)\n    def validate_a(self, key, item):\n        print(\"B.a validator\")\n        return item\n\na1 = A()\na1.bs.append(B())  # prints only \"A.bs validator\"\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import create_engine\n\nBase = automap_base()\n\n# engine, suppose it has two tables 'user' and 'address' set up\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# reflect the tables\nBase.prepare(engine, reflect=True)\n\n# mapped classes are now created with names matching that of the table\n# name.\nUser = Base.classes.user\nAddress = Base.classes.address\n\nsession = Session(engine)\n\n# rudimentary relationships are produced\nsession.add(Address(email_address=\"foo@bar.com\", user=User(name=\"foo\")))\nsession.commit()\n\n# collection-based relationships are by default named \"<classname>_collection\"\nprint(u1.address_collection)\n```", "```py\nSELECT  a.*,  b.*,  c.*  FROM  a  LEFT  OUTER  JOIN  (b  JOIN  c  ON  b.id  =  c.id)  ON  a.id\n```", "```py\nSQLite version 3.7.15.2 2013-01-09 11:53:05\nEnter \".help\" for instructions\nEnter SQL statements terminated with a \";\"\nsqlite> create table a(id integer);\nsqlite> create table b(id integer);\nsqlite> create table c(id integer);\nsqlite> select a.id, b.id, c.id from a left outer join (b join c on b.id=c.id) on b.id=a.id;\nError: no such column: b.id\n```", "```py\nsqlite>  select  a.id,  b.id,  c.id  from  b  join  c  on  b.id=c.id\n  ...>  right  outer  join  a  on  b.id=a.id;\nError:  RIGHT  and  FULL  OUTER  JOINs  are  not  currently  supported\n```", "```py\nSELECT  a.*,  anon_1.*  FROM  a  LEFT  OUTER  JOIN  (\n  SELECT  b.id  AS  b_id,  c.id  AS  c_id\n  FROM  b  JOIN  c  ON  b.id  =  c.id\n  )  AS  anon_1  ON  a.id=anon_1.b_id\n```", "```py\nsession.query(Order).outerjoin(Order.items)\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN  order_item  ON  order.id  =  order_item.order_id\nLEFT  OUTER  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem'\n```", "```py\nSELECT  parent.id  AS  parent_id\nFROM  parent  JOIN  (\n  base_table  JOIN  subclass_table\n  ON  base_table.id  =  subclass_table.id)  ON  parent.id  =  base_table.parent_id\n```", "```py\nSELECT  parent.*,  base_table_1.*,  subclass_table_1.*  FROM  parent\n  LEFT  OUTER  JOIN  (\n  base_table  AS  base_table_1  JOIN  subclass_table  AS  subclass_table_1\n  ON  base_table_1.id  =  subclass_table_1.id)\n  ON  parent.id  =  base_table_1.parent_id\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN\n(order_item  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem')\nON  order_item.order_id  =  order.id\n```", "```py\n-- sqlite only!\nSELECT  parent.id  AS  parent_id\n  FROM  parent  JOIN  (\n  SELECT  base_table.id  AS  base_table_id,\n  base_table.parent_id  AS  base_table_parent_id,\n  subclass_table.id  AS  subclass_table_id\n  FROM  base_table  JOIN  subclass_table  ON  base_table.id  =  subclass_table.id\n  )  AS  anon_1  ON  parent.id  =  anon_1.base_table_parent_id\n\n-- sqlite only!\nSELECT  parent.id  AS  parent_id,  anon_1.subclass_table_1_id  AS  subclass_table_1_id,\n  anon_1.base_table_1_id  AS  base_table_1_id,\n  anon_1.base_table_1_parent_id  AS  base_table_1_parent_id\nFROM  parent  LEFT  OUTER  JOIN  (\n  SELECT  base_table_1.id  AS  base_table_1_id,\n  base_table_1.parent_id  AS  base_table_1_parent_id,\n  subclass_table_1.id  AS  subclass_table_1_id\n  FROM  base_table  AS  base_table_1\n  JOIN  subclass_table  AS  subclass_table_1  ON  base_table_1.id  =  subclass_table_1.id\n)  AS  anon_1  ON  parent.id  =  anon_1.base_table_1_parent_id\n\n-- sqlite only!\nSELECT  \"order\".id  AS  order_id\nFROM  \"order\"  LEFT  OUTER  JOIN  (\n  SELECT  order_item_1.order_id  AS  order_item_1_order_id,\n  order_item_1.item_id  AS  order_item_1_item_id,\n  item.id  AS  item_id,  item.type  AS  item_type\nFROM  order_item  AS  order_item_1\n  JOIN  item  ON  item.id  =  order_item_1.item_id  AND  item.type  IN  (?)\n)  AS  anon_1  ON  \"order\".id  =  anon_1.order_item_1_order_id\n```", "```py\nemployee_alias = with_polymorphic(Person, [Engineer, Manager], flat=True)\n\nsession.query(Company).join(Company.employees.of_type(employee_alias)).filter(\n    or_(Engineer.primary_language == \"python\", Manager.manager_name == \"dilbert\")\n)\n```", "```py\nSELECT  companies.company_id  AS  companies_company_id,  companies.name  AS  companies_name\nFROM  companies  JOIN  (\n  people  AS  people_1\n  LEFT  OUTER  JOIN  engineers  AS  engineers_1  ON  people_1.person_id  =  engineers_1.person_id\n  LEFT  OUTER  JOIN  managers  AS  managers_1  ON  people_1.person_id  =  managers_1.person_id\n)  ON  companies.company_id  =  people_1.company_id\nWHERE  engineers.primary_language  =  %(primary_language_1)s\n  OR  managers.manager_name  =  %(manager_name_1)s\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  orders  ON  <onclause>  LEFT  OUTER  JOIN  items  ON  <onclause>\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  (orders  JOIN  items  ON  <onclause>)  ON  <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"nested\")\n)\n```", "```py\nSELECT  b.id  AS  b_id,  b.name  AS  b_name,  anon_1.b_id  AS  a_b_id\nFROM  (SELECT  DISTINCT  a_b_id  FROM  a)  AS  anon_1\nJOIN  b  ON  b.id  =  anon_1.a_b_id\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\np1 = Parent()\np2 = Parent()\nc1 = Child()\n\np1.children.append(c1)\n\nassert c1.parent is p1  # backref event establishes c1.parent as p1\n\np2.children.append(c1)\n\nassert c1.parent is p2  # backref event establishes c1.parent as p2\nassert c1 not in p1.children  # second backref event removes c1 from p1.children\n```", "```py\nfrom sqlalchemy import Table, Boolean, Integer, Column, MetaData\n\nt1 = Table(\"t\", MetaData(), Column(\"x\", Boolean()), Column(\"y\", Integer))\n```", "```py\n>>> from sqlalchemy import select, and_, false, true\n>>> from sqlalchemy.dialects import mysql, postgresql\n\n>>> print(select([t1]).where(t1.c.x).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.x  =  1 \n```", "```py\n>>> print(\n...     select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=postgresql.dialect())\n... )\nSELECT  t.x,  t.y  FROM  t  WHERE  false \n```", "```py\n>>> expr = true()\n>>> expr = expr & (t1.c.y > 5)\n>>> print(select([t1]).where(expr))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.y  >  :y_1 \n```", "```py\n>>> print(select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  0  =  1 \n```", "```py\n>>> print(select([t1.c.x]).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL\n>>> print(select([t1.c.x]).where(None).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL\n>>> print(select([t1.c.x]).where(and_(None, None)))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL \n```", "```py\nfrom sqlalchemy.sql import table, column, select, func\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\nexpr = (func.foo(t.c.c1) + t.c.c2).label(\"expr\")\n\nstmt = select([expr]).order_by(expr)\n\nprint(stmt)\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  foo(t.c1)  +  t.c2\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  expr\n```", "```py\nusers.insert().execute(\n    dict(user_id=1, user_name=\"foo\"),\n    dict(user_id=2, user_name=\"bar\"),\n    dict(user_id=3, user_name=\"def\"),\n)\n\nrows = users.select().order_by(users.c.user_name).execute().fetchall()\n\neq_(rows, [(2, \"bar\"), (3, \"def\"), (1, \"foo\")])\n\neq_(sorted(rows), [(1, \"foo\"), (2, \"bar\"), (3, \"def\")])\n```", "```py\nbp = bindparam(\"some_col\")\n```", "```py\nexpr = mytable.c.col == bp\n```", "```py\nstmt = mytable.update().values(col=bp)\n```", "```py\n>>> compiled = stmt.compile()\n>>> compiled.binds[\"some_col\"].type\nString\n```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKeyConstraint\n    >>> metadata = MetaData()\n    >>> t2 = Table(\n    ...     \"t2\",\n    ...     metadata,\n    ...     Column(\"t1a\"),\n    ...     Column(\"t1b\"),\n    ...     ForeignKeyConstraint([\"t1a\", \"t1b\"], [\"t1.a\", \"t1.b\"]),\n    ... )\n    >>> t2.c.t1a.type\n    NullType()\n    >>> t2.c.t1b.type\n    NullType()\n    >>> t1 = Table(\n    ...     \"t1\",\n    ...     metadata,\n    ...     Column(\"a\", Integer, primary_key=True),\n    ...     Column(\"b\", Integer, primary_key=True),\n    ... )\n    >>> t2.c.t1a.type\n    Integer()\n    >>> t2.c.t1b.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t3 = Table(\"t3\", metadata, Column(\"t2t1id\", ForeignKey(\"t2.t1id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t3.c.t2t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    >>> t3.c.t2t1id.type\n    Integer()\n    ```", "```py\n>>> session.query(Vertex.start, Vertex.end).filter(Vertex.start == Point(3, 4)).all()\n[(Point(x=3, y=4), Point(x=5, y=6))]\n```", "```py\n>>> session.query(Vertex.start.clauses, Vertex.end.clauses).filter(\n...     Vertex.start == Point(3, 4)\n... ).all()\n[(3, 4, 5, 6)]\n```", "```py\nselect_stmt = select([User]).where(User.id == 7).alias()\n\nq = (\n    session.query(User)\n    .join(select_stmt, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  \"user\"  JOIN  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  ON  \"user\".id  =  anon_1.id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nq = (\n    session.query(User)\n    .select_from(select_stmt)\n    .join(User, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\n-- SQLAlchemy 0.8 and earlier...\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.name  AS  anon_1_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  anon_1.id  =  anon_1.id\nWHERE  anon_1.name  =  :name_1\n```", "```py\nselect_stmt = select([User]).where(User.id == 7)\nuser_from_stmt = aliased(User, select_stmt.alias())\n\nq = session.query(user_from_stmt).filter(user_from_stmt.name == \"ed\")\n```", "```py\n-- SQLAlchemy 0.9\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  \"user\".id  =  id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey, create_engine\nfrom sqlalchemy.orm import backref, relationship, Session\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import inspect\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    a = relationship(\"A\", backref=backref(\"bs\", viewonly=True))\n\ne = create_engine(\"sqlite://\")\nBase.metadata.create_all(e)\n\na = A()\nb = B()\n\nsess = Session(e)\nsess.add_all([a, b])\nsess.commit()\n\nb.a = a\n\nassert b in sess.dirty\n\n# before 0.9.0\n# assert a in sess.dirty\n# assert inspect(a).attrs.bs.history.has_changes()\n\n# after 0.9.0\nassert a not in sess.dirty\nassert not inspect(a).attrs.bs.history.has_changes()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    b_id = Column(Integer, ForeignKey(\"b.id\"), primary_key=True)\n    b = relationship(\"B\")\n    b_value = association_proxy(\"b\", \"value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\ns.query(A).filter(A.b_value == None).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL)\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))  OR  a.b_id  IS  NULL\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  NOT  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NOT  NULL)\n```", "```py\ns.query(A).filter(A.b_value.has()).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id)\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy.orm import *\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.associationproxy import association_proxy\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\n    bname = association_proxy(\"b\", \"name\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    name = Column(String)\n\na1 = A()\n\n# this is how m2o's always have worked\nassert a1.b is None\n\n# but prior to 0.9, this would raise AttributeError,\n# now returns None just like the proxied value.\nassert a1.bname is None\n```", "```py\nfrom sqlalchemy import Column, Integer, String, create_engine, inspect\nfrom sqlalchemy.orm import Session, attributes\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\nsess = Session(e)\n\na1 = A(data=\"a1\")\nsess.add(a1)\nsess.commit()  # a1 is now expired\n\n# history doesn't emit loader callables\nassert inspect(a1).attrs.data.history == (None, None, None)\n\n# in 0.8, this would fail to load the unloaded state.\nassert attributes.get_history(a1, \"data\") == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n\n# load_history() is now equivalent to get_history() with\n# passive=PASSIVE_OFF ^ INIT_OK\nassert inspect(a1).attrs.data.load_history() == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n```", "```py\n>>> session.query(Vertex.start, Vertex.end).filter(Vertex.start == Point(3, 4)).all()\n[(Point(x=3, y=4), Point(x=5, y=6))]\n```", "```py\n>>> session.query(Vertex.start.clauses, Vertex.end.clauses).filter(\n...     Vertex.start == Point(3, 4)\n... ).all()\n[(3, 4, 5, 6)]\n```", "```py\nselect_stmt = select([User]).where(User.id == 7).alias()\n\nq = (\n    session.query(User)\n    .join(select_stmt, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  \"user\"  JOIN  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  ON  \"user\".id  =  anon_1.id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nq = (\n    session.query(User)\n    .select_from(select_stmt)\n    .join(User, User.id == select_stmt.c.id)\n    .filter(User.name == \"ed\")\n)\n```", "```py\n-- SQLAlchemy 0.8 and earlier...\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.name  AS  anon_1_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  anon_1.id  =  anon_1.id\nWHERE  anon_1.name  =  :name_1\n```", "```py\nselect_stmt = select([User]).where(User.id == 7)\nuser_from_stmt = aliased(User, select_stmt.alias())\n\nq = session.query(user_from_stmt).filter(user_from_stmt.name == \"ed\")\n```", "```py\n-- SQLAlchemy 0.9\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name\nFROM  (SELECT  \"user\".id  AS  id,  \"user\".name  AS  name\nFROM  \"user\"\nWHERE  \"user\".id  =  :id_1)  AS  anon_1  JOIN  \"user\"  ON  \"user\".id  =  id\nWHERE  \"user\".name  =  :name_1\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey, create_engine\nfrom sqlalchemy.orm import backref, relationship, Session\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import inspect\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    a = relationship(\"A\", backref=backref(\"bs\", viewonly=True))\n\ne = create_engine(\"sqlite://\")\nBase.metadata.create_all(e)\n\na = A()\nb = B()\n\nsess = Session(e)\nsess.add_all([a, b])\nsess.commit()\n\nb.a = a\n\nassert b in sess.dirty\n\n# before 0.9.0\n# assert a in sess.dirty\n# assert inspect(a).attrs.bs.history.has_changes()\n\n# after 0.9.0\nassert a not in sess.dirty\nassert not inspect(a).attrs.bs.history.has_changes()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    b_id = Column(Integer, ForeignKey(\"b.id\"), primary_key=True)\n    b = relationship(\"B\")\n    b_value = association_proxy(\"b\", \"value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\ns.query(A).filter(A.b_value == None).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL)\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))  OR  a.b_id  IS  NULL\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  NOT  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NULL))\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id  AND  b.value  IS  NOT  NULL)\n```", "```py\ns.query(A).filter(A.b_value.has()).all()\n```", "```py\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  a.b_id)\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy.orm import *\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.associationproxy import association_proxy\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\n    bname = association_proxy(\"b\", \"name\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n    name = Column(String)\n\na1 = A()\n\n# this is how m2o's always have worked\nassert a1.b is None\n\n# but prior to 0.9, this would raise AttributeError,\n# now returns None just like the proxied value.\nassert a1.bname is None\n```", "```py\nfrom sqlalchemy import Column, Integer, String, create_engine, inspect\nfrom sqlalchemy.orm import Session, attributes\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\nsess = Session(e)\n\na1 = A(data=\"a1\")\nsess.add(a1)\nsess.commit()  # a1 is now expired\n\n# history doesn't emit loader callables\nassert inspect(a1).attrs.data.history == (None, None, None)\n\n# in 0.8, this would fail to load the unloaded state.\nassert attributes.get_history(a1, \"data\") == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n\n# load_history() is now equivalent to get_history() with\n# passive=PASSIVE_OFF ^ INIT_OK\nassert inspect(a1).attrs.data.load_history() == (\n    (),\n    [\n        \"a1\",\n    ],\n    (),\n)\n```", "```py\nfrom sqlalchemy import Date, Integer\n\n# storage_format argument here has no effect on any backend;\n# it needs to be on the SQLite-specific type\nd = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\n# display_width argument here has no effect on any backend;\n# it needs to be on the MySQL-specific type\ni = Integer(display_width=5)\n```", "```py\n$ python -W always::DeprecationWarning ~/dev/sqlalchemy/test.py\n/Users/classic/dev/sqlalchemy/test.py:5: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Date'> is deprecated\n  d = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n/Users/classic/dev/sqlalchemy/test.py:9: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Integer'> is deprecated\n  i = Integer(display_width=5)\n```", "```py\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\ni = INTEGER(display_width=5)\n```", "```py\nfrom sqlalchemy import Date, Integer\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = Date().with_variant(\n    DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\"), \"sqlite\"\n)\n\ni = Integer().with_variant(INTEGER(display_width=5), \"mysql\")\n```", "```py\ncondition = None\n\nfor cond in conditions:\n    condition = condition & cond\n\nif condition is not None:\n    stmt = stmt.where(condition)\n```", "```py\nfrom sqlalchemy.sql import and_\n\nif conditions:\n    stmt = stmt.where(and_(*conditions))\n```", "```py\nfrom sqlalchemy.sql import true\n\ncondition = true()\n\nfor cond in conditions:\n    condition = cond & condition\n\nstmt = stmt.where(condition)\n```", "```py\n# password: \"pass word + other:words\"\ndbtype://user:pass word + other%3Awords@host/dbname\n\n# password: \"apples/oranges\"\ndbtype://username:apples%2Foranges@hostspec/database\n\n# password: \"apples@oranges@@\"\ndbtype://username:apples%40oranges%40%40@hostspec/database\n\n# password: '', username is \"username@\"\ndbtype://username%40:@hostspec/database\n```", "```py\nprint((column(\"x\") == \"somevalue\").collate(\"en_EN\"))\n```", "```py\n-- 0.8 behavior\n(x  =  :x_1)  COLLATE  en_EN\n```", "```py\n-- 0.9 behavior\nx  =  :x_1  COLLATE  en_EN\n```", "```py\nprint(column(\"x\") == literal(\"somevalue\").collate(\"en_EN\"))\n```", "```py\nx  =  :param_1  COLLATE  en_EN\n```", "```py\nx  =  (:param_1  COLLATE  en_EN)\n```", "```py\n>>> # 0.8\n>>> print(column(\"x\").collate(\"en_EN\").desc())\n(x  COLLATE  en_EN)  DESC\n>>> # 0.9\n>>> print(column(\"x\").collate(\"en_EN\").desc())\nx  COLLATE  en_EN  DESC \n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> type = postgresql.ENUM(\"one\", \"two\", \"three's\", name=\"myenum\")\n>>> from sqlalchemy.dialects.postgresql import base\n>>> print(base.CreateEnumType(type).compile(dialect=postgresql.dialect()))\nCREATE  TYPE  myenum  AS  ENUM  ('one','two','three''s') \n```", "```py\nfrom sqlalchemy import Date, Integer\n\n# storage_format argument here has no effect on any backend;\n# it needs to be on the SQLite-specific type\nd = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\n# display_width argument here has no effect on any backend;\n# it needs to be on the MySQL-specific type\ni = Integer(display_width=5)\n```", "```py\n$ python -W always::DeprecationWarning ~/dev/sqlalchemy/test.py\n/Users/classic/dev/sqlalchemy/test.py:5: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Date'> is deprecated\n  d = Date(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n/Users/classic/dev/sqlalchemy/test.py:9: SADeprecationWarning: Passing arguments to\ntype object constructor <class 'sqlalchemy.types.Integer'> is deprecated\n  i = Integer(display_width=5)\n```", "```py\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\")\n\ni = INTEGER(display_width=5)\n```", "```py\nfrom sqlalchemy import Date, Integer\nfrom sqlalchemy.dialects.sqlite import DATE\nfrom sqlalchemy.dialects.mysql import INTEGER\n\nd = Date().with_variant(\n    DATE(storage_format=\"%(day)02d.%(month)02d.%(year)04d\"), \"sqlite\"\n)\n\ni = Integer().with_variant(INTEGER(display_width=5), \"mysql\")\n```", "```py\ncondition = None\n\nfor cond in conditions:\n    condition = condition & cond\n\nif condition is not None:\n    stmt = stmt.where(condition)\n```", "```py\nfrom sqlalchemy.sql import and_\n\nif conditions:\n    stmt = stmt.where(and_(*conditions))\n```", "```py\nfrom sqlalchemy.sql import true\n\ncondition = true()\n\nfor cond in conditions:\n    condition = cond & condition\n\nstmt = stmt.where(condition)\n```", "```py\n# password: \"pass word + other:words\"\ndbtype://user:pass word + other%3Awords@host/dbname\n\n# password: \"apples/oranges\"\ndbtype://username:apples%2Foranges@hostspec/database\n\n# password: \"apples@oranges@@\"\ndbtype://username:apples%40oranges%40%40@hostspec/database\n\n# password: '', username is \"username@\"\ndbtype://username%40:@hostspec/database\n```", "```py\nprint((column(\"x\") == \"somevalue\").collate(\"en_EN\"))\n```", "```py\n-- 0.8 behavior\n(x  =  :x_1)  COLLATE  en_EN\n```", "```py\n-- 0.9 behavior\nx  =  :x_1  COLLATE  en_EN\n```", "```py\nprint(column(\"x\") == literal(\"somevalue\").collate(\"en_EN\"))\n```", "```py\nx  =  :param_1  COLLATE  en_EN\n```", "```py\nx  =  (:param_1  COLLATE  en_EN)\n```", "```py\n>>> # 0.8\n>>> print(column(\"x\").collate(\"en_EN\").desc())\n(x  COLLATE  en_EN)  DESC\n>>> # 0.9\n>>> print(column(\"x\").collate(\"en_EN\").desc())\nx  COLLATE  en_EN  DESC \n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> type = postgresql.ENUM(\"one\", \"two\", \"three's\", name=\"myenum\")\n>>> from sqlalchemy.dialects.postgresql import base\n>>> print(base.CreateEnumType(type).compile(dialect=postgresql.dialect()))\nCREATE  TYPE  myenum  AS  ENUM  ('one','two','three''s') \n```", "```py\n@event.listens_for(MyClass, \"before_insert\", propagate=True)\ndef my_before_insert(mapper, connection, target):\n  \"\"\"listen for before_insert\"\"\"\n    # ...\n\nevent.remove(MyClass, \"before_insert\", my_before_insert)\n```", "```py\nquery(User).options(joinedload_all(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(joinedload(\"orders\").joinedload(\"items\").joinedload(\"keywords\"))\n```", "```py\nsession.query(Company).options(\n    subqueryload_all(Company.employees.of_type(Engineer), Engineer.machines)\n)\n```", "```py\nsession.query(Company).options(\n    subqueryload(Company.employees.of_type(Engineer)).subqueryload(\"machines\")\n)\n```", "```py\nquery(User).options(subqueryload(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defaultload(\"items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders.items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defer(\"orders.description\"), defer(\"orders.isopen\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defer(\"description\").defer(\"isopen\"))\n```", "```py\nfrom sqlalchemy.orm import Load\n\nquery(User, Address).options(Load(Address).joinedload(\"entries\"))\n```", "```py\nfrom sqlalchemy.orm import load_only\n\nquery(User).options(load_only(\"name\", \"fullname\"))\n\n# specify explicit parent entity\nquery(User, Address).options(Load(User).load_only(\"name\", \"fullname\"))\n\n# specify path\nquery(User).options(joinedload(User.addresses).load_only(\"email_address\"))\n```", "```py\n# lazyload all User relationships\nquery(User).options(Load(User).lazyload(\"*\"))\n\n# undefer all User columns\nquery(User).options(Load(User).undefer(\"*\"))\n\n# lazyload all Address relationships\nquery(User).options(defaultload(User.addresses).lazyload(\"*\"))\n\n# undefer all Address columns\nquery(User).options(defaultload(User.addresses).undefer(\"*\"))\n```", "```py\n    # setup values\n    stmt = text(\n        \"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\"\n    ).bindparams(name=\"ed\", timestamp=datetime(2012, 11, 10, 15, 12, 35))\n\n    # setup types and/or values\n    stmt = (\n        text(\"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\")\n        .bindparams(bindparam(\"name\", value=\"ed\"), bindparam(\"timestamp\", type_=DateTime()))\n        .bindparam(timestamp=datetime(2012, 11, 10, 15, 12, 35))\n    )\n    ```", "```py\n    # turn a text() into an alias(), with a .c. collection:\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.alias()\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n\n    # or into a cte():\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.cte(\"x\")\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n    ```", "```py\n>>> from sqlalchemy.sql import table, column\n>>> t1 = table(\"t1\", column(\"a\"), column(\"b\"))\n>>> t2 = table(\"t2\", column(\"x\"), column(\"y\"))\n>>> print(t1.insert().from_select([\"a\", \"b\"], t2.select().where(t2.c.y == 5)))\nINSERT  INTO  t1  (a,  b)  SELECT  t2.x,  t2.y\nFROM  t2\nWHERE  t2.y  =  :y_1 \n```", "```py\ns = Session()\nq = s.query(User.id, User.name).filter_by(name=\"ed\")\nins = insert(Address).from_select((Address.id, Address.email_address), q)\n```", "```py\nINSERT  INTO  addresses  (id,  email_address)\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users  WHERE  users.name  =  :name_1\n```", "```py\nstmt = select([table]).with_for_update(read=True, nowait=True, of=table)\n```", "```py\nSELECT  table.a,  table.b  FROM  table  FOR  SHARE  OF  table  NOWAIT\n```", "```py\nfrom sqlalchemy.dialects.mysql import DOUBLE\nimport decimal\n\ndata = Table(\n    \"data\",\n    metadata,\n    Column(\"double_value\", mysql.DOUBLE(decimal_return_scale=12, asdecimal=True)),\n)\n\nconn.execute(\n    data.insert(),\n    double_value=45.768392065789,\n)\nresult = conn.scalar(select([data.c.double_value]))\n\n# previously, this would typically be Decimal(\"45.7683920658\"),\n# e.g. trimmed to 10 decimal places\n\n# now we get 12, as requested, as MySQL can support this\n# much precision for DOUBLE\nassert result == decimal.Decimal(\"45.768392065789\")\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship, validates\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\n    @validates(\"bs\")\n    def validate_bs(self, key, item):\n        print(\"A.bs validator\")\n        return item\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    @validates(\"a\", include_backrefs=False)\n    def validate_a(self, key, item):\n        print(\"B.a validator\")\n        return item\n\na1 = A()\na1.bs.append(B())  # prints only \"A.bs validator\"\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import create_engine\n\nBase = automap_base()\n\n# engine, suppose it has two tables 'user' and 'address' set up\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# reflect the tables\nBase.prepare(engine, reflect=True)\n\n# mapped classes are now created with names matching that of the table\n# name.\nUser = Base.classes.user\nAddress = Base.classes.address\n\nsession = Session(engine)\n\n# rudimentary relationships are produced\nsession.add(Address(email_address=\"foo@bar.com\", user=User(name=\"foo\")))\nsession.commit()\n\n# collection-based relationships are by default named \"<classname>_collection\"\nprint(u1.address_collection)\n```", "```py\n@event.listens_for(MyClass, \"before_insert\", propagate=True)\ndef my_before_insert(mapper, connection, target):\n  \"\"\"listen for before_insert\"\"\"\n    # ...\n\nevent.remove(MyClass, \"before_insert\", my_before_insert)\n```", "```py\nquery(User).options(joinedload_all(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(joinedload(\"orders\").joinedload(\"items\").joinedload(\"keywords\"))\n```", "```py\nsession.query(Company).options(\n    subqueryload_all(Company.employees.of_type(Engineer), Engineer.machines)\n)\n```", "```py\nsession.query(Company).options(\n    subqueryload(Company.employees.of_type(Engineer)).subqueryload(\"machines\")\n)\n```", "```py\nquery(User).options(subqueryload(\"orders.items.keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defaultload(\"items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defaultload(\"orders.items\").subqueryload(\"keywords\"))\n```", "```py\nquery(User).options(defer(\"orders.description\"), defer(\"orders.isopen\"))\n```", "```py\nquery(User).options(defaultload(\"orders\").defer(\"description\").defer(\"isopen\"))\n```", "```py\nfrom sqlalchemy.orm import Load\n\nquery(User, Address).options(Load(Address).joinedload(\"entries\"))\n```", "```py\nfrom sqlalchemy.orm import load_only\n\nquery(User).options(load_only(\"name\", \"fullname\"))\n\n# specify explicit parent entity\nquery(User, Address).options(Load(User).load_only(\"name\", \"fullname\"))\n\n# specify path\nquery(User).options(joinedload(User.addresses).load_only(\"email_address\"))\n```", "```py\n# lazyload all User relationships\nquery(User).options(Load(User).lazyload(\"*\"))\n\n# undefer all User columns\nquery(User).options(Load(User).undefer(\"*\"))\n\n# lazyload all Address relationships\nquery(User).options(defaultload(User.addresses).lazyload(\"*\"))\n\n# undefer all Address columns\nquery(User).options(defaultload(User.addresses).undefer(\"*\"))\n```", "```py\nfrom sqlalchemy.orm import Load\n\nquery(User, Address).options(Load(Address).joinedload(\"entries\"))\n```", "```py\nfrom sqlalchemy.orm import load_only\n\nquery(User).options(load_only(\"name\", \"fullname\"))\n\n# specify explicit parent entity\nquery(User, Address).options(Load(User).load_only(\"name\", \"fullname\"))\n\n# specify path\nquery(User).options(joinedload(User.addresses).load_only(\"email_address\"))\n```", "```py\n# lazyload all User relationships\nquery(User).options(Load(User).lazyload(\"*\"))\n\n# undefer all User columns\nquery(User).options(Load(User).undefer(\"*\"))\n\n# lazyload all Address relationships\nquery(User).options(defaultload(User.addresses).lazyload(\"*\"))\n\n# undefer all Address columns\nquery(User).options(defaultload(User.addresses).undefer(\"*\"))\n```", "```py\n    # setup values\n    stmt = text(\n        \"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\"\n    ).bindparams(name=\"ed\", timestamp=datetime(2012, 11, 10, 15, 12, 35))\n\n    # setup types and/or values\n    stmt = (\n        text(\"SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp\")\n        .bindparams(bindparam(\"name\", value=\"ed\"), bindparam(\"timestamp\", type_=DateTime()))\n        .bindparam(timestamp=datetime(2012, 11, 10, 15, 12, 35))\n    )\n    ```", "```py\n    # turn a text() into an alias(), with a .c. collection:\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.alias()\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n\n    # or into a cte():\n    stmt = text(\"SELECT id, name FROM user\").columns(id=Integer, name=String)\n    stmt = stmt.cte(\"x\")\n\n    stmt = select([addresses]).select_from(\n        addresses.join(stmt), addresses.c.user_id == stmt.c.id\n    )\n    ```", "```py\n>>> from sqlalchemy.sql import table, column\n>>> t1 = table(\"t1\", column(\"a\"), column(\"b\"))\n>>> t2 = table(\"t2\", column(\"x\"), column(\"y\"))\n>>> print(t1.insert().from_select([\"a\", \"b\"], t2.select().where(t2.c.y == 5)))\nINSERT  INTO  t1  (a,  b)  SELECT  t2.x,  t2.y\nFROM  t2\nWHERE  t2.y  =  :y_1 \n```", "```py\ns = Session()\nq = s.query(User.id, User.name).filter_by(name=\"ed\")\nins = insert(Address).from_select((Address.id, Address.email_address), q)\n```", "```py\nINSERT  INTO  addresses  (id,  email_address)\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users  WHERE  users.name  =  :name_1\n```", "```py\nstmt = select([table]).with_for_update(read=True, nowait=True, of=table)\n```", "```py\nSELECT  table.a,  table.b  FROM  table  FOR  SHARE  OF  table  NOWAIT\n```", "```py\nfrom sqlalchemy.dialects.mysql import DOUBLE\nimport decimal\n\ndata = Table(\n    \"data\",\n    metadata,\n    Column(\"double_value\", mysql.DOUBLE(decimal_return_scale=12, asdecimal=True)),\n)\n\nconn.execute(\n    data.insert(),\n    double_value=45.768392065789,\n)\nresult = conn.scalar(select([data.c.double_value]))\n\n# previously, this would typically be Decimal(\"45.7683920658\"),\n# e.g. trimmed to 10 decimal places\n\n# now we get 12, as requested, as MySQL can support this\n# much precision for DOUBLE\nassert result == decimal.Decimal(\"45.768392065789\")\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship, validates\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\n    @validates(\"bs\")\n    def validate_bs(self, key, item):\n        print(\"A.bs validator\")\n        return item\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    @validates(\"a\", include_backrefs=False)\n    def validate_a(self, key, item):\n        print(\"B.a validator\")\n        return item\n\na1 = A()\na1.bs.append(B())  # prints only \"A.bs validator\"\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import create_engine\n\nBase = automap_base()\n\n# engine, suppose it has two tables 'user' and 'address' set up\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# reflect the tables\nBase.prepare(engine, reflect=True)\n\n# mapped classes are now created with names matching that of the table\n# name.\nUser = Base.classes.user\nAddress = Base.classes.address\n\nsession = Session(engine)\n\n# rudimentary relationships are produced\nsession.add(Address(email_address=\"foo@bar.com\", user=User(name=\"foo\")))\nsession.commit()\n\n# collection-based relationships are by default named \"<classname>_collection\"\nprint(u1.address_collection)\n```", "```py\nSELECT  a.*,  b.*,  c.*  FROM  a  LEFT  OUTER  JOIN  (b  JOIN  c  ON  b.id  =  c.id)  ON  a.id\n```", "```py\nSQLite version 3.7.15.2 2013-01-09 11:53:05\nEnter \".help\" for instructions\nEnter SQL statements terminated with a \";\"\nsqlite> create table a(id integer);\nsqlite> create table b(id integer);\nsqlite> create table c(id integer);\nsqlite> select a.id, b.id, c.id from a left outer join (b join c on b.id=c.id) on b.id=a.id;\nError: no such column: b.id\n```", "```py\nsqlite>  select  a.id,  b.id,  c.id  from  b  join  c  on  b.id=c.id\n  ...>  right  outer  join  a  on  b.id=a.id;\nError:  RIGHT  and  FULL  OUTER  JOINs  are  not  currently  supported\n```", "```py\nSELECT  a.*,  anon_1.*  FROM  a  LEFT  OUTER  JOIN  (\n  SELECT  b.id  AS  b_id,  c.id  AS  c_id\n  FROM  b  JOIN  c  ON  b.id  =  c.id\n  )  AS  anon_1  ON  a.id=anon_1.b_id\n```", "```py\nsession.query(Order).outerjoin(Order.items)\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN  order_item  ON  order.id  =  order_item.order_id\nLEFT  OUTER  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem'\n```", "```py\nSELECT  parent.id  AS  parent_id\nFROM  parent  JOIN  (\n  base_table  JOIN  subclass_table\n  ON  base_table.id  =  subclass_table.id)  ON  parent.id  =  base_table.parent_id\n```", "```py\nSELECT  parent.*,  base_table_1.*,  subclass_table_1.*  FROM  parent\n  LEFT  OUTER  JOIN  (\n  base_table  AS  base_table_1  JOIN  subclass_table  AS  subclass_table_1\n  ON  base_table_1.id  =  subclass_table_1.id)\n  ON  parent.id  =  base_table_1.parent_id\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN\n(order_item  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem')\nON  order_item.order_id  =  order.id\n```", "```py\n-- sqlite only!\nSELECT  parent.id  AS  parent_id\n  FROM  parent  JOIN  (\n  SELECT  base_table.id  AS  base_table_id,\n  base_table.parent_id  AS  base_table_parent_id,\n  subclass_table.id  AS  subclass_table_id\n  FROM  base_table  JOIN  subclass_table  ON  base_table.id  =  subclass_table.id\n  )  AS  anon_1  ON  parent.id  =  anon_1.base_table_parent_id\n\n-- sqlite only!\nSELECT  parent.id  AS  parent_id,  anon_1.subclass_table_1_id  AS  subclass_table_1_id,\n  anon_1.base_table_1_id  AS  base_table_1_id,\n  anon_1.base_table_1_parent_id  AS  base_table_1_parent_id\nFROM  parent  LEFT  OUTER  JOIN  (\n  SELECT  base_table_1.id  AS  base_table_1_id,\n  base_table_1.parent_id  AS  base_table_1_parent_id,\n  subclass_table_1.id  AS  subclass_table_1_id\n  FROM  base_table  AS  base_table_1\n  JOIN  subclass_table  AS  subclass_table_1  ON  base_table_1.id  =  subclass_table_1.id\n)  AS  anon_1  ON  parent.id  =  anon_1.base_table_1_parent_id\n\n-- sqlite only!\nSELECT  \"order\".id  AS  order_id\nFROM  \"order\"  LEFT  OUTER  JOIN  (\n  SELECT  order_item_1.order_id  AS  order_item_1_order_id,\n  order_item_1.item_id  AS  order_item_1_item_id,\n  item.id  AS  item_id,  item.type  AS  item_type\nFROM  order_item  AS  order_item_1\n  JOIN  item  ON  item.id  =  order_item_1.item_id  AND  item.type  IN  (?)\n)  AS  anon_1  ON  \"order\".id  =  anon_1.order_item_1_order_id\n```", "```py\nemployee_alias = with_polymorphic(Person, [Engineer, Manager], flat=True)\n\nsession.query(Company).join(Company.employees.of_type(employee_alias)).filter(\n    or_(Engineer.primary_language == \"python\", Manager.manager_name == \"dilbert\")\n)\n```", "```py\nSELECT  companies.company_id  AS  companies_company_id,  companies.name  AS  companies_name\nFROM  companies  JOIN  (\n  people  AS  people_1\n  LEFT  OUTER  JOIN  engineers  AS  engineers_1  ON  people_1.person_id  =  engineers_1.person_id\n  LEFT  OUTER  JOIN  managers  AS  managers_1  ON  people_1.person_id  =  managers_1.person_id\n)  ON  companies.company_id  =  people_1.company_id\nWHERE  engineers.primary_language  =  %(primary_language_1)s\n  OR  managers.manager_name  =  %(manager_name_1)s\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  orders  ON  <onclause>  LEFT  OUTER  JOIN  items  ON  <onclause>\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  (orders  JOIN  items  ON  <onclause>)  ON  <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"nested\")\n)\n```", "```py\nSELECT  b.id  AS  b_id,  b.name  AS  b_name,  anon_1.b_id  AS  a_b_id\nFROM  (SELECT  DISTINCT  a_b_id  FROM  a)  AS  anon_1\nJOIN  b  ON  b.id  =  anon_1.a_b_id\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\np1 = Parent()\np2 = Parent()\nc1 = Child()\n\np1.children.append(c1)\n\nassert c1.parent is p1  # backref event establishes c1.parent as p1\n\np2.children.append(c1)\n\nassert c1.parent is p2  # backref event establishes c1.parent as p2\nassert c1 not in p1.children  # second backref event removes c1 from p1.children\n```", "```py\nfrom sqlalchemy import Table, Boolean, Integer, Column, MetaData\n\nt1 = Table(\"t\", MetaData(), Column(\"x\", Boolean()), Column(\"y\", Integer))\n```", "```py\n>>> from sqlalchemy import select, and_, false, true\n>>> from sqlalchemy.dialects import mysql, postgresql\n\n>>> print(select([t1]).where(t1.c.x).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.x  =  1 \n```", "```py\n>>> print(\n...     select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=postgresql.dialect())\n... )\nSELECT  t.x,  t.y  FROM  t  WHERE  false \n```", "```py\n>>> expr = true()\n>>> expr = expr & (t1.c.y > 5)\n>>> print(select([t1]).where(expr))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.y  >  :y_1 \n```", "```py\n>>> print(select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  0  =  1 \n```", "```py\n>>> print(select([t1.c.x]).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL\n>>> print(select([t1.c.x]).where(None).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL\n>>> print(select([t1.c.x]).where(and_(None, None)))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL \n```", "```py\nfrom sqlalchemy.sql import table, column, select, func\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\nexpr = (func.foo(t.c.c1) + t.c.c2).label(\"expr\")\n\nstmt = select([expr]).order_by(expr)\n\nprint(stmt)\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  foo(t.c1)  +  t.c2\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  expr\n```", "```py\nusers.insert().execute(\n    dict(user_id=1, user_name=\"foo\"),\n    dict(user_id=2, user_name=\"bar\"),\n    dict(user_id=3, user_name=\"def\"),\n)\n\nrows = users.select().order_by(users.c.user_name).execute().fetchall()\n\neq_(rows, [(2, \"bar\"), (3, \"def\"), (1, \"foo\")])\n\neq_(sorted(rows), [(1, \"foo\"), (2, \"bar\"), (3, \"def\")])\n```", "```py\nbp = bindparam(\"some_col\")\n```", "```py\nexpr = mytable.c.col == bp\n```", "```py\nstmt = mytable.update().values(col=bp)\n```", "```py\n>>> compiled = stmt.compile()\n>>> compiled.binds[\"some_col\"].type\nString\n```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKeyConstraint\n    >>> metadata = MetaData()\n    >>> t2 = Table(\n    ...     \"t2\",\n    ...     metadata,\n    ...     Column(\"t1a\"),\n    ...     Column(\"t1b\"),\n    ...     ForeignKeyConstraint([\"t1a\", \"t1b\"], [\"t1.a\", \"t1.b\"]),\n    ... )\n    >>> t2.c.t1a.type\n    NullType()\n    >>> t2.c.t1b.type\n    NullType()\n    >>> t1 = Table(\n    ...     \"t1\",\n    ...     metadata,\n    ...     Column(\"a\", Integer, primary_key=True),\n    ...     Column(\"b\", Integer, primary_key=True),\n    ... )\n    >>> t2.c.t1a.type\n    Integer()\n    >>> t2.c.t1b.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t3 = Table(\"t3\", metadata, Column(\"t2t1id\", ForeignKey(\"t2.t1id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t3.c.t2t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    >>> t3.c.t2t1id.type\n    Integer()\n    ```", "```py\nSELECT  a.*,  b.*,  c.*  FROM  a  LEFT  OUTER  JOIN  (b  JOIN  c  ON  b.id  =  c.id)  ON  a.id\n```", "```py\nSQLite version 3.7.15.2 2013-01-09 11:53:05\nEnter \".help\" for instructions\nEnter SQL statements terminated with a \";\"\nsqlite> create table a(id integer);\nsqlite> create table b(id integer);\nsqlite> create table c(id integer);\nsqlite> select a.id, b.id, c.id from a left outer join (b join c on b.id=c.id) on b.id=a.id;\nError: no such column: b.id\n```", "```py\nsqlite>  select  a.id,  b.id,  c.id  from  b  join  c  on  b.id=c.id\n  ...>  right  outer  join  a  on  b.id=a.id;\nError:  RIGHT  and  FULL  OUTER  JOINs  are  not  currently  supported\n```", "```py\nSELECT  a.*,  anon_1.*  FROM  a  LEFT  OUTER  JOIN  (\n  SELECT  b.id  AS  b_id,  c.id  AS  c_id\n  FROM  b  JOIN  c  ON  b.id  =  c.id\n  )  AS  anon_1  ON  a.id=anon_1.b_id\n```", "```py\nsession.query(Order).outerjoin(Order.items)\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN  order_item  ON  order.id  =  order_item.order_id\nLEFT  OUTER  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem'\n```", "```py\nSELECT  parent.id  AS  parent_id\nFROM  parent  JOIN  (\n  base_table  JOIN  subclass_table\n  ON  base_table.id  =  subclass_table.id)  ON  parent.id  =  base_table.parent_id\n```", "```py\nSELECT  parent.*,  base_table_1.*,  subclass_table_1.*  FROM  parent\n  LEFT  OUTER  JOIN  (\n  base_table  AS  base_table_1  JOIN  subclass_table  AS  subclass_table_1\n  ON  base_table_1.id  =  subclass_table_1.id)\n  ON  parent.id  =  base_table_1.parent_id\n```", "```py\nSELECT  order.id,  order.name\nFROM  order  LEFT  OUTER  JOIN\n(order_item  JOIN  item  ON  order_item.item_id  =  item.id  AND  item.type  =  'subitem')\nON  order_item.order_id  =  order.id\n```", "```py\n-- sqlite only!\nSELECT  parent.id  AS  parent_id\n  FROM  parent  JOIN  (\n  SELECT  base_table.id  AS  base_table_id,\n  base_table.parent_id  AS  base_table_parent_id,\n  subclass_table.id  AS  subclass_table_id\n  FROM  base_table  JOIN  subclass_table  ON  base_table.id  =  subclass_table.id\n  )  AS  anon_1  ON  parent.id  =  anon_1.base_table_parent_id\n\n-- sqlite only!\nSELECT  parent.id  AS  parent_id,  anon_1.subclass_table_1_id  AS  subclass_table_1_id,\n  anon_1.base_table_1_id  AS  base_table_1_id,\n  anon_1.base_table_1_parent_id  AS  base_table_1_parent_id\nFROM  parent  LEFT  OUTER  JOIN  (\n  SELECT  base_table_1.id  AS  base_table_1_id,\n  base_table_1.parent_id  AS  base_table_1_parent_id,\n  subclass_table_1.id  AS  subclass_table_1_id\n  FROM  base_table  AS  base_table_1\n  JOIN  subclass_table  AS  subclass_table_1  ON  base_table_1.id  =  subclass_table_1.id\n)  AS  anon_1  ON  parent.id  =  anon_1.base_table_1_parent_id\n\n-- sqlite only!\nSELECT  \"order\".id  AS  order_id\nFROM  \"order\"  LEFT  OUTER  JOIN  (\n  SELECT  order_item_1.order_id  AS  order_item_1_order_id,\n  order_item_1.item_id  AS  order_item_1_item_id,\n  item.id  AS  item_id,  item.type  AS  item_type\nFROM  order_item  AS  order_item_1\n  JOIN  item  ON  item.id  =  order_item_1.item_id  AND  item.type  IN  (?)\n)  AS  anon_1  ON  \"order\".id  =  anon_1.order_item_1_order_id\n```", "```py\nemployee_alias = with_polymorphic(Person, [Engineer, Manager], flat=True)\n\nsession.query(Company).join(Company.employees.of_type(employee_alias)).filter(\n    or_(Engineer.primary_language == \"python\", Manager.manager_name == \"dilbert\")\n)\n```", "```py\nSELECT  companies.company_id  AS  companies_company_id,  companies.name  AS  companies_name\nFROM  companies  JOIN  (\n  people  AS  people_1\n  LEFT  OUTER  JOIN  engineers  AS  engineers_1  ON  people_1.person_id  =  engineers_1.person_id\n  LEFT  OUTER  JOIN  managers  AS  managers_1  ON  people_1.person_id  =  managers_1.person_id\n)  ON  companies.company_id  =  people_1.company_id\nWHERE  engineers.primary_language  =  %(primary_language_1)s\n  OR  managers.manager_name  =  %(manager_name_1)s\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  orders  ON  <onclause>  LEFT  OUTER  JOIN  items  ON  <onclause>\n```", "```py\nFROM  users  LEFT  OUTER  JOIN  (orders  JOIN  items  ON  <onclause>)  ON  <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"nested\")\n)\n```", "```py\nSELECT  b.id  AS  b_id,  b.name  AS  b_name,  anon_1.b_id  AS  a_b_id\nFROM  (SELECT  DISTINCT  a_b_id  FROM  a)  AS  anon_1\nJOIN  b  ON  b.id  =  anon_1.a_b_id\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\np1 = Parent()\np2 = Parent()\nc1 = Child()\n\np1.children.append(c1)\n\nassert c1.parent is p1  # backref event establishes c1.parent as p1\n\np2.children.append(c1)\n\nassert c1.parent is p2  # backref event establishes c1.parent as p2\nassert c1 not in p1.children  # second backref event removes c1 from p1.children\n```", "```py\nfrom sqlalchemy import Table, Boolean, Integer, Column, MetaData\n\nt1 = Table(\"t\", MetaData(), Column(\"x\", Boolean()), Column(\"y\", Integer))\n```", "```py\n>>> from sqlalchemy import select, and_, false, true\n>>> from sqlalchemy.dialects import mysql, postgresql\n\n>>> print(select([t1]).where(t1.c.x).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.x  =  1 \n```", "```py\n>>> print(\n...     select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=postgresql.dialect())\n... )\nSELECT  t.x,  t.y  FROM  t  WHERE  false \n```", "```py\n>>> expr = true()\n>>> expr = expr & (t1.c.y > 5)\n>>> print(select([t1]).where(expr))\nSELECT  t.x,  t.y  FROM  t  WHERE  t.y  >  :y_1 \n```", "```py\n>>> print(select([t1]).where(and_(t1.c.y > 5, false())).compile(dialect=mysql.dialect()))\nSELECT  t.x,  t.y  FROM  t  WHERE  0  =  1 \n```", "```py\n>>> print(select([t1.c.x]).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL\n>>> print(select([t1.c.x]).where(None).where(None))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL\n>>> print(select([t1.c.x]).where(and_(None, None)))\nSELECT  t.x  FROM  t  WHERE  NULL  AND  NULL \n```", "```py\nfrom sqlalchemy.sql import table, column, select, func\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\nexpr = (func.foo(t.c.c1) + t.c.c2).label(\"expr\")\n\nstmt = select([expr]).order_by(expr)\n\nprint(stmt)\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  foo(t.c1)  +  t.c2\n```", "```py\nSELECT  foo(t.c1)  +  t.c2  AS  expr\nFROM  t  ORDER  BY  expr\n```", "```py\nusers.insert().execute(\n    dict(user_id=1, user_name=\"foo\"),\n    dict(user_id=2, user_name=\"bar\"),\n    dict(user_id=3, user_name=\"def\"),\n)\n\nrows = users.select().order_by(users.c.user_name).execute().fetchall()\n\neq_(rows, [(2, \"bar\"), (3, \"def\"), (1, \"foo\")])\n\neq_(sorted(rows), [(1, \"foo\"), (2, \"bar\"), (3, \"def\")])\n```", "```py\nbp = bindparam(\"some_col\")\n```", "```py\nexpr = mytable.c.col == bp\n```", "```py\nstmt = mytable.update().values(col=bp)\n```", "```py\n>>> compiled = stmt.compile()\n>>> compiled.binds[\"some_col\"].type\nString\n```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKeyConstraint\n    >>> metadata = MetaData()\n    >>> t2 = Table(\n    ...     \"t2\",\n    ...     metadata,\n    ...     Column(\"t1a\"),\n    ...     Column(\"t1b\"),\n    ...     ForeignKeyConstraint([\"t1a\", \"t1b\"], [\"t1.a\", \"t1.b\"]),\n    ... )\n    >>> t2.c.t1a.type\n    NullType()\n    >>> t2.c.t1b.type\n    NullType()\n    >>> t1 = Table(\n    ...     \"t1\",\n    ...     metadata,\n    ...     Column(\"a\", Integer, primary_key=True),\n    ...     Column(\"b\", Integer, primary_key=True),\n    ... )\n    >>> t2.c.t1a.type\n    Integer()\n    >>> t2.c.t1b.type\n    Integer()\n    ```", "```py\n    >>> from sqlalchemy import Table, MetaData, Column, Integer, ForeignKey\n    >>> metadata = MetaData()\n    >>> t2 = Table(\"t2\", metadata, Column(\"t1id\", ForeignKey(\"t1.id\")))\n    >>> t3 = Table(\"t3\", metadata, Column(\"t2t1id\", ForeignKey(\"t2.t1id\")))\n    >>> t2.c.t1id.type\n    NullType()\n    >>> t3.c.t2t1id.type\n    NullType()\n    >>> t1 = Table(\"t1\", metadata, Column(\"id\", Integer, primary_key=True))\n    >>> t2.c.t1id.type\n    Integer()\n    >>> t3.c.t2t1id.type\n    Integer()\n    ```"]