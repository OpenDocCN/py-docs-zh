["```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = mapper(\n    B,\n    j,\n    non_primary=True,\n    primary_key=[j.c.b_id],\n    properties={\n        \"id\": j.c.b_id,  # so that 'id' looks the same as before\n        \"c_id\": j.c.c_id,  # needed for disambiguation\n        \"d_c_id\": j.c.d_c_id,  # needed for disambiguation\n        \"b_id\": [j.c.b_id, j.c.d_b_id],\n        \"d_id\": j.c.d_id,\n    },\n)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == B_viacd.c.b_id)\n```", "```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = aliased(B, j, flat=True)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", lazy=\"selectin\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  a_1.id  AS  a_1_id,  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  a  AS  a_1  JOIN  b  ON  a_1.id  =  b.a_id\nWHERE  a_1.id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  a_1.id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  b.a_id  AS  b_a_id,  b.id  AS  b_id  FROM  b\nWHERE  b.a_id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  b.a_id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n\nsession.expire(u1)\nsession.expunge(u1)\n\nquery.all()  # <-- would raise DetachedInstanceError\n```", "```py\na1 = session.query(Address).filter_by(id=5).one()\n\nsession.expunge(a1)\n\na1.user = some_user\n```", "```py\nclass Address(Base):\n    # ...\n\n    user = relationship(\"User\", ..., lazy=\"raise\")\n```", "```py\nsome_object = session.query(SomeObject).get(5)\n\ndel some_object.some_attribute  # from a SQL perspective, works like \"= None\"\n```", "```py\nfrom sqlalchemy import inspect\n\nu1 = User(id=7, name=\"ed\")\n\ninspect(u1).info[\"user_info\"] = \"7|ed\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"a\", uselist=False)\n    b = association_proxy(\n        \"ab\", \"b\", creator=lambda b: AB(b=b), cascade_scalar_deletes=True\n    )\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"b\", cascade=\"all, delete-orphan\")\n\nclass AB(Base):\n    __tablename__ = \"test_ab\"\n    a_id = Column(Integer, ForeignKey(A.id), primary_key=True)\n    b_id = Column(Integer, ForeignKey(B.id), primary_key=True)\n```", "```py\na.b = B()\n```", "```py\na.b = None\nassert a.ab is None\n```", "```py\ndel a.b\nassert a.ab is None\n```", "```py\nclass User(Base):\n    # ...\n\n    keywords = association_proxy(\"kws\", \"keyword\")\n\nproxy_state = inspect(User).all_orm_descriptors[\"keywords\"].for_class(User)\n```", "```py\n>>> proxy_state.target_class\nKeyword\n```", "```py\nclass User(Base):\n    # ...\n\n    elements = relationship(\"Element\")\n\n    # column-based association proxy\n    values = association_proxy(\"elements\", \"value\")\n\nclass Element(Base):\n    # ...\n\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.values.like(\"%foo%\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  LIKE  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == \"foo\"))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  =  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == None))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  IS  NULL))  OR  NOT  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id)) \n```", "```py\n>>> print(s.query(User).filter(User.values.contains(\"foo\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  (element.value  LIKE  '%'  ||  :value_1  ||  '%')) \n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    user_elements = relationship(\"UserElement\")\n\n    # object-based association proxy\n    elements = association_proxy(\"user_elements\", \"element\")\n\nclass UserElement(Base):\n    __tablename__ = \"user_element\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(ForeignKey(\"user.id\"))\n    element_id = Column(ForeignKey(\"element.id\"))\n    element = relationship(\"Element\")\n\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.elements.contains(Element(id=1))))\nSELECT \"user\".id AS user_id\nFROM \"user\"\nWHERE EXISTS (SELECT 1\nFROM user_element\nWHERE \"user\".id = user_element.user_id AND :param_1 = user_element.element_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n    b_data = association_proxy(\"bs\", \"data\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\na1 = A(bs=[B(data=\"b1\"), B(data=\"b2\")])\n\nb_data = a1.b_data\n```", "```py\ndel a1\n```", "```py\ncollection = session.query(A).filter_by(id=1).first().b_data\n```", "```py\nassert b_data == [\"b1\", \"b2\"]\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n\n    id = Column(Integer, primary_key=True)\n    b_rel = relationship(\n        \"B\",\n        collection_class=set,\n        cascade=\"all, delete-orphan\",\n    )\n    b = association_proxy(\"b_rel\", \"value\", creator=lambda x: B(value=x))\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    __table_args__ = (UniqueConstraint(\"a_id\", \"value\"),)\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"test_a.id\"), nullable=False)\n    value = Column(String)\n\n# ...\n\ns = Session(e)\na = A(b={\"x\", \"y\", \"z\"})\ns.add(a)\ns.commit()\n\n# re-assign where one B should be deleted, one B added, two\n# B's maintained\na.b = {\"x\", \"z\", \"q\"}\n\n# only 'q' was added, so only one new B object.  previously\n# all three would have been re-created leading to flush conflicts\n# against the deleted ones.\nassert len(s.new) == 1\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\na1 = A(bs=[B(), B()])\n\na1.bs[0], a1.bs[1] = a1.bs[1], a1.bs[0]\n```", "```py\n>>> a1 = A()\n>>> b1 = B()\n>>> a1.bs.append(b1)\n>>> a1.bs.append(b1)  # append the same b1 object twice\n>>> del a1.bs[1]\n>>> a1.bs  # collection is unaffected so far...\n[<__main__.B object at 0x7f047af5fb70>]\n>>> b1.a  # however b1.a is None\n>>>\n>>> session.add(a1)\n>>> session.commit()  # so upon flush + expire....\n>>> a1.bs  # the value is gone\n[]\n```", "```py\nu_alias = aliased(User)\nsession.query(User, u_alias).join(Address)\n```", "```py\nSELECT  ...\nFROM  users  AS  users_1,  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Can't determine which FROM clause to\njoin from, there are multiple FROMS which can join to this entity.\nTry adding an explicit ON clause to help resolve the ambiguity.\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, Address.user_id == User.id)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, Address.user_id == u_alias.id)\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, User.addresses)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, u_alias.addresses)\n```", "```py\nsession.query(func.current_timestamp(), User).join(Address)\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Don't know how to join from\nCURRENT_TIMESTAMP; please use select_from() to establish the\nleft entity/selectable of this join\n```", "```py\nSELECT  CURRENT_TIMESTAMP  AS  current_timestamp_1,  users.id  AS  users_id,\nusers.name  AS  users_name,  users.fullname  AS  users_fullname,\nusers.password  AS  users_password\nFROM  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsession.query(A).options(joinedload(A.b)).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nsession.query(A).options(joinedload(A.b)).with_for_update(of=A).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE  OF  a\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    addresses = relationship(\"Address\", passive_deletes=\"all\")\n\nclass Address(Base):\n    __tablename__ = \"addresses\"\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    user = relationship(\"User\")\n\nu1 = session.query(User).first()\naddress = u1.addresses[0]\nu1.addresses.remove(address)\nsession.commit()\n\n# would fail and be set to None\nassert address.user_id == u1.id\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\ntable = Table(\n    \"info\",\n    metadata_obj,\n    Column(\"a\", Integer),\n    Column(\"b\", Integer),\n    Column(\"c\", Integer),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  info  (\n  a  INTEGER,\n  b  INTEGER,\n  c  INTEGER,\n  CONSTRAINT  uq_info_a_b_c  UNIQUE  (a,  b,  c)\n)\n```", "```py\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.dialects import postgresql\nfrom sqlalchemy.schema import AddConstraint\n\nm = MetaData()\nt = Table(\"t\", m, Column(\"x\", Integer))\nuq = UniqueConstraint(\n    t.c.x,\n    name=\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\",\n)\n\nprint(AddConstraint(uq).compile(dialect=postgresql.dialect()))\n```", "```py\nsqlalchemy.exc.IdentifierError: Identifier\n'this_is_too_long_of_a_name_for_any_database_backend_even_postgresql'\nexceeds maximum length of 63 characters\n```", "```py\nuq = UniqueConstraint(\n    t.c.x,\n    name=conv(\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\"),\n)\n```", "```py\nALTER  TABLE  t  ADD  CONSTRAINT  this_is_too_long_of_a_name_for_any_database_backend_eve_ac05  UNIQUE  (x)\n```", "```py\nclass Venue(Base):\n    __tablename__ = \"venue\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    descendants = relationship(\n        \"Venue\",\n        primaryjoin=func.instr(remote(foreign(name)), name + \"/\").as_comparison(1, 2)\n        == 1,\n        viewonly=True,\n        order_by=name,\n    )\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name\nFROM  venue\nWHERE  instr(venue.name,  (?  ||  ?))  =  ?  ORDER  BY  venue.name\n('parent1',  '/',  1)\n```", "```py\nv1 = (\n    s.query(Venue)\n    .filter_by(name=\"parent1\")\n    .options(joinedload(Venue.descendants))\n    .one()\n)\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name,\n  venue_1.id  AS  venue_1_id,  venue_1.name  AS  venue_1_name\nFROM  venue  LEFT  OUTER  JOIN  venue  AS  venue_1\n  ON  instr(venue_1.name,  (venue.name  ||  ?))  =  ?\nWHERE  venue.name  =  ?  ORDER  BY  venue_1.name\n('/',  1,  'parent1')\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             literal_column(\"1\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE 1 IN (SELECT CAST(NULL AS INTEGER) WHERE 1!=1)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, tuple_, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             tuple_(50, \"somestring\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE (%(param_1)s, %(param_2)s)\nIN (SELECT CAST(NULL AS INTEGER), CAST(NULL AS VARCHAR) WHERE 1!=1)\n```", "```py\nfrom sqlalchemy import TypeDecorator, LargeBinary, func\n\nclass CompressedLargeBinary(TypeDecorator):\n    impl = LargeBinary\n\n    def bind_expression(self, bindvalue):\n        return func.compress(bindvalue, type_=self)\n\n    def column_expression(self, col):\n        return func.uncompress(col, type_=self)\n\nMyLargeBinary = LargeBinary().with_variant(CompressedLargeBinary(), \"sqlite\")\n```", "```py\nfrom sqlalchemy import select, column\nfrom sqlalchemy.dialects import sqlite\n\nprint(select([column(\"x\", CompressedLargeBinary)]).compile(dialect=sqlite.dialect()))\n```", "```py\nSELECT  uncompress(x)  AS  x\n```", "```py\nengine.begin()\n\ntable.insert().execute(parameters)\nresult = table.select().execute()\n\ntable.update().execute(parameters)\n\nengine.commit()\n```", "```py\nconn = engine.connect()\ntry:\n    trans = conn.begin()\n\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n\n    trans.commit()\nexcept:\n    trans.rollback()\n    raise\nfinally:\n    conn.close()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n```", "```py\ndv = Table(\n    \"data_values\",\n    metadata_obj,\n    Column(\"modulus\", Integer, nullable=False),\n    Column(\"data\", String(30)),\n    postgresql_partition_by=\"range(modulus)\",\n)\n\nsa.event.listen(\n    dv,\n    \"after_create\",\n    sa.DDL(\n        \"CREATE TABLE data_values_4_10 PARTITION OF data_values \"\n        \"FOR VALUES FROM (4) TO (10)\"\n    ),\n)\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_existing_id\", data=\"inserted value\")\n\non_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(\n    [\n        (\"data\", \"some data\"),\n        (\"updated_at\", func.current_timestamp()),\n    ],\n)\n```", "```py\nsome_table = Table(\n    \"some_table\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, sqlite_on_conflict_primary_key=\"FAIL\"),\n    Column(\"data\", Integer),\n    UniqueConstraint(\"id\", \"data\", sqlite_on_conflict=\"IGNORE\"),\n)\n```", "```py\nCREATE  TABLE  some_table  (\n  id  INTEGER  NOT  NULL,\n  data  INTEGER,\n  PRIMARY  KEY  (id)  ON  CONFLICT  FAIL,\n  UNIQUE  (id,  data)  ON  CONFLICT  IGNORE\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+13+for+SQL+Server\",\n    fast_executemany=True,\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        primary_key=True,\n        mssql_identity_start=100,\n        mssql_identity_increment=10,\n    ),\n    Column(\"name\", String(20)),\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, autoincrement=False),\n    Column(\"number\", Integer, autoincrement=True),\n)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is\nrequired for bind parameter 'id' [SQL: 'select * from reviews\\nwhere id = ?']\n(Background on this error at: https://sqlalche.me/e/cd3x)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'id'\n[SQL: select * from reviews\nwhere id = ?]\n(Background on this error at: https://sqlalche.me/e/cd3x)\n```", "```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = mapper(\n    B,\n    j,\n    non_primary=True,\n    primary_key=[j.c.b_id],\n    properties={\n        \"id\": j.c.b_id,  # so that 'id' looks the same as before\n        \"c_id\": j.c.c_id,  # needed for disambiguation\n        \"d_c_id\": j.c.d_c_id,  # needed for disambiguation\n        \"b_id\": [j.c.b_id, j.c.d_b_id],\n        \"d_id\": j.c.d_id,\n    },\n)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == B_viacd.c.b_id)\n```", "```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = aliased(B, j, flat=True)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", lazy=\"selectin\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  a_1.id  AS  a_1_id,  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  a  AS  a_1  JOIN  b  ON  a_1.id  =  b.a_id\nWHERE  a_1.id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  a_1.id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  b.a_id  AS  b_a_id,  b.id  AS  b_id  FROM  b\nWHERE  b.a_id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  b.a_id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n\nsession.expire(u1)\nsession.expunge(u1)\n\nquery.all()  # <-- would raise DetachedInstanceError\n```", "```py\na1 = session.query(Address).filter_by(id=5).one()\n\nsession.expunge(a1)\n\na1.user = some_user\n```", "```py\nclass Address(Base):\n    # ...\n\n    user = relationship(\"User\", ..., lazy=\"raise\")\n```", "```py\nsome_object = session.query(SomeObject).get(5)\n\ndel some_object.some_attribute  # from a SQL perspective, works like \"= None\"\n```", "```py\nfrom sqlalchemy import inspect\n\nu1 = User(id=7, name=\"ed\")\n\ninspect(u1).info[\"user_info\"] = \"7|ed\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"a\", uselist=False)\n    b = association_proxy(\n        \"ab\", \"b\", creator=lambda b: AB(b=b), cascade_scalar_deletes=True\n    )\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"b\", cascade=\"all, delete-orphan\")\n\nclass AB(Base):\n    __tablename__ = \"test_ab\"\n    a_id = Column(Integer, ForeignKey(A.id), primary_key=True)\n    b_id = Column(Integer, ForeignKey(B.id), primary_key=True)\n```", "```py\na.b = B()\n```", "```py\na.b = None\nassert a.ab is None\n```", "```py\ndel a.b\nassert a.ab is None\n```", "```py\nclass User(Base):\n    # ...\n\n    keywords = association_proxy(\"kws\", \"keyword\")\n\nproxy_state = inspect(User).all_orm_descriptors[\"keywords\"].for_class(User)\n```", "```py\n>>> proxy_state.target_class\nKeyword\n```", "```py\nclass User(Base):\n    # ...\n\n    elements = relationship(\"Element\")\n\n    # column-based association proxy\n    values = association_proxy(\"elements\", \"value\")\n\nclass Element(Base):\n    # ...\n\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.values.like(\"%foo%\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  LIKE  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == \"foo\"))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  =  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == None))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  IS  NULL))  OR  NOT  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id)) \n```", "```py\n>>> print(s.query(User).filter(User.values.contains(\"foo\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  (element.value  LIKE  '%'  ||  :value_1  ||  '%')) \n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    user_elements = relationship(\"UserElement\")\n\n    # object-based association proxy\n    elements = association_proxy(\"user_elements\", \"element\")\n\nclass UserElement(Base):\n    __tablename__ = \"user_element\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(ForeignKey(\"user.id\"))\n    element_id = Column(ForeignKey(\"element.id\"))\n    element = relationship(\"Element\")\n\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.elements.contains(Element(id=1))))\nSELECT \"user\".id AS user_id\nFROM \"user\"\nWHERE EXISTS (SELECT 1\nFROM user_element\nWHERE \"user\".id = user_element.user_id AND :param_1 = user_element.element_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n    b_data = association_proxy(\"bs\", \"data\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\na1 = A(bs=[B(data=\"b1\"), B(data=\"b2\")])\n\nb_data = a1.b_data\n```", "```py\ndel a1\n```", "```py\ncollection = session.query(A).filter_by(id=1).first().b_data\n```", "```py\nassert b_data == [\"b1\", \"b2\"]\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n\n    id = Column(Integer, primary_key=True)\n    b_rel = relationship(\n        \"B\",\n        collection_class=set,\n        cascade=\"all, delete-orphan\",\n    )\n    b = association_proxy(\"b_rel\", \"value\", creator=lambda x: B(value=x))\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    __table_args__ = (UniqueConstraint(\"a_id\", \"value\"),)\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"test_a.id\"), nullable=False)\n    value = Column(String)\n\n# ...\n\ns = Session(e)\na = A(b={\"x\", \"y\", \"z\"})\ns.add(a)\ns.commit()\n\n# re-assign where one B should be deleted, one B added, two\n# B's maintained\na.b = {\"x\", \"z\", \"q\"}\n\n# only 'q' was added, so only one new B object.  previously\n# all three would have been re-created leading to flush conflicts\n# against the deleted ones.\nassert len(s.new) == 1\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\na1 = A(bs=[B(), B()])\n\na1.bs[0], a1.bs[1] = a1.bs[1], a1.bs[0]\n```", "```py\n>>> a1 = A()\n>>> b1 = B()\n>>> a1.bs.append(b1)\n>>> a1.bs.append(b1)  # append the same b1 object twice\n>>> del a1.bs[1]\n>>> a1.bs  # collection is unaffected so far...\n[<__main__.B object at 0x7f047af5fb70>]\n>>> b1.a  # however b1.a is None\n>>>\n>>> session.add(a1)\n>>> session.commit()  # so upon flush + expire....\n>>> a1.bs  # the value is gone\n[]\n```", "```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = mapper(\n    B,\n    j,\n    non_primary=True,\n    primary_key=[j.c.b_id],\n    properties={\n        \"id\": j.c.b_id,  # so that 'id' looks the same as before\n        \"c_id\": j.c.c_id,  # needed for disambiguation\n        \"d_c_id\": j.c.d_c_id,  # needed for disambiguation\n        \"b_id\": [j.c.b_id, j.c.d_b_id],\n        \"d_id\": j.c.d_id,\n    },\n)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == B_viacd.c.b_id)\n```", "```py\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\nB_viacd = aliased(B, j, flat=True)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", lazy=\"selectin\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  a_1.id  AS  a_1_id,  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  a  AS  a_1  JOIN  b  ON  a_1.id  =  b.a_id\nWHERE  a_1.id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  a_1.id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nSELECT  a.id  AS  a_id  FROM  a\nSELECT  b.a_id  AS  b_a_id,  b.id  AS  b_id  FROM  b\nWHERE  b.a_id  IN  (?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?)  ORDER  BY  b.a_id\n(1,  2,  3,  4,  5,  6,  7,  8,  9,  10)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n```", "```py\nu1 = session.query(User).get(5)\n\nquery = session.query(Address).filter(Address.user == u1)\n\nsession.expire(u1)\nsession.expunge(u1)\n\nquery.all()  # <-- would raise DetachedInstanceError\n```", "```py\na1 = session.query(Address).filter_by(id=5).one()\n\nsession.expunge(a1)\n\na1.user = some_user\n```", "```py\nclass Address(Base):\n    # ...\n\n    user = relationship(\"User\", ..., lazy=\"raise\")\n```", "```py\nsome_object = session.query(SomeObject).get(5)\n\ndel some_object.some_attribute  # from a SQL perspective, works like \"= None\"\n```", "```py\nfrom sqlalchemy import inspect\n\nu1 = User(id=7, name=\"ed\")\n\ninspect(u1).info[\"user_info\"] = \"7|ed\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"a\", uselist=False)\n    b = association_proxy(\n        \"ab\", \"b\", creator=lambda b: AB(b=b), cascade_scalar_deletes=True\n    )\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"b\", cascade=\"all, delete-orphan\")\n\nclass AB(Base):\n    __tablename__ = \"test_ab\"\n    a_id = Column(Integer, ForeignKey(A.id), primary_key=True)\n    b_id = Column(Integer, ForeignKey(B.id), primary_key=True)\n```", "```py\na.b = B()\n```", "```py\na.b = None\nassert a.ab is None\n```", "```py\ndel a.b\nassert a.ab is None\n```", "```py\nclass User(Base):\n    # ...\n\n    keywords = association_proxy(\"kws\", \"keyword\")\n\nproxy_state = inspect(User).all_orm_descriptors[\"keywords\"].for_class(User)\n```", "```py\n>>> proxy_state.target_class\nKeyword\n```", "```py\nclass User(Base):\n    # ...\n\n    elements = relationship(\"Element\")\n\n    # column-based association proxy\n    values = association_proxy(\"elements\", \"value\")\n\nclass Element(Base):\n    # ...\n\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.values.like(\"%foo%\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  LIKE  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == \"foo\"))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  =  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == None))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  IS  NULL))  OR  NOT  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id)) \n```", "```py\n>>> print(s.query(User).filter(User.values.contains(\"foo\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  (element.value  LIKE  '%'  ||  :value_1  ||  '%')) \n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    user_elements = relationship(\"UserElement\")\n\n    # object-based association proxy\n    elements = association_proxy(\"user_elements\", \"element\")\n\nclass UserElement(Base):\n    __tablename__ = \"user_element\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(ForeignKey(\"user.id\"))\n    element_id = Column(ForeignKey(\"element.id\"))\n    element = relationship(\"Element\")\n\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.elements.contains(Element(id=1))))\nSELECT \"user\".id AS user_id\nFROM \"user\"\nWHERE EXISTS (SELECT 1\nFROM user_element\nWHERE \"user\".id = user_element.user_id AND :param_1 = user_element.element_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n    b_data = association_proxy(\"bs\", \"data\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\na1 = A(bs=[B(data=\"b1\"), B(data=\"b2\")])\n\nb_data = a1.b_data\n```", "```py\ndel a1\n```", "```py\ncollection = session.query(A).filter_by(id=1).first().b_data\n```", "```py\nassert b_data == [\"b1\", \"b2\"]\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n\n    id = Column(Integer, primary_key=True)\n    b_rel = relationship(\n        \"B\",\n        collection_class=set,\n        cascade=\"all, delete-orphan\",\n    )\n    b = association_proxy(\"b_rel\", \"value\", creator=lambda x: B(value=x))\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    __table_args__ = (UniqueConstraint(\"a_id\", \"value\"),)\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"test_a.id\"), nullable=False)\n    value = Column(String)\n\n# ...\n\ns = Session(e)\na = A(b={\"x\", \"y\", \"z\"})\ns.add(a)\ns.commit()\n\n# re-assign where one B should be deleted, one B added, two\n# B's maintained\na.b = {\"x\", \"z\", \"q\"}\n\n# only 'q' was added, so only one new B object.  previously\n# all three would have been re-created leading to flush conflicts\n# against the deleted ones.\nassert len(s.new) == 1\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"a\", uselist=False)\n    b = association_proxy(\n        \"ab\", \"b\", creator=lambda b: AB(b=b), cascade_scalar_deletes=True\n    )\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    id = Column(Integer, primary_key=True)\n    ab = relationship(\"AB\", backref=\"b\", cascade=\"all, delete-orphan\")\n\nclass AB(Base):\n    __tablename__ = \"test_ab\"\n    a_id = Column(Integer, ForeignKey(A.id), primary_key=True)\n    b_id = Column(Integer, ForeignKey(B.id), primary_key=True)\n```", "```py\na.b = B()\n```", "```py\na.b = None\nassert a.ab is None\n```", "```py\ndel a.b\nassert a.ab is None\n```", "```py\nclass User(Base):\n    # ...\n\n    keywords = association_proxy(\"kws\", \"keyword\")\n\nproxy_state = inspect(User).all_orm_descriptors[\"keywords\"].for_class(User)\n```", "```py\n>>> proxy_state.target_class\nKeyword\n```", "```py\nclass User(Base):\n    # ...\n\n    elements = relationship(\"Element\")\n\n    # column-based association proxy\n    values = association_proxy(\"elements\", \"value\")\n\nclass Element(Base):\n    # ...\n\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.values.like(\"%foo%\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  LIKE  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == \"foo\"))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  =  :value_1) \n```", "```py\n>>> print(s.query(User).filter(User.values == None))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  element.value  IS  NULL))  OR  NOT  (EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id)) \n```", "```py\n>>> print(s.query(User).filter(User.values.contains(\"foo\")))\nSELECT  \"user\".id  AS  user_id\nFROM  \"user\"\nWHERE  EXISTS  (SELECT  1\nFROM  element\nWHERE  \"user\".id  =  element.user_id  AND  (element.value  LIKE  '%'  ||  :value_1  ||  '%')) \n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    user_elements = relationship(\"UserElement\")\n\n    # object-based association proxy\n    elements = association_proxy(\"user_elements\", \"element\")\n\nclass UserElement(Base):\n    __tablename__ = \"user_element\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(ForeignKey(\"user.id\"))\n    element_id = Column(ForeignKey(\"element.id\"))\n    element = relationship(\"Element\")\n\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    id = Column(Integer, primary_key=True)\n    value = Column(String)\n```", "```py\n>>> print(s.query(User).filter(User.elements.contains(Element(id=1))))\nSELECT \"user\".id AS user_id\nFROM \"user\"\nWHERE EXISTS (SELECT 1\nFROM user_element\nWHERE \"user\".id = user_element.user_id AND :param_1 = user_element.element_id)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n    b_data = association_proxy(\"bs\", \"data\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\na1 = A(bs=[B(data=\"b1\"), B(data=\"b2\")])\n\nb_data = a1.b_data\n```", "```py\ndel a1\n```", "```py\ncollection = session.query(A).filter_by(id=1).first().b_data\n```", "```py\nassert b_data == [\"b1\", \"b2\"]\n```", "```py\nclass A(Base):\n    __tablename__ = \"test_a\"\n\n    id = Column(Integer, primary_key=True)\n    b_rel = relationship(\n        \"B\",\n        collection_class=set,\n        cascade=\"all, delete-orphan\",\n    )\n    b = association_proxy(\"b_rel\", \"value\", creator=lambda x: B(value=x))\n\nclass B(Base):\n    __tablename__ = \"test_b\"\n    __table_args__ = (UniqueConstraint(\"a_id\", \"value\"),)\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(Integer, ForeignKey(\"test_a.id\"), nullable=False)\n    value = Column(String)\n\n# ...\n\ns = Session(e)\na = A(b={\"x\", \"y\", \"z\"})\ns.add(a)\ns.commit()\n\n# re-assign where one B should be deleted, one B added, two\n# B's maintained\na.b = {\"x\", \"z\", \"q\"}\n\n# only 'q' was added, so only one new B object.  previously\n# all three would have been re-created leading to flush conflicts\n# against the deleted ones.\nassert len(s.new) == 1\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\na1 = A(bs=[B(), B()])\n\na1.bs[0], a1.bs[1] = a1.bs[1], a1.bs[0]\n```", "```py\n>>> a1 = A()\n>>> b1 = B()\n>>> a1.bs.append(b1)\n>>> a1.bs.append(b1)  # append the same b1 object twice\n>>> del a1.bs[1]\n>>> a1.bs  # collection is unaffected so far...\n[<__main__.B object at 0x7f047af5fb70>]\n>>> b1.a  # however b1.a is None\n>>>\n>>> session.add(a1)\n>>> session.commit()  # so upon flush + expire....\n>>> a1.bs  # the value is gone\n[]\n```", "```py\nu_alias = aliased(User)\nsession.query(User, u_alias).join(Address)\n```", "```py\nSELECT  ...\nFROM  users  AS  users_1,  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Can't determine which FROM clause to\njoin from, there are multiple FROMS which can join to this entity.\nTry adding an explicit ON clause to help resolve the ambiguity.\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, Address.user_id == User.id)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, Address.user_id == u_alias.id)\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, User.addresses)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, u_alias.addresses)\n```", "```py\nsession.query(func.current_timestamp(), User).join(Address)\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Don't know how to join from\nCURRENT_TIMESTAMP; please use select_from() to establish the\nleft entity/selectable of this join\n```", "```py\nSELECT  CURRENT_TIMESTAMP  AS  current_timestamp_1,  users.id  AS  users_id,\nusers.name  AS  users_name,  users.fullname  AS  users_fullname,\nusers.password  AS  users_password\nFROM  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsession.query(A).options(joinedload(A.b)).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nsession.query(A).options(joinedload(A.b)).with_for_update(of=A).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE  OF  a\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    addresses = relationship(\"Address\", passive_deletes=\"all\")\n\nclass Address(Base):\n    __tablename__ = \"addresses\"\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    user = relationship(\"User\")\n\nu1 = session.query(User).first()\naddress = u1.addresses[0]\nu1.addresses.remove(address)\nsession.commit()\n\n# would fail and be set to None\nassert address.user_id == u1.id\n```", "```py\nu_alias = aliased(User)\nsession.query(User, u_alias).join(Address)\n```", "```py\nSELECT  ...\nFROM  users  AS  users_1,  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Can't determine which FROM clause to\njoin from, there are multiple FROMS which can join to this entity.\nTry adding an explicit ON clause to help resolve the ambiguity.\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, Address.user_id == User.id)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, Address.user_id == u_alias.id)\n```", "```py\n# join to User\nsession.query(User, u_alias).join(Address, User.addresses)\n\n# join to u_alias\nsession.query(User, u_alias).join(Address, u_alias.addresses)\n```", "```py\nsession.query(func.current_timestamp(), User).join(Address)\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Don't know how to join from\nCURRENT_TIMESTAMP; please use select_from() to establish the\nleft entity/selectable of this join\n```", "```py\nSELECT  CURRENT_TIMESTAMP  AS  current_timestamp_1,  users.id  AS  users_id,\nusers.name  AS  users_name,  users.fullname  AS  users_fullname,\nusers.password  AS  users_password\nFROM  users  JOIN  addresses  ON  users.id  =  addresses.user_id\n```", "```py\nsession.query(A).options(joinedload(A.b)).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id  FOR  UPDATE\n```", "```py\nsession.query(A).options(joinedload(A.b)).with_for_update(of=A).limit(5)\n```", "```py\nSELECT  subq.a_id,  subq.a_data,  b_alias.id,  b_alias.data  FROM  (\n  SELECT  a.id  AS  a_id,  a.data  AS  a_data  FROM  a  LIMIT  5  FOR  UPDATE  OF  a\n)  AS  subq  LEFT  OUTER  JOIN  b  ON  subq.a_id=b.a_id\n```", "```py\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    addresses = relationship(\"Address\", passive_deletes=\"all\")\n\nclass Address(Base):\n    __tablename__ = \"addresses\"\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    user = relationship(\"User\")\n\nu1 = session.query(User).first()\naddress = u1.addresses[0]\nu1.addresses.remove(address)\nsession.commit()\n\n# would fail and be set to None\nassert address.user_id == u1.id\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\ntable = Table(\n    \"info\",\n    metadata_obj,\n    Column(\"a\", Integer),\n    Column(\"b\", Integer),\n    Column(\"c\", Integer),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  info  (\n  a  INTEGER,\n  b  INTEGER,\n  c  INTEGER,\n  CONSTRAINT  uq_info_a_b_c  UNIQUE  (a,  b,  c)\n)\n```", "```py\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.dialects import postgresql\nfrom sqlalchemy.schema import AddConstraint\n\nm = MetaData()\nt = Table(\"t\", m, Column(\"x\", Integer))\nuq = UniqueConstraint(\n    t.c.x,\n    name=\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\",\n)\n\nprint(AddConstraint(uq).compile(dialect=postgresql.dialect()))\n```", "```py\nsqlalchemy.exc.IdentifierError: Identifier\n'this_is_too_long_of_a_name_for_any_database_backend_even_postgresql'\nexceeds maximum length of 63 characters\n```", "```py\nuq = UniqueConstraint(\n    t.c.x,\n    name=conv(\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\"),\n)\n```", "```py\nALTER  TABLE  t  ADD  CONSTRAINT  this_is_too_long_of_a_name_for_any_database_backend_eve_ac05  UNIQUE  (x)\n```", "```py\nclass Venue(Base):\n    __tablename__ = \"venue\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    descendants = relationship(\n        \"Venue\",\n        primaryjoin=func.instr(remote(foreign(name)), name + \"/\").as_comparison(1, 2)\n        == 1,\n        viewonly=True,\n        order_by=name,\n    )\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name\nFROM  venue\nWHERE  instr(venue.name,  (?  ||  ?))  =  ?  ORDER  BY  venue.name\n('parent1',  '/',  1)\n```", "```py\nv1 = (\n    s.query(Venue)\n    .filter_by(name=\"parent1\")\n    .options(joinedload(Venue.descendants))\n    .one()\n)\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name,\n  venue_1.id  AS  venue_1_id,  venue_1.name  AS  venue_1_name\nFROM  venue  LEFT  OUTER  JOIN  venue  AS  venue_1\n  ON  instr(venue_1.name,  (venue.name  ||  ?))  =  ?\nWHERE  venue.name  =  ?  ORDER  BY  venue_1.name\n('/',  1,  'parent1')\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             literal_column(\"1\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE 1 IN (SELECT CAST(NULL AS INTEGER) WHERE 1!=1)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, tuple_, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             tuple_(50, \"somestring\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE (%(param_1)s, %(param_2)s)\nIN (SELECT CAST(NULL AS INTEGER), CAST(NULL AS VARCHAR) WHERE 1!=1)\n```", "```py\nfrom sqlalchemy import TypeDecorator, LargeBinary, func\n\nclass CompressedLargeBinary(TypeDecorator):\n    impl = LargeBinary\n\n    def bind_expression(self, bindvalue):\n        return func.compress(bindvalue, type_=self)\n\n    def column_expression(self, col):\n        return func.uncompress(col, type_=self)\n\nMyLargeBinary = LargeBinary().with_variant(CompressedLargeBinary(), \"sqlite\")\n```", "```py\nfrom sqlalchemy import select, column\nfrom sqlalchemy.dialects import sqlite\n\nprint(select([column(\"x\", CompressedLargeBinary)]).compile(dialect=sqlite.dialect()))\n```", "```py\nSELECT  uncompress(x)  AS  x\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\ntable = Table(\n    \"info\",\n    metadata_obj,\n    Column(\"a\", Integer),\n    Column(\"b\", Integer),\n    Column(\"c\", Integer),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  info  (\n  a  INTEGER,\n  b  INTEGER,\n  c  INTEGER,\n  CONSTRAINT  uq_info_a_b_c  UNIQUE  (a,  b,  c)\n)\n```", "```py\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.dialects import postgresql\nfrom sqlalchemy.schema import AddConstraint\n\nm = MetaData()\nt = Table(\"t\", m, Column(\"x\", Integer))\nuq = UniqueConstraint(\n    t.c.x,\n    name=\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\",\n)\n\nprint(AddConstraint(uq).compile(dialect=postgresql.dialect()))\n```", "```py\nsqlalchemy.exc.IdentifierError: Identifier\n'this_is_too_long_of_a_name_for_any_database_backend_even_postgresql'\nexceeds maximum length of 63 characters\n```", "```py\nuq = UniqueConstraint(\n    t.c.x,\n    name=conv(\"this_is_too_long_of_a_name_for_any_database_backend_even_postgresql\"),\n)\n```", "```py\nALTER  TABLE  t  ADD  CONSTRAINT  this_is_too_long_of_a_name_for_any_database_backend_eve_ac05  UNIQUE  (x)\n```", "```py\nclass Venue(Base):\n    __tablename__ = \"venue\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    descendants = relationship(\n        \"Venue\",\n        primaryjoin=func.instr(remote(foreign(name)), name + \"/\").as_comparison(1, 2)\n        == 1,\n        viewonly=True,\n        order_by=name,\n    )\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name\nFROM  venue\nWHERE  instr(venue.name,  (?  ||  ?))  =  ?  ORDER  BY  venue.name\n('parent1',  '/',  1)\n```", "```py\nv1 = (\n    s.query(Venue)\n    .filter_by(name=\"parent1\")\n    .options(joinedload(Venue.descendants))\n    .one()\n)\n```", "```py\nSELECT  venue.id  AS  venue_id,  venue.name  AS  venue_name,\n  venue_1.id  AS  venue_1_id,  venue_1.name  AS  venue_1_name\nFROM  venue  LEFT  OUTER  JOIN  venue  AS  venue_1\n  ON  instr(venue_1.name,  (venue.name  ||  ?))  =  ?\nWHERE  venue.name  =  ?  ORDER  BY  venue_1.name\n('/',  1,  'parent1')\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             literal_column(\"1\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE 1 IN (SELECT CAST(NULL AS INTEGER) WHERE 1!=1)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> from sqlalchemy import select, literal_column, tuple_, bindparam\n>>> e = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\n>>> with e.connect() as conn:\n...     conn.execute(\n...         select([literal_column(\"1\")]).where(\n...             tuple_(50, \"somestring\").in_(bindparam(\"q\", expanding=True))\n...         ),\n...         q=[],\n...     )\n{exexsql}SELECT 1 WHERE (%(param_1)s, %(param_2)s)\nIN (SELECT CAST(NULL AS INTEGER), CAST(NULL AS VARCHAR) WHERE 1!=1)\n```", "```py\nfrom sqlalchemy import TypeDecorator, LargeBinary, func\n\nclass CompressedLargeBinary(TypeDecorator):\n    impl = LargeBinary\n\n    def bind_expression(self, bindvalue):\n        return func.compress(bindvalue, type_=self)\n\n    def column_expression(self, col):\n        return func.uncompress(col, type_=self)\n\nMyLargeBinary = LargeBinary().with_variant(CompressedLargeBinary(), \"sqlite\")\n```", "```py\nfrom sqlalchemy import select, column\nfrom sqlalchemy.dialects import sqlite\n\nprint(select([column(\"x\", CompressedLargeBinary)]).compile(dialect=sqlite.dialect()))\n```", "```py\nSELECT  uncompress(x)  AS  x\n```", "```py\nengine.begin()\n\ntable.insert().execute(parameters)\nresult = table.select().execute()\n\ntable.update().execute(parameters)\n\nengine.commit()\n```", "```py\nconn = engine.connect()\ntry:\n    trans = conn.begin()\n\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n\n    trans.commit()\nexcept:\n    trans.rollback()\n    raise\nfinally:\n    conn.close()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n```", "```py\nengine.begin()\n\ntable.insert().execute(parameters)\nresult = table.select().execute()\n\ntable.update().execute(parameters)\n\nengine.commit()\n```", "```py\nconn = engine.connect()\ntry:\n    trans = conn.begin()\n\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n\n    trans.commit()\nexcept:\n    trans.rollback()\n    raise\nfinally:\n    conn.close()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(table.insert(), parameters)\n    result = conn.execute(table.select())\n\n    conn.execute(table.update(), parameters)\n```", "```py\ndv = Table(\n    \"data_values\",\n    metadata_obj,\n    Column(\"modulus\", Integer, nullable=False),\n    Column(\"data\", String(30)),\n    postgresql_partition_by=\"range(modulus)\",\n)\n\nsa.event.listen(\n    dv,\n    \"after_create\",\n    sa.DDL(\n        \"CREATE TABLE data_values_4_10 PARTITION OF data_values \"\n        \"FOR VALUES FROM (4) TO (10)\"\n    ),\n)\n```", "```py\ndv = Table(\n    \"data_values\",\n    metadata_obj,\n    Column(\"modulus\", Integer, nullable=False),\n    Column(\"data\", String(30)),\n    postgresql_partition_by=\"range(modulus)\",\n)\n\nsa.event.listen(\n    dv,\n    \"after_create\",\n    sa.DDL(\n        \"CREATE TABLE data_values_4_10 PARTITION OF data_values \"\n        \"FOR VALUES FROM (4) TO (10)\"\n    ),\n)\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_existing_id\", data=\"inserted value\")\n\non_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(\n    [\n        (\"data\", \"some data\"),\n        (\"updated_at\", func.current_timestamp()),\n    ],\n)\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_existing_id\", data=\"inserted value\")\n\non_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(\n    [\n        (\"data\", \"some data\"),\n        (\"updated_at\", func.current_timestamp()),\n    ],\n)\n```", "```py\nsome_table = Table(\n    \"some_table\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, sqlite_on_conflict_primary_key=\"FAIL\"),\n    Column(\"data\", Integer),\n    UniqueConstraint(\"id\", \"data\", sqlite_on_conflict=\"IGNORE\"),\n)\n```", "```py\nCREATE  TABLE  some_table  (\n  id  INTEGER  NOT  NULL,\n  data  INTEGER,\n  PRIMARY  KEY  (id)  ON  CONFLICT  FAIL,\n  UNIQUE  (id,  data)  ON  CONFLICT  IGNORE\n)\n```", "```py\nsome_table = Table(\n    \"some_table\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, sqlite_on_conflict_primary_key=\"FAIL\"),\n    Column(\"data\", Integer),\n    UniqueConstraint(\"id\", \"data\", sqlite_on_conflict=\"IGNORE\"),\n)\n```", "```py\nCREATE  TABLE  some_table  (\n  id  INTEGER  NOT  NULL,\n  data  INTEGER,\n  PRIMARY  KEY  (id)  ON  CONFLICT  FAIL,\n  UNIQUE  (id,  data)  ON  CONFLICT  IGNORE\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+13+for+SQL+Server\",\n    fast_executemany=True,\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        primary_key=True,\n        mssql_identity_start=100,\n        mssql_identity_increment=10,\n    ),\n    Column(\"name\", String(20)),\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, autoincrement=False),\n    Column(\"number\", Integer, autoincrement=True),\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+13+for+SQL+Server\",\n    fast_executemany=True,\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        primary_key=True,\n        mssql_identity_start=100,\n        mssql_identity_increment=10,\n    ),\n    Column(\"name\", String(20)),\n)\n```", "```py\ntest = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, autoincrement=False),\n    Column(\"number\", Integer, autoincrement=True),\n)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is\nrequired for bind parameter 'id' [SQL: 'select * from reviews\\nwhere id = ?']\n(Background on this error at: https://sqlalche.me/e/cd3x)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError) A value is required for bind parameter 'id'\n[SQL: select * from reviews\nwhere id = ?]\n(Background on this error at: https://sqlalche.me/e/cd3x)\n```"]