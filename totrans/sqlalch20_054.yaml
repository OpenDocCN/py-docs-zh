- en: Additional Persistence Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加持久化技术
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html](https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html](https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html)
- en: '## Embedding SQL Insert/Update Expressions into a Flush'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将SQL插入/更新表达式嵌入到刷新中'
- en: 'This feature allows the value of a database column to be set to a SQL expression
    instead of a literal value. It’s especially useful for atomic updates, calling
    stored procedures, etc. All you do is assign an expression to an attribute:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许将数据库列的值设置为SQL表达式而不是文字值。这对于原子更新、调用存储过程等特别有用。您所要做的就是将表达式分配给属性：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This technique works both for INSERT and UPDATE statements. After the flush/commit
    operation, the `value` attribute on `someobject` above is expired, so that when
    next accessed the newly generated value will be loaded from the database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于INSERT和UPDATE语句都适用。在刷新/提交操作之后，上述`someobject`的`value`属性将会过期，因此在下次访问时，新生成的值将从数据库加载。
- en: 'The feature also has conditional support to work in conjunction with primary
    key columns. For backends that have RETURNING support (including Oracle, SQL Server,
    MariaDB 10.5, SQLite 3.35) a SQL expression may be assigned to a primary key column
    as well. This allows both the SQL expression to be evaluated, as well as allows
    any server side triggers that modify the primary key value on INSERT, to be successfully
    retrieved by the ORM as part of the object’s primary key:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能还具有条件支持，可以与主键列一起使用。对于支持RETURNING的后端（包括Oracle、SQL Server、MariaDB 10.5、SQLite
    3.35），还可以将SQL表达式分配给主键列。这允许对SQL表达式进行评估，并允许在INSERT时修改主键值的服务器端触发器成功地由ORM作为对象的主键的一部分检索：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On PostgreSQL, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will emit the following INSERT:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL上，上述[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")将发出以下INSERT：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'New in version 1.3: SQL expressions can now be passed to a primary key column
    during an ORM flush; if the database supports RETURNING, or if pysqlite is in
    use, the ORM will be able to retrieve the server-generated value as the value
    of the primary key attribute.  ## Using SQL Expressions with Sessions'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '新版本1.3中：现在可以在ORM刷新期间将SQL表达式传递给主键列；如果数据库支持RETURNING，或者正在使用pysqlite，ORM将能够将服务器生成的值作为主键属性的值检索出来。  ##
    在会话中使用SQL表达式'
- en: 'SQL expressions and strings can be executed via the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within its transactional context. This is most
    easily accomplished using the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which returns a [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in the same manner as an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQL表达式和字符串可以通过[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")在其事务上下文中执行。最简单的方法是使用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法，它以与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")相同的方式返回一个[`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult")：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The current [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") is accessible using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")持有的当前[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")可通过[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")方法访问：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The examples above deal with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). To execute statements using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which is bound either to multiple engines, or none at
    all (i.e. relies upon bound metadata), both [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") accept a dictionary of bind arguments [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") which may include “mapper” which is passed a
    mapped class or [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    instance, which is used to locate the proper context for the desired engine:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例涉及绑定到单个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")或[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。要使用绑定到多个引擎或根本没有绑定（即依赖于绑定元数据）的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")执行语句，[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")和[`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")都接受一个绑定参数字典[`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute")，其中可能包括“mapper”，该参数传递了一个映射类或[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")实例，用于定位所需引擎的适当上下文：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Changed in version 1.4: the `mapper` and `clause` arguments to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are now passed as part of a dictionary sent
    as the [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") parameter. The previous arguments are still
    accepted however this usage is deprecated.  ## Forcing NULL on a column with a
    default'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '从1.4版本开始更改：[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")中的`mapper`和`clause`参数现在作为发送给[`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute")参数的字典的一部分传递。之前的参数仍然被接受，但此用法已被弃用。  ## 强制在具有默认值的列上使用NULL'
- en: 'The ORM considers any attribute that was never set on an object as a “default”
    case; the attribute will be omitted from the INSERT statement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ORM将任何从未在对象上设置过的属性视为“默认”情况；该属性将在INSERT语句中被省略：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Omitting a column from the INSERT means that the column will have the NULL
    value set, *unless* the column has a default set up, in which case the default
    value will be persisted. This holds true both from a pure SQL perspective with
    server-side defaults, as well as the behavior of SQLAlchemy’s insert behavior
    with both client-side and server-side defaults:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在INSERT中省略一列意味着该列将设置为NULL值，*除非*该列设置了默认值，此时默认值将被保留。这既适用于纯SQL角度的服务器端默认值，也适用于SQLAlchemy在客户端和服务器端默认值下的插入行为：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, in the ORM, even if one assigns the Python value `None` explicitly
    to the object, this is treated the **same** as though the value were never assigned:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在ORM中，即使将Python值`None`明确地分配给对象，这与从未分配值一样处理：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above operation will persist into the `data` column the server default value
    of `"default"` and not SQL NULL, even though `None` was passed; this is a long-standing
    behavior of the ORM that many applications hold as an assumption.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将将服务器默认值`"default"`持久化到`data`列中，而不是SQL NULL，即使传递了`None`；这是ORM的一个长期行为，许多应用程序将其视为一种假设。
- en: 'So what if we want to actually put NULL into this column, even though the column
    has a default value? There are two approaches. One is that on a per-instance level,
    we assign the attribute using the [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL construct:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们想要实际将NULL放入这一列中，即使该列有默认值呢？有两种方法。一种是在每个实例级别上，我们使用[`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL构造来分配属性：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL construct always translates into the SQL NULL value being directly present
    in the target INSERT statement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL 构造总是直接在目标 INSERT 语句中转换为 SQL NULL 值。'
- en: 'If we’d like to be able to use the Python value `None` and have this also be
    persisted as NULL despite the presence of column defaults, we can configure this
    for the ORM using a Core-level modifier [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none"), which indicates a type where the
    ORM should treat the value `None` the same as any other value and pass it through,
    rather than omitting it as a “missing” value:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望能够使用 Python 值 `None` 并且尽管存在列默认值，也希望将其持久化为 NULL，则可以在 ORM 中使用一个 Core 级别的修改器
    [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") 进行配置，该修改器指示 ORM 应该将值 `None` 与任何其他值一样对待，并将其传递，而不是将其视为“缺失”的值而省略它：
- en: '[PRE10]  ## Fetching Server-Generated Defaults'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]  ## 获取服务器生成的默认值'
- en: As introduced in the sections [Server-invoked DDL-Explicit Default Expressions](../core/defaults.html#server-defaults)
    and [Marking Implicitly Generated Values, timestamps, and Triggered Columns](../core/defaults.html#triggered-columns),
    the Core supports the notion of database columns for which the database itself
    generates a value upon INSERT and in less common cases upon UPDATE statements.
    The ORM features support for such columns regarding being able to fetch these
    newly generated values upon flush. This behavior is required in the case of primary
    key columns that are generated by the server, since the ORM has to know the primary
    key of an object once it is persisted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[服务器调用的 DDL-显式默认表达式](../core/defaults.html#server-defaults)和[标记隐式生成的值、时间戳和触发列](../core/defaults.html#triggered-columns)章节中介绍的，Core
    支持数据库列的概念，即数据库自身在 INSERT 语句中生成一个值，以及在较少见的情况下，在 UPDATE 语句中生成一个值。ORM 功能支持此类列，以便在刷新时能够获取这些新生成的值。在服务器生成的主键列的情况下，这种行为是必需的，因为一旦对象被持久化，ORM
    就必须知道对象的主键。
- en: In the vast majority of cases, primary key columns that have their value generated
    automatically by the database are simple integer columns, which are implemented
    by the database as either a so-called “autoincrement” column, or from a sequence
    associated with the column. Every database dialect within SQLAlchemy Core supports
    a method of retrieving these primary key values which is often native to the Python
    DBAPI, and in general this process is automatic. There is more documentation regarding
    this at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，由数据库自动生成值的主键列是简单的整数列，数据库实现为所谓的“自增”列，或者从与列关联的序列中生成。SQLAlchemy Core 中的每个数据库方言都支持一种检索这些主键值的方法，这种方法通常是
    Python DBAPI 本地的，并且一般情况下这个过程是自动的。关于这一点还有更多的文档资料在 [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column")。
- en: For server-generating columns that are not primary key columns or that are not
    simple autoincrementing integer columns, the ORM requires that these columns are
    marked with an appropriate `server_default` directive that allows the ORM to retrieve
    this value. Not all methods are supported on all backends, however, so care must
    be taken to use the appropriate method. The two questions to be answered are,
    1\. is this column part of the primary key or not, and 2\. does the database support
    RETURNING or an equivalent, such as “OUTPUT inserted”; these are SQL phrases which
    return a server-generated value at the same time as the INSERT or UPDATE statement
    is invoked. RETURNING is currently supported by PostgreSQL, Oracle, MariaDB 10.5,
    SQLite 3.35, and SQL Server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是主键列或不是简单自增整数列的服务器生成列，ORM 要求这些列用适当的 `server_default` 指令标记，以允许 ORM 检索此值。然而，并非所有方法都支持所有后端，因此必须小心使用适当的方法。要回答的两个问题是，1\.
    这一列是否是主键，2\. 数据库是否支持 RETURNING 或等效方法，如“OUTPUT inserted”；这些是在调用 INSERT 或 UPDATE
    语句时同时返回服务器生成的值的 SQL 短语。RETURNING 目前由 PostgreSQL、Oracle、MariaDB 10.5、SQLite 3.35
    和 SQL Server 支持。
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 1：非主键，支持 RETURNING 或等效方法
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列应标记为 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 或具有显式的 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")。当执行 INSERT 语句时，ORM 将自动将这些列添加到 RETURNING 子句中，假设 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数设置为 `True`，或者如果将其默认设置为 `"auto"`，对于同时支持 RETURNING 和
    [insertmanyvalues](../core/connections.html#engine-insertmanyvalues) 的方言：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 INSERT 语句未为“timestamp”或“special_identifier”指定客户端端显式值时，将在 RETURNING 子句中包括“timestamp”和“special_identifier”列，以便立即可用。在
    PostgreSQL 数据库中，上述表的 INSERT 如下所示：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0.0rc1 更改：[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数现在默认为新设置 `"auto"`，它将自动使用 RETURNING 在 INSERT 时获取服务器生成的默认值，如果后备数据库同时支持
    RETURNING 和 [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的 `"auto"` 值仅适用于 INSERT 语句。即使可用，UPDATE 语句也不会使用 RETURNING，除非
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 设置为 `True`。这是因为 UPDATE 没有等价的“insertmanyvalues”功能，因此 UPDATE
    RETURNING 将要求为每个要 UPDATE 的行单独发出 UPDATE 语句。'
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 2：表中包含触发器生成的值，这些值与 RETURNING 不兼容
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的 `"auto"` 设置意味着支持 RETURNING 的后端通常会在 INSERT 语句中使用 RETURNING
    来检索新生成的默认值。但是，存在使用触发器生成的服务器生成值的限制，无法使用 RETURNING：'
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 不允许在 INSERT 语句中使用 RETURNING 来检索触发器生成的值；该语句将失败。
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 在将 RETURNING 与触发器结合使用时存在限制，因此 RETURNING 子句将不会具有 INSERTed 值可用
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他后端可能在与触发器一起使用 RETURNING 或其他类型的服务器生成的值时存在限制。
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用RETURNING用于这些值的使用，不仅包括服务器生成的默认值，还要确保ORM永远不会对特定表使用RETURNING，请为映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")指定[`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table")参数为`False`。使用声明性映射，看起来像这样：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用pyodbc驱动程序的SQL Server上，上述表的INSERT不会使用RETURNING，并将使用SQL Server `scope_identity()`函数检索新生成的主键值：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT行为](../dialects/mssql.html#mssql-insert-behavior) - SQL Server方言获取新生成的主键值的方法的背景'
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况3：非主键、不支持或不需要RETURNING或等效功能
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况与上述情况1相同，除了我们通常不想使用[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")，因为在没有支持RETURNING的情况下，它的当前实现是发出每行一个SELECT，这是不高效的。因此，在下面的映射中省略了该参数：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上述映射的记录在不包括RETURNING或“insertmanyvalues”支持的后端上INSERT之后， “timestamp”和“special_identifier”列将保持为空，并且将在刷新后首次访问时通过第二个SELECT语句获取，例如它们被标记为“过期”时。
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")显式提供了一个值为`True`，并且后端数据库不支持RETURNING或等效功能，则ORM将在INSERT语句之后立即发出一个SELECT语句以获取新生成的值；如果没有可用的RETURNING，则ORM目前无法批量选择许多新插入的行。这通常是不希望的，因为它会在刷新过程中添加额外的SELECT语句，这些语句可能是不必要的。将上述映射与[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")标志设置为True一起针对MySQL（不是MariaDB）使用会在刷新时产生如下SQL：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的SQLAlchemy版本可能会试图改进在没有RETURNING的情况下的急切默认值的效率，以便在单个SELECT语句中批量处理多行。
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况4：支持主键、RETURNING或等效功能
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 具有服务器生成值的主键列必须在INSERT后立即获取；ORM只能访问具有主键值的行，因此如果主键由服务器生成，则ORM需要一种在INSERT后立即检索该新值的方法。
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于整数的“自增”列，以及标记为[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")的列和诸如 PostgreSQL SERIAL 等特殊构造，这些类型由 Core 自动处理；数据库包括用于获取“最后插入的
    id”的函数，在不支持 RETURNING 的情况下，以及在支持 RETURNING 的情况下 SQLAlchemy 将使用它。
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Oracle 中使用标记为[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")的列，RETURNING 会自动用于获取新的主键值：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The INSERT for a model as above on Oracle looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型在 Oracle 上的 INSERT 如下所示：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 为“data”字段渲染了一个 INSERT，但只在 RETURNING 子句中包括了“id”，以便进行“id”的服务器端生成，并立即返回新值。
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由服务器端函数或触发器生成的非整数值，以及来自表本身之外的构造的整数值，包括显式序列和触发器，必须在表元数据中标记服务器默认生成。再次以 Oracle
    为例，我们可以用上面类似的表来说明使用 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 构造命名的显式序列：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An INSERT for this version of the model on Oracle would look like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 上，这个版本的模型的 INSERT 如下所示：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，SQLAlchemy 为主键列渲染了 `my_sequence.nextval`，以便用于新的主键生成，并且还使用 RETURNING
    立即获取新值。
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据源不是由简单的 SQL 函数或 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 表示，例如在使用触发器或产生新值的数据库特定数据类型时，可以通过在列定义中使用 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 来指示存在生成值的默认值。以下是一个使用 SQL Server TIMESTAMP 列作为主键的模型；在
    SQL Server 上，这种数据类型会自动生成新值，因此在表元数据中通过为 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 参数指示 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 来指示：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An INSERT for the above table on SQL Server looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表在 SQL Server 上的 INSERT 如下所示：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 5：主键，不支持 RETURNING 或等价的功能
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个区域，我们正在为像 MySQL 这样的数据库生成行，其中一些生成默认值的方法是在服务器上进行的，但超出了数据库通常的自动增量程序。在这种情况下，我们必须确保
    SQLAlchemy 可以“预执行”默认值，这意味着它必须是一个显式的 SQL 表达式。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将以MySQL的datetime值为例，说明多个配方，因为此后端的datetime数据类型具有额外的特殊要求，这些要求对于说明很有用。但请记住，MySQL对于用作主键的任何自动生成的数据类型都需要一个显式的“预执行”默认生成器，而不是通常的单列自增整数值。
- en: MySQL with DateTime primary key
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有DateTime主键的MySQL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MySQL的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")列的例子，我们使用“NOW()”SQL函数添加了一个显式的预执行支持的默认值：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，我们选择“NOW()”函数来向列传递日期时间值。由上述生成的SQL如下：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: MySQL with TIMESTAMP primary key
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有TIMESTAMP主键的MySQL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '当在MySQL中使用[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型时，MySQL通常会自动将服务器端默认值与此数据类型关联起来。但是，当我们将其用作主键时，核心无法检索新生成的值，除非我们自己执行函数。由于MySQL上的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")实际上存储了一个二进制值，因此我们需要在使用“NOW()”时添加额外的“CAST”，以便检索到可以持久化到列中的二进制值： '
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择“NOW()”函数之外，在上面的例子中，我们还额外使用`Binary`数据类型结合[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，以便返回的值是二进制的。从上面插入的SQL看起来像：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[列插入/更新默认值](../core/defaults.html)'
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于急切获取客户端调用的用于INSERT或UPDATE的SQL表达式的注意事项
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子表明了使用[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")创建包含默认生成函数的表格的DDL。
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy还支持非DDL服务器端默认值，如文档中所述[客户端调用的SQL表达式](../core/defaults.html#defaults-client-invoked-sql);
    这些“客户端调用的SQL表达式”是使用[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")参数设置的。
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 设置为 `"auto"` 或 `True` 时，这些 SQL 表达式目前受到 ORM 中与真正的服务器端默认值相同的限制；除非将
    [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    指令与 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    关联，否则当使用 RETURNING 时，它们不会被自动获取，尽管这些表达式不是 DDL 服务器默认值，而是由 SQLAlchemy 本身积极渲染的。这个限制可能在未来的
    SQLAlchemy 版本中得到解决。
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    结构可以同时应用于 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 或 [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")，以及与 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 一起使用的 SQL 表达式，例如下面的示例，其中 `func.now()` 结构用作客户端调用的 SQL
    表达式，用于 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")。为了让 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的行为包括使用 RETURNING 时获取这些值，需要使用 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 来确保进行获取：'
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述类似的映射，ORM 渲染的 INSERT 和 UPDATE 的 SQL 将在 RETURNING 子句中包含 `created` 和 `updated`：
- en: '[PRE28]  ## Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM
    Objects'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]  ## 使用 INSERT、UPDATE 和 ON CONFLICT（即 upsert）返回 ORM 对象'
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE, and upsert statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
    For upsert, see [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 包括增强功能，用于发出几种类型的 ORM-enabled INSERT、UPDATE 和 upsert 语句。请查看文档
    [ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)。有关 upsert，请参见
    [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert)。
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL ON CONFLICT 与 RETURNING 返回 upserted ORM 对象
- en: 'This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).  ##
    Partitioning Strategies (e.g. multiple database backends per Session)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已移至[ORM "upsert"语句](queryguide/dml.html#orm-queryguide-upsert)。## 分区策略（例如，每个会话多个数据库后端）
- en: Simple Vertical Partitioning
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的垂直分区
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区将不同的类、类层次结构或映射表配置到多个数据库中，方法是通过使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session")参数。该参数接收一个包含任意ORM映射类、映射层次结构中的任意类（如声明基类或混合类）、[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象的字典作为键，然后通常引用[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或不太常见的是[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象作为目标。每当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")需要代表特定类型的映射类发出SQL以定位适当的数据库连接源时，都会查询该字典：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，针对任何一个类的SQL操作都将使用与该类相关联的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")。该功能在读取和写入操作中都是全面的；针对映射到`engine1`的实体的[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")（通过查看请求项列表中的第一个实体来确定）将使用`engine1`来运行查询。刷新操作将基于每个类使用**两个**引擎，因为它会刷新`User`和`Account`类型的对象。
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在更常见的情况下，通常有基类或混合类可用于区分目的地不同数据库连接的操作。[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session")参数可以容纳任何任意的Python类作为键，如果发现它在特定映射类的`__mro__`（Python方法解析顺序）中，则将使用它。假设有两个声明基类代表两个不同的数据库连接：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，从`BaseA`和`BaseB`继承的类将根据它们是否从任何一个超类继承来路由它们的SQL操作到两个引擎之一。在一个类从多个“绑定”超类继承的情况下，将选择目标类层次结构中最高的超类来表示应该使用哪个引擎。
- en: See also
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
- en: Coordination of Transactions for a multiple-engine Session
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多引擎会话的事务协调
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个绑定引擎时的一个注意事项是，当提交操作在一个后端成功提交后，可能在另一个后端失败。这是一个不一致性问题，在关系型数据库中通过使用“两阶段事务”解决，它在提交序列中增加了一个额外的“准备”步骤，允许多个数据库在实际完成事务之前同意提交。
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DBAPI 中的支持有限，SQLAlchemy 在跨后端的两阶段事务方面的支持也有限。通常，它被认为与 PostgreSQL 后端很好地配合使用，而与
    MySQL 后端配合使用的程度较低。但是，当后端支持时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 完全能够利用两阶段事务功能，方法是在 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 或 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中设置 [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") 标志。请参阅[启用两阶段提交](session_transaction.html#session-twophase)以获取示例。
- en: '### Custom Vertical Partitioning'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义垂直分区'
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法可以构建更全面的基于规则的类级别分区。下面我们展示一个自定义的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") ，它提供以下规则：
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新操作以及批量的“更新”和“删除”操作都发送到名为 `leader` 的引擎。
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有子类为 `MyOtherClass` 的对象操作都发生在 `other` 引擎上。
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有其他类的读操作都发生在 `follower1` 或 `follower2` 数据库的随机选择上。
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    类通过 `class_` 参数插入到 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 中：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与多个 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    对象结合使用，使用类似使用声明性 `__abstract__` 关键字的方法，详细描述在 [__abstract__](declarative_config.html#declarative-abstract)。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上面的示例说明了将特定的SQL语句路由到所谓的“领导者”或“跟随者”数据库的方法，这可能不是一个实际的方法，因为它导致了在同一操作中读写之间的不协调事务行为。实际上，最好根据正在进行的整体操作/事务，提前将
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    构造为“读取器”或“写入器”会话。这样，将要写入数据的操作也将在同一事务范围内发出其读取查询。参见 [为 Sessionmaker / Engine 设置隔离级别](session_transaction.html#session-transaction-isolation-enginewide)
    中的示例，该示例设置了一个用于使用自动提交连接的“只读”操作的 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") ，另一个用于“写入”操作，其中包括 DML / COMMIT。
- en: See also
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[在SQLAlchemy中实现Django风格的数据库路由器](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - 关于更全面的[`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")的博客文章。'
- en: Horizontal Partitioning
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平分区
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).  ## Bulk
    Operations'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '水平分区将单个表（或一组表）的行分布到多个数据库中。SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 包含对这个概念的支持，但要完全使用它，需要使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 和 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的子类。这些子类的基本版本可在 [水平分片](extensions/horizontal_shard.html)
    ORM 扩展中找到。一个使用示例在这里：[水平分片](examples.html#examples-sharding)。  ## 批量操作'
- en: Legacy Feature
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 传统特性
- en: 'SQLAlchemy 2.0 has integrated the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “bulk insert” and “bulk update” capabilities into 2.0
    style [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    method, making direct use of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") and [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") constructs. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation,
    including [Legacy Session Bulk INSERT Methods](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    which illustrates migration from the older methods to the new methods.  ## Embedding
    SQL Insert/Update Expressions into a Flush'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQLAlchemy 2.0 已将“批量插入”和“批量更新”功能集成到2.0风格的 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法中，直接使用了 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 和 [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 构造。参见文档 [ORM-Enabled INSERT, UPDATE, and DELETE
    statements](queryguide/dml.html)，包括[传统的会话批量INSERT方法](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    ，该文档说明了从旧方法迁移到新方法的示例。  ## 将SQL插入/更新表达式嵌入到刷新中'
- en: 'This feature allows the value of a database column to be set to a SQL expression
    instead of a literal value. It’s especially useful for atomic updates, calling
    stored procedures, etc. All you do is assign an expression to an attribute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许将数据库列的值设置为 SQL 表达式，而不是文字值。对于原子更新、调用存储过程等特别有用。您所做的一切就是将表达式分配给属性：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This technique works both for INSERT and UPDATE statements. After the flush/commit
    operation, the `value` attribute on `someobject` above is expired, so that when
    next accessed the newly generated value will be loaded from the database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术对于 INSERT 和 UPDATE 语句均有效。在 flush/commit 操作之后，上述 `someobject` 上的 `value` 属性将过期，因此在下次访问时，新生成的值将从数据库加载。
- en: 'The feature also has conditional support to work in conjunction with primary
    key columns. For backends that have RETURNING support (including Oracle, SQL Server,
    MariaDB 10.5, SQLite 3.35) a SQL expression may be assigned to a primary key column
    as well. This allows both the SQL expression to be evaluated, as well as allows
    any server side triggers that modify the primary key value on INSERT, to be successfully
    retrieved by the ORM as part of the object’s primary key:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能还具有条件支持，可与主键列一起使用。对于支持 RETURNING 的后端（包括 Oracle、SQL Server、MariaDB 10.5、SQLite
    3.35），还可以将 SQL 表达式分配给主键列。这不仅允许评估 SQL 表达式，还允许检索任何在插入时修改主键值的服务器端触发器作为对象主键的一部分成功地检索到ORM：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On PostgreSQL, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will emit the following INSERT:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 上，上述 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    将发出以下 INSERT：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'New in version 1.3: SQL expressions can now be passed to a primary key column
    during an ORM flush; if the database supports RETURNING, or if pysqlite is in
    use, the ORM will be able to retrieve the server-generated value as the value
    of the primary key attribute.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3 新增：在ORM flush期间，SQL 表达式现在可以传递到主键列；如果数据库支持 RETURNING，或者正在使用 pysqlite，则ORM将能够将服务器生成的值检索为主键属性的值。
- en: '## Using SQL Expressions with Sessions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用 SQL 表达式与会话'
- en: 'SQL expressions and strings can be executed via the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within its transactional context. This is most
    easily accomplished using the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which returns a [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in the same manner as an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 表达式和字符串可以通过其事务上下文在 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    中执行。这最容易通过 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法来实现，该方法以与 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 相同的方式返回一个 [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult")：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The current [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") is accessible using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    当前持有的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    可以通过 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 方法访问：'
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The examples above deal with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). To execute statements using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which is bound either to multiple engines, or none at
    all (i.e. relies upon bound metadata), both [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") accept a dictionary of bind arguments [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") which may include “mapper” which is passed a
    mapped class or [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    instance, which is used to locate the proper context for the desired engine:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例涉及到绑定到单个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    或 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")。要使用绑定到多个引擎或根本没有绑定到引擎的
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    执行语句，[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    和 [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 都接受一个绑定参数字典 [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute")，其中可能包括 “mapper”，该参数传递了一个映射类或 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 实例，用于定位所需引擎的正确上下文：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Changed in version 1.4: the `mapper` and `clause` arguments to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are now passed as part of a dictionary sent
    as the [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") parameter. The previous arguments are still
    accepted however this usage is deprecated.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.4 开始变更：[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 的 `mapper` 和 `clause` 参数现在作为字典的一部分发送，作为 [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") 参数。以前的参数仍然被接受，但此用法已被弃用。
- en: '## Forcing NULL on a column with a default'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '## 强制将 NULL 值放入具有默认值的列'
- en: 'The ORM considers any attribute that was never set on an object as a “default”
    case; the attribute will be omitted from the INSERT statement:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 认为对象上从未设置的任何属性都是“默认”情况；该属性将从 INSERT 语句中省略：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Omitting a column from the INSERT means that the column will have the NULL
    value set, *unless* the column has a default set up, in which case the default
    value will be persisted. This holds true both from a pure SQL perspective with
    server-side defaults, as well as the behavior of SQLAlchemy’s insert behavior
    with both client-side and server-side defaults:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 INSERT 中省略了某列，则该列将被设置为 NULL 值，*除非*该列设置了默认值，在这种情况下，默认值将被保留。这适用于纯 SQL 视角下具有服务器端默认值的情况，也适用于
    SQLAlchemy 的插入行为，无论是客户端默认值还是服务器端默认值：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, in the ORM, even if one assigns the Python value `None` explicitly
    to the object, this is treated the **same** as though the value were never assigned:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ORM 中，即使将 Python 值 `None` 显式地分配给对象，这也被视为**相同**，就像从未分配过值一样：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The above operation will persist into the `data` column the server default value
    of `"default"` and not SQL NULL, even though `None` was passed; this is a long-standing
    behavior of the ORM that many applications hold as an assumption.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将持久化到 `data` 列的服务器默认值为 `"default"`，而不是 SQL NULL，即使传递了 `None`；这是 ORM 的长期行为，许多应用程序都将其视为假设。
- en: 'So what if we want to actually put NULL into this column, even though the column
    has a default value? There are two approaches. One is that on a per-instance level,
    we assign the attribute using the [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL construct:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想要在这列中实际放入 NULL 值，即使该列有默认值呢？有两种方法。一种是在每个实例级别上，我们使用 [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL 构造分配属性：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL construct always translates into the SQL NULL value being directly present
    in the target INSERT statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL 结构总是将 SQL NULL 值直接包含在目标 INSERT 语句中。'
- en: 'If we’d like to be able to use the Python value `None` and have this also be
    persisted as NULL despite the presence of column defaults, we can configure this
    for the ORM using a Core-level modifier [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none"), which indicates a type where the
    ORM should treat the value `None` the same as any other value and pass it through,
    rather than omitting it as a “missing” value:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望能够使用 Python 值 `None` 并且将其作为 NULL 持久化，尽管存在列默认值，我们可以在 ORM 中使用 Core 级别的修饰符
    [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") 进行配置，该修饰符指示 ORM 应该将值 `None` 与任何其他值一样对待并将其传递，而不是将其省略为“丢失”的值：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '## Fetching Server-Generated Defaults'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '## 获取服务器生成的默认值'
- en: As introduced in the sections [Server-invoked DDL-Explicit Default Expressions](../core/defaults.html#server-defaults)
    and [Marking Implicitly Generated Values, timestamps, and Triggered Columns](../core/defaults.html#triggered-columns),
    the Core supports the notion of database columns for which the database itself
    generates a value upon INSERT and in less common cases upon UPDATE statements.
    The ORM features support for such columns regarding being able to fetch these
    newly generated values upon flush. This behavior is required in the case of primary
    key columns that are generated by the server, since the ORM has to know the primary
    key of an object once it is persisted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在章节 [Server-invoked DDL-Explicit Default Expressions](../core/defaults.html#server-defaults)
    和 [Marking Implicitly Generated Values, timestamps, and Triggered Columns](../core/defaults.html#triggered-columns)
    中介绍的，Core 支持数据库列的概念，其中数据库本身在 INSERT 时生成值，在不太常见的情况下，在 UPDATE 语句中生成值。ORM 功能支持这些列，以便能够在刷新时获取这些新生成的值。在服务器生成的主键列的情况下，由于
    ORM 必须在对象持久化后知道其主键，因此需要这种行为。
- en: In the vast majority of cases, primary key columns that have their value generated
    automatically by the database are simple integer columns, which are implemented
    by the database as either a so-called “autoincrement” column, or from a sequence
    associated with the column. Every database dialect within SQLAlchemy Core supports
    a method of retrieving these primary key values which is often native to the Python
    DBAPI, and in general this process is automatic. There is more documentation regarding
    this at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，由数据库自动生成值的主键列都是简单的整数列，这些列由数据库实现为所谓的“自增”列，或者是与列关联的序列。SQLAlchemy Core
    中的每个数据库方言都支持一种检索这些主键值的方法，通常是原生于 Python DBAPI，并且通常这个过程是自动的。关于这一点，有更多的文档说明在 [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") 中。
- en: For server-generating columns that are not primary key columns or that are not
    simple autoincrementing integer columns, the ORM requires that these columns are
    marked with an appropriate `server_default` directive that allows the ORM to retrieve
    this value. Not all methods are supported on all backends, however, so care must
    be taken to use the appropriate method. The two questions to be answered are,
    1\. is this column part of the primary key or not, and 2\. does the database support
    RETURNING or an equivalent, such as “OUTPUT inserted”; these are SQL phrases which
    return a server-generated value at the same time as the INSERT or UPDATE statement
    is invoked. RETURNING is currently supported by PostgreSQL, Oracle, MariaDB 10.5,
    SQLite 3.35, and SQL Server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是主键列或不是简单自增整数列的服务器生成列，ORM 要求这些列使用适当的 `server_default` 指令标记，以允许 ORM 检索此值。然而，并不是所有方法都受到所有后端的支持，因此必须注意使用适当的方法。要回答的两个问题是，1\.
    此列是否是主键列，2\. 数据库是否支持 RETURNING 或等效操作，如 “OUTPUT inserted”；这些是 SQL 短语，它们在调用 INSERT
    或 UPDATE 语句时同时返回服务器生成的值。RETURNING 目前由 PostgreSQL、Oracle、MariaDB 10.5、SQLite 3.35
    和 SQL Server 支持。
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 1：非主键，支持 RETURNING 或等效操作
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列应标记为[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")，或者用显式的[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")。ORM 在执行 INSERT 语句时将自动将这些列添加到 RETURNING 子句中，假设 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数设置为 `True`，或者对于同时支持 RETURNING 和 [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    的方言，保持其默认设置为 `"auto"`：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，如果客户端未为“timestamp”或“special_identifier”指定显式值，则 INSERT 语句将在 RETURNING
    子句中包含“timestamp”和“special_identifier”列，以便立即使用。在 PostgreSQL 数据库中，上述表的 INSERT 如下所示：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0.0rc1 起更改：[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数现在默认为新设置 `"auto"`，如果后端数据库同时支持 RETURNING 和 [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)，将自动使用
    RETURNING 获取 INSERT 上生成的默认值。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的 `"auto"` 值仅适用于 INSERT 语句。即使可用，UPDATE 语句也不会使用 RETURNING，除非
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 设置为 `True`。这是因为 UPDATE 没有等效的“insertmanyvalues”特性，因此 UPDATE
    RETURNING 将要求对每个要更新的行分别发出 UPDATE 语句。'
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 2：表包含不兼容于 RETURNING 的触发器生成的值
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的 `"auto"` 设置意味着支持 RETURNING 的后端通常会在 INSERT 语句中使用 RETURNING
    以检索新生成的默认值。但是，使用触发器生成的服务器值存在限制，使得无法使用 RETURNING：'
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 不允许在 INSERT 语句中使用 RETURNING 来检索触发器生成的值；该语句将失败。
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 在将 RETURNING 与触发器组合使用时存在限制，因此 RETURNING 子句将不会包含插入的值
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他后端可能在与触发器一起使用 RETURNING，或者其他类型的服务器生成值时存在限制。
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用对这些值的 RETURNING 使用，不仅包括服务器生成的默认值，还要确保 ORM 永远不会与特定表使用 RETURNING，请为映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 指定 [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") 为 `False`。使用声明性映射如下所示：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 pyodbc 驱动程序的 SQL Server 上，对上述表的 INSERT 不会使用 RETURNING，并将使用 SQL Server 的
    `scope_identity()` 函数来检索新生成的主键值：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT 行为](../dialects/mssql.html#mssql-insert-behavior) - 关于 SQL Server 方言获取新生成主键值的方法的背景信息'
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 3：非主键，不支持或不需要 RETURNING 或等效功能
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该情况与上述情况 1 相同，但通常我们不希望使用 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")，因为在没有 RETURNING 支持的情况下，其当前实现是为每行发出一个 SELECT，这不是高效的。因此，在下面的映射中省略了该参数：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在不包含 RETURNING 或“insertmanyvalues”支持的后端上插入具有上述映射的记录后，"timestamp" 和 "special_identifier"
    列将保持为空，并且在刷新后首次访问时，例如标记为“过期”时，将通过第二个 SELECT 语句获取。
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 明确提供了值 `True`，并且后端数据库不支持 RETURNING 或等效功能，则 ORM 将在 INSERT
    语句后立即发出 SELECT 语句以获取新生成的值；如果没有 RETURNING 可用，ORM 目前无法批量选择许多新插入的行。这通常是不希望的，因为它会向刷新过程添加额外的
    SELECT 语句，这些语句可能是不必要的。在 MySQL（而不是 MariaDB）上使用上述映射与将 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 标志设置为 True 会导致刷新时生成以下 SQL：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 版本可能会在没有 RETURNING 的情况下，通过批量处理单个 SELECT 语句中的多行来提高急切默认值的效率。
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 4：主键，支持 RETURNING 或等效功能
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 具有服务器生成值的主键列必须在 INSERT 后立即获取；ORM 只能访问具有主键值的行，因此如果主键由服务器生成，则 ORM 需要一种在 INSERT
    后立即检索该新值的方法。
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于整数“自动增量”列，以及标记有 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") 和特殊构造（如 PostgreSQL SERIAL）的列，Core 会自动处理这些类型；数据库包括用于获取“最后插入
    id”的函数，在不支持 RETURNING 的情况下，以及支持 RETURNING 的情况下 SQLAlchemy 将使用该函数。
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Oracle 中，如果将列标记为 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")，则自动使用 RETURNING 获取新的主键值：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The INSERT for a model as above on Oracle looks like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，上述模型在 Oracle 上的 INSERT 如下所示：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 为“data”字段渲染了一个 INSERT，但在 RETURNING 子句中仅包含了“id”，以便在服务器端生成“id”，并立即返回新值。
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由服务器端函数或触发器生成的非整数值，以及来自表格本身之外的结构（包括显式序列和触发器）的整数值，必须在表格元数据中标记服务器默认生成。再次以 Oracle
    为例，我们可以举例说明一个类似上述的表格，使用 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 构造命名一个显式序列：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'An INSERT for this version of the model on Oracle would look like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 上，对于此模型的 INSERT 如下所示：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，SQLAlchemy 为主键列渲染了 `my_sequence.nextval`，以便用于新的主键生成，并且还使用 RETURNING 立即获取新值。
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据源不是由简单的 SQL 函数或 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 表示，例如在使用触发器或生成新值的数据库特定数据类型时，可以通过在列定义中使用 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 来指示值生成默认值的存在。下面是一个使用 SQL Server TIMESTAMP 列作为主键的模型；在
    SQL Server 上，此数据类型会自动生成新值，因此在表格元数据中通过为 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 参数指示 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 来表示这一点：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An INSERT for the above table on SQL Server looks like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 上，对于上述表格的 INSERT 如下所示：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况5：不支持主键、RETURNING 或等效功能。
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此领域，我们正在为 MySQL 等数据库生成行，其中服务器上正在发生一些默认生成的手段，但这些手段不在数据库的通常自增例程中。在这种情况下，我们必须确保
    SQLAlchemy 可以“预先执行”默认值，这意味着它必须是一个明确的 SQL 表达式。
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明涉及MySQL日期时间值的多个配方，因为该后端的日期时间数据类型具有额外的特殊要求，这些要求对于说明非常有用。但是请注意，除了通常的单列自增整数值之外，MySQL需要为*任何*用作主键的自动生成数据类型显式的“预执行”默认生成器。
- en: MySQL with DateTime primary key
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有DateTime主键的MySQL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以MySQL的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")列为例，我们使用“NOW()”SQL函数添加了一个明确的预执行支持的默认值：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，我们选择“NOW()”函数以向列传递日期时间值。上述生成的SQL是：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: MySQL with TIMESTAMP primary key
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有TIMESTAMP主键的MySQL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MySQL的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")数据类型时，MySQL通常会自动将服务器端默认与该数据类型关联起来。但是，当我们将其用作主键时，Core无法检索新生成的值，除非我们自己执行该函数。由于MySQL上的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")实际上存储了一个二进制值，因此我们需要在“NOW()”的使用中添加一个额外的“CAST”，以便检索到可以持久化到列中的二进制值：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，在选择“NOW()”函数的同时，我们还使用了`Binary`数据类型结合[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，以便返回的值是二进制的。在INSERT中从上述渲染的SQL如下所示：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[列插入/更新默认值](../core/defaults.html)'
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项：对于用于INSERT或UPDATE的急切提取客户端调用的SQL表达式
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例指示了使用[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")创建包含其DDL中的默认生成函数的表。
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy也支持非DDL服务器端的默认设置，如[客户端调用的SQL表达式](../core/defaults.html#defaults-client-invoked-sql
    "sqlalchemy.schema.Column")文档中所述；这些“客户端调用的SQL表达式”是使用[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")参数设置的。
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ORM 中的这些 SQL 表达式受到与真正的服务器端默认值相同的限制；当 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 设置为 `"auto"` 或 `True` 时，除非 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 指令与 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 相关联，否则它们不会被 RETURNING 急切地获取，尽管这些表达式不是 DDL 服务器默认值，并且由
    SQLAlchemy 本身主动渲染。这个限制可能在未来的 SQLAlchemy 版本中得到解决。
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    构造可以同时应用于 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 或 [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")，就像下面的例子中使用 `func.now()` 构造作为客户端调用的 SQL 表达式用于 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 一样。为了使 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的行为包括在可用时使用 RETURNING 获取这些值，[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 和 [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") 与 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 一起使用以确保获取发生：'
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似上面的映射，ORM 渲染的 INSERT 和 UPDATE 的 SQL 将在 RETURNING 子句中包括`created`和`updated`：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况1：非主键，支持 RETURNING 或等效功能
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应将列标记为[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")或具有显式的[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")。如果[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")参数设置为`True`，或者对于支持RETURNING以及[insertmanyvalues](../core/connections.html#engine-insertmanyvalues)的方言，默认设置为`"auto"`，ORM将在执行INSERT语句时自动将这些列添加到RETURNING子句中：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，未在客户端指定“timestamp”或“special_identifier”的显式值的INSERT语句将包括“timestamp”和“special_identifier”列在RETURNING子句中，以便立即使用。在PostgreSQL数据库上，上述表的INSERT将如下所示：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0.0rc1开始更改：[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")参数现在默认为新设置`"auto"`，如果支持RETURNING以及[insertmanyvalues](../core/connections.html#engine-insertmanyvalues)的后端数据库，则会自动使用RETURNING来获取INSERT时的服务器生成默认值。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")的`"auto"`值仅适用于INSERT语句。即使可用，UPDATE语句也不会使用RETURNING，除非将[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")设置为`True`。这是因为UPDATE没有等效的“insertmanyvalues”特性，因此UPDATE
    RETURNING将要求为每个被UPDATE的行分别发出UPDATE语句。'
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况2：表包含与RETURNING不兼容的触发器生成的值
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")的`"auto"`设置意味着支持RETURNING的后端通常会在INSERT语句中使用RETURNING来检索新生成的默认值。但是，存在使用触发器生成的服务器生成值的限制，因此不能使用RETURNING：'
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server不允许在INSERT语句中使用RETURNING来检索触发器生成的值；该语句将失败。
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite在与触发器结合使用RETURNING时存在限制，因此RETURNING子句将无法获取已插入的值。
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他后端可能在与触发器或其他类型的服务器生成值结合使用RETURNING时存在限制。
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用用于此类值的 RETURNING 的使用，包括不仅用于服务器生成的默认值而且确保 ORM 永远不会使用 RETURNING 与特定表，指定 [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") 为 `False` 对于映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。使用声明性映射，看起来像这样：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 pyodbc 驱动程序的 SQL Server 上，对于上述表的 INSERT 不会使用 RETURNING，并且将使用 SQL Server
    `scope_identity()` 函数来检索新生成的主键值：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT 行为](../dialects/mssql.html#mssql-insert-behavior) - 关于 SQL Server 方言获取新生成的主键值的方法的背景'
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 3：非主键，不支持或不需要 RETURNING 或等效功能
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该情况与上面的情况 1 相同，只是我们通常不想使用 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")，因为在没有 RETURNING 支持的情况下，其当前实现是发出每行一个 SELECT，这是不高效的。因此，在下面的映射中省略了该参数：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述映射中插入记录后，在不包括 RETURNING 或“insertmanyvalues”支持的后端上，“timestamp” 和 “special_identifier”
    列将保持为空，并且在刷新后首次访问时将通过第二个 SELECT 语句获取，例如，它们被标记为“过期”时。
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 明确提供了值 `True`，并且后端数据库不支持 RETURNING 或等效功能，则 ORM 将在 INSERT
    语句后立即发出 SELECT 语句，以获取新生成的值；如果没有可用的 RETURNING，ORM 目前无法批量选择许多新插入的行。这通常是不可取的，因为它会向刷新过程添加额外的
    SELECT 语句，这些语句可能是不需要的。使用上述映射，针对 MySQL（不是 MariaDB）将 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 标志设置为 True 在刷新时会产生类似以下的 SQL：
- en: '[PRE67]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 版本可能会在没有 RETURNING 的情况下寻求改进急切默认值的效率，以在单个 SELECT 语句中批量处理多行。
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 4：主键，支持 RETURNING 或等效功能
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 具有服务器生成值的主键列必须在 INSERT 后立即获取；ORM 只能访问具有主键值的行，因此如果主键由服务器生成，则 ORM 需要一种在 INSERT
    后立即检索该新值的方法。
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于整数“自增”列，以及标记为[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")的列和特殊构造，例如 PostgreSQL 的 SERIAL，这些类型将由核心自动处理；数据库包括获取“最后插入的
    id”函数，其中不支持 RETURNING，而在支持 RETURNING 的情况下，SQLAlchemy 将使用它。
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 Oracle 并将列标记为[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")，RETURNING 将自动用于获取新的主键值：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The INSERT for a model as above on Oracle looks like:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如上模型在 Oracle 上的 INSERT 如下所示：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 渲染“data”字段的 INSERT，但仅在 RETURNING 子句中包含“id”，以便在服务器端生成“id”并立即返回新值。
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由服务器端函数或触发器生成的非整数值，以及来自表本身之外的构造的整数值，包括显式序列和触发器，必须在表元数据中标记服务器默认生成。再次以 Oracle
    为例，我们可以用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")构造说明一个类似的表：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'An INSERT for this version of the model on Oracle would look like:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 上此模型的 INSERT 如下所示：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，SQLAlchemy 渲染`my_sequence.nextval`用于主键列的新主键生成，并且还使用 RETURNING 立即获取新值。
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据源不是由简单的 SQL 函数或[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")表示，例如使用触发器或生成新值的数据库特定数据类型，可以通过在列定义中使用[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")来指示值生成的默认值。下面是一个使用 SQL Server TIMESTAMP 列作为主键的模型；在
    SQL Server 上，此数据类型会自动生成新值，因此在表元数据中通过为[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")参数指定[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")来指示：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'An INSERT for the above table on SQL Server looks like:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 上上述表的 INSERT 如下所示：
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况 5：不支持主键、RETURNING 或等效项。
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域，我们为像 MySQL 这样的数据库生成行，其中服务器上正在发生某种默认生成的方法，但是超出了数据库的通常自动增量例程。在这种情况下，我们必须确保
    SQLAlchemy 可以“预执行”默认值，这意味着它必须是一个显式的 SQL 表达式。
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明MySQL中涉及日期时间值的多个示例，因为此后端的日期时间数据类型具有有用的额外特殊要求。但是请记住，MySQL对于用作主键的任何自动生成的数据类型都需要明确的“预执行”默认生成器，除了通常的单列自增整数值。
- en: MySQL with DateTime primary key
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL使用DateTime主键
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MySQL的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")列作为例子，我们使用“NOW()”SQL函数添加一个明确的预执行支持的默认值：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们选择“NOW()”函数将日期时间值传递给列。由上述生成的SQL是：
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: MySQL with TIMESTAMP primary key
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL使用TIMESTAMP主键
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当在MySQL中使用[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型时，MySQL通常会自动将服务器端默认值与此数据类型关联起来。但是，当我们将其用作主键时，Core无法检索到新生成的值，除非我们自己执行该函数。由于MySQL上的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")实际上存储的是二进制值，因此我们需要在“NOW()”的使用中添加额外的“CAST”，以便检索到可持久化到列中的二进制值：
- en: '[PRE76]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，除了选择“NOW()”函数外，我们还额外利用`Binary`数据类型与[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")结合使用，以便返回值是二进制的。在INSERT中生成的SQL如下所示：
- en: '[PRE77]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[列的INSERT/UPDATE默认值](../core/defaults.html)'
- en: MySQL with DateTime primary key
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL使用DateTime主键
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MySQL的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")列作为例子，我们使用“NOW()”SQL函数添加一个明确的预执行支持的默认值：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们选择“NOW()”函数将日期时间值传递给列。由上述生成的SQL是：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: MySQL with TIMESTAMP primary key
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL使用TIMESTAMP主键
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当在MySQL中使用[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型时，MySQL通常会自动将服务器端默认值与此数据类型关联起来。但是，当我们将其用作主键时，Core无法检索到新生成的值，除非我们自己执行该函数。由于MySQL上的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")实际上存储的是二进制值，因此我们需要在“NOW()”的使用中添加额外的“CAST”，以便检索到可持久化到列中的二进制值：
- en: '[PRE80]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，除了选择“NOW()”函数外，我们还使用`Binary`数据类型结合[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，以使返回的值是二进制的。在 INSERT 中从上面渲染的 SQL 如下所示：
- en: '[PRE81]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: See also
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[列插入/更新默认值](../core/defaults.html)'
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于急切获取用于 INSERT 或 UPDATE 的客户端调用的 SQL 表达式的注意事项
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明了使用[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")创建包含默认生成函数的表的方法。
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 也支持非 DDL 服务器端默认值，如[客户端调用的 SQL 表达式](../core/defaults.html#defaults-client-invoked-sql)文档所述；这些“客户端调用的
    SQL 表达式”是使用[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")参数设置的。
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SQL 表达式目前受 ORM 中与真正的服务器端默认值发生的相同限制的约束；当[`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")设置为`"auto"`或`True`时，它们不会被急切地获取到 RETURNING 中，除非[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue")指令与[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")关联，即使这些表达式不是 DDL 服务器默认值，而是由 SQLAlchemy 本身主动渲染的。这个限制可能在未来的
    SQLAlchemy 版本中得到解决。
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    构造可以同时应用于 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 或 [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")，与 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 一起使用 SQL 表达式，例如下面的示例中，`func.now()` 构造被用作客户端调用的 SQL
    表达式，用于 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")。为了使 [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 的行为包括使用 RETURNING 在可用时获取这些值，需要使用 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 和 [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") 与 [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") 以确保获取发生：'
- en: '[PRE82]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述类似的映射，ORM 渲染的 INSERT 和 UPDATE 的 SQL 将在 RETURNING 子句中包括 `created` 和 `updated`：
- en: '[PRE83]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '## Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM Objects'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用INSERT、UPDATE和ON CONFLICT（即upsert）返回ORM对象'
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE, and upsert statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
    For upsert, see [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 包括增强功能，用于发出几种类型的启用ORM的 INSERT、UPDATE 和 upsert 语句。查看文档 [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) 以获取文档。有关 upsert，请参见
    [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert)。
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL ON CONFLICT 与 RETURNING 返回 upserted ORM 对象
- en: This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已移至 [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert)。
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL ON CONFLICT 与 RETURNING 返回 upserted ORM 对象
- en: This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已移至 [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert)。
- en: '## Partitioning Strategies (e.g. multiple database backends per Session)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '## 分区策略（例如，每个会话使用多个数据库后端）'
- en: Simple Vertical Partitioning
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的垂直分区
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区通过配置[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") 参数，将不同的类、类层次结构或映射表放置在多个数据库中。此参数接收一个包含任意组合的 ORM 映射类、映射层次结构中的任意类（如声明性基类或混合类）、[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 对象作为键的字典，然后通常引用[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或较不常见的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象作为目标。每当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")需要代表特定类型的映射类发出 SQL 以定位适当的数据库连接源时，就会查询该字典：
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，针对任一类的 SQL 操作都将使用与该类链接的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")。该功能涵盖了读写操作；针对映射到`engine1`的实体的 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")（通过查看请求的项目列表中的第一个实体确定）将使用`engine1`来运行查询。刷新操作将根据每个类使用**两个**引擎，因为它刷新了`User`和`Account`类型的对象。
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在更常见的情况下，通常有基础类或混合类可用于区分不同数据库连接的操作。[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") 参数可以容纳任何任意的 Python 类作为键，如果发现它在特定映射类的`__mro__`（Python
    方法解析顺序）中，则会使用该键。假设两个声明性基类分别表示两个不同的数据库连接：
- en: '[PRE85]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，从`BaseA`和`BaseB`继承的类将根据它们是否继承自任何超类来将它们的 SQL 操作路由到两个引擎中的一个。对于从多个“绑定”超类继承的类的情况，将选择目标类层次结构中最高的超类来表示应使用哪个引擎。
- en: See also
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
- en: Coordination of Transactions for a multiple-engine Session
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为多引擎会话协调事务
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个绑定引擎的一个注意事项是，如果提交操作在一个后端成功提交后在另一个后端失败，则可能会出现问题。这是一个一致性问题，在关系数据库中通过“两阶段事务”解决，它在提交序列中添加了一个额外的“准备”步骤，允许多个数据库在实际完成事务之前同意提交。
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DBAPI 中的支持有限，SQLAlchemy 对跨后端的两阶段事务的支持也有限。通常来说，它已知与 PostgreSQL 后端一起工作良好，与
    MySQL 后端一起工作效果较差。然而，当后端支持时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 完全能够利用两阶段事务功能，方法是在 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 或 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中设置 [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") 标志。参见[启用两阶段提交](session_transaction.html#session-twophase)以获取示例。
- en: '### Custom Vertical Partitioning'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义垂直分区'
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 更全面的基于规则的类级分区可以通过覆盖 [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法来构建。下面我们演示了一个自定义的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，它提供以下规则：
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新操作以及批量的“更新”和“删除”操作都传递到名为 `leader` 的引擎。
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有子类为 `MyOtherClass` 的对象的操作都发生在 `other` 引擎上。
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有其他类的读取操作都发生在随机选择的 `follower1` 或 `follower2` 数据库上。
- en: '[PRE86]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    类是通过 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    的 `class_` 参数来插入的：
- en: '[PRE87]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与多个 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    对象结合使用，使用类似于使用声明性 `__abstract__` 关键字的方法，如[__abstract__](declarative_config.html#declarative-abstract)中所述。
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了根据 SQL 语句是否期望写入数据将特定 SQL 语句路由到所谓的“主”或“从”数据库，但这可能不是一个实用的方法，因为它会导致在同一操作中读取和写入之间存在不协调的事务行为。实践中，最好在整个操作/事务进行的基础上，提前构建[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")作为“读取者”或“写入者”会话。这样，将要写入数据的操作也会在同一个事务范围内发出其读取查询。有关在[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")中设置“只读”操作的配方，使用自动提交连接，以及用于包含 DML/COMMIT 的“写入”操作的另一个配方，请参阅[为
    Sessionmaker / Engine 设置隔离级别](session_transaction.html#session-transaction-isolation-enginewide)的示例。
- en: See also
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 中的 Django 风格数据库路由器](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - 关于[`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")更全面示例的博文'
- en: Horizontal Partitioning
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平分区
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 水平分区将单个表（或一组表）的行分区到多个数据库中。SQLAlchemy 的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")包含对这个概念的支持，但要完全使用它，需要使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")和[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")子类。这些子类的基本版本可在[水平分区](extensions/horizontal_shard.html)ORM
    扩展中找到。一个使用示例位于：[水平分区](examples.html#examples-sharding)。
- en: Simple Vertical Partitioning
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的垂直分区
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直分区将不同的类、类层次结构或映射表配置到多个数据库中，通过配置[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session")参数。该参数接收一个字典，其中包含任意组合的ORM映射类、映射层次结构内的任意类（例如声明基类或混合类）、[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象作为键，这些键通常引用[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或更少见的情况下引用[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象作为目标。每当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")需要代表特定类型的映射类发出SQL以定位数据库连接的适当源时，就会查询该字典：
- en: '[PRE88]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，针对任一类的SQL操作将使用与该类链接的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")。该功能在读写操作中都是全面的；针对映射到`engine1`的实体的[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")（通过查看请求的项目列表中的第一个实体来确定）将使用`engine1`来运行查询。刷新操作将基于每个类使用**两个**引擎，因为它会刷新`User`和`Account`类型的对象。
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在更常见的情况下，通常有基类或混合类可用于区分命令操作的目标数据库连接。[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session")参数可以接受任何任意的Python类作为键，如果在特定映射类的`__mro__`（Python方法解析顺序）中找到，则会使用该键。假设有两个声明基类代表两个不同的数据库连接：
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，从`BaseA`和`BaseB`继承的类将根据它们是否继承自其中任何一个超类而将其SQL操作路由到两个引擎中的一个。对于从多个“绑定”超类继承的类，将选择目标类层次结构中最高的超类来表示应该使用哪个引擎。
- en: See also
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
- en: Coordination of Transactions for a multiple-engine Session
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多引擎会话的事务协调
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多个绑定引擎的情况下，有一个需要注意的地方是，在一个提交操作在一个后端成功提交后，另一个后端可能失败。这是一个一致性问题，在关系型数据库中通过“两阶段事务”解决，该事务将一个额外的“准备”步骤添加到提交序列中，允许多个数据库在实际完成事务之前同意提交。
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DBAPI的支持有限，SQLAlchemy对跨后端的两阶段事务的支持也有限。最典型的是，它在PostgreSQL后端上运行良好，并且在MySQL后端上的支持较少。但是，当后端支持时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")完全能够利用两阶段事务功能，方法是在[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中设置[`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session")标志。参见[启用两阶段提交](session_transaction.html#session-twophase)以获取示例。
- en: '### Custom Vertical Partitioning'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义垂直分区'
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过重写[`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")方法来构建更全面的基于规则的类级分区。以下是一个自定义[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的示例，提供以下规则：
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新操作以及批量“更新”和“删除”操作将传送到名为`leader`的引擎。
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有子类化`MyOtherClass`的对象操作都发生在`other`引擎上。
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有其他类的读取操作都在`follower1`或`follower2`数据库的随机选择上进行。
- en: '[PRE90]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")类是通过向[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")传递`class_`参数来插入的：
- en: '[PRE91]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与多个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象结合使用，例如使用声明性的`__abstract__`关键字的方法，如在[__abstract__](declarative_config.html#declarative-abstract)中所述。
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的示例说明了将特定的 SQL 语句路由到基于语句是否期望写入数据的所谓 “leader” 或 “follower” 数据库，但这可能不是一种实际的方法，因为它导致在同一操作中读取和写入之间的不协调事务行为。实际上，最好是根据正在进行的整体操作
    / 事务，提前将 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    构造为 “读取者” 或 “写入者” 会话。这样，将要写入数据的操作也会在同一个事务范围内发出其读取查询。请参阅 [为 Sessionmaker / Engine
    设置隔离](session_transaction.html#session-transaction-isolation-enginewide) 中的示例，该示例设置了一个用于
    “只读” 操作的 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    ，使用自动提交连接，另一个用于包含 DML / COMMIT 的 “写入” 操作。
- en: See also
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 中的 Django 风格数据库路由器](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - 有关 [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    的更全面示例的博客文章'
- en: Horizontal Partitioning
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平分区
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 水平分区将单个表（或一组表）的行跨多个数据库进行分区。SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 包含对此概念的支持，但要充分利用它，需要使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 和 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的子类。这些子类的基本版本在 [水平分片](extensions/horizontal_shard.html)
    ORM 扩展中可用。使用示例位于：[水平分片](examples.html#examples-sharding)。
- en: '## Bulk Operations'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '## 批量操作'
- en: Legacy Feature
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留特性
- en: SQLAlchemy 2.0 has integrated the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “bulk insert” and “bulk update” capabilities into 2.0
    style [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    method, making direct use of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") and [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") constructs. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation,
    including [Legacy Session Bulk INSERT Methods](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    which illustrates migration from the older methods to the new methods.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 将 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的“批量插入”和“批量更新”功能集成到了 2.0 风格的 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法中，直接使用了 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 和 [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 构造。请参阅 [ORM 启用的 INSERT、UPDATE 和 DELETE 语句](queryguide/dml.html)
    文档，包括 [遗留 Session 批量 INSERT 方法](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    ，其中说明了从旧方法迁移到新方法的示例。
