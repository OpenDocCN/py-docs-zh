- en: Additional Persistence Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html](https://docs.sqlalchemy.org/en/20/orm/persistence_techniques.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Embedding SQL Insert/Update Expressions into a Flush'
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature allows the value of a database column to be set to a SQL expression
    instead of a literal value. It’s especially useful for atomic updates, calling
    stored procedures, etc. All you do is assign an expression to an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This technique works both for INSERT and UPDATE statements. After the flush/commit
    operation, the `value` attribute on `someobject` above is expired, so that when
    next accessed the newly generated value will be loaded from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature also has conditional support to work in conjunction with primary
    key columns. For backends that have RETURNING support (including Oracle, SQL Server,
    MariaDB 10.5, SQLite 3.35) a SQL expression may be assigned to a primary key column
    as well. This allows both the SQL expression to be evaluated, as well as allows
    any server side triggers that modify the primary key value on INSERT, to be successfully
    retrieved by the ORM as part of the object’s primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On PostgreSQL, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will emit the following INSERT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3: SQL expressions can now be passed to a primary key column
    during an ORM flush; if the database supports RETURNING, or if pysqlite is in
    use, the ORM will be able to retrieve the server-generated value as the value
    of the primary key attribute.  ## Using SQL Expressions with Sessions'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL expressions and strings can be executed via the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within its transactional context. This is most
    easily accomplished using the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which returns a [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in the same manner as an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The current [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") is accessible using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples above deal with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). To execute statements using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which is bound either to multiple engines, or none at
    all (i.e. relies upon bound metadata), both [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") accept a dictionary of bind arguments [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") which may include “mapper” which is passed a
    mapped class or [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    instance, which is used to locate the proper context for the desired engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: the `mapper` and `clause` arguments to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are now passed as part of a dictionary sent
    as the [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") parameter. The previous arguments are still
    accepted however this usage is deprecated.  ## Forcing NULL on a column with a
    default'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM considers any attribute that was never set on an object as a “default”
    case; the attribute will be omitted from the INSERT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting a column from the INSERT means that the column will have the NULL
    value set, *unless* the column has a default set up, in which case the default
    value will be persisted. This holds true both from a pure SQL perspective with
    server-side defaults, as well as the behavior of SQLAlchemy’s insert behavior
    with both client-side and server-side defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the ORM, even if one assigns the Python value `None` explicitly
    to the object, this is treated the **same** as though the value were never assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The above operation will persist into the `data` column the server default value
    of `"default"` and not SQL NULL, even though `None` was passed; this is a long-standing
    behavior of the ORM that many applications hold as an assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what if we want to actually put NULL into this column, even though the column
    has a default value? There are two approaches. One is that on a per-instance level,
    we assign the attribute using the [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL construct always translates into the SQL NULL value being directly present
    in the target INSERT statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’d like to be able to use the Python value `None` and have this also be
    persisted as NULL despite the presence of column defaults, we can configure this
    for the ORM using a Core-level modifier [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none"), which indicates a type where the
    ORM should treat the value `None` the same as any other value and pass it through,
    rather than omitting it as a “missing” value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]  ## Fetching Server-Generated Defaults'
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in the sections [Server-invoked DDL-Explicit Default Expressions](../core/defaults.html#server-defaults)
    and [Marking Implicitly Generated Values, timestamps, and Triggered Columns](../core/defaults.html#triggered-columns),
    the Core supports the notion of database columns for which the database itself
    generates a value upon INSERT and in less common cases upon UPDATE statements.
    The ORM features support for such columns regarding being able to fetch these
    newly generated values upon flush. This behavior is required in the case of primary
    key columns that are generated by the server, since the ORM has to know the primary
    key of an object once it is persisted.
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, primary key columns that have their value generated
    automatically by the database are simple integer columns, which are implemented
    by the database as either a so-called “autoincrement” column, or from a sequence
    associated with the column. Every database dialect within SQLAlchemy Core supports
    a method of retrieving these primary key values which is often native to the Python
    DBAPI, and in general this process is automatic. There is more documentation regarding
    this at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: For server-generating columns that are not primary key columns or that are not
    simple autoincrementing integer columns, the ORM requires that these columns are
    marked with an appropriate `server_default` directive that allows the ORM to retrieve
    this value. Not all methods are supported on all backends, however, so care must
    be taken to use the appropriate method. The two questions to be answered are,
    1\. is this column part of the primary key or not, and 2\. does the database support
    RETURNING or an equivalent, such as “OUTPUT inserted”; these are SQL phrases which
    return a server-generated value at the same time as the INSERT or UPDATE statement
    is invoked. RETURNING is currently supported by PostgreSQL, Oracle, MariaDB 10.5,
    SQLite 3.35, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The INSERT for a model as above on Oracle looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for this version of the model on Oracle would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for the above table on SQL Server looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL with DateTime primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: MySQL with TIMESTAMP primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  prefs: []
  type: TYPE_NORMAL
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]  ## Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM
    Objects'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE, and upsert statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
    For upsert, see [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).  ##
    Partitioning Strategies (e.g. multiple database backends per Session)'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Vertical Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: Coordination of Transactions for a multiple-engine Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '### Custom Vertical Partitioning'
  prefs: []
  type: TYPE_NORMAL
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).  ## Bulk
    Operations'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0 has integrated the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “bulk insert” and “bulk update” capabilities into 2.0
    style [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    method, making direct use of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") and [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") constructs. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation,
    including [Legacy Session Bulk INSERT Methods](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    which illustrates migration from the older methods to the new methods.  ## Embedding
    SQL Insert/Update Expressions into a Flush'
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature allows the value of a database column to be set to a SQL expression
    instead of a literal value. It’s especially useful for atomic updates, calling
    stored procedures, etc. All you do is assign an expression to an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This technique works both for INSERT and UPDATE statements. After the flush/commit
    operation, the `value` attribute on `someobject` above is expired, so that when
    next accessed the newly generated value will be loaded from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature also has conditional support to work in conjunction with primary
    key columns. For backends that have RETURNING support (including Oracle, SQL Server,
    MariaDB 10.5, SQLite 3.35) a SQL expression may be assigned to a primary key column
    as well. This allows both the SQL expression to be evaluated, as well as allows
    any server side triggers that modify the primary key value on INSERT, to be successfully
    retrieved by the ORM as part of the object’s primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On PostgreSQL, the above [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will emit the following INSERT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3: SQL expressions can now be passed to a primary key column
    during an ORM flush; if the database supports RETURNING, or if pysqlite is in
    use, the ORM will be able to retrieve the server-generated value as the value
    of the primary key attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Using SQL Expressions with Sessions'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL expressions and strings can be executed via the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within its transactional context. This is most
    easily accomplished using the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which returns a [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in the same manner as an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The current [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") is accessible using the [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples above deal with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). To execute statements using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which is bound either to multiple engines, or none at
    all (i.e. relies upon bound metadata), both [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.connection()`](session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") accept a dictionary of bind arguments [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") which may include “mapper” which is passed a
    mapped class or [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    instance, which is used to locate the proper context for the desired engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: the `mapper` and `clause` arguments to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are now passed as part of a dictionary sent
    as the [`Session.execute.bind_arguments`](session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments
    "sqlalchemy.orm.Session.execute") parameter. The previous arguments are still
    accepted however this usage is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Forcing NULL on a column with a default'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM considers any attribute that was never set on an object as a “default”
    case; the attribute will be omitted from the INSERT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting a column from the INSERT means that the column will have the NULL
    value set, *unless* the column has a default set up, in which case the default
    value will be persisted. This holds true both from a pure SQL perspective with
    server-side defaults, as well as the behavior of SQLAlchemy’s insert behavior
    with both client-side and server-side defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the ORM, even if one assigns the Python value `None` explicitly
    to the object, this is treated the **same** as though the value were never assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The above operation will persist into the `data` column the server default value
    of `"default"` and not SQL NULL, even though `None` was passed; this is a long-standing
    behavior of the ORM that many applications hold as an assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what if we want to actually put NULL into this column, even though the column
    has a default value? There are two approaches. One is that on a per-instance level,
    we assign the attribute using the [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") SQL construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The [`null`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    SQL construct always translates into the SQL NULL value being directly present
    in the target INSERT statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’d like to be able to use the Python value `None` and have this also be
    persisted as NULL despite the presence of column defaults, we can configure this
    for the ORM using a Core-level modifier [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none"), which indicates a type where the
    ORM should treat the value `None` the same as any other value and pass it through,
    rather than omitting it as a “missing” value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '## Fetching Server-Generated Defaults'
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in the sections [Server-invoked DDL-Explicit Default Expressions](../core/defaults.html#server-defaults)
    and [Marking Implicitly Generated Values, timestamps, and Triggered Columns](../core/defaults.html#triggered-columns),
    the Core supports the notion of database columns for which the database itself
    generates a value upon INSERT and in less common cases upon UPDATE statements.
    The ORM features support for such columns regarding being able to fetch these
    newly generated values upon flush. This behavior is required in the case of primary
    key columns that are generated by the server, since the ORM has to know the primary
    key of an object once it is persisted.
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, primary key columns that have their value generated
    automatically by the database are simple integer columns, which are implemented
    by the database as either a so-called “autoincrement” column, or from a sequence
    associated with the column. Every database dialect within SQLAlchemy Core supports
    a method of retrieving these primary key values which is often native to the Python
    DBAPI, and in general this process is automatic. There is more documentation regarding
    this at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: For server-generating columns that are not primary key columns or that are not
    simple autoincrementing integer columns, the ORM requires that these columns are
    marked with an appropriate `server_default` directive that allows the ORM to retrieve
    this value. Not all methods are supported on all backends, however, so care must
    be taken to use the appropriate method. The two questions to be answered are,
    1\. is this column part of the primary key or not, and 2\. does the database support
    RETURNING or an equivalent, such as “OUTPUT inserted”; these are SQL phrases which
    return a server-generated value at the same time as the INSERT or UPDATE statement
    is invoked. RETURNING is currently supported by PostgreSQL, Oracle, MariaDB 10.5,
    SQLite 3.35, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The INSERT for a model as above on Oracle looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for this version of the model on Oracle would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for the above table on SQL Server looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL with DateTime primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: MySQL with TIMESTAMP primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  prefs: []
  type: TYPE_NORMAL
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Case 1: non primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, columns should be marked as [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") or with an explicit [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"). The ORM will automatically add these columns to the
    RETURNING clause when performing INSERT statements, assuming the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter is set to `True`, or if left at its default
    setting of `"auto"`, for dialects that support both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an INSERT statement that does not specify explicit values for “timestamp”
    or “special_identifier” from the client side will include the “timestamp” and
    “special_identifier” columns within the RETURNING clause so they are available
    immediately. On the PostgreSQL database, an INSERT for the above table will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0rc1: The [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a new setting `"auto"`, which
    will automatically make use of RETURNING to fetch server-generated default values
    on INSERT if the backing database supports both RETURNING as well as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `"auto"` value for [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") only applies to INSERT statements. UPDATE statements
    will not use RETURNING, even if available, unless [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `True`. This is because there is no equivalent
    “insertmanyvalues” feature for UPDATE, so UPDATE RETURNING will require that UPDATE
    statements are emitted individually for each row being UPDATEd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Table includes trigger-generated values which are not compatible with
    RETURNING'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `"auto"` setting of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") means that a backend that supports RETURNING will usually
    make use of RETURNING with INSERT statements in order to retrieve newly generated
    default values. However there are limitations of server-generated values that
    are generated using triggers, such that RETURNING can’t be used:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server does not allow RETURNING to be used in an INSERT statement to retrieve
    a trigger-generated value; the statement will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite has limitations in combining the use of RETURNING with triggers, such
    that the RETURNING clause will not have the INSERTed value available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other backends may have limitations with RETURNING in conjunction with triggers,
    or other kinds of server-generated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To disable the use of RETURNING for such values, including not just for server
    generated default values but also to ensure that the ORM will never use RETURNING
    with a particular table, specify [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") as `False` for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Using a Declarative mapping this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'On SQL Server with the pyodbc driver, an INSERT for the above table will not
    use RETURNING and will use the SQL Server `scope_identity()` function to retrieve
    the newly generated primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT behavior](../dialects/mssql.html#mssql-insert-behavior) - background
    on the SQL Server dialect’s methods of fetching newly generated primary key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: non primary key, RETURNING or equivalent is not supported or not needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This case is the same as case 1 above, except we typically don’t want to use
    [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper"), as its current implementation in the absence of RETURNING
    support is to emit a SELECT-per-row, which is not performant. Therefore the parameter
    is omitted in the mapping below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After a record with the above mapping is INSERTed on a backend that does not
    include RETURNING or “insertmanyvalues” support, the “timestamp” and “special_identifier”
    columns will remain empty, and will be fetched via a second SELECT statement when
    they are first accessed after the flush, e.g. they are marked as “expired”.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is explicitly provided with a value of `True`, and the
    backend database does not support RETURNING or an equivalent, the ORM will emit
    a SELECT statement immediately following the INSERT statement in order to fetch
    newly generated values; the ORM does not currently have the ability to SELECT
    many newly inserted rows in batch if RETURNING was not available. This is usually
    undesirable as it adds additional SELECT statements to the flush process that
    may not be needed. Using the above mapping with the [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") flag set to True against MySQL (not MariaDB) results
    in SQL like this upon flush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: A future release of SQLAlchemy may seek to improve the efficiency of eager defaults
    in the abcense of RETURNING to batch many rows within a single SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 4: primary key, RETURNING or equivalent is supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A primary key column with a server-generated value must be fetched immediately
    upon INSERT; the ORM can only access rows for which it has a primary key value,
    so if the primary key is generated by the server, the ORM needs a way to retrieve
    that new value immediately upon INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, for integer “autoincrement” columns, as well as columns
    marked with [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    and special constructs such as PostgreSQL SERIAL, these types are handled automatically
    by the Core; databases include functions for fetching the “last inserted id” where
    RETURNING is not supported, and where RETURNING is supported SQLAlchemy will use
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using Oracle with a column marked as [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity"), RETURNING is used automatically to fetch the new
    primary key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The INSERT for a model as above on Oracle looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy renders an INSERT for the “data” field, but only includes “id” in
    the RETURNING clause, so that server-side generation for “id” will take place
    and the new value will be returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-integer values generated by server side functions or triggers, as well
    as for integer values that come from constructs outside the table itself, including
    explicit sequences and triggers, the server default generation must be marked
    in the table metadata. Using Oracle as the example again, we can illustrate a
    similar table as above naming an explicit sequence using the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for this version of the model on Oracle would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Where above, SQLAlchemy renders `my_sequence.nextval` for the primary key column
    so that it is used for new primary key generation, and also uses RETURNING to
    get the new value back immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the source of data is not represented by a simple SQL function or [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"), such as when using triggers or database-specific
    datatypes that produce new values, the presence of a value-generating default
    may be indicated by using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") within the column definition. Below is a model
    that uses a SQL Server TIMESTAMP column as the primary key; on SQL Server, this
    datatype generates new values automatically, so this is indicated in the table
    metadata by indicating [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") for the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT for the above table on SQL Server looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Case 5: primary key, RETURNING or equivalent is not supported'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this area we are generating rows for a database such as MySQL where some
    means of generating a default is occurring on the server, but is outside of the
    database’s usual autoincrement routine. In this case, we have to make sure SQLAlchemy
    can “pre-execute” the default, which means it has to be an explicit SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section will illustrate multiple recipes involving datetime values for
    MySQL, since the datetime datatypes on this backend has additional idiosyncratic
    requirements that are useful to illustrate. Keep in mind however that MySQL requires
    an explicit “pre-executed” default generator for *any* auto-generated datatype
    used as the primary key other than the usual single-column autoincrementing integer
    value.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL with DateTime primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: MySQL with TIMESTAMP primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL with DateTime primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the example of a [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") column for MySQL, we add an explicit pre-execute-supported
    default using the “NOW()” SQL function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, we select the “NOW()” function to deliver a datetime value to
    the column. The SQL generated by the above is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: MySQL with TIMESTAMP primary key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with MySQL, MySQL ordinarily associates
    a server-side default with this datatype automatically. However when we use one
    as a primary key, the Core cannot retrieve the newly generated value unless we
    execute the function ourselves. As [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") on MySQL actually stores a binary value, we need
    to add an additional “CAST” to our usage of “NOW()” so that we retrieve a binary
    value that can be persisted into the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in addition to selecting the “NOW()” function, we additionally make
    use of the `Binary` datatype in conjunction with [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that the returned value is binary. SQL rendered
    from the above within an INSERT looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column INSERT/UPDATE Defaults](../core/defaults.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Notes on eagerly fetching client invoked SQL expressions used for INSERT or
    UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding examples indicate the use of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") to create tables that include default-generation functions
    within their DDL.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy also supports non-DDL server side defaults, as documented at [Client-Invoked
    SQL Expressions](../core/defaults.html#defaults-client-invoked-sql); these “client
    invoked SQL expressions” are set up using the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameters.
  prefs: []
  type: TYPE_NORMAL
- en: These SQL expressions currently are subject to the same limitations within the
    ORM as occurs for true server-side defaults; they won’t be eagerly fetched with
    RETURNING when [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") is set to `"auto"` or `True` unless the [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") directive is associated with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), even though these expressions are not DDL server
    defaults and are actively rendered by SQLAlchemy itself. This limitation may be
    addressed in future SQLAlchemy releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue "sqlalchemy.schema.FetchedValue")
    construct can be applied to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") or [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") at the same time that a SQL expression is used with
    [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), such as in the example below where the `func.now()`
    construct is used as a client-invoked SQL expression for [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). In order for the behavior of [`Mapper.eager_defaults`](mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") to include that it fetches these values using RETURNING
    when available, [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") are used with [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue") to ensure that the fetch occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'With a mapping similar to the above, the SQL rendered by the ORM for INSERT
    and UPDATE will include `created` and `updated` in the RETURNING clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '## Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM Objects'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE, and upsert statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
    For upsert, see [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: Using PostgreSQL ON CONFLICT with RETURNING to return upserted ORM objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section has moved to [ORM “upsert” Statements](queryguide/dml.html#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: '## Partitioning Strategies (e.g. multiple database backends per Session)'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Vertical Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: Coordination of Transactions for a multiple-engine Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '### Custom Vertical Partitioning'
  prefs: []
  type: TYPE_NORMAL
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Vertical Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vertical partitioning places different classes, class hierarchies, or mapped
    tables, across multiple databases, by configuring the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with the [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument. This argument receives a dictionary that contains
    any combination of ORM-mapped classes, arbitrary classes within a mapped hierarchy
    (such as declarative base classes or mixins), [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects as keys, which then refer typically to [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or less typically [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects as targets. The dictionary is consulted
    whenever the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    needs to emit SQL on behalf of a particular kind of mapped class in order to locate
    the appropriate source of database connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Above, SQL operations against either class will make usage of the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") linked to that class. The functionality is comprehensive
    across both read and write operations; a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that is against entities mapped to `engine1` (determined
    by looking at the first entity in the list of items requested) will make use of
    `engine1` to run the query. A flush operation will make use of **both** engines
    on a per-class basis as it flushes objects of type `User` and `Account`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the more common case, there are typically base or mixin classes that can
    be used to distinguish between operations that are destined for different database
    connections. The [`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") argument can accommodate any arbitrary Python class
    as a key, which will be used if it is found to be in the `__mro__` (Python method
    resolution order) for a particular mapped class. Supposing two declarative bases
    are representing two different database connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Above, classes which descend from `BaseA` and `BaseB` will have their SQL operations
    routed to one of two engines based on which superclass they descend from, if any.
    In the case of a class that descends from more than one “bound” superclass, the
    superclass that is highest in the target class’ hierarchy will be chosen to represent
    which engine should be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.binds`](session_api.html#sqlalchemy.orm.Session.params.binds "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: Coordination of Transactions for a multiple-engine Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One caveat to using multiple bound engines is in the case where a commit operation
    may fail on one backend after the commit has succeeded on another. This is an
    inconsistency problem that in relational databases is solved using a “two phase
    transaction”, which adds an additional “prepare” step to the commit sequence that
    allows for multiple databases to agree to commit before actually completing the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Due to limited support within DBAPIs, SQLAlchemy has limited support for two-
    phase transactions across backends. Most typically, it is known to work well with
    the PostgreSQL backend and to a lesser extent with the MySQL backend. However,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is fully capable of taking advantage of the two phase transaction feature when
    the backend supports it, by setting the [`Session.use_twophase`](session_api.html#sqlalchemy.orm.Session.params.use_twophase
    "sqlalchemy.orm.Session") flag within [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). See [Enabling Two-Phase Commit](session_transaction.html#session-twophase)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '### Custom Vertical Partitioning'
  prefs: []
  type: TYPE_NORMAL
- en: 'More comprehensive rule-based class-level partitioning can be built by overriding
    the [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind "sqlalchemy.orm.Session.get_bind")
    method. Below we illustrate a custom [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which delivers the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Flush operations, as well as bulk “update” and “delete” operations, are delivered
    to the engine named `leader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations on objects that subclass `MyOtherClass` all occur on the `other`
    engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read operations for all other classes occur on a random choice of the `follower1`
    or `follower2` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class is plugged in using the `class_` argument to [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This approach can be combined with multiple [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") objects, using an approach such as that of using
    the declarative `__abstract__` keyword, described at [__abstract__](declarative_config.html#declarative-abstract).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the above example illustrates routing of specific SQL statements to a
    so-called “leader” or “follower” database based on whether or not the statement
    expects to write data, this is likely not a practical approach, as it leads to
    uncoordinated transaction behavior between reading and writing within the same
    operation. In practice, it’s likely best to construct the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") up front as a “reader” or “writer” session, based on
    the overall operation / transaction that’s proceeding. That way, an operation
    that will be writing data will also emit its read-queries within the same transaction
    scope. See the example at [Setting Isolation For A Sessionmaker / Engine Wide](session_transaction.html#session-transaction-isolation-enginewide)
    for a recipe that sets up one [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") for “read only” operations using autocommit connections,
    and another for “write” operations which will include DML / COMMIT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Django-style Database Routers in SQLAlchemy](https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/)
    - blog post on a more comprehensive example of [`Session.get_bind()`](session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal Partitioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Horizontal partitioning partitions the rows of a single table (or a set of
    tables) across multiple databases. The SQLAlchemy [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") contains support for this concept, however to use it
    fully requires that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    subclasses are used. A basic version of these subclasses are available in the
    [Horizontal Sharding](extensions/horizontal_shard.html) ORM extension. An example
    of use is at: [Horizontal Sharding](examples.html#examples-sharding).'
  prefs: []
  type: TYPE_NORMAL
- en: '## Bulk Operations'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 has integrated the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “bulk insert” and “bulk update” capabilities into 2.0
    style [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    method, making direct use of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") and [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") constructs. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation,
    including [Legacy Session Bulk INSERT Methods](queryguide/dml.html#orm-queryguide-legacy-bulk-insert)
    which illustrates migration from the older methods to the new methods.
  prefs: []
  type: TYPE_NORMAL
