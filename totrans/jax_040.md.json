["```py\nfrom functools import partial\n\nimport jax\nfrom jax.experimental import pallas as pl\nimport jax.numpy as jnp\nimport numpy as np \n```", "```py\ndef add_vectors_kernel(x_ref, y_ref, o_ref):\n  x, y = x_ref[...], y_ref[...]\n  o_ref[...] = x + y \n```", "```py\n@jax.jit\ndef add_vectors(x: jax.Array, y: jax.Array) -> jax.Array:\n  return pl.pallas_call(add_vectors_kernel,\n                        out_shape=jax.ShapeDtypeStruct(x.shape, x.dtype)\n                        )(x, y)\nadd_vectors(jnp.arange(8), jnp.arange(8)) \n```", "```py\nArray([ 0,  2,  4,  6,  8, 10, 12, 14], dtype=int32) \n```", "```py\ndef iota_kernel(o_ref):\n  i = pl.program_id(0)\n  o_ref[i] = i \n```", "```py\ndef iota(len: int):\n  return pl.pallas_call(iota_kernel,\n                        out_shape=jax.ShapeDtypeStruct((len,), jnp.int32),\n                        grid=(len,))()\niota(8) \n```", "```py\nArray([0, 1, 2, 3, 4, 5, 6, 7], dtype=int32) \n```", "```py\ndef matmul_kernel(x_ref, y_ref, z_ref):\n  z_ref[...] = x_ref[...] @ y_ref[...]\n\ndef matmul(x: jax.Array, y: jax.Array):\n  return pl.pallas_call(\n    matmul_kernel,\n    out_shape=jax.ShapeDtypeStruct((x.shape[0], y.shape[1]), x.dtype),\n    grid=(2, 2),\n    in_specs=[\n      pl.BlockSpec(lambda i, j: (i, 0), (x.shape[0] // 2, x.shape[1])),\n      pl.BlockSpec(lambda i, j: (0, j), (y.shape[0], y.shape[1] // 2))\n    ],\n    out_specs=pl.BlockSpec(\n      lambda i, j: (i, j), (x.shape[0] // 2, y.shape[1] // 2)\n    )\n  )(x, y)\nk1, k2 = jax.random.split(jax.random.key(0))\nx = jax.random.normal(k1, (1024, 1024))\ny = jax.random.normal(k2, (1024, 1024))\nz = matmul(x, y)\nnp.testing.assert_allclose(z, x @ y) \n```", "```py\ndef matmul_kernel(x_ref, y_ref, z_ref, *, activation):\n  z_ref[...] = activation(x_ref[...] @ y_ref[...])\n\ndef matmul(x: jax.Array, y: jax.Array, *, activation):\n  return pl.pallas_call(\n    partial(matmul_kernel, activation=activation),\n    out_shape=jax.ShapeDtypeStruct((x.shape[0], y.shape[1]), x.dtype),\n    grid=(2, 2),\n    in_specs=[\n      pl.BlockSpec(lambda i, j: (i, 0), (x.shape[0] // 2, x.shape[1])),\n      pl.BlockSpec(lambda i, j: (0, j), (y.shape[0], y.shape[1] // 2))\n    ],\n    out_specs=pl.BlockSpec(\n      lambda i, j: (i, j), (x.shape[0] // 2, y.shape[1] // 2)\n    ),\n  )(x, y)\nk1, k2 = jax.random.split(jax.random.key(0))\nx = jax.random.normal(k1, (1024, 1024))\ny = jax.random.normal(k2, (1024, 1024))\nz = matmul(x, y, activation=jax.nn.relu)\nnp.testing.assert_allclose(z, jax.nn.relu(x @ y)) \n```", "```py\nk1, k2 = jax.random.split(jax.random.key(0))\nx = jax.random.normal(k1, (4, 1024, 1024))\ny = jax.random.normal(k2, (4, 1024, 1024))\nz = jax.vmap(partial(matmul, activation=jax.nn.relu))(x, y)\nnp.testing.assert_allclose(z, jax.nn.relu(jax.vmap(jnp.matmul)(x, y))) \n```"]