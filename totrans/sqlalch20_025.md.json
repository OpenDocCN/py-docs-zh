["```py\nimport dataclasses\n\n@dataclasses.dataclass\nclass Point:\n    x: int\n    y: int\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase, Mapped\nfrom sqlalchemy.orm import composite, mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    start: Mapped[Point] = composite(mapped_column(\"x1\"), mapped_column(\"y1\"))\n    end: Mapped[Point] = composite(mapped_column(\"x2\"), mapped_column(\"y2\"))\n\n    def __repr__(self):\n        return f\"Vertex(start={self.start}, end={self.end})\"\n```", "```py\n>>> from sqlalchemy.schema import CreateTable\n>>> print(CreateTable(Vertex.__table__))\nCREATE  TABLE  vertices  (\n  id  INTEGER  NOT  NULL,\n  x1  INTEGER  NOT  NULL,\n  y1  INTEGER  NOT  NULL,\n  x2  INTEGER  NOT  NULL,\n  y2  INTEGER  NOT  NULL,\n  PRIMARY  KEY  (id)\n) \n```", "```py\n    >>> v = Vertex(start=Point(3, 4), end=Point(5, 6))\n    >>> session.add(v)\n    >>> session.commit()\n    BEGIN  (implicit)\n    INSERT  INTO  vertices  (x1,  y1,  x2,  y2)  VALUES  (?,  ?,  ?,  ?)\n    [generated  in  ...]  (3,  4,  5,  6)\n    COMMIT \n    ```", "```py\n    >>> stmt = select(Vertex.start, Vertex.end)\n    >>> session.execute(stmt).all()\n    SELECT  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    [...]  ()\n    [(Point(x=3, y=4), Point(x=5, y=6))]\n    ```", "```py\n    >>> stmt = select(Vertex).where(Vertex.start == Point(3, 4)).where(Vertex.end < Point(7, 8))\n    >>> session.scalars(stmt).all()\n    SELECT  vertices.id,  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    WHERE  vertices.x1  =  ?  AND  vertices.y1  =  ?  AND  vertices.x2  <  ?  AND  vertices.y2  <  ?\n    [...]  (3,  4,  7,  8)\n    [Vertex(Point(x=3, y=4), Point(x=5, y=6))]\n    ```", "```py\n    >>> v1 = session.scalars(select(Vertex)).one()\n    SELECT  vertices.id,  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    [...]  ()\n    >>> v1.end = Point(x=10, y=14)\n    >>> session.commit()\n    UPDATE  vertices  SET  x2=?,  y2=?  WHERE  vertices.id  =  ?\n    [...]  (10,  14,  1)\n    COMMIT \n    ```", "```py\nfrom sqlalchemy import Integer\nfrom sqlalchemy.orm import mapped_column, composite\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id = mapped_column(Integer, primary_key=True)\n    x1 = mapped_column(Integer)\n    y1 = mapped_column(Integer)\n    x2 = mapped_column(Integer)\n    y2 = mapped_column(Integer)\n\n    start = composite(Point, x1, y1)\n    end = composite(Point, x2, y2)\n```", "```py\nfrom sqlalchemy.orm import mapped_column, composite, Mapped\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    x1: Mapped[int]\n    y1: Mapped[int]\n    x2: Mapped[int]\n    y2: Mapped[int]\n\n    start: Mapped[Point] = composite(\"x1\", \"y1\")\n    end: Mapped[Point] = composite(\"x2\", \"y2\")\n```", "```py\nmapper_registry.map_imperatively(\n    Vertex,\n    vertices_table,\n    properties={\n        \"start\": composite(Point, vertices_table.c.x1, vertices_table.c.y1),\n        \"end\": composite(Point, vertices_table.c.x2, vertices_table.c.y2),\n    },\n)\n```", "```py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __repr__(self):\n        return f\"Point(x={self.x!r}, y={self.y!r})\"\n\n    def __eq__(self, other):\n        return isinstance(other, Point) and other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nimport dataclasses\n\nfrom sqlalchemy.orm import composite\nfrom sqlalchemy.orm import CompositeProperty\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.sql import and_\n\n@dataclasses.dataclass\nclass Point:\n    x: int\n    y: int\n\nclass PointComparator(CompositeProperty.Comparator):\n    def __gt__(self, other):\n  \"\"\"redefine the 'greater than' operation\"\"\"\n\n        return and_(\n            *[\n                a > b\n                for a, b in zip(\n                    self.__clause_element__().clauses,\n                    dataclasses.astuple(other),\n                )\n            ]\n        )\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    start: Mapped[Point] = composite(\n        mapped_column(\"x1\"), mapped_column(\"y1\"), comparator_factory=PointComparator\n    )\n    end: Mapped[Point] = composite(\n        mapped_column(\"x2\"), mapped_column(\"y2\"), comparator_factory=PointComparator\n    )\n```", "```py\n>>> print(Vertex.start > Point(5, 6))\nvertices.x1  >  :x1_1  AND  vertices.y1  >  :y1_1 \n```", "```py\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any\nfrom typing import Tuple\n\nfrom sqlalchemy.orm import composite\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\n@dataclasses.dataclass\nclass Point:\n    x: int\n    y: int\n\n@dataclasses.dataclass\nclass Vertex:\n    start: Point\n    end: Point\n\n    @classmethod\n    def _generate(cls, x1: int, y1: int, x2: int, y2: int) -> Vertex:\n  \"\"\"generate a Vertex from a row\"\"\"\n        return Vertex(Point(x1, y1), Point(x2, y2))\n\n    def __composite_values__(self) -> Tuple[Any, ...]:\n  \"\"\"generate a row from a Vertex\"\"\"\n        return dataclasses.astuple(self.start) + dataclasses.astuple(self.end)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass HasVertex(Base):\n    __tablename__ = \"has_vertex\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    x1: Mapped[int]\n    y1: Mapped[int]\n    x2: Mapped[int]\n    y2: Mapped[int]\n\n    vertex: Mapped[Vertex] = composite(Vertex._generate, \"x1\", \"y1\", \"x2\", \"y2\")\n```", "```py\nhv = HasVertex(vertex=Vertex(Point(1, 2), Point(3, 4)))\n\nsession.add(hv)\nsession.commit()\n\nstmt = select(HasVertex).where(HasVertex.vertex == Vertex(Point(1, 2), Point(3, 4)))\n\nhv = session.scalars(stmt).first()\nprint(hv.vertex.start)\nprint(hv.vertex.end)\n```", "```py\nfunction sqlalchemy.orm.composite(_class_or_attr: None | Type[_CC] | Callable[..., _CC] | _CompositeAttrType[Any] = None, *attrs: _CompositeAttrType[Any], group: str | None = None, deferred: bool = False, raiseload: bool = False, comparator_factory: Type[Composite.Comparator[_T]] | None = None, active_history: bool = False, init: _NoArg | bool = _NoArg.NO_ARG, repr: _NoArg | bool = _NoArg.NO_ARG, default: Any | None = _NoArg.NO_ARG, default_factory: _NoArg | Callable[[], _T] = _NoArg.NO_ARG, compare: _NoArg | bool = _NoArg.NO_ARG, kw_only: _NoArg | bool = _NoArg.NO_ARG, info: _InfoType | None = None, doc: str | None = None, **__kw: Any) \u2192 Composite[Any]\n```", "```py\n    >>> v = Vertex(start=Point(3, 4), end=Point(5, 6))\n    >>> session.add(v)\n    >>> session.commit()\n    BEGIN  (implicit)\n    INSERT  INTO  vertices  (x1,  y1,  x2,  y2)  VALUES  (?,  ?,  ?,  ?)\n    [generated  in  ...]  (3,  4,  5,  6)\n    COMMIT \n    ```", "```py\n    >>> stmt = select(Vertex.start, Vertex.end)\n    >>> session.execute(stmt).all()\n    SELECT  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    [...]  ()\n    [(Point(x=3, y=4), Point(x=5, y=6))]\n    ```", "```py\n    >>> stmt = select(Vertex).where(Vertex.start == Point(3, 4)).where(Vertex.end < Point(7, 8))\n    >>> session.scalars(stmt).all()\n    SELECT  vertices.id,  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    WHERE  vertices.x1  =  ?  AND  vertices.y1  =  ?  AND  vertices.x2  <  ?  AND  vertices.y2  <  ?\n    [...]  (3,  4,  7,  8)\n    [Vertex(Point(x=3, y=4), Point(x=5, y=6))]\n    ```", "```py\n    >>> v1 = session.scalars(select(Vertex)).one()\n    SELECT  vertices.id,  vertices.x1,  vertices.y1,  vertices.x2,  vertices.y2\n    FROM  vertices\n    [...]  ()\n    >>> v1.end = Point(x=10, y=14)\n    >>> session.commit()\n    UPDATE  vertices  SET  x2=?,  y2=?  WHERE  vertices.id  =  ?\n    [...]  (10,  14,  1)\n    COMMIT \n    ```", "```py\nfrom sqlalchemy import Integer\nfrom sqlalchemy.orm import mapped_column, composite\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id = mapped_column(Integer, primary_key=True)\n    x1 = mapped_column(Integer)\n    y1 = mapped_column(Integer)\n    x2 = mapped_column(Integer)\n    y2 = mapped_column(Integer)\n\n    start = composite(Point, x1, y1)\n    end = composite(Point, x2, y2)\n```", "```py\nfrom sqlalchemy.orm import mapped_column, composite, Mapped\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    x1: Mapped[int]\n    y1: Mapped[int]\n    x2: Mapped[int]\n    y2: Mapped[int]\n\n    start: Mapped[Point] = composite(\"x1\", \"y1\")\n    end: Mapped[Point] = composite(\"x2\", \"y2\")\n```", "```py\nmapper_registry.map_imperatively(\n    Vertex,\n    vertices_table,\n    properties={\n        \"start\": composite(Point, vertices_table.c.x1, vertices_table.c.y1),\n        \"end\": composite(Point, vertices_table.c.x2, vertices_table.c.y2),\n    },\n)\n```", "```py\nfrom sqlalchemy import Integer\nfrom sqlalchemy.orm import mapped_column, composite\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id = mapped_column(Integer, primary_key=True)\n    x1 = mapped_column(Integer)\n    y1 = mapped_column(Integer)\n    x2 = mapped_column(Integer)\n    y2 = mapped_column(Integer)\n\n    start = composite(Point, x1, y1)\n    end = composite(Point, x2, y2)\n```", "```py\nfrom sqlalchemy.orm import mapped_column, composite, Mapped\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    x1: Mapped[int]\n    y1: Mapped[int]\n    x2: Mapped[int]\n    y2: Mapped[int]\n\n    start: Mapped[Point] = composite(\"x1\", \"y1\")\n    end: Mapped[Point] = composite(\"x2\", \"y2\")\n```", "```py\nmapper_registry.map_imperatively(\n    Vertex,\n    vertices_table,\n    properties={\n        \"start\": composite(Point, vertices_table.c.x1, vertices_table.c.y1),\n        \"end\": composite(Point, vertices_table.c.x2, vertices_table.c.y2),\n    },\n)\n```", "```py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __repr__(self):\n        return f\"Point(x={self.x!r}, y={self.y!r})\"\n\n    def __eq__(self, other):\n        return isinstance(other, Point) and other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nimport dataclasses\n\nfrom sqlalchemy.orm import composite\nfrom sqlalchemy.orm import CompositeProperty\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.sql import and_\n\n@dataclasses.dataclass\nclass Point:\n    x: int\n    y: int\n\nclass PointComparator(CompositeProperty.Comparator):\n    def __gt__(self, other):\n  \"\"\"redefine the 'greater than' operation\"\"\"\n\n        return and_(\n            *[\n                a > b\n                for a, b in zip(\n                    self.__clause_element__().clauses,\n                    dataclasses.astuple(other),\n                )\n            ]\n        )\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    start: Mapped[Point] = composite(\n        mapped_column(\"x1\"), mapped_column(\"y1\"), comparator_factory=PointComparator\n    )\n    end: Mapped[Point] = composite(\n        mapped_column(\"x2\"), mapped_column(\"y2\"), comparator_factory=PointComparator\n    )\n```", "```py\n>>> print(Vertex.start > Point(5, 6))\nvertices.x1  >  :x1_1  AND  vertices.y1  >  :y1_1 \n```", "```py\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any\nfrom typing import Tuple\n\nfrom sqlalchemy.orm import composite\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\n@dataclasses.dataclass\nclass Point:\n    x: int\n    y: int\n\n@dataclasses.dataclass\nclass Vertex:\n    start: Point\n    end: Point\n\n    @classmethod\n    def _generate(cls, x1: int, y1: int, x2: int, y2: int) -> Vertex:\n  \"\"\"generate a Vertex from a row\"\"\"\n        return Vertex(Point(x1, y1), Point(x2, y2))\n\n    def __composite_values__(self) -> Tuple[Any, ...]:\n  \"\"\"generate a row from a Vertex\"\"\"\n        return dataclasses.astuple(self.start) + dataclasses.astuple(self.end)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass HasVertex(Base):\n    __tablename__ = \"has_vertex\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    x1: Mapped[int]\n    y1: Mapped[int]\n    x2: Mapped[int]\n    y2: Mapped[int]\n\n    vertex: Mapped[Vertex] = composite(Vertex._generate, \"x1\", \"y1\", \"x2\", \"y2\")\n```", "```py\nhv = HasVertex(vertex=Vertex(Point(1, 2), Point(3, 4)))\n\nsession.add(hv)\nsession.commit()\n\nstmt = select(HasVertex).where(HasVertex.vertex == Vertex(Point(1, 2), Point(3, 4)))\n\nhv = session.scalars(stmt).first()\nprint(hv.vertex.start)\nprint(hv.vertex.end)\n```", "```py\nfunction sqlalchemy.orm.composite(_class_or_attr: None | Type[_CC] | Callable[..., _CC] | _CompositeAttrType[Any] = None, *attrs: _CompositeAttrType[Any], group: str | None = None, deferred: bool = False, raiseload: bool = False, comparator_factory: Type[Composite.Comparator[_T]] | None = None, active_history: bool = False, init: _NoArg | bool = _NoArg.NO_ARG, repr: _NoArg | bool = _NoArg.NO_ARG, default: Any | None = _NoArg.NO_ARG, default_factory: _NoArg | Callable[[], _T] = _NoArg.NO_ARG, compare: _NoArg | bool = _NoArg.NO_ARG, kw_only: _NoArg | bool = _NoArg.NO_ARG, info: _InfoType | None = None, doc: str | None = None, **__kw: Any) \u2192 Composite[Any]\n```"]