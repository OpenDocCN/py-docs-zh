["```py\nimport numpy as np\nfrom jax import grad, jit\nfrom jax import lax\nfrom jax import random\nimport jax\nimport jax.numpy as jnp \n```", "```py\ndef impure_print_side_effect(x):\n  print(\"Executing function\")  # This is a side-effect\n  return x\n\n# The side-effects appear during the first run\nprint (\"First call: \", jit(impure_print_side_effect)(4.))\n\n# Subsequent runs with parameters of same type and shape may not show the side-effect\n# This is because JAX now invokes a cached compilation of the function\nprint (\"Second call: \", jit(impure_print_side_effect)(5.))\n\n# JAX re-runs the Python function when the type or shape of the argument changes\nprint (\"Third call, different type: \", jit(impure_print_side_effect)(jnp.array([5.]))) \n```", "```py\nExecuting function\nFirst call:  4.0\nSecond call:  5.0\nExecuting function\nThird call, different type:  [5.] \n```", "```py\ng = 0.\ndef impure_uses_globals(x):\n  return x + g\n\n# JAX captures the value of the global during the first run\nprint (\"First call: \", jit(impure_uses_globals)(4.))\ng = 10.  # Update the global\n\n# Subsequent runs may silently use the cached value of the globals\nprint (\"Second call: \", jit(impure_uses_globals)(5.))\n\n# JAX re-runs the Python function when the type or shape of the argument changes\n# This will end up reading the latest value of the global\nprint (\"Third call, different type: \", jit(impure_uses_globals)(jnp.array([4.]))) \n```", "```py\nFirst call:  4.0\nSecond call:  5.0\nThird call, different type:  [14.] \n```", "```py\ng = 0.\ndef impure_saves_global(x):\n  global g\n  g = x\n  return x\n\n# JAX runs once the transformed function with special Traced values for arguments\nprint (\"First call: \", jit(impure_saves_global)(4.))\nprint (\"Saved global: \", g)  # Saved global has an internal JAX value \n```", "```py\nFirst call:  4.0\nSaved global:  Traced<ShapedArray(float32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)> \n```", "```py\ndef pure_uses_internal_state(x):\n  state = dict(even=0, odd=0)\n  for i in range(10):\n    state['even' if i % 2 == 0 else 'odd'] += x\n  return state['even'] + state['odd']\n\nprint(jit(pure_uses_internal_state)(5.)) \n```", "```py\n50.0 \n```", "```py\nimport jax.numpy as jnp\nimport jax.lax as lax\nfrom jax import make_jaxpr\n\n# lax.fori_loop\narray = jnp.arange(10)\nprint(lax.fori_loop(0, 10, lambda i,x: x+array[i], 0)) # expected result 45\niterator = iter(range(10))\nprint(lax.fori_loop(0, 10, lambda i,x: x+next(iterator), 0)) # unexpected result 0\n\n# lax.scan\ndef func11(arr, extra):\n    ones = jnp.ones(arr.shape)\n    def body(carry, aelems):\n        ae1, ae2 = aelems\n        return (carry + ae1 * ae2 + extra, carry)\n    return lax.scan(body, 0., (arr, ones))\nmake_jaxpr(func11)(jnp.arange(16), 5.)\n# make_jaxpr(func11)(iter(range(16)), 5.) # throws error\n\n# lax.cond\narray_operand = jnp.array([0.])\nlax.cond(True, lambda x: x+1, lambda x: x-1, array_operand)\niter_operand = iter(range(10))\n# lax.cond(True, lambda x: next(x)+1, lambda x: next(x)-1, iter_operand) # throws error \n```", "```py\n45\n0 \n```", "```py\nnumpy_array = np.zeros((3,3), dtype=np.float32)\nprint(\"original array:\")\nprint(numpy_array)\n\n# In place, mutating update\nnumpy_array[1, :] = 1.0\nprint(\"updated array:\")\nprint(numpy_array) \n```", "```py\noriginal array:\n[[0\\. 0\\. 0.]\n [0\\. 0\\. 0.]\n [0\\. 0\\. 0.]]\nupdated array:\n[[0\\. 0\\. 0.]\n [1\\. 1\\. 1.]\n [0\\. 0\\. 0.]] \n```", "```py\n%xmode Minimal \n```", "```py\nException reporting mode: Minimal \n```", "```py\njax_array = jnp.zeros((3,3), dtype=jnp.float32)\n\n# In place update of JAX's array will yield an error!\njax_array[1, :] = 1.0 \n```", "```py\nTypeError: '<class 'jaxlib.xla_extension.ArrayImpl'>' object does not support item assignment. JAX arrays are immutable. Instead of ``x[idx] = y``, use ``x = x.at[idx].set(y)`` or another .at[] method: https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html \n```", "```py\nupdated_array = jax_array.at[1, :].set(1.0)\nprint(\"updated array:\\n\", updated_array) \n```", "```py\nupdated array:\n [[0\\. 0\\. 0.]\n [1\\. 1\\. 1.]\n [0\\. 0\\. 0.]] \n```", "```py\nprint(\"original array unchanged:\\n\", jax_array) \n```", "```py\noriginal array unchanged:\n [[0\\. 0\\. 0.]\n [0\\. 0\\. 0.]\n [0\\. 0\\. 0.]] \n```", "```py\nprint(\"original array:\")\njax_array = jnp.ones((5, 6))\nprint(jax_array)\n\nnew_jax_array = jax_array.at[::2, 3:].add(7.)\nprint(\"new array post-addition:\")\nprint(new_jax_array) \n```", "```py\noriginal array:\n[[1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]]\nnew array post-addition:\n[[1\\. 1\\. 1\\. 8\\. 8\\. 8.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 8\\. 8\\. 8.]\n [1\\. 1\\. 1\\. 1\\. 1\\. 1.]\n [1\\. 1\\. 1\\. 8\\. 8\\. 8.]] \n```", "```py\nnp.arange(10)[11] \n```", "```py\nIndexError: index 11 is out of bounds for axis 0 with size 10 \n```", "```py\njnp.arange(10)[11] \n```", "```py\nArray(9, dtype=int32) \n```", "```py\njnp.arange(10.0).at[11].get() \n```", "```py\nArray(9., dtype=float32) \n```", "```py\njnp.arange(10.0).at[11].get(mode='fill', fill_value=jnp.nan) \n```", "```py\nArray(nan, dtype=float32) \n```", "```py\nnp.sum([1, 2, 3]) \n```", "```py\nnp.int64(6) \n```", "```py\njnp.sum([1, 2, 3]) \n```", "```py\nTypeError: sum requires ndarray or scalar arguments, got <class 'list'> at position 0. \n```", "```py\ndef permissive_sum(x):\n  return jnp.sum(jnp.array(x))\n\nx = list(range(10))\npermissive_sum(x) \n```", "```py\nArray(45, dtype=int32) \n```", "```py\nmake_jaxpr(permissive_sum)(x) \n```", "```py\n{ lambda ; a:i32[] b:i32[] c:i32[] d:i32[] e:i32[] f:i32[] g:i32[] h:i32[] i:i32[]\n    j:i32[]. let\n    k:i32[] = convert_element_type[new_dtype=int32 weak_type=False] a\n    l:i32[] = convert_element_type[new_dtype=int32 weak_type=False] b\n    m:i32[] = convert_element_type[new_dtype=int32 weak_type=False] c\n    n:i32[] = convert_element_type[new_dtype=int32 weak_type=False] d\n    o:i32[] = convert_element_type[new_dtype=int32 weak_type=False] e\n    p:i32[] = convert_element_type[new_dtype=int32 weak_type=False] f\n    q:i32[] = convert_element_type[new_dtype=int32 weak_type=False] g\n    r:i32[] = convert_element_type[new_dtype=int32 weak_type=False] h\n    s:i32[] = convert_element_type[new_dtype=int32 weak_type=False] i\n    t:i32[] = convert_element_type[new_dtype=int32 weak_type=False] j\n    u:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] k\n    v:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] l\n    w:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] m\n    x:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] n\n    y:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] o\n    z:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] p\n    ba:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] q\n    bb:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] r\n    bc:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] s\n    bd:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] t\n    be:i32[10] = concatenate[dimension=0] u v w x y z ba bb bc bd\n    bf:i32[] = reduce_sum[axes=(0,)] be\n  in (bf,) } \n```", "```py\njnp.sum(jnp.array(x)) \n```", "```py\nArray(45, dtype=int32) \n```", "```py\nprint(np.random.random())\nprint(np.random.random())\nprint(np.random.random()) \n```", "```py\n0.9818293835329528\n0.06574727326903418\n0.3930007618911092 \n```", "```py\nnp.random.seed(0)\nrng_state = np.random.get_state()\n# print(rng_state)\n# --> ('MT19937', array([0, 1, 1812433255, 1900727105, 1208447044,\n#       2481403966, 4042607538,  337614300, ... 614 more numbers...,\n#       3048484911, 1796872496], dtype=uint32), 624, 0, 0.0) \n```", "```py\n_ = np.random.uniform()\nrng_state = np.random.get_state()\n#print(rng_state)\n# --> ('MT19937', array([2443250962, 1093594115, 1878467924,\n#       ..., 2648828502, 1678096082], dtype=uint32), 2, 0, 0.0)\n\n# Let's exhaust the entropy in this PRNG statevector\nfor i in range(311):\n  _ = np.random.uniform()\nrng_state = np.random.get_state()\n#print(rng_state)\n# --> ('MT19937', array([2443250962, 1093594115, 1878467924,\n#       ..., 2648828502, 1678096082], dtype=uint32), 624, 0, 0.0)\n\n# Next call iterates the RNG state for a new batch of fake \"entropy\".\n_ = np.random.uniform()\nrng_state = np.random.get_state()\n# print(rng_state)\n# --> ('MT19937', array([1499117434, 2949980591, 2242547484,\n#      4162027047, 3277342478], dtype=uint32), 2, 0, 0.0) \n```", "```py\nfrom jax import random\nkey = random.key(0)\nkey \n```", "```py\nArray((), dtype=key<fry>) overlaying:\n[0 0] \n```", "```py\nprint(random.normal(key, shape=(1,)))\nprint(key)\n# No no no!\nprint(random.normal(key, shape=(1,)))\nprint(key) \n```", "```py\n[-0.20584226]\nArray((), dtype=key<fry>) overlaying:\n[0 0]\n[-0.20584226]\nArray((), dtype=key<fry>) overlaying:\n[0 0] \n```", "```py\nprint(\"old key\", key)\nkey, subkey = random.split(key)\nnormal_pseudorandom = random.normal(subkey, shape=(1,))\nprint(\"    \\---SPLIT --> new key   \", key)\nprint(\"             \\--> new subkey\", subkey, \"--> normal\", normal_pseudorandom) \n```", "```py\nold key Array((), dtype=key<fry>) overlaying:\n[0 0]\n    \\---SPLIT --> new key    Array((), dtype=key<fry>) overlaying:\n[4146024105  967050713]\n             \\--> new subkey Array((), dtype=key<fry>) overlaying:\n[2718843009 1272950319] --> normal [-1.2515389] \n```", "```py\nprint(\"old key\", key)\nkey, subkey = random.split(key)\nnormal_pseudorandom = random.normal(subkey, shape=(1,))\nprint(\"    \\---SPLIT --> new key   \", key)\nprint(\"             \\--> new subkey\", subkey, \"--> normal\", normal_pseudorandom) \n```", "```py\nold key Array((), dtype=key<fry>) overlaying:\n[4146024105  967050713]\n    \\---SPLIT --> new key    Array((), dtype=key<fry>) overlaying:\n[2384771982 3928867769]\n             \\--> new subkey Array((), dtype=key<fry>) overlaying:\n[1278412471 2182328957] --> normal [-0.58665055] \n```", "```py\nkey, *subkeys = random.split(key, 4)\nfor subkey in subkeys:\n  print(random.normal(subkey, shape=(1,))) \n```", "```py\n[-0.37533438]\n[0.98645043]\n[0.14553197] \n```", "```py\ndef f(x):\n  if x < 3:\n    return 3. * x ** 2\n  else:\n    return -4 * x\n\nprint(grad(f)(2.))  # ok!\nprint(grad(f)(4.))  # ok! \n```", "```py\n12.0\n-4.0 \n```", "```py\n@jit\ndef f(x):\n  for i in range(3):\n    x = 2 * x\n  return x\n\nprint(f(3)) \n```", "```py\n24 \n```", "```py\n@jit\ndef g(x):\n  y = 0.\n  for i in range(x.shape[0]):\n    y = y + x[i]\n  return y\n\nprint(g(jnp.array([1., 2., 3.]))) \n```", "```py\n6.0 \n```", "```py\n@jit\ndef f(x):\n  if x < 3:\n    return 3. * x ** 2\n  else:\n    return -4 * x\n\n# This will fail!\nf(2) \n```", "```py\nTracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..\nThe error occurred while tracing the function f at /tmp/ipykernel_1227/3402096563.py:1 for jit. This concrete value was not available in Python because it depends on the value of the argument x.\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError \n```", "```py\ndef f(x):\n  if x < 3:\n    return 3. * x ** 2\n  else:\n    return -4 * x\n\nf = jit(f, static_argnums=(0,))\n\nprint(f(2.)) \n```", "```py\n12.0 \n```", "```py\ndef f(x, n):\n  y = 0.\n  for i in range(n):\n    y = y + x[i]\n  return y\n\nf = jit(f, static_argnums=(1,))\n\nf(jnp.array([2., 3., 4.]), 2) \n```", "```py\nArray(5., dtype=float32) \n```", "```py\ndef example_fun(length, val):\n  return jnp.ones((length,)) * val\n# un-jit'd works fine\nprint(example_fun(5, 4)) \n```", "```py\n[4\\. 4\\. 4\\. 4\\. 4.] \n```", "```py\nbad_example_jit = jit(example_fun)\n# this will fail:\nbad_example_jit(10, 4) \n```", "```py\nTypeError: Shapes must be 1D sequences of concrete values of integer type, got (Traced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>,).\nIf using `jit`, try using `static_argnums` or applying `jit` to smaller subfunctions.\nThe error occurred while tracing the function example_fun at /tmp/ipykernel_1227/1210496444.py:1 for jit. This concrete value was not available in Python because it depends on the value of the argument length. \n```", "```py\n# static_argnums tells JAX to recompile on changes at these argument positions:\ngood_example_jit = jit(example_fun, static_argnums=(0,))\n# first compile\nprint(good_example_jit(10, 4))\n# recompiles\nprint(good_example_jit(5, 4)) \n```", "```py\n[4\\. 4\\. 4\\. 4\\. 4\\. 4\\. 4\\. 4\\. 4\\. 4.]\n[4\\. 4\\. 4\\. 4\\. 4.] \n```", "```py\n@jit\ndef f(x):\n  print(x)\n  y = 2 * x\n  print(y)\n  return y\nf(2) \n```", "```py\nTraced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>\nTraced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)> \n```", "```py\nArray(4, dtype=int32, weak_type=True) \n```", "```py\ndef cond(pred, true_fun, false_fun, operand):\n  if pred:\n    return true_fun(operand)\n  else:\n    return false_fun(operand) \n```", "```py\nfrom jax import lax\n\noperand = jnp.array([0.])\nlax.cond(True, lambda x: x+1, lambda x: x-1, operand)\n# --> array([1.], dtype=float32)\nlax.cond(False, lambda x: x+1, lambda x: x-1, operand)\n# --> array([-1.], dtype=float32) \n```", "```py\nArray([-1.], dtype=float32) \n```", "```py\ndef while_loop(cond_fun, body_fun, init_val):\n  val = init_val\n  while cond_fun(val):\n    val = body_fun(val)\n  return val \n```", "```py\ninit_val = 0\ncond_fun = lambda x: x<10\nbody_fun = lambda x: x+1\nlax.while_loop(cond_fun, body_fun, init_val)\n# --> array(10, dtype=int32) \n```", "```py\nArray(10, dtype=int32, weak_type=True) \n```", "```py\ndef fori_loop(start, stop, body_fun, init_val):\n  val = init_val\n  for i in range(start, stop):\n    val = body_fun(i, val)\n  return val \n```", "```py\ninit_val = 0\nstart = 0\nstop = 10\nbody_fun = lambda i,x: x+i\nlax.fori_loop(start, stop, body_fun, init_val)\n# --> array(45, dtype=int32) \n```", "```py\nArray(45, dtype=int32, weak_type=True) \n```", "```py\ndef nansum(x):\n  mask = ~jnp.isnan(x)  # boolean mask selecting non-nan values\n  x_without_nans = x[mask]\n  return x_without_nans.sum() \n```", "```py\nx = jnp.array([1, 2, jnp.nan, 3, 4])\nprint(nansum(x)) \n```", "```py\n10.0 \n```", "```py\njax.jit(nansum)(x) \n```", "```py\nNonConcreteBooleanIndexError: Array boolean indices must be concrete; got ShapedArray(bool[5])\n\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.NonConcreteBooleanIndexError \n```", "```py\n@jax.jit\ndef nansum_2(x):\n  mask = ~jnp.isnan(x)  # boolean mask selecting non-nan values\n  return jnp.where(mask, x, 0).sum()\n\nprint(nansum_2(x)) \n```", "```py\n10.0 \n```", "```py\nIn [1]: import jax.numpy as jnp\n\nIn [2]: jnp.divide(0., 0.)\n---------------------------------------------------------------------------\nFloatingPointError                        Traceback (most recent call last)\n<ipython-input-2-f2e2c413b437> in <module>()\n----> 1 jnp.divide(0., 0.)\n\n.../jax/jax/numpy/lax_numpy.pyc in divide(x1, x2)\n    343     return floor_divide(x1, x2)\n    344   else:\n--> 345     return true_divide(x1, x2)\n    346\n    347\n\n.../jax/jax/numpy/lax_numpy.pyc in true_divide(x1, x2)\n    332   x1, x2 = _promote_shapes(x1, x2)\n    333   return lax.div(lax.convert_element_type(x1, result_dtype),\n--> 334                  lax.convert_element_type(x2, result_dtype))\n    335\n    336\n\n.../jax/jax/lax.pyc in div(x, y)\n    244 def div(x, y):\n    245   r\"\"\"Elementwise division: :math:`x \\over y`.\"\"\"\n--> 246   return div_p.bind(x, y)\n    247\n    248 def rem(x, y):\n\n... stack trace ...\n\n.../jax/jax/interpreters/xla.pyc in handle_result(device_buffer)\n    103         py_val = device_buffer.to_py()\n    104         if np.any(np.isnan(py_val)):\n--> 105           raise FloatingPointError(\"invalid value\")\n    106         else:\n    107           return Array(device_buffer, *result_shape)\n\nFloatingPointError: invalid value \n```", "```py\nIn [4]: from jax import jit\n\nIn [5]: @jit\n   ...: def f(x, y):\n   ...:     a = x * y\n   ...:     b = (x + y) / (x - y)\n   ...:     c = a + 2\n   ...:     return a + b * c\n   ...:\n\nIn [6]: x = jnp.array([2., 0.])\n\nIn [7]: y = jnp.array([3., 0.])\n\nIn [8]: f(x, y)\nInvalid value encountered in the output of a jit function. Calling the de-optimized version.\n---------------------------------------------------------------------------\nFloatingPointError                        Traceback (most recent call last)\n<ipython-input-8-811b7ddb3300> in <module>()\n----> 1 f(x, y)\n\n ... stack trace ...\n\n<ipython-input-5-619b39acbaac> in f(x, y)\n      2 def f(x, y):\n      3     a = x * y\n----> 4     b = (x + y) / (x - y)\n      5     c = a + 2\n      6     return a + b * c\n\n.../jax/jax/numpy/lax_numpy.pyc in divide(x1, x2)\n    343     return floor_divide(x1, x2)\n    344   else:\n--> 345     return true_divide(x1, x2)\n    346\n    347\n\n.../jax/jax/numpy/lax_numpy.pyc in true_divide(x1, x2)\n    332   x1, x2 = _promote_shapes(x1, x2)\n    333   return lax.div(lax.convert_element_type(x1, result_dtype),\n--> 334                  lax.convert_element_type(x2, result_dtype))\n    335\n    336\n\n.../jax/jax/lax.pyc in div(x, y)\n    244 def div(x, y):\n    245   r\"\"\"Elementwise division: :math:`x \\over y`.\"\"\"\n--> 246   return div_p.bind(x, y)\n    247\n    248 def rem(x, y):\n\n ... stack trace ... \n```", "```py\nx = random.uniform(random.key(0), (1000,), dtype=jnp.float64)\nx.dtype \n```", "```py\n/tmp/ipykernel_1227/1258726447.py:1: UserWarning: Explicitly requested dtype <class 'jax.numpy.float64'>  is not available, and will be truncated to dtype float32\\. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/google/jax#current-gotchas for more.\n  x = random.uniform(random.key(0), (1000,), dtype=jnp.float64) \n```", "```py\ndtype('float32') \n```", "```py\n    # again, this only works on startup!\n    import jax\n    jax.config.update(\"jax_enable_x64\", True) \n    ```", "```py\n    import jax\n    jax.config.config_with_absl() \n    ```", "```py\n    import jax\n    if __name__ == '__main__':\n      # calls jax.config.config_with_absl() *and* runs absl parsing\n      jax.config.parse_flags_with_absl() \n    ```", "```py\nimport jax.numpy as jnp\nfrom jax import random\nx = random.uniform(random.key(0), (1000,), dtype=jnp.float64)\nx.dtype # --> dtype('float64') \n```", "```py\n/tmp/ipykernel_1227/2819792939.py:3: UserWarning: Explicitly requested dtype <class 'jax.numpy.float64'>  is not available, and will be truncated to dtype float32\\. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/google/jax#current-gotchas for more.\n  x = random.uniform(random.key(0), (1000,), dtype=jnp.float64) \n```", "```py\ndtype('float32') \n```", "```py\n    >>> np.arange(254.0, 258.0).astype('uint8')\n    array([254, 255,   0,   1], dtype=uint8)\n\n    >>> jnp.arange(254.0, 258.0).astype('uint8')\n    Array([254, 255, 255, 255], dtype=uint8) \n    ```"]