- en: jax.random module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jax.random.html`](https://jax.readthedocs.io/en/latest/jax.random.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Utilities for pseudo-random number generation.
  prefs: []
  type: TYPE_NORMAL
- en: The `jax.random` package provides a number of routines for deterministic generation
    of sequences of pseudorandom numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: PRNG keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the *stateful* pseudorandom number generators (PRNGs) that users of
    NumPy and SciPy may be accustomed to, JAX random functions all require an explicit
    PRNG state to be passed as a first argument. The random state is described by
    a special array element type that we call a **key**, usually generated by the
    `jax.random.key()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This key can then be used in any of JAX’s random number generation routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that using a key does not modify it, so reusing the same key will lead
    to the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a new random number, you can use `jax.random.split()` to generate
    new subkeys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Typed key arrays, with element types such as `key<fry>` above, were introduced
    in JAX v0.4.16\. Before then, keys were conventionally represented in `uint32`
    arrays, whose final dimension represented the key’s bit-level representation.
  prefs: []
  type: TYPE_NORMAL
- en: Both forms of key array can still be created and used with the `jax.random`
    module. New-style typed key arrays are made with `jax.random.key()`. Legacy `uint32`
    key arrays are made with `jax.random.PRNGKey()`.
  prefs: []
  type: TYPE_NORMAL
- en: To convert between the two, use `jax.random.key_data()` and `jax.random.wrap_key_data()`.
    The legacy key format may be needed when interfacing with systems outside of JAX
    (e.g. exporting arrays to a serializable format), or when passing keys to JAX-based
    libraries that assume the legacy format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, typed keys are recommended. Caveats of legacy keys relative to typed
    ones include:'
  prefs: []
  type: TYPE_NORMAL
- en: They have an extra trailing dimension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a numeric dtype (`uint32`), allowing for operations that are typically
    not meant to be carried out over keys, such as integer arithmetic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not carry information about the RNG implementation. When legacy keys
    are passed to `jax.random` functions, a global configuration setting determines
    the RNG implementation (see “Advanced RNG configuration” below).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about this upgrade, and the design of key types, see [JEP 9263](https://jax.readthedocs.io/en/latest/jep/9263-typed-keys.html).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design and background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TLDR**: JAX PRNG = [Threefry counter PRNG](http://www.thesalmons.org/john/random123/papers/random123sc11.pdf)
    + a functional array-oriented [splitting model](https://dl.acm.org/citation.cfm?id=2503784)'
  prefs: []
  type: TYPE_NORMAL
- en: See [docs/jep/263-prng.md](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, among other requirements, the JAX PRNG aims to:'
  prefs: []
  type: TYPE_NORMAL
- en: ensure reproducibility,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: parallelize well, both in terms of vectorization (generating array values) and
    multi-replica, multi-core computation. In particular it should not use sequencing
    constraints between random function calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced RNG configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX provides several PRNG implementations. A specific one can be selected with
    the optional impl keyword argument to jax.random.key. When no impl option is passed
    to the key constructor, the implementation is determined by the global jax_default_prng_impl
    configuration flag.
  prefs: []
  type: TYPE_NORMAL
- en: '**default**, “threefry2x32”: [A counter-based PRNG built around the Threefry
    hash function](http://www.thesalmons.org/john/random123/papers/random123sc11.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*experimental* A PRNG that thinly wraps the XLA Random Bit Generator (RBG)
    algorithm. See [TF doc](https://www.tensorflow.org/xla/operation_semantics#rngbitgenerator).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “rbg” uses ThreeFry for splitting, and XLA RBG for data generation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: “unsafe_rbg” exists only for demonstration purposes, using RBG both for splitting
    (using an untested made up algorithm) and generating.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The random streams generated by these experimental implementations haven’t been
    subject to any empirical randomness testing (e.g. Big Crush). The random bits
    generated may change between JAX versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The possible reasons not use the default RNG are:'
  prefs: []
  type: TYPE_NORMAL
- en: it may be slow to compile (specifically for Google Cloud TPUs)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it’s slower to execute on TPUs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it doesn’t support efficient automatic sharding / partitioning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a short summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Threefry | Threefry* | rbg | unsafe_rbg | rbg** | unsafe_rbg**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fastest on TPU |  |  | ✅ | ✅ | ✅ | ✅ |'
  prefs: []
  type: TYPE_TB
- en: '| efficiently shardable (w/ pjit) |  | ✅ |  |  | ✅ | ✅ |'
  prefs: []
  type: TYPE_TB
- en: '| identical across shardings | ✅ | ✅ | ✅ | ✅ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| identical across CPU/GPU/TPU | ✅ | ✅ |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| identical across JAX/XLA versions | ✅ | ✅ |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '(*): with `jax_threefry_partitionable=1` set'
  prefs: []
  type: TYPE_NORMAL
- en: '(**): with `XLA_FLAGS=--xla_tpu_spmd_rng_bit_generator_unsafe=1` set'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between “rbg” and “unsafe_rbg” is that while “rbg” uses a less
    robust/studied hash function for random value generation (but not for jax.random.split
    or jax.random.fold_in), “unsafe_rbg” additionally uses less robust hash functions
    for jax.random.split and jax.random.fold_in. Therefore less safe in the sense
    that the quality of random streams it generates from different keys is less well
    understood.
  prefs: []
  type: TYPE_NORMAL
- en: For more about jax_threefry_partitionable, see [`jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html#generating-random-numbers`](https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html#generating-random-numbers)
  prefs: []
  type: TYPE_NORMAL
- en: API Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Key Creation & Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| `PRNGKey`(seed, *[, impl]) | Create a pseudo-random number generator (PRNG)
    key given an integer seed. |'
  prefs: []
  type: TYPE_TB
- en: '| `key`(seed, *[, impl]) | Create a pseudo-random number generator (PRNG) key
    given an integer seed. |'
  prefs: []
  type: TYPE_TB
- en: '| `key_data`(keys) | Recover the bits of key data underlying a PRNG key array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wrap_key_data`(key_bits_array, *[, impl]) | Wrap an array of key data bits
    into a PRNG key array. |'
  prefs: []
  type: TYPE_TB
- en: '| `fold_in`(key, data) | Folds in data to a PRNG key to form a new PRNG key.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `split`(key[, num]) | Splits a PRNG key into num new keys by adding a leading
    axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `clone`(key) | Clone a key for reuse |'
  prefs: []
  type: TYPE_TB
- en: Random Samplers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| `ball`(key, d[, p, shape, dtype]) | Sample uniformly from the unit Lp ball.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bernoulli`(key[, p, shape]) | Sample Bernoulli random values with given
    shape and mean. |'
  prefs: []
  type: TYPE_TB
- en: '| `beta`(key, a, b[, shape, dtype]) | Sample Beta random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `binomial`(key, n, p[, shape, dtype]) | Sample Binomial random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `bits`(key[, shape, dtype]) | Sample uniform bits in the form of unsigned
    integers. |'
  prefs: []
  type: TYPE_TB
- en: '| `categorical`(key, logits[, axis, shape]) | Sample random values from categorical
    distributions. |'
  prefs: []
  type: TYPE_TB
- en: '| `cauchy`(key[, shape, dtype]) | Sample Cauchy random values with given shape
    and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `chisquare`(key, df[, shape, dtype]) | Sample Chisquare random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `choice`(key, a[, shape, replace, p, axis]) | Generates a random sample from
    a given array. |'
  prefs: []
  type: TYPE_TB
- en: '| `dirichlet`(key, alpha[, shape, dtype]) | Sample Dirichlet random values
    with given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `double_sided_maxwell`(key, loc, scale[, ...]) | Sample from a double sided
    Maxwell distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `exponential`(key[, shape, dtype]) | Sample Exponential random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `f`(key, dfnum, dfden[, shape, dtype]) | Sample F-distribution random values
    with given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `gamma`(key, a[, shape, dtype]) | Sample Gamma random values with given shape
    and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `generalized_normal`(key, p[, shape, dtype]) | Sample from the generalized
    normal distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `geometric`(key, p[, shape, dtype]) | Sample Geometric random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `gumbel`(key[, shape, dtype]) | Sample Gumbel random values with given shape
    and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `laplace`(key[, shape, dtype]) | Sample Laplace random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `loggamma`(key, a[, shape, dtype]) | Sample log-gamma random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `logistic`(key[, shape, dtype]) | Sample logistic random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `lognormal`(key[, sigma, shape, dtype]) | Sample lognormal random values
    with given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxwell`(key[, shape, dtype]) | Sample from a one sided Maxwell distribution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `multivariate_normal`(key, mean, cov[, shape, ...]) | Sample multivariate
    normal random values with given mean and covariance. |'
  prefs: []
  type: TYPE_TB
- en: '| `normal`(key[, shape, dtype]) | Sample standard normal random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `orthogonal`(key, n[, shape, dtype]) | Sample uniformly from the orthogonal
    group O(n). |'
  prefs: []
  type: TYPE_TB
- en: '| `pareto`(key, b[, shape, dtype]) | Sample Pareto random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `permutation`(key, x[, axis, independent]) | Returns a randomly permuted
    array or range. |'
  prefs: []
  type: TYPE_TB
- en: '| `poisson`(key, lam[, shape, dtype]) | Sample Poisson random values with given
    shape and integer dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `rademacher`(key[, shape, dtype]) | Sample from a Rademacher distribution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `randint`(key, shape, minval, maxval[, dtype]) | Sample uniform random values
    in minval, maxval) with given shape/dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rayleigh`(key, scale[, shape, dtype]) | Sample Rayleigh random values with
    given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `t`(key, df[, shape, dtype]) | Sample Student''s t random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `triangular`(key, left, mode, right[, shape, ...]) | Sample Triangular random
    values with given shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `truncated_normal`(key, lower, upper[, shape, ...]) | Sample truncated standard
    normal random values with given shape and dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform`(key[, shape, dtype, minval, maxval]) | Sample uniform random values
    in minval, maxval) with given shape/dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| [`wald`(key, mean[, shape, dtype]) | Sample Wald random values with given
    shape and float dtype. |'
  prefs: []
  type: TYPE_TB
- en: '| `weibull_min`(key, scale, concentration[, ...]) | Sample from a Weibull distribution.
    |'
  prefs: []
  type: TYPE_TB
