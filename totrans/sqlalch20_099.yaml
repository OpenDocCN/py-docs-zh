- en: Working with Engines and Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/connections.html](https://docs.sqlalchemy.org/en/20/core/connections.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section details direct usage of the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    and related objects. Its important to note that when using the SQLAlchemy ORM,
    these objects are not generally accessed; instead, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object is used as the interface to the database. However,
    for applications that are built around direct usage of textual SQL statements
    and/or SQL expression constructs without involvement by the ORM’s higher level
    management services, the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    are king (and queen?) - read on.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from [Engine Configuration](engines.html) that an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is created via the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The typical usage of [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is once per particular database URL, held globally
    for the lifetime of a single application process. A single [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") manages many individual [DBAPI](../glossary.html#term-DBAPI)
    connections on behalf of the process and is intended to be called upon in a concurrent
    fashion. The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is **not** synonymous to the DBAPI `connect()` function, which represents just
    one connection resource - the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is most efficient when created just once at the module level of an application,
    not per-object or per-function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic function of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is to provide access to a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    which can then invoke SQL statements. To emit a textual statement to the database
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    method returns a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object, and by using it in a Python context manager (e.g. the `with:` statement)
    the [`Connection.close()`](#sqlalchemy.engine.Connection.close "sqlalchemy.engine.Connection.close")
    method is automatically invoked at the end of the block. The [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), is a **proxy** object for an actual DBAPI connection.
    The DBAPI connection is retrieved from the connection pool at the point at which
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is known as [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult"), which references a DBAPI cursor and provides
    methods for fetching rows similar to that of the DBAPI cursor. The DBAPI cursor
    will be closed by the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    when all of its result rows (if any) are exhausted. A [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") that returns no rows, such as that of an UPDATE
    statement (without any returned rows), releases cursor resources immediately upon
    construction.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is closed at the end of the `with:` block, the referenced DBAPI connection is
    [released](../glossary.html#term-released) to the connection pool. From the perspective
    of the database itself, the connection pool will not actually “close” the connection
    assuming the pool has room to store this connection for the next use. When the
    connection is returned to the pool for re-use, the pooling mechanism issues a
    `rollback()` call on the DBAPI connection so that any transactional state or locks
    are removed (this is known as [Reset On Return](pooling.html#pool-reset-on-return)),
    and the connection is ready for its next use.
  prefs: []
  type: TYPE_NORMAL
- en: Our example above illustrated the execution of a textual SQL string, which should
    be invoked by using the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct to indicate that we’d like to use
    textual SQL. The [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method can of course accommodate more
    than that; see [Working with Data](../tutorial/data.html#tutorial-working-with-data)
    in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)
    for a tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Using Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section describes how to use transactions when working directly with [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects. When using the SQLAlchemy ORM, the public API for transaction control
    is via the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object, which makes usage of the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object internally. See [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Commit As You Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object always emits SQL statements within the context of a transaction block.
    The first time the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method is called to execute a SQL statement,
    this transaction is begun automatically, using a behavior known as **autobegin**.
    The transaction remains in place for the scope of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object until the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods are called. Subsequent to the
    transaction ending, the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    waits for the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute "sqlalchemy.engine.Connection.execute")
    method to be called again, at which point it autobegins again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This calling style is known as **commit as you go**, and is illustrated in
    the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In “commit as you go” style, we can call upon [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods freely within an ongoing sequence
    of other statements emitted using [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"); each time the transaction is ended, and
    a new statement is emitted, a new transaction begins implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: “commit as you go” style is a new feature of SQLAlchemy
    2.0\. It is also available in SQLAlchemy 1.4’s “transitional” mode when using
    a “future” style engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Begin Once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object provides a more explicit transaction management style known as **begin
    once**. In contrast to “commit as you go”, “begin once” allows the start point
    of the transaction to be stated explicitly, and allows that the transaction itself
    may be framed out as a context manager block so that the end of the transaction
    is instead implicit. To use “begin once”, the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is used, which returns a [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object which represents the DBAPI transaction.
    This object also supports explicit management via its own [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") and [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") methods, but as a preferred practice
    also supports the context manager interface, where it will commit itself when
    the block ends normally and emit a rollback if an exception is raised, before
    propagating the exception outwards. Below illustrates the form of a “begin once”
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Connect and Begin Once from the Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A convenient shorthand form for the above “begin once” block is to use the
    [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    method at the level of the originating [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, rather than performing the two separate steps of [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") and [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"); the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method returns a special context manager that
    internally maintains both the context manager for the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the context manager for the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") normally returned by the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    block, we can call upon the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which will end the transaction
    normally demarcated by the block ahead of time. However, if we do so, no further
    SQL operations may be emitted on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") until the block ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Mixing Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “commit as you go” and “begin once” styles can be freely mixed within a
    single [`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    block, provided that the call to [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") does not conflict with the “autobegin” behavior.
    To accomplish this, [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") should only be called either before any
    SQL statements have been emitted, or directly after a previous call to [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When developing code that uses “begin once”, the library will raise [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if a transaction was already “autobegun”.
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting Transaction Isolation Levels including DBAPI Autocommit'
  prefs: []
  type: TYPE_NORMAL
- en: Most DBAPIs support the concept of configurable transaction [isolation](../glossary.html#term-isolation)
    levels. These are traditionally the four levels “READ UNCOMMITTED”, “READ COMMITTED”,
    “REPEATABLE READ” and “SERIALIZABLE”. These are usually applied to a DBAPI connection
    before it begins a new transaction, noting that most DBAPIs will begin this transaction
    implicitly when SQL statements are first emitted.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that support isolation levels also usually support the concept of true
    “autocommit”, which means that the DBAPI connection itself will be placed into
    a non-transactional autocommit mode. This usually means that the typical DBAPI
    behavior of emitting “BEGIN” to the database automatically no longer occurs, but
    it may also include other directives. SQLAlchemy treats the concept of “autocommit”
    like any other isolation level; in that it is an isolation level that loses not
    only “read committed” but also loses atomicity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, as will be discussed further in the section below at
    [Understanding the DBAPI-Level Autocommit Isolation Level](#dbapi-autocommit-understanding),
    that “autocommit” isolation level like any other isolation level does **not**
    affect the “transactional” behavior of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, which continues to call upon DBAPI `.commit()`
    and `.rollback()` methods (they just have no effect under autocommit), and for
    which the `.begin()` method assumes the DBAPI will start a transaction implicitly
    (which means that SQLAlchemy’s “begin” **does not change autocommit mode**).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy dialects should support these isolation levels as well as autocommit
    to as great a degree as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for a Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object that’s acquired from [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect"), the isolation level can be set for the duration
    of that [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method. The parameter is known
    as [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") and the values are strings which
    are typically a subset of the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not every DBAPI supports every value; if an unsupported value is used for a
    certain backend, an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to force REPEATABLE READ on a specific connection, then begin
    a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method is the same [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object upon which the method was called, meaning,
    it modifies the state of the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object in place. This is a new behavior as of SQLAlchemy 2.0. This behavior does
    not apply to the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method; that method still returns
    a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and as described below may be used to construct multiple [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects with different execution options, which nonetheless
    share the same dialect and connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter necessarily does not
    apply to statement level options, such as that of [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), and will be rejected
    if set at this level. This because the option must be set on a DBAPI connection
    on a per-transaction basis.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for an Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") option may also be set engine
    wide, as is often preferable. This may be achieved by passing the [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter to `create_engine()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, each new DBAPI connection the moment it’s created will
    be set to use a `"REPEATABLE READ"` isolation level setting for all subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Maintaining Multiple Isolation Levels for a Single Engine'
  prefs: []
  type: TYPE_NORMAL
- en: 'The isolation level may also be set per engine, with a potentially greater
    level of flexibility, using either the [`create_engine.execution_options`](engines.html#sqlalchemy.create_engine.params.execution_options
    "sqlalchemy.create_engine") parameter to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") or the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, the latter of which will
    create a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that shares the dialect and connection pool of the original engine, but has its
    own per-connection isolation level setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, the DBAPI connection will be set to use a `"REPEATABLE
    READ"` isolation level setting for each new transaction begun; but the connection
    as pooled will be reset to the original isolation level that was present when
    the connection first occurred. At the level of [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), the end effect is not any different from using the
    [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an application that frequently chooses to run operations within different
    isolation levels may wish to create multiple “sub-engines” of a lead [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), each of which will be configured to a different isolation
    level. One such use case is an application that has operations that break into
    “transactional” and “read-only” operations, a separate [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that makes use of `"AUTOCOMMIT"` may be separated
    off from the main engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method creates a shallow copy of
    the original [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    Both `eng` and `autocommit_engine` share the same dialect and connection pool.
    However, the “AUTOCOMMIT” mode will be set upon connections when they are acquired
    from the `autocommit_engine`.
  prefs: []
  type: TYPE_NORMAL
- en: The isolation level setting, regardless of which one it is, is unconditionally
    reverted when a connection is returned to the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Transaction Isolation](../dialects/sqlite.html#sqlite-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Transaction Isolation](../dialects/postgresql.html#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL Transaction Isolation](../dialects/mysql.html#mysql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Server Transaction Isolation](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Transaction Isolation](../dialects/oracle.html#oracle-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation)
    - for the ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect](../faq/connections.html#faq-execute-retry-autocommit)
    - a recipe that uses DBAPI autocommit to transparently reconnect to the database
    for read-only operations  ### Understanding the DBAPI-Level Autocommit Isolation
    Level'
  prefs: []
  type: TYPE_NORMAL
- en: In the parent section, we introduced the concept of the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter and how it can be
    used to set database isolation levels, including DBAPI-level “autocommit” which
    is treated by SQLAlchemy as another transaction isolation level. In this section
    we will attempt to clarify the implications of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to check out a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object and use it “autocommit” mode, we would proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Above illustrates normal usage of “DBAPI autocommit” mode. There is no need
    to make use of methods such as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") or [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit"), as all statements are committed to the
    database immediately. When the block ends, the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object will revert the “autocommit” isolation
    level, and the DBAPI connection is released to the connection pool where the DBAPI
    `connection.rollback()` method will normally be invoked, but as the above statements
    were already committed, this rollback has no change on the state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that “autocommit” mode persists even when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called; the DBAPI will not emit
    any BEGIN to the database, nor will it emit COMMIT when [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") is called. This usage is also not an error
    scenario, as it is expected that the “autocommit” isolation level may be applied
    to code that otherwise was written assuming a transactional context; the “isolation
    level” is, after all, a configurational detail of the transaction itself just
    like any other isolation level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, statements remain **autocommitting** regardless of SQLAlchemy-level
    transaction blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run a block like the above with logging turned on, the logging will
    attempt to indicate that while a DBAPI level `.commit()` is called, it probably
    will have no effect due to autocommit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, even though we are using “DBAPI autocommit”, SQLAlchemy’s
    transactional semantics, that is, the in-Python behavior of [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") as well as the behavior of “autobegin”,
    **remain in place, even though these don’t impact the DBAPI connection itself**.
    To illustrate, the code below will raise an error, as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") is being called after autobegin has already
    occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The above example also demonstrates the same theme that the “autocommit” isolation
    level is a configurational detail of the underlying database transaction, and
    is independent of the begin/commit behavior of the SQLAlchemy Connection object.
    The “autocommit” mode will not interact with [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") in any way and the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") does not consult this status when performing its
    own state changes with regards to the transaction (with the exception of suggesting
    within engine logging that these blocks are not actually committing). The rationale
    for this design is to maintain a completely consistent usage pattern with the
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") where
    DBAPI-autocommit mode can be changed independently without indicating any code
    changes elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Between Isolation Levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Isolation level settings, including autocommit mode, are reset automatically
    when the connection is released back to the connection pool. Therefore it is preferable
    to avoid trying to switch isolation levels on a single [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as this leads to excess verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use “autocommit” in an ad-hoc mode within the scope of
    a single [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkout, the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter must be re-applied
    with the previous isolation level. The previous section illustrated an attempt
    to call [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    in order to start a transaction while autocommit was taking place; we can rewrite
    that example to actually do so by first reverting the isolation level before we
    call upon [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Above, to manually revert the isolation level we made use of [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") to restore the default
    isolation level (assuming that’s what we want here). However, it’s probably a
    better idea to work with the architecture of of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which already handles resetting of isolation level
    automatically upon checkin. The **preferred** way to write the above is to use
    two blocks
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: “DBAPI level autocommit” isolation level is entirely independent of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object’s notion of “begin” and “commit”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'use individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkouts per isolation level. Avoid trying to change back and forth between “autocommit”
    on a single connection checkout; let the engine do the work of restoring default
    isolation levels  ## Using Server Side Cursors (a.k.a. stream results)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some backends feature explicit support for the concept of “server side cursors”
    versus “client side cursors”. A client side cursor here means that the database
    driver fully fetches all rows from a result set into memory before returning from
    a statement execution. Drivers such as those of PostgreSQL and MySQL/MariaDB generally
    use client side cursors by default. A server side cursor, by contrast, indicates
    that result rows remain pending within the database server’s state as result rows
    are consumed by the client. The drivers for Oracle generally use a “server side”
    model, for example, and the SQLite dialect, while not using a real “client / server”
    architecture, still uses an unbuffered result fetching approach that will leave
    result rows outside of process memory before they are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: From this basic architecture it follows that a “server side cursor” is more
    memory efficient when fetching very large result sets, while at the same time
    may introduce more complexity in the client/server communication process and be
    less efficient for small result sets (typically less than 10000 rows).
  prefs: []
  type: TYPE_NORMAL
- en: For those dialects that have conditional support for buffered or unbuffered
    results, there are usually caveats to the use of the “unbuffered”, or server side
    cursor mode. When using the psycopg2 dialect for example, an error is raised if
    a server side cursor is used with any kind of DML or DDL statement. When using
    MySQL drivers with a server side cursor, the DBAPI connection is in a more fragile
    state and does not recover as gracefully from error conditions nor will it allow
    a rollback to proceed until the cursor is fully closed.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, SQLAlchemy’s dialects will always default to the less error
    prone version of a cursor, which means for PostgreSQL and MySQL dialects it defaults
    to a buffered, “client side” cursor where the full set of results is pulled into
    memory before any fetch methods are called from the cursor. This mode of operation
    is appropriate in the **vast majority** of cases; unbuffered cursors are not generally
    useful except in the uncommon case of an application fetching a very large number
    of rows in chunks, where the processing of these rows can be complete before more
    rows are fetched.
  prefs: []
  type: TYPE_NORMAL
- en: For database drivers that provide client and server side cursor options, the
    [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") and [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution options provide access
    to “server side cursors” on a per-[`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or per-statement basis. Similar options exist
    when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming with a fixed buffer via yield_per
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As individual row-fetch operations with fully unbuffered server side cursors
    are typically more expensive than fetching batches of rows at once, The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option configures
    a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or statement to make use of server-side cursors as are available, while at the
    same time configuring a fixed-size buffer of rows that will retrieve rows from
    the server in batches as they are consumed. This parameter may be to a positive
    integer value using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method on [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or on a statement using the [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core-only option is new
    as of SQLAlchemy 1.4.40; for prior 1.4 versions, use [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") directly in combination with
    [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this option is equivalent to manually setting the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option, described in the next
    section, and then invoking the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method on the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object with the given integer value. In both cases,
    the effect this combination has includes:'
  prefs: []
  type: TYPE_NORMAL
- en: server side cursors mode is selected for the given backend, if available and
    not already the default behavior for that backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as result rows are fetched, they will be buffered in batches, where the size
    of each batch up until the last batch will be equal to the integer argument passed
    to the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option or the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method; the last batch is then sized against
    the remaining rows fewer than this size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default partition size used by the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method, if used, will be made equal to
    this integer size as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three behaviors are illustrated in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The above example illustrates the combination of `yield_per=100` along with
    using the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method to run processing on rows in batches that match the size fetched from the
    server. The use of [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") is optional, and if the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is iterated directly, a new batch of rows will be
    buffered for each 100 rows fetched. Calling a method such as [`Result.all()`](#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all") should **not** be used, as this will fully fetch
    all remaining rows at once and defeat the purpose of using `yield_per`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    may be used as a context manager as illustrated above. When iterating with a server-side
    cursor, this is the best way to ensure the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object is closed, even if exceptions are raised within
    the iteration process.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option is portable to the ORM
    as well, used by a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to fetch ORM objects, where it also limits the amount
    of ORM objects generated at once. See the section [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per) - in the
    [ORM Querying Guide](../orm/queryguide/index.html) for further background on using
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core level execution option
    to conveniently set streaming results, buffer size, and partition size all at
    once in a manner that is transferrable to that of the ORM’s similar use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Streaming with a dynamically growing buffer using stream_results'
  prefs: []
  type: TYPE_NORMAL
- en: To enable server side cursors without a specific partition size, the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be used, which like
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") may be called on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object or the statement object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    delivered using the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option is iterated directly,
    rows are fetched internally using a default buffering scheme that buffers first
    a small set of rows, then a larger and larger buffer on each fetch up to a pre-configured
    limit of 1000 rows. The maximum size of this buffer can be affected using the
    [`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options") execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be combined with
    use of the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method, a specific partition size should be passed to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") so that the entire result is not fetched.
    It is usually more straightforward to use the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option when setting up to use
    the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")  ##
    Translation of Schema Names'
  prefs: []
  type: TYPE_NORMAL
- en: To support multi-tenancy applications that distribute common sets of tables
    into multiple schemas, the [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") execution option may be used
    to repurpose a set of [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects to render under different schema names without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The “schema” of this [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    as defined by the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") attribute is `None`. The [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") can specify that all [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects with a schema of `None` would instead render
    the schema as `user_schema_one`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code will invoke SQL on the database of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the schema name is substituted with our translated name. The map can
    specify any number of target->destination schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") parameter affects all DDL and
    SQL constructs generated from the SQL expression language, as derived from the
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") or
    [`Sequence`](defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    objects. It does **not** impact literal string SQL used via the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct nor via plain strings passed to [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute").
  prefs: []
  type: TYPE_NORMAL
- en: The feature takes effect **only** in those cases where the name of the schema
    is derived directly from that of a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or [`Sequence`](defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"); it does not impact methods where a string schema
    name is passed directly. By this pattern, it takes effect within the “can create”
    / “can drop” checks performed by methods such as [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") are called, and it takes effect when using
    table reflection given a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object. However it does **not** affect the operations present on the [`Inspector`](reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object, as the schema name is passed
    to these methods explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the schema translation feature with the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), set this option at the level of the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then pass that engine to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") uses a new [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for each transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without extensions, the schema translate feature is
    only supported as **a single schema translate map per Session**. It will **not
    work** if different schema translate maps are given on a per-statement basis,
    as the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    does not take current schema translate values into account for individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a single [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with multiple `schema_translate_map` configurations,
    the [Horizontal Sharding](../orm/extensions/horizontal_shard.html) extension may
    be used. See the example at [Horizontal Sharding](../orm/examples.html#examples-sharding).  ##
    SQL Compilation Caching'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: SQLAlchemy now has a transparent query caching system that
    substantially lowers the Python computational overhead involved in converting
    SQL statement constructs into SQL strings across both Core and ORM. See the introduction
    at [Transparent SQL Compilation Caching added to All DQL, DML Statements in Core,
    ORM](../changelog/migration_14.html#change-4639).'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy includes a comprehensive caching system for the SQL compiler as
    well as its ORM variants. This caching system is transparent within the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and provides that the SQL compilation process for
    a given Core or ORM SQL statement, as well as related computations which assemble
    result-fetching mechanics for that statement, will only occur once for that statement
    object and all others with the identical structure, for the duration that the
    particular structure remains within the engine’s “compiled cache”. By “statement
    objects that have the identical structure”, this generally corresponds to a SQL
    statement that is constructed within a function and is built each time that function
    runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The above statement will generate SQL resembling `SELECT id, col FROM table
    WHERE col = :col ORDER BY id`, noting that while the value of `parameter` is a
    plain Python object such as a string or an integer, the string SQL form of the
    statement does not include this value as it uses bound parameters. Subsequent
    invocations of the above `run_my_statement()` function will use a cached compilation
    construct within the scope of the `connection.execute()` call for enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: it is important to note that the SQL compilation cache is caching the **SQL
    string that is passed to the database only**, and **not the data** returned by
    a query. It is in no way a data cache and does not impact the results returned
    for a particular SQL statement nor does it imply any memory use linked to fetching
    of result rows.
  prefs: []
  type: TYPE_NORMAL
- en: While SQLAlchemy has had a rudimentary statement cache since the early 1.x series,
    and additionally has featured the “Baked Query” extension for the ORM, both of
    these systems required a high degree of special API use in order for the cache
    to be effective. The new cache as of 1.4 is instead completely automatic and requires
    no change in programming style to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: The cache is automatically used without any configurational changes and no special
    steps are needed in order to enable it. The following sections detail the configuration
    and advanced usage patterns for the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The cache itself is a dictionary-like object called an `LRUCache`, which is
    an internal SQLAlchemy dictionary subclass that tracks the usage of particular
    keys and features a periodic “pruning” step which removes the least recently used
    items when the size of the cache reaches a certain threshold. The size of this
    cache defaults to 500 and may be configured using the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The size of the cache can grow to be a factor of 150% of the size given, before
    it’s pruned back down to the target size. A cache of size 1200 above can therefore
    grow to be 1800 elements in size at which point it will be pruned to 1200.
  prefs: []
  type: TYPE_NORMAL
- en: The sizing of the cache is based on a single entry per unique SQL statement
    rendered, per engine. SQL statements generated from both the Core and the ORM
    are treated equally. DDL statements will usually not be cached. In order to determine
    what the cache is doing, engine logging will include details about the cache’s
    behavior, described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '### Estimating Cache Performance Using Logging'
  prefs: []
  type: TYPE_NORMAL
- en: The above cache size of 1200 is actually fairly large. For small applications,
    a size of 100 is likely sufficient. To estimate the optimal size of the cache,
    assuming enough memory is present on the target host, the size of the cache should
    be based on the number of unique SQL strings that may be rendered for the target
    engine in use. The most expedient way to see this is to use SQL echoing, which
    is most directly enabled by using the [`create_engine.echo`](engines.html#sqlalchemy.create_engine.params.echo
    "sqlalchemy.create_engine") flag, or by using Python logging; see the section
    [Configuring Logging](engines.html#dbengine-logging) for background on logging
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will examine the logging produced by the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, each SQL statement that’s logged will include a bracketed cache statistics
    badge to the left of the parameters passed. The four types of message we may see
    are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[raw sql]` - the driver or the end-user emitted raw SQL using [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") - caching does not apply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[no key]` - the statement object is a DDL statement that is not cached, or
    the statement object contains uncacheable elements such as user-defined constructs
    or arbitrarily large VALUES clauses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[generated in Xs]` - the statement was a **cache miss** and had to be compiled,
    then stored in the cache. it took X seconds to produce the compiled construct.
    The number X will be in the small fractional seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[cached since Xs ago]` - the statement was a **cache hit** and did not have
    to be recompiled. The statement has been stored in the cache since X seconds ago.
    The number X will be proportional to how long the application has been running
    and how long the statement has been cached, so for example would be 86400 for
    a 24 hour period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each badge is described in more detail below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first statements we see for the above program will be the SQLite dialect
    checking for the existence of the “a” and “b” tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For the above two SQLite PRAGMA statements, the badge reads `[raw sql]`, which
    indicates the driver is sending a Python string directly to the database using
    [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql"). Caching does not apply to such
    statements because they already exist in string form, and there is nothing known
    about what kinds of result rows will be returned since SQLAlchemy does not parse
    SQL strings ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statements we see are the CREATE TABLE statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For each of these statements, the badge reads `[no key 0.00006s]`. This indicates
    that these two particular statements, caching did not occur because the DDL-oriented
    [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable")
    construct did not produce a cache key. DDL constructs generally do not participate
    in caching because they are not typically subject to being repeated a second time
    and DDL is also a database configurational step where performance is not as critical.
  prefs: []
  type: TYPE_NORMAL
- en: The `[no key]` badge is important for one other reason, as it can be produced
    for SQL statements that are cacheable except for some particular sub-construct
    that is not currently cacheable. Examples of this include custom user-defined
    SQL elements that don’t define caching parameters, as well as some constructs
    that generate arbitrarily long and non-reproducible SQL strings, the main examples
    being the [`Values`](selectable.html#sqlalchemy.sql.expression.Values "sqlalchemy.sql.expression.Values")
    construct as well as when using “multivalued inserts” with the [`Insert.values()`](dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far our cache is still empty. The next statements will be cached however,
    a segment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see essentially two unique SQL strings; `"INSERT INTO a (data) VALUES
    (?)"` and `"INSERT INTO b (a_id, data) VALUES (?, ?)"`. Since SQLAlchemy uses
    bound parameters for all literal values, even though these statements are repeated
    many times for different objects, because the parameters are separate, the actual
    SQL string stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: the above two statements are generated by the ORM unit of work process, and
    in fact will be caching these in a separate cache that is local to each mapper.
    However the mechanics and terminology are the same. The section [Disabling or
    using an alternate dictionary to cache some (or all) statements](#engine-compiled-cache)
    below will describe how user-facing code can also use an alternate caching container
    on a per-statement basis.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge we see for the first occurrence of each of these two statements
    is `[generated in 0.00011s]`. This indicates that the statement was **not in the
    cache, was compiled into a String in .00011s and was then cached**. When we see
    the `[generated]` badge, we know that this means there was a **cache miss**. This
    is to be expected for the first occurrence of a particular statement. However,
    if lots of new `[generated]` badges are observed for a long-running application
    that is generally using the same series of SQL statements over and over, this
    may be a sign that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter is too small. When a statement that was
    cached is then evicted from the cache due to the LRU cache pruning lesser used
    items, it will display the `[generated]` badge when it is next used.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge that we then see for the subsequent occurrences of each of
    these two statements looks like `[cached since 0.0003533s ago]`. This indicates
    that the statement **was found in the cache, and was originally placed into the
    cache .0003533 seconds ago**. It is important to note that while the `[generated]`
    and `[cached since]` badges refer to a number of seconds, they mean different
    things; in the case of `[generated]`, the number is a rough timing of how long
    it took to compile the statement, and will be an extremely small amount of time.
    In the case of `[cached since]`, this is the total time that a statement has been
    present in the cache. For an application that’s been running for six hours, this
    number may read `[cached since 21600 seconds ago]`, and that’s a good thing. Seeing
    high numbers for “cached since” is an indication that these statements have not
    been subject to cache misses for a long time. Statements that frequently have
    a low number of “cached since” even if the application has been running a long
    time may indicate these statements are too frequently subject to cache misses,
    and that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") may need to be increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example program then performs some SELECTs where we can see the same pattern
    of “generated” then “cached”, for the SELECT of the “a” table as well as for subsequent
    lazy loads of the “b” table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From our above program, a full run shows a total of four distinct SQL strings
    being cached. Which indicates a cache size of **four** would be sufficient. This
    is obviously an extremely small size, and the default size of 500 is fine to be
    left at its default.
  prefs: []
  type: TYPE_NORMAL
- en: How much memory does the cache use?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section detailed some techniques to check if the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") needs to be bigger. How do we know if the cache is
    not too large? The reason we may want to set [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") to not be higher than a certain number would be because
    we have an application that may make use of a very large number of different statements,
    such as an application that is building queries on the fly from a search UX, and
    we don’t want our host to run out of memory if for example, a hundred thousand
    different queries were run in the past 24 hours and they were all cached.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely difficult to measure how much memory is occupied by Python data
    structures, however using a process to measure growth in memory via `top` as a
    successive series of 250 new statements are added to the cache suggest a moderate
    Core statement takes up about 12K while a small ORM statement takes about 20K,
    including result-fetching structures which for the ORM will be much greater.
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling or using an alternate dictionary to cache some (or all) statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal cache used is known as `LRUCache`, but this is mostly just a dictionary.
    Any dictionary may be used as a cache for any series of statements by using the
    [`Connection.execution_options.compiled_cache`](#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") option as an execution option.
    Execution options may be set on a statement, on an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    as well as when using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method for SQLAlchemy-2.0 style invocations.
    For example, to run a series of SQL statements and have them cached in a particular
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The SQLAlchemy ORM uses the above technique to hold onto per-mapper caches within
    the unit of work “flush” process that are separate from the default cache configured
    on the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), as well
    as for some relationship loader queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache can also be disabled with this argument by sending a value of `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]  ### Caching for Third Party Dialects'
  prefs: []
  type: TYPE_NORMAL
- en: The caching feature requires that the dialect’s compiler produces SQL strings
    that are safe to reuse for many statement invocations, given a particular cache
    key that is keyed to that SQL string. This means that any literal values in a
    statement, such as the LIMIT/OFFSET values for a SELECT, can not be hardcoded
    in the dialect’s compilation scheme, as the compiled string will not be re-usable.
    SQLAlchemy supports rendered bound parameters using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method which
    can be applied to the existing `Select._limit_clause` and `Select._offset_clause`
    attributes by a custom compiler, which are illustrated later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As there are many third party dialects, many of which may be generating literal
    values from SQL statements without the benefit of the newer “literal execute”
    feature, SQLAlchemy as of version 1.4.5 has added an attribute to dialects known
    as [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache"). This attribute is checked
    at runtime for its presence directly on a particular dialect’s class, even if
    it’s already present on a superclass, so that even a third party dialect that
    subclasses an existing cacheable SQLAlchemy dialect such as `sqlalchemy.dialects.postgresql.PGDialect`
    must still explicitly include this attribute for caching to be enabled. The attribute
    should **only** be enabled once the dialect has been altered as needed and tested
    for reusability of compiled SQL statements with differing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For all third party dialects that don’t support this attribute, the logging
    for such a dialect will indicate `dialect does not support caching`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a dialect has been tested against caching, and in particular the SQL compiler
    has been updated to not render any literal LIMIT / OFFSET within a SQL string
    directly, dialect authors can apply the attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag needs to be applied to all subclasses of the dialect as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.5: Added the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The typical case for dialect modification follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Rendering LIMIT / OFFSET with post compile parameters'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, suppose a dialect overrides the `SQLCompiler.limit_clause()`
    method, which produces the “LIMIT / OFFSET” clause for a SQL statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The above routine renders the `Select._limit` and `Select._offset` integer values
    as literal integers embedded in the SQL statement. This is a common requirement
    for databases that do not support using a bound parameter within the LIMIT/OFFSET
    clauses of a SELECT statement. However, rendering the integer value within the
    initial compilation stage is directly **incompatible** with caching as the limit
    and offset integer values of a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object are not part of the cache key, so that
    many [`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statements with different limit/offset values would not render with the correct
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction for the above code is to move the literal integer into SQLAlchemy’s
    [post-compile](../changelog/migration_14.html#change-4808) facility, which will
    render the literal integer outside of the initial compilation stage, but instead
    at execution time before the statement is sent to the DBAPI. This is accessed
    within the compilation stage using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method, in conjunction
    with using the `Select._limit_clause` and `Select._offset_clause` attributes,
    which represent the LIMIT/OFFSET as a complete SQL expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach above will generate a compiled SELECT statement that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `__[POSTCOMPILE_param_1]` and `__[POSTCOMPILE_param_2]` indicators
    will be populated with their corresponding integer values at statement execution
    time, after the SQL string has been retrieved from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: After changes like the above have been made as appropriate, the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") flag should be set to `True`.
    It is strongly recommended that third party dialects make use of the [dialect
    third party test suite](https://github.com/sqlalchemy/sqlalchemy/blob/main/README.dialects.rst)
    which will assert that operations like SELECTs with LIMIT/OFFSET are correctly
    rendered and cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](../faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](../faq/index.html) section  ### Using Lambdas
    to add significant speed gains to statement production'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Alchemy
  prefs: []
  type: TYPE_NORMAL
- en: This technique is generally non-essential except in very performance intensive
    scenarios, and intended for experienced Python programmers. While fairly straightforward,
    it involves metaprogramming concepts that are not appropriate for novice Python
    developers. The lambda approach can be applied to at a later time to existing
    code with a minimal amount of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Python functions, typically expressed as lambdas, may be used to generate SQL
    expressions which are cacheable based on the Python code location of the lambda
    function itself as well as the closure variables within the lambda. The rationale
    is to allow caching of not only the SQL string-compiled form of a SQL expression
    construct as is SQLAlchemy’s normal behavior when the lambda system isn’t used,
    but also the in-Python composition of the SQL expression construct itself, which
    also has some degree of Python overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda SQL expression feature is available as a performance enhancing feature,
    and is also optionally used in the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") ORM option in order to provide a generic
    SQL fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lambda statements are constructed using the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") function, which returns an instance of
    [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement"), which is itself an executable
    statement construct. Additional modifiers and criteria are added to the object
    using the Python addition operator `+`, or alternatively the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method which
    allows for more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is assumed that the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") construct is being invoked within an
    enclosing function or method that expects to be used many times within an application,
    so that subsequent executions beyond the first one can take advantage of the compiled
    SQL being cached. When the lambda is constructed inside of an enclosing function
    in Python it is then subject to also having closure variables, which are significant
    to the whole approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Above, the three `lambda` callables that are used to define the structure of
    a SELECT statement are invoked exactly once, and the resulting SQL string cached
    in the compilation cache of the engine. From that point forward, the `run_my_statement()`
    function may be invoked any number of times and the `lambda` callables within
    it will not be called, only used as cache keys to retrieve the already-compiled
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is already SQL caching in place when the
    lambda system is not used. The lambda system only adds an additional layer of
    work reduction per SQL statement invoked by caching the building up of the SQL
    construct itself and also using a simpler cache key.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Guidelines for Lambdas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Above all, the emphasis within the lambda SQL system is ensuring that there
    is never a mismatch between the cache key generated for a lambda and the SQL string
    it will produce. The [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") and related objects will run and analyze
    the given lambda in order to calculate how it should be cached on each run, trying
    to detect any potential problems. Basic guidelines include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any kind of statement is supported** - while it’s expected that [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are the prime use case for [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt"), DML statements such as [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") and [`update()`](dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") are equally usable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**ORM use cases directly supported as well** - the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") can accommodate ORM functionality completely
    and used directly with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bound parameters are automatically accommodated** - in contrast to SQLAlchemy’s
    previous “baked query” system, the lambda SQL system accommodates for Python literal
    values which become SQL bound parameters automatically. This means that even though
    a given lambda runs only once, the values that become bound parameters are extracted
    from the **closure** of the lambda on every run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above, [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") extracted the values of `x`
    and `y` from the **closure** of the lambda that is generated each time `my_stmt()`
    is invoked; these were substituted into the cached SQL construct as the values
    of the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The lambda should ideally produce an identical SQL structure in all cases**
    - Avoid using conditionals or custom callables inside of lambdas that might make
    it produce different SQL based on inputs; if a function might conditionally use
    two different SQL fragments, use two separate lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a variety of failures which can occur if the lambda does not produce
    a consistent SQL construct and some are not trivially detectable right now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Don’t use functions inside the lambda to produce bound values** - the bound
    value tracking approach requires that the actual value to be used in the SQL statement
    be locally present in the closure of the lambda. This is not possible if values
    are generated from other functions, and the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") should normally raise an error if this
    is attempted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above, the use of `get_x()` and `get_y()`, if they are necessary, should occur
    **outside** of the lambda and assigned to a local closure variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Avoid referring to non-SQL constructs inside of lambdas as they are not cacheable
    by default** - this issue refers to how the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") creates a cache key from other closure
    variables within the statement. In order to provide the best guarantee of an accurate
    cache key, all objects located in the closure of the lambda are considered to
    be significant, and none will be assumed to be appropriate for a cache key by
    default. So the following example will also raise a rather detailed error message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above error indicates that [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") will not assume that the `Foo` object
    passed in will continue to behave the same in all cases. It also won’t assume
    it can use `Foo` as part of the cache key by default; if it were to use the `Foo`
    object as part of the cache key, if there were many different `Foo` objects this
    would fill up the cache with duplicate information, and would also hold long-lasting
    references to all of these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The best way to resolve the above situation is to not refer to `foo` inside
    of the lambda, and refer to it **outside** instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In some situations, if the SQL structure of the lambda is guaranteed to never
    change based on input, to pass `track_closure_variables=False` which will disable
    any tracking of closure variables other than those used for bound parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also the option to add objects to the element to explicitly form part
    of the cache key, using the `track_on` parameter; using this parameter allows
    specific values to serve as the cache key and will also prevent other closure
    variables from being considered. This is useful for cases where part of the SQL
    being constructed originates from a contextual object of some sort that may have
    many different values. In the example below, the first segment of the SELECT statement
    will disable tracking of the `foo` variable, whereas the second segment will explicitly
    track `self` as part of the cache key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `track_on` means the given objects will be stored long term in the lambda’s
    internal cache and will have strong references for as long as the cache doesn’t
    clear out those objects (an LRU scheme of 1000 entries is used by default).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cache Key Generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand some of the options and behaviors which occur with lambda
    SQL constructs, an understanding of the caching system is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s caching system normally generates a cache key from a given SQL
    expression construct by producing a structure that represents all the state within
    the construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The above key is stored in the cache which is essentially a dictionary, and
    the value is a construct that among other things stores the string form of the
    SQL statement, in this case the phrase “SELECT q”. We can observe that even for
    an extremely short query the cache key is pretty verbose as it has to represent
    everything that may vary about what’s being rendered and potentially executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda construction system by contrast creates a different kind of cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see a cache key that is vastly shorter than that of the non-lambda
    statement, and additionally that production of the `select(column("q"))` construct
    itself was not even necessary; the Python lambda itself contains an attribute
    called `__code__` which refers to a Python code object that within the runtime
    of the application is immutable and permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the lambda also includes closure variables, in the normal case that these
    variables refer to SQL constructs such as column objects, they become part of
    the cache key, or if they refer to literal values that will be bound parameters,
    they are placed in a separate element of the cache key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") includes two lambdas, both
    of which refer to the `col` closure variable, so the cache key will represent
    both of these segments as well as the `column()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the cache key has retrieved the bound parameters that will
    be used when the statement is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For a series of examples of “lambda” caching with performance comparisons,
    see the “short_selects” test suite within the [Performance](../orm/examples.html#examples-performance)
    performance example.  ## “Insert Many Values” Behavior for INSERT statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: see [Optimized ORM bulk insert now implemented for all
    backends other than MySQL](../changelog/whatsnew_20.html#change-6047) for background
    on the change including sample performance tests'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [insertmanyvalues](../glossary.html#term-insertmanyvalues) feature is a
    **transparently available** performance feature which requires no end-user intervention
    in order for it to take place as needed. This section describes the architecture
    of the feature as well as how to measure its performance and tune its behavior
    in order to optimize the speed of bulk INSERT statements, particularly as used
    by the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: As more databases have added support for INSERT..RETURNING, SQLAlchemy has undergone
    a major change in how it approaches the subject of INSERT statements where there’s
    a need to acquire server-generated values, most importantly server-generated primary
    key values which allow the new row to be referenced in subsequent operations.
    In particular, this scenario has long been a significant performance issue in
    the ORM, which relies on being able to retrieve server-generated primary key values
    in order to correctly populate the [identity map](../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: With recent support for RETURNING added to SQLite and MariaDB, SQLAlchemy no
    longer needs to rely upon the single-row-only [cursor.lastrowid](https://peps.python.org/pep-0249/#lastrowid)
    attribute provided by the [DBAPI](../glossary.html#term-DBAPI) for most backends;
    RETURNING may now be used for all [SQLAlchemy-included](../dialects/index.html#included-dialects)
    backends with the exception of MySQL. The remaining performance limitation, that
    the [cursor.executemany()](https://peps.python.org/pep-0249/#executemany) DBAPI
    method does not allow for rows to be fetched, is resolved for most backends by
    foregoing the use of `executemany()` and instead restructuring individual INSERT
    statements to each accommodate a large number of rows in a single statement that
    is invoked using `cursor.execute()`. This approach originates from the [psycopg2
    fast execution helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    feature of the `psycopg2` DBAPI, which SQLAlchemy incrementally added more and
    more support towards in recent release series.
  prefs: []
  type: TYPE_NORMAL
- en: Current Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The feature is enabled for all backend included in SQLAlchemy that support RETURNING,
    with the exception of Oracle for which both the cx_Oracle and OracleDB drivers
    offer their own equivalent feature. The feature normally takes place when making
    use of the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method of an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in conjunction with [executemany](../glossary.html#term-executemany)
    execution, which occurs when passing a list of dictionaries to the [`Connection.execute.parameters`](#sqlalchemy.engine.Connection.execute.params.parameters
    "sqlalchemy.engine.Connection.execute") parameter of the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") methods (as well as equivalent methods under
    [asyncio](../orm/extensions/asyncio.html) and shorthand methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")). It also takes place within the ORM [unit of
    work](../glossary.html#term-unit-of-work) process when using methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") to add rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLAlchemy’s included dialects, support or equivalent support is currently
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - supported for SQLite versions 3.35 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - all supported Postgresql versions (9 and above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server - all supported SQL Server versions [[1]](#id2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB - supported for MariaDB versions 10.5 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL - no support, no RETURNING feature is present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - supports RETURNING with executemany using native cx_Oracle / OracleDB
    APIs, for all supported Oracle versions 9 and above, using multi-row OUT parameters.
    This is not the same implementation as “executemanyvalues”, however has the same
    usage patterns and equivalent performance benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To disable the “insertmanyvalues” feature for a given backend for an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") overall, pass the [`create_engine.use_insertmanyvalues`](engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") parameter as `False` to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature can also be disabled from being used implicitly for a particular
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    by passing the [`Table.implicit_returning`](metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The reason one might want to disable RETURNING for a specific table is to work
    around backend-specific limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Batched Mode Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The feature has two modes of operation, which are selected transparently on
    a per-dialect, per-[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    basis. One is **batched mode**, which reduces the number of database round trips
    by rewriting an INSERT statement of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'into a “batched” form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: where above, the statement is organized against a subset (a “batch”) of the
    input data, the size of which is determined by the database backend as well as
    the number of parameters in each batch to correspond to known limits for statement
    size / number of parameters. The feature then executes the INSERT statement once
    for each batch of input data until all records are consumed, concatenating the
    RETURNING results for each batch into a single large rowset that’s available from
    a single [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: This “batched” form allows INSERT of many rows using much fewer database round
    trips, and has been shown to allow dramatic performance improvements for most
    backends where it’s supported.
  prefs: []
  type: TYPE_NORMAL
- en: '### Correlating RETURNING rows to parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.10.
  prefs: []
  type: TYPE_NORMAL
- en: The “batch” mode query illustrated in the previous section does not guarantee
    the order of records returned would correspond with that of the input data. When
    used by the SQLAlchemy ORM [unit of work](../glossary.html#term-unit-of-work)
    process, as well as for applications which correlate returned server-generated
    values with input data, the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and [`UpdateBase.return_defaults()`](dml.html#sqlalchemy.sql.expression.UpdateBase.return_defaults
    "sqlalchemy.sql.expression.UpdateBase.return_defaults") methods include an option
    [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which indicates that “insertmanyvalues”
    mode should guarantee this correspondence. This is **not related** to the order
    in which records are actually INSERTed by the database backend, which is **not**
    assumed under any circumstances; only that the returned records should be organized
    when received back to correspond to the order in which the original input data
    was passed.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter is present, for tables
    that use server-generated integer primary key values such as `IDENTITY`, PostgreSQL
    `SERIAL`, MariaDB `AUTO_INCREMENT`, or SQLite’s `ROWID` scheme, “batch” mode may
    instead opt to use a more complex INSERT..RETURNING form, in conjunction with
    post-execution sorting of rows based on the returned values, or if such a form
    is not available, the “insertmanyvalues” feature may gracefully degrade to “non-batched”
    mode which runs individual INSERT statements for each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on SQL Server when an auto incrementing `IDENTITY` column is used
    as the primary key, the following SQL form is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A similar form is used for PostgreSQL as well, when primary key columns use
    SERIAL or IDENTITY. The above form **does not** guarantee the order in which rows
    are inserted. However, it does guarantee that the IDENTITY or SERIAL values will
    be created in order with each parameter set [[2]](#id5). The “insertmanyvalues”
    feature then sorts the returned rows for the above INSERT statement by incrementing
    integer identity.
  prefs: []
  type: TYPE_NORMAL
- en: For the SQLite database, there is no appropriate INSERT form that can correlate
    the production of new ROWID values with the order in which the parameter sets
    are passed. As a result, when using server-generated primary key values, the SQLite
    backend will degrade to “non-batched” mode when ordered RETURNING is requested.
    For MariaDB, the default INSERT form used by insertmanyvalues is sufficient, as
    this database backend will line up the order of AUTO_INCREMENT with the order
    of input data when using InnoDB [[3]](#id6).
  prefs: []
  type: TYPE_NORMAL
- en: For a client-side generated primary key, such as when using the Python `uuid.uuid4()`
    function to generate new values for a [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column, the “insertmanyvalues” feature transparently
    includes this column in the RETURNING records and correlates its value to that
    of the given input records, thus maintaining correspondence between input records
    and result rows. From this, it follows that all backends allow for batched, parameter-correlated
    RETURNING order when client-side-generated primary key values are used.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of how “insertmanyvalues” “batch” mode determines a column or columns
    to use as a point of correspondence between input parameters and RETURNING rows
    is known as an [insert sentinel](../glossary.html#term-insert-sentinel), which
    is a specific column or columns that are used to track such values. The “insert
    sentinel” is normally selected automatically, however can also be user-configuration
    for extremely special cases; the section [Configuring Sentinel Columns](#engine-insertmanyvalues-sentinel-columns)
    describes this.
  prefs: []
  type: TYPE_NORMAL
- en: For backends that do not offer an appropriate INSERT form that can deliver server-generated
    values deterministically aligned with input values, or for [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") configurations that feature other kinds of server generated
    primary key values, “insertmanyvalues” mode will make use of **non-batched** mode
    when guaranteed RETURNING ordering is requested.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft SQL Server rationale
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: “INSERT queries that use SELECT with ORDER BY to populate rows guarantees how
    identity values are computed but not the order in which the rows are inserted.”
    [https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions](https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PostgreSQL batched INSERT Discussion
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Original description in 2018 [https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us](https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Follow up in 2023 - [https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com](https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MariaDB AUTO_INCREMENT behavior (using the same InnoDB engine as MySQL):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://dba.stackexchange.com/a/72099](https://dba.stackexchange.com/a/72099)  ###
    Non-Batched Mode Operation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    configurations that do not have client side primary key values, and offer server-generated
    primary key values (or no primary key) that the database in question is not able
    to invoke in a deterministic or sortable way relative to multiple parameter sets,
    the “insertmanyvalues” feature when tasked with satisfying the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") requirement for an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement may instead opt to use **non-batched
    mode**.
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, the original SQL form of INSERT is maintained, and the “insertmanyvalues”
    feature will instead run the statement as given for each parameter set individually,
    organizing the returned rows into a full result set. Unlike previous SQLAlchemy
    versions, it does so in a tight loop that minimizes Python overhead. In some cases,
    such as on SQLite, “non-batched” mode performs exactly as well as “batched” mode.
  prefs: []
  type: TYPE_NORMAL
- en: Statement Execution Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For both “batched” and “non-batched” modes, the feature will necessarily invoke
    **multiple INSERT statements** using the DBAPI `cursor.execute()` method, within
    the scope of **single** call to the Core-level [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, with each statement containing
    up to a fixed limit of parameter sets. This limit is configurable as described
    below at [Controlling the Batch Size](#engine-insertmanyvalues-page-size). The
    separate calls to `cursor.execute()` are logged individually and also individually
    passed along to event listeners such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") (see [Logging and
    Events](#engine-insertmanyvalues-events) below).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Configuring Sentinel Columns'
  prefs: []
  type: TYPE_NORMAL
- en: In typical cases, the “insertmanyvalues” feature in order to provide INSERT..RETURNING
    with deterministic row order will automatically determine a sentinel column from
    a given table’s primary key, gracefully degrading to “row at a time” mode if one
    cannot be identified. As a completely **optional** feature, to get full “insertmanyvalues”
    bulk performance for tables that have server generated primary keys whose default
    generator functions aren’t compatible with the “sentinel” use case, other non-primary
    key columns may be marked as “sentinel” columns assuming they meet certain requirements.
    A typical example is a non-primary key [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column with a client side default such as the Python
    `uuid.uuid4()` function. There is also a construct to create simple integer columns
    with a a client side integer counter oriented towards the “insertmanyvalues” use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sentinel columns may be indicated by adding [`Column.insert_sentinel`](metadata.html#sqlalchemy.schema.Column.params.insert_sentinel
    "sqlalchemy.schema.Column") to qualifying columns. The most basic “qualifying”
    column is a not-nullable, unique column with a client side default, such as a
    UUID column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative models, the same forms are available using the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: While the values generated by the default generator **must** be unique, the
    actual UNIQUE constraint on the above “sentinel” column, indicated by the `unique=True`
    parameter, itself is optional and may be omitted if not desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a special form of “insert sentinel” that’s a dedicated nullable
    integer column which makes use of a special default integer counter that’s only
    used during “insertmanyvalues” operations; as an additional behavior, the column
    will omit itself from SQL statements and result sets and behave in a mostly transparent
    manner. It does need to be physically present within the actual database table,
    however. This style of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    may be constructed using the function [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative, a Declarative-friendly version of [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel") is available called [`orm_insert_sentinel()`](../orm/mapping_api.html#sqlalchemy.orm.orm_insert_sentinel
    "sqlalchemy.orm.orm_insert_sentinel"), which has the ability to be used on the
    Base class or a mixin; if packaged using [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"), the column will apply itself to all table-bound
    subclasses including within joined inheritance hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, both “my_table” and “sub_table” will have an additional
    integer column named “_sentinel” that can be used by the “insertmanyvalues” feature
    to help optimize bulk inserts used by the ORM.  ### Controlling the Batch Size'
  prefs: []
  type: TYPE_NORMAL
- en: A key characteristic of “insertmanyvalues” is that the size of the INSERT statement
    is limited on a fixed max number of “values” clauses as well as a dialect-specific
    fixed total number of bound parameters that may be represented in one INSERT statement
    at a time. When the number of parameter dictionaries given exceeds a fixed limit,
    or when the total number of bound parameters to be rendered in a single INSERT
    statement exceeds a fixed limit (the two fixed limits are separate), multiple
    INSERT statements will be invoked within the scope of a single [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") call, each of which accommodate for a
    portion of the parameter dictionaries, known as a “batch”. The number of parameter
    dictionaries represented within each “batch” is then known as the “batch size”.
    For example, a batch size of 500 means that each INSERT statement emitted will
    INSERT at most 500 rows.
  prefs: []
  type: TYPE_NORMAL
- en: It’s potentially important to be able to adjust the batch size, as a larger
    batch size may be more performant for an INSERT where the value sets themselves
    are relatively small, and a smaller batch size may be more appropriate for an
    INSERT that uses very large value sets, where both the size of the rendered SQL
    as well as the total data size being passed in one statement may benefit from
    being limited to a certain size based on backend behavior and memory constraints.
    For this reason the batch size can be configured on a per-[`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as well as a per-statement basis. The parameter limit
    on the other hand is fixed based on the known characteristics of the database
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: The batch size defaults to 1000 for most backends, with an additional per-dialect
    “max number of parameters” limiting factor that may reduce the batch size further
    on a per-statement basis. The max number of parameters varies by dialect and server
    version; the largest size is 32700 (chosen as a healthy distance away from PostgreSQL’s
    limit of 32767 and SQLite’s modern limit of 32766, while leaving room for additional
    parameters in the statement as well as for DBAPI quirkiness). Older versions of
    SQLite (prior to 3.32.0) will set this value to 999\. MariaDB has no established
    limit however 32700 remains as a limiting factor for SQL message size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the “batch size” can be affected [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") wide via the [`create_engine.insertmanyvalues_page_size`](engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter. Such as, to affect INSERT statements to
    include up to 100 parameter sets in each statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The batch size may also be affected on a per statement basis using the [`Connection.execution_options.insertmanyvalues_page_size`](#sqlalchemy.engine.Connection.execution_options.params.insertmanyvalues_page_size
    "sqlalchemy.engine.Connection.execution_options") execution option, such as per
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Or configured on the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]  ### Logging and Events'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “insertmanyvalues” feature integrates fully with SQLAlchemy’s [statement
    logging](engines.html#dbengine-logging) as well as cursor events such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute"). When the list of
    parameters is broken into separate batches, **each INSERT statement is logged
    and passed to event handlers individually**. This is a major change compared to
    how the psycopg2-only feature worked in previous 1.x series of SQLAlchemy, where
    the production of multiple INSERT statements was hidden from logging and events.
    Logging display will truncate the long lists of parameters for readability, and
    will also indicate the specific batch of each statement. The example below illustrates
    an excerpt of this logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When [non-batch mode](#engine-insertmanyvalues-non-batch) takes place, logging
    will indicate this along with the insertmanyvalues message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Logging](engines.html#dbengine-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Upsert Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The PostgreSQL, SQLite, and MariaDB dialects offer backend-specific “upsert”
    constructs [`insert()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert"), [`insert()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") and [`insert()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert"), which are each [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs that have an additional method
    such as `on_conflict_do_update()` or ``on_duplicate_key()`. These constructs also
    support “insertmanyvalues” behaviors when they are used with RETURNING, allowing
    efficient upserts with RETURNING to take place.  ## Engine Disposal'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") refers
    to a connection pool, which means under normal circumstances, there are open database
    connections present while the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object is still resident in memory. When an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is garbage collected, its connection pool is no longer
    referred to by that [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"),
    and assuming none of its connections are still checked out, the pool and its connections
    will also be garbage collected, which has the effect of closing out the actual
    database connections as well. But otherwise, the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") will hold onto open database connections assuming
    it uses the normally default pool implementation of [`QueuePool`](pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  prefs: []
  type: TYPE_NORMAL
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is intended
    to normally be a permanent fixture established up-front and maintained throughout
    the lifespan of an application. It is **not** intended to be created and disposed
    on a per-connection basis; it is instead a registry that maintains both a pool
    of connections as well as configurational information about the database and DBAPI
    in use, as well as some degree of internal caching of per-database resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many cases where it is desirable that all connection resources
    referred to by the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    be completely closed out. It’s generally not a good idea to rely on Python garbage
    collection for this to occur for these cases; instead, the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be explicitly disposed using the [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") method. This disposes of the engine’s underlying
    connection pool and replaces it with a new one that’s empty. Provided that the
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is discarded
    at this point and no longer used, all **checked-in** connections which it refers
    to will also be fully closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid use cases for calling [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") include:'
  prefs: []
  type: TYPE_NORMAL
- en: When a program wants to release any remaining checked-in connections held by
    the connection pool and expects to no longer be connected to that database at
    all for any future operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a program uses multiprocessing or `fork()`, and an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object is copied to the child process, [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") should be called so that the engine creates
    brand new database connections local to that fork. Database connections generally
    do **not** travel across process boundaries. Use the [`Engine.dispose.close`](#sqlalchemy.engine.Engine.dispose.params.close
    "sqlalchemy.engine.Engine.dispose") parameter set to False in this case. See the
    section [Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)
    for more background on this use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within test suites or multitenancy scenarios where many ad-hoc, short-lived
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") objects may be
    created and disposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connections that are **checked out** are **not** discarded when the engine is
    disposed or garbage collected, as these connections are still strongly referenced
    elsewhere by the application. However, after [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") is called, those connections are no longer
    associated with that [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine");
    when they are closed, they will be returned to their now-orphaned connection pool
    which will ultimately be garbage collected, once all connections which refer to
    it are also no longer referenced anywhere. Since this process is not easy to control,
    it is strongly recommended that [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") is called only after all checked out connections
    are checked in or otherwise de-associated from their pool.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative for applications that are negatively impacted by the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object’s use of connection pooling is to disable pooling
    entirely. This typically incurs only a modest performance impact upon the use
    of new connections, and means that when a connection is checked in, it is entirely
    closed out and is not held in memory. See [Switching Pool Implementations](pooling.html#pool-switching)
    for guidelines on how to disable pooling.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)  ##
    Working with Driver SQL and Raw DBAPI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The introduction on using [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") made use of the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct in order to illustrate how textual
    SQL statements may be invoked. When working with SQLAlchemy, textual SQL is actually
    more of the exception rather than the norm, as the Core expression language and
    the ORM both abstract away the textual representation of SQL. However, the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct itself also provides some abstraction
    of textual SQL in that it normalizes how bound parameters are passed, as well
    as that it supports datatyping behavior for parameters and result set rows.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking SQL strings directly to the driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the use case where one wants to invoke textual SQL directly passed to the
    underlying driver (known as the [DBAPI](../glossary.html#term-DBAPI)) without
    any intervention from the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: Added the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Working with the DBAPI cursor directly'
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where SQLAlchemy does not provide a genericized way at
    accessing some [DBAPI](../glossary.html#term-DBAPI) functions, such as calling
    stored procedures as well as dealing with multiple result sets. In these cases,
    it’s just as expedient to deal with the raw DBAPI connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to access the raw DBAPI connection is to get it from an
    already present [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object directly. It is present using the [`Connection.connection`](#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The DBAPI connection here is actually a “proxied” in terms of the originating
    connection pool, however this is an implementation detail that in most cases can
    be ignored. As this DBAPI connection is still contained within the scope of an
    owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object, it is best to make use of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object for most features such as transaction control
    as well as calling the [`Connection.close()`](#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") method; if these operations are performed
    on the DBAPI connection directly, the owning [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") will not be aware of these changes in state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the limitations imposed by the DBAPI connection that is maintained
    by an owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    a DBAPI connection is also available without the need to procure a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") first, using the [`Engine.raw_connection()`](#sqlalchemy.engine.Engine.raw_connection
    "sqlalchemy.engine.Engine.raw_connection") method of [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This DBAPI connection is again a “proxied” form as was the case before. The
    purpose of this proxying is now apparent, as when we call the `.close()` method
    of this connection, the DBAPI connection is typically not actually closed, but
    instead [released](../glossary.html#term-released) back to the engine’s connection
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: While SQLAlchemy may in the future add built-in patterns for more DBAPI use
    cases, there are diminishing returns as these cases tend to be rarely needed and
    they also vary highly dependent on the type of DBAPI in use, so in any case the
    direct DBAPI calling pattern is always there for those cases where it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I get at the raw DBAPI connection when using an Engine?](../faq/connections.html#faq-dbapi-connection)
    - includes additional details about how the DBAPI connection is accessed as well
    as the “driver” connection when using asyncio drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some recipes for DBAPI connection use follow.  ### Calling Stored Procedures
    and User Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports calling stored procedures and user defined functions several
    ways. Please note that all DBAPIs have different practices, so you must consult
    your underlying DBAPI’s documentation for specifics in relation to your particular
    usage. The following examples are hypothetical and may not work with your underlying
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For stored procedures or functions with special syntactical or parameter concerns,
    DBAPI-level [callproc](https://legacy.python.org/dev/peps/pep-0249/#callproc)
    may potentially be used with your DBAPI. An example of this pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all DBAPIs use callproc and overall usage details will vary. The above example
    is only an illustration of how it might look to use a particular DBAPI function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your DBAPI may not have a `callproc` requirement *or* may require a stored
    procedure or user defined function to be invoked with another pattern, such as
    normal SQLAlchemy connection usage. One example of this usage pattern is, *at
    the time of this documentation’s writing*, executing a stored procedure in the
    PostgreSQL database with the psycopg2 DBAPI, which should be invoked with normal
    connection usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This above example is hypothetical. The underlying database is not guaranteed
    to support “CALL” or “SELECT” in these situations, and the keyword may vary dependent
    on the function being a stored procedure or a user defined function. You should
    consult your underlying DBAPI and database documentation in these situations to
    determine the correct syntax and patterns to use.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Result Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiple result set support is available from a raw DBAPI cursor using the
    [nextset](https://legacy.python.org/dev/peps/pep-0249/#nextset) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Registering New Dialects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`create_engine()`](engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function call locates the given dialect using setuptools entrypoints. These entry
    points can be established for third party dialects within the setup.py script.
    For example, to create a new dialect “foodialect://”, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a package called `foodialect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package should have a module containing the dialect class, which is typically
    a subclass of [`sqlalchemy.engine.default.DefaultDialect`](internals.html#sqlalchemy.engine.default.DefaultDialect
    "sqlalchemy.engine.default.DefaultDialect"). In this example let’s say it’s called
    `FooDialect` and its module is accessed via `foodialect.dialect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The entry point can be established in `setup.cfg` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the dialect is providing support for a particular DBAPI on top of an existing
    SQLAlchemy-supported database, the name can be given including a database-qualification.
    For example, if `FooDialect` were in fact a MySQL dialect, the entry point could
    be established like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The above entrypoint would then be accessed as `create_engine("mysql+foodialect://")`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Dialects In-Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy also allows a dialect to be registered within the current process,
    bypassing the need for separate installation. Use the `register()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The above will respond to `create_engine("mysql+foodialect://")` and load the
    `MyMySQLDialect` class from the `myapp.dialect` module.
  prefs: []
  type: TYPE_NORMAL
- en: Connection / Engine API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Connection](#sqlalchemy.engine.Connection) | Provides high-level functionality
    for a wrapped DB-API connection. |'
  prefs: []
  type: TYPE_TB
- en: '| [CreateEnginePlugin](#sqlalchemy.engine.CreateEnginePlugin) | A set of hooks
    intended to augment the construction of an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object based on entrypoint names in a URL. |'
  prefs: []
  type: TYPE_TB
- en: '| [Engine](#sqlalchemy.engine.Engine) | Connects a [`Pool`](pooling.html#sqlalchemy.pool.Pool
    "sqlalchemy.pool.Pool") and [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect") together to provide a source of database
    connectivity and behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| [ExceptionContext](#sqlalchemy.engine.ExceptionContext) | Encapsulate information
    about an error condition in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| [NestedTransaction](#sqlalchemy.engine.NestedTransaction) | Represent a ‘nested’,
    or SAVEPOINT transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| [RootTransaction](#sqlalchemy.engine.RootTransaction) | Represent the “root”
    transaction on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Transaction](#sqlalchemy.engine.Transaction) | Represent a database transaction
    in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| [TwoPhaseTransaction](#sqlalchemy.engine.TwoPhaseTransaction) | Represent
    a two-phase transaction. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Provides high-level functionality for a wrapped DB-API connection.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is procured by calling the [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method of the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object, and provides services for execution of SQL
    statements as well as transaction control.
  prefs: []
  type: TYPE_NORMAL
- en: The Connection object is **not** thread-safe. While a Connection can be shared
    among threads using properly synchronized access, it is still possible that the
    underlying DBAPI connection may not support shared access between threads. Check
    the DBAPI documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.Connection.__init__), [begin()](#sqlalchemy.engine.Connection.begin),
    [begin_nested()](#sqlalchemy.engine.Connection.begin_nested), [begin_twophase()](#sqlalchemy.engine.Connection.begin_twophase),
    [close()](#sqlalchemy.engine.Connection.close), [closed](#sqlalchemy.engine.Connection.closed),
    [commit()](#sqlalchemy.engine.Connection.commit), [connection](#sqlalchemy.engine.Connection.connection),
    [default_isolation_level](#sqlalchemy.engine.Connection.default_isolation_level),
    [detach()](#sqlalchemy.engine.Connection.detach), [exec_driver_sql()](#sqlalchemy.engine.Connection.exec_driver_sql),
    [execute()](#sqlalchemy.engine.Connection.execute), [execution_options()](#sqlalchemy.engine.Connection.execution_options),
    [get_execution_options()](#sqlalchemy.engine.Connection.get_execution_options),
    [get_isolation_level()](#sqlalchemy.engine.Connection.get_isolation_level), [get_nested_transaction()](#sqlalchemy.engine.Connection.get_nested_transaction),
    [get_transaction()](#sqlalchemy.engine.Connection.get_transaction), [in_nested_transaction()](#sqlalchemy.engine.Connection.in_nested_transaction),
    [in_transaction()](#sqlalchemy.engine.Connection.in_transaction), [info](#sqlalchemy.engine.Connection.info),
    [invalidate()](#sqlalchemy.engine.Connection.invalidate), [invalidated](#sqlalchemy.engine.Connection.invalidated),
    [rollback()](#sqlalchemy.engine.Connection.rollback), [scalar()](#sqlalchemy.engine.Connection.scalar),
    [scalars()](#sqlalchemy.engine.Connection.scalars), [schema_for_object()](#sqlalchemy.engine.Connection.schema_for_object)'
  prefs: []
  type: TYPE_NORMAL
- en: The Connection object represents a single DBAPI connection checked out from
    the connection pool. In this state, the connection pool has no affect upon the
    connection, including its expiration or timeout state. For the connection pool
    to properly manage connections, connections should be returned to the connection
    pool (i.e. `connection.close()`) whenever the connection is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    (`sqlalchemy.engine.interfaces.ConnectionEventsTarget`, `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new Connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Begin a transaction prior to autobegin occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The returned object is an instance of [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction"). This object represents the “scope” of the
    transaction, which completes when either the [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") method is called; the object also works
    as a context manager as illustrated above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    method begins a transaction that normally will be begun in any case when the connection
    is first used to execute a statement. The reason this method might be used would
    be to invoke the [`ConnectionEvents.begin()`](events.html#sqlalchemy.events.ConnectionEvents.begin
    "sqlalchemy.events.ConnectionEvents.begin") event at a specific time, or to organize
    code within the scope of a connection checkout in terms of context managed blocks,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code is not fundamentally any different in its behavior than the
    following code which does not use [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"); the below style is known as “commit as
    you go” style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: From a database point of view, the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method does not emit any SQL or change the
    state of the underlying DBAPI connection in any way; the Python DBAPI does not
    have any concept of explicit transaction begin.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Transactions and the DBAPI](../tutorial/dbapi_transactions.html#tutorial-working-with-transactions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested "sqlalchemy.engine.Connection.begin_nested")
    - use a SAVEPOINT'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase") - use a two phase /XID transaction'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    - context manager available from [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Begin a nested transaction (i.e. SAVEPOINT) and return a transaction handle
    that controls the scope of the SAVEPOINT.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The returned object is an instance of [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction"), which includes transactional methods [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") and [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback"); for a nested transaction, these
    methods correspond to the operations “RELEASE SAVEPOINT <name>” and “ROLLBACK
    TO SAVEPOINT <name>”. The name of the savepoint is local to the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") object and is generated automatically.
    Like any other [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction"),
    the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction")
    may be used as a context manager as illustrated above which will “release” or
    “rollback” corresponding to if the operation within the block were successful
    or raised an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested transactions require SAVEPOINT support in the underlying database, else
    the behavior is undefined. SAVEPOINT is commonly used to run operations within
    a transaction that may fail, while continuing the outer transaction. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") is called without first calling [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") or [`Engine.begin()`](#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object will “autobegin” the outer transaction
    first. This outer transaction may be committed using “commit-as-you-go” style,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0: [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") will now participate in the connection
    “autobegin” behavior that is new as of 2.0 / “future” style connections in 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SAVEPOINT](../orm/session_transaction.html#session-begin-nested) - ORM
    support for SAVEPOINT'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Begin a two-phase or XA transaction and return a transaction handle.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is an instance of [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction"), which in addition to the methods provided
    by [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction"),
    also provides a [`TwoPhaseTransaction.prepare()`](#sqlalchemy.engine.TwoPhaseTransaction.prepare
    "sqlalchemy.engine.TwoPhaseTransaction.prepare") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xid** – the two phase transaction id. If not supplied, a random id will be
    generated.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This results in a release of the underlying database resources, that is, the
    DBAPI connection referenced internally. The DBAPI connection is typically restored
    back to the connection-holding [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    referenced by the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that produced this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    Any transactional state present on the DBAPI connection is also unconditionally
    released via the DBAPI connection’s `rollback()` method, regardless of any [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object that may be outstanding with regards to
    this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This has the effect of also calling [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") if any transaction is in place.
  prefs: []
  type: TYPE_NORMAL
- en: After [`Connection.close()`](#sqlalchemy.engine.Connection.close "sqlalchemy.engine.Connection.close")
    is called, the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is permanently in a closed state, and will allow no further operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Commit the transaction that is currently in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This method commits the current transaction if one has been started. If no transaction
    was started, the method has no effect, assuming the connection is in a non-invalidated
    state.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is begun on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    automatically whenever a statement is first executed, or when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    method only acts upon the primary database transaction that is linked to the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. It does not operate upon a SAVEPOINT that
    would have been invoked from the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method; for control of a SAVEPOINT,
    call [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") on the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") that is returned by the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The underlying DB-API connection managed by this Connection.
  prefs: []
  type: TYPE_NORMAL
- en: This is a SQLAlchemy connection-pool proxied connection which then has the attribute
    `_ConnectionFairy.dbapi_connection` that refers to the actual driver connection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Driver SQL and Raw DBAPI Connections](#dbapi-connections)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The initial-connection time isolation level associated with the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") in use.
  prefs: []
  type: TYPE_NORMAL
- en: This value is independent of the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") and [`Engine.execution_options.isolation_level`](#sqlalchemy.engine.Engine.execution_options.params.isolation_level
    "sqlalchemy.engine.Engine.execution_options") execution options, and is determined
    by the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    when the first connection is created, by performing a SQL query against the database
    for the current isolation level before any additional commands have been emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Calling this accessor does not invoke any new SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.get_isolation_level()`](#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") - view current actual isolation
    level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") - set per [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") - set per [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Detach the underlying DB-API connection from its connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    instance will remain usable. When closed (or exited from a context manager context
    as above), the DB-API connection will be literally closed and not returned to
    its originating pool.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be used to insulate the rest of an application from a modified
    state on a connection (such as a transaction isolation level or similar).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Executes a string SQL statement on the DBAPI cursor directly, without any SQL
    compilation steps.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to pass any string directly to the `cursor.execute()` method
    of the DBAPI in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`statement` – The statement str to be executed. Bound parameters must use the
    underlying DBAPI’s paramstyle, such as “qmark”, “pyformat”, “format”, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` – represent bound parameter values to be used in the execution.
    The format is one of: a dictionary of named parameters, a tuple of positional
    parameters, or a list containing either dictionaries or tuples for multiple-execute
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. multiple dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Single dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Single tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method does not participate in
    the [`ConnectionEvents.before_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_execute
    "sqlalchemy.events.ConnectionEvents.before_execute") and [`ConnectionEvents.after_execute()`](events.html#sqlalchemy.events.ConnectionEvents.after_execute
    "sqlalchemy.events.ConnectionEvents.after_execute") events. To intercept calls
    to [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql"), use [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") and [`ConnectionEvents.after_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute
    "sqlalchemy.events.ConnectionEvents.after_cursor_execute").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[**PEP 249**](https://peps.python.org/pep-0249/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Executes a SQL statement construct and returns a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`statement` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The statement to be executed. This is always an object that is in both the
    [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement "sqlalchemy.sql.expression.ClauseElement")
    and [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable")
    hierarchies, including:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Insert`](dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert"),
    [`Update`](dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update"),
    [`Delete`](dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TextClause`](sqlelement.html#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    and [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DDL`](ddl.html#sqlalchemy.schema.DDL "sqlalchemy.schema.DDL") and objects
    which inherit from [`ExecutableDDLElement`](ddl.html#sqlalchemy.schema.ExecutableDDLElement
    "sqlalchemy.schema.ExecutableDDLElement")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` – parameters which will be bound into the statement. This may
    be either a dictionary of parameter names to values, or a mutable sequence (e.g.
    a list) of dictionaries. When a list of dictionaries is passed, the underlying
    statement execution will make use of the DBAPI `cursor.executemany()` method.
    When a single dictionary is passed, the DBAPI `cursor.execute()` method will be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution_options` – optional dictionary of execution options, which will
    be associated with the statement execution. This dictionary can provide a subset
    of the options that are accepted by [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Set non-SQL options for the connection which take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: This method modifies this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    **in-place**; the return value is the same [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object upon which the method is called. Note that
    this is in contrast to the behavior of the `execution_options` methods on other
    objects such as [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") and [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"). The rationale is that
    many such execution options necessarily modify the state of the base DBAPI connection
    in any case so there is no feasible means of keeping the effect of such an option
    localized to a “sub” connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method, in contrast to other
    objects with this method, modifies the connection in-place without creating copy
    of it.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed elsewhere, the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method accepts any arbitrary
    parameters including user defined names. All parameters given are consumable in
    a number of ways including by using the [`Connection.get_execution_options()`](#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options") method. See the examples
    at [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") and [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options").
  prefs: []
  type: TYPE_NORMAL
- en: The keywords that are currently recognized by SQLAlchemy itself include all
    those listed under [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), as well as others that
    are specific to [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compiled_cache` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A dictionary where [`Compiled`](internals.html#sqlalchemy.engine.Compiled "sqlalchemy.engine.Compiled")
    objects will be cached when the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    compiles a clause expression into a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. This dictionary will supersede the statement
    cache that may be configured on the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    itself. If set to None, caching is disabled, even if the engine has a configured
    cache size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the ORM makes use of its own “compiled” caches for some operations,
    including flush operations. The caching used by the ORM internally supersedes
    a cache dictionary specified here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`logging_token` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adds the specified string token surrounded by brackets in log messages logged
    by the connection, i.e. the logging that’s enabled either via the [`create_engine.echo`](engines.html#sqlalchemy.create_engine.params.echo
    "sqlalchemy.create_engine") flag or via the `logging.getLogger("sqlalchemy.engine")`
    logger. This allows a per-connection or per-sub-engine token to be available which
    is useful for debugging concurrent connection scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.0b2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Per-Connection / Sub-Engine Tokens](engines.html#dbengine-logging-tokens)
    - usage example'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`create_engine.logging_name`](engines.html#sqlalchemy.create_engine.params.logging_name
    "sqlalchemy.create_engine") - adds a name to the name used by the Python logger
    object itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isolation_level` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the transaction isolation level for the lifespan of this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. Valid values include those string values
    accepted by the [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter passed to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). These levels are semi-database specific; see individual
    dialect documentation for valid levels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The isolation level option applies the isolation level by emitting statements
    on the DBAPI connection, and **necessarily affects the original Connection object
    overall**. The isolation level will remain at the given setting until explicitly
    changed, or when the DBAPI connection itself is [released](../glossary.html#term-released)
    to the connection pool, i.e. the [`Connection.close()`](#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") method is called, at which time an event
    handler will emit additional statements on the DBAPI connection in order to revert
    the isolation level change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `isolation_level` execution option may only be established before the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called, as well as before any
    SQL statements are emitted which would otherwise trigger “autobegin”, or directly
    after a call to [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback").
    A database cannot change the isolation level on a transaction in progress.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `isolation_level` execution option is implicitly reset if the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is invalidated, e.g. via the [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method, or if a disconnection error
    occurs. The new connection produced after the invalidation will **not** have the
    selected isolation level re-applied to it automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](#dbapi-autocommit)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.get_isolation_level()`](#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") - view current actual level'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`no_parameters` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When `True`, if the final parameter list or dictionary is totally empty, will
    invoke the statement on the cursor as `cursor.execute(statement)`, not passing
    the parameter collection at all. Some DBAPIs such as psycopg2 and mysql-python
    consider percent signs as significant only when parameters are present; this option
    allows code to generate SQL containing percent signs (and possibly other characters)
    that is neutral regarding whether it’s executed by the DBAPI or piped into a script
    that’s later invoked by command line tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stream_results` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indicate to the dialect that results should be “streamed” and not pre-buffered,
    if possible. For backends such as PostgreSQL, MySQL and MariaDB, this indicates
    the use of a “server side cursor” as opposed to a client side cursor. Other backends
    such as that of Oracle may already use server side cursors by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The usage of [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") is usually combined with setting
    a fixed number of rows to to be fetched in batches, to allow for efficient iteration
    of database rows while at the same time not loading all result rows into memory
    at once; this can be configured on a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object using the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method, after execution has returned a new [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"). If [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") is not used, the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") mode of operation will instead
    use a dynamically sized buffer which buffers sets of rows at a time, growing on
    each batch based on a fixed growth size up until a limit which may be configured
    using the [`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using the ORM to fetch ORM mapped objects from a result, [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") should always be used with [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options"), so that the ORM does not fetch
    all rows into new ORM objects at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For typical use, the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option should be preferred,
    which sets up both [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") and [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") at once. This option is supported both at
    a core level by [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    as well as by the ORM `Session`; the latter is described at [Fetching Large Result
    Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - background on [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) describing the ORM
    version of `yield_per`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_row_buffer` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").
    Sets a maximum buffer size to use when the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used on
    a backend that supports server side cursors. The default value if not specified
    is 1000.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`yield_per` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").
    Integer value applied which will set the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option and invoke
    [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    automatically at once. Allows equivalent functionality as is present when using
    this parameter with the ORM.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.40.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - background and examples on using server side cursors with Core.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) describing the ORM
    version of `yield_per`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`insertmanyvalues_page_size` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"). Number of rows
    to format into an INSERT statement when the statement uses “insertmanyvalues”
    mode, which is a paged form of bulk insert that is used for many backends when
    using [executemany](../glossary.html#term-executemany) execution typically in
    conjunction with RETURNING. Defaults to 1000\. May also be modified on a per-engine
    basis using the [`create_engine.insertmanyvalues_page_size`](engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](#engine-insertmanyvalues)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`schema_translate_map` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A dictionary mapping schema names to schema names, that will be applied to the
    [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema "sqlalchemy.schema.Table")
    element of each [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    encountered when SQL or DDL expression elements are compiled into strings; the
    resulting schema name will be converted based on presence in the map of the original
    name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Translation of Schema Names](#schema-translating)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`preserve_rowcount` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean; when True, the `cursor.rowcount` attribute will be unconditionally
    memoized within the result and made available via the [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") attribute. Normally, this attribute
    is only preserved for UPDATE and DELETE statements. Using this option, the DBAPIs
    rowcount value can be accessed for other kinds of statements such as INSERT and
    SELECT, to the degree that the DBAPI supports these statements. See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") for notes regarding the behavior of
    this attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.28.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.get_execution_options()`](#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Execution Options](../orm/queryguide/api.html#orm-queryguide-execution-options)
    - documentation on all ORM-specific execution options'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Get the non-SQL options which will take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Return the current **actual** isolation level that’s present on the database
    within the scope of this connection.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute will perform a live SQL operation against the database in order
    to procure the current isolation level, so the value returned is the actual level
    on the underlying DBAPI connection regardless of how this state was set. This
    will be one of the four actual isolation modes `READ UNCOMMITTED`, `READ COMMITTED`,
    `REPEATABLE READ`, `SERIALIZABLE`. It will **not** include the `AUTOCOMMIT` isolation
    level setting. Third party dialects may also feature additional isolation level
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method **will not report** on the `AUTOCOMMIT` isolation level, which is
    a separate [dbapi](../glossary.html#term-DBAPI) setting that’s independent of
    **actual** isolation level. When `AUTOCOMMIT` is in use, the database connection
    still has a “traditional” isolation mode in effect, that is typically one of the
    four values `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Compare to the [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") accessor which returns
    the isolation level that is present on the database at initial connection time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") - view default level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") - set per [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") - set per [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Return the current nested transaction in progress, if any.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Return the current root transaction in progress, if any.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Return True if a transaction is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return True if a transaction is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Info dictionary associated with the underlying DBAPI connection referred to
    by this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    allowing user-defined data to be associated with the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The data here will follow along with the DBAPI connection including after it
    is returned to the connection pool and used again in subsequent instances of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Invalidate the underlying DBAPI connection associated with this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: An attempt will be made to close the underlying DBAPI connection immediately;
    however if this operation fails, the error is logged but not raised. The connection
    is then discarded whether or not close() succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Upon the next use (where “use” typically means using the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method or similar), this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") will attempt to procure a new DBAPI connection
    using the services of the [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    as a source of connectivity (e.g. a “reconnection”).
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction was in progress (e.g. the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method has been called) when [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method is called, at the DBAPI level
    all state associated with this transaction is lost, as the DBAPI connection is
    closed. The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    will not allow a reconnection to proceed until the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object is ended, by calling the [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") method; until that point, any attempt
    at continuing to use the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    will raise an [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError"). This is to prevent applications from accidentally
    continuing an ongoing transactional operations despite the fact that the transaction
    has been lost due to an invalidation.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate "sqlalchemy.engine.Connection.invalidate")
    method, just like auto-invalidation, will at the connection pool level invoke
    the [`PoolEvents.invalidate()`](events.html#sqlalchemy.events.PoolEvents.invalidate
    "sqlalchemy.events.PoolEvents.invalidate") event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**exception** – an optional `Exception` instance that’s the reason for the
    invalidation. is passed along to event handlers and logging functions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[More on Invalidation](pooling.html#pool-connection-invalidation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this connection was invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: This does not indicate whether or not the connection was invalidated at the
    pool level, however
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Roll back the transaction that is currently in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This method rolls back the current transaction if one has been started. If no
    transaction was started, the method has no effect. If a transaction was started
    and the connection is in an invalidated state, the transaction is cleared using
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is begun on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    automatically whenever a statement is first executed, or when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback")
    method only acts upon the primary database transaction that is linked to the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. It does not operate upon a SAVEPOINT that
    would have been invoked from the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method; for control of a SAVEPOINT,
    call [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback") on the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") that is returned by the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Executes a SQL statement construct and returns a scalar object.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for invoking the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method after invoking the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method. Parameters are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a scalar Python value representing the first column of the first row returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Executes and returns a scalar result set, which yields scalar values from the
    first column of each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method is equivalent to calling [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") to receive a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, then invoking the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method to produce a [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.24.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Return the schema name for the given schema item taking into account current
    schema translate map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: A set of hooks intended to augment the construction of an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object based on entrypoint names in a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is to allow third-party systems to apply
    engine, pool and dialect level event listeners without the need for the target
    application to be modified; instead, the plugin names can be added to the database
    URL. Target applications for [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") include:'
  prefs: []
  type: TYPE_NORMAL
- en: connection and SQL performance tools, e.g. which use events to track number
    of checkouts and/or time spent with statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: connectivity plugins such as proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A rudimentary [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that attaches a logger to an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugins are registered using entry points in a similar way as that of dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'A plugin that uses the above names would be invoked from a database URL as
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plugin` URL parameter supports multiple instances, so that a URL may specify
    multiple plugins; they are loaded in the order stated in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin names may also be passed directly to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") using the [`create_engine.plugins`](engines.html#sqlalchemy.create_engine.params.plugins
    "sqlalchemy.create_engine") argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.2.3: plugin names can also be specified to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as a list'
  prefs: []
  type: TYPE_NORMAL
- en: A plugin may consume plugin-specific arguments from the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object as well as the `kwargs` dictionary, which is the
    dictionary of arguments passed to the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. “Consuming” these arguments includes that they
    must be removed when the plugin initializes, so that the arguments are not passed
    along to the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    constructor, where they will raise an [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") because they are not known by the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of version 1.4 of SQLAlchemy, arguments should continue to be consumed from
    the `kwargs` dictionary directly, by removing the values with a method such as
    `dict.pop`. Arguments from the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object should be consumed by implementing the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method, returning a new copy
    of the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") with
    plugin-specific parameters removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments like those illustrated above would be consumed from a [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object is now immutable; a [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that needs to alter the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") should implement the newly added [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method, which is invoked after
    the plugin is constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For migration, construct the plugin in the following way, checking for the
    existence of the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method to detect which version
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The URL object is now immutable](../changelog/migration_14.html#change-5526)
    - overview of the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    change which also includes notes regarding [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.CreateEnginePlugin.__init__), [engine_created()](#sqlalchemy.engine.CreateEnginePlugin.engine_created),
    [handle_dialect_kwargs()](#sqlalchemy.engine.CreateEnginePlugin.handle_dialect_kwargs),
    [handle_pool_kwargs()](#sqlalchemy.engine.CreateEnginePlugin.handle_pool_kwargs),
    [update_url()](#sqlalchemy.engine.CreateEnginePlugin.update_url)'
  prefs: []
  type: TYPE_NORMAL
- en: When the engine creation process completes and produces the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object, it is again passed to the plugin via the [`CreateEnginePlugin.engine_created()`](#sqlalchemy.engine.CreateEnginePlugin.engine_created
    "sqlalchemy.engine.CreateEnginePlugin.engine_created") hook. In this hook, additional
    changes can be made to the engine, most typically involving setup of events (e.g.
    those defined in [Core Events](events.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin").
  prefs: []
  type: TYPE_NORMAL
- en: The plugin object is instantiated individually for each call to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). A single `Engine` will be passed to the [`CreateEnginePlugin.engine_created()`](#sqlalchemy.engine.CreateEnginePlugin.engine_created
    "sqlalchemy.engine.CreateEnginePlugin.engine_created") method corresponding to
    this URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") object.
    The plugin may inspect the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    for arguments. Arguments used by the plugin should be removed, by returning an
    updated [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") from
    the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object is now immutable, so a [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that needs to alter the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object should implement the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`kwargs` – The keyword arguments passed to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Receive the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object when it is fully constructed.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin may make additional changes to the engine, such as registering engine
    or connection pool events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: parse and modify dialect kwargs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: parse and modify pool kwargs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Update the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL").
  prefs: []
  type: TYPE_NORMAL
- en: A new [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") should
    be returned. This method is typically used to consume configuration arguments
    from the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") which
    must be removed, as they will not be recognized by the dialect. The [`URL.difference_update_query()`](engines.html#sqlalchemy.engine.URL.difference_update_query
    "sqlalchemy.engine.URL.difference_update_query") method is available to remove
    these arguments. See the docstring at [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for an example.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Connects a [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    and [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    together to provide a source of database connectivity and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: An [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") object is
    instantiated publicly using the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Engine Configuration](engines.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](#)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[begin()](#sqlalchemy.engine.Engine.begin), [clear_compiled_cache()](#sqlalchemy.engine.Engine.clear_compiled_cache),
    [connect()](#sqlalchemy.engine.Engine.connect), [dispose()](#sqlalchemy.engine.Engine.dispose),
    [driver](#sqlalchemy.engine.Engine.driver), [engine](#sqlalchemy.engine.Engine.engine),
    [execution_options()](#sqlalchemy.engine.Engine.execution_options), [get_execution_options()](#sqlalchemy.engine.Engine.get_execution_options),
    [name](#sqlalchemy.engine.Engine.name), [raw_connection()](#sqlalchemy.engine.Engine.raw_connection),
    [update_execution_options()](#sqlalchemy.engine.Engine.update_execution_options)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    (`sqlalchemy.engine.interfaces.ConnectionEventsTarget`, [`sqlalchemy.log.Identified`](internals.html#sqlalchemy.log.Identified
    "sqlalchemy.log.Identified"), `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Return a context manager delivering a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with a [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") established.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Upon successful operation, the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") is committed. If an error is raised, the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") is rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    - procure a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    from an [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    - start a [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    for a particular [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Clear the compiled cache associated with the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: This applies **only** to the built-in cache that is established via the `create_engine.query_cache_size`
    parameter. It will not impact any dictionary caches that were passed via the [`Connection.execution_options.compiled_cache`](#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    acts as a Python context manager, so the typical use of this method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Where above, after the block is completed, the connection is “closed” and its
    underlying DBAPI resources are returned to the connection pool. This also has
    the effect of rolling back any transaction that was explicitly begun or was begun
    via autobegin, and will emit the [`ConnectionEvents.rollback()`](events.html#sqlalchemy.events.ConnectionEvents.rollback
    "sqlalchemy.events.ConnectionEvents.rollback") event if one was started and is
    still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Dispose of the connection pool used by this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: A new connection pool is created immediately after the old one has been disposed.
    The previous connection pool is disposed either actively, by closing out all currently
    checked-in connections in that pool, or passively, by losing references to it
    but otherwise not closing any connections. The latter strategy is more appropriate
    for an initializer in a forked Python process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**close** –'
  prefs: []
  type: TYPE_NORMAL
- en: if left at its default of `True`, has the effect of fully closing all **currently
    checked in** database connections. Connections that are still checked out will
    **not** be closed, however they will no longer be associated with this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), so when they are closed individually, eventually
    the [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool") which they
    are associated with will be garbage collected and they will be closed out fully,
    if not already closed on checkin.
  prefs: []
  type: TYPE_NORMAL
- en: If set to `False`, the previous connection pool is de-referenced, and otherwise
    not touched in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.33: Added the [`Engine.dispose.close`](#sqlalchemy.engine.Engine.dispose.params.close
    "sqlalchemy.engine.Engine.dispose") parameter to allow the replacement of a connection
    pool in a child process without interfering with the connections used by the parent
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Engine Disposal](#engine-disposal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Driver name of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    in use by this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Returns this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: Used for legacy schemes that accept [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") / [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    objects within the same variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that will provide [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects with the given execution options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    remains related to the original [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    in that it shares the same connection pool and other state:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool") used
    by the new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is
    the same instance. The [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") method will replace the connection pool instance
    for the parent engine as well as this one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners are “cascaded” - meaning, the new [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") inherits the events of the parent, and new events
    can be associated with the new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging configuration and logging_name is copied from the parent [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intent of the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method is to implement schemes where
    multiple [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") objects
    refer to the same connection pool, but are differentiated by options that affect
    some execution-level behavior for each engine. One such example is breaking into
    separate “reader” and “writer” [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    instances, where one [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    has a lower [isolation level](../glossary.html#term-isolation-level) setting configured
    or is even transaction-disabled using “autocommit”. An example of this configuration
    is at [Maintaining Multiple Isolation Levels for a Single Engine](#dbapi-autocommit-multiple).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is one that uses a custom option `shard_id` which is consumed
    by an event to change the current schema on a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The above recipe illustrates two [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    objects that will each serve as factories for [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that have pre-established “shard_id” execution
    options present. A [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") event handler then
    interprets this execution option to emit a MySQL `use` statement to switch databases
    before a statement execution, while at the same time keeping track of which database
    we’ve established using the [`Connection.info`](#sqlalchemy.engine.Connection.info
    "sqlalchemy.engine.Connection.info") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") - update execution options on
    a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.update_execution_options()`](#sqlalchemy.engine.Engine.update_execution_options
    "sqlalchemy.engine.Engine.update_execution_options") - update the execution options
    for a given [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") in
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.get_execution_options()`](#sqlalchemy.engine.Engine.get_execution_options
    "sqlalchemy.engine.Engine.get_execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Get the non-SQL options which will take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: String name of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    in use by this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Return a “raw” DBAPI connection from the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is a proxied version of the DBAPI connection object used
    by the underlying driver in use. The object will have all the same behavior as
    the real DBAPI connection, except that its `close()` method will result in the
    connection being returned to the pool, rather than being closed for real.
  prefs: []
  type: TYPE_NORMAL
- en: This method provides direct DBAPI connection access for special situations when
    the API provided by [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is not needed. When a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is already present, the DBAPI connection is available using the [`Connection.connection`](#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Driver SQL and Raw DBAPI Connections](#dbapi-connections)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Update the default execution_options dictionary of this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: The given keys/values in **opt are added to the default execution options that
    will be used for all connections. The initial contents of this dictionary can
    be sent via the `execution_options` parameter to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulate information about an error condition in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[chained_exception](#sqlalchemy.engine.ExceptionContext.chained_exception),
    [connection](#sqlalchemy.engine.ExceptionContext.connection), [cursor](#sqlalchemy.engine.ExceptionContext.cursor),
    [dialect](#sqlalchemy.engine.ExceptionContext.dialect), [engine](#sqlalchemy.engine.ExceptionContext.engine),
    [execution_context](#sqlalchemy.engine.ExceptionContext.execution_context), [invalidate_pool_on_disconnect](#sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect),
    [is_disconnect](#sqlalchemy.engine.ExceptionContext.is_disconnect), [is_pre_ping](#sqlalchemy.engine.ExceptionContext.is_pre_ping),
    [original_exception](#sqlalchemy.engine.ExceptionContext.original_exception),
    [parameters](#sqlalchemy.engine.ExceptionContext.parameters), [sqlalchemy_exception](#sqlalchemy.engine.ExceptionContext.sqlalchemy_exception),
    [statement](#sqlalchemy.engine.ExceptionContext.statement)'
  prefs: []
  type: TYPE_NORMAL
- en: This object exists solely to be passed to the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") event, supporting an interface
    that can be extended without backwards-incompatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The exception that was returned by the previous handler in the exception chain,
    if any.
  prefs: []
  type: TYPE_NORMAL
- en: If present, this exception will be the one ultimately raised by SQLAlchemy unless
    a subsequent handler replaces it.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    in use during the exception.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present, except in the case of a failure when first connecting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExceptionContext.engine`](#sqlalchemy.engine.ExceptionContext.engine "sqlalchemy.engine.ExceptionContext.engine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The DBAPI cursor object.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present for all invocations of the event hook.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") in use
    during the exception.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present in all cases except for when handling an error within
    the connection pool “pre-ping” process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    corresponding to the execution operation in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This is present for statement execution operations, but not for operations such
    as transaction begin/end. It also is not present when the exception was raised
    before the [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext") could be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the [`ExceptionContext.statement`](#sqlalchemy.engine.ExceptionContext.statement
    "sqlalchemy.engine.ExceptionContext.statement") and [`ExceptionContext.parameters`](#sqlalchemy.engine.ExceptionContext.parameters
    "sqlalchemy.engine.ExceptionContext.parameters") members may represent a different
    value than that of the [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext"), potentially in the case where a [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") event or similar modified
    the statement/parameters to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Represent whether all connections in the pool should be invalidated when a “disconnect”
    condition is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: Setting this flag to False within the scope of the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") event will have the effect such
    that the full collection of connections in the pool will not be invalidated during
    a disconnect; only the current connection that is the subject of the error will
    actually be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this flag is for custom disconnect-handling schemes where the
    invalidation of other connections in the pool is to be performed based on other
    conditions, or even on a per-connection basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Represent whether the exception as occurred represents a “disconnect” condition.
  prefs: []
  type: TYPE_NORMAL
- en: This flag will always be True or False within the scope of the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") handler.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will defer to this flag in order to determine whether or not the
    connection should be invalidated subsequently. That is, by assigning to this flag,
    a “disconnect” event which then results in a connection and pool invalidation
    can be invoked or prevented by changing this flag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The pool “pre_ping” handler enabled using the [`create_engine.pool_pre_ping`](engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine") parameter does **not** consult this event before deciding
    if the “ping” returned false, as opposed to receiving an unhandled error. For
    this use case, the [legacy recipe based on engine_connect() may be used](pooling.html#pool-disconnects-pessimistic-custom).
    A future API allow more comprehensive customization of the “disconnect” detection
    mechanism across all functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this error is occurring within the “pre-ping” step performed when
    [`create_engine.pool_pre_ping`](engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine") is set to `True`. In this mode, the [`ExceptionContext.engine`](#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") attribute will be `None`. The dialect
    in use is accessible via the [`ExceptionContext.dialect`](#sqlalchemy.engine.ExceptionContext.dialect
    "sqlalchemy.engine.ExceptionContext.dialect") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The exception object which was caught.
  prefs: []
  type: TYPE_NORMAL
- en: This member is always present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Parameter collection that was emitted directly to the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The [`sqlalchemy.exc.StatementError`](exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") which wraps the original, and will be raised
    if exception handling is not circumvented by the event.
  prefs: []
  type: TYPE_NORMAL
- en: May be None, as not all exception types are wrapped by SQLAlchemy. For DBAPI-level
    exceptions that subclass the dbapi’s Error class, this field will always be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: String SQL statement that was emitted directly to the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Represent a ‘nested’, or SAVEPOINT transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction")
    object is created by calling the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    the semantics of “begin” / “commit” / “rollback” are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the “begin” operation corresponds to the “BEGIN SAVEPOINT” command, where the
    savepoint is given an explicit name that is part of the state of this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") method corresponds to a “RELEASE
    SAVEPOINT” operation, using the savepoint identifier associated with this [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback") method corresponds to a “ROLLBACK
    TO SAVEPOINT” operation, using the savepoint identifier associated with this [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rationale for mimicking the semantics of an outer transaction in terms of
    savepoints so that code may deal with a “savepoint” transaction and an “outer”
    transaction in an agnostic way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SAVEPOINT](../orm/session_transaction.html#session-begin-nested) - ORM
    version of the SAVEPOINT API.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.NestedTransaction.close), [commit()](#sqlalchemy.engine.NestedTransaction.commit),
    [rollback()](#sqlalchemy.engine.NestedTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") ([`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Represent the “root” transaction on a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to the current “BEGIN/COMMIT/ROLLBACK” that’s occurring for
    the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    The [`RootTransaction`](#sqlalchemy.engine.RootTransaction "sqlalchemy.engine.RootTransaction")
    is created by calling upon the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, and remains associated with the
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") throughout
    its active span. The current [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") in use is accessible via the [`Connection.get_transaction`](#sqlalchemy.engine.Connection.get_transaction
    "sqlalchemy.engine.Connection.get_transaction") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: In [2.0 style](../glossary.html#term-2.0-style) use, the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") also employs “autobegin” behavior that will create
    a new [`RootTransaction`](#sqlalchemy.engine.RootTransaction "sqlalchemy.engine.RootTransaction")
    whenever a connection in a non-transactional state is used to emit commands on
    the DBAPI connection. The scope of the [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") in 2.0 style use can be controlled using
    the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    and [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback")
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.RootTransaction.close), [commit()](#sqlalchemy.engine.RootTransaction.commit),
    [rollback()](#sqlalchemy.engine.RootTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") ([`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Represent a database transaction in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    object is procured by calling the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The object provides [`rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") and [`commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") methods in order to control transaction
    boundaries. It also implements a context manager interface so that the Python
    `with` statement can be used with the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The Transaction object is **not** threadsafe.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.Transaction.close), [commit()](#sqlalchemy.engine.Transaction.commit),
    [rollback()](#sqlalchemy.engine.Transaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested "sqlalchemy.engine.Connection.begin_nested")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    (`sqlalchemy.engine.util.TransactionalContext`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Represent a two-phase transaction.
  prefs: []
  type: TYPE_NORMAL
- en: A new [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction")
    object may be procured using the [`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase") method.
  prefs: []
  type: TYPE_NORMAL
- en: The interface is the same as that of [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") with the addition of the [`prepare()`](#sqlalchemy.engine.TwoPhaseTransaction.prepare
    "sqlalchemy.engine.TwoPhaseTransaction.prepare") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.TwoPhaseTransaction.close), [commit()](#sqlalchemy.engine.TwoPhaseTransaction.commit),
    [prepare()](#sqlalchemy.engine.TwoPhaseTransaction.prepare), [rollback()](#sqlalchemy.engine.TwoPhaseTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction") ([`sqlalchemy.engine.RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Prepare this [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction").
  prefs: []
  type: TYPE_NORMAL
- en: After a PREPARE, the transaction can be committed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result Set API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ChunkedIteratorResult](#sqlalchemy.engine.ChunkedIteratorResult) | An [`IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult") that works from an iterator-producing callable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [CursorResult](#sqlalchemy.engine.CursorResult) | A Result that is representing
    state from a DBAPI cursor. |'
  prefs: []
  type: TYPE_TB
- en: '| [FilterResult](#sqlalchemy.engine.FilterResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns objects other than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, such as dictionaries or scalar objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [FrozenResult](#sqlalchemy.engine.FrozenResult) | Represents a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object in a “frozen” state suitable for caching. |'
  prefs: []
  type: TYPE_TB
- en: '| [IteratorResult](#sqlalchemy.engine.IteratorResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that gets data from a Python iterator of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects or similar row-like data. |'
  prefs: []
  type: TYPE_TB
- en: '| [MappingResult](#sqlalchemy.engine.MappingResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns dictionary values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values. |'
  prefs: []
  type: TYPE_TB
- en: '| [MergedResult](#sqlalchemy.engine.MergedResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that is merged from any number of [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Result](#sqlalchemy.engine.Result) | Represent a set of database results.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Row](#sqlalchemy.engine.Row) | Represent a single result row. |'
  prefs: []
  type: TYPE_TB
- en: '| [RowMapping](#sqlalchemy.engine.RowMapping) | A `Mapping` that maps column
    names and objects to [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ScalarResult](#sqlalchemy.engine.ScalarResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values. |'
  prefs: []
  type: TYPE_TB
- en: '| [TupleResult](#sqlalchemy.engine.TupleResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that’s typed as returning plain Python tuples instead
    of rows. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: An [`IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult")
    that works from an iterator-producing callable.
  prefs: []
  type: TYPE_NORMAL
- en: The given `chunks` argument is a function that is given a number of rows to
    return in each chunk, or `None` for all rows. The function should then return
    an un-consumed iterator of lists, each list of the requested size.
  prefs: []
  type: TYPE_NORMAL
- en: The function can be called at any time again, in which case it should continue
    from the same result set but adjust the chunk size as given.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[yield_per()](#sqlalchemy.engine.ChunkedIteratorResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.ChunkedIteratorResult`](#sqlalchemy.engine.ChunkedIteratorResult
    "sqlalchemy.engine.ChunkedIteratorResult") ([`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: A Result that is representing state from a DBAPI cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `CursorResult`` class replaces the previous `ResultProxy`
    interface. This classes are based on the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") calling API which provides an updated usage model
    and calling facade for SQLAlchemy Core and SQLAlchemy ORM.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns database rows via the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class, which provides additional API features and behaviors on top of the raw
    data returned by the DBAPI. Through the use of filters such as the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, other kinds of objects may also be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SELECT Statements](../tutorial/data_select.html#tutorial-selecting-data)
    - introductory material for accessing [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") and [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.CursorResult.all), [close()](#sqlalchemy.engine.CursorResult.close),
    [columns()](#sqlalchemy.engine.CursorResult.columns), [fetchall()](#sqlalchemy.engine.CursorResult.fetchall),
    [fetchmany()](#sqlalchemy.engine.CursorResult.fetchmany), [fetchone()](#sqlalchemy.engine.CursorResult.fetchone),
    [first()](#sqlalchemy.engine.CursorResult.first), [freeze()](#sqlalchemy.engine.CursorResult.freeze),
    [inserted_primary_key](#sqlalchemy.engine.CursorResult.inserted_primary_key),
    [inserted_primary_key_rows](#sqlalchemy.engine.CursorResult.inserted_primary_key_rows),
    [is_insert](#sqlalchemy.engine.CursorResult.is_insert), [keys()](#sqlalchemy.engine.CursorResult.keys),
    [last_inserted_params()](#sqlalchemy.engine.CursorResult.last_inserted_params),
    [last_updated_params()](#sqlalchemy.engine.CursorResult.last_updated_params),
    [lastrow_has_defaults()](#sqlalchemy.engine.CursorResult.lastrow_has_defaults),
    [lastrowid](#sqlalchemy.engine.CursorResult.lastrowid), [mappings()](#sqlalchemy.engine.CursorResult.mappings),
    [merge()](#sqlalchemy.engine.CursorResult.merge), [one()](#sqlalchemy.engine.CursorResult.one),
    [one_or_none()](#sqlalchemy.engine.CursorResult.one_or_none), [partitions()](#sqlalchemy.engine.CursorResult.partitions),
    [postfetch_cols()](#sqlalchemy.engine.CursorResult.postfetch_cols), [prefetch_cols()](#sqlalchemy.engine.CursorResult.prefetch_cols),
    [returned_defaults](#sqlalchemy.engine.CursorResult.returned_defaults), [returned_defaults_rows](#sqlalchemy.engine.CursorResult.returned_defaults_rows),
    [returns_rows](#sqlalchemy.engine.CursorResult.returns_rows), [rowcount](#sqlalchemy.engine.CursorResult.rowcount),
    [scalar()](#sqlalchemy.engine.CursorResult.scalar), [scalar_one()](#sqlalchemy.engine.CursorResult.scalar_one),
    [scalar_one_or_none()](#sqlalchemy.engine.CursorResult.scalar_one_or_none), [scalars()](#sqlalchemy.engine.CursorResult.scalars),
    [splice_horizontally()](#sqlalchemy.engine.CursorResult.splice_horizontally),
    [splice_vertically()](#sqlalchemy.engine.CursorResult.splice_vertically), [supports_sane_multi_rowcount()](#sqlalchemy.engine.CursorResult.supports_sane_multi_rowcount),
    [supports_sane_rowcount()](#sqlalchemy.engine.CursorResult.supports_sane_rowcount),
    [t](#sqlalchemy.engine.CursorResult.t), [tuples()](#sqlalchemy.engine.CursorResult.tuples),
    [unique()](#sqlalchemy.engine.CursorResult.unique), [yield_per()](#sqlalchemy.engine.CursorResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    ([`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return all rows in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set after invocation. Subsequent invocations will return an
    empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - How to stream a large result set without loading it completely in python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: This closes out the underlying DBAPI cursor corresponding to the statement execution,
    if one is still present. Note that the DBAPI cursor is automatically released
    when the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    exhausts all available rows. [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") is generally an optional method except
    in the case when discarding a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") that still has additional rows pending for fetch.
  prefs: []
  type: TYPE_NORMAL
- en: After this method is called, it is no longer valid to call upon the fetch methods,
    which will raise a [`ResourceClosedError`](exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError") on subsequent use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](#)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be used to limit the columns returned as well as to reorder
    them. The given list of expressions are normally a series of integers or string
    key names. They may also be appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects which correspond to a given
    statement construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Due to a bug in 1.4, the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method had an incorrect behavior where calling
    upon the method with just one index would cause the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object to yield scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects. In version 2.0, this behavior has been corrected
    such that calling upon [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") with a single index will produce a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that continues to yield [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, which include only a single column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of using the column objects from the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***col_expressions** – indicates columns to be returned. Elements may be integer
    row indexes, string column names, or appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects corresponding to a select construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    with the modifications given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchall()`](#sqlalchemy.engine.Result.fetchall
    "sqlalchemy.engine.Result.fetchall") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for the [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch many rows.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch rows in groups, use the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch one row.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns None.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the first row of a result only, use the [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") method. To iterate through all rows, iterate
    the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object if no filters
    are applied, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the first row or `None` if no row is present.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set and discards remaining rows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in contrast to the behavior of the legacy ORM [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") method, **no limit is applied** to the SQL query
    which was invoked to produce this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result");
    for a DBAPI driver that buffers results in memory before yielding rows, all rows
    will be sent to the Python process and all but the first row will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query Unified with Core Select](../changelog/migration_20.html#migration-20-unify-select)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object, or None if
    no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.freeze()`](#sqlalchemy.engine.Result.freeze "sqlalchemy.engine.Result.freeze")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a callable object that will produce copies of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The callable object returned is an instance of [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult").
  prefs: []
  type: TYPE_NORMAL
- en: This is used for result set caching. The method must be called on the result
    when it has been unconsumed, and calling the method will consume the result fully.
    When the [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    is retrieved from a cache, it can be called any number of times where it will
    produce a new [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object each time against its stored set of rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Return the primary key for the row just inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object representing a named tuple of primary key values in the order in which
    the primary key columns are configured in the source [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.8: - the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") value is now a named tuple
    via the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") class, rather
    than a plain tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: This accessor only applies to single row [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") constructs which did not explicitly specify
    [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning "sqlalchemy.sql.expression.Insert.returning").
    Support for multirow inserts, while not yet available for most backends, would
    be accessed using the [`CursorResult.inserted_primary_key_rows`](#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Note that primary key columns which specify a server_default clause, or otherwise
    do not qualify as “autoincrement” columns (see the notes at [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")), and were generated using the database-side default,
    will appear in this list as `None` unless the backend supports “returning” and
    the insert statement executed with the “implicit returning” enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Return the value of [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") as a row contained within
    a list; some dialects may support a multiple row form as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As indicated below, in current SQLAlchemy versions this accessor is only useful
    beyond what’s already supplied by [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") when using the [psycopg2](../dialects/postgresql.html#postgresql-psycopg2)
    dialect. Future versions hope to generalize this feature to more dialects.
  prefs: []
  type: TYPE_NORMAL
- en: This accessor is added to support dialects that offer the feature that is currently
    implemented by the [Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)
    feature, currently **only the psycopg2 dialect**, which provides for many rows
    to be INSERTed at once while still retaining the behavior of being able to return
    server-generated primary key values.
  prefs: []
  type: TYPE_NORMAL
- en: '`When using the psycopg2 dialect, or other dialects that may support “fast
    executemany” style inserts in upcoming releases` : When invoking an INSERT statement
    while passing a list of rows as the second argument to [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), this accessor will then provide a list
    of rows, where each row contains the primary key value for each row that was INSERTed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When using all other dialects / backends that don’t yet support this feature`:
    This accessor is only useful for `single row INSERT statements`, and returns the
    same information as that of the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") within a single-element
    list. When an INSERT statement is executed in conjunction with a list of rows
    to be INSERTed, the list will contain one row per row inserted in the statement,
    however it will contain `None` for any server-generated values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future releases of SQLAlchemy will further generalize the “fast execution helper”
    feature of psycopg2 to suit other dialects, thus allowing this accessor to be
    of more general use.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: True if this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    is the result of a executing an expression language compiled [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: When True, this implies that the [`inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") attribute is accessible,
    assuming the statement did not include a user defined “returning” construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Return the collection of inserted parameters from this execution.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Return the collection of updated parameters from this execution.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Return `lastrow_has_defaults()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Return the ‘lastrowid’ accessor on the DBAPI cursor.
  prefs: []
  type: TYPE_NORMAL
- en: This is a DBAPI specific method and is only functional for those backends which
    support it, for statements where it is appropriate. It’s behavior is not consistent
    across backends.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of this method is normally unnecessary when using insert() expression
    constructs; the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") attribute provides a tuple
    of primary key values for a newly inserted row, regardless of database backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a mappings filter to returned rows, returning an instance of [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied, fetching rows will return [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") objects instead of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Merge this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    with other compatible result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is an instance of [`MergedResult`](#sqlalchemy.engine.MergedResult
    "sqlalchemy.engine.MergedResult"), which will be composed of iterators from the
    given result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new result will use the metadata from this result object. The subsequent
    result objects must be against an identical set of result / cursor metadata, otherwise
    the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one row or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound "sqlalchemy.exc.NoResultFound")
    if the result returns no rows, or [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound"), [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound
    "sqlalchemy.exc.NoResultFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one "sqlalchemy.engine.Result.scalar_one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return at most one result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if the result has no rows. Raises [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") or `None`
    if no row is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through sub-lists of rows of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Each list will be of the size given, excluding the last list to be yielded,
    which may have a small number of rows. No empty lists will be yielded.
  prefs: []
  type: TYPE_NORMAL
- en: The result object is automatically closed when the iterator is fully consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend driver will usually buffer the entire result ahead of
    time unless the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used indicating
    that the driver should not pre-buffer results, if possible. Not all drivers support
    this option and the option is silently ignored for those who do not.
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM, the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method is typically more effective from
    a memory perspective when it is combined with use of the [yield_per execution
    option](../orm/queryguide/api.html#orm-queryguide-yield-per), which instructs
    both the DBAPI driver to use server side cursors, if available, as well as instructs
    the ORM loading internals to only build a certain amount of ORM objects from a
    result at a time before yielding them out.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size** – indicate the maximum number of rows to be present in each list yielded.
    If None, makes use of the value set by the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per"), method, if it were called, or the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which is equivalent
    in this regard. If yield_per weren’t set, it makes use of the [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") default, which may be backend specific and
    not well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: iterator of lists
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Return `postfetch_cols()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() or update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Return `prefetch_cols()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() or update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Return the values of default columns that were fetched using the `ValuesBase.return_defaults()`
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: The value is an instance of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row"),
    or `None` if `ValuesBase.return_defaults()` was not used or if the backend does
    not support RETURNING.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`ValuesBase.return_defaults()`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of rows each containing the values of default columns that were
    fetched using the `ValuesBase.return_defaults()` feature.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a list of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: True if this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    returns zero or more rows.
  prefs: []
  type: TYPE_NORMAL
- en: I.e. if it is legal to call the methods [`CursorResult.fetchone()`](#sqlalchemy.engine.CursorResult.fetchone
    "sqlalchemy.engine.CursorResult.fetchone"), [`CursorResult.fetchmany()`](#sqlalchemy.engine.CursorResult.fetchmany
    "sqlalchemy.engine.CursorResult.fetchmany") [`CursorResult.fetchall()`](#sqlalchemy.engine.CursorResult.fetchall
    "sqlalchemy.engine.CursorResult.fetchall").
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the value of [`CursorResult.returns_rows`](#sqlalchemy.engine.CursorResult.returns_rows
    "sqlalchemy.engine.CursorResult.returns_rows") should always be synonymous with
    whether or not the DBAPI cursor had a `.description` attribute, indicating the
    presence of result columns, noting that a cursor that returns zero rows still
    has a `.description` if a row-returning statement was emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute should be True for all results that are against SELECT statements,
    as well as for DML statements INSERT/UPDATE/DELETE that use RETURNING. For INSERT/UPDATE/DELETE
    statements that were not using RETURNING, the value will usually be False, however
    there are some dialect-specific exceptions to this, such as when using the MSSQL
    / pyodbc dialect a SELECT is emitted inline in order to retrieve an inserted primary
    key value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Return the ‘rowcount’ for this result.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of ‘rowcount’ is to report the number of rows matched by
    the WHERE criterion of an UPDATE or DELETE statement executed once (i.e. for a
    single parameter set), which may then be compared to the number of rows expected
    to be updated or deleted as a means of asserting data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is transferred from the `cursor.rowcount` attribute of the DBAPI
    before the cursor is closed, to support DBAPIs that don’t make this value available
    after cursor close. Some DBAPIs may offer meaningful values for other kinds of
    statements, such as INSERT and SELECT statements as well. In order to retrieve
    `cursor.rowcount` for these statements, set the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option to True, which
    will cause the `cursor.rowcount` value to be unconditionally memoized before any
    results are returned or the cursor is closed, regardless of statement type.
  prefs: []
  type: TYPE_NORMAL
- en: For cases where the DBAPI does not support rowcount for a particular kind of
    statement and/or execution, the returned value will be `-1`, which is delivered
    directly from the DBAPI and is part of [**PEP 249**](https://peps.python.org/pep-0249/).
    All DBAPIs should support rowcount for single-parameter-set UPDATE and DELETE
    statements, however.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes regarding [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount"):'
  prefs: []
  type: TYPE_NORMAL
- en: This attribute returns the number of rows *matched*, which is not necessarily
    the same as the number of rows that were actually *modified*. For example, an
    UPDATE statement may have no net change on a given row if the SET values given
    are the same as those present in the row already. Such a row would be matched
    but not modified. On backends that feature both styles, such as MySQL, rowcount
    is configured to return the match count in all cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    in the default case is *only* useful in conjunction with an UPDATE or DELETE statement,
    and only with a single set of parameters. For other kinds of statements, SQLAlchemy
    will not attempt to pre-memoize the value unless the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option is used. Note
    that contrary to [**PEP 249**](https://peps.python.org/pep-0249/), many DBAPIs
    do not support rowcount values for statements that are not UPDATE or DELETE, particularly
    when rows are being returned which are not fully pre-buffered. DBAPIs that dont
    support rowcount for a particular kind of statement should return the value `-1`
    for such statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    may not be meaningful when executing a single statement with multiple parameter
    sets (i.e. an [executemany](../glossary.html#term-executemany)). Most DBAPIs do
    not sum “rowcount” values across multiple parameter sets and will return `-1`
    when accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy’s [“Insert Many Values” Behavior for INSERT statements](#engine-insertmanyvalues)
    feature does support a correct population of [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") when the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option is set to True.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that use RETURNING may not support rowcount, returning a `-1` value
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting Affected Row Count from UPDATE, DELETE](../tutorial/data_update.html#tutorial-update-delete-rowcount)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the first column of the first row, and close the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if there are no rows to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: No validation is performed to test if additional rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: After calling this method, the object is fully closed, e.g. the [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") method will have been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python scalar value, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one scalar result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar_one_or_none()`](#sqlalchemy.engine.Result.scalar_one_or_none
    "sqlalchemy.engine.Result.scalar_one_or_none") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one scalar result or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object which will return single elements rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: When results are fetched from the [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") filtering object, the single column-row that
    would be returned by the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    is instead returned as the column’s value.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**index** – integer or row key indicating the column to be fetched from each
    row, defaults to `0` indicating the first column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    that “horizontally splices” together the rows of this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") with that of another [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This method is for the benefit of the SQLAlchemy ORM and is not intended for
    general use.
  prefs: []
  type: TYPE_NORMAL
- en: “horizontally splices” means that for each row in the first and second result
    sets, a new row that concatenates the two rows together is produced, which then
    becomes the new row. The incoming [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") must have the identical number of rows. It is
    typically expected that the two result sets come from the same sort order as well,
    as the result rows are spliced together based on their position in the result.
  prefs: []
  type: TYPE_NORMAL
- en: The expected use case here is so that multiple INSERT..RETURNING statements
    (which definitely need to be sorted) against different tables can produce a single
    result that looks like a JOIN of those two tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.splice_vertically()`](#sqlalchemy.engine.CursorResult.splice_vertically
    "sqlalchemy.engine.CursorResult.splice_vertically")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    that “vertically splices”, i.e. “extends”, the rows of this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") with that of another [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This method is for the benefit of the SQLAlchemy ORM and is not intended for
    general use.
  prefs: []
  type: TYPE_NORMAL
- en: “vertically splices” means the rows of the given result are appended to the
    rows of this cursor result. The incoming [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") must have rows that represent the identical
    list of columns in the identical order as they are in this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.splice_horizontally()`](#sqlalchemy.engine.CursorResult.splice_horizontally
    "sqlalchemy.engine.CursorResult.splice_horizontally")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Return `supports_sane_multi_rowcount` from the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Return `supports_sane_rowcount` from the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t")
    *attribute of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") attribute
    is a synonym for calling the [`Result.tuples()`](#sqlalchemy.engine.Result.tuples
    "sqlalchemy.engine.Result.tuples") method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.tuples()`](#sqlalchemy.engine.Result.tuples "sqlalchemy.engine.Result.tuples")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the same [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object at runtime, however annotates as returning a [`TupleResult`](#sqlalchemy.engine.TupleResult
    "sqlalchemy.engine.TupleResult") object that will indicate to [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools that plain typed `Tuple` instances are returned rather than rows.
    This allows tuple unpacking and `__getitem__` access of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects to by typed, for those cases where the statement
    invoked itself included typing information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the [`TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    type at typing time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") - shorter
    synonym'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") version'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply unique filtering to the objects returned by this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied with no arguments, the rows or objects returned
    will filtered such that each row is returned uniquely. The algorithm used to determine
    this uniqueness is by default the Python hashing identity of the whole tuple.
    In some cases a specialized per-entity hashing scheme may be used, such as when
    using the ORM, a scheme is applied which works against the primary key identity
    of returned objects.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter is applied **after all other filters**, which means if the
    columns returned have been refined using a method such as the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") or [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, the uniquing is applied to **only
    the column or columns returned**. This occurs regardless of the order in which
    these methods have been called upon the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter also changes the calculus used for methods like [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") and [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions"). When using [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique"), these methods will continue to yield the number
    of rows or objects requested, after uniquing has been applied. However, this necessarily
    impacts the buffering behavior of the underlying cursor or datasource, such that
    multiple underlying calls to `cursor.fetchmany()` may be necessary in order to
    accumulate enough objects in order to provide a unique collection of the requested
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**strategy** – a callable that will be applied to rows or objects being iterated,
    which should return an object that represents the unique value of the row. A Python
    `set()` is used to store these identities. If not passed, a default uniqueness
    strategy is used which may have been assembled by the source of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns objects other than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, such as dictionaries or scalar objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult")
    is the common base for additional result APIs including [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult"), [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") and `AsyncResult`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.FilterResult.close), [closed](#sqlalchemy.engine.FilterResult.closed),
    [yield_per()](#sqlalchemy.engine.FilterResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult")
    (`sqlalchemy.engine.ResultInternal`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Represents a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object in a “frozen” state suitable for caching.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    object is returned from the [`Result.freeze()`](#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze") method of any [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new iterable [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object is generated from a fixed set of data each time the [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult") is invoked as a callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '`merge_frozen_result()` - ORM function to merge a frozen result back into a
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that gets
    data from a Python iterator of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects or similar row-like data.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[closed](#sqlalchemy.engine.IteratorResult.closed)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult") ([`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if this [`IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult")
    has been closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that is merged
    from any number of [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Returned by the [`Result.merge()`](#sqlalchemy.engine.Result.merge "sqlalchemy.engine.Result.merge")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.MergedResult`](#sqlalchemy.engine.MergedResult "sqlalchemy.engine.MergedResult")
    ([`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Represent a set of database results.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object provides a completely updated usage model and calling facade for SQLAlchemy
    Core and SQLAlchemy ORM. In Core, it forms the basis of the [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") object which replaces the previous `ResultProxy`
    interface. When using the ORM, a higher level object called [`ChunkedIteratorResult`](#sqlalchemy.engine.ChunkedIteratorResult
    "sqlalchemy.engine.ChunkedIteratorResult") is normally used.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy 1.4 and above, this object is used for ORM results returned by
    [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute"),
    which can yield instances of ORM mapped objects either individually or within
    tuple-like rows. Note that the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object does not deduplicate instances or rows automatically as is the case with
    the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object. For in-Python de-duplication of instances or rows, use the [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") modifier method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Rows](../tutorial/dbapi_transactions.html#tutorial-fetching-rows)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.Result.all), [close()](#sqlalchemy.engine.Result.close),
    [closed](#sqlalchemy.engine.Result.closed), [columns()](#sqlalchemy.engine.Result.columns),
    [fetchall()](#sqlalchemy.engine.Result.fetchall), [fetchmany()](#sqlalchemy.engine.Result.fetchmany),
    [fetchone()](#sqlalchemy.engine.Result.fetchone), [first()](#sqlalchemy.engine.Result.first),
    [freeze()](#sqlalchemy.engine.Result.freeze), [keys()](#sqlalchemy.engine.Result.keys),
    [mappings()](#sqlalchemy.engine.Result.mappings), [merge()](#sqlalchemy.engine.Result.merge),
    [one()](#sqlalchemy.engine.Result.one), [one_or_none()](#sqlalchemy.engine.Result.one_or_none),
    [partitions()](#sqlalchemy.engine.Result.partitions), [scalar()](#sqlalchemy.engine.Result.scalar),
    [scalar_one()](#sqlalchemy.engine.Result.scalar_one), [scalar_one_or_none()](#sqlalchemy.engine.Result.scalar_one_or_none),
    [scalars()](#sqlalchemy.engine.Result.scalars), [t](#sqlalchemy.engine.Result.t),
    [tuples()](#sqlalchemy.engine.Result.tuples), [unique()](#sqlalchemy.engine.Result.unique),
    [yield_per()](#sqlalchemy.engine.Result.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    (`sqlalchemy.engine._WithKeys`, `sqlalchemy.engine.ResultInternal`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Return all rows in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set after invocation. Subsequent invocations will return an
    empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - How to stream a large result set without loading it completely in python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: close this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of this method is implementation specific, and is not implemented
    by default. The method should generally end the resources in use by the result
    object and also cause any subsequent iteration or row fetching to raise [`ResourceClosedError`](exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.27: - `.close()` was previously not generally available
    for all [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") classes,
    instead only being available on the [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") returned for Core statement executions. As most
    other result objects, namely the ones used by the ORM, are proxying a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in any case, this allows the underlying cursor
    result to be closed from the outside facade for the case when the ORM query is
    using the `yield_per` execution option where it does not immediately exhaust and
    autoclose the database cursor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: return `True` if this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports .closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be used to limit the columns returned as well as to reorder
    them. The given list of expressions are normally a series of integers or string
    key names. They may also be appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects which correspond to a given
    statement construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Due to a bug in 1.4, the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method had an incorrect behavior where calling
    upon the method with just one index would cause the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object to yield scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects. In version 2.0, this behavior has been corrected
    such that calling upon [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") with a single index will produce a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that continues to yield [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, which include only a single column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of using the column objects from the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***col_expressions** – indicates columns to be returned. Elements may be integer
    row indexes, string column names, or appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects corresponding to a select construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    with the modifications given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many rows.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch rows in groups, use the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Fetch one row.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns None.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the first row of a result only, use the [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") method. To iterate through all rows, iterate
    the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object if no filters
    are applied, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first row or `None` if no row is present.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set and discards remaining rows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in contrast to the behavior of the legacy ORM [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") method, **no limit is applied** to the SQL query
    which was invoked to produce this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result");
    for a DBAPI driver that buffers results in memory before yielding rows, all rows
    will be sent to the Python process and all but the first row will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query Unified with Core Select](../changelog/migration_20.html#migration-20-unify-select)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object, or None if
    no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Return a callable object that will produce copies of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The callable object returned is an instance of [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult").
  prefs: []
  type: TYPE_NORMAL
- en: This is used for result set caching. The method must be called on the result
    when it has been unconsumed, and calling the method will consume the result fully.
    When the [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    is retrieved from a cache, it can be called any number of times where it will
    produce a new [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object each time against its stored set of rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Apply a mappings filter to returned rows, returning an instance of [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied, fetching rows will return [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") objects instead of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Merge this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    with other compatible result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is an instance of [`MergedResult`](#sqlalchemy.engine.MergedResult
    "sqlalchemy.engine.MergedResult"), which will be composed of iterators from the
    given result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new result will use the metadata from this result object. The subsequent
    result objects must be against an identical set of result / cursor metadata, otherwise
    the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one row or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound "sqlalchemy.exc.NoResultFound")
    if the result returns no rows, or [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound"), [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound
    "sqlalchemy.exc.NoResultFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one "sqlalchemy.engine.Result.scalar_one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if the result has no rows. Raises [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") or `None`
    if no row is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of rows of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Each list will be of the size given, excluding the last list to be yielded,
    which may have a small number of rows. No empty lists will be yielded.
  prefs: []
  type: TYPE_NORMAL
- en: The result object is automatically closed when the iterator is fully consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend driver will usually buffer the entire result ahead of
    time unless the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used indicating
    that the driver should not pre-buffer results, if possible. Not all drivers support
    this option and the option is silently ignored for those who do not.
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM, the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method is typically more effective from
    a memory perspective when it is combined with use of the [yield_per execution
    option](../orm/queryguide/api.html#orm-queryguide-yield-per), which instructs
    both the DBAPI driver to use server side cursors, if available, as well as instructs
    the ORM loading internals to only build a certain amount of ORM objects from a
    result at a time before yielding them out.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size** – indicate the maximum number of rows to be present in each list yielded.
    If None, makes use of the value set by the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per"), method, if it were called, or the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which is equivalent
    in this regard. If yield_per weren’t set, it makes use of the [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") default, which may be backend specific and
    not well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: iterator of lists
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first column of the first row, and close the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if there are no rows to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: No validation is performed to test if additional rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: After calling this method, the object is fully closed, e.g. the [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") method will have been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python scalar value, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one scalar result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one scalar result or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object which will return single elements rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: When results are fetched from the [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") filtering object, the single column-row that
    would be returned by the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    is instead returned as the column’s value.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**index** – integer or row key indicating the column to be fetched from each
    row, defaults to `0` indicating the first column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") attribute
    is a synonym for calling the [`Result.tuples()`](#sqlalchemy.engine.Result.tuples
    "sqlalchemy.engine.Result.tuples") method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the same [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object at runtime, however annotates as returning a [`TupleResult`](#sqlalchemy.engine.TupleResult
    "sqlalchemy.engine.TupleResult") object that will indicate to [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools that plain typed `Tuple` instances are returned rather than rows.
    This allows tuple unpacking and `__getitem__` access of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects to by typed, for those cases where the statement
    invoked itself included typing information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the [`TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    type at typing time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") - shorter
    synonym'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") version'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied with no arguments, the rows or objects returned
    will filtered such that each row is returned uniquely. The algorithm used to determine
    this uniqueness is by default the Python hashing identity of the whole tuple.
    In some cases a specialized per-entity hashing scheme may be used, such as when
    using the ORM, a scheme is applied which works against the primary key identity
    of returned objects.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter is applied **after all other filters**, which means if the
    columns returned have been refined using a method such as the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") or [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, the uniquing is applied to **only
    the column or columns returned**. This occurs regardless of the order in which
    these methods have been called upon the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter also changes the calculus used for methods like [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") and [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions"). When using [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique"), these methods will continue to yield the number
    of rows or objects requested, after uniquing has been applied. However, this necessarily
    impacts the buffering behavior of the underlying cursor or datasource, such that
    multiple underlying calls to `cursor.fetchmany()` may be necessary in order to
    accumulate enough objects in order to provide a unique collection of the requested
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**strategy** – a callable that will be applied to rows or objects being iterated,
    which should return an object that represents the unique value of the row. A Python
    `set()` is used to store these identities. If not passed, a default uniqueness
    strategy is used which may have been assembled by the source of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns scalar values rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    object is acquired by calling the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method.
  prefs: []
  type: TYPE_NORMAL
- en: A special limitation of [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    is that it has no `fetchone()` method; since the semantics of `fetchone()` are
    that the `None` value indicates no more results, this is not compatible with [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") since there is no way to distinguish between
    `None` as a row value versus `None` as an indicator. Use `next(result)` to receive
    values individually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.ScalarResult.all), [close()](#sqlalchemy.engine.ScalarResult.close),
    [closed](#sqlalchemy.engine.ScalarResult.closed), [fetchall()](#sqlalchemy.engine.ScalarResult.fetchall),
    [fetchmany()](#sqlalchemy.engine.ScalarResult.fetchmany), [first()](#sqlalchemy.engine.ScalarResult.first),
    [one()](#sqlalchemy.engine.ScalarResult.one), [one_or_none()](#sqlalchemy.engine.ScalarResult.one_or_none),
    [partitions()](#sqlalchemy.engine.ScalarResult.partitions), [unique()](#sqlalchemy.engine.ScalarResult.unique),
    [yield_per()](#sqlalchemy.engine.ScalarResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    ([`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Return all scalar values in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.close()`](#sqlalchemy.engine.FilterResult.close
    "sqlalchemy.engine.FilterResult.close") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.closed`](#sqlalchemy.engine.FilterResult.closed
    "sqlalchemy.engine.FilterResult.closed") *attribute of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`ScalarResult.all()`](#sqlalchemy.engine.ScalarResult.all
    "sqlalchemy.engine.ScalarResult.all") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many objects.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany "sqlalchemy.engine.Result.fetchmany")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first object or `None` if no object is present.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") except that scalar values, rather than
    [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of elements of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  prefs: []
  type: TYPE_NORMAL
- en: See [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    for usage details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns dictionary values rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    object is acquired by calling the [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.MappingResult.all), [close()](#sqlalchemy.engine.MappingResult.close),
    [closed](#sqlalchemy.engine.MappingResult.closed), [columns()](#sqlalchemy.engine.MappingResult.columns),
    [fetchall()](#sqlalchemy.engine.MappingResult.fetchall), [fetchmany()](#sqlalchemy.engine.MappingResult.fetchmany),
    [fetchone()](#sqlalchemy.engine.MappingResult.fetchone), [first()](#sqlalchemy.engine.MappingResult.first),
    [keys()](#sqlalchemy.engine.MappingResult.keys), [one()](#sqlalchemy.engine.MappingResult.one),
    [one_or_none()](#sqlalchemy.engine.MappingResult.one_or_none), [partitions()](#sqlalchemy.engine.MappingResult.partitions),
    [unique()](#sqlalchemy.engine.MappingResult.unique), [yield_per()](#sqlalchemy.engine.MappingResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    (`sqlalchemy.engine._WithKeys`, [`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Return all scalar values in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.close()`](#sqlalchemy.engine.FilterResult.close
    "sqlalchemy.engine.FilterResult.close") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.closed`](#sqlalchemy.engine.FilterResult.closed
    "sqlalchemy.engine.FilterResult.closed") *attribute of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`MappingResult.all()`](#sqlalchemy.engine.MappingResult.all
    "sqlalchemy.engine.MappingResult.all") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many objects.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany "sqlalchemy.engine.Result.fetchmany")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Fetch one object.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone "sqlalchemy.engine.Result.fetchone")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first object or `None` if no object is present.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") except that [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") values, rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of elements of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: See [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    for usage details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Represent a single result row.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object represents
    a row of a database result. It is typically associated in the 1.x series of SQLAlchemy
    with the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    object, however is also used by the ORM for tuple-like results as of SQLAlchemy
    1.4.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object seeks to
    act as much like a Python named tuple as possible. For mapping (i.e. dictionary)
    behavior on a row, such as testing for containment of keys, refer to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SELECT Statements](../tutorial/data_select.html#tutorial-selecting-data)
    - includes examples of selecting rows from SELECT statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: Renamed `RowProxy` to [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is no longer a “proxy” object in that it contains the final form of data within
    it, and now acts mostly like a named tuple. Mapping-like functionality is moved
    to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")
    attribute. See [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](../changelog/migration_14.html#change-4710-core)
    for background on this change.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_asdict()](#sqlalchemy.engine.Row._asdict), [_fields](#sqlalchemy.engine.Row._fields),
    [_mapping](#sqlalchemy.engine.Row._mapping), [_t](#sqlalchemy.engine.Row._t),
    [_tuple()](#sqlalchemy.engine.Row._tuple), [count](#sqlalchemy.engine.Row.count),
    [index](#sqlalchemy.engine.Row.index), [t](#sqlalchemy.engine.Row.t), [tuple()](#sqlalchemy.engine.Row.tuple)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    (`sqlalchemy.engine._py_row.BaseRow`, `collections.abc.Sequence`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Return a new dict which maps field names to their corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: This method is analogous to the Python named tuple `._asdict()` method, and
    works by applying the `dict()` constructor to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Return a tuple of string keys as represented by this [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is analogous to the Python named tuple `._fields` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    for this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: This object provides a consistent Python mapping (i.e. dictionary) interface
    for the data contained within the row. The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    by itself behaves like a named tuple.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._fields`](#sqlalchemy.engine.Row._fields "sqlalchemy.engine.Row._fields")'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.19: - The [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t")
    attribute supersedes the previous [`Row.t`](#sqlalchemy.engine.Row.t "sqlalchemy.engine.Row.t")
    attribute, which is now underscored to avoid name conflicts with column names
    in the same way as other named-tuple methods on [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Return a ‘tuple’ form of this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, this method returns “self”; the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object is already a named tuple. However, at the typing level, if this [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") is typed, the “tuple” return type will be a [**PEP 484**](https://peps.python.org/pep-0484/)
    `Tuple` datatype that contains typing information about individual elements, supporting
    typed unpacking and attribute access.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.19: - The [`Row._tuple()`](#sqlalchemy.engine.Row._tuple
    "sqlalchemy.engine.Row._tuple") method supersedes the previous [`Row.tuple()`](#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") method, which is now underscored to avoid name
    conflicts with column names in the same way as other named-tuple methods on [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - shorthand
    attribute notation'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.tuples()`](#sqlalchemy.engine.Result.tuples "sqlalchemy.engine.Result.tuples")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0.19: The [`Row.t`](#sqlalchemy.engine.Row.t "sqlalchemy.engine.Row.t")
    attribute is deprecated in favor of [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t");
    all [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") methods and library-level
    attributes are intended to be underscored to avoid name conflicts. Please use
    [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t").'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Return a ‘tuple’ form of this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0.19: The [`Row.tuple()`](#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") method is deprecated in favor of [`Row._tuple()`](#sqlalchemy.engine.Row._tuple
    "sqlalchemy.engine.Row._tuple"); all [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    methods and library-level attributes are intended to be underscored to avoid name
    conflicts. Please use [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: A `Mapping` that maps column names and objects to [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    is available from a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") via
    the [`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")
    attribute, as well as from the iterable interface provided by the [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult") object returned by the [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    supplies Python mapping (i.e. dictionary) access to the contents of the row. This
    includes support for testing of containment of specific keys (string column names
    or objects), as well as iteration of keys, values, and items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: The [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    object replaces the mapping-like access previously provided by a database result
    row, which now seeks to behave mostly like a named tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[items()](#sqlalchemy.engine.RowMapping.items), [keys()](#sqlalchemy.engine.RowMapping.keys),
    [values()](#sqlalchemy.engine.RowMapping.values)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    (`sqlalchemy.engine._py_row.BaseRow`, `collections.abc.Mapping`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of key/value tuples for the elements in the underlying [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of ‘keys’ for string column names represented by the underlying
    [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of values for the values represented in the underlying [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that’s typed
    as returning plain Python tuples instead of rows.
  prefs: []
  type: TYPE_NORMAL
- en: Since [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") acts like a tuple
    in every way already, this class is a typing only class, regular [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is still used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    ([`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult"),
    `sqlalchemy.util.langhelpers.TypingOnly`)
  prefs: []
  type: TYPE_NORMAL
- en: Basic Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from [Engine Configuration](engines.html) that an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is created via the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: The typical usage of [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is once per particular database URL, held globally
    for the lifetime of a single application process. A single [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") manages many individual [DBAPI](../glossary.html#term-DBAPI)
    connections on behalf of the process and is intended to be called upon in a concurrent
    fashion. The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is **not** synonymous to the DBAPI `connect()` function, which represents just
    one connection resource - the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is most efficient when created just once at the module level of an application,
    not per-object or per-function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic function of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    is to provide access to a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    which can then invoke SQL statements. To emit a textual statement to the database
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    method returns a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object, and by using it in a Python context manager (e.g. the `with:` statement)
    the [`Connection.close()`](#sqlalchemy.engine.Connection.close "sqlalchemy.engine.Connection.close")
    method is automatically invoked at the end of the block. The [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), is a **proxy** object for an actual DBAPI connection.
    The DBAPI connection is retrieved from the connection pool at the point at which
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is known as [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult"), which references a DBAPI cursor and provides
    methods for fetching rows similar to that of the DBAPI cursor. The DBAPI cursor
    will be closed by the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    when all of its result rows (if any) are exhausted. A [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") that returns no rows, such as that of an UPDATE
    statement (without any returned rows), releases cursor resources immediately upon
    construction.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is closed at the end of the `with:` block, the referenced DBAPI connection is
    [released](../glossary.html#term-released) to the connection pool. From the perspective
    of the database itself, the connection pool will not actually “close” the connection
    assuming the pool has room to store this connection for the next use. When the
    connection is returned to the pool for re-use, the pooling mechanism issues a
    `rollback()` call on the DBAPI connection so that any transactional state or locks
    are removed (this is known as [Reset On Return](pooling.html#pool-reset-on-return)),
    and the connection is ready for its next use.
  prefs: []
  type: TYPE_NORMAL
- en: Our example above illustrated the execution of a textual SQL string, which should
    be invoked by using the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct to indicate that we’d like to use
    textual SQL. The [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method can of course accommodate more
    than that; see [Working with Data](../tutorial/data.html#tutorial-working-with-data)
    in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)
    for a tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Using Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section describes how to use transactions when working directly with [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects. When using the SQLAlchemy ORM, the public API for transaction control
    is via the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object, which makes usage of the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object internally. See [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Commit As You Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object always emits SQL statements within the context of a transaction block.
    The first time the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method is called to execute a SQL statement,
    this transaction is begun automatically, using a behavior known as **autobegin**.
    The transaction remains in place for the scope of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object until the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods are called. Subsequent to the
    transaction ending, the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    waits for the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute "sqlalchemy.engine.Connection.execute")
    method to be called again, at which point it autobegins again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This calling style is known as **commit as you go**, and is illustrated in
    the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'In “commit as you go” style, we can call upon [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods freely within an ongoing sequence
    of other statements emitted using [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"); each time the transaction is ended, and
    a new statement is emitted, a new transaction begins implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: “commit as you go” style is a new feature of SQLAlchemy
    2.0\. It is also available in SQLAlchemy 1.4’s “transitional” mode when using
    a “future” style engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Begin Once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object provides a more explicit transaction management style known as **begin
    once**. In contrast to “commit as you go”, “begin once” allows the start point
    of the transaction to be stated explicitly, and allows that the transaction itself
    may be framed out as a context manager block so that the end of the transaction
    is instead implicit. To use “begin once”, the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is used, which returns a [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object which represents the DBAPI transaction.
    This object also supports explicit management via its own [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") and [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") methods, but as a preferred practice
    also supports the context manager interface, where it will commit itself when
    the block ends normally and emit a rollback if an exception is raised, before
    propagating the exception outwards. Below illustrates the form of a “begin once”
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Connect and Begin Once from the Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A convenient shorthand form for the above “begin once” block is to use the
    [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    method at the level of the originating [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, rather than performing the two separate steps of [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") and [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"); the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method returns a special context manager that
    internally maintains both the context manager for the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the context manager for the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") normally returned by the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    block, we can call upon the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which will end the transaction
    normally demarcated by the block ahead of time. However, if we do so, no further
    SQL operations may be emitted on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") until the block ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Mixing Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “commit as you go” and “begin once” styles can be freely mixed within a
    single [`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    block, provided that the call to [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") does not conflict with the “autobegin” behavior.
    To accomplish this, [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") should only be called either before any
    SQL statements have been emitted, or directly after a previous call to [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: When developing code that uses “begin once”, the library will raise [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if a transaction was already “autobegun”.
  prefs: []
  type: TYPE_NORMAL
- en: Commit As You Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object always emits SQL statements within the context of a transaction block.
    The first time the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method is called to execute a SQL statement,
    this transaction is begun automatically, using a behavior known as **autobegin**.
    The transaction remains in place for the scope of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object until the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods are called. Subsequent to the
    transaction ending, the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    waits for the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute "sqlalchemy.engine.Connection.execute")
    method to be called again, at which point it autobegins again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This calling style is known as **commit as you go**, and is illustrated in
    the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'In “commit as you go” style, we can call upon [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods freely within an ongoing sequence
    of other statements emitted using [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"); each time the transaction is ended, and
    a new statement is emitted, a new transaction begins implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: “commit as you go” style is a new feature of SQLAlchemy
    2.0\. It is also available in SQLAlchemy 1.4’s “transitional” mode when using
    a “future” style engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Begin Once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object provides a more explicit transaction management style known as **begin
    once**. In contrast to “commit as you go”, “begin once” allows the start point
    of the transaction to be stated explicitly, and allows that the transaction itself
    may be framed out as a context manager block so that the end of the transaction
    is instead implicit. To use “begin once”, the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is used, which returns a [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object which represents the DBAPI transaction.
    This object also supports explicit management via its own [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") and [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") methods, but as a preferred practice
    also supports the context manager interface, where it will commit itself when
    the block ends normally and emit a rollback if an exception is raised, before
    propagating the exception outwards. Below illustrates the form of a “begin once”
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Connect and Begin Once from the Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A convenient shorthand form for the above “begin once” block is to use the
    [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    method at the level of the originating [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, rather than performing the two separate steps of [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") and [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"); the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") method returns a special context manager that
    internally maintains both the context manager for the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the context manager for the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") normally returned by the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the [`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    block, we can call upon the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which will end the transaction
    normally demarcated by the block ahead of time. However, if we do so, no further
    SQL operations may be emitted on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") until the block ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Mixing Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “commit as you go” and “begin once” styles can be freely mixed within a
    single [`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    block, provided that the call to [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") does not conflict with the “autobegin” behavior.
    To accomplish this, [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") should only be called either before any
    SQL statements have been emitted, or directly after a previous call to [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: When developing code that uses “begin once”, the library will raise [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if a transaction was already “autobegun”.
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting Transaction Isolation Levels including DBAPI Autocommit'
  prefs: []
  type: TYPE_NORMAL
- en: Most DBAPIs support the concept of configurable transaction [isolation](../glossary.html#term-isolation)
    levels. These are traditionally the four levels “READ UNCOMMITTED”, “READ COMMITTED”,
    “REPEATABLE READ” and “SERIALIZABLE”. These are usually applied to a DBAPI connection
    before it begins a new transaction, noting that most DBAPIs will begin this transaction
    implicitly when SQL statements are first emitted.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that support isolation levels also usually support the concept of true
    “autocommit”, which means that the DBAPI connection itself will be placed into
    a non-transactional autocommit mode. This usually means that the typical DBAPI
    behavior of emitting “BEGIN” to the database automatically no longer occurs, but
    it may also include other directives. SQLAlchemy treats the concept of “autocommit”
    like any other isolation level; in that it is an isolation level that loses not
    only “read committed” but also loses atomicity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, as will be discussed further in the section below at
    [Understanding the DBAPI-Level Autocommit Isolation Level](#dbapi-autocommit-understanding),
    that “autocommit” isolation level like any other isolation level does **not**
    affect the “transactional” behavior of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, which continues to call upon DBAPI `.commit()`
    and `.rollback()` methods (they just have no effect under autocommit), and for
    which the `.begin()` method assumes the DBAPI will start a transaction implicitly
    (which means that SQLAlchemy’s “begin” **does not change autocommit mode**).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy dialects should support these isolation levels as well as autocommit
    to as great a degree as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for a Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object that’s acquired from [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect"), the isolation level can be set for the duration
    of that [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method. The parameter is known
    as [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") and the values are strings which
    are typically a subset of the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Not every DBAPI supports every value; if an unsupported value is used for a
    certain backend, an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to force REPEATABLE READ on a specific connection, then begin
    a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method is the same [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object upon which the method was called, meaning,
    it modifies the state of the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object in place. This is a new behavior as of SQLAlchemy 2.0. This behavior does
    not apply to the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method; that method still returns
    a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and as described below may be used to construct multiple [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects with different execution options, which nonetheless
    share the same dialect and connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter necessarily does not
    apply to statement level options, such as that of [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), and will be rejected
    if set at this level. This because the option must be set on a DBAPI connection
    on a per-transaction basis.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for an Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") option may also be set engine
    wide, as is often preferable. This may be achieved by passing the [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter to `create_engine()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, each new DBAPI connection the moment it’s created will
    be set to use a `"REPEATABLE READ"` isolation level setting for all subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Maintaining Multiple Isolation Levels for a Single Engine'
  prefs: []
  type: TYPE_NORMAL
- en: 'The isolation level may also be set per engine, with a potentially greater
    level of flexibility, using either the [`create_engine.execution_options`](engines.html#sqlalchemy.create_engine.params.execution_options
    "sqlalchemy.create_engine") parameter to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") or the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, the latter of which will
    create a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that shares the dialect and connection pool of the original engine, but has its
    own per-connection isolation level setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, the DBAPI connection will be set to use a `"REPEATABLE
    READ"` isolation level setting for each new transaction begun; but the connection
    as pooled will be reset to the original isolation level that was present when
    the connection first occurred. At the level of [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), the end effect is not any different from using the
    [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an application that frequently chooses to run operations within different
    isolation levels may wish to create multiple “sub-engines” of a lead [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), each of which will be configured to a different isolation
    level. One such use case is an application that has operations that break into
    “transactional” and “read-only” operations, a separate [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that makes use of `"AUTOCOMMIT"` may be separated
    off from the main engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method creates a shallow copy of
    the original [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    Both `eng` and `autocommit_engine` share the same dialect and connection pool.
    However, the “AUTOCOMMIT” mode will be set upon connections when they are acquired
    from the `autocommit_engine`.
  prefs: []
  type: TYPE_NORMAL
- en: The isolation level setting, regardless of which one it is, is unconditionally
    reverted when a connection is returned to the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Transaction Isolation](../dialects/sqlite.html#sqlite-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Transaction Isolation](../dialects/postgresql.html#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL Transaction Isolation](../dialects/mysql.html#mysql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Server Transaction Isolation](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Transaction Isolation](../dialects/oracle.html#oracle-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation)
    - for the ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect](../faq/connections.html#faq-execute-retry-autocommit)
    - a recipe that uses DBAPI autocommit to transparently reconnect to the database
    for read-only operations  ### Understanding the DBAPI-Level Autocommit Isolation
    Level'
  prefs: []
  type: TYPE_NORMAL
- en: In the parent section, we introduced the concept of the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter and how it can be
    used to set database isolation levels, including DBAPI-level “autocommit” which
    is treated by SQLAlchemy as another transaction isolation level. In this section
    we will attempt to clarify the implications of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to check out a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object and use it “autocommit” mode, we would proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Above illustrates normal usage of “DBAPI autocommit” mode. There is no need
    to make use of methods such as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") or [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit"), as all statements are committed to the
    database immediately. When the block ends, the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object will revert the “autocommit” isolation
    level, and the DBAPI connection is released to the connection pool where the DBAPI
    `connection.rollback()` method will normally be invoked, but as the above statements
    were already committed, this rollback has no change on the state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that “autocommit” mode persists even when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called; the DBAPI will not emit
    any BEGIN to the database, nor will it emit COMMIT when [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") is called. This usage is also not an error
    scenario, as it is expected that the “autocommit” isolation level may be applied
    to code that otherwise was written assuming a transactional context; the “isolation
    level” is, after all, a configurational detail of the transaction itself just
    like any other isolation level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, statements remain **autocommitting** regardless of SQLAlchemy-level
    transaction blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run a block like the above with logging turned on, the logging will
    attempt to indicate that while a DBAPI level `.commit()` is called, it probably
    will have no effect due to autocommit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, even though we are using “DBAPI autocommit”, SQLAlchemy’s
    transactional semantics, that is, the in-Python behavior of [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") as well as the behavior of “autobegin”,
    **remain in place, even though these don’t impact the DBAPI connection itself**.
    To illustrate, the code below will raise an error, as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") is being called after autobegin has already
    occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: The above example also demonstrates the same theme that the “autocommit” isolation
    level is a configurational detail of the underlying database transaction, and
    is independent of the begin/commit behavior of the SQLAlchemy Connection object.
    The “autocommit” mode will not interact with [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") in any way and the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") does not consult this status when performing its
    own state changes with regards to the transaction (with the exception of suggesting
    within engine logging that these blocks are not actually committing). The rationale
    for this design is to maintain a completely consistent usage pattern with the
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") where
    DBAPI-autocommit mode can be changed independently without indicating any code
    changes elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Between Isolation Levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Isolation level settings, including autocommit mode, are reset automatically
    when the connection is released back to the connection pool. Therefore it is preferable
    to avoid trying to switch isolation levels on a single [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as this leads to excess verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use “autocommit” in an ad-hoc mode within the scope of
    a single [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkout, the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter must be re-applied
    with the previous isolation level. The previous section illustrated an attempt
    to call [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    in order to start a transaction while autocommit was taking place; we can rewrite
    that example to actually do so by first reverting the isolation level before we
    call upon [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Above, to manually revert the isolation level we made use of [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") to restore the default
    isolation level (assuming that’s what we want here). However, it’s probably a
    better idea to work with the architecture of of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which already handles resetting of isolation level
    automatically upon checkin. The **preferred** way to write the above is to use
    two blocks
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: “DBAPI level autocommit” isolation level is entirely independent of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object’s notion of “begin” and “commit”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: use individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkouts per isolation level. Avoid trying to change back and forth between “autocommit”
    on a single connection checkout; let the engine do the work of restoring default
    isolation levels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for a Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object that’s acquired from [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect"), the isolation level can be set for the duration
    of that [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method. The parameter is known
    as [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") and the values are strings which
    are typically a subset of the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Not every DBAPI supports every value; if an unsupported value is used for a
    certain backend, an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to force REPEATABLE READ on a specific connection, then begin
    a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method is the same [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object upon which the method was called, meaning,
    it modifies the state of the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object in place. This is a new behavior as of SQLAlchemy 2.0. This behavior does
    not apply to the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method; that method still returns
    a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and as described below may be used to construct multiple [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects with different execution options, which nonetheless
    share the same dialect and connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter necessarily does not
    apply to statement level options, such as that of [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), and will be rejected
    if set at this level. This because the option must be set on a DBAPI connection
    on a per-transaction basis.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Isolation Level or DBAPI Autocommit for an Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") option may also be set engine
    wide, as is often preferable. This may be achieved by passing the [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter to `create_engine()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, each new DBAPI connection the moment it’s created will
    be set to use a `"REPEATABLE READ"` isolation level setting for all subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Maintaining Multiple Isolation Levels for a Single Engine'
  prefs: []
  type: TYPE_NORMAL
- en: 'The isolation level may also be set per engine, with a potentially greater
    level of flexibility, using either the [`create_engine.execution_options`](engines.html#sqlalchemy.create_engine.params.execution_options
    "sqlalchemy.create_engine") parameter to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") or the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method, the latter of which will
    create a copy of the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that shares the dialect and connection pool of the original engine, but has its
    own per-connection isolation level setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: With the above setting, the DBAPI connection will be set to use a `"REPEATABLE
    READ"` isolation level setting for each new transaction begun; but the connection
    as pooled will be reset to the original isolation level that was present when
    the connection first occurred. At the level of [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), the end effect is not any different from using the
    [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an application that frequently chooses to run operations within different
    isolation levels may wish to create multiple “sub-engines” of a lead [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), each of which will be configured to a different isolation
    level. One such use case is an application that has operations that break into
    “transactional” and “read-only” operations, a separate [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that makes use of `"AUTOCOMMIT"` may be separated
    off from the main engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method creates a shallow copy of
    the original [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    Both `eng` and `autocommit_engine` share the same dialect and connection pool.
    However, the “AUTOCOMMIT” mode will be set upon connections when they are acquired
    from the `autocommit_engine`.
  prefs: []
  type: TYPE_NORMAL
- en: The isolation level setting, regardless of which one it is, is unconditionally
    reverted when a connection is returned to the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Transaction Isolation](../dialects/sqlite.html#sqlite-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Transaction Isolation](../dialects/postgresql.html#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL Transaction Isolation](../dialects/mysql.html#mysql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Server Transaction Isolation](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Transaction Isolation](../dialects/oracle.html#oracle-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation)
    - for the ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using DBAPI Autocommit Allows for a Readonly Version of Transparent Reconnect](../faq/connections.html#faq-execute-retry-autocommit)
    - a recipe that uses DBAPI autocommit to transparently reconnect to the database
    for read-only operations'
  prefs: []
  type: TYPE_NORMAL
- en: '### Understanding the DBAPI-Level Autocommit Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: In the parent section, we introduced the concept of the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter and how it can be
    used to set database isolation levels, including DBAPI-level “autocommit” which
    is treated by SQLAlchemy as another transaction isolation level. In this section
    we will attempt to clarify the implications of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to check out a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object and use it “autocommit” mode, we would proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Above illustrates normal usage of “DBAPI autocommit” mode. There is no need
    to make use of methods such as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") or [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit"), as all statements are committed to the
    database immediately. When the block ends, the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object will revert the “autocommit” isolation
    level, and the DBAPI connection is released to the connection pool where the DBAPI
    `connection.rollback()` method will normally be invoked, but as the above statements
    were already committed, this rollback has no change on the state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that “autocommit” mode persists even when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called; the DBAPI will not emit
    any BEGIN to the database, nor will it emit COMMIT when [`Connection.commit()`](#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") is called. This usage is also not an error
    scenario, as it is expected that the “autocommit” isolation level may be applied
    to code that otherwise was written assuming a transactional context; the “isolation
    level” is, after all, a configurational detail of the transaction itself just
    like any other isolation level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, statements remain **autocommitting** regardless of SQLAlchemy-level
    transaction blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run a block like the above with logging turned on, the logging will
    attempt to indicate that while a DBAPI level `.commit()` is called, it probably
    will have no effect due to autocommit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, even though we are using “DBAPI autocommit”, SQLAlchemy’s
    transactional semantics, that is, the in-Python behavior of [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") as well as the behavior of “autobegin”,
    **remain in place, even though these don’t impact the DBAPI connection itself**.
    To illustrate, the code below will raise an error, as [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") is being called after autobegin has already
    occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: The above example also demonstrates the same theme that the “autocommit” isolation
    level is a configurational detail of the underlying database transaction, and
    is independent of the begin/commit behavior of the SQLAlchemy Connection object.
    The “autocommit” mode will not interact with [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") in any way and the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") does not consult this status when performing its
    own state changes with regards to the transaction (with the exception of suggesting
    within engine logging that these blocks are not actually committing). The rationale
    for this design is to maintain a completely consistent usage pattern with the
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") where
    DBAPI-autocommit mode can be changed independently without indicating any code
    changes elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Between Isolation Levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Isolation level settings, including autocommit mode, are reset automatically
    when the connection is released back to the connection pool. Therefore it is preferable
    to avoid trying to switch isolation levels on a single [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as this leads to excess verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use “autocommit” in an ad-hoc mode within the scope of
    a single [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkout, the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter must be re-applied
    with the previous isolation level. The previous section illustrated an attempt
    to call [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    in order to start a transaction while autocommit was taking place; we can rewrite
    that example to actually do so by first reverting the isolation level before we
    call upon [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Above, to manually revert the isolation level we made use of [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") to restore the default
    isolation level (assuming that’s what we want here). However, it’s probably a
    better idea to work with the architecture of of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which already handles resetting of isolation level
    automatically upon checkin. The **preferred** way to write the above is to use
    two blocks
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: “DBAPI level autocommit” isolation level is entirely independent of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object’s notion of “begin” and “commit”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: use individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkouts per isolation level. Avoid trying to change back and forth between “autocommit”
    on a single connection checkout; let the engine do the work of restoring default
    isolation levels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing Between Isolation Levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Isolation level settings, including autocommit mode, are reset automatically
    when the connection is released back to the connection pool. Therefore it is preferable
    to avoid trying to switch isolation levels on a single [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object as this leads to excess verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use “autocommit” in an ad-hoc mode within the scope of
    a single [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkout, the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter must be re-applied
    with the previous isolation level. The previous section illustrated an attempt
    to call [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    in order to start a transaction while autocommit was taking place; we can rewrite
    that example to actually do so by first reverting the isolation level before we
    call upon [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Above, to manually revert the isolation level we made use of [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") to restore the default
    isolation level (assuming that’s what we want here). However, it’s probably a
    better idea to work with the architecture of of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which already handles resetting of isolation level
    automatically upon checkin. The **preferred** way to write the above is to use
    two blocks
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: “DBAPI level autocommit” isolation level is entirely independent of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object’s notion of “begin” and “commit”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: use individual [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    checkouts per isolation level. Avoid trying to change back and forth between “autocommit”
    on a single connection checkout; let the engine do the work of restoring default
    isolation levels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '## Using Server Side Cursors (a.k.a. stream results)'
  prefs: []
  type: TYPE_NORMAL
- en: Some backends feature explicit support for the concept of “server side cursors”
    versus “client side cursors”. A client side cursor here means that the database
    driver fully fetches all rows from a result set into memory before returning from
    a statement execution. Drivers such as those of PostgreSQL and MySQL/MariaDB generally
    use client side cursors by default. A server side cursor, by contrast, indicates
    that result rows remain pending within the database server’s state as result rows
    are consumed by the client. The drivers for Oracle generally use a “server side”
    model, for example, and the SQLite dialect, while not using a real “client / server”
    architecture, still uses an unbuffered result fetching approach that will leave
    result rows outside of process memory before they are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: From this basic architecture it follows that a “server side cursor” is more
    memory efficient when fetching very large result sets, while at the same time
    may introduce more complexity in the client/server communication process and be
    less efficient for small result sets (typically less than 10000 rows).
  prefs: []
  type: TYPE_NORMAL
- en: For those dialects that have conditional support for buffered or unbuffered
    results, there are usually caveats to the use of the “unbuffered”, or server side
    cursor mode. When using the psycopg2 dialect for example, an error is raised if
    a server side cursor is used with any kind of DML or DDL statement. When using
    MySQL drivers with a server side cursor, the DBAPI connection is in a more fragile
    state and does not recover as gracefully from error conditions nor will it allow
    a rollback to proceed until the cursor is fully closed.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, SQLAlchemy’s dialects will always default to the less error
    prone version of a cursor, which means for PostgreSQL and MySQL dialects it defaults
    to a buffered, “client side” cursor where the full set of results is pulled into
    memory before any fetch methods are called from the cursor. This mode of operation
    is appropriate in the **vast majority** of cases; unbuffered cursors are not generally
    useful except in the uncommon case of an application fetching a very large number
    of rows in chunks, where the processing of these rows can be complete before more
    rows are fetched.
  prefs: []
  type: TYPE_NORMAL
- en: For database drivers that provide client and server side cursor options, the
    [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") and [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution options provide access
    to “server side cursors” on a per-[`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or per-statement basis. Similar options exist
    when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming with a fixed buffer via yield_per
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As individual row-fetch operations with fully unbuffered server side cursors
    are typically more expensive than fetching batches of rows at once, The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option configures
    a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or statement to make use of server-side cursors as are available, while at the
    same time configuring a fixed-size buffer of rows that will retrieve rows from
    the server in batches as they are consumed. This parameter may be to a positive
    integer value using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method on [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or on a statement using the [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core-only option is new
    as of SQLAlchemy 1.4.40; for prior 1.4 versions, use [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") directly in combination with
    [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this option is equivalent to manually setting the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option, described in the next
    section, and then invoking the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method on the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object with the given integer value. In both cases,
    the effect this combination has includes:'
  prefs: []
  type: TYPE_NORMAL
- en: server side cursors mode is selected for the given backend, if available and
    not already the default behavior for that backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as result rows are fetched, they will be buffered in batches, where the size
    of each batch up until the last batch will be equal to the integer argument passed
    to the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option or the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method; the last batch is then sized against
    the remaining rows fewer than this size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default partition size used by the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method, if used, will be made equal to
    this integer size as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three behaviors are illustrated in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: The above example illustrates the combination of `yield_per=100` along with
    using the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method to run processing on rows in batches that match the size fetched from the
    server. The use of [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") is optional, and if the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is iterated directly, a new batch of rows will be
    buffered for each 100 rows fetched. Calling a method such as [`Result.all()`](#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all") should **not** be used, as this will fully fetch
    all remaining rows at once and defeat the purpose of using `yield_per`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    may be used as a context manager as illustrated above. When iterating with a server-side
    cursor, this is the best way to ensure the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object is closed, even if exceptions are raised within
    the iteration process.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option is portable to the ORM
    as well, used by a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to fetch ORM objects, where it also limits the amount
    of ORM objects generated at once. See the section [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per) - in the
    [ORM Querying Guide](../orm/queryguide/index.html) for further background on using
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core level execution option
    to conveniently set streaming results, buffer size, and partition size all at
    once in a manner that is transferrable to that of the ORM’s similar use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Streaming with a dynamically growing buffer using stream_results'
  prefs: []
  type: TYPE_NORMAL
- en: To enable server side cursors without a specific partition size, the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be used, which like
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") may be called on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object or the statement object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    delivered using the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option is iterated directly,
    rows are fetched internally using a default buffering scheme that buffers first
    a small set of rows, then a larger and larger buffer on each fetch up to a pre-configured
    limit of 1000 rows. The maximum size of this buffer can be affected using the
    [`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options") execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: While the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be combined with
    use of the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method, a specific partition size should be passed to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") so that the entire result is not fetched.
    It is usually more straightforward to use the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option when setting up to use
    the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming with a fixed buffer via yield_per
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As individual row-fetch operations with fully unbuffered server side cursors
    are typically more expensive than fetching batches of rows at once, The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option configures
    a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or statement to make use of server-side cursors as are available, while at the
    same time configuring a fixed-size buffer of rows that will retrieve rows from
    the server in batches as they are consumed. This parameter may be to a positive
    integer value using the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method on [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or on a statement using the [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core-only option is new
    as of SQLAlchemy 1.4.40; for prior 1.4 versions, use [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") directly in combination with
    [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this option is equivalent to manually setting the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option, described in the next
    section, and then invoking the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method on the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object with the given integer value. In both cases,
    the effect this combination has includes:'
  prefs: []
  type: TYPE_NORMAL
- en: server side cursors mode is selected for the given backend, if available and
    not already the default behavior for that backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as result rows are fetched, they will be buffered in batches, where the size
    of each batch up until the last batch will be equal to the integer argument passed
    to the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option or the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method; the last batch is then sized against
    the remaining rows fewer than this size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default partition size used by the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method, if used, will be made equal to
    this integer size as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three behaviors are illustrated in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: The above example illustrates the combination of `yield_per=100` along with
    using the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method to run processing on rows in batches that match the size fetched from the
    server. The use of [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") is optional, and if the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is iterated directly, a new batch of rows will be
    buffered for each 100 rows fetched. Calling a method such as [`Result.all()`](#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all") should **not** be used, as this will fully fetch
    all remaining rows at once and defeat the purpose of using `yield_per`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    may be used as a context manager as illustrated above. When iterating with a server-side
    cursor, this is the best way to ensure the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object is closed, even if exceptions are raised within
    the iteration process.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option is portable to the ORM
    as well, used by a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to fetch ORM objects, where it also limits the amount
    of ORM objects generated at once. See the section [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per) - in the
    [ORM Querying Guide](../orm/queryguide/index.html) for further background on using
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") as a Core level execution option
    to conveniently set streaming results, buffer size, and partition size all at
    once in a manner that is transferrable to that of the ORM’s similar use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Streaming with a dynamically growing buffer using stream_results'
  prefs: []
  type: TYPE_NORMAL
- en: To enable server side cursors without a specific partition size, the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be used, which like
    [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") may be called on the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object or the statement object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    delivered using the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option is iterated directly,
    rows are fetched internally using a default buffering scheme that buffers first
    a small set of rows, then a larger and larger buffer on each fetch up to a pre-configured
    limit of 1000 rows. The maximum size of this buffer can be affected using the
    [`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options") execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: While the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") option may be combined with
    use of the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method, a specific partition size should be passed to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") so that the entire result is not fetched.
    It is usually more straightforward to use the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") option when setting up to use
    the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '## Translation of Schema Names'
  prefs: []
  type: TYPE_NORMAL
- en: To support multi-tenancy applications that distribute common sets of tables
    into multiple schemas, the [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") execution option may be used
    to repurpose a set of [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects to render under different schema names without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'The “schema” of this [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    as defined by the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") attribute is `None`. The [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") can specify that all [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects with a schema of `None` would instead render
    the schema as `user_schema_one`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code will invoke SQL on the database of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the schema name is substituted with our translated name. The map can
    specify any number of target->destination schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: The [`Connection.execution_options.schema_translate_map`](#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") parameter affects all DDL and
    SQL constructs generated from the SQL expression language, as derived from the
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") or
    [`Sequence`](defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    objects. It does **not** impact literal string SQL used via the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct nor via plain strings passed to [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute").
  prefs: []
  type: TYPE_NORMAL
- en: The feature takes effect **only** in those cases where the name of the schema
    is derived directly from that of a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or [`Sequence`](defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence"); it does not impact methods where a string schema
    name is passed directly. By this pattern, it takes effect within the “can create”
    / “can drop” checks performed by methods such as [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") are called, and it takes effect when using
    table reflection given a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object. However it does **not** affect the operations present on the [`Inspector`](reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object, as the schema name is passed
    to these methods explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the schema translation feature with the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), set this option at the level of the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then pass that engine to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") uses a new [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for each transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without extensions, the schema translate feature is
    only supported as **a single schema translate map per Session**. It will **not
    work** if different schema translate maps are given on a per-statement basis,
    as the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    does not take current schema translate values into account for individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: To use a single [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with multiple `schema_translate_map` configurations, the [Horizontal Sharding](../orm/extensions/horizontal_shard.html)
    extension may be used. See the example at [Horizontal Sharding](../orm/examples.html#examples-sharding).
  prefs: []
  type: TYPE_NORMAL
- en: '## SQL Compilation Caching'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: SQLAlchemy now has a transparent query caching system that
    substantially lowers the Python computational overhead involved in converting
    SQL statement constructs into SQL strings across both Core and ORM. See the introduction
    at [Transparent SQL Compilation Caching added to All DQL, DML Statements in Core,
    ORM](../changelog/migration_14.html#change-4639).'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy includes a comprehensive caching system for the SQL compiler as
    well as its ORM variants. This caching system is transparent within the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and provides that the SQL compilation process for
    a given Core or ORM SQL statement, as well as related computations which assemble
    result-fetching mechanics for that statement, will only occur once for that statement
    object and all others with the identical structure, for the duration that the
    particular structure remains within the engine’s “compiled cache”. By “statement
    objects that have the identical structure”, this generally corresponds to a SQL
    statement that is constructed within a function and is built each time that function
    runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: The above statement will generate SQL resembling `SELECT id, col FROM table
    WHERE col = :col ORDER BY id`, noting that while the value of `parameter` is a
    plain Python object such as a string or an integer, the string SQL form of the
    statement does not include this value as it uses bound parameters. Subsequent
    invocations of the above `run_my_statement()` function will use a cached compilation
    construct within the scope of the `connection.execute()` call for enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: it is important to note that the SQL compilation cache is caching the **SQL
    string that is passed to the database only**, and **not the data** returned by
    a query. It is in no way a data cache and does not impact the results returned
    for a particular SQL statement nor does it imply any memory use linked to fetching
    of result rows.
  prefs: []
  type: TYPE_NORMAL
- en: While SQLAlchemy has had a rudimentary statement cache since the early 1.x series,
    and additionally has featured the “Baked Query” extension for the ORM, both of
    these systems required a high degree of special API use in order for the cache
    to be effective. The new cache as of 1.4 is instead completely automatic and requires
    no change in programming style to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: The cache is automatically used without any configurational changes and no special
    steps are needed in order to enable it. The following sections detail the configuration
    and advanced usage patterns for the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The cache itself is a dictionary-like object called an `LRUCache`, which is
    an internal SQLAlchemy dictionary subclass that tracks the usage of particular
    keys and features a periodic “pruning” step which removes the least recently used
    items when the size of the cache reaches a certain threshold. The size of this
    cache defaults to 500 and may be configured using the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: The size of the cache can grow to be a factor of 150% of the size given, before
    it’s pruned back down to the target size. A cache of size 1200 above can therefore
    grow to be 1800 elements in size at which point it will be pruned to 1200.
  prefs: []
  type: TYPE_NORMAL
- en: The sizing of the cache is based on a single entry per unique SQL statement
    rendered, per engine. SQL statements generated from both the Core and the ORM
    are treated equally. DDL statements will usually not be cached. In order to determine
    what the cache is doing, engine logging will include details about the cache’s
    behavior, described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '### Estimating Cache Performance Using Logging'
  prefs: []
  type: TYPE_NORMAL
- en: The above cache size of 1200 is actually fairly large. For small applications,
    a size of 100 is likely sufficient. To estimate the optimal size of the cache,
    assuming enough memory is present on the target host, the size of the cache should
    be based on the number of unique SQL strings that may be rendered for the target
    engine in use. The most expedient way to see this is to use SQL echoing, which
    is most directly enabled by using the [`create_engine.echo`](engines.html#sqlalchemy.create_engine.params.echo
    "sqlalchemy.create_engine") flag, or by using Python logging; see the section
    [Configuring Logging](engines.html#dbengine-logging) for background on logging
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will examine the logging produced by the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, each SQL statement that’s logged will include a bracketed cache statistics
    badge to the left of the parameters passed. The four types of message we may see
    are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[raw sql]` - the driver or the end-user emitted raw SQL using [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") - caching does not apply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[no key]` - the statement object is a DDL statement that is not cached, or
    the statement object contains uncacheable elements such as user-defined constructs
    or arbitrarily large VALUES clauses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[generated in Xs]` - the statement was a **cache miss** and had to be compiled,
    then stored in the cache. it took X seconds to produce the compiled construct.
    The number X will be in the small fractional seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[cached since Xs ago]` - the statement was a **cache hit** and did not have
    to be recompiled. The statement has been stored in the cache since X seconds ago.
    The number X will be proportional to how long the application has been running
    and how long the statement has been cached, so for example would be 86400 for
    a 24 hour period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each badge is described in more detail below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first statements we see for the above program will be the SQLite dialect
    checking for the existence of the “a” and “b” tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: For the above two SQLite PRAGMA statements, the badge reads `[raw sql]`, which
    indicates the driver is sending a Python string directly to the database using
    [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql"). Caching does not apply to such
    statements because they already exist in string form, and there is nothing known
    about what kinds of result rows will be returned since SQLAlchemy does not parse
    SQL strings ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statements we see are the CREATE TABLE statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: For each of these statements, the badge reads `[no key 0.00006s]`. This indicates
    that these two particular statements, caching did not occur because the DDL-oriented
    [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable")
    construct did not produce a cache key. DDL constructs generally do not participate
    in caching because they are not typically subject to being repeated a second time
    and DDL is also a database configurational step where performance is not as critical.
  prefs: []
  type: TYPE_NORMAL
- en: The `[no key]` badge is important for one other reason, as it can be produced
    for SQL statements that are cacheable except for some particular sub-construct
    that is not currently cacheable. Examples of this include custom user-defined
    SQL elements that don’t define caching parameters, as well as some constructs
    that generate arbitrarily long and non-reproducible SQL strings, the main examples
    being the [`Values`](selectable.html#sqlalchemy.sql.expression.Values "sqlalchemy.sql.expression.Values")
    construct as well as when using “multivalued inserts” with the [`Insert.values()`](dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far our cache is still empty. The next statements will be cached however,
    a segment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see essentially two unique SQL strings; `"INSERT INTO a (data) VALUES
    (?)"` and `"INSERT INTO b (a_id, data) VALUES (?, ?)"`. Since SQLAlchemy uses
    bound parameters for all literal values, even though these statements are repeated
    many times for different objects, because the parameters are separate, the actual
    SQL string stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: the above two statements are generated by the ORM unit of work process, and
    in fact will be caching these in a separate cache that is local to each mapper.
    However the mechanics and terminology are the same. The section [Disabling or
    using an alternate dictionary to cache some (or all) statements](#engine-compiled-cache)
    below will describe how user-facing code can also use an alternate caching container
    on a per-statement basis.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge we see for the first occurrence of each of these two statements
    is `[generated in 0.00011s]`. This indicates that the statement was **not in the
    cache, was compiled into a String in .00011s and was then cached**. When we see
    the `[generated]` badge, we know that this means there was a **cache miss**. This
    is to be expected for the first occurrence of a particular statement. However,
    if lots of new `[generated]` badges are observed for a long-running application
    that is generally using the same series of SQL statements over and over, this
    may be a sign that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter is too small. When a statement that was
    cached is then evicted from the cache due to the LRU cache pruning lesser used
    items, it will display the `[generated]` badge when it is next used.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge that we then see for the subsequent occurrences of each of
    these two statements looks like `[cached since 0.0003533s ago]`. This indicates
    that the statement **was found in the cache, and was originally placed into the
    cache .0003533 seconds ago**. It is important to note that while the `[generated]`
    and `[cached since]` badges refer to a number of seconds, they mean different
    things; in the case of `[generated]`, the number is a rough timing of how long
    it took to compile the statement, and will be an extremely small amount of time.
    In the case of `[cached since]`, this is the total time that a statement has been
    present in the cache. For an application that’s been running for six hours, this
    number may read `[cached since 21600 seconds ago]`, and that’s a good thing. Seeing
    high numbers for “cached since” is an indication that these statements have not
    been subject to cache misses for a long time. Statements that frequently have
    a low number of “cached since” even if the application has been running a long
    time may indicate these statements are too frequently subject to cache misses,
    and that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") may need to be increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example program then performs some SELECTs where we can see the same pattern
    of “generated” then “cached”, for the SELECT of the “a” table as well as for subsequent
    lazy loads of the “b” table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: From our above program, a full run shows a total of four distinct SQL strings
    being cached. Which indicates a cache size of **four** would be sufficient. This
    is obviously an extremely small size, and the default size of 500 is fine to be
    left at its default.
  prefs: []
  type: TYPE_NORMAL
- en: How much memory does the cache use?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section detailed some techniques to check if the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") needs to be bigger. How do we know if the cache is
    not too large? The reason we may want to set [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") to not be higher than a certain number would be because
    we have an application that may make use of a very large number of different statements,
    such as an application that is building queries on the fly from a search UX, and
    we don’t want our host to run out of memory if for example, a hundred thousand
    different queries were run in the past 24 hours and they were all cached.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely difficult to measure how much memory is occupied by Python data
    structures, however using a process to measure growth in memory via `top` as a
    successive series of 250 new statements are added to the cache suggest a moderate
    Core statement takes up about 12K while a small ORM statement takes about 20K,
    including result-fetching structures which for the ORM will be much greater.
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling or using an alternate dictionary to cache some (or all) statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal cache used is known as `LRUCache`, but this is mostly just a dictionary.
    Any dictionary may be used as a cache for any series of statements by using the
    [`Connection.execution_options.compiled_cache`](#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") option as an execution option.
    Execution options may be set on a statement, on an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    as well as when using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method for SQLAlchemy-2.0 style invocations.
    For example, to run a series of SQL statements and have them cached in a particular
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: The SQLAlchemy ORM uses the above technique to hold onto per-mapper caches within
    the unit of work “flush” process that are separate from the default cache configured
    on the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), as well
    as for some relationship loader queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache can also be disabled with this argument by sending a value of `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]  ### Caching for Third Party Dialects'
  prefs: []
  type: TYPE_NORMAL
- en: The caching feature requires that the dialect’s compiler produces SQL strings
    that are safe to reuse for many statement invocations, given a particular cache
    key that is keyed to that SQL string. This means that any literal values in a
    statement, such as the LIMIT/OFFSET values for a SELECT, can not be hardcoded
    in the dialect’s compilation scheme, as the compiled string will not be re-usable.
    SQLAlchemy supports rendered bound parameters using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method which
    can be applied to the existing `Select._limit_clause` and `Select._offset_clause`
    attributes by a custom compiler, which are illustrated later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As there are many third party dialects, many of which may be generating literal
    values from SQL statements without the benefit of the newer “literal execute”
    feature, SQLAlchemy as of version 1.4.5 has added an attribute to dialects known
    as [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache"). This attribute is checked
    at runtime for its presence directly on a particular dialect’s class, even if
    it’s already present on a superclass, so that even a third party dialect that
    subclasses an existing cacheable SQLAlchemy dialect such as `sqlalchemy.dialects.postgresql.PGDialect`
    must still explicitly include this attribute for caching to be enabled. The attribute
    should **only** be enabled once the dialect has been altered as needed and tested
    for reusability of compiled SQL statements with differing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For all third party dialects that don’t support this attribute, the logging
    for such a dialect will indicate `dialect does not support caching`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a dialect has been tested against caching, and in particular the SQL compiler
    has been updated to not render any literal LIMIT / OFFSET within a SQL string
    directly, dialect authors can apply the attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag needs to be applied to all subclasses of the dialect as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.5: Added the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The typical case for dialect modification follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Rendering LIMIT / OFFSET with post compile parameters'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, suppose a dialect overrides the `SQLCompiler.limit_clause()`
    method, which produces the “LIMIT / OFFSET” clause for a SQL statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: The above routine renders the `Select._limit` and `Select._offset` integer values
    as literal integers embedded in the SQL statement. This is a common requirement
    for databases that do not support using a bound parameter within the LIMIT/OFFSET
    clauses of a SELECT statement. However, rendering the integer value within the
    initial compilation stage is directly **incompatible** with caching as the limit
    and offset integer values of a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object are not part of the cache key, so that
    many [`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statements with different limit/offset values would not render with the correct
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction for the above code is to move the literal integer into SQLAlchemy’s
    [post-compile](../changelog/migration_14.html#change-4808) facility, which will
    render the literal integer outside of the initial compilation stage, but instead
    at execution time before the statement is sent to the DBAPI. This is accessed
    within the compilation stage using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method, in conjunction
    with using the `Select._limit_clause` and `Select._offset_clause` attributes,
    which represent the LIMIT/OFFSET as a complete SQL expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach above will generate a compiled SELECT statement that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `__[POSTCOMPILE_param_1]` and `__[POSTCOMPILE_param_2]` indicators
    will be populated with their corresponding integer values at statement execution
    time, after the SQL string has been retrieved from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: After changes like the above have been made as appropriate, the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") flag should be set to `True`.
    It is strongly recommended that third party dialects make use of the [dialect
    third party test suite](https://github.com/sqlalchemy/sqlalchemy/blob/main/README.dialects.rst)
    which will assert that operations like SELECTs with LIMIT/OFFSET are correctly
    rendered and cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](../faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](../faq/index.html) section  ### Using Lambdas
    to add significant speed gains to statement production'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Alchemy
  prefs: []
  type: TYPE_NORMAL
- en: This technique is generally non-essential except in very performance intensive
    scenarios, and intended for experienced Python programmers. While fairly straightforward,
    it involves metaprogramming concepts that are not appropriate for novice Python
    developers. The lambda approach can be applied to at a later time to existing
    code with a minimal amount of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Python functions, typically expressed as lambdas, may be used to generate SQL
    expressions which are cacheable based on the Python code location of the lambda
    function itself as well as the closure variables within the lambda. The rationale
    is to allow caching of not only the SQL string-compiled form of a SQL expression
    construct as is SQLAlchemy’s normal behavior when the lambda system isn’t used,
    but also the in-Python composition of the SQL expression construct itself, which
    also has some degree of Python overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda SQL expression feature is available as a performance enhancing feature,
    and is also optionally used in the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") ORM option in order to provide a generic
    SQL fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lambda statements are constructed using the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") function, which returns an instance of
    [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement"), which is itself an executable
    statement construct. Additional modifiers and criteria are added to the object
    using the Python addition operator `+`, or alternatively the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method which
    allows for more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is assumed that the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") construct is being invoked within an
    enclosing function or method that expects to be used many times within an application,
    so that subsequent executions beyond the first one can take advantage of the compiled
    SQL being cached. When the lambda is constructed inside of an enclosing function
    in Python it is then subject to also having closure variables, which are significant
    to the whole approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Above, the three `lambda` callables that are used to define the structure of
    a SELECT statement are invoked exactly once, and the resulting SQL string cached
    in the compilation cache of the engine. From that point forward, the `run_my_statement()`
    function may be invoked any number of times and the `lambda` callables within
    it will not be called, only used as cache keys to retrieve the already-compiled
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is already SQL caching in place when the
    lambda system is not used. The lambda system only adds an additional layer of
    work reduction per SQL statement invoked by caching the building up of the SQL
    construct itself and also using a simpler cache key.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Guidelines for Lambdas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Above all, the emphasis within the lambda SQL system is ensuring that there
    is never a mismatch between the cache key generated for a lambda and the SQL string
    it will produce. The [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") and related objects will run and analyze
    the given lambda in order to calculate how it should be cached on each run, trying
    to detect any potential problems. Basic guidelines include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any kind of statement is supported** - while it’s expected that [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are the prime use case for [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt"), DML statements such as [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") and [`update()`](dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") are equally usable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**ORM use cases directly supported as well** - the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") can accommodate ORM functionality completely
    and used directly with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bound parameters are automatically accommodated** - in contrast to SQLAlchemy’s
    previous “baked query” system, the lambda SQL system accommodates for Python literal
    values which become SQL bound parameters automatically. This means that even though
    a given lambda runs only once, the values that become bound parameters are extracted
    from the **closure** of the lambda on every run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above, [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") extracted the values of `x`
    and `y` from the **closure** of the lambda that is generated each time `my_stmt()`
    is invoked; these were substituted into the cached SQL construct as the values
    of the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The lambda should ideally produce an identical SQL structure in all cases**
    - Avoid using conditionals or custom callables inside of lambdas that might make
    it produce different SQL based on inputs; if a function might conditionally use
    two different SQL fragments, use two separate lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a variety of failures which can occur if the lambda does not produce
    a consistent SQL construct and some are not trivially detectable right now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Don’t use functions inside the lambda to produce bound values** - the bound
    value tracking approach requires that the actual value to be used in the SQL statement
    be locally present in the closure of the lambda. This is not possible if values
    are generated from other functions, and the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") should normally raise an error if this
    is attempted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above, the use of `get_x()` and `get_y()`, if they are necessary, should occur
    **outside** of the lambda and assigned to a local closure variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Avoid referring to non-SQL constructs inside of lambdas as they are not cacheable
    by default** - this issue refers to how the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") creates a cache key from other closure
    variables within the statement. In order to provide the best guarantee of an accurate
    cache key, all objects located in the closure of the lambda are considered to
    be significant, and none will be assumed to be appropriate for a cache key by
    default. So the following example will also raise a rather detailed error message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above error indicates that [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") will not assume that the `Foo` object
    passed in will continue to behave the same in all cases. It also won’t assume
    it can use `Foo` as part of the cache key by default; if it were to use the `Foo`
    object as part of the cache key, if there were many different `Foo` objects this
    would fill up the cache with duplicate information, and would also hold long-lasting
    references to all of these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The best way to resolve the above situation is to not refer to `foo` inside
    of the lambda, and refer to it **outside** instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In some situations, if the SQL structure of the lambda is guaranteed to never
    change based on input, to pass `track_closure_variables=False` which will disable
    any tracking of closure variables other than those used for bound parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also the option to add objects to the element to explicitly form part
    of the cache key, using the `track_on` parameter; using this parameter allows
    specific values to serve as the cache key and will also prevent other closure
    variables from being considered. This is useful for cases where part of the SQL
    being constructed originates from a contextual object of some sort that may have
    many different values. In the example below, the first segment of the SELECT statement
    will disable tracking of the `foo` variable, whereas the second segment will explicitly
    track `self` as part of the cache key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `track_on` means the given objects will be stored long term in the lambda’s
    internal cache and will have strong references for as long as the cache doesn’t
    clear out those objects (an LRU scheme of 1000 entries is used by default).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cache Key Generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand some of the options and behaviors which occur with lambda
    SQL constructs, an understanding of the caching system is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s caching system normally generates a cache key from a given SQL
    expression construct by producing a structure that represents all the state within
    the construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: The above key is stored in the cache which is essentially a dictionary, and
    the value is a construct that among other things stores the string form of the
    SQL statement, in this case the phrase “SELECT q”. We can observe that even for
    an extremely short query the cache key is pretty verbose as it has to represent
    everything that may vary about what’s being rendered and potentially executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda construction system by contrast creates a different kind of cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see a cache key that is vastly shorter than that of the non-lambda
    statement, and additionally that production of the `select(column("q"))` construct
    itself was not even necessary; the Python lambda itself contains an attribute
    called `__code__` which refers to a Python code object that within the runtime
    of the application is immutable and permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the lambda also includes closure variables, in the normal case that these
    variables refer to SQL constructs such as column objects, they become part of
    the cache key, or if they refer to literal values that will be bound parameters,
    they are placed in a separate element of the cache key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") includes two lambdas, both
    of which refer to the `col` closure variable, so the cache key will represent
    both of these segments as well as the `column()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the cache key has retrieved the bound parameters that will
    be used when the statement is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: For a series of examples of “lambda” caching with performance comparisons, see
    the “short_selects” test suite within the [Performance](../orm/examples.html#examples-performance)
    performance example.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The cache itself is a dictionary-like object called an `LRUCache`, which is
    an internal SQLAlchemy dictionary subclass that tracks the usage of particular
    keys and features a periodic “pruning” step which removes the least recently used
    items when the size of the cache reaches a certain threshold. The size of this
    cache defaults to 500 and may be configured using the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: The size of the cache can grow to be a factor of 150% of the size given, before
    it’s pruned back down to the target size. A cache of size 1200 above can therefore
    grow to be 1800 elements in size at which point it will be pruned to 1200.
  prefs: []
  type: TYPE_NORMAL
- en: The sizing of the cache is based on a single entry per unique SQL statement
    rendered, per engine. SQL statements generated from both the Core and the ORM
    are treated equally. DDL statements will usually not be cached. In order to determine
    what the cache is doing, engine logging will include details about the cache’s
    behavior, described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '### Estimating Cache Performance Using Logging'
  prefs: []
  type: TYPE_NORMAL
- en: The above cache size of 1200 is actually fairly large. For small applications,
    a size of 100 is likely sufficient. To estimate the optimal size of the cache,
    assuming enough memory is present on the target host, the size of the cache should
    be based on the number of unique SQL strings that may be rendered for the target
    engine in use. The most expedient way to see this is to use SQL echoing, which
    is most directly enabled by using the [`create_engine.echo`](engines.html#sqlalchemy.create_engine.params.echo
    "sqlalchemy.create_engine") flag, or by using Python logging; see the section
    [Configuring Logging](engines.html#dbengine-logging) for background on logging
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will examine the logging produced by the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, each SQL statement that’s logged will include a bracketed cache statistics
    badge to the left of the parameters passed. The four types of message we may see
    are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[raw sql]` - the driver or the end-user emitted raw SQL using [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") - caching does not apply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[no key]` - the statement object is a DDL statement that is not cached, or
    the statement object contains uncacheable elements such as user-defined constructs
    or arbitrarily large VALUES clauses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[generated in Xs]` - the statement was a **cache miss** and had to be compiled,
    then stored in the cache. it took X seconds to produce the compiled construct.
    The number X will be in the small fractional seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[cached since Xs ago]` - the statement was a **cache hit** and did not have
    to be recompiled. The statement has been stored in the cache since X seconds ago.
    The number X will be proportional to how long the application has been running
    and how long the statement has been cached, so for example would be 86400 for
    a 24 hour period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each badge is described in more detail below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first statements we see for the above program will be the SQLite dialect
    checking for the existence of the “a” and “b” tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: For the above two SQLite PRAGMA statements, the badge reads `[raw sql]`, which
    indicates the driver is sending a Python string directly to the database using
    [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql"). Caching does not apply to such
    statements because they already exist in string form, and there is nothing known
    about what kinds of result rows will be returned since SQLAlchemy does not parse
    SQL strings ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statements we see are the CREATE TABLE statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: For each of these statements, the badge reads `[no key 0.00006s]`. This indicates
    that these two particular statements, caching did not occur because the DDL-oriented
    [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable")
    construct did not produce a cache key. DDL constructs generally do not participate
    in caching because they are not typically subject to being repeated a second time
    and DDL is also a database configurational step where performance is not as critical.
  prefs: []
  type: TYPE_NORMAL
- en: The `[no key]` badge is important for one other reason, as it can be produced
    for SQL statements that are cacheable except for some particular sub-construct
    that is not currently cacheable. Examples of this include custom user-defined
    SQL elements that don’t define caching parameters, as well as some constructs
    that generate arbitrarily long and non-reproducible SQL strings, the main examples
    being the [`Values`](selectable.html#sqlalchemy.sql.expression.Values "sqlalchemy.sql.expression.Values")
    construct as well as when using “multivalued inserts” with the [`Insert.values()`](dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far our cache is still empty. The next statements will be cached however,
    a segment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see essentially two unique SQL strings; `"INSERT INTO a (data) VALUES
    (?)"` and `"INSERT INTO b (a_id, data) VALUES (?, ?)"`. Since SQLAlchemy uses
    bound parameters for all literal values, even though these statements are repeated
    many times for different objects, because the parameters are separate, the actual
    SQL string stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: the above two statements are generated by the ORM unit of work process, and
    in fact will be caching these in a separate cache that is local to each mapper.
    However the mechanics and terminology are the same. The section [Disabling or
    using an alternate dictionary to cache some (or all) statements](#engine-compiled-cache)
    below will describe how user-facing code can also use an alternate caching container
    on a per-statement basis.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge we see for the first occurrence of each of these two statements
    is `[generated in 0.00011s]`. This indicates that the statement was **not in the
    cache, was compiled into a String in .00011s and was then cached**. When we see
    the `[generated]` badge, we know that this means there was a **cache miss**. This
    is to be expected for the first occurrence of a particular statement. However,
    if lots of new `[generated]` badges are observed for a long-running application
    that is generally using the same series of SQL statements over and over, this
    may be a sign that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") parameter is too small. When a statement that was
    cached is then evicted from the cache due to the LRU cache pruning lesser used
    items, it will display the `[generated]` badge when it is next used.
  prefs: []
  type: TYPE_NORMAL
- en: The caching badge that we then see for the subsequent occurrences of each of
    these two statements looks like `[cached since 0.0003533s ago]`. This indicates
    that the statement **was found in the cache, and was originally placed into the
    cache .0003533 seconds ago**. It is important to note that while the `[generated]`
    and `[cached since]` badges refer to a number of seconds, they mean different
    things; in the case of `[generated]`, the number is a rough timing of how long
    it took to compile the statement, and will be an extremely small amount of time.
    In the case of `[cached since]`, this is the total time that a statement has been
    present in the cache. For an application that’s been running for six hours, this
    number may read `[cached since 21600 seconds ago]`, and that’s a good thing. Seeing
    high numbers for “cached since” is an indication that these statements have not
    been subject to cache misses for a long time. Statements that frequently have
    a low number of “cached since” even if the application has been running a long
    time may indicate these statements are too frequently subject to cache misses,
    and that the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") may need to be increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example program then performs some SELECTs where we can see the same pattern
    of “generated” then “cached”, for the SELECT of the “a” table as well as for subsequent
    lazy loads of the “b” table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: From our above program, a full run shows a total of four distinct SQL strings
    being cached. Which indicates a cache size of **four** would be sufficient. This
    is obviously an extremely small size, and the default size of 500 is fine to be
    left at its default.
  prefs: []
  type: TYPE_NORMAL
- en: How much memory does the cache use?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section detailed some techniques to check if the [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") needs to be bigger. How do we know if the cache is
    not too large? The reason we may want to set [`create_engine.query_cache_size`](engines.html#sqlalchemy.create_engine.params.query_cache_size
    "sqlalchemy.create_engine") to not be higher than a certain number would be because
    we have an application that may make use of a very large number of different statements,
    such as an application that is building queries on the fly from a search UX, and
    we don’t want our host to run out of memory if for example, a hundred thousand
    different queries were run in the past 24 hours and they were all cached.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely difficult to measure how much memory is occupied by Python data
    structures, however using a process to measure growth in memory via `top` as a
    successive series of 250 new statements are added to the cache suggest a moderate
    Core statement takes up about 12K while a small ORM statement takes about 20K,
    including result-fetching structures which for the ORM will be much greater.
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling or using an alternate dictionary to cache some (or all) statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal cache used is known as `LRUCache`, but this is mostly just a dictionary.
    Any dictionary may be used as a cache for any series of statements by using the
    [`Connection.execution_options.compiled_cache`](#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") option as an execution option.
    Execution options may be set on a statement, on an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    as well as when using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method for SQLAlchemy-2.0 style invocations.
    For example, to run a series of SQL statements and have them cached in a particular
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: The SQLAlchemy ORM uses the above technique to hold onto per-mapper caches within
    the unit of work “flush” process that are separate from the default cache configured
    on the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), as well
    as for some relationship loader queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache can also be disabled with this argument by sending a value of `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '### Caching for Third Party Dialects'
  prefs: []
  type: TYPE_NORMAL
- en: The caching feature requires that the dialect’s compiler produces SQL strings
    that are safe to reuse for many statement invocations, given a particular cache
    key that is keyed to that SQL string. This means that any literal values in a
    statement, such as the LIMIT/OFFSET values for a SELECT, can not be hardcoded
    in the dialect’s compilation scheme, as the compiled string will not be re-usable.
    SQLAlchemy supports rendered bound parameters using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method which
    can be applied to the existing `Select._limit_clause` and `Select._offset_clause`
    attributes by a custom compiler, which are illustrated later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As there are many third party dialects, many of which may be generating literal
    values from SQL statements without the benefit of the newer “literal execute”
    feature, SQLAlchemy as of version 1.4.5 has added an attribute to dialects known
    as [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache"). This attribute is checked
    at runtime for its presence directly on a particular dialect’s class, even if
    it’s already present on a superclass, so that even a third party dialect that
    subclasses an existing cacheable SQLAlchemy dialect such as `sqlalchemy.dialects.postgresql.PGDialect`
    must still explicitly include this attribute for caching to be enabled. The attribute
    should **only** be enabled once the dialect has been altered as needed and tested
    for reusability of compiled SQL statements with differing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For all third party dialects that don’t support this attribute, the logging
    for such a dialect will indicate `dialect does not support caching`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a dialect has been tested against caching, and in particular the SQL compiler
    has been updated to not render any literal LIMIT / OFFSET within a SQL string
    directly, dialect authors can apply the attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag needs to be applied to all subclasses of the dialect as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.5: Added the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The typical case for dialect modification follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Rendering LIMIT / OFFSET with post compile parameters'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, suppose a dialect overrides the `SQLCompiler.limit_clause()`
    method, which produces the “LIMIT / OFFSET” clause for a SQL statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: The above routine renders the `Select._limit` and `Select._offset` integer values
    as literal integers embedded in the SQL statement. This is a common requirement
    for databases that do not support using a bound parameter within the LIMIT/OFFSET
    clauses of a SELECT statement. However, rendering the integer value within the
    initial compilation stage is directly **incompatible** with caching as the limit
    and offset integer values of a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object are not part of the cache key, so that
    many [`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statements with different limit/offset values would not render with the correct
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction for the above code is to move the literal integer into SQLAlchemy’s
    [post-compile](../changelog/migration_14.html#change-4808) facility, which will
    render the literal integer outside of the initial compilation stage, but instead
    at execution time before the statement is sent to the DBAPI. This is accessed
    within the compilation stage using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method, in conjunction
    with using the `Select._limit_clause` and `Select._offset_clause` attributes,
    which represent the LIMIT/OFFSET as a complete SQL expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach above will generate a compiled SELECT statement that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `__[POSTCOMPILE_param_1]` and `__[POSTCOMPILE_param_2]` indicators
    will be populated with their corresponding integer values at statement execution
    time, after the SQL string has been retrieved from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: After changes like the above have been made as appropriate, the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") flag should be set to `True`.
    It is strongly recommended that third party dialects make use of the [dialect
    third party test suite](https://github.com/sqlalchemy/sqlalchemy/blob/main/README.dialects.rst)
    which will assert that operations like SELECTs with LIMIT/OFFSET are correctly
    rendered and cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](../faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](../faq/index.html) section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Rendering LIMIT / OFFSET with post compile parameters'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, suppose a dialect overrides the `SQLCompiler.limit_clause()`
    method, which produces the “LIMIT / OFFSET” clause for a SQL statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: The above routine renders the `Select._limit` and `Select._offset` integer values
    as literal integers embedded in the SQL statement. This is a common requirement
    for databases that do not support using a bound parameter within the LIMIT/OFFSET
    clauses of a SELECT statement. However, rendering the integer value within the
    initial compilation stage is directly **incompatible** with caching as the limit
    and offset integer values of a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object are not part of the cache key, so that
    many [`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statements with different limit/offset values would not render with the correct
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction for the above code is to move the literal integer into SQLAlchemy’s
    [post-compile](../changelog/migration_14.html#change-4808) facility, which will
    render the literal integer outside of the initial compilation stage, but instead
    at execution time before the statement is sent to the DBAPI. This is accessed
    within the compilation stage using the [`BindParameter.render_literal_execute()`](sqlelement.html#sqlalchemy.sql.expression.BindParameter.render_literal_execute
    "sqlalchemy.sql.expression.BindParameter.render_literal_execute") method, in conjunction
    with using the `Select._limit_clause` and `Select._offset_clause` attributes,
    which represent the LIMIT/OFFSET as a complete SQL expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach above will generate a compiled SELECT statement that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `__[POSTCOMPILE_param_1]` and `__[POSTCOMPILE_param_2]` indicators
    will be populated with their corresponding integer values at statement execution
    time, after the SQL string has been retrieved from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: After changes like the above have been made as appropriate, the [`Dialect.supports_statement_cache`](internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") flag should be set to `True`.
    It is strongly recommended that third party dialects make use of the [dialect
    third party test suite](https://github.com/sqlalchemy/sqlalchemy/blob/main/README.dialects.rst)
    which will assert that operations like SELECTs with LIMIT/OFFSET are correctly
    rendered and cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](../faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](../faq/index.html) section'
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Lambdas to add significant speed gains to statement production'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Alchemy
  prefs: []
  type: TYPE_NORMAL
- en: This technique is generally non-essential except in very performance intensive
    scenarios, and intended for experienced Python programmers. While fairly straightforward,
    it involves metaprogramming concepts that are not appropriate for novice Python
    developers. The lambda approach can be applied to at a later time to existing
    code with a minimal amount of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Python functions, typically expressed as lambdas, may be used to generate SQL
    expressions which are cacheable based on the Python code location of the lambda
    function itself as well as the closure variables within the lambda. The rationale
    is to allow caching of not only the SQL string-compiled form of a SQL expression
    construct as is SQLAlchemy’s normal behavior when the lambda system isn’t used,
    but also the in-Python composition of the SQL expression construct itself, which
    also has some degree of Python overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda SQL expression feature is available as a performance enhancing feature,
    and is also optionally used in the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") ORM option in order to provide a generic
    SQL fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lambda statements are constructed using the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") function, which returns an instance of
    [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement"), which is itself an executable
    statement construct. Additional modifiers and criteria are added to the object
    using the Python addition operator `+`, or alternatively the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method which
    allows for more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is assumed that the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") construct is being invoked within an
    enclosing function or method that expects to be used many times within an application,
    so that subsequent executions beyond the first one can take advantage of the compiled
    SQL being cached. When the lambda is constructed inside of an enclosing function
    in Python it is then subject to also having closure variables, which are significant
    to the whole approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Above, the three `lambda` callables that are used to define the structure of
    a SELECT statement are invoked exactly once, and the resulting SQL string cached
    in the compilation cache of the engine. From that point forward, the `run_my_statement()`
    function may be invoked any number of times and the `lambda` callables within
    it will not be called, only used as cache keys to retrieve the already-compiled
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is already SQL caching in place when the
    lambda system is not used. The lambda system only adds an additional layer of
    work reduction per SQL statement invoked by caching the building up of the SQL
    construct itself and also using a simpler cache key.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Guidelines for Lambdas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Above all, the emphasis within the lambda SQL system is ensuring that there
    is never a mismatch between the cache key generated for a lambda and the SQL string
    it will produce. The [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") and related objects will run and analyze
    the given lambda in order to calculate how it should be cached on each run, trying
    to detect any potential problems. Basic guidelines include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any kind of statement is supported** - while it’s expected that [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are the prime use case for [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt"), DML statements such as [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") and [`update()`](dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") are equally usable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**ORM use cases directly supported as well** - the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") can accommodate ORM functionality completely
    and used directly with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bound parameters are automatically accommodated** - in contrast to SQLAlchemy’s
    previous “baked query” system, the lambda SQL system accommodates for Python literal
    values which become SQL bound parameters automatically. This means that even though
    a given lambda runs only once, the values that become bound parameters are extracted
    from the **closure** of the lambda on every run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above, [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") extracted the values of `x`
    and `y` from the **closure** of the lambda that is generated each time `my_stmt()`
    is invoked; these were substituted into the cached SQL construct as the values
    of the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The lambda should ideally produce an identical SQL structure in all cases**
    - Avoid using conditionals or custom callables inside of lambdas that might make
    it produce different SQL based on inputs; if a function might conditionally use
    two different SQL fragments, use two separate lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a variety of failures which can occur if the lambda does not produce
    a consistent SQL construct and some are not trivially detectable right now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Don’t use functions inside the lambda to produce bound values** - the bound
    value tracking approach requires that the actual value to be used in the SQL statement
    be locally present in the closure of the lambda. This is not possible if values
    are generated from other functions, and the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") should normally raise an error if this
    is attempted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above, the use of `get_x()` and `get_y()`, if they are necessary, should occur
    **outside** of the lambda and assigned to a local closure variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Avoid referring to non-SQL constructs inside of lambdas as they are not cacheable
    by default** - this issue refers to how the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") creates a cache key from other closure
    variables within the statement. In order to provide the best guarantee of an accurate
    cache key, all objects located in the closure of the lambda are considered to
    be significant, and none will be assumed to be appropriate for a cache key by
    default. So the following example will also raise a rather detailed error message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above error indicates that [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") will not assume that the `Foo` object
    passed in will continue to behave the same in all cases. It also won’t assume
    it can use `Foo` as part of the cache key by default; if it were to use the `Foo`
    object as part of the cache key, if there were many different `Foo` objects this
    would fill up the cache with duplicate information, and would also hold long-lasting
    references to all of these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The best way to resolve the above situation is to not refer to `foo` inside
    of the lambda, and refer to it **outside** instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In some situations, if the SQL structure of the lambda is guaranteed to never
    change based on input, to pass `track_closure_variables=False` which will disable
    any tracking of closure variables other than those used for bound parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also the option to add objects to the element to explicitly form part
    of the cache key, using the `track_on` parameter; using this parameter allows
    specific values to serve as the cache key and will also prevent other closure
    variables from being considered. This is useful for cases where part of the SQL
    being constructed originates from a contextual object of some sort that may have
    many different values. In the example below, the first segment of the SELECT statement
    will disable tracking of the `foo` variable, whereas the second segment will explicitly
    track `self` as part of the cache key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `track_on` means the given objects will be stored long term in the lambda’s
    internal cache and will have strong references for as long as the cache doesn’t
    clear out those objects (an LRU scheme of 1000 entries is used by default).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cache Key Generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand some of the options and behaviors which occur with lambda
    SQL constructs, an understanding of the caching system is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s caching system normally generates a cache key from a given SQL
    expression construct by producing a structure that represents all the state within
    the construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: The above key is stored in the cache which is essentially a dictionary, and
    the value is a construct that among other things stores the string form of the
    SQL statement, in this case the phrase “SELECT q”. We can observe that even for
    an extremely short query the cache key is pretty verbose as it has to represent
    everything that may vary about what’s being rendered and potentially executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda construction system by contrast creates a different kind of cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see a cache key that is vastly shorter than that of the non-lambda
    statement, and additionally that production of the `select(column("q"))` construct
    itself was not even necessary; the Python lambda itself contains an attribute
    called `__code__` which refers to a Python code object that within the runtime
    of the application is immutable and permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the lambda also includes closure variables, in the normal case that these
    variables refer to SQL constructs such as column objects, they become part of
    the cache key, or if they refer to literal values that will be bound parameters,
    they are placed in a separate element of the cache key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") includes two lambdas, both
    of which refer to the `col` closure variable, so the cache key will represent
    both of these segments as well as the `column()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the cache key has retrieved the bound parameters that will
    be used when the statement is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: For a series of examples of “lambda” caching with performance comparisons, see
    the “short_selects” test suite within the [Performance](../orm/examples.html#examples-performance)
    performance example.
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lambda statements are constructed using the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") function, which returns an instance of
    [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement"), which is itself an executable
    statement construct. Additional modifiers and criteria are added to the object
    using the Python addition operator `+`, or alternatively the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method which
    allows for more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is assumed that the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") construct is being invoked within an
    enclosing function or method that expects to be used many times within an application,
    so that subsequent executions beyond the first one can take advantage of the compiled
    SQL being cached. When the lambda is constructed inside of an enclosing function
    in Python it is then subject to also having closure variables, which are significant
    to the whole approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Above, the three `lambda` callables that are used to define the structure of
    a SELECT statement are invoked exactly once, and the resulting SQL string cached
    in the compilation cache of the engine. From that point forward, the `run_my_statement()`
    function may be invoked any number of times and the `lambda` callables within
    it will not be called, only used as cache keys to retrieve the already-compiled
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is already SQL caching in place when the
    lambda system is not used. The lambda system only adds an additional layer of
    work reduction per SQL statement invoked by caching the building up of the SQL
    construct itself and also using a simpler cache key.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Guidelines for Lambdas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Above all, the emphasis within the lambda SQL system is ensuring that there
    is never a mismatch between the cache key generated for a lambda and the SQL string
    it will produce. The [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") and related objects will run and analyze
    the given lambda in order to calculate how it should be cached on each run, trying
    to detect any potential problems. Basic guidelines include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any kind of statement is supported** - while it’s expected that [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are the prime use case for [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt"), DML statements such as [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") and [`update()`](dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") are equally usable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**ORM use cases directly supported as well** - the [`lambda_stmt()`](sqlelement.html#sqlalchemy.sql.expression.lambda_stmt
    "sqlalchemy.sql.expression.lambda_stmt") can accommodate ORM functionality completely
    and used directly with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bound parameters are automatically accommodated** - in contrast to SQLAlchemy’s
    previous “baked query” system, the lambda SQL system accommodates for Python literal
    values which become SQL bound parameters automatically. This means that even though
    a given lambda runs only once, the values that become bound parameters are extracted
    from the **closure** of the lambda on every run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above, [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") extracted the values of `x`
    and `y` from the **closure** of the lambda that is generated each time `my_stmt()`
    is invoked; these were substituted into the cached SQL construct as the values
    of the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The lambda should ideally produce an identical SQL structure in all cases**
    - Avoid using conditionals or custom callables inside of lambdas that might make
    it produce different SQL based on inputs; if a function might conditionally use
    two different SQL fragments, use two separate lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a variety of failures which can occur if the lambda does not produce
    a consistent SQL construct and some are not trivially detectable right now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Don’t use functions inside the lambda to produce bound values** - the bound
    value tracking approach requires that the actual value to be used in the SQL statement
    be locally present in the closure of the lambda. This is not possible if values
    are generated from other functions, and the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") should normally raise an error if this
    is attempted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above, the use of `get_x()` and `get_y()`, if they are necessary, should occur
    **outside** of the lambda and assigned to a local closure variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Avoid referring to non-SQL constructs inside of lambdas as they are not cacheable
    by default** - this issue refers to how the [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") creates a cache key from other closure
    variables within the statement. In order to provide the best guarantee of an accurate
    cache key, all objects located in the closure of the lambda are considered to
    be significant, and none will be assumed to be appropriate for a cache key by
    default. So the following example will also raise a rather detailed error message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above error indicates that [`LambdaElement`](foundation.html#sqlalchemy.sql.expression.LambdaElement
    "sqlalchemy.sql.expression.LambdaElement") will not assume that the `Foo` object
    passed in will continue to behave the same in all cases. It also won’t assume
    it can use `Foo` as part of the cache key by default; if it were to use the `Foo`
    object as part of the cache key, if there were many different `Foo` objects this
    would fill up the cache with duplicate information, and would also hold long-lasting
    references to all of these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The best way to resolve the above situation is to not refer to `foo` inside
    of the lambda, and refer to it **outside** instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In some situations, if the SQL structure of the lambda is guaranteed to never
    change based on input, to pass `track_closure_variables=False` which will disable
    any tracking of closure variables other than those used for bound parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also the option to add objects to the element to explicitly form part
    of the cache key, using the `track_on` parameter; using this parameter allows
    specific values to serve as the cache key and will also prevent other closure
    variables from being considered. This is useful for cases where part of the SQL
    being constructed originates from a contextual object of some sort that may have
    many different values. In the example below, the first segment of the SELECT statement
    will disable tracking of the `foo` variable, whereas the second segment will explicitly
    track `self` as part of the cache key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `track_on` means the given objects will be stored long term in the lambda’s
    internal cache and will have strong references for as long as the cache doesn’t
    clear out those objects (an LRU scheme of 1000 entries is used by default).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cache Key Generation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand some of the options and behaviors which occur with lambda
    SQL constructs, an understanding of the caching system is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s caching system normally generates a cache key from a given SQL
    expression construct by producing a structure that represents all the state within
    the construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: The above key is stored in the cache which is essentially a dictionary, and
    the value is a construct that among other things stores the string form of the
    SQL statement, in this case the phrase “SELECT q”. We can observe that even for
    an extremely short query the cache key is pretty verbose as it has to represent
    everything that may vary about what’s being rendered and potentially executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda construction system by contrast creates a different kind of cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see a cache key that is vastly shorter than that of the non-lambda
    statement, and additionally that production of the `select(column("q"))` construct
    itself was not even necessary; the Python lambda itself contains an attribute
    called `__code__` which refers to a Python code object that within the runtime
    of the application is immutable and permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the lambda also includes closure variables, in the normal case that these
    variables refer to SQL constructs such as column objects, they become part of
    the cache key, or if they refer to literal values that will be bound parameters,
    they are placed in a separate element of the cache key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement") includes two lambdas, both
    of which refer to the `col` closure variable, so the cache key will represent
    both of these segments as well as the `column()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the cache key has retrieved the bound parameters that will
    be used when the statement is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: For a series of examples of “lambda” caching with performance comparisons, see
    the “short_selects” test suite within the [Performance](../orm/examples.html#examples-performance)
    performance example.
  prefs: []
  type: TYPE_NORMAL
- en: '## “Insert Many Values” Behavior for INSERT statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: see [Optimized ORM bulk insert now implemented for all
    backends other than MySQL](../changelog/whatsnew_20.html#change-6047) for background
    on the change including sample performance tests'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [insertmanyvalues](../glossary.html#term-insertmanyvalues) feature is a
    **transparently available** performance feature which requires no end-user intervention
    in order for it to take place as needed. This section describes the architecture
    of the feature as well as how to measure its performance and tune its behavior
    in order to optimize the speed of bulk INSERT statements, particularly as used
    by the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: As more databases have added support for INSERT..RETURNING, SQLAlchemy has undergone
    a major change in how it approaches the subject of INSERT statements where there’s
    a need to acquire server-generated values, most importantly server-generated primary
    key values which allow the new row to be referenced in subsequent operations.
    In particular, this scenario has long been a significant performance issue in
    the ORM, which relies on being able to retrieve server-generated primary key values
    in order to correctly populate the [identity map](../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: With recent support for RETURNING added to SQLite and MariaDB, SQLAlchemy no
    longer needs to rely upon the single-row-only [cursor.lastrowid](https://peps.python.org/pep-0249/#lastrowid)
    attribute provided by the [DBAPI](../glossary.html#term-DBAPI) for most backends;
    RETURNING may now be used for all [SQLAlchemy-included](../dialects/index.html#included-dialects)
    backends with the exception of MySQL. The remaining performance limitation, that
    the [cursor.executemany()](https://peps.python.org/pep-0249/#executemany) DBAPI
    method does not allow for rows to be fetched, is resolved for most backends by
    foregoing the use of `executemany()` and instead restructuring individual INSERT
    statements to each accommodate a large number of rows in a single statement that
    is invoked using `cursor.execute()`. This approach originates from the [psycopg2
    fast execution helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    feature of the `psycopg2` DBAPI, which SQLAlchemy incrementally added more and
    more support towards in recent release series.
  prefs: []
  type: TYPE_NORMAL
- en: Current Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The feature is enabled for all backend included in SQLAlchemy that support RETURNING,
    with the exception of Oracle for which both the cx_Oracle and OracleDB drivers
    offer their own equivalent feature. The feature normally takes place when making
    use of the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method of an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in conjunction with [executemany](../glossary.html#term-executemany)
    execution, which occurs when passing a list of dictionaries to the [`Connection.execute.parameters`](#sqlalchemy.engine.Connection.execute.params.parameters
    "sqlalchemy.engine.Connection.execute") parameter of the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") methods (as well as equivalent methods under
    [asyncio](../orm/extensions/asyncio.html) and shorthand methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")). It also takes place within the ORM [unit of
    work](../glossary.html#term-unit-of-work) process when using methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") to add rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLAlchemy’s included dialects, support or equivalent support is currently
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - supported for SQLite versions 3.35 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - all supported Postgresql versions (9 and above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server - all supported SQL Server versions [[1]](#id2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB - supported for MariaDB versions 10.5 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL - no support, no RETURNING feature is present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - supports RETURNING with executemany using native cx_Oracle / OracleDB
    APIs, for all supported Oracle versions 9 and above, using multi-row OUT parameters.
    This is not the same implementation as “executemanyvalues”, however has the same
    usage patterns and equivalent performance benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To disable the “insertmanyvalues” feature for a given backend for an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") overall, pass the [`create_engine.use_insertmanyvalues`](engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") parameter as `False` to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature can also be disabled from being used implicitly for a particular
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    by passing the [`Table.implicit_returning`](metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: The reason one might want to disable RETURNING for a specific table is to work
    around backend-specific limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Batched Mode Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The feature has two modes of operation, which are selected transparently on
    a per-dialect, per-[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    basis. One is **batched mode**, which reduces the number of database round trips
    by rewriting an INSERT statement of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'into a “batched” form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: where above, the statement is organized against a subset (a “batch”) of the
    input data, the size of which is determined by the database backend as well as
    the number of parameters in each batch to correspond to known limits for statement
    size / number of parameters. The feature then executes the INSERT statement once
    for each batch of input data until all records are consumed, concatenating the
    RETURNING results for each batch into a single large rowset that’s available from
    a single [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: This “batched” form allows INSERT of many rows using much fewer database round
    trips, and has been shown to allow dramatic performance improvements for most
    backends where it’s supported.
  prefs: []
  type: TYPE_NORMAL
- en: '### Correlating RETURNING rows to parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.10.
  prefs: []
  type: TYPE_NORMAL
- en: The “batch” mode query illustrated in the previous section does not guarantee
    the order of records returned would correspond with that of the input data. When
    used by the SQLAlchemy ORM [unit of work](../glossary.html#term-unit-of-work)
    process, as well as for applications which correlate returned server-generated
    values with input data, the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and [`UpdateBase.return_defaults()`](dml.html#sqlalchemy.sql.expression.UpdateBase.return_defaults
    "sqlalchemy.sql.expression.UpdateBase.return_defaults") methods include an option
    [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which indicates that “insertmanyvalues”
    mode should guarantee this correspondence. This is **not related** to the order
    in which records are actually INSERTed by the database backend, which is **not**
    assumed under any circumstances; only that the returned records should be organized
    when received back to correspond to the order in which the original input data
    was passed.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter is present, for tables
    that use server-generated integer primary key values such as `IDENTITY`, PostgreSQL
    `SERIAL`, MariaDB `AUTO_INCREMENT`, or SQLite’s `ROWID` scheme, “batch” mode may
    instead opt to use a more complex INSERT..RETURNING form, in conjunction with
    post-execution sorting of rows based on the returned values, or if such a form
    is not available, the “insertmanyvalues” feature may gracefully degrade to “non-batched”
    mode which runs individual INSERT statements for each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on SQL Server when an auto incrementing `IDENTITY` column is used
    as the primary key, the following SQL form is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: A similar form is used for PostgreSQL as well, when primary key columns use
    SERIAL or IDENTITY. The above form **does not** guarantee the order in which rows
    are inserted. However, it does guarantee that the IDENTITY or SERIAL values will
    be created in order with each parameter set [[2]](#id5). The “insertmanyvalues”
    feature then sorts the returned rows for the above INSERT statement by incrementing
    integer identity.
  prefs: []
  type: TYPE_NORMAL
- en: For the SQLite database, there is no appropriate INSERT form that can correlate
    the production of new ROWID values with the order in which the parameter sets
    are passed. As a result, when using server-generated primary key values, the SQLite
    backend will degrade to “non-batched” mode when ordered RETURNING is requested.
    For MariaDB, the default INSERT form used by insertmanyvalues is sufficient, as
    this database backend will line up the order of AUTO_INCREMENT with the order
    of input data when using InnoDB [[3]](#id6).
  prefs: []
  type: TYPE_NORMAL
- en: For a client-side generated primary key, such as when using the Python `uuid.uuid4()`
    function to generate new values for a [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column, the “insertmanyvalues” feature transparently
    includes this column in the RETURNING records and correlates its value to that
    of the given input records, thus maintaining correspondence between input records
    and result rows. From this, it follows that all backends allow for batched, parameter-correlated
    RETURNING order when client-side-generated primary key values are used.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of how “insertmanyvalues” “batch” mode determines a column or columns
    to use as a point of correspondence between input parameters and RETURNING rows
    is known as an [insert sentinel](../glossary.html#term-insert-sentinel), which
    is a specific column or columns that are used to track such values. The “insert
    sentinel” is normally selected automatically, however can also be user-configuration
    for extremely special cases; the section [Configuring Sentinel Columns](#engine-insertmanyvalues-sentinel-columns)
    describes this.
  prefs: []
  type: TYPE_NORMAL
- en: For backends that do not offer an appropriate INSERT form that can deliver server-generated
    values deterministically aligned with input values, or for [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") configurations that feature other kinds of server generated
    primary key values, “insertmanyvalues” mode will make use of **non-batched** mode
    when guaranteed RETURNING ordering is requested.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft SQL Server rationale
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: “INSERT queries that use SELECT with ORDER BY to populate rows guarantees how
    identity values are computed but not the order in which the rows are inserted.”
    [https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions](https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PostgreSQL batched INSERT Discussion
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Original description in 2018 [https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us](https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Follow up in 2023 - [https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com](https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MariaDB AUTO_INCREMENT behavior (using the same InnoDB engine as MySQL):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://dba.stackexchange.com/a/72099](https://dba.stackexchange.com/a/72099)  ###
    Non-Batched Mode Operation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    configurations that do not have client side primary key values, and offer server-generated
    primary key values (or no primary key) that the database in question is not able
    to invoke in a deterministic or sortable way relative to multiple parameter sets,
    the “insertmanyvalues” feature when tasked with satisfying the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") requirement for an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement may instead opt to use **non-batched
    mode**.
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, the original SQL form of INSERT is maintained, and the “insertmanyvalues”
    feature will instead run the statement as given for each parameter set individually,
    organizing the returned rows into a full result set. Unlike previous SQLAlchemy
    versions, it does so in a tight loop that minimizes Python overhead. In some cases,
    such as on SQLite, “non-batched” mode performs exactly as well as “batched” mode.
  prefs: []
  type: TYPE_NORMAL
- en: Statement Execution Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For both “batched” and “non-batched” modes, the feature will necessarily invoke
    **multiple INSERT statements** using the DBAPI `cursor.execute()` method, within
    the scope of **single** call to the Core-level [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, with each statement containing
    up to a fixed limit of parameter sets. This limit is configurable as described
    below at [Controlling the Batch Size](#engine-insertmanyvalues-page-size). The
    separate calls to `cursor.execute()` are logged individually and also individually
    passed along to event listeners such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") (see [Logging and
    Events](#engine-insertmanyvalues-events) below).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Configuring Sentinel Columns'
  prefs: []
  type: TYPE_NORMAL
- en: In typical cases, the “insertmanyvalues” feature in order to provide INSERT..RETURNING
    with deterministic row order will automatically determine a sentinel column from
    a given table’s primary key, gracefully degrading to “row at a time” mode if one
    cannot be identified. As a completely **optional** feature, to get full “insertmanyvalues”
    bulk performance for tables that have server generated primary keys whose default
    generator functions aren’t compatible with the “sentinel” use case, other non-primary
    key columns may be marked as “sentinel” columns assuming they meet certain requirements.
    A typical example is a non-primary key [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column with a client side default such as the Python
    `uuid.uuid4()` function. There is also a construct to create simple integer columns
    with a a client side integer counter oriented towards the “insertmanyvalues” use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sentinel columns may be indicated by adding [`Column.insert_sentinel`](metadata.html#sqlalchemy.schema.Column.params.insert_sentinel
    "sqlalchemy.schema.Column") to qualifying columns. The most basic “qualifying”
    column is a not-nullable, unique column with a client side default, such as a
    UUID column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative models, the same forms are available using the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: While the values generated by the default generator **must** be unique, the
    actual UNIQUE constraint on the above “sentinel” column, indicated by the `unique=True`
    parameter, itself is optional and may be omitted if not desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a special form of “insert sentinel” that’s a dedicated nullable
    integer column which makes use of a special default integer counter that’s only
    used during “insertmanyvalues” operations; as an additional behavior, the column
    will omit itself from SQL statements and result sets and behave in a mostly transparent
    manner. It does need to be physically present within the actual database table,
    however. This style of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    may be constructed using the function [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative, a Declarative-friendly version of [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel") is available called [`orm_insert_sentinel()`](../orm/mapping_api.html#sqlalchemy.orm.orm_insert_sentinel
    "sqlalchemy.orm.orm_insert_sentinel"), which has the ability to be used on the
    Base class or a mixin; if packaged using [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"), the column will apply itself to all table-bound
    subclasses including within joined inheritance hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, both “my_table” and “sub_table” will have an additional
    integer column named “_sentinel” that can be used by the “insertmanyvalues” feature
    to help optimize bulk inserts used by the ORM.  ### Controlling the Batch Size'
  prefs: []
  type: TYPE_NORMAL
- en: A key characteristic of “insertmanyvalues” is that the size of the INSERT statement
    is limited on a fixed max number of “values” clauses as well as a dialect-specific
    fixed total number of bound parameters that may be represented in one INSERT statement
    at a time. When the number of parameter dictionaries given exceeds a fixed limit,
    or when the total number of bound parameters to be rendered in a single INSERT
    statement exceeds a fixed limit (the two fixed limits are separate), multiple
    INSERT statements will be invoked within the scope of a single [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") call, each of which accommodate for a
    portion of the parameter dictionaries, known as a “batch”. The number of parameter
    dictionaries represented within each “batch” is then known as the “batch size”.
    For example, a batch size of 500 means that each INSERT statement emitted will
    INSERT at most 500 rows.
  prefs: []
  type: TYPE_NORMAL
- en: It’s potentially important to be able to adjust the batch size, as a larger
    batch size may be more performant for an INSERT where the value sets themselves
    are relatively small, and a smaller batch size may be more appropriate for an
    INSERT that uses very large value sets, where both the size of the rendered SQL
    as well as the total data size being passed in one statement may benefit from
    being limited to a certain size based on backend behavior and memory constraints.
    For this reason the batch size can be configured on a per-[`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as well as a per-statement basis. The parameter limit
    on the other hand is fixed based on the known characteristics of the database
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: The batch size defaults to 1000 for most backends, with an additional per-dialect
    “max number of parameters” limiting factor that may reduce the batch size further
    on a per-statement basis. The max number of parameters varies by dialect and server
    version; the largest size is 32700 (chosen as a healthy distance away from PostgreSQL’s
    limit of 32767 and SQLite’s modern limit of 32766, while leaving room for additional
    parameters in the statement as well as for DBAPI quirkiness). Older versions of
    SQLite (prior to 3.32.0) will set this value to 999\. MariaDB has no established
    limit however 32700 remains as a limiting factor for SQL message size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the “batch size” can be affected [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") wide via the [`create_engine.insertmanyvalues_page_size`](engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter. Such as, to affect INSERT statements to
    include up to 100 parameter sets in each statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'The batch size may also be affected on a per statement basis using the [`Connection.execution_options.insertmanyvalues_page_size`](#sqlalchemy.engine.Connection.execution_options.params.insertmanyvalues_page_size
    "sqlalchemy.engine.Connection.execution_options") execution option, such as per
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'Or configured on the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]  ### Logging and Events'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “insertmanyvalues” feature integrates fully with SQLAlchemy’s [statement
    logging](engines.html#dbengine-logging) as well as cursor events such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute"). When the list of
    parameters is broken into separate batches, **each INSERT statement is logged
    and passed to event handlers individually**. This is a major change compared to
    how the psycopg2-only feature worked in previous 1.x series of SQLAlchemy, where
    the production of multiple INSERT statements was hidden from logging and events.
    Logging display will truncate the long lists of parameters for readability, and
    will also indicate the specific batch of each statement. The example below illustrates
    an excerpt of this logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'When [non-batch mode](#engine-insertmanyvalues-non-batch) takes place, logging
    will indicate this along with the insertmanyvalues message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Logging](engines.html#dbengine-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Upsert Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL, SQLite, and MariaDB dialects offer backend-specific “upsert”
    constructs [`insert()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert"), [`insert()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") and [`insert()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert"), which are each [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs that have an additional method
    such as `on_conflict_do_update()` or ``on_duplicate_key()`. These constructs also
    support “insertmanyvalues” behaviors when they are used with RETURNING, allowing
    efficient upserts with RETURNING to take place.
  prefs: []
  type: TYPE_NORMAL
- en: Current Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The feature is enabled for all backend included in SQLAlchemy that support RETURNING,
    with the exception of Oracle for which both the cx_Oracle and OracleDB drivers
    offer their own equivalent feature. The feature normally takes place when making
    use of the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method of an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in conjunction with [executemany](../glossary.html#term-executemany)
    execution, which occurs when passing a list of dictionaries to the [`Connection.execute.parameters`](#sqlalchemy.engine.Connection.execute.params.parameters
    "sqlalchemy.engine.Connection.execute") parameter of the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") methods (as well as equivalent methods under
    [asyncio](../orm/extensions/asyncio.html) and shorthand methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")). It also takes place within the ORM [unit of
    work](../glossary.html#term-unit-of-work) process when using methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") to add rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLAlchemy’s included dialects, support or equivalent support is currently
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - supported for SQLite versions 3.35 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - all supported Postgresql versions (9 and above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server - all supported SQL Server versions [[1]](#id2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB - supported for MariaDB versions 10.5 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL - no support, no RETURNING feature is present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - supports RETURNING with executemany using native cx_Oracle / OracleDB
    APIs, for all supported Oracle versions 9 and above, using multi-row OUT parameters.
    This is not the same implementation as “executemanyvalues”, however has the same
    usage patterns and equivalent performance benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To disable the “insertmanyvalues” feature for a given backend for an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") overall, pass the [`create_engine.use_insertmanyvalues`](engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") parameter as `False` to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature can also be disabled from being used implicitly for a particular
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    by passing the [`Table.implicit_returning`](metadata.html#sqlalchemy.schema.Table.params.implicit_returning
    "sqlalchemy.schema.Table") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: The reason one might want to disable RETURNING for a specific table is to work
    around backend-specific limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Batched Mode Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The feature has two modes of operation, which are selected transparently on
    a per-dialect, per-[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    basis. One is **batched mode**, which reduces the number of database round trips
    by rewriting an INSERT statement of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'into a “batched” form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: where above, the statement is organized against a subset (a “batch”) of the
    input data, the size of which is determined by the database backend as well as
    the number of parameters in each batch to correspond to known limits for statement
    size / number of parameters. The feature then executes the INSERT statement once
    for each batch of input data until all records are consumed, concatenating the
    RETURNING results for each batch into a single large rowset that’s available from
    a single [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: This “batched” form allows INSERT of many rows using much fewer database round
    trips, and has been shown to allow dramatic performance improvements for most
    backends where it’s supported.
  prefs: []
  type: TYPE_NORMAL
- en: '### Correlating RETURNING rows to parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.10.
  prefs: []
  type: TYPE_NORMAL
- en: The “batch” mode query illustrated in the previous section does not guarantee
    the order of records returned would correspond with that of the input data. When
    used by the SQLAlchemy ORM [unit of work](../glossary.html#term-unit-of-work)
    process, as well as for applications which correlate returned server-generated
    values with input data, the [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and [`UpdateBase.return_defaults()`](dml.html#sqlalchemy.sql.expression.UpdateBase.return_defaults
    "sqlalchemy.sql.expression.UpdateBase.return_defaults") methods include an option
    [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which indicates that “insertmanyvalues”
    mode should guarantee this correspondence. This is **not related** to the order
    in which records are actually INSERTed by the database backend, which is **not**
    assumed under any circumstances; only that the returned records should be organized
    when received back to correspond to the order in which the original input data
    was passed.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter is present, for tables
    that use server-generated integer primary key values such as `IDENTITY`, PostgreSQL
    `SERIAL`, MariaDB `AUTO_INCREMENT`, or SQLite’s `ROWID` scheme, “batch” mode may
    instead opt to use a more complex INSERT..RETURNING form, in conjunction with
    post-execution sorting of rows based on the returned values, or if such a form
    is not available, the “insertmanyvalues” feature may gracefully degrade to “non-batched”
    mode which runs individual INSERT statements for each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on SQL Server when an auto incrementing `IDENTITY` column is used
    as the primary key, the following SQL form is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: A similar form is used for PostgreSQL as well, when primary key columns use
    SERIAL or IDENTITY. The above form **does not** guarantee the order in which rows
    are inserted. However, it does guarantee that the IDENTITY or SERIAL values will
    be created in order with each parameter set [[2]](#id5). The “insertmanyvalues”
    feature then sorts the returned rows for the above INSERT statement by incrementing
    integer identity.
  prefs: []
  type: TYPE_NORMAL
- en: For the SQLite database, there is no appropriate INSERT form that can correlate
    the production of new ROWID values with the order in which the parameter sets
    are passed. As a result, when using server-generated primary key values, the SQLite
    backend will degrade to “non-batched” mode when ordered RETURNING is requested.
    For MariaDB, the default INSERT form used by insertmanyvalues is sufficient, as
    this database backend will line up the order of AUTO_INCREMENT with the order
    of input data when using InnoDB [[3]](#id6).
  prefs: []
  type: TYPE_NORMAL
- en: For a client-side generated primary key, such as when using the Python `uuid.uuid4()`
    function to generate new values for a [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column, the “insertmanyvalues” feature transparently
    includes this column in the RETURNING records and correlates its value to that
    of the given input records, thus maintaining correspondence between input records
    and result rows. From this, it follows that all backends allow for batched, parameter-correlated
    RETURNING order when client-side-generated primary key values are used.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of how “insertmanyvalues” “batch” mode determines a column or columns
    to use as a point of correspondence between input parameters and RETURNING rows
    is known as an [insert sentinel](../glossary.html#term-insert-sentinel), which
    is a specific column or columns that are used to track such values. The “insert
    sentinel” is normally selected automatically, however can also be user-configuration
    for extremely special cases; the section [Configuring Sentinel Columns](#engine-insertmanyvalues-sentinel-columns)
    describes this.
  prefs: []
  type: TYPE_NORMAL
- en: For backends that do not offer an appropriate INSERT form that can deliver server-generated
    values deterministically aligned with input values, or for [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") configurations that feature other kinds of server generated
    primary key values, “insertmanyvalues” mode will make use of **non-batched** mode
    when guaranteed RETURNING ordering is requested.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft SQL Server rationale
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: “INSERT queries that use SELECT with ORDER BY to populate rows guarantees how
    identity values are computed but not the order in which the rows are inserted.”
    [https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions](https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16#limitations-and-restrictions)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PostgreSQL batched INSERT Discussion
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Original description in 2018 [https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us](https://www.postgresql.org/message-id/29386.1528813619@sss.pgh.pa.us)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Follow up in 2023 - [https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com](https://www.postgresql.org/message-id/be108555-da2a-4abc-a46b-acbe8b55bd25%40app.fastmail.com)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MariaDB AUTO_INCREMENT behavior (using the same InnoDB engine as MySQL):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://dba.stackexchange.com/a/72099](https://dba.stackexchange.com/a/72099)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### Non-Batched Mode Operation'
  prefs: []
  type: TYPE_NORMAL
- en: For [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    configurations that do not have client side primary key values, and offer server-generated
    primary key values (or no primary key) that the database in question is not able
    to invoke in a deterministic or sortable way relative to multiple parameter sets,
    the “insertmanyvalues” feature when tasked with satisfying the [`Insert.returning.sort_by_parameter_order`](dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") requirement for an [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement may instead opt to use **non-batched
    mode**.
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, the original SQL form of INSERT is maintained, and the “insertmanyvalues”
    feature will instead run the statement as given for each parameter set individually,
    organizing the returned rows into a full result set. Unlike previous SQLAlchemy
    versions, it does so in a tight loop that minimizes Python overhead. In some cases,
    such as on SQLite, “non-batched” mode performs exactly as well as “batched” mode.
  prefs: []
  type: TYPE_NORMAL
- en: Statement Execution Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For both “batched” and “non-batched” modes, the feature will necessarily invoke
    **multiple INSERT statements** using the DBAPI `cursor.execute()` method, within
    the scope of **single** call to the Core-level [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, with each statement containing
    up to a fixed limit of parameter sets. This limit is configurable as described
    below at [Controlling the Batch Size](#engine-insertmanyvalues-page-size). The
    separate calls to `cursor.execute()` are logged individually and also individually
    passed along to event listeners such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") (see [Logging and
    Events](#engine-insertmanyvalues-events) below).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Configuring Sentinel Columns'
  prefs: []
  type: TYPE_NORMAL
- en: In typical cases, the “insertmanyvalues” feature in order to provide INSERT..RETURNING
    with deterministic row order will automatically determine a sentinel column from
    a given table’s primary key, gracefully degrading to “row at a time” mode if one
    cannot be identified. As a completely **optional** feature, to get full “insertmanyvalues”
    bulk performance for tables that have server generated primary keys whose default
    generator functions aren’t compatible with the “sentinel” use case, other non-primary
    key columns may be marked as “sentinel” columns assuming they meet certain requirements.
    A typical example is a non-primary key [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column with a client side default such as the Python
    `uuid.uuid4()` function. There is also a construct to create simple integer columns
    with a a client side integer counter oriented towards the “insertmanyvalues” use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sentinel columns may be indicated by adding [`Column.insert_sentinel`](metadata.html#sqlalchemy.schema.Column.params.insert_sentinel
    "sqlalchemy.schema.Column") to qualifying columns. The most basic “qualifying”
    column is a not-nullable, unique column with a client side default, such as a
    UUID column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative models, the same forms are available using the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: While the values generated by the default generator **must** be unique, the
    actual UNIQUE constraint on the above “sentinel” column, indicated by the `unique=True`
    parameter, itself is optional and may be omitted if not desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a special form of “insert sentinel” that’s a dedicated nullable
    integer column which makes use of a special default integer counter that’s only
    used during “insertmanyvalues” operations; as an additional behavior, the column
    will omit itself from SQL statements and result sets and behave in a mostly transparent
    manner. It does need to be physically present within the actual database table,
    however. This style of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    may be constructed using the function [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative, a Declarative-friendly version of [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel") is available called [`orm_insert_sentinel()`](../orm/mapping_api.html#sqlalchemy.orm.orm_insert_sentinel
    "sqlalchemy.orm.orm_insert_sentinel"), which has the ability to be used on the
    Base class or a mixin; if packaged using [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"), the column will apply itself to all table-bound
    subclasses including within joined inheritance hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, both “my_table” and “sub_table” will have an additional
    integer column named “_sentinel” that can be used by the “insertmanyvalues” feature
    to help optimize bulk inserts used by the ORM.  #### Configuring Sentinel Columns'
  prefs: []
  type: TYPE_NORMAL
- en: In typical cases, the “insertmanyvalues” feature in order to provide INSERT..RETURNING
    with deterministic row order will automatically determine a sentinel column from
    a given table’s primary key, gracefully degrading to “row at a time” mode if one
    cannot be identified. As a completely **optional** feature, to get full “insertmanyvalues”
    bulk performance for tables that have server generated primary keys whose default
    generator functions aren’t compatible with the “sentinel” use case, other non-primary
    key columns may be marked as “sentinel” columns assuming they meet certain requirements.
    A typical example is a non-primary key [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") column with a client side default such as the Python
    `uuid.uuid4()` function. There is also a construct to create simple integer columns
    with a a client side integer counter oriented towards the “insertmanyvalues” use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sentinel columns may be indicated by adding [`Column.insert_sentinel`](metadata.html#sqlalchemy.schema.Column.params.insert_sentinel
    "sqlalchemy.schema.Column") to qualifying columns. The most basic “qualifying”
    column is a not-nullable, unique column with a client side default, such as a
    UUID column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative models, the same forms are available using the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: While the values generated by the default generator **must** be unique, the
    actual UNIQUE constraint on the above “sentinel” column, indicated by the `unique=True`
    parameter, itself is optional and may be omitted if not desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a special form of “insert sentinel” that’s a dedicated nullable
    integer column which makes use of a special default integer counter that’s only
    used during “insertmanyvalues” operations; as an additional behavior, the column
    will omit itself from SQL statements and result sets and behave in a mostly transparent
    manner. It does need to be physically present within the actual database table,
    however. This style of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    may be constructed using the function [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'When using ORM Declarative, a Declarative-friendly version of [`insert_sentinel()`](metadata.html#sqlalchemy.schema.insert_sentinel
    "sqlalchemy.schema.insert_sentinel") is available called [`orm_insert_sentinel()`](../orm/mapping_api.html#sqlalchemy.orm.orm_insert_sentinel
    "sqlalchemy.orm.orm_insert_sentinel"), which has the ability to be used on the
    Base class or a mixin; if packaged using [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"), the column will apply itself to all table-bound
    subclasses including within joined inheritance hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, both “my_table” and “sub_table” will have an additional
    integer column named “_sentinel” that can be used by the “insertmanyvalues” feature
    to help optimize bulk inserts used by the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: '### Controlling the Batch Size'
  prefs: []
  type: TYPE_NORMAL
- en: A key characteristic of “insertmanyvalues” is that the size of the INSERT statement
    is limited on a fixed max number of “values” clauses as well as a dialect-specific
    fixed total number of bound parameters that may be represented in one INSERT statement
    at a time. When the number of parameter dictionaries given exceeds a fixed limit,
    or when the total number of bound parameters to be rendered in a single INSERT
    statement exceeds a fixed limit (the two fixed limits are separate), multiple
    INSERT statements will be invoked within the scope of a single [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") call, each of which accommodate for a
    portion of the parameter dictionaries, known as a “batch”. The number of parameter
    dictionaries represented within each “batch” is then known as the “batch size”.
    For example, a batch size of 500 means that each INSERT statement emitted will
    INSERT at most 500 rows.
  prefs: []
  type: TYPE_NORMAL
- en: It’s potentially important to be able to adjust the batch size, as a larger
    batch size may be more performant for an INSERT where the value sets themselves
    are relatively small, and a smaller batch size may be more appropriate for an
    INSERT that uses very large value sets, where both the size of the rendered SQL
    as well as the total data size being passed in one statement may benefit from
    being limited to a certain size based on backend behavior and memory constraints.
    For this reason the batch size can be configured on a per-[`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as well as a per-statement basis. The parameter limit
    on the other hand is fixed based on the known characteristics of the database
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: The batch size defaults to 1000 for most backends, with an additional per-dialect
    “max number of parameters” limiting factor that may reduce the batch size further
    on a per-statement basis. The max number of parameters varies by dialect and server
    version; the largest size is 32700 (chosen as a healthy distance away from PostgreSQL’s
    limit of 32767 and SQLite’s modern limit of 32766, while leaving room for additional
    parameters in the statement as well as for DBAPI quirkiness). Older versions of
    SQLite (prior to 3.32.0) will set this value to 999\. MariaDB has no established
    limit however 32700 remains as a limiting factor for SQL message size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the “batch size” can be affected [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") wide via the [`create_engine.insertmanyvalues_page_size`](engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter. Such as, to affect INSERT statements to
    include up to 100 parameter sets in each statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'The batch size may also be affected on a per statement basis using the [`Connection.execution_options.insertmanyvalues_page_size`](#sqlalchemy.engine.Connection.execution_options.params.insertmanyvalues_page_size
    "sqlalchemy.engine.Connection.execution_options") execution option, such as per
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'Or configured on the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '### Logging and Events'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “insertmanyvalues” feature integrates fully with SQLAlchemy’s [statement
    logging](engines.html#dbengine-logging) as well as cursor events such as [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute"). When the list of
    parameters is broken into separate batches, **each INSERT statement is logged
    and passed to event handlers individually**. This is a major change compared to
    how the psycopg2-only feature worked in previous 1.x series of SQLAlchemy, where
    the production of multiple INSERT statements was hidden from logging and events.
    Logging display will truncate the long lists of parameters for readability, and
    will also indicate the specific batch of each statement. The example below illustrates
    an excerpt of this logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: 'When [non-batch mode](#engine-insertmanyvalues-non-batch) takes place, logging
    will indicate this along with the insertmanyvalues message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Logging](engines.html#dbengine-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Upsert Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL, SQLite, and MariaDB dialects offer backend-specific “upsert”
    constructs [`insert()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert"), [`insert()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") and [`insert()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert"), which are each [`Insert`](dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs that have an additional method
    such as `on_conflict_do_update()` or ``on_duplicate_key()`. These constructs also
    support “insertmanyvalues” behaviors when they are used with RETURNING, allowing
    efficient upserts with RETURNING to take place.
  prefs: []
  type: TYPE_NORMAL
- en: '## Engine Disposal'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") refers
    to a connection pool, which means under normal circumstances, there are open database
    connections present while the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object is still resident in memory. When an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is garbage collected, its connection pool is no longer
    referred to by that [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"),
    and assuming none of its connections are still checked out, the pool and its connections
    will also be garbage collected, which has the effect of closing out the actual
    database connections as well. But otherwise, the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") will hold onto open database connections assuming
    it uses the normally default pool implementation of [`QueuePool`](pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  prefs: []
  type: TYPE_NORMAL
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is intended
    to normally be a permanent fixture established up-front and maintained throughout
    the lifespan of an application. It is **not** intended to be created and disposed
    on a per-connection basis; it is instead a registry that maintains both a pool
    of connections as well as configurational information about the database and DBAPI
    in use, as well as some degree of internal caching of per-database resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many cases where it is desirable that all connection resources
    referred to by the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    be completely closed out. It’s generally not a good idea to rely on Python garbage
    collection for this to occur for these cases; instead, the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") can be explicitly disposed using the [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") method. This disposes of the engine’s underlying
    connection pool and replaces it with a new one that’s empty. Provided that the
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is discarded
    at this point and no longer used, all **checked-in** connections which it refers
    to will also be fully closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid use cases for calling [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") include:'
  prefs: []
  type: TYPE_NORMAL
- en: When a program wants to release any remaining checked-in connections held by
    the connection pool and expects to no longer be connected to that database at
    all for any future operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a program uses multiprocessing or `fork()`, and an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object is copied to the child process, [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") should be called so that the engine creates
    brand new database connections local to that fork. Database connections generally
    do **not** travel across process boundaries. Use the [`Engine.dispose.close`](#sqlalchemy.engine.Engine.dispose.params.close
    "sqlalchemy.engine.Engine.dispose") parameter set to False in this case. See the
    section [Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)
    for more background on this use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within test suites or multitenancy scenarios where many ad-hoc, short-lived
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") objects may be
    created and disposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connections that are **checked out** are **not** discarded when the engine is
    disposed or garbage collected, as these connections are still strongly referenced
    elsewhere by the application. However, after [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") is called, those connections are no longer
    associated with that [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine");
    when they are closed, they will be returned to their now-orphaned connection pool
    which will ultimately be garbage collected, once all connections which refer to
    it are also no longer referenced anywhere. Since this process is not easy to control,
    it is strongly recommended that [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") is called only after all checked out connections
    are checked in or otherwise de-associated from their pool.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative for applications that are negatively impacted by the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object’s use of connection pooling is to disable pooling
    entirely. This typically incurs only a modest performance impact upon the use
    of new connections, and means that when a connection is checked in, it is entirely
    closed out and is not held in memory. See [Switching Pool Implementations](pooling.html#pool-switching)
    for guidelines on how to disable pooling.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Working with Driver SQL and Raw DBAPI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The introduction on using [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") made use of the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct in order to illustrate how textual
    SQL statements may be invoked. When working with SQLAlchemy, textual SQL is actually
    more of the exception rather than the norm, as the Core expression language and
    the ORM both abstract away the textual representation of SQL. However, the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct itself also provides some abstraction
    of textual SQL in that it normalizes how bound parameters are passed, as well
    as that it supports datatyping behavior for parameters and result set rows.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking SQL strings directly to the driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the use case where one wants to invoke textual SQL directly passed to the
    underlying driver (known as the [DBAPI](../glossary.html#term-DBAPI)) without
    any intervention from the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: Added the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Working with the DBAPI cursor directly'
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where SQLAlchemy does not provide a genericized way at
    accessing some [DBAPI](../glossary.html#term-DBAPI) functions, such as calling
    stored procedures as well as dealing with multiple result sets. In these cases,
    it’s just as expedient to deal with the raw DBAPI connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to access the raw DBAPI connection is to get it from an
    already present [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object directly. It is present using the [`Connection.connection`](#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: The DBAPI connection here is actually a “proxied” in terms of the originating
    connection pool, however this is an implementation detail that in most cases can
    be ignored. As this DBAPI connection is still contained within the scope of an
    owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object, it is best to make use of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object for most features such as transaction control
    as well as calling the [`Connection.close()`](#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") method; if these operations are performed
    on the DBAPI connection directly, the owning [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") will not be aware of these changes in state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the limitations imposed by the DBAPI connection that is maintained
    by an owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    a DBAPI connection is also available without the need to procure a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") first, using the [`Engine.raw_connection()`](#sqlalchemy.engine.Engine.raw_connection
    "sqlalchemy.engine.Engine.raw_connection") method of [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'This DBAPI connection is again a “proxied” form as was the case before. The
    purpose of this proxying is now apparent, as when we call the `.close()` method
    of this connection, the DBAPI connection is typically not actually closed, but
    instead [released](../glossary.html#term-released) back to the engine’s connection
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: While SQLAlchemy may in the future add built-in patterns for more DBAPI use
    cases, there are diminishing returns as these cases tend to be rarely needed and
    they also vary highly dependent on the type of DBAPI in use, so in any case the
    direct DBAPI calling pattern is always there for those cases where it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I get at the raw DBAPI connection when using an Engine?](../faq/connections.html#faq-dbapi-connection)
    - includes additional details about how the DBAPI connection is accessed as well
    as the “driver” connection when using asyncio drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some recipes for DBAPI connection use follow.  ### Calling Stored Procedures
    and User Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports calling stored procedures and user defined functions several
    ways. Please note that all DBAPIs have different practices, so you must consult
    your underlying DBAPI’s documentation for specifics in relation to your particular
    usage. The following examples are hypothetical and may not work with your underlying
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For stored procedures or functions with special syntactical or parameter concerns,
    DBAPI-level [callproc](https://legacy.python.org/dev/peps/pep-0249/#callproc)
    may potentially be used with your DBAPI. An example of this pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all DBAPIs use callproc and overall usage details will vary. The above example
    is only an illustration of how it might look to use a particular DBAPI function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your DBAPI may not have a `callproc` requirement *or* may require a stored
    procedure or user defined function to be invoked with another pattern, such as
    normal SQLAlchemy connection usage. One example of this usage pattern is, *at
    the time of this documentation’s writing*, executing a stored procedure in the
    PostgreSQL database with the psycopg2 DBAPI, which should be invoked with normal
    connection usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: This above example is hypothetical. The underlying database is not guaranteed
    to support “CALL” or “SELECT” in these situations, and the keyword may vary dependent
    on the function being a stored procedure or a user defined function. You should
    consult your underlying DBAPI and database documentation in these situations to
    determine the correct syntax and patterns to use.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Result Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiple result set support is available from a raw DBAPI cursor using the
    [nextset](https://legacy.python.org/dev/peps/pep-0249/#nextset) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Invoking SQL strings directly to the driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the use case where one wants to invoke textual SQL directly passed to the
    underlying driver (known as the [DBAPI](../glossary.html#term-DBAPI)) without
    any intervention from the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: Added the [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Working with the DBAPI cursor directly'
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where SQLAlchemy does not provide a genericized way at
    accessing some [DBAPI](../glossary.html#term-DBAPI) functions, such as calling
    stored procedures as well as dealing with multiple result sets. In these cases,
    it’s just as expedient to deal with the raw DBAPI connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to access the raw DBAPI connection is to get it from an
    already present [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object directly. It is present using the [`Connection.connection`](#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: The DBAPI connection here is actually a “proxied” in terms of the originating
    connection pool, however this is an implementation detail that in most cases can
    be ignored. As this DBAPI connection is still contained within the scope of an
    owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object, it is best to make use of the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object for most features such as transaction control
    as well as calling the [`Connection.close()`](#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") method; if these operations are performed
    on the DBAPI connection directly, the owning [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") will not be aware of these changes in state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the limitations imposed by the DBAPI connection that is maintained
    by an owning [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    a DBAPI connection is also available without the need to procure a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") first, using the [`Engine.raw_connection()`](#sqlalchemy.engine.Engine.raw_connection
    "sqlalchemy.engine.Engine.raw_connection") method of [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: 'This DBAPI connection is again a “proxied” form as was the case before. The
    purpose of this proxying is now apparent, as when we call the `.close()` method
    of this connection, the DBAPI connection is typically not actually closed, but
    instead [released](../glossary.html#term-released) back to the engine’s connection
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: While SQLAlchemy may in the future add built-in patterns for more DBAPI use
    cases, there are diminishing returns as these cases tend to be rarely needed and
    they also vary highly dependent on the type of DBAPI in use, so in any case the
    direct DBAPI calling pattern is always there for those cases where it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I get at the raw DBAPI connection when using an Engine?](../faq/connections.html#faq-dbapi-connection)
    - includes additional details about how the DBAPI connection is accessed as well
    as the “driver” connection when using asyncio drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: Some recipes for DBAPI connection use follow.
  prefs: []
  type: TYPE_NORMAL
- en: '### Calling Stored Procedures and User Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports calling stored procedures and user defined functions several
    ways. Please note that all DBAPIs have different practices, so you must consult
    your underlying DBAPI’s documentation for specifics in relation to your particular
    usage. The following examples are hypothetical and may not work with your underlying
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For stored procedures or functions with special syntactical or parameter concerns,
    DBAPI-level [callproc](https://legacy.python.org/dev/peps/pep-0249/#callproc)
    may potentially be used with your DBAPI. An example of this pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all DBAPIs use callproc and overall usage details will vary. The above example
    is only an illustration of how it might look to use a particular DBAPI function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your DBAPI may not have a `callproc` requirement *or* may require a stored
    procedure or user defined function to be invoked with another pattern, such as
    normal SQLAlchemy connection usage. One example of this usage pattern is, *at
    the time of this documentation’s writing*, executing a stored procedure in the
    PostgreSQL database with the psycopg2 DBAPI, which should be invoked with normal
    connection usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: This above example is hypothetical. The underlying database is not guaranteed
    to support “CALL” or “SELECT” in these situations, and the keyword may vary dependent
    on the function being a stored procedure or a user defined function. You should
    consult your underlying DBAPI and database documentation in these situations to
    determine the correct syntax and patterns to use.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Result Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiple result set support is available from a raw DBAPI cursor using the
    [nextset](https://legacy.python.org/dev/peps/pep-0249/#nextset) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Registering New Dialects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`create_engine()`](engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function call locates the given dialect using setuptools entrypoints. These entry
    points can be established for third party dialects within the setup.py script.
    For example, to create a new dialect “foodialect://”, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a package called `foodialect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package should have a module containing the dialect class, which is typically
    a subclass of [`sqlalchemy.engine.default.DefaultDialect`](internals.html#sqlalchemy.engine.default.DefaultDialect
    "sqlalchemy.engine.default.DefaultDialect"). In this example let’s say it’s called
    `FooDialect` and its module is accessed via `foodialect.dialect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The entry point can be established in `setup.cfg` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the dialect is providing support for a particular DBAPI on top of an existing
    SQLAlchemy-supported database, the name can be given including a database-qualification.
    For example, if `FooDialect` were in fact a MySQL dialect, the entry point could
    be established like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: The above entrypoint would then be accessed as `create_engine("mysql+foodialect://")`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Dialects In-Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy also allows a dialect to be registered within the current process,
    bypassing the need for separate installation. Use the `register()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: The above will respond to `create_engine("mysql+foodialect://")` and load the
    `MyMySQLDialect` class from the `myapp.dialect` module.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Dialects In-Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy also allows a dialect to be registered within the current process,
    bypassing the need for separate installation. Use the `register()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: The above will respond to `create_engine("mysql+foodialect://")` and load the
    `MyMySQLDialect` class from the `myapp.dialect` module.
  prefs: []
  type: TYPE_NORMAL
- en: Connection / Engine API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Connection](#sqlalchemy.engine.Connection) | Provides high-level functionality
    for a wrapped DB-API connection. |'
  prefs: []
  type: TYPE_TB
- en: '| [CreateEnginePlugin](#sqlalchemy.engine.CreateEnginePlugin) | A set of hooks
    intended to augment the construction of an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object based on entrypoint names in a URL. |'
  prefs: []
  type: TYPE_TB
- en: '| [Engine](#sqlalchemy.engine.Engine) | Connects a [`Pool`](pooling.html#sqlalchemy.pool.Pool
    "sqlalchemy.pool.Pool") and [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect") together to provide a source of database
    connectivity and behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| [ExceptionContext](#sqlalchemy.engine.ExceptionContext) | Encapsulate information
    about an error condition in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| [NestedTransaction](#sqlalchemy.engine.NestedTransaction) | Represent a ‘nested’,
    or SAVEPOINT transaction. |'
  prefs: []
  type: TYPE_TB
- en: '| [RootTransaction](#sqlalchemy.engine.RootTransaction) | Represent the “root”
    transaction on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Transaction](#sqlalchemy.engine.Transaction) | Represent a database transaction
    in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| [TwoPhaseTransaction](#sqlalchemy.engine.TwoPhaseTransaction) | Represent
    a two-phase transaction. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Provides high-level functionality for a wrapped DB-API connection.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is procured by calling the [`Engine.connect()`](#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method of the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object, and provides services for execution of SQL
    statements as well as transaction control.
  prefs: []
  type: TYPE_NORMAL
- en: The Connection object is **not** thread-safe. While a Connection can be shared
    among threads using properly synchronized access, it is still possible that the
    underlying DBAPI connection may not support shared access between threads. Check
    the DBAPI documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.Connection.__init__), [begin()](#sqlalchemy.engine.Connection.begin),
    [begin_nested()](#sqlalchemy.engine.Connection.begin_nested), [begin_twophase()](#sqlalchemy.engine.Connection.begin_twophase),
    [close()](#sqlalchemy.engine.Connection.close), [closed](#sqlalchemy.engine.Connection.closed),
    [commit()](#sqlalchemy.engine.Connection.commit), [connection](#sqlalchemy.engine.Connection.connection),
    [default_isolation_level](#sqlalchemy.engine.Connection.default_isolation_level),
    [detach()](#sqlalchemy.engine.Connection.detach), [exec_driver_sql()](#sqlalchemy.engine.Connection.exec_driver_sql),
    [execute()](#sqlalchemy.engine.Connection.execute), [execution_options()](#sqlalchemy.engine.Connection.execution_options),
    [get_execution_options()](#sqlalchemy.engine.Connection.get_execution_options),
    [get_isolation_level()](#sqlalchemy.engine.Connection.get_isolation_level), [get_nested_transaction()](#sqlalchemy.engine.Connection.get_nested_transaction),
    [get_transaction()](#sqlalchemy.engine.Connection.get_transaction), [in_nested_transaction()](#sqlalchemy.engine.Connection.in_nested_transaction),
    [in_transaction()](#sqlalchemy.engine.Connection.in_transaction), [info](#sqlalchemy.engine.Connection.info),
    [invalidate()](#sqlalchemy.engine.Connection.invalidate), [invalidated](#sqlalchemy.engine.Connection.invalidated),
    [rollback()](#sqlalchemy.engine.Connection.rollback), [scalar()](#sqlalchemy.engine.Connection.scalar),
    [scalars()](#sqlalchemy.engine.Connection.scalars), [schema_for_object()](#sqlalchemy.engine.Connection.schema_for_object)'
  prefs: []
  type: TYPE_NORMAL
- en: The Connection object represents a single DBAPI connection checked out from
    the connection pool. In this state, the connection pool has no affect upon the
    connection, including its expiration or timeout state. For the connection pool
    to properly manage connections, connections should be returned to the connection
    pool (i.e. `connection.close()`) whenever the connection is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    (`sqlalchemy.engine.interfaces.ConnectionEventsTarget`, `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new Connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Begin a transaction prior to autobegin occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: The returned object is an instance of [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction"). This object represents the “scope” of the
    transaction, which completes when either the [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") method is called; the object also works
    as a context manager as illustrated above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    method begins a transaction that normally will be begun in any case when the connection
    is first used to execute a statement. The reason this method might be used would
    be to invoke the [`ConnectionEvents.begin()`](events.html#sqlalchemy.events.ConnectionEvents.begin
    "sqlalchemy.events.ConnectionEvents.begin") event at a specific time, or to organize
    code within the scope of a connection checkout in terms of context managed blocks,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code is not fundamentally any different in its behavior than the
    following code which does not use [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"); the below style is known as “commit as
    you go” style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: From a database point of view, the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method does not emit any SQL or change the
    state of the underlying DBAPI connection in any way; the Python DBAPI does not
    have any concept of explicit transaction begin.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Transactions and the DBAPI](../tutorial/dbapi_transactions.html#tutorial-working-with-transactions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested "sqlalchemy.engine.Connection.begin_nested")
    - use a SAVEPOINT'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase") - use a two phase /XID transaction'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")
    - context manager available from [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Begin a nested transaction (i.e. SAVEPOINT) and return a transaction handle
    that controls the scope of the SAVEPOINT.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: The returned object is an instance of [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction"), which includes transactional methods [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") and [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback"); for a nested transaction, these
    methods correspond to the operations “RELEASE SAVEPOINT <name>” and “ROLLBACK
    TO SAVEPOINT <name>”. The name of the savepoint is local to the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") object and is generated automatically.
    Like any other [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction"),
    the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction")
    may be used as a context manager as illustrated above which will “release” or
    “rollback” corresponding to if the operation within the block were successful
    or raised an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested transactions require SAVEPOINT support in the underlying database, else
    the behavior is undefined. SAVEPOINT is commonly used to run operations within
    a transaction that may fail, while continuing the outer transaction. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'If [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") is called without first calling [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") or [`Engine.begin()`](#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object will “autobegin” the outer transaction
    first. This outer transaction may be committed using “commit-as-you-go” style,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0: [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") will now participate in the connection
    “autobegin” behavior that is new as of 2.0 / “future” style connections in 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SAVEPOINT](../orm/session_transaction.html#session-begin-nested) - ORM
    support for SAVEPOINT'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Begin a two-phase or XA transaction and return a transaction handle.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is an instance of [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction"), which in addition to the methods provided
    by [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction"),
    also provides a [`TwoPhaseTransaction.prepare()`](#sqlalchemy.engine.TwoPhaseTransaction.prepare
    "sqlalchemy.engine.TwoPhaseTransaction.prepare") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xid** – the two phase transaction id. If not supplied, a random id will be
    generated.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This results in a release of the underlying database resources, that is, the
    DBAPI connection referenced internally. The DBAPI connection is typically restored
    back to the connection-holding [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    referenced by the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that produced this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    Any transactional state present on the DBAPI connection is also unconditionally
    released via the DBAPI connection’s `rollback()` method, regardless of any [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object that may be outstanding with regards to
    this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This has the effect of also calling [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") if any transaction is in place.
  prefs: []
  type: TYPE_NORMAL
- en: After [`Connection.close()`](#sqlalchemy.engine.Connection.close "sqlalchemy.engine.Connection.close")
    is called, the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is permanently in a closed state, and will allow no further operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Commit the transaction that is currently in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This method commits the current transaction if one has been started. If no transaction
    was started, the method has no effect, assuming the connection is in a non-invalidated
    state.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is begun on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    automatically whenever a statement is first executed, or when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    method only acts upon the primary database transaction that is linked to the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. It does not operate upon a SAVEPOINT that
    would have been invoked from the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method; for control of a SAVEPOINT,
    call [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") on the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") that is returned by the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: The underlying DB-API connection managed by this Connection.
  prefs: []
  type: TYPE_NORMAL
- en: This is a SQLAlchemy connection-pool proxied connection which then has the attribute
    `_ConnectionFairy.dbapi_connection` that refers to the actual driver connection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Driver SQL and Raw DBAPI Connections](#dbapi-connections)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: The initial-connection time isolation level associated with the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") in use.
  prefs: []
  type: TYPE_NORMAL
- en: This value is independent of the [`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") and [`Engine.execution_options.isolation_level`](#sqlalchemy.engine.Engine.execution_options.params.isolation_level
    "sqlalchemy.engine.Engine.execution_options") execution options, and is determined
    by the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    when the first connection is created, by performing a SQL query against the database
    for the current isolation level before any additional commands have been emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Calling this accessor does not invoke any new SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.get_isolation_level()`](#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") - view current actual isolation
    level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") - set per [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") - set per [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Detach the underlying DB-API connection from its connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: This [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    instance will remain usable. When closed (or exited from a context manager context
    as above), the DB-API connection will be literally closed and not returned to
    its originating pool.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be used to insulate the rest of an application from a modified
    state on a connection (such as a transaction isolation level or similar).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Executes a string SQL statement on the DBAPI cursor directly, without any SQL
    compilation steps.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to pass any string directly to the `cursor.execute()` method
    of the DBAPI in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`statement` – The statement str to be executed. Bound parameters must use the
    underlying DBAPI’s paramstyle, such as “qmark”, “pyformat”, “format”, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` – represent bound parameter values to be used in the execution.
    The format is one of: a dictionary of named parameters, a tuple of positional
    parameters, or a list containing either dictionaries or tuples for multiple-execute
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. multiple dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: 'Single dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'Single tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method does not participate in
    the [`ConnectionEvents.before_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_execute
    "sqlalchemy.events.ConnectionEvents.before_execute") and [`ConnectionEvents.after_execute()`](events.html#sqlalchemy.events.ConnectionEvents.after_execute
    "sqlalchemy.events.ConnectionEvents.after_execute") events. To intercept calls
    to [`Connection.exec_driver_sql()`](#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql"), use [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") and [`ConnectionEvents.after_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute
    "sqlalchemy.events.ConnectionEvents.after_cursor_execute").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[**PEP 249**](https://peps.python.org/pep-0249/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Executes a SQL statement construct and returns a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`statement` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The statement to be executed. This is always an object that is in both the
    [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement "sqlalchemy.sql.expression.ClauseElement")
    and [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable")
    hierarchies, including:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Select`](selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Insert`](dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert"),
    [`Update`](dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update"),
    [`Delete`](dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TextClause`](sqlelement.html#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    and [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DDL`](ddl.html#sqlalchemy.schema.DDL "sqlalchemy.schema.DDL") and objects
    which inherit from [`ExecutableDDLElement`](ddl.html#sqlalchemy.schema.ExecutableDDLElement
    "sqlalchemy.schema.ExecutableDDLElement")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters` – parameters which will be bound into the statement. This may
    be either a dictionary of parameter names to values, or a mutable sequence (e.g.
    a list) of dictionaries. When a list of dictionaries is passed, the underlying
    statement execution will make use of the DBAPI `cursor.executemany()` method.
    When a single dictionary is passed, the DBAPI `cursor.execute()` method will be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution_options` – optional dictionary of execution options, which will
    be associated with the statement execution. This dictionary can provide a subset
    of the options that are accepted by [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: Set non-SQL options for the connection which take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: This method modifies this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    **in-place**; the return value is the same [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object upon which the method is called. Note that
    this is in contrast to the behavior of the `execution_options` methods on other
    objects such as [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") and [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"). The rationale is that
    many such execution options necessarily modify the state of the base DBAPI connection
    in any case so there is no feasible means of keeping the effect of such an option
    localized to a “sub” connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method, in contrast to other
    objects with this method, modifies the connection in-place without creating copy
    of it.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed elsewhere, the [`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method accepts any arbitrary
    parameters including user defined names. All parameters given are consumable in
    a number of ways including by using the [`Connection.get_execution_options()`](#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options") method. See the examples
    at [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") and [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options").
  prefs: []
  type: TYPE_NORMAL
- en: The keywords that are currently recognized by SQLAlchemy itself include all
    those listed under [`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), as well as others that
    are specific to [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compiled_cache` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A dictionary where [`Compiled`](internals.html#sqlalchemy.engine.Compiled "sqlalchemy.engine.Compiled")
    objects will be cached when the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    compiles a clause expression into a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. This dictionary will supersede the statement
    cache that may be configured on the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    itself. If set to None, caching is disabled, even if the engine has a configured
    cache size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the ORM makes use of its own “compiled” caches for some operations,
    including flush operations. The caching used by the ORM internally supersedes
    a cache dictionary specified here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`logging_token` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adds the specified string token surrounded by brackets in log messages logged
    by the connection, i.e. the logging that’s enabled either via the [`create_engine.echo`](engines.html#sqlalchemy.create_engine.params.echo
    "sqlalchemy.create_engine") flag or via the `logging.getLogger("sqlalchemy.engine")`
    logger. This allows a per-connection or per-sub-engine token to be available which
    is useful for debugging concurrent connection scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.0b2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Per-Connection / Sub-Engine Tokens](engines.html#dbengine-logging-tokens)
    - usage example'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`create_engine.logging_name`](engines.html#sqlalchemy.create_engine.params.logging_name
    "sqlalchemy.create_engine") - adds a name to the name used by the Python logger
    object itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isolation_level` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the transaction isolation level for the lifespan of this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. Valid values include those string values
    accepted by the [`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter passed to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). These levels are semi-database specific; see individual
    dialect documentation for valid levels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The isolation level option applies the isolation level by emitting statements
    on the DBAPI connection, and **necessarily affects the original Connection object
    overall**. The isolation level will remain at the given setting until explicitly
    changed, or when the DBAPI connection itself is [released](../glossary.html#term-released)
    to the connection pool, i.e. the [`Connection.close()`](#sqlalchemy.engine.Connection.close
    "sqlalchemy.engine.Connection.close") method is called, at which time an event
    handler will emit additional statements on the DBAPI connection in order to revert
    the isolation level change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `isolation_level` execution option may only be established before the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called, as well as before any
    SQL statements are emitted which would otherwise trigger “autobegin”, or directly
    after a call to [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    or [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback").
    A database cannot change the isolation level on a transaction in progress.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `isolation_level` execution option is implicitly reset if the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is invalidated, e.g. via the [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method, or if a disconnection error
    occurs. The new connection produced after the invalidation will **not** have the
    selected isolation level re-applied to it automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](#dbapi-autocommit)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.get_isolation_level()`](#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") - view current actual level'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`no_parameters` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When `True`, if the final parameter list or dictionary is totally empty, will
    invoke the statement on the cursor as `cursor.execute(statement)`, not passing
    the parameter collection at all. Some DBAPIs such as psycopg2 and mysql-python
    consider percent signs as significant only when parameters are present; this option
    allows code to generate SQL containing percent signs (and possibly other characters)
    that is neutral regarding whether it’s executed by the DBAPI or piped into a script
    that’s later invoked by command line tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stream_results` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indicate to the dialect that results should be “streamed” and not pre-buffered,
    if possible. For backends such as PostgreSQL, MySQL and MariaDB, this indicates
    the use of a “server side cursor” as opposed to a client side cursor. Other backends
    such as that of Oracle may already use server side cursors by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The usage of [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") is usually combined with setting
    a fixed number of rows to to be fetched in batches, to allow for efficient iteration
    of database rows while at the same time not loading all result rows into memory
    at once; this can be configured on a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object using the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method, after execution has returned a new [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"). If [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") is not used, the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") mode of operation will instead
    use a dynamically sized buffer which buffers sets of rows at a time, growing on
    each batch based on a fixed growth size up until a limit which may be configured
    using the [`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using the ORM to fetch ORM mapped objects from a result, [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") should always be used with [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options"), so that the ORM does not fetch
    all rows into new ORM objects at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For typical use, the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option should be preferred,
    which sets up both [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") and [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") at once. This option is supported both at
    a core level by [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    as well as by the ORM `Session`; the latter is described at [Fetching Large Result
    Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - background on [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.max_row_buffer`](#sqlalchemy.engine.Connection.execution_options.params.max_row_buffer
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) describing the ORM
    version of `yield_per`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_row_buffer` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").
    Sets a maximum buffer size to use when the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used on
    a backend that supports server side cursors. The default value if not specified
    is 1000.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`yield_per` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable "sqlalchemy.sql.expression.Executable").
    Integer value applied which will set the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option and invoke
    [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    automatically at once. Allows equivalent functionality as is present when using
    this parameter with the ORM.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.40.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - background and examples on using server side cursors with Core.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) describing the ORM
    version of `yield_per`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`insertmanyvalues_page_size` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"). Number of rows
    to format into an INSERT statement when the statement uses “insertmanyvalues”
    mode, which is a paged form of bulk insert that is used for many backends when
    using [executemany](../glossary.html#term-executemany) execution typically in
    conjunction with RETURNING. Defaults to 1000\. May also be modified on a per-engine
    basis using the [`create_engine.insertmanyvalues_page_size`](engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](#engine-insertmanyvalues)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`schema_translate_map` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Available on: [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"), [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable").'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A dictionary mapping schema names to schema names, that will be applied to the
    [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema "sqlalchemy.schema.Table")
    element of each [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    encountered when SQL or DDL expression elements are compiled into strings; the
    resulting schema name will be converted based on presence in the map of the original
    name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Translation of Schema Names](#schema-translating)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`preserve_rowcount` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean; when True, the `cursor.rowcount` attribute will be unconditionally
    memoized within the result and made available via the [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") attribute. Normally, this attribute
    is only preserved for UPDATE and DELETE statements. Using this option, the DBAPIs
    rowcount value can be accessed for other kinds of statements such as INSERT and
    SELECT, to the degree that the DBAPI supports these statements. See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") for notes regarding the behavior of
    this attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.28.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Executable.execution_options()`](selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.get_execution_options()`](#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Execution Options](../orm/queryguide/api.html#orm-queryguide-execution-options)
    - documentation on all ORM-specific execution options'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Get the non-SQL options which will take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Return the current **actual** isolation level that’s present on the database
    within the scope of this connection.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute will perform a live SQL operation against the database in order
    to procure the current isolation level, so the value returned is the actual level
    on the underlying DBAPI connection regardless of how this state was set. This
    will be one of the four actual isolation modes `READ UNCOMMITTED`, `READ COMMITTED`,
    `REPEATABLE READ`, `SERIALIZABLE`. It will **not** include the `AUTOCOMMIT` isolation
    level setting. Third party dialects may also feature additional isolation level
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method **will not report** on the `AUTOCOMMIT` isolation level, which is
    a separate [dbapi](../glossary.html#term-DBAPI) setting that’s independent of
    **actual** isolation level. When `AUTOCOMMIT` is in use, the database connection
    still has a “traditional” isolation mode in effect, that is typically one of the
    four values `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Compare to the [`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") accessor which returns
    the isolation level that is present on the database at initial connection time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.default_isolation_level`](#sqlalchemy.engine.Connection.default_isolation_level
    "sqlalchemy.engine.Connection.default_isolation_level") - view default level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`create_engine.isolation_level`](engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") - set per [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.isolation_level`](#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") - set per [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") isolation level'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Return the current nested transaction in progress, if any.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: Return the current root transaction in progress, if any.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Return True if a transaction is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: Return True if a transaction is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Info dictionary associated with the underlying DBAPI connection referred to
    by this [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    allowing user-defined data to be associated with the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The data here will follow along with the DBAPI connection including after it
    is returned to the connection pool and used again in subsequent instances of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Invalidate the underlying DBAPI connection associated with this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: An attempt will be made to close the underlying DBAPI connection immediately;
    however if this operation fails, the error is logged but not raised. The connection
    is then discarded whether or not close() succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Upon the next use (where “use” typically means using the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method or similar), this [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") will attempt to procure a new DBAPI connection
    using the services of the [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    as a source of connectivity (e.g. a “reconnection”).
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction was in progress (e.g. the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method has been called) when [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate") method is called, at the DBAPI level
    all state associated with this transaction is lost, as the DBAPI connection is
    closed. The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    will not allow a reconnection to proceed until the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") object is ended, by calling the [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") method; until that point, any attempt
    at continuing to use the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    will raise an [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError"). This is to prevent applications from accidentally
    continuing an ongoing transactional operations despite the fact that the transaction
    has been lost due to an invalidation.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.invalidate()`](#sqlalchemy.engine.Connection.invalidate "sqlalchemy.engine.Connection.invalidate")
    method, just like auto-invalidation, will at the connection pool level invoke
    the [`PoolEvents.invalidate()`](events.html#sqlalchemy.events.PoolEvents.invalidate
    "sqlalchemy.events.PoolEvents.invalidate") event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**exception** – an optional `Exception` instance that’s the reason for the
    invalidation. is passed along to event handlers and logging functions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[More on Invalidation](pooling.html#pool-connection-invalidation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this connection was invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: This does not indicate whether or not the connection was invalidated at the
    pool level, however
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: Roll back the transaction that is currently in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This method rolls back the current transaction if one has been started. If no
    transaction was started, the method has no effect. If a transaction was started
    and the connection is in an invalidated state, the transaction is cleared using
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is begun on a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    automatically whenever a statement is first executed, or when the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback")
    method only acts upon the primary database transaction that is linked to the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. It does not operate upon a SAVEPOINT that
    would have been invoked from the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method; for control of a SAVEPOINT,
    call [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback") on the [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") that is returned by the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Executes a SQL statement construct and returns a scalar object.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for invoking the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method after invoking the [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method. Parameters are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a scalar Python value representing the first column of the first row returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Executes and returns a scalar result set, which yields scalar values from the
    first column of each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method is equivalent to calling [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") to receive a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, then invoking the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method to produce a [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.24.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Return the schema name for the given schema item taking into account current
    schema translate map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: A set of hooks intended to augment the construction of an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object based on entrypoint names in a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is to allow third-party systems to apply
    engine, pool and dialect level event listeners without the need for the target
    application to be modified; instead, the plugin names can be added to the database
    URL. Target applications for [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") include:'
  prefs: []
  type: TYPE_NORMAL
- en: connection and SQL performance tools, e.g. which use events to track number
    of checkouts and/or time spent with statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: connectivity plugins such as proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A rudimentary [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that attaches a logger to an [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugins are registered using entry points in a similar way as that of dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'A plugin that uses the above names would be invoked from a database URL as
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plugin` URL parameter supports multiple instances, so that a URL may specify
    multiple plugins; they are loaded in the order stated in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin names may also be passed directly to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") using the [`create_engine.plugins`](engines.html#sqlalchemy.create_engine.params.plugins
    "sqlalchemy.create_engine") argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.2.3: plugin names can also be specified to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as a list'
  prefs: []
  type: TYPE_NORMAL
- en: A plugin may consume plugin-specific arguments from the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object as well as the `kwargs` dictionary, which is the
    dictionary of arguments passed to the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. “Consuming” these arguments includes that they
    must be removed when the plugin initializes, so that the arguments are not passed
    along to the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    constructor, where they will raise an [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") because they are not known by the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of version 1.4 of SQLAlchemy, arguments should continue to be consumed from
    the `kwargs` dictionary directly, by removing the values with a method such as
    `dict.pop`. Arguments from the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object should be consumed by implementing the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method, returning a new copy
    of the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") with
    plugin-specific parameters removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments like those illustrated above would be consumed from a [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object is now immutable; a [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that needs to alter the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") should implement the newly added [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method, which is invoked after
    the plugin is constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For migration, construct the plugin in the following way, checking for the
    existence of the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method to detect which version
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The URL object is now immutable](../changelog/migration_14.html#change-5526)
    - overview of the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    change which also includes notes regarding [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.CreateEnginePlugin.__init__), [engine_created()](#sqlalchemy.engine.CreateEnginePlugin.engine_created),
    [handle_dialect_kwargs()](#sqlalchemy.engine.CreateEnginePlugin.handle_dialect_kwargs),
    [handle_pool_kwargs()](#sqlalchemy.engine.CreateEnginePlugin.handle_pool_kwargs),
    [update_url()](#sqlalchemy.engine.CreateEnginePlugin.update_url)'
  prefs: []
  type: TYPE_NORMAL
- en: When the engine creation process completes and produces the [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object, it is again passed to the plugin via the [`CreateEnginePlugin.engine_created()`](#sqlalchemy.engine.CreateEnginePlugin.engine_created
    "sqlalchemy.engine.CreateEnginePlugin.engine_created") hook. In this hook, additional
    changes can be made to the engine, most typically involving setup of events (e.g.
    those defined in [Core Events](events.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin").
  prefs: []
  type: TYPE_NORMAL
- en: The plugin object is instantiated individually for each call to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). A single `Engine` will be passed to the [`CreateEnginePlugin.engine_created()`](#sqlalchemy.engine.CreateEnginePlugin.engine_created
    "sqlalchemy.engine.CreateEnginePlugin.engine_created") method corresponding to
    this URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") object.
    The plugin may inspect the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    for arguments. Arguments used by the plugin should be removed, by returning an
    updated [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") from
    the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object is now immutable, so a [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") that needs to alter the [`URL`](engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object should implement the [`CreateEnginePlugin.update_url()`](#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`kwargs` – The keyword arguments passed to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Receive the [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object when it is fully constructed.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin may make additional changes to the engine, such as registering engine
    or connection pool events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: parse and modify dialect kwargs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: parse and modify pool kwargs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Update the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL").
  prefs: []
  type: TYPE_NORMAL
- en: A new [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") should
    be returned. This method is typically used to consume configuration arguments
    from the [`URL`](engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") which
    must be removed, as they will not be recognized by the dialect. The [`URL.difference_update_query()`](engines.html#sqlalchemy.engine.URL.difference_update_query
    "sqlalchemy.engine.URL.difference_update_query") method is available to remove
    these arguments. See the docstring at [`CreateEnginePlugin`](#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for an example.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Connects a [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool")
    and [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    together to provide a source of database connectivity and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: An [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") object is
    instantiated publicly using the [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Engine Configuration](engines.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](#)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[begin()](#sqlalchemy.engine.Engine.begin), [clear_compiled_cache()](#sqlalchemy.engine.Engine.clear_compiled_cache),
    [connect()](#sqlalchemy.engine.Engine.connect), [dispose()](#sqlalchemy.engine.Engine.dispose),
    [driver](#sqlalchemy.engine.Engine.driver), [engine](#sqlalchemy.engine.Engine.engine),
    [execution_options()](#sqlalchemy.engine.Engine.execution_options), [get_execution_options()](#sqlalchemy.engine.Engine.get_execution_options),
    [name](#sqlalchemy.engine.Engine.name), [raw_connection()](#sqlalchemy.engine.Engine.raw_connection),
    [update_execution_options()](#sqlalchemy.engine.Engine.update_execution_options)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    (`sqlalchemy.engine.interfaces.ConnectionEventsTarget`, [`sqlalchemy.log.Identified`](internals.html#sqlalchemy.log.Identified
    "sqlalchemy.log.Identified"), `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Return a context manager delivering a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") with a [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") established.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Upon successful operation, the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") is committed. If an error is raised, the [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") is rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.connect()`](#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")
    - procure a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    from an [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")
    - start a [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    for a particular [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Clear the compiled cache associated with the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: This applies **only** to the built-in cache that is established via the `create_engine.query_cache_size`
    parameter. It will not impact any dictionary caches that were passed via the [`Connection.execution_options.compiled_cache`](#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    acts as a Python context manager, so the typical use of this method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Where above, after the block is completed, the connection is “closed” and its
    underlying DBAPI resources are returned to the connection pool. This also has
    the effect of rolling back any transaction that was explicitly begun or was begun
    via autobegin, and will emit the [`ConnectionEvents.rollback()`](events.html#sqlalchemy.events.ConnectionEvents.rollback
    "sqlalchemy.events.ConnectionEvents.rollback") event if one was started and is
    still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.begin()`](#sqlalchemy.engine.Engine.begin "sqlalchemy.engine.Engine.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Dispose of the connection pool used by this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: A new connection pool is created immediately after the old one has been disposed.
    The previous connection pool is disposed either actively, by closing out all currently
    checked-in connections in that pool, or passively, by losing references to it
    but otherwise not closing any connections. The latter strategy is more appropriate
    for an initializer in a forked Python process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**close** –'
  prefs: []
  type: TYPE_NORMAL
- en: if left at its default of `True`, has the effect of fully closing all **currently
    checked in** database connections. Connections that are still checked out will
    **not** be closed, however they will no longer be associated with this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), so when they are closed individually, eventually
    the [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool") which they
    are associated with will be garbage collected and they will be closed out fully,
    if not already closed on checkin.
  prefs: []
  type: TYPE_NORMAL
- en: If set to `False`, the previous connection pool is de-referenced, and otherwise
    not touched in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.33: Added the [`Engine.dispose.close`](#sqlalchemy.engine.Engine.dispose.params.close
    "sqlalchemy.engine.Engine.dispose") parameter to allow the replacement of a connection
    pool in a child process without interfering with the connections used by the parent
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Engine Disposal](#engine-disposal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Connection Pools with Multiprocessing or os.fork()](pooling.html#pooling-multiprocessing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Driver name of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    in use by this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: Returns this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: Used for legacy schemes that accept [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") / [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    objects within the same variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that will provide [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects with the given execution options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    remains related to the original [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    in that it shares the same connection pool and other state:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Pool`](pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool") used
    by the new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") is
    the same instance. The [`Engine.dispose()`](#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") method will replace the connection pool instance
    for the parent engine as well as this one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners are “cascaded” - meaning, the new [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") inherits the events of the parent, and new events
    can be associated with the new [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging configuration and logging_name is copied from the parent [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intent of the [`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options") method is to implement schemes where
    multiple [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") objects
    refer to the same connection pool, but are differentiated by options that affect
    some execution-level behavior for each engine. One such example is breaking into
    separate “reader” and “writer” [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    instances, where one [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    has a lower [isolation level](../glossary.html#term-isolation-level) setting configured
    or is even transaction-disabled using “autocommit”. An example of this configuration
    is at [Maintaining Multiple Isolation Levels for a Single Engine](#dbapi-autocommit-multiple).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is one that uses a custom option `shard_id` which is consumed
    by an event to change the current schema on a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: The above recipe illustrates two [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    objects that will each serve as factories for [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that have pre-established “shard_id” execution
    options present. A [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") event handler then
    interprets this execution option to emit a MySQL `use` statement to switch databases
    before a statement execution, while at the same time keeping track of which database
    we’ve established using the [`Connection.info`](#sqlalchemy.engine.Connection.info
    "sqlalchemy.engine.Connection.info") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") - update execution options on
    a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.update_execution_options()`](#sqlalchemy.engine.Engine.update_execution_options
    "sqlalchemy.engine.Engine.update_execution_options") - update the execution options
    for a given [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") in
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.get_execution_options()`](#sqlalchemy.engine.Engine.get_execution_options
    "sqlalchemy.engine.Engine.get_execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: Get the non-SQL options which will take effect during execution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: String name of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    in use by this [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: Return a “raw” DBAPI connection from the connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is a proxied version of the DBAPI connection object used
    by the underlying driver in use. The object will have all the same behavior as
    the real DBAPI connection, except that its `close()` method will result in the
    connection being returned to the pool, rather than being closed for real.
  prefs: []
  type: TYPE_NORMAL
- en: This method provides direct DBAPI connection access for special situations when
    the API provided by [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is not needed. When a [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is already present, the DBAPI connection is available using the [`Connection.connection`](#sqlalchemy.engine.Connection.connection
    "sqlalchemy.engine.Connection.connection") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Driver SQL and Raw DBAPI Connections](#dbapi-connections)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Update the default execution_options dictionary of this [`Engine`](#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: The given keys/values in **opt are added to the default execution options that
    will be used for all connections. The initial contents of this dictionary can
    be sent via the `execution_options` parameter to [`create_engine()`](engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options()`](#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Engine.execution_options()`](#sqlalchemy.engine.Engine.execution_options
    "sqlalchemy.engine.Engine.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulate information about an error condition in progress.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[chained_exception](#sqlalchemy.engine.ExceptionContext.chained_exception),
    [connection](#sqlalchemy.engine.ExceptionContext.connection), [cursor](#sqlalchemy.engine.ExceptionContext.cursor),
    [dialect](#sqlalchemy.engine.ExceptionContext.dialect), [engine](#sqlalchemy.engine.ExceptionContext.engine),
    [execution_context](#sqlalchemy.engine.ExceptionContext.execution_context), [invalidate_pool_on_disconnect](#sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect),
    [is_disconnect](#sqlalchemy.engine.ExceptionContext.is_disconnect), [is_pre_ping](#sqlalchemy.engine.ExceptionContext.is_pre_ping),
    [original_exception](#sqlalchemy.engine.ExceptionContext.original_exception),
    [parameters](#sqlalchemy.engine.ExceptionContext.parameters), [sqlalchemy_exception](#sqlalchemy.engine.ExceptionContext.sqlalchemy_exception),
    [statement](#sqlalchemy.engine.ExceptionContext.statement)'
  prefs: []
  type: TYPE_NORMAL
- en: This object exists solely to be passed to the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") event, supporting an interface
    that can be extended without backwards-incompatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: The exception that was returned by the previous handler in the exception chain,
    if any.
  prefs: []
  type: TYPE_NORMAL
- en: If present, this exception will be the one ultimately raised by SQLAlchemy unless
    a subsequent handler replaces it.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: The [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    in use during the exception.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present, except in the case of a failure when first connecting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExceptionContext.engine`](#sqlalchemy.engine.ExceptionContext.engine "sqlalchemy.engine.ExceptionContext.engine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: The DBAPI cursor object.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: The [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present for all invocations of the event hook.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: The [`Engine`](#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine") in use
    during the exception.
  prefs: []
  type: TYPE_NORMAL
- en: This member is present in all cases except for when handling an error within
    the connection pool “pre-ping” process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: The [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    corresponding to the execution operation in progress.
  prefs: []
  type: TYPE_NORMAL
- en: This is present for statement execution operations, but not for operations such
    as transaction begin/end. It also is not present when the exception was raised
    before the [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext") could be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the [`ExceptionContext.statement`](#sqlalchemy.engine.ExceptionContext.statement
    "sqlalchemy.engine.ExceptionContext.statement") and [`ExceptionContext.parameters`](#sqlalchemy.engine.ExceptionContext.parameters
    "sqlalchemy.engine.ExceptionContext.parameters") members may represent a different
    value than that of the [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext"), potentially in the case where a [`ConnectionEvents.before_cursor_execute()`](events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") event or similar modified
    the statement/parameters to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Represent whether all connections in the pool should be invalidated when a “disconnect”
    condition is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: Setting this flag to False within the scope of the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") event will have the effect such
    that the full collection of connections in the pool will not be invalidated during
    a disconnect; only the current connection that is the subject of the error will
    actually be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this flag is for custom disconnect-handling schemes where the
    invalidation of other connections in the pool is to be performed based on other
    conditions, or even on a per-connection basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: Represent whether the exception as occurred represents a “disconnect” condition.
  prefs: []
  type: TYPE_NORMAL
- en: This flag will always be True or False within the scope of the [`DialectEvents.handle_error()`](events.html#sqlalchemy.events.DialectEvents.handle_error
    "sqlalchemy.events.DialectEvents.handle_error") handler.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will defer to this flag in order to determine whether or not the
    connection should be invalidated subsequently. That is, by assigning to this flag,
    a “disconnect” event which then results in a connection and pool invalidation
    can be invoked or prevented by changing this flag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The pool “pre_ping” handler enabled using the [`create_engine.pool_pre_ping`](engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine") parameter does **not** consult this event before deciding
    if the “ping” returned false, as opposed to receiving an unhandled error. For
    this use case, the [legacy recipe based on engine_connect() may be used](pooling.html#pool-disconnects-pessimistic-custom).
    A future API allow more comprehensive customization of the “disconnect” detection
    mechanism across all functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this error is occurring within the “pre-ping” step performed when
    [`create_engine.pool_pre_ping`](engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine") is set to `True`. In this mode, the [`ExceptionContext.engine`](#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") attribute will be `None`. The dialect
    in use is accessible via the [`ExceptionContext.dialect`](#sqlalchemy.engine.ExceptionContext.dialect
    "sqlalchemy.engine.ExceptionContext.dialect") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: The exception object which was caught.
  prefs: []
  type: TYPE_NORMAL
- en: This member is always present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Parameter collection that was emitted directly to the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: The [`sqlalchemy.exc.StatementError`](exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") which wraps the original, and will be raised
    if exception handling is not circumvented by the event.
  prefs: []
  type: TYPE_NORMAL
- en: May be None, as not all exception types are wrapped by SQLAlchemy. For DBAPI-level
    exceptions that subclass the dbapi’s Error class, this field will always be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: String SQL statement that was emitted directly to the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: May be None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Represent a ‘nested’, or SAVEPOINT transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction")
    object is created by calling the [`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    the semantics of “begin” / “commit” / “rollback” are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the “begin” operation corresponds to the “BEGIN SAVEPOINT” command, where the
    savepoint is given an explicit name that is part of the state of this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NestedTransaction.commit()`](#sqlalchemy.engine.NestedTransaction.commit
    "sqlalchemy.engine.NestedTransaction.commit") method corresponds to a “RELEASE
    SAVEPOINT” operation, using the savepoint identifier associated with this [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NestedTransaction.rollback()`](#sqlalchemy.engine.NestedTransaction.rollback
    "sqlalchemy.engine.NestedTransaction.rollback") method corresponds to a “ROLLBACK
    TO SAVEPOINT” operation, using the savepoint identifier associated with this [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rationale for mimicking the semantics of an outer transaction in terms of
    savepoints so that code may deal with a “savepoint” transaction and an “outer”
    transaction in an agnostic way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SAVEPOINT](../orm/session_transaction.html#session-begin-nested) - ORM
    version of the SAVEPOINT API.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.NestedTransaction.close), [commit()](#sqlalchemy.engine.NestedTransaction.commit),
    [rollback()](#sqlalchemy.engine.NestedTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.NestedTransaction`](#sqlalchemy.engine.NestedTransaction
    "sqlalchemy.engine.NestedTransaction") ([`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Represent the “root” transaction on a [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to the current “BEGIN/COMMIT/ROLLBACK” that’s occurring for
    the [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection").
    The [`RootTransaction`](#sqlalchemy.engine.RootTransaction "sqlalchemy.engine.RootTransaction")
    is created by calling upon the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, and remains associated with the
    [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection") throughout
    its active span. The current [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") in use is accessible via the [`Connection.get_transaction`](#sqlalchemy.engine.Connection.get_transaction
    "sqlalchemy.engine.Connection.get_transaction") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: In [2.0 style](../glossary.html#term-2.0-style) use, the [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") also employs “autobegin” behavior that will create
    a new [`RootTransaction`](#sqlalchemy.engine.RootTransaction "sqlalchemy.engine.RootTransaction")
    whenever a connection in a non-transactional state is used to emit commands on
    the DBAPI connection. The scope of the [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") in 2.0 style use can be controlled using
    the [`Connection.commit()`](#sqlalchemy.engine.Connection.commit "sqlalchemy.engine.Connection.commit")
    and [`Connection.rollback()`](#sqlalchemy.engine.Connection.rollback "sqlalchemy.engine.Connection.rollback")
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.RootTransaction.close), [commit()](#sqlalchemy.engine.RootTransaction.commit),
    [rollback()](#sqlalchemy.engine.RootTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction") ([`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: Represent a database transaction in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    object is procured by calling the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method of [`Connection`](#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'The object provides [`rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") and [`commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") methods in order to control transaction
    boundaries. It also implements a context manager interface so that the Python
    `with` statement can be used with the [`Connection.begin()`](#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: The Transaction object is **not** threadsafe.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.Transaction.close), [commit()](#sqlalchemy.engine.Transaction.commit),
    [rollback()](#sqlalchemy.engine.Transaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin()`](#sqlalchemy.engine.Connection.begin "sqlalchemy.engine.Connection.begin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.begin_nested()`](#sqlalchemy.engine.Connection.begin_nested "sqlalchemy.engine.Connection.begin_nested")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    (`sqlalchemy.engine.util.TransactionalContext`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Represent a two-phase transaction.
  prefs: []
  type: TYPE_NORMAL
- en: A new [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction")
    object may be procured using the [`Connection.begin_twophase()`](#sqlalchemy.engine.Connection.begin_twophase
    "sqlalchemy.engine.Connection.begin_twophase") method.
  prefs: []
  type: TYPE_NORMAL
- en: The interface is the same as that of [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") with the addition of the [`prepare()`](#sqlalchemy.engine.TwoPhaseTransaction.prepare
    "sqlalchemy.engine.TwoPhaseTransaction.prepare") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.TwoPhaseTransaction.close), [commit()](#sqlalchemy.engine.TwoPhaseTransaction.commit),
    [prepare()](#sqlalchemy.engine.TwoPhaseTransaction.prepare), [rollback()](#sqlalchemy.engine.TwoPhaseTransaction.rollback)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction") ([`sqlalchemy.engine.RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.close()`](#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: If this transaction is the base transaction in a begin/commit nesting, the transaction
    will rollback(). Otherwise, the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to cancel a Transaction without affecting the scope of an enclosing
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.commit()`](#sqlalchemy.engine.Transaction.commit
    "sqlalchemy.engine.Transaction.commit") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Commit this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a COMMIT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “RELEASE SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Prepare this [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction
    "sqlalchemy.engine.TwoPhaseTransaction").
  prefs: []
  type: TYPE_NORMAL
- en: After a PREPARE, the transaction can be committed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Transaction.rollback()`](#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") *method of* [`Transaction`](#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back this [`Transaction`](#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction").
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this may vary based on the type of transaction in use:'
  prefs: []
  type: TYPE_NORMAL
- en: For a simple database transaction (e.g. [`RootTransaction`](#sqlalchemy.engine.RootTransaction
    "sqlalchemy.engine.RootTransaction")), it corresponds to a ROLLBACK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`NestedTransaction`](#sqlalchemy.engine.NestedTransaction "sqlalchemy.engine.NestedTransaction"),
    it corresponds to a “ROLLBACK TO SAVEPOINT” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`TwoPhaseTransaction`](#sqlalchemy.engine.TwoPhaseTransaction "sqlalchemy.engine.TwoPhaseTransaction"),
    DBAPI-specific methods for two phase transactions may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result Set API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ChunkedIteratorResult](#sqlalchemy.engine.ChunkedIteratorResult) | An [`IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult") that works from an iterator-producing callable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [CursorResult](#sqlalchemy.engine.CursorResult) | A Result that is representing
    state from a DBAPI cursor. |'
  prefs: []
  type: TYPE_TB
- en: '| [FilterResult](#sqlalchemy.engine.FilterResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns objects other than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, such as dictionaries or scalar objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [FrozenResult](#sqlalchemy.engine.FrozenResult) | Represents a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object in a “frozen” state suitable for caching. |'
  prefs: []
  type: TYPE_TB
- en: '| [IteratorResult](#sqlalchemy.engine.IteratorResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that gets data from a Python iterator of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects or similar row-like data. |'
  prefs: []
  type: TYPE_TB
- en: '| [MappingResult](#sqlalchemy.engine.MappingResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns dictionary values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values. |'
  prefs: []
  type: TYPE_TB
- en: '| [MergedResult](#sqlalchemy.engine.MergedResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that is merged from any number of [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Result](#sqlalchemy.engine.Result) | Represent a set of database results.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Row](#sqlalchemy.engine.Row) | Represent a single result row. |'
  prefs: []
  type: TYPE_TB
- en: '| [RowMapping](#sqlalchemy.engine.RowMapping) | A `Mapping` that maps column
    names and objects to [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ScalarResult](#sqlalchemy.engine.ScalarResult) | A wrapper for a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that returns scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values. |'
  prefs: []
  type: TYPE_TB
- en: '| [TupleResult](#sqlalchemy.engine.TupleResult) | A [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that’s typed as returning plain Python tuples instead
    of rows. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: An [`IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult")
    that works from an iterator-producing callable.
  prefs: []
  type: TYPE_NORMAL
- en: The given `chunks` argument is a function that is given a number of rows to
    return in each chunk, or `None` for all rows. The function should then return
    an un-consumed iterator of lists, each list of the requested size.
  prefs: []
  type: TYPE_NORMAL
- en: The function can be called at any time again, in which case it should continue
    from the same result set but adjust the chunk size as given.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[yield_per()](#sqlalchemy.engine.ChunkedIteratorResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.ChunkedIteratorResult`](#sqlalchemy.engine.ChunkedIteratorResult
    "sqlalchemy.engine.ChunkedIteratorResult") ([`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: A Result that is representing state from a DBAPI cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `CursorResult`` class replaces the previous `ResultProxy`
    interface. This classes are based on the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") calling API which provides an updated usage model
    and calling facade for SQLAlchemy Core and SQLAlchemy ORM.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns database rows via the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class, which provides additional API features and behaviors on top of the raw
    data returned by the DBAPI. Through the use of filters such as the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, other kinds of objects may also be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SELECT Statements](../tutorial/data_select.html#tutorial-selecting-data)
    - introductory material for accessing [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") and [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.CursorResult.all), [close()](#sqlalchemy.engine.CursorResult.close),
    [columns()](#sqlalchemy.engine.CursorResult.columns), [fetchall()](#sqlalchemy.engine.CursorResult.fetchall),
    [fetchmany()](#sqlalchemy.engine.CursorResult.fetchmany), [fetchone()](#sqlalchemy.engine.CursorResult.fetchone),
    [first()](#sqlalchemy.engine.CursorResult.first), [freeze()](#sqlalchemy.engine.CursorResult.freeze),
    [inserted_primary_key](#sqlalchemy.engine.CursorResult.inserted_primary_key),
    [inserted_primary_key_rows](#sqlalchemy.engine.CursorResult.inserted_primary_key_rows),
    [is_insert](#sqlalchemy.engine.CursorResult.is_insert), [keys()](#sqlalchemy.engine.CursorResult.keys),
    [last_inserted_params()](#sqlalchemy.engine.CursorResult.last_inserted_params),
    [last_updated_params()](#sqlalchemy.engine.CursorResult.last_updated_params),
    [lastrow_has_defaults()](#sqlalchemy.engine.CursorResult.lastrow_has_defaults),
    [lastrowid](#sqlalchemy.engine.CursorResult.lastrowid), [mappings()](#sqlalchemy.engine.CursorResult.mappings),
    [merge()](#sqlalchemy.engine.CursorResult.merge), [one()](#sqlalchemy.engine.CursorResult.one),
    [one_or_none()](#sqlalchemy.engine.CursorResult.one_or_none), [partitions()](#sqlalchemy.engine.CursorResult.partitions),
    [postfetch_cols()](#sqlalchemy.engine.CursorResult.postfetch_cols), [prefetch_cols()](#sqlalchemy.engine.CursorResult.prefetch_cols),
    [returned_defaults](#sqlalchemy.engine.CursorResult.returned_defaults), [returned_defaults_rows](#sqlalchemy.engine.CursorResult.returned_defaults_rows),
    [returns_rows](#sqlalchemy.engine.CursorResult.returns_rows), [rowcount](#sqlalchemy.engine.CursorResult.rowcount),
    [scalar()](#sqlalchemy.engine.CursorResult.scalar), [scalar_one()](#sqlalchemy.engine.CursorResult.scalar_one),
    [scalar_one_or_none()](#sqlalchemy.engine.CursorResult.scalar_one_or_none), [scalars()](#sqlalchemy.engine.CursorResult.scalars),
    [splice_horizontally()](#sqlalchemy.engine.CursorResult.splice_horizontally),
    [splice_vertically()](#sqlalchemy.engine.CursorResult.splice_vertically), [supports_sane_multi_rowcount()](#sqlalchemy.engine.CursorResult.supports_sane_multi_rowcount),
    [supports_sane_rowcount()](#sqlalchemy.engine.CursorResult.supports_sane_rowcount),
    [t](#sqlalchemy.engine.CursorResult.t), [tuples()](#sqlalchemy.engine.CursorResult.tuples),
    [unique()](#sqlalchemy.engine.CursorResult.unique), [yield_per()](#sqlalchemy.engine.CursorResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    ([`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return all rows in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set after invocation. Subsequent invocations will return an
    empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - How to stream a large result set without loading it completely in python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: This closes out the underlying DBAPI cursor corresponding to the statement execution,
    if one is still present. Note that the DBAPI cursor is automatically released
    when the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    exhausts all available rows. [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") is generally an optional method except
    in the case when discarding a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") that still has additional rows pending for fetch.
  prefs: []
  type: TYPE_NORMAL
- en: After this method is called, it is no longer valid to call upon the fetch methods,
    which will raise a [`ResourceClosedError`](exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError") on subsequent use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](#)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be used to limit the columns returned as well as to reorder
    them. The given list of expressions are normally a series of integers or string
    key names. They may also be appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects which correspond to a given
    statement construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Due to a bug in 1.4, the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method had an incorrect behavior where calling
    upon the method with just one index would cause the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object to yield scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects. In version 2.0, this behavior has been corrected
    such that calling upon [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") with a single index will produce a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that continues to yield [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, which include only a single column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of using the column objects from the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***col_expressions** – indicates columns to be returned. Elements may be integer
    row indexes, string column names, or appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects corresponding to a select construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    with the modifications given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchall()`](#sqlalchemy.engine.Result.fetchall
    "sqlalchemy.engine.Result.fetchall") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for the [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch many rows.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch rows in groups, use the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch one row.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns None.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the first row of a result only, use the [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") method. To iterate through all rows, iterate
    the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object if no filters
    are applied, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the first row or `None` if no row is present.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set and discards remaining rows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in contrast to the behavior of the legacy ORM [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") method, **no limit is applied** to the SQL query
    which was invoked to produce this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result");
    for a DBAPI driver that buffers results in memory before yielding rows, all rows
    will be sent to the Python process and all but the first row will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query Unified with Core Select](../changelog/migration_20.html#migration-20-unify-select)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object, or None if
    no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.freeze()`](#sqlalchemy.engine.Result.freeze "sqlalchemy.engine.Result.freeze")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a callable object that will produce copies of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The callable object returned is an instance of [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult").
  prefs: []
  type: TYPE_NORMAL
- en: This is used for result set caching. The method must be called on the result
    when it has been unconsumed, and calling the method will consume the result fully.
    When the [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    is retrieved from a cache, it can be called any number of times where it will
    produce a new [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object each time against its stored set of rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Return the primary key for the row just inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object representing a named tuple of primary key values in the order in which
    the primary key columns are configured in the source [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.8: - the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") value is now a named tuple
    via the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") class, rather
    than a plain tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: This accessor only applies to single row [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") constructs which did not explicitly specify
    [`Insert.returning()`](dml.html#sqlalchemy.sql.expression.Insert.returning "sqlalchemy.sql.expression.Insert.returning").
    Support for multirow inserts, while not yet available for most backends, would
    be accessed using the [`CursorResult.inserted_primary_key_rows`](#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Note that primary key columns which specify a server_default clause, or otherwise
    do not qualify as “autoincrement” columns (see the notes at [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")), and were generated using the database-side default,
    will appear in this list as `None` unless the backend supports “returning” and
    the insert statement executed with the “implicit returning” enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Return the value of [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") as a row contained within
    a list; some dialects may support a multiple row form as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As indicated below, in current SQLAlchemy versions this accessor is only useful
    beyond what’s already supplied by [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") when using the [psycopg2](../dialects/postgresql.html#postgresql-psycopg2)
    dialect. Future versions hope to generalize this feature to more dialects.
  prefs: []
  type: TYPE_NORMAL
- en: This accessor is added to support dialects that offer the feature that is currently
    implemented by the [Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)
    feature, currently **only the psycopg2 dialect**, which provides for many rows
    to be INSERTed at once while still retaining the behavior of being able to return
    server-generated primary key values.
  prefs: []
  type: TYPE_NORMAL
- en: '`When using the psycopg2 dialect, or other dialects that may support “fast
    executemany” style inserts in upcoming releases` : When invoking an INSERT statement
    while passing a list of rows as the second argument to [`Connection.execute()`](#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), this accessor will then provide a list
    of rows, where each row contains the primary key value for each row that was INSERTed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When using all other dialects / backends that don’t yet support this feature`:
    This accessor is only useful for `single row INSERT statements`, and returns the
    same information as that of the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") within a single-element
    list. When an INSERT statement is executed in conjunction with a list of rows
    to be INSERTed, the list will contain one row per row inserted in the statement,
    however it will contain `None` for any server-generated values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future releases of SQLAlchemy will further generalize the “fast execution helper”
    feature of psycopg2 to suit other dialects, thus allowing this accessor to be
    of more general use.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: True if this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    is the result of a executing an expression language compiled [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: When True, this implies that the [`inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") attribute is accessible,
    assuming the statement did not include a user defined “returning” construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: Return the collection of inserted parameters from this execution.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Return the collection of updated parameters from this execution.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: Return `lastrow_has_defaults()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: Return the ‘lastrowid’ accessor on the DBAPI cursor.
  prefs: []
  type: TYPE_NORMAL
- en: This is a DBAPI specific method and is only functional for those backends which
    support it, for statements where it is appropriate. It’s behavior is not consistent
    across backends.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of this method is normally unnecessary when using insert() expression
    constructs; the [`CursorResult.inserted_primary_key`](#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") attribute provides a tuple
    of primary key values for a newly inserted row, regardless of database backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a mappings filter to returned rows, returning an instance of [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied, fetching rows will return [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") objects instead of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: Merge this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    with other compatible result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is an instance of [`MergedResult`](#sqlalchemy.engine.MergedResult
    "sqlalchemy.engine.MergedResult"), which will be composed of iterators from the
    given result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new result will use the metadata from this result object. The subsequent
    result objects must be against an identical set of result / cursor metadata, otherwise
    the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one row or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound "sqlalchemy.exc.NoResultFound")
    if the result returns no rows, or [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound"), [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound
    "sqlalchemy.exc.NoResultFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one "sqlalchemy.engine.Result.scalar_one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return at most one result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if the result has no rows. Raises [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") or `None`
    if no row is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through sub-lists of rows of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Each list will be of the size given, excluding the last list to be yielded,
    which may have a small number of rows. No empty lists will be yielded.
  prefs: []
  type: TYPE_NORMAL
- en: The result object is automatically closed when the iterator is fully consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend driver will usually buffer the entire result ahead of
    time unless the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used indicating
    that the driver should not pre-buffer results, if possible. Not all drivers support
    this option and the option is silently ignored for those who do not.
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM, the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method is typically more effective from
    a memory perspective when it is combined with use of the [yield_per execution
    option](../orm/queryguide/api.html#orm-queryguide-yield-per), which instructs
    both the DBAPI driver to use server side cursors, if available, as well as instructs
    the ORM loading internals to only build a certain amount of ORM objects from a
    result at a time before yielding them out.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size** – indicate the maximum number of rows to be present in each list yielded.
    If None, makes use of the value set by the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per"), method, if it were called, or the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which is equivalent
    in this regard. If yield_per weren’t set, it makes use of the [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") default, which may be backend specific and
    not well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: iterator of lists
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: Return `postfetch_cols()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() or update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Return `prefetch_cols()` from the underlying [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext
    "sqlalchemy.engine.ExecutionContext").
  prefs: []
  type: TYPE_NORMAL
- en: See [`ExecutionContext`](internals.html#sqlalchemy.engine.ExecutionContext "sqlalchemy.engine.ExecutionContext")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`InvalidRequestError`](exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") if the executed statement is not a compiled
    expression construct or is not an insert() or update() construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: Return the values of default columns that were fetched using the `ValuesBase.return_defaults()`
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: The value is an instance of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row"),
    or `None` if `ValuesBase.return_defaults()` was not used or if the backend does
    not support RETURNING.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`ValuesBase.return_defaults()`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of rows each containing the values of default columns that were
    fetched using the `ValuesBase.return_defaults()` feature.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a list of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: True if this [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    returns zero or more rows.
  prefs: []
  type: TYPE_NORMAL
- en: I.e. if it is legal to call the methods [`CursorResult.fetchone()`](#sqlalchemy.engine.CursorResult.fetchone
    "sqlalchemy.engine.CursorResult.fetchone"), [`CursorResult.fetchmany()`](#sqlalchemy.engine.CursorResult.fetchmany
    "sqlalchemy.engine.CursorResult.fetchmany") [`CursorResult.fetchall()`](#sqlalchemy.engine.CursorResult.fetchall
    "sqlalchemy.engine.CursorResult.fetchall").
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the value of [`CursorResult.returns_rows`](#sqlalchemy.engine.CursorResult.returns_rows
    "sqlalchemy.engine.CursorResult.returns_rows") should always be synonymous with
    whether or not the DBAPI cursor had a `.description` attribute, indicating the
    presence of result columns, noting that a cursor that returns zero rows still
    has a `.description` if a row-returning statement was emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute should be True for all results that are against SELECT statements,
    as well as for DML statements INSERT/UPDATE/DELETE that use RETURNING. For INSERT/UPDATE/DELETE
    statements that were not using RETURNING, the value will usually be False, however
    there are some dialect-specific exceptions to this, such as when using the MSSQL
    / pyodbc dialect a SELECT is emitted inline in order to retrieve an inserted primary
    key value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Return the ‘rowcount’ for this result.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of ‘rowcount’ is to report the number of rows matched by
    the WHERE criterion of an UPDATE or DELETE statement executed once (i.e. for a
    single parameter set), which may then be compared to the number of rows expected
    to be updated or deleted as a means of asserting data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is transferred from the `cursor.rowcount` attribute of the DBAPI
    before the cursor is closed, to support DBAPIs that don’t make this value available
    after cursor close. Some DBAPIs may offer meaningful values for other kinds of
    statements, such as INSERT and SELECT statements as well. In order to retrieve
    `cursor.rowcount` for these statements, set the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option to True, which
    will cause the `cursor.rowcount` value to be unconditionally memoized before any
    results are returned or the cursor is closed, regardless of statement type.
  prefs: []
  type: TYPE_NORMAL
- en: For cases where the DBAPI does not support rowcount for a particular kind of
    statement and/or execution, the returned value will be `-1`, which is delivered
    directly from the DBAPI and is part of [**PEP 249**](https://peps.python.org/pep-0249/).
    All DBAPIs should support rowcount for single-parameter-set UPDATE and DELETE
    statements, however.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes regarding [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount"):'
  prefs: []
  type: TYPE_NORMAL
- en: This attribute returns the number of rows *matched*, which is not necessarily
    the same as the number of rows that were actually *modified*. For example, an
    UPDATE statement may have no net change on a given row if the SET values given
    are the same as those present in the row already. Such a row would be matched
    but not modified. On backends that feature both styles, such as MySQL, rowcount
    is configured to return the match count in all cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    in the default case is *only* useful in conjunction with an UPDATE or DELETE statement,
    and only with a single set of parameters. For other kinds of statements, SQLAlchemy
    will not attempt to pre-memoize the value unless the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option is used. Note
    that contrary to [**PEP 249**](https://peps.python.org/pep-0249/), many DBAPIs
    do not support rowcount values for statements that are not UPDATE or DELETE, particularly
    when rows are being returned which are not fully pre-buffered. DBAPIs that dont
    support rowcount for a particular kind of statement should return the value `-1`
    for such statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    may not be meaningful when executing a single statement with multiple parameter
    sets (i.e. an [executemany](../glossary.html#term-executemany)). Most DBAPIs do
    not sum “rowcount” values across multiple parameter sets and will return `-1`
    when accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy’s [“Insert Many Values” Behavior for INSERT statements](#engine-insertmanyvalues)
    feature does support a correct population of [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") when the [`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options") execution option is set to True.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that use RETURNING may not support rowcount, returning a `-1` value
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting Affected Row Count from UPDATE, DELETE](../tutorial/data_update.html#tutorial-update-delete-rowcount)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Connection.execution_options.preserve_rowcount`](#sqlalchemy.engine.Connection.execution_options.params.preserve_rowcount
    "sqlalchemy.engine.Connection.execution_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the first column of the first row, and close the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if there are no rows to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: No validation is performed to test if additional rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: After calling this method, the object is fully closed, e.g. the [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") method will have been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python scalar value, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one scalar result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalar_one_or_none()`](#sqlalchemy.engine.Result.scalar_one_or_none
    "sqlalchemy.engine.Result.scalar_one_or_none") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return exactly one scalar result or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") *method of* [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object which will return single elements rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: When results are fetched from the [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") filtering object, the single column-row that
    would be returned by the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    is instead returned as the column’s value.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**index** – integer or row key indicating the column to be fetched from each
    row, defaults to `0` indicating the first column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    that “horizontally splices” together the rows of this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") with that of another [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This method is for the benefit of the SQLAlchemy ORM and is not intended for
    general use.
  prefs: []
  type: TYPE_NORMAL
- en: “horizontally splices” means that for each row in the first and second result
    sets, a new row that concatenates the two rows together is produced, which then
    becomes the new row. The incoming [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") must have the identical number of rows. It is
    typically expected that the two result sets come from the same sort order as well,
    as the result rows are spliced together based on their position in the result.
  prefs: []
  type: TYPE_NORMAL
- en: The expected use case here is so that multiple INSERT..RETURNING statements
    (which definitely need to be sorted) against different tables can produce a single
    result that looks like a JOIN of those two tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.splice_vertically()`](#sqlalchemy.engine.CursorResult.splice_vertically
    "sqlalchemy.engine.CursorResult.splice_vertically")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: Return a new [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    that “vertically splices”, i.e. “extends”, the rows of this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") with that of another [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This method is for the benefit of the SQLAlchemy ORM and is not intended for
    general use.
  prefs: []
  type: TYPE_NORMAL
- en: “vertically splices” means the rows of the given result are appended to the
    rows of this cursor result. The incoming [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") must have rows that represent the identical
    list of columns in the identical order as they are in this [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.splice_horizontally()`](#sqlalchemy.engine.CursorResult.splice_horizontally
    "sqlalchemy.engine.CursorResult.splice_horizontally")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Return `supports_sane_multi_rowcount` from the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Return `supports_sane_rowcount` from the dialect.
  prefs: []
  type: TYPE_NORMAL
- en: See [`CursorResult.rowcount`](#sqlalchemy.engine.CursorResult.rowcount "sqlalchemy.engine.CursorResult.rowcount")
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t")
    *attribute of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") attribute
    is a synonym for calling the [`Result.tuples()`](#sqlalchemy.engine.Result.tuples
    "sqlalchemy.engine.Result.tuples") method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.tuples()`](#sqlalchemy.engine.Result.tuples "sqlalchemy.engine.Result.tuples")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the same [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object at runtime, however annotates as returning a [`TupleResult`](#sqlalchemy.engine.TupleResult
    "sqlalchemy.engine.TupleResult") object that will indicate to [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools that plain typed `Tuple` instances are returned rather than rows.
    This allows tuple unpacking and `__getitem__` access of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects to by typed, for those cases where the statement
    invoked itself included typing information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the [`TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    type at typing time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") - shorter
    synonym'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") version'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    *method of* [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")'
  prefs: []
  type: TYPE_NORMAL
- en: Apply unique filtering to the objects returned by this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied with no arguments, the rows or objects returned
    will filtered such that each row is returned uniquely. The algorithm used to determine
    this uniqueness is by default the Python hashing identity of the whole tuple.
    In some cases a specialized per-entity hashing scheme may be used, such as when
    using the ORM, a scheme is applied which works against the primary key identity
    of returned objects.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter is applied **after all other filters**, which means if the
    columns returned have been refined using a method such as the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") or [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, the uniquing is applied to **only
    the column or columns returned**. This occurs regardless of the order in which
    these methods have been called upon the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter also changes the calculus used for methods like [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") and [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions"). When using [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique"), these methods will continue to yield the number
    of rows or objects requested, after uniquing has been applied. However, this necessarily
    impacts the buffering behavior of the underlying cursor or datasource, such that
    multiple underlying calls to `cursor.fetchmany()` may be necessary in order to
    accumulate enough objects in order to provide a unique collection of the requested
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**strategy** – a callable that will be applied to rows or objects being iterated,
    which should return an object that represents the unique value of the row. A Python
    `set()` is used to store these identities. If not passed, a default uniqueness
    strategy is used which may have been assembled by the source of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns objects other than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, such as dictionaries or scalar objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult")
    is the common base for additional result APIs including [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult"), [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") and `AsyncResult`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[close()](#sqlalchemy.engine.FilterResult.close), [closed](#sqlalchemy.engine.FilterResult.closed),
    [yield_per()](#sqlalchemy.engine.FilterResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult")
    (`sqlalchemy.engine.ResultInternal`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Represents a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object in a “frozen” state suitable for caching.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    object is returned from the [`Result.freeze()`](#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze") method of any [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new iterable [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object is generated from a fixed set of data each time the [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult") is invoked as a callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '`merge_frozen_result()` - ORM function to merge a frozen result back into a
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that gets
    data from a Python iterator of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects or similar row-like data.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[closed](#sqlalchemy.engine.IteratorResult.closed)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult
    "sqlalchemy.engine.IteratorResult") ([`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if this [`IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult")
    has been closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that is merged
    from any number of [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Returned by the [`Result.merge()`](#sqlalchemy.engine.Result.merge "sqlalchemy.engine.Result.merge")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.MergedResult`](#sqlalchemy.engine.MergedResult "sqlalchemy.engine.MergedResult")
    ([`sqlalchemy.engine.IteratorResult`](#sqlalchemy.engine.IteratorResult "sqlalchemy.engine.IteratorResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: Represent a set of database results.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object provides a completely updated usage model and calling facade for SQLAlchemy
    Core and SQLAlchemy ORM. In Core, it forms the basis of the [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") object which replaces the previous `ResultProxy`
    interface. When using the ORM, a higher level object called [`ChunkedIteratorResult`](#sqlalchemy.engine.ChunkedIteratorResult
    "sqlalchemy.engine.ChunkedIteratorResult") is normally used.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy 1.4 and above, this object is used for ORM results returned by
    [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute"),
    which can yield instances of ORM mapped objects either individually or within
    tuple-like rows. Note that the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object does not deduplicate instances or rows automatically as is the case with
    the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object. For in-Python de-duplication of instances or rows, use the [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") modifier method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Rows](../tutorial/dbapi_transactions.html#tutorial-fetching-rows)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.Result.all), [close()](#sqlalchemy.engine.Result.close),
    [closed](#sqlalchemy.engine.Result.closed), [columns()](#sqlalchemy.engine.Result.columns),
    [fetchall()](#sqlalchemy.engine.Result.fetchall), [fetchmany()](#sqlalchemy.engine.Result.fetchmany),
    [fetchone()](#sqlalchemy.engine.Result.fetchone), [first()](#sqlalchemy.engine.Result.first),
    [freeze()](#sqlalchemy.engine.Result.freeze), [keys()](#sqlalchemy.engine.Result.keys),
    [mappings()](#sqlalchemy.engine.Result.mappings), [merge()](#sqlalchemy.engine.Result.merge),
    [one()](#sqlalchemy.engine.Result.one), [one_or_none()](#sqlalchemy.engine.Result.one_or_none),
    [partitions()](#sqlalchemy.engine.Result.partitions), [scalar()](#sqlalchemy.engine.Result.scalar),
    [scalar_one()](#sqlalchemy.engine.Result.scalar_one), [scalar_one_or_none()](#sqlalchemy.engine.Result.scalar_one_or_none),
    [scalars()](#sqlalchemy.engine.Result.scalars), [t](#sqlalchemy.engine.Result.t),
    [tuples()](#sqlalchemy.engine.Result.tuples), [unique()](#sqlalchemy.engine.Result.unique),
    [yield_per()](#sqlalchemy.engine.Result.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    (`sqlalchemy.engine._WithKeys`, `sqlalchemy.engine.ResultInternal`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: Return all rows in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set after invocation. Subsequent invocations will return an
    empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - How to stream a large result set without loading it completely in python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: close this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of this method is implementation specific, and is not implemented
    by default. The method should generally end the resources in use by the result
    object and also cause any subsequent iteration or row fetching to raise [`ResourceClosedError`](exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.27: - `.close()` was previously not generally available
    for all [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") classes,
    instead only being available on the [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") returned for Core statement executions. As most
    other result objects, namely the ones used by the ORM, are proxying a [`CursorResult`](#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") in any case, this allows the underlying cursor
    result to be closed from the outside facade for the case when the ORM query is
    using the `yield_per` execution option where it does not immediately exhaust and
    autoclose the database cursor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: return `True` if this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports .closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be used to limit the columns returned as well as to reorder
    them. The given list of expressions are normally a series of integers or string
    key names. They may also be appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects which correspond to a given
    statement construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Due to a bug in 1.4, the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method had an incorrect behavior where calling
    upon the method with just one index would cause the [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object to yield scalar values rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects. In version 2.0, this behavior has been corrected
    such that calling upon [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") with a single index will produce a [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that continues to yield [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, which include only a single column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of using the column objects from the statement itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***col_expressions** – indicates columns to be returned. Elements may be integer
    row indexes, string column names, or appropriate [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects corresponding to a select construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object
    with the modifications given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many rows.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch rows in groups, use the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: Fetch one row.
  prefs: []
  type: TYPE_NORMAL
- en: When all rows are exhausted, returns None.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided for backwards compatibility with SQLAlchemy 1.x.x.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the first row of a result only, use the [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") method. To iterate through all rows, iterate
    the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") object directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object if no filters
    are applied, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first row or `None` if no row is present.
  prefs: []
  type: TYPE_NORMAL
- en: Closes the result set and discards remaining rows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar()`](#sqlalchemy.engine.Result.scalar
    "sqlalchemy.engine.Result.scalar") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.first()`](#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in contrast to the behavior of the legacy ORM [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") method, **no limit is applied** to the SQL query
    which was invoked to produce this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result");
    for a DBAPI driver that buffers results in memory before yielding rows, all rows
    will be sent to the Python process and all but the first row will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query Unified with Core Select](../changelog/migration_20.html#migration-20-unify-select)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object, or None if
    no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar()`](#sqlalchemy.engine.Result.scalar "sqlalchemy.engine.Result.scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Return a callable object that will produce copies of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The callable object returned is an instance of [`FrozenResult`](#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult").
  prefs: []
  type: TYPE_NORMAL
- en: This is used for result set caching. The method must be called on the result
    when it has been unconsumed, and calling the method will consume the result fully.
    When the [`FrozenResult`](#sqlalchemy.engine.FrozenResult "sqlalchemy.engine.FrozenResult")
    is retrieved from a cache, it can be called any number of times where it will
    produce a new [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object each time against its stored set of rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Re-Executing Statements](../orm/session_events.html#do-orm-execute-re-executing)
    - example usage within the ORM to implement a result-set cache.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: Apply a mappings filter to returned rows, returning an instance of [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied, fetching rows will return [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") objects instead of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Merge this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    with other compatible result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The object returned is an instance of [`MergedResult`](#sqlalchemy.engine.MergedResult
    "sqlalchemy.engine.MergedResult"), which will be composed of iterators from the
    given result objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new result will use the metadata from this result object. The subsequent
    result objects must be against an identical set of result / cursor metadata, otherwise
    the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one row or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Raises [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound "sqlalchemy.exc.NoResultFound")
    if the result returns no rows, or [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method returns one **row**, e.g. tuple, by default. To return exactly one
    single scalar value, that is, the first column of the first row, use the [`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method, or combine [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound"), [`NoResultFound`](exceptions.html#sqlalchemy.exc.NoResultFound
    "sqlalchemy.exc.NoResultFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalar_one()`](#sqlalchemy.engine.Result.scalar_one "sqlalchemy.engine.Result.scalar_one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if the result has no rows. Raises [`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound") if multiple rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") or `None`
    if no row is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultipleResultsFound`](exceptions.html#sqlalchemy.exc.MultipleResultsFound
    "sqlalchemy.exc.MultipleResultsFound")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of rows of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Each list will be of the size given, excluding the last list to be yielded,
    which may have a small number of rows. No empty lists will be yielded.
  prefs: []
  type: TYPE_NORMAL
- en: The result object is automatically closed when the iterator is fully consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the backend driver will usually buffer the entire result ahead of
    time unless the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option is used indicating
    that the driver should not pre-buffer results, if possible. Not all drivers support
    this option and the option is silently ignored for those who do not.
  prefs: []
  type: TYPE_NORMAL
- en: When using the ORM, the [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") method is typically more effective from
    a memory perspective when it is combined with use of the [yield_per execution
    option](../orm/queryguide/api.html#orm-queryguide-yield-per), which instructs
    both the DBAPI driver to use server side cursors, if available, as well as instructs
    the ORM loading internals to only build a certain amount of ORM objects from a
    result at a time before yielding them out.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size** – indicate the maximum number of rows to be present in each list yielded.
    If None, makes use of the value set by the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per"), method, if it were called, or the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which is equivalent
    in this regard. If yield_per weren’t set, it makes use of the [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") default, which may be backend specific and
    not well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: iterator of lists
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first column of the first row, and close the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `None` if there are no rows to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: No validation is performed to test if additional rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: After calling this method, the object is fully closed, e.g. the [`CursorResult.close()`](#sqlalchemy.engine.CursorResult.close
    "sqlalchemy.engine.CursorResult.close") method will have been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python scalar value, or `None` if no rows remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one scalar result or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one()`](#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one scalar result or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to calling [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") and then [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none "sqlalchemy.engine.Result.one_or_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.scalars()`](#sqlalchemy.engine.Result.scalars "sqlalchemy.engine.Result.scalars")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object which will return single elements rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: When results are fetched from the [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") filtering object, the single column-row that
    would be returned by the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    is instead returned as the column’s value.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**index** – integer or row key indicating the column to be fetched from each
    row, defaults to `0` indicating the first column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    filtering object referring to this [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") attribute
    is a synonym for calling the [`Result.tuples()`](#sqlalchemy.engine.Result.tuples
    "sqlalchemy.engine.Result.tuples") method.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: Apply a “typed tuple” typing filter to returned rows.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the same [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object at runtime, however annotates as returning a [`TupleResult`](#sqlalchemy.engine.TupleResult
    "sqlalchemy.engine.TupleResult") object that will indicate to [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools that plain typed `Tuple` instances are returned rather than rows.
    This allows tuple unpacking and `__getitem__` access of [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects to by typed, for those cases where the statement
    invoked itself included typing information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the [`TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    type at typing time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t") - shorter
    synonym'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") version'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result").
  prefs: []
  type: TYPE_NORMAL
- en: When this filter is applied with no arguments, the rows or objects returned
    will filtered such that each row is returned uniquely. The algorithm used to determine
    this uniqueness is by default the Python hashing identity of the whole tuple.
    In some cases a specialized per-entity hashing scheme may be used, such as when
    using the ORM, a scheme is applied which works against the primary key identity
    of returned objects.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter is applied **after all other filters**, which means if the
    columns returned have been refined using a method such as the [`Result.columns()`](#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") or [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method, the uniquing is applied to **only
    the column or columns returned**. This occurs regardless of the order in which
    these methods have been called upon the [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The unique filter also changes the calculus used for methods like [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany
    "sqlalchemy.engine.Result.fetchmany") and [`Result.partitions()`](#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions"). When using [`Result.unique()`](#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique"), these methods will continue to yield the number
    of rows or objects requested, after uniquing has been applied. However, this necessarily
    impacts the buffering behavior of the underlying cursor or datasource, such that
    multiple underlying calls to `cursor.fetchmany()` may be necessary in order to
    accumulate enough objects in order to provide a unique collection of the requested
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**strategy** – a callable that will be applied to rows or objects being iterated,
    which should return an object that represents the unique value of the row. A Python
    `set()` is used to store these identities. If not passed, a default uniqueness
    strategy is used which may have been assembled by the source of this [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts the underlying behavior of the result when iterating over the result
    object, or otherwise making use of methods such as [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone
    "sqlalchemy.engine.Result.fetchone") that return one row at a time. Data from
    the underlying cursor or other data source will be buffered up to this many rows
    in memory, and the buffered collection will then be yielded out one row at a time
    or as many rows are requested. Each time the buffer clears, it will be refreshed
    to this many rows or as many rows remain if fewer remain.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per "sqlalchemy.engine.Result.yield_per")
    method is generally used in conjunction with the [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    allow the database dialect in use to make use of a server side cursor, if the
    DBAPI supports a specific “server side cursor” mode separate from its default
    mode of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Consider using the [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option, which will
    simultaneously set [`Connection.execution_options.stream_results`](#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") to ensure the use of server
    side cursors, as well as automatically invoke the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method to establish a fixed row buffer size
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Connection.execution_options.yield_per`](#sqlalchemy.engine.Connection.execution_options.params.yield_per
    "sqlalchemy.engine.Connection.execution_options") execution option is available
    for ORM operations, with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")-oriented use described at [Fetching Large Result Sets
    with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per). The Core-only
    version which works with [`Connection`](#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is new as of SQLAlchemy 1.4.40.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num** – number of rows to fetch each time the buffer is refilled. If set
    to a value below 1, fetches all rows for the next buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns scalar values rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    object is acquired by calling the [`Result.scalars()`](#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") method.
  prefs: []
  type: TYPE_NORMAL
- en: A special limitation of [`ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    is that it has no `fetchone()` method; since the semantics of `fetchone()` are
    that the `None` value indicates no more results, this is not compatible with [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") since there is no way to distinguish between
    `None` as a row value versus `None` as an indicator. Use `next(result)` to receive
    values individually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.ScalarResult.all), [close()](#sqlalchemy.engine.ScalarResult.close),
    [closed](#sqlalchemy.engine.ScalarResult.closed), [fetchall()](#sqlalchemy.engine.ScalarResult.fetchall),
    [fetchmany()](#sqlalchemy.engine.ScalarResult.fetchmany), [first()](#sqlalchemy.engine.ScalarResult.first),
    [one()](#sqlalchemy.engine.ScalarResult.one), [one_or_none()](#sqlalchemy.engine.ScalarResult.one_or_none),
    [partitions()](#sqlalchemy.engine.ScalarResult.partitions), [unique()](#sqlalchemy.engine.ScalarResult.unique),
    [yield_per()](#sqlalchemy.engine.ScalarResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.ScalarResult`](#sqlalchemy.engine.ScalarResult "sqlalchemy.engine.ScalarResult")
    ([`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Return all scalar values in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.close()`](#sqlalchemy.engine.FilterResult.close
    "sqlalchemy.engine.FilterResult.close") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.closed`](#sqlalchemy.engine.FilterResult.closed
    "sqlalchemy.engine.FilterResult.closed") *attribute of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`ScalarResult.all()`](#sqlalchemy.engine.ScalarResult.all
    "sqlalchemy.engine.ScalarResult.all") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many objects.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany "sqlalchemy.engine.Result.fetchmany")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first object or `None` if no object is present.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") except that scalar values, rather than
    [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of elements of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    except that scalar values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`ScalarResult`](#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  prefs: []
  type: TYPE_NORMAL
- en: See [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    for usage details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper for a [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    that returns dictionary values rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    object is acquired by calling the [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[all()](#sqlalchemy.engine.MappingResult.all), [close()](#sqlalchemy.engine.MappingResult.close),
    [closed](#sqlalchemy.engine.MappingResult.closed), [columns()](#sqlalchemy.engine.MappingResult.columns),
    [fetchall()](#sqlalchemy.engine.MappingResult.fetchall), [fetchmany()](#sqlalchemy.engine.MappingResult.fetchmany),
    [fetchone()](#sqlalchemy.engine.MappingResult.fetchone), [first()](#sqlalchemy.engine.MappingResult.first),
    [keys()](#sqlalchemy.engine.MappingResult.keys), [one()](#sqlalchemy.engine.MappingResult.one),
    [one_or_none()](#sqlalchemy.engine.MappingResult.one_or_none), [partitions()](#sqlalchemy.engine.MappingResult.partitions),
    [unique()](#sqlalchemy.engine.MappingResult.unique), [yield_per()](#sqlalchemy.engine.MappingResult.yield_per)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.MappingResult`](#sqlalchemy.engine.MappingResult "sqlalchemy.engine.MappingResult")
    (`sqlalchemy.engine._WithKeys`, [`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Return all scalar values in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.all()`](#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.close()`](#sqlalchemy.engine.FilterResult.close
    "sqlalchemy.engine.FilterResult.close") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Close this [`FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.closed`](#sqlalchemy.engine.FilterResult.closed
    "sqlalchemy.engine.FilterResult.closed") *attribute of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Return `True` if the underlying [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    reports closed
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.43.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: Establish the columns that should be returned in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the [`MappingResult.all()`](#sqlalchemy.engine.MappingResult.all
    "sqlalchemy.engine.MappingResult.all") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: Fetch many objects.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchmany()`](#sqlalchemy.engine.Result.fetchmany "sqlalchemy.engine.Result.fetchmany")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Fetch one object.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.fetchone()`](#sqlalchemy.engine.Result.fetchone "sqlalchemy.engine.Result.fetchone")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the first object or `None` if no object is present.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.first()`](#sqlalchemy.engine.Result.first "sqlalchemy.engine.Result.first")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.engine._WithKeys.keys` *method of* `sqlalchemy.engine._WithKeys`'
  prefs: []
  type: TYPE_NORMAL
- en: Return an iterable view which yields the string keys that would be represented
    by each [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: The view also can be tested for key containment using the Python `in` operator,
    which will test both for the string keys represented in the view, as well as for
    alternate keys such as column objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: a key view object is returned rather than a plain list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: Return exactly one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one()`](#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: Return at most one object or raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.one_or_none()`](#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") except that [`RowMapping`](#sqlalchemy.engine.RowMapping
    "sqlalchemy.engine.RowMapping") values, rather than [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects, are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through sub-lists of elements of the size given.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to [`Result.partitions()`](#sqlalchemy.engine.Result.partitions "sqlalchemy.engine.Result.partitions")
    except that [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    values, rather than [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") objects,
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: Apply unique filtering to the objects returned by this [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult").
  prefs: []
  type: TYPE_NORMAL
- en: See [`Result.unique()`](#sqlalchemy.engine.Result.unique "sqlalchemy.engine.Result.unique")
    for usage details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") *method of* [`FilterResult`](#sqlalchemy.engine.FilterResult
    "sqlalchemy.engine.FilterResult")'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the row-fetching strategy to fetch `num` rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per "sqlalchemy.engine.FilterResult.yield_per")
    method is a pass through to the [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per") method. See that method’s documentation
    for usage notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: - added [`FilterResult.yield_per()`](#sqlalchemy.engine.FilterResult.yield_per
    "sqlalchemy.engine.FilterResult.yield_per") so that the method is available on
    all result set implementations'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](#engine-stream-results)
    - describes Core behavior for [`Result.yield_per()`](#sqlalchemy.engine.Result.yield_per
    "sqlalchemy.engine.Result.yield_per")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching Large Result Sets with Yield Per](../orm/queryguide/api.html#orm-queryguide-yield-per)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: Represent a single result row.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object represents
    a row of a database result. It is typically associated in the 1.x series of SQLAlchemy
    with the [`CursorResult`](#sqlalchemy.engine.CursorResult "sqlalchemy.engine.CursorResult")
    object, however is also used by the ORM for tuple-like results as of SQLAlchemy
    1.4.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") object seeks to
    act as much like a Python named tuple as possible. For mapping (i.e. dictionary)
    behavior on a row, such as testing for containment of keys, refer to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using SELECT Statements](../tutorial/data_select.html#tutorial-selecting-data)
    - includes examples of selecting rows from SELECT statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: Renamed `RowProxy` to [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is no longer a “proxy” object in that it contains the final form of data within
    it, and now acts mostly like a named tuple. Mapping-like functionality is moved
    to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")
    attribute. See [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](../changelog/migration_14.html#change-4710-core)
    for background on this change.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_asdict()](#sqlalchemy.engine.Row._asdict), [_fields](#sqlalchemy.engine.Row._fields),
    [_mapping](#sqlalchemy.engine.Row._mapping), [_t](#sqlalchemy.engine.Row._t),
    [_tuple()](#sqlalchemy.engine.Row._tuple), [count](#sqlalchemy.engine.Row.count),
    [index](#sqlalchemy.engine.Row.index), [t](#sqlalchemy.engine.Row.t), [tuple()](#sqlalchemy.engine.Row.tuple)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    (`sqlalchemy.engine._py_row.BaseRow`, `collections.abc.Sequence`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Return a new dict which maps field names to their corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: This method is analogous to the Python named tuple `._asdict()` method, and
    works by applying the `dict()` constructor to the [`Row._mapping`](#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: Return a tuple of string keys as represented by this [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: The keys can represent the labels of the columns returned by a core statement
    or the names of the orm classes returned by an orm execution.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is analogous to the Python named tuple `._fields` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    for this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: This object provides a consistent Python mapping (i.e. dictionary) interface
    for the data contained within the row. The [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    by itself behaves like a named tuple.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._fields`](#sqlalchemy.engine.Row._fields "sqlalchemy.engine.Row._fields")'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.19: - The [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t")
    attribute supersedes the previous [`Row.t`](#sqlalchemy.engine.Row.t "sqlalchemy.engine.Row.t")
    attribute, which is now underscored to avoid name conflicts with column names
    in the same way as other named-tuple methods on [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.t`](#sqlalchemy.engine.Result.t "sqlalchemy.engine.Result.t")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: Return a ‘tuple’ form of this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, this method returns “self”; the [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object is already a named tuple. However, at the typing level, if this [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") is typed, the “tuple” return type will be a [**PEP 484**](https://peps.python.org/pep-0484/)
    `Tuple` datatype that contains typing information about individual elements, supporting
    typed unpacking and attribute access.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.19: - The [`Row._tuple()`](#sqlalchemy.engine.Row._tuple
    "sqlalchemy.engine.Row._tuple") method supersedes the previous [`Row.tuple()`](#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") method, which is now underscored to avoid name
    conflicts with column names in the same way as other named-tuple methods on [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t") - shorthand
    attribute notation'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Result.tuples()`](#sqlalchemy.engine.Result.tuples "sqlalchemy.engine.Result.tuples")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0.19: The [`Row.t`](#sqlalchemy.engine.Row.t "sqlalchemy.engine.Row.t")
    attribute is deprecated in favor of [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t");
    all [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") methods and library-level
    attributes are intended to be underscored to avoid name conflicts. Please use
    [`Row._t`](#sqlalchemy.engine.Row._t "sqlalchemy.engine.Row._t").'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: Return a ‘tuple’ form of this [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0.19: The [`Row.tuple()`](#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") method is deprecated in favor of [`Row._tuple()`](#sqlalchemy.engine.Row._tuple
    "sqlalchemy.engine.Row._tuple"); all [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    methods and library-level attributes are intended to be underscored to avoid name
    conflicts. Please use [`Row._tuple()`](#sqlalchemy.engine.Row._tuple "sqlalchemy.engine.Row._tuple").'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: A `Mapping` that maps column names and objects to [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") values.
  prefs: []
  type: TYPE_NORMAL
- en: The [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    is available from a [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") via
    the [`Row._mapping`](#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")
    attribute, as well as from the iterable interface provided by the [`MappingResult`](#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult") object returned by the [`Result.mappings()`](#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    supplies Python mapping (i.e. dictionary) access to the contents of the row. This
    includes support for testing of containment of specific keys (string column names
    or objects), as well as iteration of keys, values, and items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: The [`RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    object replaces the mapping-like access previously provided by a database result
    row, which now seeks to behave mostly like a named tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[items()](#sqlalchemy.engine.RowMapping.items), [keys()](#sqlalchemy.engine.RowMapping.keys),
    [values()](#sqlalchemy.engine.RowMapping.values)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.RowMapping`](#sqlalchemy.engine.RowMapping "sqlalchemy.engine.RowMapping")
    (`sqlalchemy.engine._py_row.BaseRow`, `collections.abc.Mapping`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of key/value tuples for the elements in the underlying [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of ‘keys’ for string column names represented by the underlying
    [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: Return a view of values for the values represented in the underlying [`Row`](#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: A [`Result`](#sqlalchemy.engine.Result "sqlalchemy.engine.Result") that’s typed
    as returning plain Python tuples instead of rows.
  prefs: []
  type: TYPE_NORMAL
- en: Since [`Row`](#sqlalchemy.engine.Row "sqlalchemy.engine.Row") acts like a tuple
    in every way already, this class is a typing only class, regular [`Result`](#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is still used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.TupleResult`](#sqlalchemy.engine.TupleResult "sqlalchemy.engine.TupleResult")
    ([`sqlalchemy.engine.FilterResult`](#sqlalchemy.engine.FilterResult "sqlalchemy.engine.FilterResult"),
    `sqlalchemy.util.langhelpers.TypingOnly`)
  prefs: []
  type: TYPE_NORMAL
