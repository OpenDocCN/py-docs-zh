["```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        select(User)\n        .where(User.name == \"sandy\")\n        .join(User.addresses)\n        .where(Address.email_address.like(\"%gmail%\"))\n    )\n\n    result = sess.execute(stmt)\n\n    for user in result.scalars():\n        print(user)\n```", "```py\nsession.query(User).filter(User.name == \"sandy\").update(\n    {\"password\": \"foobar\"}, synchronize_session=\"fetch\"\n)\n```", "```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        update(User)\n        .where(User.name == \"sandy\")\n        .values(password=\"foobar\")\n        .execution_options(synchronize_session=\"fetch\")\n    )\n\n    sess.execute(stmt)\n```", "```py\n>>> engine = create_engine(\"...\", future=True)\n>>> conn = engine.connect()\n>>> row = conn.execute.first()\n>>> \"name\" in row\nTrue\n```", "```py\nfor dict_row in session.execute(text(\"select id from table\")).mappings():\n    assert \"id\" in dict_row\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    result = session.query(Customer).filter(Customer.id == id_).one()\n```", "```py\ntest_orm_query : (10000 iterations); total time 3.440652 sec\n```", "```py\ntest_orm_query : (10000 iterations); total time 2.367934 sec\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    stmt = lambda_stmt(lambda: future_select(Customer))\n    stmt += lambda s: s.where(Customer.id == id_)\n    session.execute(stmt).scalar_one()\n```", "```py\ntest_orm_query_newstyle_w_lambdas : (10000 iterations); total time 1.247092 sec\n```", "```py\n@util.dependency_for(\"sqlalchemy.sql.dml\")\ndef insert(self, dml, *args, **kw): ...\n```", "```py\nstmt1 = select(user.c.id, user.c.name)\nstmt2 = select(addresses, stmt1).select_from(addresses.join(stmt1))\n```", "```py\nsqlalchemy.exc.ArgumentError: Column expression or FROM clause expected,\ngot <...Select object ...>. To create a FROM clause from a <class\n'sqlalchemy.sql.selectable.Select'> object, use the .subquery() method.\n```", "```py\nsq1 = select(user.c.id, user.c.name).subquery()\nstmt2 = select(addresses, sq1).select_from(addresses.join(sq1))\n```", "```py\n    #  MySQL  /  MariaDB:\n\n    MariaDB  [(none)]>  select  *  from  (select  1);\n    ERROR  1248  (42000):  Every  derived  table  must  have  its  own  alias\n\n    #  PostgreSQL:\n\n    test=>  select  *  from  (select  1);\n    ERROR:  subquery  in  FROM  must  have  an  alias\n    LINE  1:  select  *  from  (select  1);\n      ^\n    HINT:  For  example,  FROM  (SELECT  ...)  [AS]  foo.\n    ```", "```py\n    sqlite>  CREATE  TABLE  a(id  integer);\n    sqlite>  CREATE  TABLE  b(id  integer);\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=id;\n    Error:  ambiguous  column  name:  id\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=b.id;\n    Error:  no  such  column:  b.id\n\n    #  use  a  name\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  AS  anon_1  ON  a.id=anon_1.id;\n    ```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.c.name == \"foo\")\n```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.selected_columns.name == \"foo\")\n```", "```py\nstmt = select(user_table).join(\n    addresses_table, user_table.c.id == addresses_table.c.user_id\n)\n```", "```py\nSELECT  user.id,  user.name  FROM  user  JOIN  address  ON  user.id=address.user_id\n```", "```py\nstmt = select(user_table).join(addresses_table)\n```", "```py\nstmt = select(User).join(User.addresses)\n```", "```py\nstmt = select(Address.email_address, User.name).join_from(User, Address)\n```", "```py\nSELECT  address.email_address,  user.name  FROM  user  JOIN  address  ON  user.id  ==  address.user_id\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\"postgresql+psycopg2://user:pass@host/dbname\")\n```", "```py\n>>> from sqlalchemy.engine import URL\n>>> url = URL.create(\"postgresql\", \"user\", \"pass\", host=\"host\", database=\"dbname\")\n>>> str(url)\n'postgresql://user:pass@host/dbname'\n```", "```py\n>>> mysql_url = url.set(drivername=\"mysql+pymysql\")\n>>> str(mysql_url)\n'mysql+pymysql://user:pass@host/dbname'\n```", "```py\n>>> url.update_query_dict({\"sslcert\": \"/path/to/crt\"})\npostgresql://user:***@host/dbname?sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\ndef set_url_drivername(some_url, some_drivername):\n    # check for 1.4\n    if hasattr(some_url, \"set\"):\n        return some_url.set(drivername=some_drivername)\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.drivername = some_drivername\n        return some_url\n\ndef set_ssl_cert(some_url, ssl_cert):\n    # check for 1.4\n    if hasattr(some_url, \"update_query_dict\"):\n        return some_url.update_query_dict({\"sslcert\": ssl_cert})\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.query[\"sslcert\"] = ssl_cert\n        return some_url\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\n...     \"postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&sslcert=%2Fpath%2Fto%2Fcrt\"\n... )\n>>> url.query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': '/path/to/crt'})\n```", "```py\n>>> url.normalized_query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': ('/path/to/crt',)})\n```", "```py\n>>> url.update_query_dict({\"alt_host\": \"host3\"}, append=True)\npostgresql://user:***@host/dbname?alt_host=host1&alt_host=host2&alt_host=host3&sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\nfrom sqlalchemy.engine import CreateEnginePlugin\n\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # check for 1.4 style\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            self.my_argument_one = url.query[\"my_argument_one\"]\n            self.my_argument_two = url.query[\"my_argument_two\"]\n        else:\n            # legacy\n            self.my_argument_one = url.query.pop(\"my_argument_one\")\n            self.my_argument_two = url.query.pop(\"my_argument_two\")\n\n        self.my_argument_three = kwargs.pop(\"my_argument_three\", None)\n\n    def update_url(self, url):\n        # this method runs in 1.4 only and should be used to consume\n        # plugin-specific arguments\n        return url.difference_update_query([\"my_argument_one\", \"my_argument_two\"])\n```", "```py\n# new way, supports 2.0\nstmt = select(table.c.col1, table.c.col2, ...)\n```", "```py\n# old way, still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...])\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], whereclause=table.c.col1 == 5)\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], table.c.col1 == 5)\n```", "```py\nstmt = select(users_table).where(\n    case(\n        (users_table.c.name == \"wendy\", \"W\"),\n        (users_table.c.name == \"jack\", \"J\"),\n        else_=\"E\",\n    )\n)\n```", "```py\nstmt = select(A.id, A.data).where(A.id.in_([1, 2, 3]))\n```", "```py\n>>> print(stmt)\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  ([POSTCOMPILE_id_1]) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"literal_binds\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (1,  2,  3) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"render_postcompile\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (:id_1_1,  :id_1_2,  :id_1_3) \n```", "```py\nINFO  sqlalchemy.engine.base.Engine  SELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (?,  ?,  ?)\nINFO  sqlalchemy.engine.base.Engine  (1,  2,  3)\n```", "```py\naddress_alias = aliased(Address)\n\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n)\n```", "```py\nSELECT\n  users.id  AS  users_id,  users.name  AS  users_name,\n  users.fullname  AS  users_fullname,\n  users.nickname  AS  users_nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1\n```", "```py\n>>> q.all()\nSAWarning: SELECT statement has a cartesian product between FROM\nelement(s) \"addresses_1\", \"users\" and FROM element \"addresses\".\nApply join condition(s) between each element to resolve.\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id == address_alias.id)\n)  # resolve cartesian products,\n# will no longer warn\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id > address_alias.id)\n)  # will generate a lot of rows,\n# but no warning\n```", "```py\nfrom sqlalchemy import true\n\n# intentional cartesian product\nq = session.query(User).join(Address, true())  # intentional cartesian product\n```", "```py\n>>> from sqlalchemy.sql import FROM_LINTING\n>>> print(q.statement.compile(linting=FROM_LINTING))\nSAWarning: SELECT statement has a cartesian product between FROM element(s) \"addresses\" and FROM element \"users\".  Apply join condition(s) between each element to resolve.\nSELECT  users.id,  users.name,  users.fullname,  users.nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1 \n```", "```py\nwith engine.connect() as conn:\n    row = conn.execute(table.select().where(table.c.id == 5)).one()\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(\n        table.select().order_by(table.c.id),\n        execution_options={\"stream_results\": True},\n    )\n    for chunk in result.partitions(500):\n        # process up to 500 records\n        ...\n```", "```py\nwith engine.connect() as conn:\n    # requests x, y, z\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    # iterate rows as y, x\n    for y, x in result.columns(\"y\", \"x\"):\n        print(\"Y: %s X: %s\" % (y, x))\n```", "```py\nresult = session.execute(select(User).order_by(User.id))\nfor user_obj in result.scalars():\n    ...\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    for map_ in result.mappings():\n        print(\"Y: %(y)s X: %(x)s\" % map_)\n```", "```py\nrow = (id: 5,  name: 'some name')\n```", "```py\n\"id\" in row  # True for a mapping, False for a named tuple\n\"some name\" in row  # False for a mapping, True for a named tuple\n```", "```py\n\"id\" in row._mapping\n```", "```py\n# using sqlalchemy.future package\nfor row in result.mappings():\n    row[\"id\"]\n```", "```py\nrow_proxy = (1, \"2019-12-31 19:56:58.272106\")\n```", "```py\nrow = (1, datetime.datetime(2019, 12, 31, 19, 56, 58, 272106))\n```", "```py\n>>> from sqlalchemy import column, select\n>>> c1, c2, c3, c4 = column(\"c1\"), column(\"c2\"), column(\"c3\"), column(\"c4\")\n>>> stmt = select(c1, c2, c3.label(\"c2\"), c2, c4)\n>>> print(stmt)\nSELECT  c1,  c2,  c3  AS  c2,  c2,  c4 \n```", "```py\n>>> list(stmt.selected_columns)\n[\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcca20; c1>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540897048; c4>\n]\n\n>>> print(stmt.subquery().select())\nSELECT  anon_1.c1,  anon_1.c2,  anon_1.c2,  anon_1.c2,  anon_1.c4\nFROM  (SELECT  c1,  c2,  c3  AS  c2,  c2,  c4)  AS  anon_1 \n```", "```py\n>>> stmt.selected_columns[2]\n<sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>\n```", "```py\n>>> from sqlalchemy import table\n>>> user = table(\"user\", column(\"id\"), column(\"name\"))\n>>> stmt = select(user.c.id, user.c.name, user.c.id).apply_labels()\n>>> print(stmt)\nSELECT \"user\".id AS user_id, \"user\".name AS user_name, \"user\".id AS id_1\nFROM \"user\"\n```", "```py\n>>> s1 = select(user, user.c.id)\n>>> s2 = select(c1, c2, c3)\n>>> from sqlalchemy import union\n>>> u = union(s1, s2)\n>>> print(u)\nSELECT  \"user\".id,  \"user\".name,  \"user\".id\nFROM  \"user\"  UNION  SELECT  c1,  c2,  c3 \n```", "```py\ntest=> SELECT CAST(data AS VARCHAR) FROM foo;\n\ndata\n------\n 5\n(1 row)\n```", "```py\nMariaDB [test]> SELECT CAST(data AS CHAR) FROM foo;\n+--------------------+\n| CAST(data AS CHAR) |\n+--------------------+\n| 5                  |\n+--------------------+\n1 row in set (0.003 sec)\n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  anon_1  #  old  behavior\nFROM  foo \n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  data\nFROM  foo \n```", "```py\n>>> print(select(cast(\"hi there,\" + foo.c.data, String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  anon_1\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data).label(\"hello_data\"), String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data), String).label(\"hello_data\")))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\nSELECT  TOP  5  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  :param_1\n)  anon_1  WHERE  ora_rn  >  :param_2\n```", "```py\nSELECT  TOP  [POSTCOMPILE_param_1]  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS([POSTCOMPILE__ora_frow_1]) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  [POSTCOMPILE_param_1]\n)  anon_1  WHERE  ora_rn  >  [POSTCOMPILE_param_2]\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id  AS  id,  mytable.data  AS  data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  8\n)  anon_1  WHERE  ora_rn  >  3\n```", "```py\nclass Spam(Base):\n    __tablename__ = \"spam\"\n    id = Column(Integer, primary_key=True)\n    boolean = Column(Boolean(create_constraint=True))\n    enum = Column(Enum(\"a\", \"b\", \"c\", create_constraint=True))\n```", "```py\nbook = session.query(Book).options(defer(Book.summary, raiseload=True)).first()\n\n# would raise an exception\nbook.summary\n```", "```py\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    book_id = Column(Integer, primary_key=True)\n    title = Column(String(200), nullable=False)\n    summary = deferred(Column(String(2000)), raiseload=True)\n    excerpt = deferred(Column(Text), raiseload=True)\n\nbook_w_excerpt = session.query(Book).options(undefer(Book.excerpt)).first()\n```", "```py\nsession.query(Order).options(joinedload(Order.items), raiseload(\"*\"))\n```", "```py\n# 1.3\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 14.051527 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 15.002470 sec\ntest_flush_pk_given : (100000 iterations); total time 7.863680 sec\ntest_bulk_save : (100000 iterations); total time 6.780378 sec\ntest_bulk_insert_mappings :  (100000 iterations); total time 5.363070 sec\ntest_core_insert : (100000 iterations); total time 5.362647 sec\n\n# 1.4 with enhancement\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 3.820807 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 3.176378 sec\ntest_flush_pk_given : (100000 iterations); total time 4.037789 sec\ntest_bulk_save : (100000 iterations); total time 2.604446 sec\ntest_bulk_insert_mappings : (100000 iterations); total time 1.204897 sec\ntest_core_insert : (100000 iterations); total time 0.958976 sec\n```", "```py\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine INSERT INTO a (data) VALUES (%(data)s) RETURNING a.id\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine [generated in 0.00698s] ({'data': 'data 1'}, {'data': 'data 2'}, {'data': 'data 3'}, {'data': 'data 4'}, {'data': 'data 5'}, {'data': 'data 6'}, {'data': 'data 7'}, {'data': 'data 8'}  ... displaying 10 of 4999 total bound parameter sets ...  {'data': 'data 4998'}, {'data': 'data 4999'})\n2020-06-27 19:08:18,254 INFO sqlalchemy.engine.Engine COMMIT\n```", "```py\n2020-06-27 19:08:18.169 EDT [26960] LOG:  statement: INSERT INTO a (data)\nVALUES ('data 1'),('data 2'),('data 3'),('data 4'),('data 5'),('data 6'),('data\n7'),('data 8'),('data 9'),('data 10'),('data 11'),('data 12'),\n... ('data 999'),('data 1000') RETURNING a.id\n\n2020-06-27 19:08:18.175 EDT\n[26960] LOG:  statement: INSERT INTO a (data) VALUES ('data 1001'),('data\n1002'),('data 1003'),('data 1004'),('data 1005 '),('data 1006'),('data\n1007'),('data 1008'),('data 1009'),('data 1010'),('data 1011'), ...\n```", "```py\nsess.query(User).filter(User.age > 29).update(\n    {\"age\": User.age - 10}, synchronize_session=\"fetch\"\n)\n```", "```py\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s RETURNING users.id\n[generated in 0.00060s] {'age_int_1': 10, 'age_int_2': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\n```", "```py\nSELECT users.id FROM users WHERE users.age_int > %(age_int_1)s\n[generated in 0.00043s] {'age_int_1': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s\n[generated in 0.00102s] {'age_int_1': 10, 'age_int_2': 29}\n```", "```py\nrow = s.query(User, Address).join(User.addresses).first()\n\nrow._mapping[User]  # same as row[0]\nrow._mapping[Address]  # same as row[1]\nrow._mapping[\"User\"]  # same as row[0]\nrow._mapping[\"Address\"]  # same as row[1]\n\nu1 = aliased(User)\nrow = s.query(u1).only_return_tuples(True).first()\nrow._mapping[u1]  # same as row[0]\n\nrow = s.query(User.id, Address.email_address).join(User.addresses).first()\n\nrow._mapping[User.id]  # same as row[0]\nrow._mapping[\"id\"]  # same as row[0]\nrow._mapping[users.c.id]  # same as row[0]\n```", "```py\nclass User(Base):\n    # ...\n\n    addresses = relationship(Address, backref=backref(\"user\", viewonly=True))\n\nclass Address(Base): ...\n\nu1 = session.query(User).filter_by(name=\"x\").first()\n\na1 = Address()\na1.user = u1\n```", "```py\nu1 = User()\nsession.add(u1)\n\na1 = Address()\na1.user = u1  # <--- adds \"a1\" to the Session\n```", "```py\nSession = sessionmaker(engine, future=True)\n\nwith Session() as session:\n    u1 = User()\n    session.add(u1)\n\n    a1 = Address()\n    a1.user = u1  # <--- will not add \"a1\" to the Session\n```", "```py\n>>> a1 = session.query(A).options(joinedload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n```", "```py\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nWHERE  a.id  =  ? \n```", "```py\n>>> a1 = session.query(A).options(selectinload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data\nFROM  a\nWHERE  a.id  =  ?\n(1,)\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(1,) \n```", "```py\nq1 = session.query(User).options(with_expression(User.expr, literal(\"u1\")))\nq2 = session.query(User).options(with_expression(User.expr, literal(\"u2\")))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id,\nanon_1.user_account_name  AS  anon_1_user_account_name\nFROM  (\n  SELECT  ?  AS  anon_2,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  ?  AS  anon_3,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n('u1',  'u2')\n```", "```py\nSELECT  ?  AS  anon_1,  anon_2.user_account_id  AS  anon_2_user_account_id,\nanon_2.user_account_name  AS  anon_2_user_account_name\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_2\n('u1',)\n```", "```py\nq1 = session.query(User).options(defer(User.name))\nq2 = session.query(User).options(defer(User.name))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n  UNION  ALL\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n)  AS  anon_1\n```", "```py\nSELECT  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n```", "```py\ns1 = select(User).options(with_expression(User.expr, literal(\"u1\")))\ns2 = select(User).options(with_expression(User.expr, literal(\"u2\")))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(select(User).from_statement(stmt)).all()\n```", "```py\nSELECT  user_account.id,  user_account.name\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name\nFROM  user_account\n```", "```py\ns1 = select(User, literal(\"u1\").label(\"some_literal\"))\ns2 = select(User, literal(\"u2\").label(\"some_literal\"))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(\n    select(User)\n    .from_statement(stmt)\n    .options(with_expression(User.expr, stmt.selected_columns.some_literal))\n).all()\n```", "```py\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\n```", "```py\n>>> u1 = User()\n>>> u1.name\nNone\n>>> u1.addresses\n[]\n```", "```py\n>>> u1 = User()\n>>> u1.addresses.append(Address())  # no need to assign u1.addresses = []\n```", "```py\n>>> u1 = User()\n>>> u1.name = None  # explicit assignment\n\n>>> u2 = User()\n>>> u2.name  # implicit assignment just by accessing it\nNone\n```", "```py\n>>> u1 = User(id=1)  # create an empty User to merge with id=1 in the database\n>>> merged1 = session.merge(\n...     u1\n... )  # value of merged1.addresses is unchanged from that of the DB\n\n>>> u2 = User(id=2)  # create an empty User to merge with id=2 in the database\n>>> u2.addresses\n[]\n>>> merged2 = session.merge(u2)  # value of merged2.addresses has been emptied in the DB\n```", "```py\n>>> u1 = User()\n>>> l1 = u1.addresses  # new list is created, associated with the state\n>>> assert u1.addresses is l1  # you get the same list each time you access it\n>>> assert (\n...     \"addresses\" not in u1.__dict__\n... )  # but it won't go into __dict__ until it's mutated\n>>> from sqlalchemy import inspect\n>>> inspect(u1).attrs.addresses.history\nHistory(added=None, unchanged=None, deleted=None)\n```", "```py\n>>> l1.append(Address())\n>>> assert \"addresses\" in u1.__dict__\n>>> inspect(u1).attrs.addresses.history\nHistory(added=[<__main__.Address object at 0x7f49b725eda0>], unchanged=[], deleted=[])\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n# this will now fail, would pass before\n>>> assert {k: v for k, v in u1.__dict__.items() if not k.startswith(\"_\")} == {\n...     \"addresses\": []\n... }\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n>>> s.add(u1)\n>>> s.flush()\n>>> s.close()\n>>> u1.addresses  # <-- will fail, .addresses is not loaded and object is detached\n```", "```py\n>>> u1.addresses = []\n```", "```py\nclass Product(Base):\n    __tablename__ = \"product\"\n\n    id = Column(Integer, primary_key=True)\n\nsession = Session(engine)\n\n# add Product with primary key 1\nsession.add(Product(id=1))\nsession.flush()\n\n# add another Product with same primary key\nsession.add(Product(id=1))\ns.commit()  # <-- will raise FlushError\n```", "```py\nsqlalchemy/orm/persistence.py:408: SAWarning: New instance <Product at 0x7f1ff65e0ba8> with identity key (<class '__main__.Product'>, (1,), None) conflicts with persistent instance <Product at 0x7f1ff60a4550>\n```", "```py\nsqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: product.id\n```", "```py\n# add another Product with same primary key\ntry:\n    with session.begin_nested():\n        session.add(Product(id=1))\nexcept exc.IntegrityError:\n    print(\"row already exists\")\n```", "```py\nclass User(Base):\n    # ...\n\n    # this is now an error\n    addresses = relationship(\"Address\", viewonly=True, cascade=\"all, delete-orphan\")\n```", "```py\nsqlalchemy.exc.ArgumentError: Cascade settings\n\"delete, delete-orphan, merge, save-update\" apply to persistence\noperations and should not be combined with a viewonly=True relationship.\n```", "```py\ns = Session(e)\n\ns.add_all([Engineer(), Manager()])\n\ns.commit()\n\nprint(s.query(Manager).select_entity_from(s.query(Employee).subquery()).all())\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:04:13,524 INFO sqlalchemy.engine.base.Engine ()\n[<__main__.Engineer object at 0x7f7f5b9a9810>, <__main__.Manager object at 0x7f7f5b9a9750>]\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140205120401296 anon)s.type'\nrefers to mapped class Engineer->engineer, which is not a sub-mapper of\nthe requested mapped class Manager->manager\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\nWHERE anon_1.type IN (?)\n2020-01-29 18:08:32,975 INFO sqlalchemy.engine.base.Engine ('manager',)\n[<__main__.Manager object at 0x7ff1b0200d50>]\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:13:10,554 INFO sqlalchemy.engine.base.Engine ()\nTraceback (most recent call last):\n# ...\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140700085268432 anon)s.type'\nrefers to mapped class Engineer->employee, which is not a sub-mapper of\nthe requested mapped class Manager->employee\n```", "```py\nprint(\n    s.query(Manager)\n    .select_entity_from(\n        s.query(Employee).filter(Employee.discriminator == \"manager\").subquery()\n    )\n    .all()\n)\n```", "```py\nSELECT  anon_1.type  AS  anon_1_type,  anon_1.id  AS  anon_1_id\nFROM  (SELECT  employee.type  AS  type,  employee.id  AS  id\nFROM  employee\nWHERE  employee.type  =  ?)  AS  anon_1\n2020-01-29  18:14:49,770  INFO  sqlalchemy.engine.base.Engine  ('manager',)\n[<__main__.Manager  object  at  0x7f70e13fca90>]\n```", "```py\n$ python -m examples.performance bulk_inserts --test test_core_insert --num 100000 --dburl postgresql://scott:tiger@localhost/test\n\n# 1.3\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 5.229326 sec\n\n# 1.4\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 0.944007 sec\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\n        \"id\", Integer, Sequence(\"some_seq\", start=1, optional=True), primary_key=True\n    ),\n)\n```", "```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        select(User)\n        .where(User.name == \"sandy\")\n        .join(User.addresses)\n        .where(Address.email_address.like(\"%gmail%\"))\n    )\n\n    result = sess.execute(stmt)\n\n    for user in result.scalars():\n        print(user)\n```", "```py\nsession.query(User).filter(User.name == \"sandy\").update(\n    {\"password\": \"foobar\"}, synchronize_session=\"fetch\"\n)\n```", "```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        update(User)\n        .where(User.name == \"sandy\")\n        .values(password=\"foobar\")\n        .execution_options(synchronize_session=\"fetch\")\n    )\n\n    sess.execute(stmt)\n```", "```py\n>>> engine = create_engine(\"...\", future=True)\n>>> conn = engine.connect()\n>>> row = conn.execute.first()\n>>> \"name\" in row\nTrue\n```", "```py\nfor dict_row in session.execute(text(\"select id from table\")).mappings():\n    assert \"id\" in dict_row\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    result = session.query(Customer).filter(Customer.id == id_).one()\n```", "```py\ntest_orm_query : (10000 iterations); total time 3.440652 sec\n```", "```py\ntest_orm_query : (10000 iterations); total time 2.367934 sec\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    stmt = lambda_stmt(lambda: future_select(Customer))\n    stmt += lambda s: s.where(Customer.id == id_)\n    session.execute(stmt).scalar_one()\n```", "```py\ntest_orm_query_newstyle_w_lambdas : (10000 iterations); total time 1.247092 sec\n```", "```py\n@util.dependency_for(\"sqlalchemy.sql.dml\")\ndef insert(self, dml, *args, **kw): ...\n```", "```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        select(User)\n        .where(User.name == \"sandy\")\n        .join(User.addresses)\n        .where(Address.email_address.like(\"%gmail%\"))\n    )\n\n    result = sess.execute(stmt)\n\n    for user in result.scalars():\n        print(user)\n```", "```py\nsession.query(User).filter(User.name == \"sandy\").update(\n    {\"password\": \"foobar\"}, synchronize_session=\"fetch\"\n)\n```", "```py\nwith Session(engine, future=True) as sess:\n    stmt = (\n        update(User)\n        .where(User.name == \"sandy\")\n        .values(password=\"foobar\")\n        .execution_options(synchronize_session=\"fetch\")\n    )\n\n    sess.execute(stmt)\n```", "```py\n>>> engine = create_engine(\"...\", future=True)\n>>> conn = engine.connect()\n>>> row = conn.execute.first()\n>>> \"name\" in row\nTrue\n```", "```py\nfor dict_row in session.execute(text(\"select id from table\")).mappings():\n    assert \"id\" in dict_row\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    result = session.query(Customer).filter(Customer.id == id_).one()\n```", "```py\ntest_orm_query : (10000 iterations); total time 3.440652 sec\n```", "```py\ntest_orm_query : (10000 iterations); total time 2.367934 sec\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    stmt = lambda_stmt(lambda: future_select(Customer))\n    stmt += lambda s: s.where(Customer.id == id_)\n    session.execute(stmt).scalar_one()\n```", "```py\ntest_orm_query_newstyle_w_lambdas : (10000 iterations); total time 1.247092 sec\n```", "```py\n@util.dependency_for(\"sqlalchemy.sql.dml\")\ndef insert(self, dml, *args, **kw): ...\n```", "```py\nstmt1 = select(user.c.id, user.c.name)\nstmt2 = select(addresses, stmt1).select_from(addresses.join(stmt1))\n```", "```py\nsqlalchemy.exc.ArgumentError: Column expression or FROM clause expected,\ngot <...Select object ...>. To create a FROM clause from a <class\n'sqlalchemy.sql.selectable.Select'> object, use the .subquery() method.\n```", "```py\nsq1 = select(user.c.id, user.c.name).subquery()\nstmt2 = select(addresses, sq1).select_from(addresses.join(sq1))\n```", "```py\n    #  MySQL  /  MariaDB:\n\n    MariaDB  [(none)]>  select  *  from  (select  1);\n    ERROR  1248  (42000):  Every  derived  table  must  have  its  own  alias\n\n    #  PostgreSQL:\n\n    test=>  select  *  from  (select  1);\n    ERROR:  subquery  in  FROM  must  have  an  alias\n    LINE  1:  select  *  from  (select  1);\n      ^\n    HINT:  For  example,  FROM  (SELECT  ...)  [AS]  foo.\n    ```", "```py\n    sqlite>  CREATE  TABLE  a(id  integer);\n    sqlite>  CREATE  TABLE  b(id  integer);\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=id;\n    Error:  ambiguous  column  name:  id\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=b.id;\n    Error:  no  such  column:  b.id\n\n    #  use  a  name\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  AS  anon_1  ON  a.id=anon_1.id;\n    ```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.c.name == \"foo\")\n```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.selected_columns.name == \"foo\")\n```", "```py\nstmt = select(user_table).join(\n    addresses_table, user_table.c.id == addresses_table.c.user_id\n)\n```", "```py\nSELECT  user.id,  user.name  FROM  user  JOIN  address  ON  user.id=address.user_id\n```", "```py\nstmt = select(user_table).join(addresses_table)\n```", "```py\nstmt = select(User).join(User.addresses)\n```", "```py\nstmt = select(Address.email_address, User.name).join_from(User, Address)\n```", "```py\nSELECT  address.email_address,  user.name  FROM  user  JOIN  address  ON  user.id  ==  address.user_id\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\"postgresql+psycopg2://user:pass@host/dbname\")\n```", "```py\n>>> from sqlalchemy.engine import URL\n>>> url = URL.create(\"postgresql\", \"user\", \"pass\", host=\"host\", database=\"dbname\")\n>>> str(url)\n'postgresql://user:pass@host/dbname'\n```", "```py\n>>> mysql_url = url.set(drivername=\"mysql+pymysql\")\n>>> str(mysql_url)\n'mysql+pymysql://user:pass@host/dbname'\n```", "```py\n>>> url.update_query_dict({\"sslcert\": \"/path/to/crt\"})\npostgresql://user:***@host/dbname?sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\ndef set_url_drivername(some_url, some_drivername):\n    # check for 1.4\n    if hasattr(some_url, \"set\"):\n        return some_url.set(drivername=some_drivername)\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.drivername = some_drivername\n        return some_url\n\ndef set_ssl_cert(some_url, ssl_cert):\n    # check for 1.4\n    if hasattr(some_url, \"update_query_dict\"):\n        return some_url.update_query_dict({\"sslcert\": ssl_cert})\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.query[\"sslcert\"] = ssl_cert\n        return some_url\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\n...     \"postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&sslcert=%2Fpath%2Fto%2Fcrt\"\n... )\n>>> url.query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': '/path/to/crt'})\n```", "```py\n>>> url.normalized_query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': ('/path/to/crt',)})\n```", "```py\n>>> url.update_query_dict({\"alt_host\": \"host3\"}, append=True)\npostgresql://user:***@host/dbname?alt_host=host1&alt_host=host2&alt_host=host3&sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\nfrom sqlalchemy.engine import CreateEnginePlugin\n\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # check for 1.4 style\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            self.my_argument_one = url.query[\"my_argument_one\"]\n            self.my_argument_two = url.query[\"my_argument_two\"]\n        else:\n            # legacy\n            self.my_argument_one = url.query.pop(\"my_argument_one\")\n            self.my_argument_two = url.query.pop(\"my_argument_two\")\n\n        self.my_argument_three = kwargs.pop(\"my_argument_three\", None)\n\n    def update_url(self, url):\n        # this method runs in 1.4 only and should be used to consume\n        # plugin-specific arguments\n        return url.difference_update_query([\"my_argument_one\", \"my_argument_two\"])\n```", "```py\n# new way, supports 2.0\nstmt = select(table.c.col1, table.c.col2, ...)\n```", "```py\n# old way, still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...])\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], whereclause=table.c.col1 == 5)\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], table.c.col1 == 5)\n```", "```py\nstmt = select(users_table).where(\n    case(\n        (users_table.c.name == \"wendy\", \"W\"),\n        (users_table.c.name == \"jack\", \"J\"),\n        else_=\"E\",\n    )\n)\n```", "```py\nstmt = select(A.id, A.data).where(A.id.in_([1, 2, 3]))\n```", "```py\n>>> print(stmt)\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  ([POSTCOMPILE_id_1]) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"literal_binds\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (1,  2,  3) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"render_postcompile\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (:id_1_1,  :id_1_2,  :id_1_3) \n```", "```py\nINFO  sqlalchemy.engine.base.Engine  SELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (?,  ?,  ?)\nINFO  sqlalchemy.engine.base.Engine  (1,  2,  3)\n```", "```py\naddress_alias = aliased(Address)\n\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n)\n```", "```py\nSELECT\n  users.id  AS  users_id,  users.name  AS  users_name,\n  users.fullname  AS  users_fullname,\n  users.nickname  AS  users_nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1\n```", "```py\n>>> q.all()\nSAWarning: SELECT statement has a cartesian product between FROM\nelement(s) \"addresses_1\", \"users\" and FROM element \"addresses\".\nApply join condition(s) between each element to resolve.\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id == address_alias.id)\n)  # resolve cartesian products,\n# will no longer warn\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id > address_alias.id)\n)  # will generate a lot of rows,\n# but no warning\n```", "```py\nfrom sqlalchemy import true\n\n# intentional cartesian product\nq = session.query(User).join(Address, true())  # intentional cartesian product\n```", "```py\n>>> from sqlalchemy.sql import FROM_LINTING\n>>> print(q.statement.compile(linting=FROM_LINTING))\nSAWarning: SELECT statement has a cartesian product between FROM element(s) \"addresses\" and FROM element \"users\".  Apply join condition(s) between each element to resolve.\nSELECT  users.id,  users.name,  users.fullname,  users.nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1 \n```", "```py\nwith engine.connect() as conn:\n    row = conn.execute(table.select().where(table.c.id == 5)).one()\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(\n        table.select().order_by(table.c.id),\n        execution_options={\"stream_results\": True},\n    )\n    for chunk in result.partitions(500):\n        # process up to 500 records\n        ...\n```", "```py\nwith engine.connect() as conn:\n    # requests x, y, z\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    # iterate rows as y, x\n    for y, x in result.columns(\"y\", \"x\"):\n        print(\"Y: %s X: %s\" % (y, x))\n```", "```py\nresult = session.execute(select(User).order_by(User.id))\nfor user_obj in result.scalars():\n    ...\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    for map_ in result.mappings():\n        print(\"Y: %(y)s X: %(x)s\" % map_)\n```", "```py\nrow = (id: 5,  name: 'some name')\n```", "```py\n\"id\" in row  # True for a mapping, False for a named tuple\n\"some name\" in row  # False for a mapping, True for a named tuple\n```", "```py\n\"id\" in row._mapping\n```", "```py\n# using sqlalchemy.future package\nfor row in result.mappings():\n    row[\"id\"]\n```", "```py\nrow_proxy = (1, \"2019-12-31 19:56:58.272106\")\n```", "```py\nrow = (1, datetime.datetime(2019, 12, 31, 19, 56, 58, 272106))\n```", "```py\n>>> from sqlalchemy import column, select\n>>> c1, c2, c3, c4 = column(\"c1\"), column(\"c2\"), column(\"c3\"), column(\"c4\")\n>>> stmt = select(c1, c2, c3.label(\"c2\"), c2, c4)\n>>> print(stmt)\nSELECT  c1,  c2,  c3  AS  c2,  c2,  c4 \n```", "```py\n>>> list(stmt.selected_columns)\n[\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcca20; c1>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540897048; c4>\n]\n\n>>> print(stmt.subquery().select())\nSELECT  anon_1.c1,  anon_1.c2,  anon_1.c2,  anon_1.c2,  anon_1.c4\nFROM  (SELECT  c1,  c2,  c3  AS  c2,  c2,  c4)  AS  anon_1 \n```", "```py\n>>> stmt.selected_columns[2]\n<sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>\n```", "```py\n>>> from sqlalchemy import table\n>>> user = table(\"user\", column(\"id\"), column(\"name\"))\n>>> stmt = select(user.c.id, user.c.name, user.c.id).apply_labels()\n>>> print(stmt)\nSELECT \"user\".id AS user_id, \"user\".name AS user_name, \"user\".id AS id_1\nFROM \"user\"\n```", "```py\n>>> s1 = select(user, user.c.id)\n>>> s2 = select(c1, c2, c3)\n>>> from sqlalchemy import union\n>>> u = union(s1, s2)\n>>> print(u)\nSELECT  \"user\".id,  \"user\".name,  \"user\".id\nFROM  \"user\"  UNION  SELECT  c1,  c2,  c3 \n```", "```py\ntest=> SELECT CAST(data AS VARCHAR) FROM foo;\n\ndata\n------\n 5\n(1 row)\n```", "```py\nMariaDB [test]> SELECT CAST(data AS CHAR) FROM foo;\n+--------------------+\n| CAST(data AS CHAR) |\n+--------------------+\n| 5                  |\n+--------------------+\n1 row in set (0.003 sec)\n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  anon_1  #  old  behavior\nFROM  foo \n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  data\nFROM  foo \n```", "```py\n>>> print(select(cast(\"hi there,\" + foo.c.data, String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  anon_1\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data).label(\"hello_data\"), String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data), String).label(\"hello_data\")))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\nSELECT  TOP  5  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  :param_1\n)  anon_1  WHERE  ora_rn  >  :param_2\n```", "```py\nSELECT  TOP  [POSTCOMPILE_param_1]  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS([POSTCOMPILE__ora_frow_1]) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  [POSTCOMPILE_param_1]\n)  anon_1  WHERE  ora_rn  >  [POSTCOMPILE_param_2]\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id  AS  id,  mytable.data  AS  data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  8\n)  anon_1  WHERE  ora_rn  >  3\n```", "```py\nclass Spam(Base):\n    __tablename__ = \"spam\"\n    id = Column(Integer, primary_key=True)\n    boolean = Column(Boolean(create_constraint=True))\n    enum = Column(Enum(\"a\", \"b\", \"c\", create_constraint=True))\n```", "```py\nstmt1 = select(user.c.id, user.c.name)\nstmt2 = select(addresses, stmt1).select_from(addresses.join(stmt1))\n```", "```py\nsqlalchemy.exc.ArgumentError: Column expression or FROM clause expected,\ngot <...Select object ...>. To create a FROM clause from a <class\n'sqlalchemy.sql.selectable.Select'> object, use the .subquery() method.\n```", "```py\nsq1 = select(user.c.id, user.c.name).subquery()\nstmt2 = select(addresses, sq1).select_from(addresses.join(sq1))\n```", "```py\n    #  MySQL  /  MariaDB:\n\n    MariaDB  [(none)]>  select  *  from  (select  1);\n    ERROR  1248  (42000):  Every  derived  table  must  have  its  own  alias\n\n    #  PostgreSQL:\n\n    test=>  select  *  from  (select  1);\n    ERROR:  subquery  in  FROM  must  have  an  alias\n    LINE  1:  select  *  from  (select  1);\n      ^\n    HINT:  For  example,  FROM  (SELECT  ...)  [AS]  foo.\n    ```", "```py\n    sqlite>  CREATE  TABLE  a(id  integer);\n    sqlite>  CREATE  TABLE  b(id  integer);\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=id;\n    Error:  ambiguous  column  name:  id\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  ON  a.id=b.id;\n    Error:  no  such  column:  b.id\n\n    #  use  a  name\n    sqlite>  SELECT  *  FROM  a  JOIN  (SELECT  *  FROM  b)  AS  anon_1  ON  a.id=anon_1.id;\n    ```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.c.name == \"foo\")\n```", "```py\nstmt = select(users)\nstmt = stmt.where(stmt.selected_columns.name == \"foo\")\n```", "```py\nstmt = select(user_table).join(\n    addresses_table, user_table.c.id == addresses_table.c.user_id\n)\n```", "```py\nSELECT  user.id,  user.name  FROM  user  JOIN  address  ON  user.id=address.user_id\n```", "```py\nstmt = select(user_table).join(addresses_table)\n```", "```py\nstmt = select(User).join(User.addresses)\n```", "```py\nstmt = select(Address.email_address, User.name).join_from(User, Address)\n```", "```py\nSELECT  address.email_address,  user.name  FROM  user  JOIN  address  ON  user.id  ==  address.user_id\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\"postgresql+psycopg2://user:pass@host/dbname\")\n```", "```py\n>>> from sqlalchemy.engine import URL\n>>> url = URL.create(\"postgresql\", \"user\", \"pass\", host=\"host\", database=\"dbname\")\n>>> str(url)\n'postgresql://user:pass@host/dbname'\n```", "```py\n>>> mysql_url = url.set(drivername=\"mysql+pymysql\")\n>>> str(mysql_url)\n'mysql+pymysql://user:pass@host/dbname'\n```", "```py\n>>> url.update_query_dict({\"sslcert\": \"/path/to/crt\"})\npostgresql://user:***@host/dbname?sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\ndef set_url_drivername(some_url, some_drivername):\n    # check for 1.4\n    if hasattr(some_url, \"set\"):\n        return some_url.set(drivername=some_drivername)\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.drivername = some_drivername\n        return some_url\n\ndef set_ssl_cert(some_url, ssl_cert):\n    # check for 1.4\n    if hasattr(some_url, \"update_query_dict\"):\n        return some_url.update_query_dict({\"sslcert\": ssl_cert})\n    else:\n        # SQLAlchemy 1.3 or earlier, mutate in place\n        some_url.query[\"sslcert\"] = ssl_cert\n        return some_url\n```", "```py\n>>> from sqlalchemy.engine import make_url\n>>> url = make_url(\n...     \"postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&sslcert=%2Fpath%2Fto%2Fcrt\"\n... )\n>>> url.query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': '/path/to/crt'})\n```", "```py\n>>> url.normalized_query\nimmutabledict({'alt_host': ('host1', 'host2'), 'sslcert': ('/path/to/crt',)})\n```", "```py\n>>> url.update_query_dict({\"alt_host\": \"host3\"}, append=True)\npostgresql://user:***@host/dbname?alt_host=host1&alt_host=host2&alt_host=host3&sslcert=%2Fpath%2Fto%2Fcrt\n```", "```py\nfrom sqlalchemy.engine import CreateEnginePlugin\n\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # check for 1.4 style\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            self.my_argument_one = url.query[\"my_argument_one\"]\n            self.my_argument_two = url.query[\"my_argument_two\"]\n        else:\n            # legacy\n            self.my_argument_one = url.query.pop(\"my_argument_one\")\n            self.my_argument_two = url.query.pop(\"my_argument_two\")\n\n        self.my_argument_three = kwargs.pop(\"my_argument_three\", None)\n\n    def update_url(self, url):\n        # this method runs in 1.4 only and should be used to consume\n        # plugin-specific arguments\n        return url.difference_update_query([\"my_argument_one\", \"my_argument_two\"])\n```", "```py\nfrom sqlalchemy.engine import CreateEnginePlugin\n\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # check for 1.4 style\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            self.my_argument_one = url.query[\"my_argument_one\"]\n            self.my_argument_two = url.query[\"my_argument_two\"]\n        else:\n            # legacy\n            self.my_argument_one = url.query.pop(\"my_argument_one\")\n            self.my_argument_two = url.query.pop(\"my_argument_two\")\n\n        self.my_argument_three = kwargs.pop(\"my_argument_three\", None)\n\n    def update_url(self, url):\n        # this method runs in 1.4 only and should be used to consume\n        # plugin-specific arguments\n        return url.difference_update_query([\"my_argument_one\", \"my_argument_two\"])\n```", "```py\n# new way, supports 2.0\nstmt = select(table.c.col1, table.c.col2, ...)\n```", "```py\n# old way, still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...])\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], whereclause=table.c.col1 == 5)\n```", "```py\n# very much the old way, but still works in 1.4\nstmt = select([table.c.col1, table.c.col2, ...], table.c.col1 == 5)\n```", "```py\nstmt = select(users_table).where(\n    case(\n        (users_table.c.name == \"wendy\", \"W\"),\n        (users_table.c.name == \"jack\", \"J\"),\n        else_=\"E\",\n    )\n)\n```", "```py\nstmt = select(A.id, A.data).where(A.id.in_([1, 2, 3]))\n```", "```py\n>>> print(stmt)\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  ([POSTCOMPILE_id_1]) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"literal_binds\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (1,  2,  3) \n```", "```py\n>>> print(stmt.compile(compile_kwargs={\"render_postcompile\": True}))\nSELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (:id_1_1,  :id_1_2,  :id_1_3) \n```", "```py\nINFO  sqlalchemy.engine.base.Engine  SELECT  a.id,  a.data\nFROM  a\nWHERE  a.id  IN  (?,  ?,  ?)\nINFO  sqlalchemy.engine.base.Engine  (1,  2,  3)\n```", "```py\naddress_alias = aliased(Address)\n\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n)\n```", "```py\nSELECT\n  users.id  AS  users_id,  users.name  AS  users_name,\n  users.fullname  AS  users_fullname,\n  users.nickname  AS  users_nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1\n```", "```py\n>>> q.all()\nSAWarning: SELECT statement has a cartesian product between FROM\nelement(s) \"addresses_1\", \"users\" and FROM element \"addresses\".\nApply join condition(s) between each element to resolve.\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id == address_alias.id)\n)  # resolve cartesian products,\n# will no longer warn\n```", "```py\nq = (\n    session.query(User)\n    .join(address_alias, User.addresses)\n    .filter(Address.email_address == \"foo\")\n    .filter(Address.id > address_alias.id)\n)  # will generate a lot of rows,\n# but no warning\n```", "```py\nfrom sqlalchemy import true\n\n# intentional cartesian product\nq = session.query(User).join(Address, true())  # intentional cartesian product\n```", "```py\n>>> from sqlalchemy.sql import FROM_LINTING\n>>> print(q.statement.compile(linting=FROM_LINTING))\nSAWarning: SELECT statement has a cartesian product between FROM element(s) \"addresses\" and FROM element \"users\".  Apply join condition(s) between each element to resolve.\nSELECT  users.id,  users.name,  users.fullname,  users.nickname\nFROM  addresses,  users  JOIN  addresses  AS  addresses_1  ON  users.id  =  addresses_1.user_id\nWHERE  addresses.email_address  =  :email_address_1 \n```", "```py\nwith engine.connect() as conn:\n    row = conn.execute(table.select().where(table.c.id == 5)).one()\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(\n        table.select().order_by(table.c.id),\n        execution_options={\"stream_results\": True},\n    )\n    for chunk in result.partitions(500):\n        # process up to 500 records\n        ...\n```", "```py\nwith engine.connect() as conn:\n    # requests x, y, z\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    # iterate rows as y, x\n    for y, x in result.columns(\"y\", \"x\"):\n        print(\"Y: %s X: %s\" % (y, x))\n```", "```py\nresult = session.execute(select(User).order_by(User.id))\nfor user_obj in result.scalars():\n    ...\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(select(table.c.x, table.c.y, table.c.z))\n\n    for map_ in result.mappings():\n        print(\"Y: %(y)s X: %(x)s\" % map_)\n```", "```py\nrow = (id: 5,  name: 'some name')\n```", "```py\n\"id\" in row  # True for a mapping, False for a named tuple\n\"some name\" in row  # False for a mapping, True for a named tuple\n```", "```py\n\"id\" in row._mapping\n```", "```py\n# using sqlalchemy.future package\nfor row in result.mappings():\n    row[\"id\"]\n```", "```py\nrow_proxy = (1, \"2019-12-31 19:56:58.272106\")\n```", "```py\nrow = (1, datetime.datetime(2019, 12, 31, 19, 56, 58, 272106))\n```", "```py\nrow = (id: 5,  name: 'some name')\n```", "```py\n\"id\" in row  # True for a mapping, False for a named tuple\n\"some name\" in row  # False for a mapping, True for a named tuple\n```", "```py\n\"id\" in row._mapping\n```", "```py\n# using sqlalchemy.future package\nfor row in result.mappings():\n    row[\"id\"]\n```", "```py\nrow_proxy = (1, \"2019-12-31 19:56:58.272106\")\n```", "```py\nrow = (1, datetime.datetime(2019, 12, 31, 19, 56, 58, 272106))\n```", "```py\n>>> from sqlalchemy import column, select\n>>> c1, c2, c3, c4 = column(\"c1\"), column(\"c2\"), column(\"c3\"), column(\"c4\")\n>>> stmt = select(c1, c2, c3.label(\"c2\"), c2, c4)\n>>> print(stmt)\nSELECT  c1,  c2,  c3  AS  c2,  c2,  c4 \n```", "```py\n>>> list(stmt.selected_columns)\n[\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcca20; c1>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2>,\n <sqlalchemy.sql.elements.ColumnClause at 0x7fa540897048; c4>\n]\n\n>>> print(stmt.subquery().select())\nSELECT  anon_1.c1,  anon_1.c2,  anon_1.c2,  anon_1.c2,  anon_1.c4\nFROM  (SELECT  c1,  c2,  c3  AS  c2,  c2,  c4)  AS  anon_1 \n```", "```py\n>>> stmt.selected_columns[2]\n<sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8>\n```", "```py\n>>> from sqlalchemy import table\n>>> user = table(\"user\", column(\"id\"), column(\"name\"))\n>>> stmt = select(user.c.id, user.c.name, user.c.id).apply_labels()\n>>> print(stmt)\nSELECT \"user\".id AS user_id, \"user\".name AS user_name, \"user\".id AS id_1\nFROM \"user\"\n```", "```py\n>>> s1 = select(user, user.c.id)\n>>> s2 = select(c1, c2, c3)\n>>> from sqlalchemy import union\n>>> u = union(s1, s2)\n>>> print(u)\nSELECT  \"user\".id,  \"user\".name,  \"user\".id\nFROM  \"user\"  UNION  SELECT  c1,  c2,  c3 \n```", "```py\ntest=> SELECT CAST(data AS VARCHAR) FROM foo;\n\ndata\n------\n 5\n(1 row)\n```", "```py\nMariaDB [test]> SELECT CAST(data AS CHAR) FROM foo;\n+--------------------+\n| CAST(data AS CHAR) |\n+--------------------+\n| 5                  |\n+--------------------+\n1 row in set (0.003 sec)\n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  anon_1  #  old  behavior\nFROM  foo \n```", "```py\n>>> print(select(cast(foo.c.data, String)))\nSELECT  CAST(foo.data  AS  VARCHAR)  AS  data\nFROM  foo \n```", "```py\n>>> print(select(cast(\"hi there,\" + foo.c.data, String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  anon_1\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data).label(\"hello_data\"), String)))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\n>>> print(select(cast((\"hi there,\" + foo.c.data), String).label(\"hello_data\")))\nSELECT  CAST(:data_1  +  foo.data  AS  VARCHAR)  AS  hello_data\nFROM  foo \n```", "```py\nSELECT  TOP  5  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  :param_1\n)  anon_1  WHERE  ora_rn  >  :param_2\n```", "```py\nSELECT  TOP  [POSTCOMPILE_param_1]  mytable.id,  mytable.data  FROM  mytable\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS([POSTCOMPILE__ora_frow_1]) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id,  mytable.data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  [POSTCOMPILE_param_1]\n)  anon_1  WHERE  ora_rn  >  [POSTCOMPILE_param_2]\n```", "```py\nSELECT  anon_1.id,  anon_1.data  FROM  (\n  SELECT  /*+ FIRST_ROWS(5) */\n  anon_2.id  AS  id,\n  anon_2.data  AS  data,\n  ROWNUM  AS  ora_rn  FROM  (\n  SELECT  mytable.id  AS  id,  mytable.data  AS  data  FROM  mytable\n  )  anon_2\n  WHERE  ROWNUM  <=  8\n)  anon_1  WHERE  ora_rn  >  3\n```", "```py\nclass Spam(Base):\n    __tablename__ = \"spam\"\n    id = Column(Integer, primary_key=True)\n    boolean = Column(Boolean(create_constraint=True))\n    enum = Column(Enum(\"a\", \"b\", \"c\", create_constraint=True))\n```", "```py\nbook = session.query(Book).options(defer(Book.summary, raiseload=True)).first()\n\n# would raise an exception\nbook.summary\n```", "```py\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    book_id = Column(Integer, primary_key=True)\n    title = Column(String(200), nullable=False)\n    summary = deferred(Column(String(2000)), raiseload=True)\n    excerpt = deferred(Column(Text), raiseload=True)\n\nbook_w_excerpt = session.query(Book).options(undefer(Book.excerpt)).first()\n```", "```py\nsession.query(Order).options(joinedload(Order.items), raiseload(\"*\"))\n```", "```py\n# 1.3\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 14.051527 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 15.002470 sec\ntest_flush_pk_given : (100000 iterations); total time 7.863680 sec\ntest_bulk_save : (100000 iterations); total time 6.780378 sec\ntest_bulk_insert_mappings :  (100000 iterations); total time 5.363070 sec\ntest_core_insert : (100000 iterations); total time 5.362647 sec\n\n# 1.4 with enhancement\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 3.820807 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 3.176378 sec\ntest_flush_pk_given : (100000 iterations); total time 4.037789 sec\ntest_bulk_save : (100000 iterations); total time 2.604446 sec\ntest_bulk_insert_mappings : (100000 iterations); total time 1.204897 sec\ntest_core_insert : (100000 iterations); total time 0.958976 sec\n```", "```py\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine INSERT INTO a (data) VALUES (%(data)s) RETURNING a.id\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine [generated in 0.00698s] ({'data': 'data 1'}, {'data': 'data 2'}, {'data': 'data 3'}, {'data': 'data 4'}, {'data': 'data 5'}, {'data': 'data 6'}, {'data': 'data 7'}, {'data': 'data 8'}  ... displaying 10 of 4999 total bound parameter sets ...  {'data': 'data 4998'}, {'data': 'data 4999'})\n2020-06-27 19:08:18,254 INFO sqlalchemy.engine.Engine COMMIT\n```", "```py\n2020-06-27 19:08:18.169 EDT [26960] LOG:  statement: INSERT INTO a (data)\nVALUES ('data 1'),('data 2'),('data 3'),('data 4'),('data 5'),('data 6'),('data\n7'),('data 8'),('data 9'),('data 10'),('data 11'),('data 12'),\n... ('data 999'),('data 1000') RETURNING a.id\n\n2020-06-27 19:08:18.175 EDT\n[26960] LOG:  statement: INSERT INTO a (data) VALUES ('data 1001'),('data\n1002'),('data 1003'),('data 1004'),('data 1005 '),('data 1006'),('data\n1007'),('data 1008'),('data 1009'),('data 1010'),('data 1011'), ...\n```", "```py\nsess.query(User).filter(User.age > 29).update(\n    {\"age\": User.age - 10}, synchronize_session=\"fetch\"\n)\n```", "```py\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s RETURNING users.id\n[generated in 0.00060s] {'age_int_1': 10, 'age_int_2': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\n```", "```py\nSELECT users.id FROM users WHERE users.age_int > %(age_int_1)s\n[generated in 0.00043s] {'age_int_1': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s\n[generated in 0.00102s] {'age_int_1': 10, 'age_int_2': 29}\n```", "```py\nbook = session.query(Book).options(defer(Book.summary, raiseload=True)).first()\n\n# would raise an exception\nbook.summary\n```", "```py\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    book_id = Column(Integer, primary_key=True)\n    title = Column(String(200), nullable=False)\n    summary = deferred(Column(String(2000)), raiseload=True)\n    excerpt = deferred(Column(Text), raiseload=True)\n\nbook_w_excerpt = session.query(Book).options(undefer(Book.excerpt)).first()\n```", "```py\nsession.query(Order).options(joinedload(Order.items), raiseload(\"*\"))\n```", "```py\n# 1.3\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 14.051527 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 15.002470 sec\ntest_flush_pk_given : (100000 iterations); total time 7.863680 sec\ntest_bulk_save : (100000 iterations); total time 6.780378 sec\ntest_bulk_insert_mappings :  (100000 iterations); total time 5.363070 sec\ntest_core_insert : (100000 iterations); total time 5.362647 sec\n\n# 1.4 with enhancement\n$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test\ntest_flush_no_pk : (100000 iterations); total time 3.820807 sec\ntest_bulk_save_return_pks : (100000 iterations); total time 3.176378 sec\ntest_flush_pk_given : (100000 iterations); total time 4.037789 sec\ntest_bulk_save : (100000 iterations); total time 2.604446 sec\ntest_bulk_insert_mappings : (100000 iterations); total time 1.204897 sec\ntest_core_insert : (100000 iterations); total time 0.958976 sec\n```", "```py\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine INSERT INTO a (data) VALUES (%(data)s) RETURNING a.id\n2020-06-27 19:08:18,166 INFO sqlalchemy.engine.Engine [generated in 0.00698s] ({'data': 'data 1'}, {'data': 'data 2'}, {'data': 'data 3'}, {'data': 'data 4'}, {'data': 'data 5'}, {'data': 'data 6'}, {'data': 'data 7'}, {'data': 'data 8'}  ... displaying 10 of 4999 total bound parameter sets ...  {'data': 'data 4998'}, {'data': 'data 4999'})\n2020-06-27 19:08:18,254 INFO sqlalchemy.engine.Engine COMMIT\n```", "```py\n2020-06-27 19:08:18.169 EDT [26960] LOG:  statement: INSERT INTO a (data)\nVALUES ('data 1'),('data 2'),('data 3'),('data 4'),('data 5'),('data 6'),('data\n7'),('data 8'),('data 9'),('data 10'),('data 11'),('data 12'),\n... ('data 999'),('data 1000') RETURNING a.id\n\n2020-06-27 19:08:18.175 EDT\n[26960] LOG:  statement: INSERT INTO a (data) VALUES ('data 1001'),('data\n1002'),('data 1003'),('data 1004'),('data 1005 '),('data 1006'),('data\n1007'),('data 1008'),('data 1009'),('data 1010'),('data 1011'), ...\n```", "```py\nsess.query(User).filter(User.age > 29).update(\n    {\"age\": User.age - 10}, synchronize_session=\"fetch\"\n)\n```", "```py\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s RETURNING users.id\n[generated in 0.00060s] {'age_int_1': 10, 'age_int_2': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\n```", "```py\nSELECT users.id FROM users WHERE users.age_int > %(age_int_1)s\n[generated in 0.00043s] {'age_int_1': 29}\nCol ('id',)\nRow (2,)\nRow (4,)\nUPDATE users SET age_int=(users.age_int - %(age_int_1)s) WHERE users.age_int > %(age_int_2)s\n[generated in 0.00102s] {'age_int_1': 10, 'age_int_2': 29}\n```", "```py\nrow = s.query(User, Address).join(User.addresses).first()\n\nrow._mapping[User]  # same as row[0]\nrow._mapping[Address]  # same as row[1]\nrow._mapping[\"User\"]  # same as row[0]\nrow._mapping[\"Address\"]  # same as row[1]\n\nu1 = aliased(User)\nrow = s.query(u1).only_return_tuples(True).first()\nrow._mapping[u1]  # same as row[0]\n\nrow = s.query(User.id, Address.email_address).join(User.addresses).first()\n\nrow._mapping[User.id]  # same as row[0]\nrow._mapping[\"id\"]  # same as row[0]\nrow._mapping[users.c.id]  # same as row[0]\n```", "```py\nclass User(Base):\n    # ...\n\n    addresses = relationship(Address, backref=backref(\"user\", viewonly=True))\n\nclass Address(Base): ...\n\nu1 = session.query(User).filter_by(name=\"x\").first()\n\na1 = Address()\na1.user = u1\n```", "```py\nu1 = User()\nsession.add(u1)\n\na1 = Address()\na1.user = u1  # <--- adds \"a1\" to the Session\n```", "```py\nSession = sessionmaker(engine, future=True)\n\nwith Session() as session:\n    u1 = User()\n    session.add(u1)\n\n    a1 = Address()\n    a1.user = u1  # <--- will not add \"a1\" to the Session\n```", "```py\n>>> a1 = session.query(A).options(joinedload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n```", "```py\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nWHERE  a.id  =  ? \n```", "```py\n>>> a1 = session.query(A).options(selectinload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data\nFROM  a\nWHERE  a.id  =  ?\n(1,)\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(1,) \n```", "```py\nq1 = session.query(User).options(with_expression(User.expr, literal(\"u1\")))\nq2 = session.query(User).options(with_expression(User.expr, literal(\"u2\")))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id,\nanon_1.user_account_name  AS  anon_1_user_account_name\nFROM  (\n  SELECT  ?  AS  anon_2,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  ?  AS  anon_3,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n('u1',  'u2')\n```", "```py\nSELECT  ?  AS  anon_1,  anon_2.user_account_id  AS  anon_2_user_account_id,\nanon_2.user_account_name  AS  anon_2_user_account_name\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_2\n('u1',)\n```", "```py\nq1 = session.query(User).options(defer(User.name))\nq2 = session.query(User).options(defer(User.name))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n  UNION  ALL\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n)  AS  anon_1\n```", "```py\nSELECT  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n```", "```py\ns1 = select(User).options(with_expression(User.expr, literal(\"u1\")))\ns2 = select(User).options(with_expression(User.expr, literal(\"u2\")))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(select(User).from_statement(stmt)).all()\n```", "```py\nSELECT  user_account.id,  user_account.name\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name\nFROM  user_account\n```", "```py\ns1 = select(User, literal(\"u1\").label(\"some_literal\"))\ns2 = select(User, literal(\"u2\").label(\"some_literal\"))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(\n    select(User)\n    .from_statement(stmt)\n    .options(with_expression(User.expr, stmt.selected_columns.some_literal))\n).all()\n```", "```py\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\n```", "```py\n>>> u1 = User()\n>>> u1.name\nNone\n>>> u1.addresses\n[]\n```", "```py\n>>> u1 = User()\n>>> u1.addresses.append(Address())  # no need to assign u1.addresses = []\n```", "```py\n>>> u1 = User()\n>>> u1.name = None  # explicit assignment\n\n>>> u2 = User()\n>>> u2.name  # implicit assignment just by accessing it\nNone\n```", "```py\n>>> u1 = User(id=1)  # create an empty User to merge with id=1 in the database\n>>> merged1 = session.merge(\n...     u1\n... )  # value of merged1.addresses is unchanged from that of the DB\n\n>>> u2 = User(id=2)  # create an empty User to merge with id=2 in the database\n>>> u2.addresses\n[]\n>>> merged2 = session.merge(u2)  # value of merged2.addresses has been emptied in the DB\n```", "```py\n>>> u1 = User()\n>>> l1 = u1.addresses  # new list is created, associated with the state\n>>> assert u1.addresses is l1  # you get the same list each time you access it\n>>> assert (\n...     \"addresses\" not in u1.__dict__\n... )  # but it won't go into __dict__ until it's mutated\n>>> from sqlalchemy import inspect\n>>> inspect(u1).attrs.addresses.history\nHistory(added=None, unchanged=None, deleted=None)\n```", "```py\n>>> l1.append(Address())\n>>> assert \"addresses\" in u1.__dict__\n>>> inspect(u1).attrs.addresses.history\nHistory(added=[<__main__.Address object at 0x7f49b725eda0>], unchanged=[], deleted=[])\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n# this will now fail, would pass before\n>>> assert {k: v for k, v in u1.__dict__.items() if not k.startswith(\"_\")} == {\n...     \"addresses\": []\n... }\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n>>> s.add(u1)\n>>> s.flush()\n>>> s.close()\n>>> u1.addresses  # <-- will fail, .addresses is not loaded and object is detached\n```", "```py\n>>> u1.addresses = []\n```", "```py\nclass Product(Base):\n    __tablename__ = \"product\"\n\n    id = Column(Integer, primary_key=True)\n\nsession = Session(engine)\n\n# add Product with primary key 1\nsession.add(Product(id=1))\nsession.flush()\n\n# add another Product with same primary key\nsession.add(Product(id=1))\ns.commit()  # <-- will raise FlushError\n```", "```py\nsqlalchemy/orm/persistence.py:408: SAWarning: New instance <Product at 0x7f1ff65e0ba8> with identity key (<class '__main__.Product'>, (1,), None) conflicts with persistent instance <Product at 0x7f1ff60a4550>\n```", "```py\nsqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: product.id\n```", "```py\n# add another Product with same primary key\ntry:\n    with session.begin_nested():\n        session.add(Product(id=1))\nexcept exc.IntegrityError:\n    print(\"row already exists\")\n```", "```py\nclass User(Base):\n    # ...\n\n    # this is now an error\n    addresses = relationship(\"Address\", viewonly=True, cascade=\"all, delete-orphan\")\n```", "```py\nsqlalchemy.exc.ArgumentError: Cascade settings\n\"delete, delete-orphan, merge, save-update\" apply to persistence\noperations and should not be combined with a viewonly=True relationship.\n```", "```py\ns = Session(e)\n\ns.add_all([Engineer(), Manager()])\n\ns.commit()\n\nprint(s.query(Manager).select_entity_from(s.query(Employee).subquery()).all())\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:04:13,524 INFO sqlalchemy.engine.base.Engine ()\n[<__main__.Engineer object at 0x7f7f5b9a9810>, <__main__.Manager object at 0x7f7f5b9a9750>]\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140205120401296 anon)s.type'\nrefers to mapped class Engineer->engineer, which is not a sub-mapper of\nthe requested mapped class Manager->manager\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\nWHERE anon_1.type IN (?)\n2020-01-29 18:08:32,975 INFO sqlalchemy.engine.base.Engine ('manager',)\n[<__main__.Manager object at 0x7ff1b0200d50>]\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:13:10,554 INFO sqlalchemy.engine.base.Engine ()\nTraceback (most recent call last):\n# ...\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140700085268432 anon)s.type'\nrefers to mapped class Engineer->employee, which is not a sub-mapper of\nthe requested mapped class Manager->employee\n```", "```py\nprint(\n    s.query(Manager)\n    .select_entity_from(\n        s.query(Employee).filter(Employee.discriminator == \"manager\").subquery()\n    )\n    .all()\n)\n```", "```py\nSELECT  anon_1.type  AS  anon_1_type,  anon_1.id  AS  anon_1_id\nFROM  (SELECT  employee.type  AS  type,  employee.id  AS  id\nFROM  employee\nWHERE  employee.type  =  ?)  AS  anon_1\n2020-01-29  18:14:49,770  INFO  sqlalchemy.engine.base.Engine  ('manager',)\n[<__main__.Manager  object  at  0x7f70e13fca90>]\n```", "```py\nrow = s.query(User, Address).join(User.addresses).first()\n\nrow._mapping[User]  # same as row[0]\nrow._mapping[Address]  # same as row[1]\nrow._mapping[\"User\"]  # same as row[0]\nrow._mapping[\"Address\"]  # same as row[1]\n\nu1 = aliased(User)\nrow = s.query(u1).only_return_tuples(True).first()\nrow._mapping[u1]  # same as row[0]\n\nrow = s.query(User.id, Address.email_address).join(User.addresses).first()\n\nrow._mapping[User.id]  # same as row[0]\nrow._mapping[\"id\"]  # same as row[0]\nrow._mapping[users.c.id]  # same as row[0]\n```", "```py\nclass User(Base):\n    # ...\n\n    addresses = relationship(Address, backref=backref(\"user\", viewonly=True))\n\nclass Address(Base): ...\n\nu1 = session.query(User).filter_by(name=\"x\").first()\n\na1 = Address()\na1.user = u1\n```", "```py\nu1 = User()\nsession.add(u1)\n\na1 = Address()\na1.user = u1  # <--- adds \"a1\" to the Session\n```", "```py\nSession = sessionmaker(engine, future=True)\n\nwith Session() as session:\n    u1 = User()\n    session.add(u1)\n\n    a1 = Address()\n    a1.user = u1  # <--- will not add \"a1\" to the Session\n```", "```py\n>>> a1 = session.query(A).options(joinedload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n```", "```py\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nWHERE  a.id  =  ? \n```", "```py\n>>> a1 = session.query(A).options(selectinload(A.bs)).first()\n>>> a1.data = \"new data\"\n>>> session.commit()\n>>> a1.data\nSELECT  a.id  AS  a_id,  a.data  AS  a_data\nFROM  a\nWHERE  a.id  =  ?\n(1,)\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(1,) \n```", "```py\nq1 = session.query(User).options(with_expression(User.expr, literal(\"u1\")))\nq2 = session.query(User).options(with_expression(User.expr, literal(\"u2\")))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id,\nanon_1.user_account_name  AS  anon_1_user_account_name\nFROM  (\n  SELECT  ?  AS  anon_2,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  ?  AS  anon_3,  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n('u1',  'u2')\n```", "```py\nSELECT  ?  AS  anon_1,  anon_2.user_account_id  AS  anon_2_user_account_id,\nanon_2.user_account_name  AS  anon_2_user_account_name\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_2\n('u1',)\n```", "```py\nq1 = session.query(User).options(defer(User.name))\nq2 = session.query(User).options(defer(User.name))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n  UNION  ALL\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n)  AS  anon_1\n```", "```py\nSELECT  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n```", "```py\ns1 = select(User).options(with_expression(User.expr, literal(\"u1\")))\ns2 = select(User).options(with_expression(User.expr, literal(\"u2\")))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(select(User).from_statement(stmt)).all()\n```", "```py\nSELECT  user_account.id,  user_account.name\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name\nFROM  user_account\n```", "```py\ns1 = select(User, literal(\"u1\").label(\"some_literal\"))\ns2 = select(User, literal(\"u2\").label(\"some_literal\"))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(\n    select(User)\n    .from_statement(stmt)\n    .options(with_expression(User.expr, stmt.selected_columns.some_literal))\n).all()\n```", "```py\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\n```", "```py\nq1 = session.query(User).options(defer(User.name))\nq2 = session.query(User).options(defer(User.name))\n\nq1.union_all(q2).all()\n```", "```py\nSELECT  anon_1.anon_2  AS  anon_1_anon_2,  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n  UNION  ALL\n  SELECT  NULL  AS  anon_2,  user_account.id  AS  user_account_id\n  FROM  user_account\n)  AS  anon_1\n```", "```py\nSELECT  anon_1.user_account_id  AS  anon_1_user_account_id\nFROM  (\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n  UNION  ALL\n  SELECT  user_account.id  AS  user_account_id,  user_account.name  AS  user_account_name\n  FROM  user_account\n)  AS  anon_1\n```", "```py\ns1 = select(User).options(with_expression(User.expr, literal(\"u1\")))\ns2 = select(User).options(with_expression(User.expr, literal(\"u2\")))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(select(User).from_statement(stmt)).all()\n```", "```py\nSELECT  user_account.id,  user_account.name\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name\nFROM  user_account\n```", "```py\ns1 = select(User, literal(\"u1\").label(\"some_literal\"))\ns2 = select(User, literal(\"u2\").label(\"some_literal\"))\n\nstmt = union_all(s1, s2)\n\nsession.scalars(\n    select(User)\n    .from_statement(stmt)\n    .options(with_expression(User.expr, stmt.selected_columns.some_literal))\n).all()\n```", "```py\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\nUNION  ALL\nSELECT  user_account.id,  user_account.name,  ?  AS  some_literal\nFROM  user_account\n```", "```py\n>>> u1 = User()\n>>> u1.name\nNone\n>>> u1.addresses\n[]\n```", "```py\n>>> u1 = User()\n>>> u1.addresses.append(Address())  # no need to assign u1.addresses = []\n```", "```py\n>>> u1 = User()\n>>> u1.name = None  # explicit assignment\n\n>>> u2 = User()\n>>> u2.name  # implicit assignment just by accessing it\nNone\n```", "```py\n>>> u1 = User(id=1)  # create an empty User to merge with id=1 in the database\n>>> merged1 = session.merge(\n...     u1\n... )  # value of merged1.addresses is unchanged from that of the DB\n\n>>> u2 = User(id=2)  # create an empty User to merge with id=2 in the database\n>>> u2.addresses\n[]\n>>> merged2 = session.merge(u2)  # value of merged2.addresses has been emptied in the DB\n```", "```py\n>>> u1 = User()\n>>> l1 = u1.addresses  # new list is created, associated with the state\n>>> assert u1.addresses is l1  # you get the same list each time you access it\n>>> assert (\n...     \"addresses\" not in u1.__dict__\n... )  # but it won't go into __dict__ until it's mutated\n>>> from sqlalchemy import inspect\n>>> inspect(u1).attrs.addresses.history\nHistory(added=None, unchanged=None, deleted=None)\n```", "```py\n>>> l1.append(Address())\n>>> assert \"addresses\" in u1.__dict__\n>>> inspect(u1).attrs.addresses.history\nHistory(added=[<__main__.Address object at 0x7f49b725eda0>], unchanged=[], deleted=[])\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n# this will now fail, would pass before\n>>> assert {k: v for k, v in u1.__dict__.items() if not k.startswith(\"_\")} == {\n...     \"addresses\": []\n... }\n```", "```py\n>>> u1 = User()\n>>> u1.addresses\n[]\n>>> s.add(u1)\n>>> s.flush()\n>>> s.close()\n>>> u1.addresses  # <-- will fail, .addresses is not loaded and object is detached\n```", "```py\n>>> u1.addresses = []\n```", "```py\nclass Product(Base):\n    __tablename__ = \"product\"\n\n    id = Column(Integer, primary_key=True)\n\nsession = Session(engine)\n\n# add Product with primary key 1\nsession.add(Product(id=1))\nsession.flush()\n\n# add another Product with same primary key\nsession.add(Product(id=1))\ns.commit()  # <-- will raise FlushError\n```", "```py\nsqlalchemy/orm/persistence.py:408: SAWarning: New instance <Product at 0x7f1ff65e0ba8> with identity key (<class '__main__.Product'>, (1,), None) conflicts with persistent instance <Product at 0x7f1ff60a4550>\n```", "```py\nsqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: product.id\n```", "```py\n# add another Product with same primary key\ntry:\n    with session.begin_nested():\n        session.add(Product(id=1))\nexcept exc.IntegrityError:\n    print(\"row already exists\")\n```", "```py\nclass User(Base):\n    # ...\n\n    # this is now an error\n    addresses = relationship(\"Address\", viewonly=True, cascade=\"all, delete-orphan\")\n```", "```py\nsqlalchemy.exc.ArgumentError: Cascade settings\n\"delete, delete-orphan, merge, save-update\" apply to persistence\noperations and should not be combined with a viewonly=True relationship.\n```", "```py\ns = Session(e)\n\ns.add_all([Engineer(), Manager()])\n\ns.commit()\n\nprint(s.query(Manager).select_entity_from(s.query(Employee).subquery()).all())\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:04:13,524 INFO sqlalchemy.engine.base.Engine ()\n[<__main__.Engineer object at 0x7f7f5b9a9810>, <__main__.Manager object at 0x7f7f5b9a9750>]\n```", "```py\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140205120401296 anon)s.type'\nrefers to mapped class Engineer->engineer, which is not a sub-mapper of\nthe requested mapped class Manager->manager\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\nWHERE anon_1.type IN (?)\n2020-01-29 18:08:32,975 INFO sqlalchemy.engine.base.Engine ('manager',)\n[<__main__.Manager object at 0x7ff1b0200d50>]\n```", "```py\nSELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id\nFROM (SELECT employee.type AS type, employee.id AS id\nFROM employee) AS anon_1\n2020-01-29 18:13:10,554 INFO sqlalchemy.engine.base.Engine ()\nTraceback (most recent call last):\n# ...\nsqlalchemy.exc.InvalidRequestError: Row with identity key\n(<class '__main__.Employee'>, (1,), None) can't be loaded into an object;\nthe polymorphic discriminator column '%(140700085268432 anon)s.type'\nrefers to mapped class Engineer->employee, which is not a sub-mapper of\nthe requested mapped class Manager->employee\n```", "```py\nprint(\n    s.query(Manager)\n    .select_entity_from(\n        s.query(Employee).filter(Employee.discriminator == \"manager\").subquery()\n    )\n    .all()\n)\n```", "```py\nSELECT  anon_1.type  AS  anon_1_type,  anon_1.id  AS  anon_1_id\nFROM  (SELECT  employee.type  AS  type,  employee.id  AS  id\nFROM  employee\nWHERE  employee.type  =  ?)  AS  anon_1\n2020-01-29  18:14:49,770  INFO  sqlalchemy.engine.base.Engine  ('manager',)\n[<__main__.Manager  object  at  0x7f70e13fca90>]\n```", "```py\n$ python -m examples.performance bulk_inserts --test test_core_insert --num 100000 --dburl postgresql://scott:tiger@localhost/test\n\n# 1.3\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 5.229326 sec\n\n# 1.4\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 0.944007 sec\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\n        \"id\", Integer, Sequence(\"some_seq\", start=1, optional=True), primary_key=True\n    ),\n)\n```", "```py\n$ python -m examples.performance bulk_inserts --test test_core_insert --num 100000 --dburl postgresql://scott:tiger@localhost/test\n\n# 1.3\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 5.229326 sec\n\n# 1.4\ntest_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 0.944007 sec\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\n        \"id\", Integer, Sequence(\"some_seq\", start=1, optional=True), primary_key=True\n    ),\n)\n```"]