["```py\nfrom sqlalchemy.orm import Session\n\nsession = Session(engine)\n```", "```py\nwith session.begin():\n    session.add(some_object())\n    session.add(some_other_object())\n# commits transaction at the end, or rolls back if there\n# was an exception raised\n```", "```py\nsession = Session(engine)\n\nsession.add(some_object())\nsession.add(some_other_object())\n\nsession.commit()  # commits\n\n# will automatically begin again\nresult = session.execute(text(\"< some select statement >\"))\nsession.add_all([more_objects, ...])\nsession.commit()  # commits\n\nsession.add(still_another_object)\nsession.flush()  # flush still_another_object\nsession.rollback()  # rolls back still_another_object\n```", "```py\n# expunges all objects, releases all transactions unconditionally\n# (with rollback), releases all database connections back to their\n# engines\nsession.close()\n```", "```py\nwith Session(engine) as session:\n    session.add(some_object())\n    session.add(some_other_object())\n\n    session.commit()  # commits\n\n    session.add(still_another_object)\n    session.flush()  # flush still_another_object\n\n    session.commit()  # commits\n\n    result = session.execute(text(\"<some SELECT statement>\"))\n\n# remaining transactional state from the .execute() call is\n# discarded\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    with session.begin():\n        session.add(some_object)\n    # commits\n\n# closes the Session\n```", "```py\nwith Session.begin() as session:\n    session.add(some_object)\n```", "```py\nSession = sessionmaker()\n\nwith Session.begin() as session:\n    session.add(u1)\n    session.add(u2)\n\n    nested = session.begin_nested()  # establish a savepoint\n    session.add(u3)\n    nested.rollback()  # rolls back u3, keeps u1 and u2\n\n# commits u1 and u2\n```", "```py\nfor record in records:\n    try:\n        with session.begin_nested():\n            session.merge(record)\n    except:\n        print(\"Skipped record %s\" % record)\nsession.commit()\n```", "```py\nfrom sqlalchemy import exc\n\nwith session.begin():\n    for record in records:\n        try:\n            with session.begin_nested():\n                obj = SomeRecord(id=record[\"identifier\"], name=record[\"name\"])\n                session.add(obj)\n        except exc.IntegrityError:\n            print(f\"Skipped record {record} - row already exists\")\n```", "```py\nORM                                           Core\n-----------------------------------------     -----------------------------------\nsessionmaker                                  Engine\nSession                                       Connection\nsessionmaker.begin()                          Engine.begin()\nsome_session.commit()                         some_connection.commit()\nwith some_sessionmaker() as session:          with some_engine.connect() as conn:\nwith some_sessionmaker.begin() as session:    with some_engine.begin() as conn:\nwith some_session.begin_nested() as sp:       with some_connection.begin_nested() as sp:\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.connect() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    conn.commit()\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    session.commit()\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n# commits and closes automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n# commits and closes automatically\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    savepoint = conn.begin_nested()\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    savepoint.commit()  # or rollback\n\n# commits automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    savepoint = session.begin_nested()\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    savepoint.commit()  # or rollback\n# commits automatically\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nsession.begin()\ntry:\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n    session.commit()\nexcept:\n    session.rollback()\n    raise\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nwith session.begin():\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker(twophase=True)\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n\n# .... work with accounts and users\n\n# commit.  session will issue a flush to all DBs, and a prepare step to all DBs,\n# before committing both transactions\nsession.commit()\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    isolation_level=\"REPEATABLE READ\",\n)\n\nSession = sessionmaker(eng)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n\ntransactional_session = sessionmaker(eng)\nautocommit_session = sessionmaker(autocommit_engine)\n```", "```py\nwith autocommit_session() as session:\n    some_objects = session.execute(text(\"<statement>\"))\n    some_other_objects = session.execute(text(\"<statement>\"))\n\n# closes connection\n```", "```py\nplain_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = plain_engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n# will normally use plain_engine\nSession = sessionmaker(plain_engine)\n\n# make a specific Session that will use the \"autocommit\" engine\nwith Session(bind=autocommit_engine) as session:\n    # work with session\n    ...\n```", "```py\nwith Session() as session:\n    session.bind_mapper(User, autocommit_engine)\n```", "```py\nfrom sqlalchemy.orm import Session\n\n# assume session just constructed\nsess = Session(bind=engine)\n\n# call connection() with options before any other operations proceed.\n# this will procure a new connection from the bound engine and begin a real\n# database transaction.\nsess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n# ... work with session in SERIALIZABLE isolation level...\n\n# commit transaction.  the connection is released\n# and reverted to its previous isolation level.\nsess.commit()\n\n# subsequent to commit() above, a new transaction may be begun if desired,\n# which will proceed with the previous default isolation level unless\n# it is set again.\n```", "```py\nsess = Session(bind=engine)\n\nwith sess.begin():\n    # call connection() with options before any other operations proceed.\n    # this will procure a new connection from the bound engine and begin a\n    # real database transaction.\n    sess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n    # ... work with session in SERIALIZABLE isolation level...\n\n# outside the block, the transaction has been committed.  the connection is\n# released and reverted to its previous isolation level.\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\nfrom unittest import TestCase\n\n# global application scope.  create Session class, engine\nSession = sessionmaker()\n\nengine = create_engine(\"postgresql+psycopg2://...\")\n\nclass SomeTest(TestCase):\n    def setUp(self):\n        # connect to the database\n        self.connection = engine.connect()\n\n        # begin a non-ORM transaction\n        self.trans = self.connection.begin()\n\n        # bind an individual Session to the connection, selecting\n        # \"create_savepoint\" join_transaction_mode\n        self.session = Session(\n            bind=self.connection, join_transaction_mode=\"create_savepoint\"\n        )\n\n    def test_something(self):\n        # use the session in tests.\n\n        self.session.add(Foo())\n        self.session.commit()\n\n    def test_something_with_rollbacks(self):\n        self.session.add(Bar())\n        self.session.flush()\n        self.session.rollback()\n\n        self.session.add(Foo())\n        self.session.commit()\n\n    def tearDown(self):\n        self.session.close()\n\n        # rollback - everything that happened with the\n        # Session above (including calls to commit())\n        # is rolled back.\n        self.trans.rollback()\n\n        # return connection to the Engine\n        self.connection.close()\n```", "```py\nfrom sqlalchemy.orm import Session\n\nsession = Session(engine)\n```", "```py\nwith session.begin():\n    session.add(some_object())\n    session.add(some_other_object())\n# commits transaction at the end, or rolls back if there\n# was an exception raised\n```", "```py\nsession = Session(engine)\n\nsession.add(some_object())\nsession.add(some_other_object())\n\nsession.commit()  # commits\n\n# will automatically begin again\nresult = session.execute(text(\"< some select statement >\"))\nsession.add_all([more_objects, ...])\nsession.commit()  # commits\n\nsession.add(still_another_object)\nsession.flush()  # flush still_another_object\nsession.rollback()  # rolls back still_another_object\n```", "```py\n# expunges all objects, releases all transactions unconditionally\n# (with rollback), releases all database connections back to their\n# engines\nsession.close()\n```", "```py\nwith Session(engine) as session:\n    session.add(some_object())\n    session.add(some_other_object())\n\n    session.commit()  # commits\n\n    session.add(still_another_object)\n    session.flush()  # flush still_another_object\n\n    session.commit()  # commits\n\n    result = session.execute(text(\"<some SELECT statement>\"))\n\n# remaining transactional state from the .execute() call is\n# discarded\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    with session.begin():\n        session.add(some_object)\n    # commits\n\n# closes the Session\n```", "```py\nwith Session.begin() as session:\n    session.add(some_object)\n```", "```py\nSession = sessionmaker()\n\nwith Session.begin() as session:\n    session.add(u1)\n    session.add(u2)\n\n    nested = session.begin_nested()  # establish a savepoint\n    session.add(u3)\n    nested.rollback()  # rolls back u3, keeps u1 and u2\n\n# commits u1 and u2\n```", "```py\nfor record in records:\n    try:\n        with session.begin_nested():\n            session.merge(record)\n    except:\n        print(\"Skipped record %s\" % record)\nsession.commit()\n```", "```py\nfrom sqlalchemy import exc\n\nwith session.begin():\n    for record in records:\n        try:\n            with session.begin_nested():\n                obj = SomeRecord(id=record[\"identifier\"], name=record[\"name\"])\n                session.add(obj)\n        except exc.IntegrityError:\n            print(f\"Skipped record {record} - row already exists\")\n```", "```py\nORM                                           Core\n-----------------------------------------     -----------------------------------\nsessionmaker                                  Engine\nSession                                       Connection\nsessionmaker.begin()                          Engine.begin()\nsome_session.commit()                         some_connection.commit()\nwith some_sessionmaker() as session:          with some_engine.connect() as conn:\nwith some_sessionmaker.begin() as session:    with some_engine.begin() as conn:\nwith some_session.begin_nested() as sp:       with some_connection.begin_nested() as sp:\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.connect() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    conn.commit()\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    session.commit()\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n# commits and closes automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n# commits and closes automatically\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    savepoint = conn.begin_nested()\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    savepoint.commit()  # or rollback\n\n# commits automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    savepoint = session.begin_nested()\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    savepoint.commit()  # or rollback\n# commits automatically\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nsession.begin()\ntry:\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n    session.commit()\nexcept:\n    session.rollback()\n    raise\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nwith session.begin():\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker(twophase=True)\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n\n# .... work with accounts and users\n\n# commit.  session will issue a flush to all DBs, and a prepare step to all DBs,\n# before committing both transactions\nsession.commit()\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    isolation_level=\"REPEATABLE READ\",\n)\n\nSession = sessionmaker(eng)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n\ntransactional_session = sessionmaker(eng)\nautocommit_session = sessionmaker(autocommit_engine)\n```", "```py\nwith autocommit_session() as session:\n    some_objects = session.execute(text(\"<statement>\"))\n    some_other_objects = session.execute(text(\"<statement>\"))\n\n# closes connection\n```", "```py\nplain_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = plain_engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n# will normally use plain_engine\nSession = sessionmaker(plain_engine)\n\n# make a specific Session that will use the \"autocommit\" engine\nwith Session(bind=autocommit_engine) as session:\n    # work with session\n    ...\n```", "```py\nwith Session() as session:\n    session.bind_mapper(User, autocommit_engine)\n```", "```py\nfrom sqlalchemy.orm import Session\n\n# assume session just constructed\nsess = Session(bind=engine)\n\n# call connection() with options before any other operations proceed.\n# this will procure a new connection from the bound engine and begin a real\n# database transaction.\nsess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n# ... work with session in SERIALIZABLE isolation level...\n\n# commit transaction.  the connection is released\n# and reverted to its previous isolation level.\nsess.commit()\n\n# subsequent to commit() above, a new transaction may be begun if desired,\n# which will proceed with the previous default isolation level unless\n# it is set again.\n```", "```py\nsess = Session(bind=engine)\n\nwith sess.begin():\n    # call connection() with options before any other operations proceed.\n    # this will procure a new connection from the bound engine and begin a\n    # real database transaction.\n    sess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n    # ... work with session in SERIALIZABLE isolation level...\n\n# outside the block, the transaction has been committed.  the connection is\n# released and reverted to its previous isolation level.\n```", "```py\nSession = sessionmaker()\n\nwith Session.begin() as session:\n    session.add(u1)\n    session.add(u2)\n\n    nested = session.begin_nested()  # establish a savepoint\n    session.add(u3)\n    nested.rollback()  # rolls back u3, keeps u1 and u2\n\n# commits u1 and u2\n```", "```py\nfor record in records:\n    try:\n        with session.begin_nested():\n            session.merge(record)\n    except:\n        print(\"Skipped record %s\" % record)\nsession.commit()\n```", "```py\nfrom sqlalchemy import exc\n\nwith session.begin():\n    for record in records:\n        try:\n            with session.begin_nested():\n                obj = SomeRecord(id=record[\"identifier\"], name=record[\"name\"])\n                session.add(obj)\n        except exc.IntegrityError:\n            print(f\"Skipped record {record} - row already exists\")\n```", "```py\nORM                                           Core\n-----------------------------------------     -----------------------------------\nsessionmaker                                  Engine\nSession                                       Connection\nsessionmaker.begin()                          Engine.begin()\nsome_session.commit()                         some_connection.commit()\nwith some_sessionmaker() as session:          with some_engine.connect() as conn:\nwith some_sessionmaker.begin() as session:    with some_engine.begin() as conn:\nwith some_session.begin_nested() as sp:       with some_connection.begin_nested() as sp:\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.connect() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    conn.commit()\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    session.commit()\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n# commits and closes automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n# commits and closes automatically\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    savepoint = conn.begin_nested()\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    savepoint.commit()  # or rollback\n\n# commits automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    savepoint = session.begin_nested()\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    savepoint.commit()  # or rollback\n# commits automatically\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.connect() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    conn.commit()\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    session.commit()\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n# commits and closes automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n# commits and closes automatically\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://user:pass@host/dbname\")\n\nwith engine.begin() as conn:\n    savepoint = conn.begin_nested()\n    conn.execute(\n        some_table.insert(),\n        [\n            {\"data\": \"some data one\"},\n            {\"data\": \"some data two\"},\n            {\"data\": \"some data three\"},\n        ],\n    )\n    savepoint.commit()  # or rollback\n\n# commits automatically\n```", "```py\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    savepoint = session.begin_nested()\n    session.add_all(\n        [\n            SomeClass(data=\"some data one\"),\n            SomeClass(data=\"some data two\"),\n            SomeClass(data=\"some data three\"),\n        ]\n    )\n    savepoint.commit()  # or rollback\n# commits automatically\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nsession.begin()\ntry:\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n    session.commit()\nexcept:\n    session.rollback()\n    raise\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\nwith session.begin():\n    item1 = session.get(Item, 1)\n    item2 = session.get(Item, 2)\n    item1.foo = \"bar\"\n    item2.bar = \"foo\"\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker(twophase=True)\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n\n# .... work with accounts and users\n\n# commit.  session will issue a flush to all DBs, and a prepare step to all DBs,\n# before committing both transactions\nsession.commit()\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    isolation_level=\"REPEATABLE READ\",\n)\n\nSession = sessionmaker(eng)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n\ntransactional_session = sessionmaker(eng)\nautocommit_session = sessionmaker(autocommit_engine)\n```", "```py\nwith autocommit_session() as session:\n    some_objects = session.execute(text(\"<statement>\"))\n    some_other_objects = session.execute(text(\"<statement>\"))\n\n# closes connection\n```", "```py\nplain_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = plain_engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n# will normally use plain_engine\nSession = sessionmaker(plain_engine)\n\n# make a specific Session that will use the \"autocommit\" engine\nwith Session(bind=autocommit_engine) as session:\n    # work with session\n    ...\n```", "```py\nwith Session() as session:\n    session.bind_mapper(User, autocommit_engine)\n```", "```py\nfrom sqlalchemy.orm import Session\n\n# assume session just constructed\nsess = Session(bind=engine)\n\n# call connection() with options before any other operations proceed.\n# this will procure a new connection from the bound engine and begin a real\n# database transaction.\nsess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n# ... work with session in SERIALIZABLE isolation level...\n\n# commit transaction.  the connection is released\n# and reverted to its previous isolation level.\nsess.commit()\n\n# subsequent to commit() above, a new transaction may be begun if desired,\n# which will proceed with the previous default isolation level unless\n# it is set again.\n```", "```py\nsess = Session(bind=engine)\n\nwith sess.begin():\n    # call connection() with options before any other operations proceed.\n    # this will procure a new connection from the bound engine and begin a\n    # real database transaction.\n    sess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n    # ... work with session in SERIALIZABLE isolation level...\n\n# outside the block, the transaction has been committed.  the connection is\n# released and reverted to its previous isolation level.\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    isolation_level=\"REPEATABLE READ\",\n)\n\nSession = sessionmaker(eng)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n\ntransactional_session = sessionmaker(eng)\nautocommit_session = sessionmaker(autocommit_engine)\n```", "```py\nwith autocommit_session() as session:\n    some_objects = session.execute(text(\"<statement>\"))\n    some_other_objects = session.execute(text(\"<statement>\"))\n\n# closes connection\n```", "```py\nplain_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = plain_engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n# will normally use plain_engine\nSession = sessionmaker(plain_engine)\n\n# make a specific Session that will use the \"autocommit\" engine\nwith Session(bind=autocommit_engine) as session:\n    # work with session\n    ...\n```", "```py\nwith Session() as session:\n    session.bind_mapper(User, autocommit_engine)\n```", "```py\nfrom sqlalchemy.orm import Session\n\n# assume session just constructed\nsess = Session(bind=engine)\n\n# call connection() with options before any other operations proceed.\n# this will procure a new connection from the bound engine and begin a real\n# database transaction.\nsess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n# ... work with session in SERIALIZABLE isolation level...\n\n# commit transaction.  the connection is released\n# and reverted to its previous isolation level.\nsess.commit()\n\n# subsequent to commit() above, a new transaction may be begun if desired,\n# which will proceed with the previous default isolation level unless\n# it is set again.\n```", "```py\nsess = Session(bind=engine)\n\nwith sess.begin():\n    # call connection() with options before any other operations proceed.\n    # this will procure a new connection from the bound engine and begin a\n    # real database transaction.\n    sess.connection(execution_options={\"isolation_level\": \"SERIALIZABLE\"})\n\n    # ... work with session in SERIALIZABLE isolation level...\n\n# outside the block, the transaction has been committed.  the connection is\n# released and reverted to its previous isolation level.\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\nfrom unittest import TestCase\n\n# global application scope.  create Session class, engine\nSession = sessionmaker()\n\nengine = create_engine(\"postgresql+psycopg2://...\")\n\nclass SomeTest(TestCase):\n    def setUp(self):\n        # connect to the database\n        self.connection = engine.connect()\n\n        # begin a non-ORM transaction\n        self.trans = self.connection.begin()\n\n        # bind an individual Session to the connection, selecting\n        # \"create_savepoint\" join_transaction_mode\n        self.session = Session(\n            bind=self.connection, join_transaction_mode=\"create_savepoint\"\n        )\n\n    def test_something(self):\n        # use the session in tests.\n\n        self.session.add(Foo())\n        self.session.commit()\n\n    def test_something_with_rollbacks(self):\n        self.session.add(Bar())\n        self.session.flush()\n        self.session.rollback()\n\n        self.session.add(Foo())\n        self.session.commit()\n\n    def tearDown(self):\n        self.session.close()\n\n        # rollback - everything that happened with the\n        # Session above (including calls to commit())\n        # is rolled back.\n        self.trans.rollback()\n\n        # return connection to the Engine\n        self.connection.close()\n```"]