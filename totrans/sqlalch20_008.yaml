- en: Using SELECT Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SELECT 语句
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/data_select.html](https://docs.sqlalchemy.org/en/20/tutorial/data_select.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/data_select.html](https://docs.sqlalchemy.org/en/20/tutorial/data_select.html)
- en: For both Core and ORM, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function generates a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct which is used for all SELECT queries.
    Passed to methods like [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") in Core and [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in ORM, a SELECT statement is emitted in the
    current transaction and the result rows available via the returned [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Core 和 ORM，[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 函数生成一个用于所有 SELECT 查询的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造。传递给 Core 中的 [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") 方法和 ORM 中的 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法，在当前事务中发出 SELECT 语句并通过返回的 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象获取结果行。
- en: '**ORM Readers** - the content here applies equally well to both Core and ORM
    use and basic ORM variant use cases are mentioned here. However there are a lot
    more ORM-specific features available as well; these are documented at [ORM Querying
    Guide](../orm/queryguide/index.html).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**ORM 读者** - 这里的内容同样适用于 Core 和 ORM 使用，并提到了基本 ORM 变体用例。然而，还有更多的 ORM 特定功能可用；这些在[ORM
    查询指南](../orm/queryguide/index.html)中有文档记录。'
- en: The select() SQL Expression Construct
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: select() SQL 表达式构造
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct builds up a statement in the same way as that of [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), using a [generative](../glossary.html#term-generative)
    approach where each method builds more state onto the object. Like the other SQL
    constructs, it can be stringified in place:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造以与 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    相同的方式构建语句，使用 [生成式](../glossary.html#term-generative) 方法，其中每个方法都会将更多的状态添加到对象上。与其他
    SQL 构造一样，它可以在原地字符串化：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also in the same manner as all other statement-level SQL constructs, to actually
    run the statement we pass it to an execution method. Since a SELECT statement
    returns rows we can always iterate the result object to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects back:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他语句级别的 SQL 构造相同，要实际运行语句，我们将其传递给执行方法。由于 SELECT 语句返回行，我们始终可以迭代结果对象以获取 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象返回：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using the ORM, particularly with a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct that’s composed against ORM entities,
    we will want to execute it using the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); using this approach, we continue to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects from the result, however these rows are now capable
    of including complete entities, such as instances of the `User` class, as individual
    elements within each row:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 时，特别是对 ORM 实体组成的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 结构执行时，我们将希望使用 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 上执行它；通过这种方法，我们继续从结果中获取 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，但是这些行现在可以包括完整的实体，例如 `User` 类的实例，作为每行中的单独元素：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following sections will discuss the SELECT construct in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将更详细地讨论 SELECT 构造。
- en: '## Setting the COLUMNS and FROM clause'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## 设置 COLUMNS 和 FROM 子句'
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    function accepts positional elements representing any number of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and/or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") expressions, as well as a wide range of compatible
    objects, which are resolved into a list of SQL expressions to be SELECTed from
    that will be returned as columns in the result set. These elements also serve
    in simpler cases to create the FROM clause, which is inferred from the columns
    and table-like expressions passed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    函数接受表示任意数量[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")和/或[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")表达式的位置元素，以及一系列兼容对象，这些对象将解析为要从中选择的SQL表达式列表，这些表达式将作为结果集中的列返回。这些元素在更简单的情况下还用于创建FROM子句，该子句是从传递的列和类似表达式中推断出来的：'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To SELECT from individual columns using a Core approach, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are accessed from the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor and can be sent directly; the FROM clause
    will be inferred as the set of all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects that are represented by those
    columns:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心方法从单独列进行SELECT操作时，可以直接访问[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问器中的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象；FROM子句将被推断为由这些列所代表的所有[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和其他[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")对象的集合：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, when using the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection of any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), multiple columns may be specified for a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") by using a tuple of string names:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当使用任何[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")的[`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c")集合，例如[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")时，可以通过使用字符串名称的元组指定多个列进行[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")操作：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'New in version 2.0: Added tuple-accessor capability to the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中新增：为[`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c")集合添加了元组访问器功能
- en: '### Selecting ORM Entities and Columns'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择ORM实体和列'
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ORM实体，例如我们的`User`类以及其上的列映射属性，例如`User.name`，也参与SQL表达语言系统，表示表和列。下面举例说明了从`User`实体中进行SELECT操作的示例，最终呈现的方式与直接使用`user_table`相同：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法执行类似上述语句时，当我们从完整实体（例如`User`）选择时，与`user_table`相反，有一个重要的区别，即**实体本身作为每行的单个元素返回**。也就是说，当我们从上述语句中获取行时，因为在要获取的内容列表中只有`User`实体，所以我们会收到仅包含一个元素的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，其中包含`User`类的实例：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")只有一个元素，代表`User`实体：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与上述相同结果的一种高度推荐的便利方法是使用[`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")方法直接执行语句；此方法将返回一个[`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")对象，该对象一次性返回每行的第一个“列”，在本例中是`User`类的实例：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用类绑定的属性选择 ORM 实体的各个列作为结果行中的单独元素；当这些属性传递给诸如[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")之类的构造时，它们会解析为每个属性代表的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或其他 SQL 表达式：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")调用*此*语句时，我们现在会收到每个值具有单独元素的行，每个元素对应一个单独的列或其他 SQL
    表达式：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以混合使用这些方法，如下所示，我们选择`User`实体的`name`属性作为行的第一个元素，并将其与完整的`Address`实体组合为第二个元素：
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[选择 ORM 实体和列](../orm/queryguide/select.html#orm-queryguide-select-columns)以及将行转换为常见方法方面的方法进一步讨论。
- en: See also
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 ORM 实体和列](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - 在[ORM 查询指南](../orm/queryguide/index.html)中'
- en: Selecting from Labeled SQL Expressions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从带标签的 SQL 表达式中进行选择
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label")方法以及可用于ORM属性的同名方法提供列或表达式的SQL标签，允许它在结果集中具有特定名称。当通过名称引用结果行中的任意SQL表达式时，这可能会有所帮助：'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[按标签排序或分组](#tutorial-order-by-label) - 我们创建的标签名称也可以在[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")的ORDER BY或GROUP BY子句中引用。'
- en: '### Selecting with Textual Column Expressions'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用文本列表达式进行选择'
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")函数构造一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象时，通常会向其中传递一系列使用[table metadata](metadata.html#tutorial-working-with-metadata)定义的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，或者在使用ORM时，我们可能会发送代表表列的ORM映射属性。然而，有时也需要在语句中制造任意SQL块，比如常量字符串表达式，或者一些直接编写的任意SQL。
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)中介绍的[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造实际上可以直接嵌入到[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中，如下所示，我们制造了一个硬编码的字符串字面量`'some phrase'`并将其嵌入到SELECT语句中：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")构造可用于大多数位置来插入文字SQL短语，但我们实际上更多地处理的是每个代表单个列表达式的文本单元。在这种常见情况下，我们可以使用[`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column")构造来获得更多的功能。此对象类似于[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")，但它不是表示任意形式的任意SQL，而是明确表示一个“列”，然后可以在子查询和其他表达式中进行标记和引用：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.  ## The WHERE clause'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用 [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    或 [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") 时，我们正在编写一个语法上的 SQL 表达式，而不是一个字面值。因此，我们必须包括所需的任何引号或语法，以便我们想要看到的
    SQL 被呈现出来。## WHERE 子句
- en: 'SQLAlchemy allows us to compose SQL expressions, such as `name = ''squidward''`
    or `user_id > 10`, by making use of standard Python operators in conjunction with
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and similar objects. For boolean expressions, most Python operators such as `==`,
    `!=`, `<`, `>=` etc. generate new SQL Expression objects, rather than plain boolean
    `True`/`False` values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 允许我们通过使用标准 Python 运算符结合 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 和类似对象来组合 SQL 表达式，例如 `name = 'squidward'` 或 `user_id
    > 10`。对于布尔表达式，大多数 Python 运算符（如 `==`、`!=`、`<`、`>=` 等）生成新的 SQL 表达式对象，而不是纯粹的布尔 `True`/`False`
    值：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use expressions like these to generate the WHERE clause by passing the
    resulting objects to the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的表达式来生成 WHERE 子句，方法是将生成的对象传递给 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 方法：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To produce multiple expressions joined by AND, the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method may be invoked any number of
    times:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成由 AND 连接的多个表达式，可以多次调用 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 方法：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A single call to [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") also accepts multiple expressions with
    the same effect:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有相同效果的多个表达式，单次调用 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 也可以接受多个表达式：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '“AND” and “OR” conjunctions are both available directly using the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") functions, illustrated below in terms of ORM
    entities:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “AND” 和 “OR” 连接词可以直接使用 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 和 [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") 函数，下面是在 ORM 实体方面的示例：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For simple “equality” comparisons against a single entity, there’s also a popular
    method known as [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") which accepts keyword arguments
    that match to column keys or ORM attribute names. It will filter against the leftmost
    FROM clause or the last entity joined:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于针对单个实体的简单“相等性”比较，还有一种称为 [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") 的流行方法，它接受与列键或 ORM 属性名称匹配的关键字参数。它将针对最左边的
    FROM 子句或最后一个连接的实体进行过滤：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See also
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Operator Reference](../core/operators.html) - descriptions of most SQL operator
    functions in SQLAlchemy  ## Explicit FROM clauses and JOINs'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[运算符参考](../core/operators.html) - SQLAlchemy 中大多数 SQL 运算符函数的描述## 明确的 FROM 子句和
    JOINs'
- en: As mentioned previously, the FROM clause is usually **inferred** based on the
    expressions that we are setting in the columns clause as well as other elements
    of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，FROM 子句通常是基于我们在列子句中设置的表达式以及 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 的其他元素而 **推断** 的。
- en: 'If we set a single column from a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the COLUMNS clause, it puts that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the FROM clause as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 COLUMNS 子句中设置了一个特定 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的单个列，它也会将该 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 放在 FROM 子句中：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we were to put columns from two tables, then we get a comma-separated FROM
    clause:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从两个表中取列，那么我们得到一个用逗号分隔的 FROM 子句：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to JOIN these two tables together, we typically use one of two methods
    on [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
    The first is the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method, which allows us to indicate
    the left and right side of the JOIN explicitly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这两个表 JOIN 在一起，我们通常在 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 上使用两种方法之一。第一种是 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 方法，它允许我们明确指示 JOIN 的左侧和右侧：
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The other is the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method, which indicates only the right
    side of the JOIN, the left hand-side is inferred:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法，它表示 JOIN 的右侧，左侧被推断：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also have the option to add elements to the FROM clause explicitly, if it
    is not inferred the way we want from the columns clause. We use the [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method to achieve this, as below
    where we establish `user_table` as the first element in the FROM clause and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to establish `address_table` as the second:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 FROM 子句没有按照我们想要的方式进行推断，我们还可以选择将元素明确添加到 FROM 子句中。我们使用 [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 方法来实现这一点，如下所示，我们将 `user_table`
    设为 FROM 子句中的第一个元素，然后使用 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 将 `address_table` 设为第二个元素：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another example where we might want to use [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") is if our columns clause doesn’t
    have enough information to provide for a FROM clause. For example, to SELECT from
    the common SQL expression `count(*)`, we use a SQLAlchemy element known as [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to produce the SQL `count()` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要使用 [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 的另一个示例是，如果我们的 columns 子句没有足够的信息提供
    FROM 子句。例如，要从常见的 SQL 表达式 `count(*)` 中选择，我们使用名为 [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 的 SQLAlchemy 元素来生成 SQL `count()` 函数：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Setting the leftmost FROM clause in a join](../orm/queryguide/select.html#orm-queryguide-select-from)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) - contains additional
    examples and notes regarding the interaction of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[在连接中设置最左侧的 FROM 子句](../orm/queryguide/select.html#orm-queryguide-select-from)
    - 在 [ORM 查询指南](../orm/queryguide/index.html) - 包含有关 [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 和 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 互动的附加示例和注释。'
- en: '### Setting the ON Clause'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置 ON 子句'
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面 JOIN 的示例说明了 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 结构可以在两个表之间进行 JOIN，并自动生成 ON 子句。这在这些示例中发生，因为
    `user_table` 和 `address_table` `Table` 对象包含单个 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 定义，用于形成此 ON 子句。
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接的左右目标没有这样的约束，或者存在多个约束，则需要直接指定 ON 子句。 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 都接受用于 ON 子句的额外参数，其使用与我们在 [WHERE
    子句](#tutorial-select-where-clause) 中看到的 SQL 表达式机制相同：
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**ORM 提示** - 在使用 ORM 实体时，当使用 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造时，还有另一种生成 ON 子句的方式，就像在 [声明映射类](metadata.html#tutorial-declaring-mapped-classes)
    中的前一节设置的映射一样。这是一个单独的主题，详细介绍在 [使用关系连接](orm_related_objects.html#tutorial-joining-relationships)。'
- en: OUTER and FULL join
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OUTER 和 FULL join
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 方法都接受关键字参数 [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join")，分别会渲染 LEFT OUTER JOIN 和 FULL OUTER JOIN：'
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方法 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")，它等同于使用 `.join(..., isouter=True)`。
- en: Tip
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.  ## ORDER
    BY, GROUP BY, HAVING'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQL 还有一个“RIGHT OUTER JOIN”。SQLAlchemy 不会直接呈现这个；相反，反转表的顺序并使用“LEFT OUTER JOIN”。  ##
    ORDER BY、GROUP BY、HAVING'
- en: The SELECT SQL statement includes a clause called ORDER BY which is used to
    return the selected rows within a given ordering.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT SQL 语句包括一个称为 ORDER BY 的子句，用于以给定顺序返回所选行。
- en: The GROUP BY clause is constructed similarly to the ORDER BY clause, and has
    the purpose of sub-dividing the selected rows into specific groups upon which
    aggregate functions may be invoked. The HAVING clause is usually used with GROUP
    BY and is of a similar form to the WHERE clause, except that it’s applied to the
    aggregated functions used within groups.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: GROUP BY 子句的构造方式类似于 ORDER BY 子句，其目的是将所选行细分为特定的分组，从而可以对这些分组调用聚合函数。HAVING 子句通常与
    GROUP BY 一起使用，其形式与 WHERE 子句类似，只是它应用于分组内使用的聚合函数。
- en: '### ORDER BY'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORDER BY'
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ORDER BY子句是根据SQL表达式构造的，通常基于[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或类似对象。[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")方法按位置接受一个或多个这些表达式：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 升序/降序可以从[`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc")和[`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc")修饰符中获得，这些修饰符也存在于ORM绑定的属性中：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.  ### Aggregate functions with GROUP BY / HAVING'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将按照`user_account.fullname`列按降序排序的行。### 带有GROUP BY / HAVING的聚合函数
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，聚合函数允许跨多行的列表达式聚合在一起，以产生单个结果。示例包括计数、计算平均值，以及在一组值中定位最大值或最小值。
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy以一种开放式的方式提供SQL函数，使用一个名为[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")的命名空间。这是一个特殊的构造对象，当给定特定SQL函数的名称时，它将创建[`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function")的新实例，该函数可以有任何名称，以及零个或多个要传递给函数的参数，就像在所有其他情况下一样，都是SQL表达式构造。例如，要针对`user_account.id`列渲染SQL
    COUNT()函数，我们调用`count()`名称：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SQL函数在本教程的后面部分详细描述，链接在[使用SQL函数](#tutorial-functions)。
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中使用聚合函数时，GROUP BY子句是必不可少的，因为它允许将行分成组，其中聚合函数将分别应用于每个组。在SELECT语句的COLUMNS子句中请求非聚合列时，SQL要求这些列都受到GROUP
    BY子句的约束，直接或间接地基于主键关联。然后，HAVING子句类似于WHERE子句，不同之处在于它根据聚合值而不是直接行内容来过滤行。
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供了这两个子句的功能，使用 [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") 和 [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") 方法。下面我们示例选择用户名称字段以及地址计数，对于那些拥有多个地址的用户：
- en: '[PRE33]  ### Ordering or Grouping by a Label'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]  ### 按标签排序或分组'
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的一项技术，在某些数据库后端特别是，是有能力按照已在列子句中已经声明的表达式进行 ORDER BY 或 GROUP BY，而无需在 ORDER
    BY 或 GROUP BY 子句中重新声明表达式，而是使用 COLUMNS 子句中的列名或标记名。可以通过将名称的字符串文本传递给 [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") 或 [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") 方法来使用这种形式。传递的文本**不会直接渲染**；而是在列子句中给定的表达式名称，并在上下文中呈现为该表达式名称，如果找不到匹配项，则会引发错误。这种形式也可以使用一元修饰符
    [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    和 [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")：
- en: '[PRE34]  ## Using Aliases'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]  ## 使用别名'
- en: Now that we are selecting from multiple tables and using joins, we quickly run
    into the case where we need to refer to the same table multiple times in the FROM
    clause of a statement. We accomplish this using SQL **aliases**, which are a syntax
    that supplies an alternative name to a table or subquery from which it can be
    referenced in the statement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在从多个表中进行选择并使用连接，我们很快就会遇到需要在语句的 FROM 子句中多次引用同一张表的情况。我们使用 SQL **别名** 来实现这一点，这是一种为表或子查询提供替代名称的语法，可以在语句中引用它。
- en: 'In the SQLAlchemy Expression Language, these “names” are instead represented
    by [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects known as the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct, which is constructed in Core using
    the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method. An [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct is just like a `Table` construct
    in that it also has a namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the `Alias.c` collection. The SELECT
    statement below for example returns all unique pairs of user names:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 表达语言中，这些“名称”代替了 [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 对象，被称为 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") 构造，在 Core 中使用 [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") 方法构造。一个 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") 构造就像一个 `Table` 构造一样，它也有一个在 `Alias.c` 集合中的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的命名空间。例如下面的 SELECT 语句返回所有唯一的用户名对：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '### ORM Entity Aliases'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM 实体别名'
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 中与 [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") 方法对应的方法是 ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 函数，可应用于实体，如 `User` 和 `Address`。这将在内部生成一个 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") 对象，针对原始映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，同时保持 ORM 功能。下面的 SELECT 从 `User` 实体中选择包含两个特定电子邮件地址的所有对象：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Tip
- en: 'As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).  ##
    Subqueries and CTEs'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [设置 ON 子句](#tutorial-select-join-onclause) 中提到的，ORM 提供了使用 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 结构进行连接的另一种方式。上述使用别名的示例是使用 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 在 [使用关系在别名目标之间进行连接](../orm/queryguide/select.html#tutorial-joining-relationships-aliased)
    中演示的。## 子查询和 CTE
- en: A subquery in SQL is a SELECT statement that is rendered within parenthesis
    and placed within the context of an enclosing statement, typically a SELECT statement
    but not necessarily.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 中的子查询是在括号内呈现并放置在封闭语句上下文中的 SELECT 语句，通常是 SELECT 语句，但不一定。
- en: This section will cover a so-called “non-scalar” subquery, which is typically
    placed in the FROM clause of an enclosing SELECT. We will also cover the Common
    Table Expression or CTE, which is used in a similar way as a subquery, but includes
    additional features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍所谓的“非标量”子查询，通常放置在封闭 SELECT 的 FROM 子句中。我们还将介绍通用表达式（Common Table Expression，CTE），它与子查询的使用方式类似，但包含其他功能。
- en: SQLAlchemy uses the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object to represent a subquery and the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") to represent a CTE, usually obtained from the
    [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") and [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods, respectively. Either object can
    be used as a FROM element inside of a larger [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 使用 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象表示子查询，使用 [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") 表示 CTE，通常分别从 [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") 和 [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") 方法获取。这两个对象都可以作为较大的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 结构中的 FROM 元素使用。
- en: 'We can construct a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") that will select an aggregate count of rows
    from the `address` table (aggregate functions and GROUP BY were introduced previously
    at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates)):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构造一个 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") ，将从 `address` 表中选择行的聚合计数（聚合函数和 GROUP BY
    在 [具有 GROUP BY / HAVING 的聚合函数](#tutorial-group-by-w-aggregates) 中已介绍）：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Stringifying the subquery by itself without it being embedded inside of another
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    or other statement produces the plain SELECT statement without any enclosing parenthesis:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单独将子查询字符串化，而不将其嵌入到另一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")或其他语句中，会生成不带任何封闭括号的普通SELECT语句：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object behaves like any other FROM object
    such as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    notably that it includes a `Subquery.c` namespace of the columns which it selects.
    We can use this namespace to refer to both the `user_id` column as well as our
    custom labeled `count` expression:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery "sqlalchemy.sql.expression.Subquery")对象的行为类似于任何其他FROM对象，例如[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，特别是它包含一个`Subquery.c`列的命名空间，该命名空间选择它。 我们可以使用此命名空间来引用`user_id`列以及我们的自定义标记的`count`表达式：'
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With a selection of rows contained within the `subq` object, we can apply the
    object to a larger [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that will join the data to the `user_account`
    table:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含在`subq`对象中的一系列行的选择，我们可以将该对象应用于一个更大的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")，将数据连接到`user_account`表：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In order to join from `user_account` to `address`, we made use of the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method. As has been illustrated
    previously, the ON clause of this join was again **inferred** based on foreign
    key constraints. Even though a SQL subquery does not itself have any constraints,
    SQLAlchemy can act upon constraints represented on the columns by determining
    that the `subq.c.user_id` column is **derived** from the `address_table.c.user_id`
    column, which does express a foreign key relationship back to the `user_table.c.id`
    column which is then used to generate the ON clause.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`user_account`连接到`address`，我们利用了[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法。 正如之前所说明的，此连接的ON子句再次基于外键约束**推断**。
    即使SQL子查询本身没有任何约束，SQLAlchemy也可以根据列上表示的约束来操作列，从而确定`subq.c.user_id`列**派生自**表达外键关系的`address_table.c.user_id`列，该列又表达了与`user_table.c.id`列的外键关系，然后用于生成ON子句。
- en: Common Table Expressions (CTEs)
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共表达式（CTEs）
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中使用[`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE")结构的用法与使用[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")结构几乎相同。 通过将[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery")方法的调用更改为使用[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte")而不是，我们可以像以前一样使用结果对象作为FROM元素，但是渲染的SQL是非常不同的常用表达式语法：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")结构还具有以“递归”方式使用的能力，并且在更复杂的情况下可以由INSERT、UPDATE或DELETE语句的RETURNING子句组成。
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")的文档字符串包含有关这些附加模式的详细信息。'
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '在这两种情况下，子查询和 CTE 在 SQL 层面上都被命名为“匿名”名称。在 Python 代码中，我们根本不需要提供这些名称。当渲染时，[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 或 [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") 实例的对象标识作为对象的语法标识。可以通过将其作为 [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") 或 [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") 方法的第一个参数来提供在 SQL 中呈现的名称。  '
- en: See also
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - 关于子查询的进一步细节'
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - 包括如何使用 RECURSIVE 以及面向 DML 的 CTE 的示例'
- en: '### ORM Entity Subqueries/CTEs'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM 实体子查询/CTEs'
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中，[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造可用于将 ORM 实体（例如我们的 `User` 或 `Address` 类）与表示行来源的任何 [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 概念相关联。前一节 [ORM 实体别名](#tutorial-orm-entity-aliases)
    演示了如何使用 [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    将映射类与其映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    相关联。在这里，我们演示了 [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 对一个 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 以及对一个由 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造生成的 [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") 执行相同操作，最终从相同的映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 派生。
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    应用到[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery "sqlalchemy.sql.expression.Subquery")
    构造的示例，以便从其行中提取ORM实体。结果显示了一系列`User`和`Address`对象，其中每个`Address`对象的数据最终来自于针对`address`表的子查询，而不是直接来自该表：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个例子，与之前的例子完全相同，只是它使用了[`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") 构造：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ## Scalar and Correlated
    Subqueries'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[从子查询中选择实体](../orm/queryguide/select.html#orm-queryguide-subqueries) - 在[ORM查询指南](../orm/queryguide/index.html)
    ## 标量和相关子查询'
- en: A scalar subquery is a subquery that returns exactly zero or one row and exactly
    one column. The subquery is then used in the COLUMNS or WHERE clause of an enclosing
    SELECT statement and is different than a regular subquery in that it is not used
    in the FROM clause. A [correlated subquery](../glossary.html#term-correlated-subquery)
    is a scalar subquery that refers to a table in the enclosing SELECT statement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标量子查询是一个返回零行或一行且一列的子查询。然后，该子查询在包含SELECT语句的COLUMNS或WHERE子句中使用，并且与常规子查询不同之处在于它不在FROM子句中使用。[相关子查询](../glossary.html#term-correlated-subquery)
    是指在包含SELECT语句中引用表的标量子查询。
- en: SQLAlchemy represents the scalar subquery using the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct, which is part of the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression hierarchy, in contrast to
    the regular subquery which is represented by the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, which is in the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") hierarchy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy使用[`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") 构造来表示标量子查询，该构造是[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 表达式层次结构的一部分，与常规子查询不同，常规子查询由[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 构造表示，该构造位于[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 层次结构中。
- en: 'Scalar subqueries are often, but not necessarily, used with aggregate functions,
    introduced previously at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates).
    A scalar subquery is indicated explicitly by making use of the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method as below. It’s default
    string form when stringified by itself renders as an ordinary SELECT statement
    that is selecting from two tables:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 标量子查询通常与聚合函数一起使用，但不一定要这样，之前在[带有 GROUP BY / HAVING 的聚合函数](#tutorial-group-by-w-aggregates)中介绍过。标量子查询通过显式使用[`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") 方法来指示。下面是一个示例，其默认的字符串形式在单独字符串化时呈现为从两个表中选择的普通SELECT语句：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The above `subq` object now falls within the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") SQL expression hierarchy, in that it
    may be used like any other column expression:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`subq`对象现在位于[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") SQL表达式层次结构中，因此它可以像任何其他列表达式一样使用：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Although the scalar subquery by itself renders both `user_account` and `address`
    in its FROM clause when stringified by itself, when embedding it into an enclosing
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct that deals with the `user_account` table, the `user_account` table is
    automatically **correlated**, meaning it does not render in the FROM clause of
    the subquery:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标量子查询本身在自身字符串化时在其 FROM 子句中呈现了`user_account`和`address`，但是，当将其嵌入到处理`user_account`表的封闭[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造中时，`user_account`表会自动**相关联**，这意味着它不会在子查询的
    FROM 子句中呈现：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Simple correlated subqueries will usually do the right thing that’s desired.
    However, in the case where the correlation is ambiguous, SQLAlchemy will let us
    know that more clarity is needed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的相关子查询通常会执行所需的正确操作。但是，在相关性不明确的情况下，SQLAlchemy 将通知我们需要更清晰：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To specify that the `user_table` is the one we seek to correlate we specify
    this using the [`ScalarSelect.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate
    "sqlalchemy.sql.expression.ScalarSelect.correlate") or [`ScalarSelect.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except
    "sqlalchemy.sql.expression.ScalarSelect.correlate_except") methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定`user_table`是我们要关联的表，我们使用[`ScalarSelect.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate
    "sqlalchemy.sql.expression.ScalarSelect.correlate")或[`ScalarSelect.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except
    "sqlalchemy.sql.expression.ScalarSelect.correlate_except")方法来指定：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The statement then can return the data for this column like any other:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该语句可以像处理其他列一样返回此列的数据：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '### LATERAL correlation'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '### LATERAL 相关性'
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: LATERAL 相关性是 SQL 相关性的一种特殊子类，它允许可选单元在单个 FROM 子句内引用另一个可选单元。这是一个极其特殊的用例，虽然是 SQL
    标准的一部分，但只有最近版本的 PostgreSQL 已知支持。
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果 SELECT 语句在其 FROM 子句中引用了`table1 JOIN (SELECT ...) AS subquery`，则右侧的子查询可能不会引用左侧的“table1”表达式；相关联可能只引用完全包围此
    SELECT 的另一个 SELECT 的表。LATERAL 关键字允许我们改变这种行为，允许来自右侧 JOIN 的相关联。
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 支持使用[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")方法实现此功能，该方法创建一个称为[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral")的对象。[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral")与[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")和[`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")位于同一家族，但在将构造添加到封闭 SELECT 的 FROM 子句时还包括相关联行为。以下示例说明了使用
    LATERAL 的 SQL 查询，选择“用户帐户/电子邮件地址计数”数据，如前一节所讨论的：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，JOIN 的右侧是一个子查询，它与左侧的`user_account`表相关联。
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")时，[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") 和 [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") 方法的行为也会应用于[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") 结构。
- en: See also
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")  ## UNION, UNION ALL and other set
    operations'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")  ## UNION、UNION ALL 和其他集合操作'
- en: In SQL, SELECT statements can be merged together using the UNION or UNION ALL
    SQL operation, which produces the set of all rows produced by one or more statements
    together. Other set operations such as INTERSECT [ALL] and EXCEPT [ALL] are also
    possible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，SELECT语句可以使用UNION或UNION ALL SQL操作合并在一起，它产生由一个或多个语句一起产生的所有行的集合。还可以进行其他集合操作，例如INTERSECT
    [ALL] 和 EXCEPT [ALL]。
- en: SQLAlchemy’s [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct supports compositions of this nature
    using functions like [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union"), [`intersect()`](../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and [`except_()`](../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), and the “all” counterparts [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"), [`intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.intersect_all
    "sqlalchemy.sql.expression.intersect_all") and [`except_all()`](../core/selectable.html#sqlalchemy.sql.expression.except_all
    "sqlalchemy.sql.expression.except_all"). These functions all accept an arbitrary
    number of sub-selectables, which are typically [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs but may also be an existing composition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 结构支持使用像[`union()`](../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union")、[`intersect()`](../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") 和 [`except_()`](../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_") 这样的函数进行此类组合，以及“all”对应项 [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all")、[`intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.intersect_all
    "sqlalchemy.sql.expression.intersect_all") 和 [`except_all()`](../core/selectable.html#sqlalchemy.sql.expression.except_all
    "sqlalchemy.sql.expression.except_all")。这些函数都接受任意数量的子可选择项，通常是[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 结构，但也可以是现有的组合。
- en: 'The construct produced by these functions is the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is used in the same manner
    as the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct, except that it has fewer methods. The [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") produced by [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") for example may be invoked directly using
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数生成的构造物是 [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect")，其使用方式与 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造物相同，只是方法较少。例如，由 [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 生成的 [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 可以直接使用 [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") 调用：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To use a [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") as a subquery, just like [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") it provides a [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method which will produce a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object with a [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection that may be referenced in
    an enclosing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 用作子查询，就像 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 一样，它提供了一个 [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") 方法，该方法将生成一个带有 [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") 集合的 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象，该集合可以在封闭的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 中引用：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '### Selecting ORM Entities from Unions'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从并集中选择 ORM 实体'
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子演示了如何构造一个 UNION，给定两个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，然后返回数据库行。如果我们想要使用 UNION 或其他集合操作来选择行，然后将其作为 ORM 对象接收，有两种方法可以使用。在这两种情况下，我们首先构造一个
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    或 [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 对象，该对象表示我们想要执行的 SELECT / UNION / 等语句；这个语句应该针对目标
    ORM 实体或它们的基础映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象组成：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的 SELECT 和 UNION，如果它还没有嵌套在子查询中，那么可以经常在 ORM 对象获取的上下文中使用[`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")方法。通过这种方法，UNION 语句表示整个查询；在使用[`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")之后，不能添加额外的条件：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要以更灵活的方式将 UNION 或其他集合相关的构造用作实体相关组件，可以使用[`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect")构造将其组织到一个子查询中，然后使用[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")函数将其链接到 ORM 对象。这与在[ORM 实体子查询/CTEs](#tutorial-subqueries-orm-aliased)中引入的方式相同，首先创建我们想要的实体到子查询的临时“映射”，然后从新实体中选择，就像它是任何其他映射类一样。在下面的示例中，我们可以添加额外的条件，比如在
    UNION 之外进行 ORDER BY，因为我们可以过滤或按子查询导出的列进行排序：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ## EXISTS subqueries'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[从 UNIONs 和其他集合操作中选择实体](../orm/queryguide/select.html#orm-queryguide-unions)
    - 在[ORM 查询指南](../orm/queryguide/index.html)中的 ## EXISTS 子查询'
- en: 'The SQL EXISTS keyword is an operator that is used with [scalar subqueries](#tutorial-scalar-subquery)
    to return a boolean true or false depending on if the SELECT statement would return
    a row. SQLAlchemy includes a variant of the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") object called [`Exists`](../core/selectable.html#sqlalchemy.sql.expression.Exists
    "sqlalchemy.sql.expression.Exists"), which will generate an EXISTS subquery and
    is most conveniently generated using the [`SelectBase.exists()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists
    "sqlalchemy.sql.expression.SelectBase.exists") method. Below we produce an EXISTS
    so that we can return `user_account` rows that have more than one related row
    in `address`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: SQL EXISTS 关键字是与[标量子查询](#tutorial-scalar-subquery)一起使用的运算符，根据 SELECT 语句是否返回行来返回布尔值
    true 或 false。SQLAlchemy 包含一个称为[`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect")的对象变体，它将生成一个 EXISTS 子查询，并且最方便地使用[`SelectBase.exists()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists
    "sqlalchemy.sql.expression.SelectBase.exists")方法生成。下面我们生成一个 EXISTS，以便我们可以返回`user_account`中有多个相关行的行：
- en: '[PRE56]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The EXISTS construct is more often than not used as a negation, e.g. NOT EXISTS,
    as it provides a SQL-efficient form of locating rows for which a related table
    has no rows. Below we select user names that have no email addresses; note the
    binary negation operator (`~`) used inside the second WHERE clause:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: EXISTS 构造更常用于否定，例如 NOT EXISTS，因为它提供了一种 SQL 效率高的形式来定位一个相关表没有行的行。下面我们选择没有电子邮件地址的用户名称；注意第二个
    WHERE 子句中使用的二进制否定运算符 (`~`)：
- en: '[PRE57]  ## Working with SQL Functions'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE57]  ## 使用 SQL 函数'
- en: 'First introduced earlier in this section at [Aggregate functions with GROUP
    BY / HAVING](#tutorial-group-by-w-aggregates), the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object serves as a factory for creating new
    [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects, which when used in a construct like [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), produce a SQL function display, typically
    consisting of a name, some parenthesis (although not always), and possibly some
    arguments. Examples of typical SQL functions include:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节早些时候介绍的 [带 GROUP BY / HAVING 的聚合函数](#tutorial-group-by-w-aggregates)，[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 对象充当创建新的 [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") 对象的工厂，当在像 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 这样的结构中使用时，会产生一个 SQL 函数显示，通常由名称、一些括号（虽然不总是），以及可能的一些参数组成。典型的
    SQL 函数示例包括：
- en: 'the `count()` function, an aggregate function which counts how many rows are
    returned:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()` 函数，计算返回的行数的聚合函数：'
- en: '[PRE58]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'the `lower()` function, a string function that converts a string to lower case:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower()` 函数，将字符串转换为小写的字符串函数：'
- en: '[PRE59]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'the `now()` function, which provides for the current date and time; as this
    is a common function, SQLAlchemy knows how to render this differently for each
    backend, in the case of SQLite using the CURRENT_TIMESTAMP function:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now()` 函数，提供当前日期和时间；由于这是一个常见的函数，SQLAlchemy 知道如何为每个后端呈现这个函数的不同表现形式，在 SQLite
    中使用 CURRENT_TIMESTAMP 函数：'
- en: '[PRE60]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As most database backends feature dozens if not hundreds of different SQL functions,
    [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    tries to be as liberal as possible in what it accepts. Any name that is accessed
    from this namespace is automatically considered to be a SQL function that will
    render in a generic way:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数数据库后端都具有几十甚至上百种不同的 SQL 函数，[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 尽可能宽松地接受任何输入。从这个命名空间访问的任何名称都自动被视为是一个 SQL 函数，将以一种通用的方式呈现：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'At the same time, a relatively small set of extremely common SQL functions
    such as [`count`](../core/functions.html#sqlalchemy.sql.functions.count "sqlalchemy.sql.functions.count"),
    [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now"),
    [`max`](../core/functions.html#sqlalchemy.sql.functions.max "sqlalchemy.sql.functions.max"),
    [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat "sqlalchemy.sql.functions.concat")
    include pre-packaged versions of themselves which provide for proper typing information
    as well as backend-specific SQL generation in some cases. The example below contrasts
    the SQL generation that occurs for the PostgreSQL dialect compared to the Oracle
    dialect for the [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，一组相对较小的极其常见的 SQL 函数，如[`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count")、[`now`](../core/functions.html#sqlalchemy.sql.functions.now
    "sqlalchemy.sql.functions.now")、[`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max")、[`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") 包括它们自己的预打包版本，这些版本提供了适当的类型信息，并在某些情况下提供特定于后端的
    SQL 生成。下面的示例对比了 PostgreSQL 方言和 Oracle 方言对 [`now`](../core/functions.html#sqlalchemy.sql.functions.now
    "sqlalchemy.sql.functions.now") 函数的 SQL 生成：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Functions Have Return Types
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数具有返回类型
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是列表达式，它们还有 SQL [数据类型](../core/types.html)，描述了生成的 SQL 表达式的数据类型。我们在这里将这些类型称为“SQL
    返回类型”，指的是在数据库端 SQL 表达式上下文中由函数返回的 SQL 值的类型，而不是 Python 函数的“返回类型”。
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 SQL 函数的 SQL 返回类型可以通过引用 `Function.type` 属性来访问，通常用于调试目的：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些SQL返回类型在将函数表达式用于更大表达式的上下文中时很重要；也就是说，数学运算符在表达式的数据类型为[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")或[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")之类时效果更佳，为了使JSON访问器能够工作，需要使用诸如[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")之类的类型。某些类别的函数返回整行而不是列值，需要引用特定列；这些函数被称为[table valued functions](#tutorial-functions-table-valued)。
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行语句并获取行时，函数的SQL返回类型也可能很重要，特别是对于那些SQLAlchemy必须应用结果集处理的情况。一个典型的例子是SQLite上的日期相关函数，其中SQLAlchemy的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")和相关数据类型在收到结果行时扮演了将字符串值转换为Python `datetime()`对象的角色。
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将特定类型应用于我们创建的函数，我们使用[`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function")参数传递它；类型参数可以是[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类或实例。在下面的示例中，我们传递[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")类以生成PostgreSQL的`json_object()`函数，注意SQL返回类型将是JSON类型：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用带有[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")数据类型的JSON函数，SQL表达式对象具有了与JSON相关的功能，例如访问元素：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Built-in Functions Have Pre-Configured Return Types
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数具有预配置的返回类型
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像[`count`](../core/functions.html#sqlalchemy.sql.functions.count "sqlalchemy.sql.functions.count")、[`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max")、[`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min")等常见的聚合函数，以及非常少数的日期函数，比如[`now`](../core/functions.html#sqlalchemy.sql.functions.now
    "sqlalchemy.sql.functions.now")和字符串函数，比如[`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat")，SQL返回类型将适当地设置，有时是基于用法。[`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max")函数和类似的聚合过滤函数将根据给定的参数设置SQL返回类型：
- en: '[PRE66]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间函数通常对应于由[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")、[`Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date")或[`Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time")描述的 SQL 表达式：
- en: '[PRE67]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 已知的字符串函数，如[`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat")，将知道 SQL 表达式的类型为[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")：
- en: '[PRE68]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于绝大多数 SQL 函数，SQLAlchemy 并没有将它们显式地列在已知函数的非常小的列表中。例如，虽然通常使用 SQL 函数 `func.lower()`
    和 `func.upper()` 来转换字符串的大小写没有问题，但 SQLAlchemy 实际上并不知道这些函数，因此它们具有“null”SQL 返回类型：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`upper`和`lower`这样的简单函数，通常情况下问题不是很严重，因为字符串值可以在没有任何特殊类型处理的情况下从数据库接收，而且 SQLAlchemy
    的类型转换规则通常也能够正确猜测意图；例如，Python 的`+`操作符会根据表达式的两边正确解释为字符串连接操作符：
- en: '[PRE70]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，[`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") 参数可能是必要的情况是：
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数不是 SQLAlchemy 的内置函数；这可以通过创建函数并观察`Function.type`属性来证明，即：
- en: '[PRE71]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'vs.:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与：
- en: '[PRE72]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要支持函数感知的表达式；这通常是指与诸如[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")或[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")之类的数据类型相关的特殊操作符
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要结果值处理，其中可能包括诸如`DateTime`、[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")、[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")或者再次是特殊的数据类型，如[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")、[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")。
- en: Advanced SQL Function Techniques
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级 SQL 函数技术
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节说明了可以使用 SQL 函数做的更多事情。虽然这些技术比基本的 SQL 函数使用更不常见且更高级，但它们仍然非常受欢迎，这在很大程度上是由于
    PostgreSQL 强调更复杂的函数形式，包括与 JSON 数据流行的表和列值形式。
- en: '#### Using Window Functions'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用窗口函数'
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数是 SQL 聚合函数的特殊用法，它在处理个别结果行时计算在一组中返回的行上的聚合值。而像 `MAX()` 这样的函数将为你提供一组行中的列的最高值，使用相同函数作为“窗口函数”将为你提供每行的最高值，*截至该行*。
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，窗口函数允许指定应该应用函数的行、一个考虑不同行子集的“分区”值以及一个重要的指示行应该应用到聚合函数的顺序的“order by”表达式。
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，由 [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 命名空间生成的所有 SQL 函数都包括一个 [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") 方法，它授予窗口函数或“OVER”语法；生成的结构是 [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") 结构。
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与窗口函数一起常用的函数是 `row_number()` 函数，它简单地计算行数。我们可以根据用户名对此行计数进行分区，以为个别用户的电子邮件地址编号：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中，使用了 [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") 参数，以使 `PARTITION BY` 子句在 OVER
    子句中呈现。我们还可以使用 [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over") 来使用 `ORDER BY` 子句：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数的更多选项包括使用范围；请参阅 [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") 以获取更多示例。
- en: Tip
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，[`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") 方法仅适用于那些实际上是聚合函数的 SQL 函数；虽然 [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") 结构会愉快地为任何给定的 SQL 函数渲染自己，但如果函数本身不是 SQL 聚合函数，数据库将拒绝该表达式。  ####
    特殊修饰符 WITHIN GROUP, FILTER'
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '"WITHIN GROUP" SQL 语法与“有序集合”或“假设集合”聚合函数一起使用。常见的“有序集合”函数包括`percentile_cont()`和`rank()`。SQLAlchemy
    包含内置实现[`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") 和 [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc")，其中包括一个 [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") 方法：'
- en: '[PRE75]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '"FILTER" 受一些后端支持，用于将聚合函数的范围限制为与返回的总行范围相比的特定子集，可使用 [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") 方法：'
- en: '[PRE76]  #### Table-Valued Functions'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE76]  #### 表值函数'
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表值 SQL 函数支持包含命名子元素的标量表示形式。通常用于 JSON 和 ARRAY 导向的函数以及像`generate_series()`这样的函数，表值函数在
    FROM 子句中指定，然后被引用为表，有时甚至作为列。这种形式的函数在 PostgreSQL 数据库中非常突出，但某些形式的表值函数也受 SQLite、Oracle
    和 SQL Server 支持。
- en: See also
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[表值、表和列值函数、行和元组对象](../dialects/postgresql.html#postgresql-table-valued-overview)
    - 在 [PostgreSQL](../dialects/postgresql.html) 文档中。'
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多数据库支持表值和其他特殊形式，但 PostgreSQL 往往是对这些功能需求最大的地方。请参阅本节，了解 PostgreSQL 语法的附加示例以及其他功能。
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.  ## Data Casts
    and Type Coercion'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, we often need to indicate the datatype of an expression explicitly,
    either to tell the database what type is expected in an otherwise ambiguous expression,
    or in some cases when we want to convert the implied datatype of a SQL expression
    into something else. The SQL CAST keyword is used for this task, which in SQLAlchemy
    is provided by the [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") function. This function accepts a column expression
    and a data type object as arguments, as demonstrated below where we produce a
    SQL expression `CAST(user_account.id AS VARCHAR)` from the `user_table.c.id` column
    object:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function not only renders the SQL CAST syntax, it also produces a SQLAlchemy column
    expression that will act as the given datatype on the Python side as well. A string
    expression that is [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will gain JSON subscript and comparison operators, for
    example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: type_coerce() - a Python-only “cast”
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The select() SQL Expression Construct
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct builds up a statement in the same way as that of [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), using a [generative](../glossary.html#term-generative)
    approach where each method builds more state onto the object. Like the other SQL
    constructs, it can be stringified in place:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Also in the same manner as all other statement-level SQL constructs, to actually
    run the statement we pass it to an execution method. Since a SELECT statement
    returns rows we can always iterate the result object to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects back:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When using the ORM, particularly with a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct that’s composed against ORM entities,
    we will want to execute it using the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); using this approach, we continue to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects from the result, however these rows are now capable
    of including complete entities, such as instances of the `User` class, as individual
    elements within each row:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The following sections will discuss the SELECT construct in more detail.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting the COLUMNS and FROM clause'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    function accepts positional elements representing any number of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and/or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") expressions, as well as a wide range of compatible
    objects, which are resolved into a list of SQL expressions to be SELECTed from
    that will be returned as columns in the result set. These elements also serve
    in simpler cases to create the FROM clause, which is inferred from the columns
    and table-like expressions passed:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To SELECT from individual columns using a Core approach, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are accessed from the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor and can be sent directly; the FROM clause
    will be inferred as the set of all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects that are represented by those
    columns:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Alternatively, when using the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection of any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), multiple columns may be specified for a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") by using a tuple of string names:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'New in version 2.0: Added tuple-accessor capability to the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting ORM Entities and Columns'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from Labeled SQL Expressions
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: See also
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting with Textual Column Expressions'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.  ### Selecting
    ORM Entities and Columns'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from Labeled SQL Expressions
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: See also
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting with Textual Column Expressions'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '## The WHERE clause'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy allows us to compose SQL expressions, such as `name = ''squidward''`
    or `user_id > 10`, by making use of standard Python operators in conjunction with
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and similar objects. For boolean expressions, most Python operators such as `==`,
    `!=`, `<`, `>=` etc. generate new SQL Expression objects, rather than plain boolean
    `True`/`False` values:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We can use expressions like these to generate the WHERE clause by passing the
    resulting objects to the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To produce multiple expressions joined by AND, the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method may be invoked any number of
    times:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'A single call to [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") also accepts multiple expressions with
    the same effect:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '“AND” and “OR” conjunctions are both available directly using the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") functions, illustrated below in terms of ORM
    entities:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For simple “equality” comparisons against a single entity, there’s also a popular
    method known as [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") which accepts keyword arguments
    that match to column keys or ORM attribute names. It will filter against the leftmost
    FROM clause or the last entity joined:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: See also
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[Operator Reference](../core/operators.html) - descriptions of most SQL operator
    functions in SQLAlchemy'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '## Explicit FROM clauses and JOINs'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the FROM clause is usually **inferred** based on the
    expressions that we are setting in the columns clause as well as other elements
    of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set a single column from a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the COLUMNS clause, it puts that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the FROM clause as well:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If we were to put columns from two tables, then we get a comma-separated FROM
    clause:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In order to JOIN these two tables together, we typically use one of two methods
    on [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
    The first is the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method, which allows us to indicate
    the left and right side of the JOIN explicitly:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The other is the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method, which indicates only the right
    side of the JOIN, the left hand-side is inferred:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We also have the option to add elements to the FROM clause explicitly, if it
    is not inferred the way we want from the columns clause. We use the [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method to achieve this, as below
    where we establish `user_table` as the first element in the FROM clause and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to establish `address_table` as the second:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Another example where we might want to use [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") is if our columns clause doesn’t
    have enough information to provide for a FROM clause. For example, to SELECT from
    the common SQL expression `count(*)`, we use a SQLAlchemy element known as [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to produce the SQL `count()` function:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: See also
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting the leftmost FROM clause in a join](../orm/queryguide/select.html#orm-queryguide-select-from)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) - contains additional
    examples and notes regarding the interaction of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting the ON Clause'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: OUTER and FULL join
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting the ON Clause'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: OUTER and FULL join
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '## ORDER BY, GROUP BY, HAVING'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT SQL statement includes a clause called ORDER BY which is used to
    return the selected rows within a given ordering.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The GROUP BY clause is constructed similarly to the ORDER BY clause, and has
    the purpose of sub-dividing the selected rows into specific groups upon which
    aggregate functions may be invoked. The HAVING clause is usually used with GROUP
    BY and is of a similar form to the WHERE clause, except that it’s applied to the
    aggregated functions used within groups.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '### ORDER BY'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.  ### Aggregate functions with GROUP BY / HAVING'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]  ### Ordering or Grouping by a Label'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]  ### ORDER BY'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregate functions with GROUP BY / HAVING'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '### Ordering or Grouping by a Label'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '## Using Aliases'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are selecting from multiple tables and using joins, we quickly run
    into the case where we need to refer to the same table multiple times in the FROM
    clause of a statement. We accomplish this using SQL **aliases**, which are a syntax
    that supplies an alternative name to a table or subquery from which it can be
    referenced in the statement.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'In the SQLAlchemy Expression Language, these “names” are instead represented
    by [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects known as the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct, which is constructed in Core using
    the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method. An [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct is just like a `Table` construct
    in that it also has a namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the `Alias.c` collection. The SELECT
    statement below for example returns all unique pairs of user names:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '### ORM Entity Aliases'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Tip
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).  ###
    ORM Entity Aliases'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Tip
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '## Subqueries and CTEs'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: A subquery in SQL is a SELECT statement that is rendered within parenthesis
    and placed within the context of an enclosing statement, typically a SELECT statement
    but not necessarily.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover a so-called “non-scalar” subquery, which is typically
    placed in the FROM clause of an enclosing SELECT. We will also cover the Common
    Table Expression or CTE, which is used in a similar way as a subquery, but includes
    additional features.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy uses the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object to represent a subquery and the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") to represent a CTE, usually obtained from the
    [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") and [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods, respectively. Either object can
    be used as a FROM element inside of a larger [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'We can construct a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") that will select an aggregate count of rows
    from the `address` table (aggregate functions and GROUP BY were introduced previously
    at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates)):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Stringifying the subquery by itself without it being embedded inside of another
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    or other statement produces the plain SELECT statement without any enclosing parenthesis:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object behaves like any other FROM object
    such as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    notably that it includes a `Subquery.c` namespace of the columns which it selects.
    We can use this namespace to refer to both the `user_id` column as well as our
    custom labeled `count` expression:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'With a selection of rows contained within the `subq` object, we can apply the
    object to a larger [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that will join the data to the `user_account`
    table:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In order to join from `user_account` to `address`, we made use of the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method. As has been illustrated
    previously, the ON clause of this join was again **inferred** based on foreign
    key constraints. Even though a SQL subquery does not itself have any constraints,
    SQLAlchemy can act upon constraints represented on the columns by determining
    that the `subq.c.user_id` column is **derived** from the `address_table.c.user_id`
    column, which does express a foreign key relationship back to the `user_table.c.id`
    column which is then used to generate the ON clause.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions (CTEs)
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Entity Subqueries/CTEs'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: See also
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions (CTEs)
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Entity Subqueries/CTEs'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: See also
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '## Scalar and Correlated Subqueries'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: A scalar subquery is a subquery that returns exactly zero or one row and exactly
    one column. The subquery is then used in the COLUMNS or WHERE clause of an enclosing
    SELECT statement and is different than a regular subquery in that it is not used
    in the FROM clause. A [correlated subquery](../glossary.html#term-correlated-subquery)
    is a scalar subquery that refers to a table in the enclosing SELECT statement.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy represents the scalar subquery using the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct, which is part of the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression hierarchy, in contrast to
    the regular subquery which is represented by the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, which is in the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") hierarchy.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar subqueries are often, but not necessarily, used with aggregate functions,
    introduced previously at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates).
    A scalar subquery is indicated explicitly by making use of the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method as below. It’s default
    string form when stringified by itself renders as an ordinary SELECT statement
    that is selecting from two tables:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The above `subq` object now falls within the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") SQL expression hierarchy, in that it
    may be used like any other column expression:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Although the scalar subquery by itself renders both `user_account` and `address`
    in its FROM clause when stringified by itself, when embedding it into an enclosing
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct that deals with the `user_account` table, the `user_account` table is
    automatically **correlated**, meaning it does not render in the FROM clause of
    the subquery:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Simple correlated subqueries will usually do the right thing that’s desired.
    However, in the case where the correlation is ambiguous, SQLAlchemy will let us
    know that more clarity is needed:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'To specify that the `user_table` is the one we seek to correlate we specify
    this using the [`ScalarSelect.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate
    "sqlalchemy.sql.expression.ScalarSelect.correlate") or [`ScalarSelect.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except
    "sqlalchemy.sql.expression.ScalarSelect.correlate_except") methods:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The statement then can return the data for this column like any other:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '### LATERAL correlation'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")  ### LATERAL correlation'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '## UNION, UNION ALL and other set operations'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, SELECT statements can be merged together using the UNION or UNION ALL
    SQL operation, which produces the set of all rows produced by one or more statements
    together. Other set operations such as INTERSECT [ALL] and EXCEPT [ALL] are also
    possible.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct supports compositions of this nature
    using functions like [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union"), [`intersect()`](../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and [`except_()`](../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), and the “all” counterparts [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"), [`intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.intersect_all
    "sqlalchemy.sql.expression.intersect_all") and [`except_all()`](../core/selectable.html#sqlalchemy.sql.expression.except_all
    "sqlalchemy.sql.expression.except_all"). These functions all accept an arbitrary
    number of sub-selectables, which are typically [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs but may also be an existing composition.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'The construct produced by these functions is the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is used in the same manner
    as the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct, except that it has fewer methods. The [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") produced by [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") for example may be invoked directly using
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'To use a [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") as a subquery, just like [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") it provides a [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method which will produce a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object with a [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection that may be referenced in
    an enclosing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '### Selecting ORM Entities from Unions'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: See also
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ### Selecting ORM
    Entities from Unions'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: See also
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '## EXISTS subqueries'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL EXISTS keyword is an operator that is used with [scalar subqueries](#tutorial-scalar-subquery)
    to return a boolean true or false depending on if the SELECT statement would return
    a row. SQLAlchemy includes a variant of the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") object called [`Exists`](../core/selectable.html#sqlalchemy.sql.expression.Exists
    "sqlalchemy.sql.expression.Exists"), which will generate an EXISTS subquery and
    is most conveniently generated using the [`SelectBase.exists()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists
    "sqlalchemy.sql.expression.SelectBase.exists") method. Below we produce an EXISTS
    so that we can return `user_account` rows that have more than one related row
    in `address`:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The EXISTS construct is more often than not used as a negation, e.g. NOT EXISTS,
    as it provides a SQL-efficient form of locating rows for which a related table
    has no rows. Below we select user names that have no email addresses; note the
    binary negation operator (`~`) used inside the second WHERE clause:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '## Working with SQL Functions'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'First introduced earlier in this section at [Aggregate functions with GROUP
    BY / HAVING](#tutorial-group-by-w-aggregates), the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object serves as a factory for creating new
    [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects, which when used in a construct like [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), produce a SQL function display, typically
    consisting of a name, some parenthesis (although not always), and possibly some
    arguments. Examples of typical SQL functions include:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'the `count()` function, an aggregate function which counts how many rows are
    returned:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'the `lower()` function, a string function that converts a string to lower case:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'the `now()` function, which provides for the current date and time; as this
    is a common function, SQLAlchemy knows how to render this differently for each
    backend, in the case of SQLite using the CURRENT_TIMESTAMP function:'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'As most database backends feature dozens if not hundreds of different SQL functions,
    [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    tries to be as liberal as possible in what it accepts. Any name that is accessed
    from this namespace is automatically considered to be a SQL function that will
    render in a generic way:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'At the same time, a relatively small set of extremely common SQL functions
    such as [`count`](../core/functions.html#sqlalchemy.sql.functions.count "sqlalchemy.sql.functions.count"),
    [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now"),
    [`max`](../core/functions.html#sqlalchemy.sql.functions.max "sqlalchemy.sql.functions.max"),
    [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat "sqlalchemy.sql.functions.concat")
    include pre-packaged versions of themselves which provide for proper typing information
    as well as backend-specific SQL generation in some cases. The example below contrasts
    the SQL generation that occurs for the PostgreSQL dialect compared to the Oracle
    dialect for the [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    function:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Functions Have Return Types
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Built-in Functions Have Pre-Configured Return Types
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'vs.:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced SQL Function Techniques
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Window Functions'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]  #### Table-Valued Functions'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: See also
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Functions Have Return Types
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Built-in Functions Have Pre-Configured Return Types
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'vs.:'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced SQL Function Techniques
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Window Functions'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]  #### Table-Valued Functions'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: See also
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.  #### Using
    Window Functions'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '#### Special Modifiers WITHIN GROUP, FILTER'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '#### Table-Valued Functions'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '#### Column Valued Functions - Table Valued Function as a Scalar Column'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: See also
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '## Data Casts and Type Coercion'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, we often need to indicate the datatype of an expression explicitly,
    either to tell the database what type is expected in an otherwise ambiguous expression,
    or in some cases when we want to convert the implied datatype of a SQL expression
    into something else. The SQL CAST keyword is used for this task, which in SQLAlchemy
    is provided by the [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") function. This function accepts a column expression
    and a data type object as arguments, as demonstrated below where we produce a
    SQL expression `CAST(user_account.id AS VARCHAR)` from the `user_table.c.id` column
    object:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'The [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function not only renders the SQL CAST syntax, it also produces a SQLAlchemy column
    expression that will act as the given datatype on the Python side as well. A string
    expression that is [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will gain JSON subscript and comparison operators, for
    example:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: type_coerce() - a Python-only “cast”
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: type_coerce() - a Python-only “cast”
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
