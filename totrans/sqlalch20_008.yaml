- en: Using SELECT Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/data_select.html](https://docs.sqlalchemy.org/en/20/tutorial/data_select.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For both Core and ORM, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function generates a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct which is used for all SELECT queries.
    Passed to methods like [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") in Core and [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in ORM, a SELECT statement is emitted in the
    current transaction and the result rows available via the returned [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**ORM Readers** - the content here applies equally well to both Core and ORM
    use and basic ORM variant use cases are mentioned here. However there are a lot
    more ORM-specific features available as well; these are documented at [ORM Querying
    Guide](../orm/queryguide/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The select() SQL Expression Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct builds up a statement in the same way as that of [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), using a [generative](../glossary.html#term-generative)
    approach where each method builds more state onto the object. Like the other SQL
    constructs, it can be stringified in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in the same manner as all other statement-level SQL constructs, to actually
    run the statement we pass it to an execution method. Since a SELECT statement
    returns rows we can always iterate the result object to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the ORM, particularly with a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct that’s composed against ORM entities,
    we will want to execute it using the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); using this approach, we continue to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects from the result, however these rows are now capable
    of including complete entities, such as instances of the `User` class, as individual
    elements within each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following sections will discuss the SELECT construct in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting the COLUMNS and FROM clause'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    function accepts positional elements representing any number of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and/or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") expressions, as well as a wide range of compatible
    objects, which are resolved into a list of SQL expressions to be SELECTed from
    that will be returned as columns in the result set. These elements also serve
    in simpler cases to create the FROM clause, which is inferred from the columns
    and table-like expressions passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To SELECT from individual columns using a Core approach, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are accessed from the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor and can be sent directly; the FROM clause
    will be inferred as the set of all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects that are represented by those
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, when using the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection of any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), multiple columns may be specified for a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") by using a tuple of string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added tuple-accessor capability to the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection'
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting ORM Entities and Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from Labeled SQL Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting with Textual Column Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.  ## The WHERE clause'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy allows us to compose SQL expressions, such as `name = ''squidward''`
    or `user_id > 10`, by making use of standard Python operators in conjunction with
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and similar objects. For boolean expressions, most Python operators such as `==`,
    `!=`, `<`, `>=` etc. generate new SQL Expression objects, rather than plain boolean
    `True`/`False` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use expressions like these to generate the WHERE clause by passing the
    resulting objects to the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce multiple expressions joined by AND, the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method may be invoked any number of
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A single call to [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") also accepts multiple expressions with
    the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '“AND” and “OR” conjunctions are both available directly using the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") functions, illustrated below in terms of ORM
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple “equality” comparisons against a single entity, there’s also a popular
    method known as [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") which accepts keyword arguments
    that match to column keys or ORM attribute names. It will filter against the leftmost
    FROM clause or the last entity joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Operator Reference](../core/operators.html) - descriptions of most SQL operator
    functions in SQLAlchemy  ## Explicit FROM clauses and JOINs'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the FROM clause is usually **inferred** based on the
    expressions that we are setting in the columns clause as well as other elements
    of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set a single column from a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the COLUMNS clause, it puts that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the FROM clause as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to put columns from two tables, then we get a comma-separated FROM
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to JOIN these two tables together, we typically use one of two methods
    on [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
    The first is the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method, which allows us to indicate
    the left and right side of the JOIN explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The other is the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method, which indicates only the right
    side of the JOIN, the left hand-side is inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the option to add elements to the FROM clause explicitly, if it
    is not inferred the way we want from the columns clause. We use the [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method to achieve this, as below
    where we establish `user_table` as the first element in the FROM clause and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to establish `address_table` as the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example where we might want to use [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") is if our columns clause doesn’t
    have enough information to provide for a FROM clause. For example, to SELECT from
    the common SQL expression `count(*)`, we use a SQLAlchemy element known as [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to produce the SQL `count()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting the leftmost FROM clause in a join](../orm/queryguide/select.html#orm-queryguide-select-from)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) - contains additional
    examples and notes regarding the interaction of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting the ON Clause'
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  prefs: []
  type: TYPE_NORMAL
- en: OUTER and FULL join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.  ## ORDER
    BY, GROUP BY, HAVING'
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT SQL statement includes a clause called ORDER BY which is used to
    return the selected rows within a given ordering.
  prefs: []
  type: TYPE_NORMAL
- en: The GROUP BY clause is constructed similarly to the ORDER BY clause, and has
    the purpose of sub-dividing the selected rows into specific groups upon which
    aggregate functions may be invoked. The HAVING clause is usually used with GROUP
    BY and is of a similar form to the WHERE clause, except that it’s applied to the
    aggregated functions used within groups.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.  ### Aggregate functions with GROUP BY / HAVING'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  prefs: []
  type: TYPE_NORMAL
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]  ### Ordering or Grouping by a Label'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]  ## Using Aliases'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are selecting from multiple tables and using joins, we quickly run
    into the case where we need to refer to the same table multiple times in the FROM
    clause of a statement. We accomplish this using SQL **aliases**, which are a syntax
    that supplies an alternative name to a table or subquery from which it can be
    referenced in the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the SQLAlchemy Expression Language, these “names” are instead represented
    by [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects known as the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct, which is constructed in Core using
    the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method. An [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct is just like a `Table` construct
    in that it also has a namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the `Alias.c` collection. The SELECT
    statement below for example returns all unique pairs of user names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '### ORM Entity Aliases'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).  ##
    Subqueries and CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: A subquery in SQL is a SELECT statement that is rendered within parenthesis
    and placed within the context of an enclosing statement, typically a SELECT statement
    but not necessarily.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover a so-called “non-scalar” subquery, which is typically
    placed in the FROM clause of an enclosing SELECT. We will also cover the Common
    Table Expression or CTE, which is used in a similar way as a subquery, but includes
    additional features.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy uses the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object to represent a subquery and the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") to represent a CTE, usually obtained from the
    [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") and [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods, respectively. Either object can
    be used as a FROM element inside of a larger [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can construct a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") that will select an aggregate count of rows
    from the `address` table (aggregate functions and GROUP BY were introduced previously
    at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Stringifying the subquery by itself without it being embedded inside of another
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    or other statement produces the plain SELECT statement without any enclosing parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object behaves like any other FROM object
    such as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    notably that it includes a `Subquery.c` namespace of the columns which it selects.
    We can use this namespace to refer to both the `user_id` column as well as our
    custom labeled `count` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With a selection of rows contained within the `subq` object, we can apply the
    object to a larger [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that will join the data to the `user_account`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In order to join from `user_account` to `address`, we made use of the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method. As has been illustrated
    previously, the ON clause of this join was again **inferred** based on foreign
    key constraints. Even though a SQL subquery does not itself have any constraints,
    SQLAlchemy can act upon constraints represented on the columns by determining
    that the `subq.c.user_id` column is **derived** from the `address_table.c.user_id`
    column, which does express a foreign key relationship back to the `user_table.c.id`
    column which is then used to generate the ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions (CTEs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Entity Subqueries/CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ## Scalar and Correlated
    Subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: A scalar subquery is a subquery that returns exactly zero or one row and exactly
    one column. The subquery is then used in the COLUMNS or WHERE clause of an enclosing
    SELECT statement and is different than a regular subquery in that it is not used
    in the FROM clause. A [correlated subquery](../glossary.html#term-correlated-subquery)
    is a scalar subquery that refers to a table in the enclosing SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy represents the scalar subquery using the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct, which is part of the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression hierarchy, in contrast to
    the regular subquery which is represented by the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, which is in the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar subqueries are often, but not necessarily, used with aggregate functions,
    introduced previously at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates).
    A scalar subquery is indicated explicitly by making use of the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method as below. It’s default
    string form when stringified by itself renders as an ordinary SELECT statement
    that is selecting from two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `subq` object now falls within the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") SQL expression hierarchy, in that it
    may be used like any other column expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the scalar subquery by itself renders both `user_account` and `address`
    in its FROM clause when stringified by itself, when embedding it into an enclosing
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct that deals with the `user_account` table, the `user_account` table is
    automatically **correlated**, meaning it does not render in the FROM clause of
    the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple correlated subqueries will usually do the right thing that’s desired.
    However, in the case where the correlation is ambiguous, SQLAlchemy will let us
    know that more clarity is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify that the `user_table` is the one we seek to correlate we specify
    this using the [`ScalarSelect.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate
    "sqlalchemy.sql.expression.ScalarSelect.correlate") or [`ScalarSelect.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except
    "sqlalchemy.sql.expression.ScalarSelect.correlate_except") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement then can return the data for this column like any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '### LATERAL correlation'
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  prefs: []
  type: TYPE_NORMAL
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")  ## UNION, UNION ALL and other set
    operations'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, SELECT statements can be merged together using the UNION or UNION ALL
    SQL operation, which produces the set of all rows produced by one or more statements
    together. Other set operations such as INTERSECT [ALL] and EXCEPT [ALL] are also
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct supports compositions of this nature
    using functions like [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union"), [`intersect()`](../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and [`except_()`](../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), and the “all” counterparts [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"), [`intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.intersect_all
    "sqlalchemy.sql.expression.intersect_all") and [`except_all()`](../core/selectable.html#sqlalchemy.sql.expression.except_all
    "sqlalchemy.sql.expression.except_all"). These functions all accept an arbitrary
    number of sub-selectables, which are typically [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs but may also be an existing composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The construct produced by these functions is the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is used in the same manner
    as the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct, except that it has fewer methods. The [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") produced by [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") for example may be invoked directly using
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") as a subquery, just like [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") it provides a [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method which will produce a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object with a [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection that may be referenced in
    an enclosing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '### Selecting ORM Entities from Unions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ## EXISTS subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL EXISTS keyword is an operator that is used with [scalar subqueries](#tutorial-scalar-subquery)
    to return a boolean true or false depending on if the SELECT statement would return
    a row. SQLAlchemy includes a variant of the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") object called [`Exists`](../core/selectable.html#sqlalchemy.sql.expression.Exists
    "sqlalchemy.sql.expression.Exists"), which will generate an EXISTS subquery and
    is most conveniently generated using the [`SelectBase.exists()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists
    "sqlalchemy.sql.expression.SelectBase.exists") method. Below we produce an EXISTS
    so that we can return `user_account` rows that have more than one related row
    in `address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The EXISTS construct is more often than not used as a negation, e.g. NOT EXISTS,
    as it provides a SQL-efficient form of locating rows for which a related table
    has no rows. Below we select user names that have no email addresses; note the
    binary negation operator (`~`) used inside the second WHERE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]  ## Working with SQL Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'First introduced earlier in this section at [Aggregate functions with GROUP
    BY / HAVING](#tutorial-group-by-w-aggregates), the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object serves as a factory for creating new
    [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects, which when used in a construct like [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), produce a SQL function display, typically
    consisting of a name, some parenthesis (although not always), and possibly some
    arguments. Examples of typical SQL functions include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the `count()` function, an aggregate function which counts how many rows are
    returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'the `lower()` function, a string function that converts a string to lower case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'the `now()` function, which provides for the current date and time; as this
    is a common function, SQLAlchemy knows how to render this differently for each
    backend, in the case of SQLite using the CURRENT_TIMESTAMP function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As most database backends feature dozens if not hundreds of different SQL functions,
    [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    tries to be as liberal as possible in what it accepts. Any name that is accessed
    from this namespace is automatically considered to be a SQL function that will
    render in a generic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, a relatively small set of extremely common SQL functions
    such as [`count`](../core/functions.html#sqlalchemy.sql.functions.count "sqlalchemy.sql.functions.count"),
    [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now"),
    [`max`](../core/functions.html#sqlalchemy.sql.functions.max "sqlalchemy.sql.functions.max"),
    [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat "sqlalchemy.sql.functions.concat")
    include pre-packaged versions of themselves which provide for proper typing information
    as well as backend-specific SQL generation in some cases. The example below contrasts
    the SQL generation that occurs for the PostgreSQL dialect compared to the Oracle
    dialect for the [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Functions Have Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  prefs: []
  type: TYPE_NORMAL
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Built-in Functions Have Pre-Configured Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'vs.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced SQL Function Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]  #### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.  ## Data Casts
    and Type Coercion'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, we often need to indicate the datatype of an expression explicitly,
    either to tell the database what type is expected in an otherwise ambiguous expression,
    or in some cases when we want to convert the implied datatype of a SQL expression
    into something else. The SQL CAST keyword is used for this task, which in SQLAlchemy
    is provided by the [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") function. This function accepts a column expression
    and a data type object as arguments, as demonstrated below where we produce a
    SQL expression `CAST(user_account.id AS VARCHAR)` from the `user_table.c.id` column
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function not only renders the SQL CAST syntax, it also produces a SQLAlchemy column
    expression that will act as the given datatype on the Python side as well. A string
    expression that is [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will gain JSON subscript and comparison operators, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: type_coerce() - a Python-only “cast”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The select() SQL Expression Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct builds up a statement in the same way as that of [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), using a [generative](../glossary.html#term-generative)
    approach where each method builds more state onto the object. Like the other SQL
    constructs, it can be stringified in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in the same manner as all other statement-level SQL constructs, to actually
    run the statement we pass it to an execution method. Since a SELECT statement
    returns rows we can always iterate the result object to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the ORM, particularly with a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct that’s composed against ORM entities,
    we will want to execute it using the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); using this approach, we continue to get [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects from the result, however these rows are now capable
    of including complete entities, such as instances of the `User` class, as individual
    elements within each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The following sections will discuss the SELECT construct in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting the COLUMNS and FROM clause'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    function accepts positional elements representing any number of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and/or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") expressions, as well as a wide range of compatible
    objects, which are resolved into a list of SQL expressions to be SELECTed from
    that will be returned as columns in the result set. These elements also serve
    in simpler cases to create the FROM clause, which is inferred from the columns
    and table-like expressions passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To SELECT from individual columns using a Core approach, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are accessed from the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor and can be sent directly; the FROM clause
    will be inferred as the set of all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects that are represented by those
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, when using the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection of any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), multiple columns may be specified for a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") by using a tuple of string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added tuple-accessor capability to the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection'
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting ORM Entities and Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from Labeled SQL Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting with Textual Column Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.  ### Selecting
    ORM Entities and Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM entities, such our `User` class as well as the column-mapped attributes
    upon it such as `User.name`, also participate in the SQL Expression Language system
    representing tables and columns. Below illustrates an example of SELECTing from
    the `User` entity, which ultimately renders in the same way as if we had used
    `user_table` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing a statement like the above using the ORM [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, there is an important difference when
    we select from a full entity such as `User`, as opposed to `user_table`, which
    is that the **entity itself is returned as a single element within each row**.
    That is, when we fetch rows from the above statement, as there is only the `User`
    entity in the list of things to fetch, we get back [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have only one element, which contain instances
    of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    has just one element, representing the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'A highly recommended convenience method of achieving the same result as above
    is to use the [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute the statement directly; this
    method will return a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object that delivers the first “column” of each
    row at once, in this case, instances of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can select individual columns of an ORM entity as distinct
    elements within result rows, by using the class-bound attributes; when these are
    passed to a construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), they are resolved into the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression represented by each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke *this* statement using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), we now receive rows that have individual elements
    per value, each corresponding to a separate column or other SQL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The approaches can also be mixed, as below where we SELECT the `name` attribute
    of the `User` entity as the first element of the row, and combine it with full
    `Address` entities in the second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Approaches towards selecting ORM entities and columns as well as common methods
    for converting rows are discussed further at [Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting ORM Entities and Attributes](../orm/queryguide/select.html#orm-queryguide-select-columns)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from Labeled SQL Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method as well as the same-named
    method available on ORM attributes provides a SQL label of a column or expression,
    allowing it to have a specific name in a result set. This can be helpful when
    referring to arbitrary SQL expressions in a result row by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Ordering or Grouping by a Label](#tutorial-order-by-label) - the label names
    we create may also be referenced in the ORDER BY or GROUP BY clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting with Textual Column Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: When we construct a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, we are normally passing to it a
    series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects that were defined using [table metadata](metadata.html#tutorial-working-with-metadata),
    or when using the ORM we may be sending ORM-mapped attributes that represent table
    columns. However, sometimes there is also the need to manufacture arbitrary SQL
    blocks inside of statements, such as constant string expressions, or just some
    arbitrary SQL that’s quicker to write literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct introduced at [Working with Transactions and the DBAPI](dbapi_transactions.html#tutorial-working-with-transactions)
    can in fact be embedded into a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct directly, such as below where we
    manufacture a hardcoded string literal `''some phrase''` and embed it within the
    SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'While the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be used in most places to inject
    literal SQL phrases, more often than not we are actually dealing with textual
    units that each represent an individual column expression. In this common case
    we can get more functionality out of our textual fragment using the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct instead. This object is
    similar to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    except that instead of representing arbitrary SQL of any form, it explicitly represents
    a single “column” and can then be labeled and referred towards in subqueries and
    other expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Note that in both cases, when using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column"), we are writing a syntactical SQL
    expression, and not a literal value. We therefore have to include whatever quoting
    or syntaxes are necessary for the SQL we want to see rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '## The WHERE clause'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy allows us to compose SQL expressions, such as `name = ''squidward''`
    or `user_id > 10`, by making use of standard Python operators in conjunction with
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and similar objects. For boolean expressions, most Python operators such as `==`,
    `!=`, `<`, `>=` etc. generate new SQL Expression objects, rather than plain boolean
    `True`/`False` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use expressions like these to generate the WHERE clause by passing the
    resulting objects to the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce multiple expressions joined by AND, the [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method may be invoked any number of
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'A single call to [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") also accepts multiple expressions with
    the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '“AND” and “OR” conjunctions are both available directly using the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") functions, illustrated below in terms of ORM
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple “equality” comparisons against a single entity, there’s also a popular
    method known as [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") which accepts keyword arguments
    that match to column keys or ORM attribute names. It will filter against the leftmost
    FROM clause or the last entity joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Operator Reference](../core/operators.html) - descriptions of most SQL operator
    functions in SQLAlchemy'
  prefs: []
  type: TYPE_NORMAL
- en: '## Explicit FROM clauses and JOINs'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the FROM clause is usually **inferred** based on the
    expressions that we are setting in the columns clause as well as other elements
    of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set a single column from a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the COLUMNS clause, it puts that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") in the FROM clause as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to put columns from two tables, then we get a comma-separated FROM
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to JOIN these two tables together, we typically use one of two methods
    on [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select").
    The first is the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method, which allows us to indicate
    the left and right side of the JOIN explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The other is the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method, which indicates only the right
    side of the JOIN, the left hand-side is inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the option to add elements to the FROM clause explicitly, if it
    is not inferred the way we want from the columns clause. We use the [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method to achieve this, as below
    where we establish `user_table` as the first element in the FROM clause and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to establish `address_table` as the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example where we might want to use [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") is if our columns clause doesn’t
    have enough information to provide for a FROM clause. For example, to SELECT from
    the common SQL expression `count(*)`, we use a SQLAlchemy element known as [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to produce the SQL `count()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting the leftmost FROM clause in a join](../orm/queryguide/select.html#orm-queryguide-select-from)
    - in the [ORM Querying Guide](../orm/queryguide/index.html) - contains additional
    examples and notes regarding the interaction of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") and [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting the ON Clause'
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  prefs: []
  type: TYPE_NORMAL
- en: OUTER and FULL join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting the ON Clause'
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples of JOIN illustrated that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct can join between two tables and
    produce the ON clause automatically. This occurs in those examples because the
    `user_table` and `address_table` `Table` objects include a single [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") definition which is used to form this
    ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the left and right targets of the join do not have such a constraint, or
    there are multiple constraints in place, we need to specify the ON clause directly.
    Both [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") accept an additional argument for
    the ON clause, which is stated using the same SQL Expression mechanics as we saw
    about in [The WHERE clause](#tutorial-select-where-clause):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '**ORM Tip** - there’s another way to generate the ON clause when using ORM
    entities that make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, like the mapping set up in the previous
    section at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    This is a whole subject onto itself, which is introduced at length at [Using Relationships
    to Join](orm_related_objects.html#tutorial-joining-relationships).'
  prefs: []
  type: TYPE_NORMAL
- en: OUTER and FULL join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods accept keyword arguments
    [`Select.join.isouter`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter
    "sqlalchemy.sql.expression.Select.join") and [`Select.join.full`](../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full
    "sqlalchemy.sql.expression.Select.join") which will render LEFT OUTER JOIN and
    FULL OUTER JOIN, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There is also a method [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") that is equivalent to using `.join(...,
    isouter=True)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: SQL also has a “RIGHT OUTER JOIN”. SQLAlchemy doesn’t render this directly;
    instead, reverse the order of the tables and use “LEFT OUTER JOIN”.
  prefs: []
  type: TYPE_NORMAL
- en: '## ORDER BY, GROUP BY, HAVING'
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT SQL statement includes a clause called ORDER BY which is used to
    return the selected rows within a given ordering.
  prefs: []
  type: TYPE_NORMAL
- en: The GROUP BY clause is constructed similarly to the ORDER BY clause, and has
    the purpose of sub-dividing the selected rows into specific groups upon which
    aggregate functions may be invoked. The HAVING clause is usually used with GROUP
    BY and is of a similar form to the WHERE clause, except that it’s applied to the
    aggregated functions used within groups.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.  ### Aggregate functions with GROUP BY / HAVING'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  prefs: []
  type: TYPE_NORMAL
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]  ### Ordering or Grouping by a Label'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]  ### ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORDER BY clause is constructed in terms of SQL Expression constructs typically
    based on [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or similar objects. The [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") method accepts one or more of these
    expressions positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Ascending / descending is available from the [`ColumnElement.asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") and [`ColumnElement.desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifiers, which are present from
    ORM-bound attributes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The above statement will yield rows that are sorted by the `user_account.fullname`
    column in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregate functions with GROUP BY / HAVING'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, aggregate functions allow column expressions across multiple rows to
    be aggregated together to produce a single result. Examples include counting,
    computing averages, as well as locating the maximum or minimum value in a set
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for SQL functions in an open-ended way using a namespace
    known as [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    This is a special constructor object which will create new instances of [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") when given the name of a particular SQL function,
    which can have any name, as well as zero or more arguments to pass to the function,
    which are, like in all other cases, SQL Expression constructs. For example, to
    render the SQL COUNT() function against the `user_account.id` column, we call
    upon the `count()` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: SQL functions are described in more detail later in this tutorial at [Working
    with SQL Functions](#tutorial-functions).
  prefs: []
  type: TYPE_NORMAL
- en: When using aggregate functions in SQL, the GROUP BY clause is essential in that
    it allows rows to be partitioned into groups where aggregate functions will be
    applied to each group individually. When requesting non-aggregated columns in
    the COLUMNS clause of a SELECT statement, SQL requires that these columns all
    be subject to a GROUP BY clause, either directly or indirectly based on a primary
    key association. The HAVING clause is then used in a similar manner as the WHERE
    clause, except that it filters out rows based on aggregated values rather than
    direct row contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides for these two clauses using the [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") and [`Select.having()`](../core/selectable.html#sqlalchemy.sql.expression.Select.having
    "sqlalchemy.sql.expression.Select.having") methods. Below we illustrate selecting
    user name fields as well as count of addresses, for those users that have more
    than one address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '### Ordering or Grouping by a Label'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique, in particular on some database backends, is the ability
    to ORDER BY or GROUP BY an expression that is already stated in the columns clause,
    without re-stating the expression in the ORDER BY or GROUP BY clause and instead
    using the column name or labeled name from the COLUMNS clause. This form is available
    by passing the string text of the name to the [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") or [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") method. The text passed is **not
    rendered directly**; instead, the name given to an expression in the columns clause
    and rendered as that expression name in context, raising an error if no match
    is found. The unary modifiers [`asc()`](../core/sqlelement.html#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") and [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") may also be used in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '## Using Aliases'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are selecting from multiple tables and using joins, we quickly run
    into the case where we need to refer to the same table multiple times in the FROM
    clause of a statement. We accomplish this using SQL **aliases**, which are a syntax
    that supplies an alternative name to a table or subquery from which it can be
    referenced in the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the SQLAlchemy Expression Language, these “names” are instead represented
    by [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects known as the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct, which is constructed in Core using
    the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method. An [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") construct is just like a `Table` construct
    in that it also has a namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the `Alias.c` collection. The SELECT
    statement below for example returns all unique pairs of user names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '### ORM Entity Aliases'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).  ###
    ORM Entity Aliases'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM equivalent of the [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias
    "sqlalchemy.sql.expression.FromClause.alias") method is the ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function, which may be applied to an entity such as
    `User` and `Address`. This produces a [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object internally that’s against the original
    mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, while maintaining ORM functionality. The SELECT below selects from the
    `User` entity all objects that include two particular email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Setting the ON Clause](#tutorial-select-join-onclause), the
    ORM provides for another way to join using the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. The above example using aliases is demonstrated
    using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") at [Using Relationship to join between aliased
    targets](../orm/queryguide/select.html#tutorial-joining-relationships-aliased).
  prefs: []
  type: TYPE_NORMAL
- en: '## Subqueries and CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: A subquery in SQL is a SELECT statement that is rendered within parenthesis
    and placed within the context of an enclosing statement, typically a SELECT statement
    but not necessarily.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover a so-called “non-scalar” subquery, which is typically
    placed in the FROM clause of an enclosing SELECT. We will also cover the Common
    Table Expression or CTE, which is used in a similar way as a subquery, but includes
    additional features.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy uses the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object to represent a subquery and the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") to represent a CTE, usually obtained from the
    [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") and [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods, respectively. Either object can
    be used as a FROM element inside of a larger [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can construct a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") that will select an aggregate count of rows
    from the `address` table (aggregate functions and GROUP BY were introduced previously
    at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Stringifying the subquery by itself without it being embedded inside of another
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    or other statement produces the plain SELECT statement without any enclosing parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object behaves like any other FROM object
    such as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    notably that it includes a `Subquery.c` namespace of the columns which it selects.
    We can use this namespace to refer to both the `user_id` column as well as our
    custom labeled `count` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'With a selection of rows contained within the `subq` object, we can apply the
    object to a larger [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that will join the data to the `user_account`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: In order to join from `user_account` to `address`, we made use of the [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method. As has been illustrated
    previously, the ON clause of this join was again **inferred** based on foreign
    key constraints. Even though a SQL subquery does not itself have any constraints,
    SQLAlchemy can act upon constraints represented on the columns by determining
    that the `subq.c.user_id` column is **derived** from the `address_table.c.user_id`
    column, which does express a foreign key relationship back to the `user_table.c.id`
    column which is then used to generate the ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions (CTEs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Entity Subqueries/CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions (CTEs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usage of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct in SQLAlchemy is virtually the same
    as how the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct is used. By changing the invocation
    of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") method to use [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") instead, we can use the resulting object
    as a FROM element in the same way, but the SQL rendered is the very different
    common table expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct also features the ability to be used in a “recursive” style, and may
    in more elaborate cases be composed from the RETURNING clause of an INSERT, UPDATE
    or DELETE statement. The docstring for [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") includes details on these additional patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the subquery and CTE were named at the SQL level using an “anonymous”
    name. In the Python code, we don’t need to provide these names at all. The object
    identity of the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") or [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") instances serves as the syntactical identity
    of the object when rendered. A name that will be rendered in the SQL can be provided
    by passing it as the first argument of the [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") or [`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") - further detail on subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.cte()`](../core/selectable.html#sqlalchemy.sql.expression.Select.cte
    "sqlalchemy.sql.expression.Select.cte") - examples for CTE including how to use
    RECURSIVE as well as DML-oriented CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Entity Subqueries/CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: In the ORM, the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct may be used to associate an ORM entity, such
    as our `User` or `Address` class, with any [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") concept that represents a source of rows.
    The preceding section [ORM Entity Aliases](#tutorial-orm-entity-aliases) illustrates
    using [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    to associate the mapped class with an [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") of its mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Here we illustrate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") doing the same thing against both a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") as well as a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") generated against a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, that ultimately derives from that
    same mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of applying [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") to the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, so that ORM entities can be extracted
    from its rows. The result shows a series of `User` and `Address` objects, where
    the data for each `Address` object ultimately came from a subquery against the
    `address` table rather than that table directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example follows, which is exactly the same except it makes use of the
    [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE "sqlalchemy.sql.expression.CTE")
    construct instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from Subqueries](../orm/queryguide/select.html#orm-queryguide-subqueries)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Scalar and Correlated Subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: A scalar subquery is a subquery that returns exactly zero or one row and exactly
    one column. The subquery is then used in the COLUMNS or WHERE clause of an enclosing
    SELECT statement and is different than a regular subquery in that it is not used
    in the FROM clause. A [correlated subquery](../glossary.html#term-correlated-subquery)
    is a scalar subquery that refers to a table in the enclosing SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy represents the scalar subquery using the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct, which is part of the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression hierarchy, in contrast to
    the regular subquery which is represented by the [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") construct, which is in the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar subqueries are often, but not necessarily, used with aggregate functions,
    introduced previously at [Aggregate functions with GROUP BY / HAVING](#tutorial-group-by-w-aggregates).
    A scalar subquery is indicated explicitly by making use of the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method as below. It’s default
    string form when stringified by itself renders as an ordinary SELECT statement
    that is selecting from two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `subq` object now falls within the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") SQL expression hierarchy, in that it
    may be used like any other column expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the scalar subquery by itself renders both `user_account` and `address`
    in its FROM clause when stringified by itself, when embedding it into an enclosing
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct that deals with the `user_account` table, the `user_account` table is
    automatically **correlated**, meaning it does not render in the FROM clause of
    the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple correlated subqueries will usually do the right thing that’s desired.
    However, in the case where the correlation is ambiguous, SQLAlchemy will let us
    know that more clarity is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify that the `user_table` is the one we seek to correlate we specify
    this using the [`ScalarSelect.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate
    "sqlalchemy.sql.expression.ScalarSelect.correlate") or [`ScalarSelect.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except
    "sqlalchemy.sql.expression.ScalarSelect.correlate_except") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement then can return the data for this column like any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '### LATERAL correlation'
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  prefs: []
  type: TYPE_NORMAL
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")  ### LATERAL correlation'
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL correlation is a special sub-category of SQL correlation which allows
    a selectable unit to refer to another selectable unit within a single FROM clause.
    This is an extremely special use case which, while part of the SQL standard, is
    only known to be supported by recent versions of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, if a SELECT statement refers to `table1 JOIN (SELECT ...) AS subquery`
    in its FROM clause, the subquery on the right side may not refer to the “table1”
    expression from the left side; correlation may only refer to a table that is part
    of another SELECT that entirely encloses this SELECT. The LATERAL keyword allows
    us to turn this behavior around and allow correlation from the right side JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports this feature using the [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") method, which creates an object known
    as [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral").
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    is in the same family as [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias"), but also includes correlation behavior when
    the construct is added to the FROM clause of an enclosing SELECT. The following
    example illustrates a SQL query that makes use of LATERAL, selecting the “user
    account / count of email address” data as was discussed in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Above, the right side of the JOIN is a subquery that correlates to the `user_account`
    table that’s on the left side of the join.
  prefs: []
  type: TYPE_NORMAL
- en: When using [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral"), the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") methods is applied to the
    [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")
    construct as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '## UNION, UNION ALL and other set operations'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, SELECT statements can be merged together using the UNION or UNION ALL
    SQL operation, which produces the set of all rows produced by one or more statements
    together. Other set operations such as INTERSECT [ALL] and EXCEPT [ALL] are also
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct supports compositions of this nature
    using functions like [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union"), [`intersect()`](../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and [`except_()`](../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), and the “all” counterparts [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"), [`intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.intersect_all
    "sqlalchemy.sql.expression.intersect_all") and [`except_all()`](../core/selectable.html#sqlalchemy.sql.expression.except_all
    "sqlalchemy.sql.expression.except_all"). These functions all accept an arbitrary
    number of sub-selectables, which are typically [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs but may also be an existing composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The construct produced by these functions is the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is used in the same manner
    as the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct, except that it has fewer methods. The [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") produced by [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") for example may be invoked directly using
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") as a subquery, just like [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") it provides a [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method which will produce a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object with a [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") collection that may be referenced in
    an enclosing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '### Selecting ORM Entities from Unions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)  ### Selecting ORM
    Entities from Unions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples illustrated how to construct a UNION given two [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, to then return database rows. If we wanted
    to use a UNION or other set operation to select rows that we then receive as ORM
    objects, there are two approaches that may be used. In both cases, we first construct
    a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    or [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") object that represents the SELECT
    / UNION / etc statement we want to execute; this statement should be composed
    against the target ORM entities or their underlying mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'For a simple SELECT with UNION that is not already nested inside of a subquery,
    these can often be used in an ORM object fetching context by using the [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method. With this approach,
    the UNION statement represents the entire query; no additional criteria can be
    added after [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a UNION or other set-related construct as an entity-related component
    in in a more flexible manner, the [`CompoundSelect`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct may be organized into a
    subquery using [`CompoundSelect.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery"), which then links to ORM
    objects using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function. This works in the same way introduced at [ORM
    Entity Subqueries/CTEs](#tutorial-subqueries-orm-aliased), to first create an
    ad-hoc “mapping” of our desired entity to the subquery, then selecting from that
    new entity as though it were any other mapped class. In the example below, we
    are able to add additional criteria such as ORDER BY outside of the UNION itself,
    as we can filter or order by the columns exported by the subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting Entities from UNIONs and other set operations](../orm/queryguide/select.html#orm-queryguide-unions)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## EXISTS subqueries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL EXISTS keyword is an operator that is used with [scalar subqueries](#tutorial-scalar-subquery)
    to return a boolean true or false depending on if the SELECT statement would return
    a row. SQLAlchemy includes a variant of the [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") object called [`Exists`](../core/selectable.html#sqlalchemy.sql.expression.Exists
    "sqlalchemy.sql.expression.Exists"), which will generate an EXISTS subquery and
    is most conveniently generated using the [`SelectBase.exists()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists
    "sqlalchemy.sql.expression.SelectBase.exists") method. Below we produce an EXISTS
    so that we can return `user_account` rows that have more than one related row
    in `address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The EXISTS construct is more often than not used as a negation, e.g. NOT EXISTS,
    as it provides a SQL-efficient form of locating rows for which a related table
    has no rows. Below we select user names that have no email addresses; note the
    binary negation operator (`~`) used inside the second WHERE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '## Working with SQL Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'First introduced earlier in this section at [Aggregate functions with GROUP
    BY / HAVING](#tutorial-group-by-w-aggregates), the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object serves as a factory for creating new
    [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects, which when used in a construct like [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), produce a SQL function display, typically
    consisting of a name, some parenthesis (although not always), and possibly some
    arguments. Examples of typical SQL functions include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the `count()` function, an aggregate function which counts how many rows are
    returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'the `lower()` function, a string function that converts a string to lower case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'the `now()` function, which provides for the current date and time; as this
    is a common function, SQLAlchemy knows how to render this differently for each
    backend, in the case of SQLite using the CURRENT_TIMESTAMP function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As most database backends feature dozens if not hundreds of different SQL functions,
    [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    tries to be as liberal as possible in what it accepts. Any name that is accessed
    from this namespace is automatically considered to be a SQL function that will
    render in a generic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, a relatively small set of extremely common SQL functions
    such as [`count`](../core/functions.html#sqlalchemy.sql.functions.count "sqlalchemy.sql.functions.count"),
    [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now"),
    [`max`](../core/functions.html#sqlalchemy.sql.functions.max "sqlalchemy.sql.functions.max"),
    [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat "sqlalchemy.sql.functions.concat")
    include pre-packaged versions of themselves which provide for proper typing information
    as well as backend-specific SQL generation in some cases. The example below contrasts
    the SQL generation that occurs for the PostgreSQL dialect compared to the Oracle
    dialect for the [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Functions Have Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  prefs: []
  type: TYPE_NORMAL
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Built-in Functions Have Pre-Configured Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'vs.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced SQL Function Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]  #### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions Have Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As functions are column expressions, they also have SQL [datatypes](../core/types.html)
    that describe the data type of a generated SQL expression. We refer to these types
    here as “SQL return types”, in reference to the type of SQL value that is returned
    by the function in the context of a database-side SQL expression, as opposed to
    the “return type” of a Python function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL return type of any SQL function may be accessed, typically for debugging
    purposes, by referring to the `Function.type` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: These SQL return types are significant when making use of the function expression
    in the context of a larger expression; that is, math operators will work better
    when the datatype of the expression is something like [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), JSON accessors in order to work need to be using
    a type such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    Certain classes of functions return entire rows instead of column values, where
    there is a need to refer to specific columns; such functions are known as [table
    valued functions](#tutorial-functions-table-valued).
  prefs: []
  type: TYPE_NORMAL
- en: The SQL return type of the function may also be significant when executing a
    statement and getting rows back, for those cases where SQLAlchemy has to apply
    result-set processing. A prime example of this are date-related functions on SQLite,
    where SQLAlchemy’s [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related datatypes take on the role of converting
    from string values to Python `datetime()` objects as result rows are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a specific type to a function we’re creating, we pass it using the
    [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter; the type argument may be either
    a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or an instance. In the example below we pass the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class to generate the PostgreSQL `json_object()` function,
    noting that the SQL return type will be of type JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating our JSON function with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, the SQL expression object takes on JSON-related
    features, such as that of accessing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Built-in Functions Have Pre-Configured Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For common aggregate functions like [`count`](../core/functions.html#sqlalchemy.sql.functions.count
    "sqlalchemy.sql.functions.count"), [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max"), [`min`](../core/functions.html#sqlalchemy.sql.functions.min
    "sqlalchemy.sql.functions.min") as well as a very small number of date functions
    like [`now`](../core/functions.html#sqlalchemy.sql.functions.now "sqlalchemy.sql.functions.now")
    and string functions like [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat"), the SQL return type is set up appropriately,
    sometimes based on usage. The [`max`](../core/functions.html#sqlalchemy.sql.functions.max
    "sqlalchemy.sql.functions.max") function and similar aggregate filtering functions
    will set up the SQL return type based on the argument given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Date and time functions typically correspond to SQL expressions described by
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'A known string function such as [`concat`](../core/functions.html#sqlalchemy.sql.functions.concat
    "sqlalchemy.sql.functions.concat") will know that a SQL expression would be of
    type [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the vast majority of SQL functions, SQLAlchemy does not have them
    explicitly present in its very small list of known functions. For example, while
    there is typically no issue using SQL functions `func.lower()` and `func.upper()`
    to convert the casing of strings, SQLAlchemy doesn’t actually know about these
    functions, so they have a “null” SQL return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple functions like `upper` and `lower`, the issue is not usually significant,
    as string values may be received from the database without any special type handling
    on the SQLAlchemy side, and SQLAlchemy’s type coercion rules can often correctly
    guess intent as well; the Python `+` operator for example will be correctly interpreted
    as the string concatenation operator based on looking at both sides of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, the scenario where the [`Function.type_`](../core/functions.html#sqlalchemy.sql.functions.Function.params.type_
    "sqlalchemy.sql.functions.Function") parameter is likely necessary is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the function is not already a SQLAlchemy built-in function; this can be evidenced
    by creating the function and observing the `Function.type` attribute, that is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'vs.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function-aware expression support is needed; this most typically refers to special
    operators related to datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") or [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result value processing is needed, which may include types such as `DateTime`,
    [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"),
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum"),
    or again special datatypes such as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced SQL Function Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections illustrate more things that can be done with SQL functions.
    While these techniques are less common and more advanced than basic SQL function
    use, they nonetheless are extremely popular, largely as a result of PostgreSQL’s
    emphasis on more complex function forms, including table- and column-valued forms
    that are popular with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.  #### Special Modifiers WITHIN GROUP, FILTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]  #### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.  #### Column Valued Functions - Table
    Valued Function as a Scalar Column'
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.  #### Using
    Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: A window function is a special use of a SQL aggregate function which calculates
    the aggregate value over the rows being returned in a group as the individual
    result rows are processed. Whereas a function like `MAX()` will give you the highest
    value of a column within a set of rows, using the same function as a “window function”
    will given you the highest value for each row, *as of that row*.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, window functions allow one to specify the rows over which the function
    should be applied, a “partition” value which considers the window over different
    sub-sets of rows, and an “order by” expression which importantly indicates the
    order in which rows should be applied to the aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, all SQL functions generated by the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace include a method [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") which grants the window function,
    or “OVER”, syntax; the construct produced is the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common function used with window functions is the `row_number()` function
    which simply counts rows. We may partition this row count against user name to
    number the email addresses of individual users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`FunctionElement.over.partition_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by
    "sqlalchemy.sql.functions.FunctionElement.over") parameter is used so that the
    `PARTITION BY` clause is rendered within the OVER clause. We also may make use
    of the `ORDER BY` clause using [`FunctionElement.over.order_by`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by
    "sqlalchemy.sql.functions.FunctionElement.over"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Further options for window functions include usage of ranges; see [`over()`](../core/sqlelement.html#sqlalchemy.sql.expression.over
    "sqlalchemy.sql.expression.over") for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the [`FunctionElement.over()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method only applies to those
    SQL functions which are in fact aggregate functions; while the [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct will happily render itself for any
    SQL function given, the database will reject the expression if the function itself
    is not a SQL aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Special Modifiers WITHIN GROUP, FILTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
    or a “hypothetical set” aggregate function. Common “ordered set” functions include
    `percentile_cont()` and `rank()`. SQLAlchemy includes built in implementations
    [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank "sqlalchemy.sql.functions.rank"),
    [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank "sqlalchemy.sql.functions.dense_rank"),
    [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode "sqlalchemy.sql.functions.mode"),
    [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont") and [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc") which include a [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '“FILTER” is supported by some backends to limit the range of an aggregate function
    to a particular subset of rows compared to the total range of rows returned, available
    using the [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '#### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued SQL functions support a scalar representation that contains named
    sub-elements. Often used for JSON and ARRAY-oriented functions as well as functions
    like `generate_series()`, the table-valued function is specified in the FROM clause,
    and is then referenced as a table, or sometimes even as a column. Functions of
    this form are prominent within the PostgreSQL database, however some forms of
    table valued functions are also supported by SQLite, Oracle, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table values, Table and Column valued functions, Row and Tuple objects](../dialects/postgresql.html#postgresql-table-valued-overview)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: While many databases support table valued and other special forms, PostgreSQL
    tends to be where there is the most demand for these features. See this section
    for additional examples of PostgreSQL syntaxes as well as additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method as the basic “table
    valued function” construct, which will convert a [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") object into a FROM clause containing a series
    of named columns, based on string names passed positionally. This returns a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") object, which is a function-enabled
    [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    construct that may be used as any other FROM clause as introduced at [Using Aliases](#tutorial-using-aliases).
    Below we illustrate the `json_each()` function, which while common on PostgreSQL
    is also supported by modern versions of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Above, we used the `json_each()` JSON function supported by SQLite and PostgreSQL
    to generate a table valued expression with a single column referred towards as
    `value`, and then selected two of its three rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../dialects/postgresql.html#postgresql-table-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation - this section
    will detail additional syntaxes such as special column derivations and “WITH ORDINALITY”
    that are known to work with PostgreSQL.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Column Valued Functions - Table Valued Function as a Scalar Column'
  prefs: []
  type: TYPE_NORMAL
- en: A special syntax supported by PostgreSQL and Oracle is that of referring towards
    a function in the FROM clause, which then delivers itself as a single column in
    the columns clause of a SELECT statement or other column expression context. PostgreSQL
    makes great use of this syntax for such functions as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy refers to this as a “column valued” function and is available by
    applying the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") modifier to a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The “column valued” form is also supported by the Oracle dialect, where it
    is usable for custom SQL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions](../dialects/postgresql.html#postgresql-column-valued)
    - in the [PostgreSQL](../dialects/postgresql.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Data Casts and Type Coercion'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, we often need to indicate the datatype of an expression explicitly,
    either to tell the database what type is expected in an otherwise ambiguous expression,
    or in some cases when we want to convert the implied datatype of a SQL expression
    into something else. The SQL CAST keyword is used for this task, which in SQLAlchemy
    is provided by the [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") function. This function accepts a column expression
    and a data type object as arguments, as demonstrated below where we produce a
    SQL expression `CAST(user_account.id AS VARCHAR)` from the `user_table.c.id` column
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function not only renders the SQL CAST syntax, it also produces a SQLAlchemy column
    expression that will act as the given datatype on the Python side as well. A string
    expression that is [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will gain JSON subscript and comparison operators, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: type_coerce() - a Python-only “cast”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: type_coerce() - a Python-only “cast”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes there is the need to have SQLAlchemy know the datatype of an expression,
    for all the reasons mentioned above, but to not render the CAST expression itself
    on the SQL side, where it may interfere with a SQL operation that already works
    without it. For this fairly common use case there is another function [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") which is closely related to [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast"), in that it sets up a Python expression as having
    a specific SQL database type, but does not render the `CAST` keyword or datatype
    on the database side. [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is particularly important when dealing
    with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, which typically has an intricate relationship with string-oriented datatypes
    on different platforms and may not even be an explicit datatype, such as on SQLite
    and MariaDB. Below, we use [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to deliver a Python structure as a JSON
    string into one of MySQL’s JSON functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Above, MySQL’s `JSON_EXTRACT` SQL function was invoked because we used [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to indicate that our Python dictionary
    should be treated as [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
    The Python `__getitem__` operator, `['some_key']` in this case, became available
    as a result and allowed a `JSON_EXTRACT` path expression (not shown, however in
    this case it would ultimately be `'$."some_key"'`) to be rendered.
  prefs: []
  type: TYPE_NORMAL
