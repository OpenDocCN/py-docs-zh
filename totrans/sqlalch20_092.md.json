["```py\nevent.listen(\n    metadata,\n    \"after_create\",\n    DDL(\n        \"ALTER TABLE users ADD CONSTRAINT \"\n        \"cst_user_name_length \"\n        \" CHECK (length(user_name) >= 8)\"\n    ),\n)\n```", "```py\nmytable = Table(\n    \"mytable\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n)\n\nfunc = DDL(\n    \"CREATE FUNCTION my_func() \"\n    \"RETURNS TRIGGER AS $$ \"\n    \"BEGIN \"\n    \"NEW.data := 'ins'; \"\n    \"RETURN NEW; \"\n    \"END; $$ LANGUAGE PLPGSQL\"\n)\n\ntrigger = DDL(\n    \"CREATE TRIGGER dt_ins BEFORE INSERT ON mytable \"\n    \"FOR EACH ROW EXECUTE PROCEDURE my_func();\"\n)\n\nevent.listen(mytable, \"after_create\", func.execute_if(dialect=\"postgresql\"))\n\nevent.listen(mytable, \"after_create\", trigger.execute_if(dialect=\"postgresql\"))\n```", "```py\nevent.listen(\n    mytable, \"after_create\", trigger.execute_if(dialect=(\"postgresql\", \"mysql\"))\n)\nevent.listen(\n    mytable, \"before_drop\", trigger.execute_if(dialect=(\"postgresql\", \"mysql\"))\n)\n```", "```py\ndef should_create(ddl, target, connection, **kw):\n    row = connection.execute(\n        \"select conname from pg_constraint where conname='%s'\" % ddl.element.name\n    ).scalar()\n    return not bool(row)\n\ndef should_drop(ddl, target, connection, **kw):\n    return not should_create(ddl, target, connection, **kw)\n\nevent.listen(\n    users,\n    \"after_create\",\n    DDL(\n        \"ALTER TABLE users ADD CONSTRAINT \"\n        \"cst_user_name_length CHECK (length(user_name) >= 8)\"\n    ).execute_if(callable_=should_create),\n)\nevent.listen(\n    users,\n    \"before_drop\",\n    DDL(\"ALTER TABLE users DROP CONSTRAINT cst_user_name_length\").execute_if(\n        callable_=should_drop\n    ),\n)\n\nusers.create(engine)\nCREATE  TABLE  users  (\n  user_id  SERIAL  NOT  NULL,\n  user_name  VARCHAR(40)  NOT  NULL,\n  PRIMARY  KEY  (user_id)\n)\n\nSELECT  conname  FROM  pg_constraint  WHERE  conname='cst_user_name_length'\nALTER  TABLE  users  ADD  CONSTRAINT  cst_user_name_length  CHECK  (length(user_name)  >=  8)\nusers.drop(engine)\nSELECT  conname  FROM  pg_constraint  WHERE  conname='cst_user_name_length'\nALTER  TABLE  users  DROP  CONSTRAINT  cst_user_name_length\nDROP  TABLE  users \n```", "```py\nfrom sqlalchemy.schema import CreateTable\n\nwith engine.connect() as conn:\n    conn.execute(CreateTable(mytable))\nCREATE  TABLE  mytable  (\n  col1  INTEGER,\n  col2  INTEGER,\n  col3  INTEGER,\n  col4  INTEGER,\n  col5  INTEGER,\n  col6  INTEGER\n) \n```", "```py\nfrom sqlalchemy import CheckConstraint, Index\nfrom sqlalchemy import MetaData, Table, Column\nfrom sqlalchemy import Integer, String\n\nmeta = MetaData()\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(dialect=\"postgresql\"),\n    CheckConstraint(\"num > 5\").ddl_if(dialect=\"postgresql\"),\n)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> sqlite_engine = create_engine(\"sqlite+pysqlite://\", echo=True)\n>>> meta.create_all(sqlite_engine)\nBEGIN  (implicit)\nPRAGMA  main.table_info(\"my_table\")\n[raw  sql]  ()\nPRAGMA  temp.table_info(\"my_table\")\n[raw  sql]  ()\n\nCREATE  TABLE  my_table  (\n  id  INTEGER  NOT  NULL,\n  num  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n) \n```", "```py\n>>> from sqlalchemy import create_engine\n>>> postgresql_engine = create_engine(\n...     \"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True\n... )\n>>> meta.create_all(postgresql_engine)\nBEGIN  (implicit)\nselect  relname  from  pg_class  c  join  pg_namespace  n  on  n.oid=c.relnamespace  where  pg_catalog.pg_table_is_visible(c.oid)  and  relname=%(name)s\n[generated  in  0.00009s]  {'name':  'my_table'}\n\nCREATE  TABLE  my_table  (\n  id  SERIAL  NOT  NULL,\n  num  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id),\n  CHECK  (num  >  5)\n)\n[no  key  0.00007s]  {}\nCREATE  INDEX  my_pg_index  ON  my_table  (data)\n[no  key  0.00013s]  {}\nCOMMIT \n```", "```py\ndef only_pg_14(ddl_element, target, bind, dialect, **kw):\n    return dialect.name == \"postgresql\" and dialect.server_version_info >= (14,)\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(callable_=only_pg_14),\n)\n```", "```py\nfunction sqlalchemy.schema.sort_tables(tables: Iterable[TableClause], skip_fn: Callable[[ForeignKeyConstraint], bool] | None = None, extra_dependencies: typing_Sequence[Tuple[TableClause, TableClause]] | None = None) \u2192 List[Table]\n```", "```py\nfunction sqlalchemy.schema.sort_tables_and_constraints(tables, filter_fn=None, extra_dependencies=None, _warn_for_cycles=False)\n```", "```py\nclass sqlalchemy.schema.BaseDDLElement\n```", "```py\nclass sqlalchemy.schema.ExecutableDDLElement\n```", "```py\nevent.listen(\n    users,\n    'after_create',\n    AddConstraint(constraint).execute_if(dialect='postgresql')\n)\n```", "```py\nmethod __call__(target, bind, **kw)\n```", "```py\nmethod against(target: SchemaItem) \u2192 Self\n```", "```py\nmethod execute_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nevent.listen(\n            metadata,\n            'before_create',\n            DDL(\"my_ddl\").execute_if(dialect='postgresql')\n        )\n```", "```py\n    DDL('something').execute_if(dialect='postgresql')\n    ```", "```py\n    DDL('something').execute_if(dialect=('postgresql', 'mysql'))\n    ```", "```py\nclass sqlalchemy.schema.DDL\n```", "```py\nfrom sqlalchemy import event, DDL\n\ntbl = Table('users', metadata, Column('uid', Integer))\nevent.listen(tbl, 'before_create', DDL('DROP TRIGGER users_trigger'))\n\nspow = DDL('ALTER TABLE %(table)s SET secretpowers TRUE')\nevent.listen(tbl, 'after_create', spow.execute_if(dialect='somedb'))\n\ndrop_spow = DDL('ALTER TABLE users SET secretpowers FALSE')\nconnection.execute(drop_spow)\n```", "```py\n%(table)s  - the Table name, with any required quoting applied\n%(schema)s - the schema name, with any required quoting applied\n%(fullname)s - the Table name including schema, quoted if needed\n```", "```py\nmethod __init__(statement, context=None)\n```", "```py\nclass sqlalchemy.schema._CreateDropBase\n```", "```py\nclass sqlalchemy.schema.CreateTable\n```", "```py\nmethod __init__(element: Table, include_foreign_key_constraints: typing_Sequence[ForeignKeyConstraint] | None = None, if_not_exists: bool = False)\n```", "```py\nclass sqlalchemy.schema.DropTable\n```", "```py\nmethod __init__(element: Table, if_exists: bool = False)\n```", "```py\nclass sqlalchemy.schema.CreateColumn\n```", "```py\nfrom sqlalchemy import schema\nfrom sqlalchemy.ext.compiler import compiles\n\n@compiles(schema.CreateColumn)\ndef compile(element, compiler, **kw):\n    column = element.element\n\n    if \"special\" not in column.info:\n        return compiler.visit_create_column(element, **kw)\n\n    text = \"%s SPECIAL DIRECTIVE %s\" % (\n            column.name,\n            compiler.type_compiler.process(column.type)\n        )\n    default = compiler.get_column_default_string(column)\n    if default is not None:\n        text += \" DEFAULT \" + default\n\n    if not column.nullable:\n        text += \" NOT NULL\"\n\n    if column.constraints:\n        text += \" \".join(\n                    compiler.process(const)\n                    for const in column.constraints)\n    return text\n```", "```py\nfrom sqlalchemy import Table, Metadata, Column, Integer, String\nfrom sqlalchemy import schema\n\nmetadata = MetaData()\n\ntable = Table('mytable', MetaData(),\n        Column('x', Integer, info={\"special\":True}, primary_key=True),\n        Column('y', String(50)),\n        Column('z', String(20), info={\"special\":True})\n    )\n\nmetadata.create_all(conn)\n```", "```py\nCREATE TABLE mytable (\n        x SPECIAL DIRECTIVE INTEGER NOT NULL,\n        y VARCHAR(50),\n        z SPECIAL DIRECTIVE VARCHAR(20),\n    PRIMARY KEY (x)\n)\n```", "```py\nfrom sqlalchemy.schema import CreateColumn\n\n@compiles(CreateColumn, \"postgresql\")\ndef skip_xmin(element, compiler, **kw):\n    if element.element.name == 'xmin':\n        return None\n    else:\n        return compiler.visit_create_column(element, **kw)\n\nmy_table = Table('mytable', metadata,\n            Column('id', Integer, primary_key=True),\n            Column('xmin', Integer)\n        )\n```", "```py\nclass sqlalchemy.schema.CreateSequence\n```", "```py\nclass sqlalchemy.schema.DropSequence\n```", "```py\nclass sqlalchemy.schema.CreateIndex\n```", "```py\nmethod __init__(element, if_not_exists=False)\n```", "```py\nclass sqlalchemy.schema.DropIndex\n```", "```py\nmethod __init__(element, if_exists=False)\n```", "```py\nclass sqlalchemy.schema.AddConstraint\n```", "```py\nclass sqlalchemy.schema.DropConstraint\n```", "```py\nclass sqlalchemy.schema.CreateSchema\n```", "```py\nmethod __init__(name, if_not_exists=False)\n```", "```py\nclass sqlalchemy.schema.DropSchema\n```", "```py\nmethod __init__(name, cascade=False, if_exists=False)\n```", "```py\nevent.listen(\n    metadata,\n    \"after_create\",\n    DDL(\n        \"ALTER TABLE users ADD CONSTRAINT \"\n        \"cst_user_name_length \"\n        \" CHECK (length(user_name) >= 8)\"\n    ),\n)\n```", "```py\nmytable = Table(\n    \"mytable\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n)\n\nfunc = DDL(\n    \"CREATE FUNCTION my_func() \"\n    \"RETURNS TRIGGER AS $$ \"\n    \"BEGIN \"\n    \"NEW.data := 'ins'; \"\n    \"RETURN NEW; \"\n    \"END; $$ LANGUAGE PLPGSQL\"\n)\n\ntrigger = DDL(\n    \"CREATE TRIGGER dt_ins BEFORE INSERT ON mytable \"\n    \"FOR EACH ROW EXECUTE PROCEDURE my_func();\"\n)\n\nevent.listen(mytable, \"after_create\", func.execute_if(dialect=\"postgresql\"))\n\nevent.listen(mytable, \"after_create\", trigger.execute_if(dialect=\"postgresql\"))\n```", "```py\nevent.listen(\n    mytable, \"after_create\", trigger.execute_if(dialect=(\"postgresql\", \"mysql\"))\n)\nevent.listen(\n    mytable, \"before_drop\", trigger.execute_if(dialect=(\"postgresql\", \"mysql\"))\n)\n```", "```py\ndef should_create(ddl, target, connection, **kw):\n    row = connection.execute(\n        \"select conname from pg_constraint where conname='%s'\" % ddl.element.name\n    ).scalar()\n    return not bool(row)\n\ndef should_drop(ddl, target, connection, **kw):\n    return not should_create(ddl, target, connection, **kw)\n\nevent.listen(\n    users,\n    \"after_create\",\n    DDL(\n        \"ALTER TABLE users ADD CONSTRAINT \"\n        \"cst_user_name_length CHECK (length(user_name) >= 8)\"\n    ).execute_if(callable_=should_create),\n)\nevent.listen(\n    users,\n    \"before_drop\",\n    DDL(\"ALTER TABLE users DROP CONSTRAINT cst_user_name_length\").execute_if(\n        callable_=should_drop\n    ),\n)\n\nusers.create(engine)\nCREATE  TABLE  users  (\n  user_id  SERIAL  NOT  NULL,\n  user_name  VARCHAR(40)  NOT  NULL,\n  PRIMARY  KEY  (user_id)\n)\n\nSELECT  conname  FROM  pg_constraint  WHERE  conname='cst_user_name_length'\nALTER  TABLE  users  ADD  CONSTRAINT  cst_user_name_length  CHECK  (length(user_name)  >=  8)\nusers.drop(engine)\nSELECT  conname  FROM  pg_constraint  WHERE  conname='cst_user_name_length'\nALTER  TABLE  users  DROP  CONSTRAINT  cst_user_name_length\nDROP  TABLE  users \n```", "```py\nfrom sqlalchemy.schema import CreateTable\n\nwith engine.connect() as conn:\n    conn.execute(CreateTable(mytable))\nCREATE  TABLE  mytable  (\n  col1  INTEGER,\n  col2  INTEGER,\n  col3  INTEGER,\n  col4  INTEGER,\n  col5  INTEGER,\n  col6  INTEGER\n) \n```", "```py\nfrom sqlalchemy import CheckConstraint, Index\nfrom sqlalchemy import MetaData, Table, Column\nfrom sqlalchemy import Integer, String\n\nmeta = MetaData()\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(dialect=\"postgresql\"),\n    CheckConstraint(\"num > 5\").ddl_if(dialect=\"postgresql\"),\n)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> sqlite_engine = create_engine(\"sqlite+pysqlite://\", echo=True)\n>>> meta.create_all(sqlite_engine)\nBEGIN  (implicit)\nPRAGMA  main.table_info(\"my_table\")\n[raw  sql]  ()\nPRAGMA  temp.table_info(\"my_table\")\n[raw  sql]  ()\n\nCREATE  TABLE  my_table  (\n  id  INTEGER  NOT  NULL,\n  num  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n) \n```", "```py\n>>> from sqlalchemy import create_engine\n>>> postgresql_engine = create_engine(\n...     \"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True\n... )\n>>> meta.create_all(postgresql_engine)\nBEGIN  (implicit)\nselect  relname  from  pg_class  c  join  pg_namespace  n  on  n.oid=c.relnamespace  where  pg_catalog.pg_table_is_visible(c.oid)  and  relname=%(name)s\n[generated  in  0.00009s]  {'name':  'my_table'}\n\nCREATE  TABLE  my_table  (\n  id  SERIAL  NOT  NULL,\n  num  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id),\n  CHECK  (num  >  5)\n)\n[no  key  0.00007s]  {}\nCREATE  INDEX  my_pg_index  ON  my_table  (data)\n[no  key  0.00013s]  {}\nCOMMIT \n```", "```py\ndef only_pg_14(ddl_element, target, bind, dialect, **kw):\n    return dialect.name == \"postgresql\" and dialect.server_version_info >= (14,)\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(callable_=only_pg_14),\n)\n```", "```py\nfunction sqlalchemy.schema.sort_tables(tables: Iterable[TableClause], skip_fn: Callable[[ForeignKeyConstraint], bool] | None = None, extra_dependencies: typing_Sequence[Tuple[TableClause, TableClause]] | None = None) \u2192 List[Table]\n```", "```py\nfunction sqlalchemy.schema.sort_tables_and_constraints(tables, filter_fn=None, extra_dependencies=None, _warn_for_cycles=False)\n```", "```py\nclass sqlalchemy.schema.BaseDDLElement\n```", "```py\nclass sqlalchemy.schema.ExecutableDDLElement\n```", "```py\nevent.listen(\n    users,\n    'after_create',\n    AddConstraint(constraint).execute_if(dialect='postgresql')\n)\n```", "```py\nmethod __call__(target, bind, **kw)\n```", "```py\nmethod against(target: SchemaItem) \u2192 Self\n```", "```py\nmethod execute_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nevent.listen(\n            metadata,\n            'before_create',\n            DDL(\"my_ddl\").execute_if(dialect='postgresql')\n        )\n```", "```py\n    DDL('something').execute_if(dialect='postgresql')\n    ```", "```py\n    DDL('something').execute_if(dialect=('postgresql', 'mysql'))\n    ```", "```py\nclass sqlalchemy.schema.DDL\n```", "```py\nfrom sqlalchemy import event, DDL\n\ntbl = Table('users', metadata, Column('uid', Integer))\nevent.listen(tbl, 'before_create', DDL('DROP TRIGGER users_trigger'))\n\nspow = DDL('ALTER TABLE %(table)s SET secretpowers TRUE')\nevent.listen(tbl, 'after_create', spow.execute_if(dialect='somedb'))\n\ndrop_spow = DDL('ALTER TABLE users SET secretpowers FALSE')\nconnection.execute(drop_spow)\n```", "```py\n%(table)s  - the Table name, with any required quoting applied\n%(schema)s - the schema name, with any required quoting applied\n%(fullname)s - the Table name including schema, quoted if needed\n```", "```py\nmethod __init__(statement, context=None)\n```", "```py\nclass sqlalchemy.schema._CreateDropBase\n```", "```py\nclass sqlalchemy.schema.CreateTable\n```", "```py\nmethod __init__(element: Table, include_foreign_key_constraints: typing_Sequence[ForeignKeyConstraint] | None = None, if_not_exists: bool = False)\n```", "```py\nclass sqlalchemy.schema.DropTable\n```", "```py\nmethod __init__(element: Table, if_exists: bool = False)\n```", "```py\nclass sqlalchemy.schema.CreateColumn\n```", "```py\nfrom sqlalchemy import schema\nfrom sqlalchemy.ext.compiler import compiles\n\n@compiles(schema.CreateColumn)\ndef compile(element, compiler, **kw):\n    column = element.element\n\n    if \"special\" not in column.info:\n        return compiler.visit_create_column(element, **kw)\n\n    text = \"%s SPECIAL DIRECTIVE %s\" % (\n            column.name,\n            compiler.type_compiler.process(column.type)\n        )\n    default = compiler.get_column_default_string(column)\n    if default is not None:\n        text += \" DEFAULT \" + default\n\n    if not column.nullable:\n        text += \" NOT NULL\"\n\n    if column.constraints:\n        text += \" \".join(\n                    compiler.process(const)\n                    for const in column.constraints)\n    return text\n```", "```py\nfrom sqlalchemy import Table, Metadata, Column, Integer, String\nfrom sqlalchemy import schema\n\nmetadata = MetaData()\n\ntable = Table('mytable', MetaData(),\n        Column('x', Integer, info={\"special\":True}, primary_key=True),\n        Column('y', String(50)),\n        Column('z', String(20), info={\"special\":True})\n    )\n\nmetadata.create_all(conn)\n```", "```py\nCREATE TABLE mytable (\n        x SPECIAL DIRECTIVE INTEGER NOT NULL,\n        y VARCHAR(50),\n        z SPECIAL DIRECTIVE VARCHAR(20),\n    PRIMARY KEY (x)\n)\n```", "```py\nfrom sqlalchemy.schema import CreateColumn\n\n@compiles(CreateColumn, \"postgresql\")\ndef skip_xmin(element, compiler, **kw):\n    if element.element.name == 'xmin':\n        return None\n    else:\n        return compiler.visit_create_column(element, **kw)\n\nmy_table = Table('mytable', metadata,\n            Column('id', Integer, primary_key=True),\n            Column('xmin', Integer)\n        )\n```", "```py\nclass sqlalchemy.schema.CreateSequence\n```", "```py\nclass sqlalchemy.schema.DropSequence\n```", "```py\nclass sqlalchemy.schema.CreateIndex\n```", "```py\nmethod __init__(element, if_not_exists=False)\n```", "```py\nclass sqlalchemy.schema.DropIndex\n```", "```py\nmethod __init__(element, if_exists=False)\n```", "```py\nclass sqlalchemy.schema.AddConstraint\n```", "```py\nclass sqlalchemy.schema.DropConstraint\n```", "```py\nclass sqlalchemy.schema.CreateSchema\n```", "```py\nmethod __init__(name, if_not_exists=False)\n```", "```py\nclass sqlalchemy.schema.DropSchema\n```", "```py\nmethod __init__(name, cascade=False, if_exists=False)\n```"]