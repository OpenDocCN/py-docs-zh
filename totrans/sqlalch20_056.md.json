["```py\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if orm_execute_state.is_select:\n        # add populate_existing for all SELECT statements\n\n        orm_execute_state.update_execution_options(populate_existing=True)\n\n        # check if the SELECT is against a certain entity and add an\n        # ORDER BY if so\n        col_descriptions = orm_execute_state.statement.column_descriptions\n\n        if col_descriptions[0][\"entity\"] is MyEntity:\n            orm_execute_state.statement = statement.order_by(MyEntity.name)\n```", "```py\nfrom sqlalchemy.orm import with_loader_criteria\n\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(MyEntity.public == True)\n        )\n```", "```py\nimport datetime\n\nclass HasTimestamp:\n    timestamp = mapped_column(DateTime, default=datetime.datetime.now)\n\nclass SomeEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n\nclass SomeOtherEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        one_month_ago = datetime.datetime.today() - datetime.timedelta(months=1)\n\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(\n                HasTimestamp,\n                lambda cls: cls.timestamp >= one_month_ago,\n                include_aliases=True,\n            )\n        )\n```", "```py\nfrom sqlalchemy.orm import loading\n\ncache = {}\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if \"my_cache_key\" in orm_execute_state.execution_options:\n        cache_key = orm_execute_state.execution_options[\"my_cache_key\"]\n\n        if cache_key in cache:\n            frozen_result = cache[cache_key]\n        else:\n            frozen_result = orm_execute_state.invoke_statement().freeze()\n            cache[cache_key] = frozen_result\n\n        return loading.merge_frozen_result(\n            orm_execute_state.session,\n            orm_execute_state.statement,\n            frozen_result,\n            load=False,\n        )\n```", "```py\nstmt = (\n    select(User).where(User.name == \"sandy\").execution_options(my_cache_key=\"key_sandy\")\n)\n\nresult = session.execute(stmt)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.orm import Session\n\nsession = Session()\n\n@event.listens_for(session, \"transient_to_pending\")\ndef object_is_pending(session, obj):\n    print(\"new pending: %s\" % obj)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.orm import sessionmaker\n\nmaker = sessionmaker()\n\n@event.listens_for(maker, \"transient_to_pending\")\ndef object_is_pending(session, obj):\n    print(\"new pending: %s\" % obj)\n```", "```py\n@event.listens_for(maker, \"pending_to_persistent\")\n@event.listens_for(maker, \"deleted_to_persistent\")\n@event.listens_for(maker, \"detached_to_persistent\")\n@event.listens_for(maker, \"loaded_as_persistent\")\ndef detect_all_persistent(session, instance):\n    print(\"object is now persistent: %s\" % instance)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\n@event.listens_for(Base, \"init\", propagate=True)\ndef intercept_init(instance, args, kwargs):\n    print(\"new transient: %s\" % instance)\n```", "```py\n@event.listens_for(sessionmaker, \"transient_to_pending\")\ndef intercept_transient_to_pending(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_persistent\")\ndef intercept_pending_to_persistent(session, object_):\n    print(\"pending to persistent: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_transient\")\ndef intercept_pending_to_transient(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"loaded_as_persistent\")\ndef intercept_loaded_as_persistent(session, object_):\n    print(\"object loaded into persistent state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_transient\")\ndef intercept_persistent_to_transient(session, object_):\n    print(\"persistent to transient: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_deleted\")\ndef intercept_persistent_to_deleted(session, object_):\n    print(\"object was DELETEd, is now in deleted state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_detached\")\ndef intercept_deleted_to_detached(session, object_):\n    print(\"deleted to detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_detached\")\ndef intercept_persistent_to_detached(session, object_):\n    print(\"object became detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"detached_to_persistent\")\ndef intercept_detached_to_persistent(session, object_):\n    print(\"object became persistent again: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_persistent\")\ndef intercept_deleted_to_persistent(session, object_):\n    print(\"deleted to persistent: %s\" % object_)\n```", "```py\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if orm_execute_state.is_select:\n        # add populate_existing for all SELECT statements\n\n        orm_execute_state.update_execution_options(populate_existing=True)\n\n        # check if the SELECT is against a certain entity and add an\n        # ORDER BY if so\n        col_descriptions = orm_execute_state.statement.column_descriptions\n\n        if col_descriptions[0][\"entity\"] is MyEntity:\n            orm_execute_state.statement = statement.order_by(MyEntity.name)\n```", "```py\nfrom sqlalchemy.orm import with_loader_criteria\n\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(MyEntity.public == True)\n        )\n```", "```py\nimport datetime\n\nclass HasTimestamp:\n    timestamp = mapped_column(DateTime, default=datetime.datetime.now)\n\nclass SomeEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n\nclass SomeOtherEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        one_month_ago = datetime.datetime.today() - datetime.timedelta(months=1)\n\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(\n                HasTimestamp,\n                lambda cls: cls.timestamp >= one_month_ago,\n                include_aliases=True,\n            )\n        )\n```", "```py\nfrom sqlalchemy.orm import loading\n\ncache = {}\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if \"my_cache_key\" in orm_execute_state.execution_options:\n        cache_key = orm_execute_state.execution_options[\"my_cache_key\"]\n\n        if cache_key in cache:\n            frozen_result = cache[cache_key]\n        else:\n            frozen_result = orm_execute_state.invoke_statement().freeze()\n            cache[cache_key] = frozen_result\n\n        return loading.merge_frozen_result(\n            orm_execute_state.session,\n            orm_execute_state.statement,\n            frozen_result,\n            load=False,\n        )\n```", "```py\nstmt = (\n    select(User).where(User.name == \"sandy\").execution_options(my_cache_key=\"key_sandy\")\n)\n\nresult = session.execute(stmt)\n```", "```py\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if orm_execute_state.is_select:\n        # add populate_existing for all SELECT statements\n\n        orm_execute_state.update_execution_options(populate_existing=True)\n\n        # check if the SELECT is against a certain entity and add an\n        # ORDER BY if so\n        col_descriptions = orm_execute_state.statement.column_descriptions\n\n        if col_descriptions[0][\"entity\"] is MyEntity:\n            orm_execute_state.statement = statement.order_by(MyEntity.name)\n```", "```py\nfrom sqlalchemy.orm import with_loader_criteria\n\nSession = sessionmaker(engine)\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(MyEntity.public == True)\n        )\n```", "```py\nimport datetime\n\nclass HasTimestamp:\n    timestamp = mapped_column(DateTime, default=datetime.datetime.now)\n\nclass SomeEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n\nclass SomeOtherEntity(HasTimestamp, Base):\n    __tablename__ = \"some_entity\"\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if (\n        orm_execute_state.is_select\n        and not orm_execute_state.is_column_load\n        and not orm_execute_state.is_relationship_load\n    ):\n        one_month_ago = datetime.datetime.today() - datetime.timedelta(months=1)\n\n        orm_execute_state.statement = orm_execute_state.statement.options(\n            with_loader_criteria(\n                HasTimestamp,\n                lambda cls: cls.timestamp >= one_month_ago,\n                include_aliases=True,\n            )\n        )\n```", "```py\nfrom sqlalchemy.orm import loading\n\ncache = {}\n\n@event.listens_for(Session, \"do_orm_execute\")\ndef _do_orm_execute(orm_execute_state):\n    if \"my_cache_key\" in orm_execute_state.execution_options:\n        cache_key = orm_execute_state.execution_options[\"my_cache_key\"]\n\n        if cache_key in cache:\n            frozen_result = cache[cache_key]\n        else:\n            frozen_result = orm_execute_state.invoke_statement().freeze()\n            cache[cache_key] = frozen_result\n\n        return loading.merge_frozen_result(\n            orm_execute_state.session,\n            orm_execute_state.statement,\n            frozen_result,\n            load=False,\n        )\n```", "```py\nstmt = (\n    select(User).where(User.name == \"sandy\").execution_options(my_cache_key=\"key_sandy\")\n)\n\nresult = session.execute(stmt)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.orm import Session\n\nsession = Session()\n\n@event.listens_for(session, \"transient_to_pending\")\ndef object_is_pending(session, obj):\n    print(\"new pending: %s\" % obj)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.orm import sessionmaker\n\nmaker = sessionmaker()\n\n@event.listens_for(maker, \"transient_to_pending\")\ndef object_is_pending(session, obj):\n    print(\"new pending: %s\" % obj)\n```", "```py\n@event.listens_for(maker, \"pending_to_persistent\")\n@event.listens_for(maker, \"deleted_to_persistent\")\n@event.listens_for(maker, \"detached_to_persistent\")\n@event.listens_for(maker, \"loaded_as_persistent\")\ndef detect_all_persistent(session, instance):\n    print(\"object is now persistent: %s\" % instance)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\n@event.listens_for(Base, \"init\", propagate=True)\ndef intercept_init(instance, args, kwargs):\n    print(\"new transient: %s\" % instance)\n```", "```py\n@event.listens_for(sessionmaker, \"transient_to_pending\")\ndef intercept_transient_to_pending(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_persistent\")\ndef intercept_pending_to_persistent(session, object_):\n    print(\"pending to persistent: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_transient\")\ndef intercept_pending_to_transient(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"loaded_as_persistent\")\ndef intercept_loaded_as_persistent(session, object_):\n    print(\"object loaded into persistent state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_transient\")\ndef intercept_persistent_to_transient(session, object_):\n    print(\"persistent to transient: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_deleted\")\ndef intercept_persistent_to_deleted(session, object_):\n    print(\"object was DELETEd, is now in deleted state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_detached\")\ndef intercept_deleted_to_detached(session, object_):\n    print(\"deleted to detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_detached\")\ndef intercept_persistent_to_detached(session, object_):\n    print(\"object became detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"detached_to_persistent\")\ndef intercept_detached_to_persistent(session, object_):\n    print(\"object became persistent again: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_persistent\")\ndef intercept_deleted_to_persistent(session, object_):\n    print(\"deleted to persistent: %s\" % object_)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\n@event.listens_for(Base, \"init\", propagate=True)\ndef intercept_init(instance, args, kwargs):\n    print(\"new transient: %s\" % instance)\n```", "```py\n@event.listens_for(sessionmaker, \"transient_to_pending\")\ndef intercept_transient_to_pending(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_persistent\")\ndef intercept_pending_to_persistent(session, object_):\n    print(\"pending to persistent: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"pending_to_transient\")\ndef intercept_pending_to_transient(session, object_):\n    print(\"transient to pending: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"loaded_as_persistent\")\ndef intercept_loaded_as_persistent(session, object_):\n    print(\"object loaded into persistent state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_transient\")\ndef intercept_persistent_to_transient(session, object_):\n    print(\"persistent to transient: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_deleted\")\ndef intercept_persistent_to_deleted(session, object_):\n    print(\"object was DELETEd, is now in deleted state: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_detached\")\ndef intercept_deleted_to_detached(session, object_):\n    print(\"deleted to detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"persistent_to_detached\")\ndef intercept_persistent_to_detached(session, object_):\n    print(\"object became detached: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"detached_to_persistent\")\ndef intercept_detached_to_persistent(session, object_):\n    print(\"object became persistent again: %s\" % object_)\n```", "```py\n@event.listens_for(sessionmaker, \"deleted_to_persistent\")\ndef intercept_deleted_to_persistent(session, object_):\n    print(\"deleted to persistent: %s\" % object_)\n```"]