["```py\nclass sqlalchemy.sql.functions.AnsiFunction\n```", "```py\nclass sqlalchemy.sql.functions.Function\n```", "```py\n    func.mypackage.some_function(col1, col2)\n    ```", "```py\nmethod __init__(name: str, *clauses: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T] | None = None, packagenames: Tuple[str, ...] | None = None)\n```", "```py\nclass sqlalchemy.sql.functions.FunctionElement\n```", "```py\nmethod __init__(*clauses: _ColumnExpressionOrLiteralArgument[Any])\n```", "```py\nmethod alias(name: str | None = None, joins_implicitly: bool = False) \u2192 TableValuedAlias\n```", "```py\n>>> from sqlalchemy import func, select, column\n>>> data_view = func.unnest([1, 2, 3]).alias(\"data_view\")\n>>> print(select(data_view.column))\nSELECT  data_view\nFROM  unnest(:unnest_1)  AS  data_view \n```", "```py\n>>> data_view = func.unnest([1, 2, 3]).column_valued(\"data_view\")\n>>> print(select(data_view))\nSELECT  data_view\nFROM  unnest(:unnest_1)  AS  data_view \n```", "```py\nmethod as_comparison(left_index: int, right_index: int) \u2192 FunctionAsBinary\n```", "```py\nexpr = func.is_equal(\"a\", \"b\")\n```", "```py\nexpr = func.is_equal(\"a\", \"b\").as_comparison(1, 2)\n```", "```py\nBinaryExpression(\"a\", \"b\", operator=op.eq)\n```", "```py\nclass Venue(Base):\n    __tablename__ = 'venue'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    descendants = relationship(\n        \"Venue\",\n        primaryjoin=func.instr(\n            remote(foreign(name)), name + \"/\"\n        ).as_comparison(1, 2) == 1,\n        viewonly=True,\n        order_by=name\n    )\n```", "```py\nattribute c\n```", "```py\nattribute clauses\n```", "```py\nmethod column_valued(name: str | None = None, joins_implicitly: bool = False) \u2192 TableValuedColumn[_T]\n```", "```py\n>>> from sqlalchemy import select, func\n>>> gs = func.generate_series(1, 5, -1).column_valued()\n>>> print(select(gs))\nSELECT  anon_1\nFROM  generate_series(:generate_series_1,  :generate_series_2,  :generate_series_3)  AS  anon_1 \n```", "```py\ngs = func.generate_series(1, 5, -1).alias().column\n```", "```py\nattribute columns\n```", "```py\n>>> from sqlalchemy import column, select, func\n>>> stmt = select(column('x'), column('y')).select_from(func.myfunction())\n>>> print(stmt)\nSELECT  x,  y  FROM  myfunction() \n```", "```py\nattribute entity_namespace\n```", "```py\nattribute exported_columns\n```", "```py\nmethod filter(*criterion: _ColumnExpressionArgument[bool]) \u2192 Self | FunctionFilter[_T]\n```", "```py\nfunc.count(1).filter(True)\n```", "```py\nfrom sqlalchemy import funcfilter\nfuncfilter(func.count(1), True)\n```", "```py\nmethod over(*, partition_by: _ByArgument | None = None, order_by: _ByArgument | None = None, rows: Tuple[int | None, int | None] | None = None, range_: Tuple[int | None, int | None] | None = None) \u2192 Over[_T]\n```", "```py\nfunc.row_number().over(order_by='x')\n```", "```py\nfrom sqlalchemy import over\nover(func.row_number(), order_by='x')\n```", "```py\nmethod scalar_table_valued(name: str, type_: _TypeEngineArgument[_T] | None = None) \u2192 ScalarFunctionColumn[_T]\n```", "```py\n>>> from sqlalchemy import func, select\n>>> fn = func.jsonb_each(\"{'k', 'v'}\").scalar_table_valued(\"key\")\n>>> print(select(fn))\nSELECT  (jsonb_each(:jsonb_each_1)).key \n```", "```py\nmethod select() \u2192 Select\n```", "```py\ns = select(function_element)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued(*expr: _ColumnExpressionOrStrLabelArgument[Any], **kw: Any) \u2192 TableValuedAlias\n```", "```py\n>>> fn = (\n...     func.generate_series(1, 5).\n...     table_valued(\"value\", \"start\", \"stop\", \"step\")\n... )\n\n>>> print(select(fn))\nSELECT  anon_1.value,  anon_1.start,  anon_1.stop,  anon_1.step\nFROM  generate_series(:generate_series_1,  :generate_series_2)  AS  anon_1\n>>> print(select(fn.c.value, fn.c.stop).where(fn.c.value > 2))\nSELECT  anon_1.value,  anon_1.stop\nFROM  generate_series(:generate_series_1,  :generate_series_2)  AS  anon_1\nWHERE  anon_1.value  >  :value_1 \n```", "```py\n>>> fn = func.generate_series(4, 1, -1).table_valued(\"gen\", with_ordinality=\"ordinality\")\n>>> print(select(fn))\nSELECT  anon_1.gen,  anon_1.ordinality\nFROM  generate_series(:generate_series_1,  :generate_series_2,  :generate_series_3)  WITH  ORDINALITY  AS  anon_1 \n```", "```py\nmethod within_group(*order_by: _ColumnExpressionArgument[Any]) \u2192 WithinGroup[_T]\n```", "```py\nmethod within_group_type(within_group: WithinGroup[_S]) \u2192 TypeEngine | None\n```", "```py\nclass sqlalchemy.sql.functions.GenericFunction\n```", "```py\nfrom sqlalchemy.sql.functions import GenericFunction\nfrom sqlalchemy.types import DateTime\n\nclass as_utc(GenericFunction):\n    type = DateTime()\n    inherit_cache = True\n\nprint(select(func.as_utc()))\n```", "```py\nclass as_utc(GenericFunction):\n    type = DateTime()\n    package = \"time\"\n    inherit_cache = True\n```", "```py\nprint(select(func.time.as_utc()))\n```", "```py\nclass GeoBuffer(GenericFunction):\n    type = Geometry()\n    package = \"geo\"\n    name = \"ST_Buffer\"\n    identifier = \"buffer\"\n    inherit_cache = True\n```", "```py\n>>> print(func.geo.buffer())\nST_Buffer() \n```", "```py\nfrom sqlalchemy.sql import quoted_name\n\nclass GeoBuffer(GenericFunction):\n    type = Geometry()\n    package = \"geo\"\n    name = quoted_name(\"ST_Buffer\", True)\n    identifier = \"buffer\"\n    inherit_cache = True\n```", "```py\n>>> print(func.geo.buffer())\n\"ST_Buffer\"() \n```", "```py\nclass as_utc(GenericFunction[datetime.datetime]):\n    type = DateTime()\n    inherit_cache = True\n```", "```py\nconnection.scalar(select(func.as_utc()))\n```", "```py\nfunction sqlalchemy.sql.functions.register_function(identifier: str, fn: Type[Function[Any]], package: str = '_default') \u2192 None\n```", "```py\nselect(func.count(\"*\")).select_from(some_table)\n```", "```py\nclass sqlalchemy.sql.functions.aggregate_strings\n```", "```py\nstmt = select(func.aggregate_strings(table.c.str_col, \".\"))\n```", "```py\nclass sqlalchemy.sql.functions.array_agg\n```", "```py\nstmt = select(func.array_agg(table.c.values)[2:5])\n```", "```py\nclass sqlalchemy.sql.functions.char_length\n```", "```py\nclass sqlalchemy.sql.functions.coalesce\n```", "```py\nclass sqlalchemy.sql.functions.concat\n```", "```py\n>>> print(select(func.concat('a', 'b')))\nSELECT  concat(:concat_2,  :concat_3)  AS  concat_1 \n```", "```py\n>>> print(select(literal(\"a\") + \"b\"))\nSELECT  :param_1  ||  :param_2  AS  anon_1 \n```", "```py\nclass sqlalchemy.sql.functions.count\n```", "```py\nfrom sqlalchemy import func\nfrom sqlalchemy import select\nfrom sqlalchemy import table, column\n\nmy_table = table('some_table', column('id'))\n\nstmt = select(func.count()).select_from(my_table)\n```", "```py\nSELECT count(*) AS count_1\nFROM some_table\n```", "```py\nclass sqlalchemy.sql.functions.cube\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.cube(table.c.col_1, table.c.col_2))\n```", "```py\nclass sqlalchemy.sql.functions.cume_dist\n```", "```py\nclass sqlalchemy.sql.functions.current_date\n```", "```py\nclass sqlalchemy.sql.functions.current_time\n```", "```py\nclass sqlalchemy.sql.functions.current_timestamp\n```", "```py\nclass sqlalchemy.sql.functions.current_user\n```", "```py\nclass sqlalchemy.sql.functions.dense_rank\n```", "```py\nclass sqlalchemy.sql.functions.grouping_sets\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.grouping_sets(table.c.col_1, table.c.col_2))\n```", "```py\nfrom sqlalchemy import tuple_\n\nstmt = select(\n    func.sum(table.c.value),\n    table.c.col_1, table.c.col_2,\n    table.c.col_3\n).group_by(\n    func.grouping_sets(\n        tuple_(table.c.col_1, table.c.col_2),\n        tuple_(table.c.value, table.c.col_3),\n    )\n)\n```", "```py\nclass sqlalchemy.sql.functions.localtime\n```", "```py\nclass sqlalchemy.sql.functions.localtimestamp\n```", "```py\nclass sqlalchemy.sql.functions.max\n```", "```py\nclass sqlalchemy.sql.functions.min\n```", "```py\nclass sqlalchemy.sql.functions.mode\n```", "```py\nclass sqlalchemy.sql.functions.next_value\n```", "```py\nclass sqlalchemy.sql.functions.now\n```", "```py\nclass sqlalchemy.sql.functions.percent_rank\n```", "```py\nclass sqlalchemy.sql.functions.percentile_cont\n```", "```py\nclass sqlalchemy.sql.functions.percentile_disc\n```", "```py\nclass sqlalchemy.sql.functions.random\n```", "```py\nclass sqlalchemy.sql.functions.rank\n```", "```py\nclass sqlalchemy.sql.functions.rollup\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.rollup(table.c.col_1, table.c.col_2))\n```", "```py\nclass sqlalchemy.sql.functions.session_user\n```", "```py\nclass sqlalchemy.sql.functions.sum\n```", "```py\nclass sqlalchemy.sql.functions.sysdate\n```", "```py\nclass sqlalchemy.sql.functions.user\n```", "```py\nclass sqlalchemy.sql.functions.AnsiFunction\n```", "```py\nclass sqlalchemy.sql.functions.Function\n```", "```py\n    func.mypackage.some_function(col1, col2)\n    ```", "```py\nmethod __init__(name: str, *clauses: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T] | None = None, packagenames: Tuple[str, ...] | None = None)\n```", "```py\nclass sqlalchemy.sql.functions.FunctionElement\n```", "```py\nmethod __init__(*clauses: _ColumnExpressionOrLiteralArgument[Any])\n```", "```py\nmethod alias(name: str | None = None, joins_implicitly: bool = False) \u2192 TableValuedAlias\n```", "```py\n>>> from sqlalchemy import func, select, column\n>>> data_view = func.unnest([1, 2, 3]).alias(\"data_view\")\n>>> print(select(data_view.column))\nSELECT  data_view\nFROM  unnest(:unnest_1)  AS  data_view \n```", "```py\n>>> data_view = func.unnest([1, 2, 3]).column_valued(\"data_view\")\n>>> print(select(data_view))\nSELECT  data_view\nFROM  unnest(:unnest_1)  AS  data_view \n```", "```py\nmethod as_comparison(left_index: int, right_index: int) \u2192 FunctionAsBinary\n```", "```py\nexpr = func.is_equal(\"a\", \"b\")\n```", "```py\nexpr = func.is_equal(\"a\", \"b\").as_comparison(1, 2)\n```", "```py\nBinaryExpression(\"a\", \"b\", operator=op.eq)\n```", "```py\nclass Venue(Base):\n    __tablename__ = 'venue'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    descendants = relationship(\n        \"Venue\",\n        primaryjoin=func.instr(\n            remote(foreign(name)), name + \"/\"\n        ).as_comparison(1, 2) == 1,\n        viewonly=True,\n        order_by=name\n    )\n```", "```py\nattribute c\n```", "```py\nattribute clauses\n```", "```py\nmethod column_valued(name: str | None = None, joins_implicitly: bool = False) \u2192 TableValuedColumn[_T]\n```", "```py\n>>> from sqlalchemy import select, func\n>>> gs = func.generate_series(1, 5, -1).column_valued()\n>>> print(select(gs))\nSELECT  anon_1\nFROM  generate_series(:generate_series_1,  :generate_series_2,  :generate_series_3)  AS  anon_1 \n```", "```py\ngs = func.generate_series(1, 5, -1).alias().column\n```", "```py\nattribute columns\n```", "```py\n>>> from sqlalchemy import column, select, func\n>>> stmt = select(column('x'), column('y')).select_from(func.myfunction())\n>>> print(stmt)\nSELECT  x,  y  FROM  myfunction() \n```", "```py\nattribute entity_namespace\n```", "```py\nattribute exported_columns\n```", "```py\nmethod filter(*criterion: _ColumnExpressionArgument[bool]) \u2192 Self | FunctionFilter[_T]\n```", "```py\nfunc.count(1).filter(True)\n```", "```py\nfrom sqlalchemy import funcfilter\nfuncfilter(func.count(1), True)\n```", "```py\nmethod over(*, partition_by: _ByArgument | None = None, order_by: _ByArgument | None = None, rows: Tuple[int | None, int | None] | None = None, range_: Tuple[int | None, int | None] | None = None) \u2192 Over[_T]\n```", "```py\nfunc.row_number().over(order_by='x')\n```", "```py\nfrom sqlalchemy import over\nover(func.row_number(), order_by='x')\n```", "```py\nmethod scalar_table_valued(name: str, type_: _TypeEngineArgument[_T] | None = None) \u2192 ScalarFunctionColumn[_T]\n```", "```py\n>>> from sqlalchemy import func, select\n>>> fn = func.jsonb_each(\"{'k', 'v'}\").scalar_table_valued(\"key\")\n>>> print(select(fn))\nSELECT  (jsonb_each(:jsonb_each_1)).key \n```", "```py\nmethod select() \u2192 Select\n```", "```py\ns = select(function_element)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued(*expr: _ColumnExpressionOrStrLabelArgument[Any], **kw: Any) \u2192 TableValuedAlias\n```", "```py\n>>> fn = (\n...     func.generate_series(1, 5).\n...     table_valued(\"value\", \"start\", \"stop\", \"step\")\n... )\n\n>>> print(select(fn))\nSELECT  anon_1.value,  anon_1.start,  anon_1.stop,  anon_1.step\nFROM  generate_series(:generate_series_1,  :generate_series_2)  AS  anon_1\n>>> print(select(fn.c.value, fn.c.stop).where(fn.c.value > 2))\nSELECT  anon_1.value,  anon_1.stop\nFROM  generate_series(:generate_series_1,  :generate_series_2)  AS  anon_1\nWHERE  anon_1.value  >  :value_1 \n```", "```py\n>>> fn = func.generate_series(4, 1, -1).table_valued(\"gen\", with_ordinality=\"ordinality\")\n>>> print(select(fn))\nSELECT  anon_1.gen,  anon_1.ordinality\nFROM  generate_series(:generate_series_1,  :generate_series_2,  :generate_series_3)  WITH  ORDINALITY  AS  anon_1 \n```", "```py\nmethod within_group(*order_by: _ColumnExpressionArgument[Any]) \u2192 WithinGroup[_T]\n```", "```py\nmethod within_group_type(within_group: WithinGroup[_S]) \u2192 TypeEngine | None\n```", "```py\nclass sqlalchemy.sql.functions.GenericFunction\n```", "```py\nfrom sqlalchemy.sql.functions import GenericFunction\nfrom sqlalchemy.types import DateTime\n\nclass as_utc(GenericFunction):\n    type = DateTime()\n    inherit_cache = True\n\nprint(select(func.as_utc()))\n```", "```py\nclass as_utc(GenericFunction):\n    type = DateTime()\n    package = \"time\"\n    inherit_cache = True\n```", "```py\nprint(select(func.time.as_utc()))\n```", "```py\nclass GeoBuffer(GenericFunction):\n    type = Geometry()\n    package = \"geo\"\n    name = \"ST_Buffer\"\n    identifier = \"buffer\"\n    inherit_cache = True\n```", "```py\n>>> print(func.geo.buffer())\nST_Buffer() \n```", "```py\nfrom sqlalchemy.sql import quoted_name\n\nclass GeoBuffer(GenericFunction):\n    type = Geometry()\n    package = \"geo\"\n    name = quoted_name(\"ST_Buffer\", True)\n    identifier = \"buffer\"\n    inherit_cache = True\n```", "```py\n>>> print(func.geo.buffer())\n\"ST_Buffer\"() \n```", "```py\nclass as_utc(GenericFunction[datetime.datetime]):\n    type = DateTime()\n    inherit_cache = True\n```", "```py\nconnection.scalar(select(func.as_utc()))\n```", "```py\nfunction sqlalchemy.sql.functions.register_function(identifier: str, fn: Type[Function[Any]], package: str = '_default') \u2192 None\n```", "```py\nselect(func.count(\"*\")).select_from(some_table)\n```", "```py\nclass sqlalchemy.sql.functions.aggregate_strings\n```", "```py\nstmt = select(func.aggregate_strings(table.c.str_col, \".\"))\n```", "```py\nclass sqlalchemy.sql.functions.array_agg\n```", "```py\nstmt = select(func.array_agg(table.c.values)[2:5])\n```", "```py\nclass sqlalchemy.sql.functions.char_length\n```", "```py\nclass sqlalchemy.sql.functions.coalesce\n```", "```py\nclass sqlalchemy.sql.functions.concat\n```", "```py\n>>> print(select(func.concat('a', 'b')))\nSELECT  concat(:concat_2,  :concat_3)  AS  concat_1 \n```", "```py\n>>> print(select(literal(\"a\") + \"b\"))\nSELECT  :param_1  ||  :param_2  AS  anon_1 \n```", "```py\nclass sqlalchemy.sql.functions.count\n```", "```py\nfrom sqlalchemy import func\nfrom sqlalchemy import select\nfrom sqlalchemy import table, column\n\nmy_table = table('some_table', column('id'))\n\nstmt = select(func.count()).select_from(my_table)\n```", "```py\nSELECT count(*) AS count_1\nFROM some_table\n```", "```py\nclass sqlalchemy.sql.functions.cube\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.cube(table.c.col_1, table.c.col_2))\n```", "```py\nclass sqlalchemy.sql.functions.cume_dist\n```", "```py\nclass sqlalchemy.sql.functions.current_date\n```", "```py\nclass sqlalchemy.sql.functions.current_time\n```", "```py\nclass sqlalchemy.sql.functions.current_timestamp\n```", "```py\nclass sqlalchemy.sql.functions.current_user\n```", "```py\nclass sqlalchemy.sql.functions.dense_rank\n```", "```py\nclass sqlalchemy.sql.functions.grouping_sets\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.grouping_sets(table.c.col_1, table.c.col_2))\n```", "```py\nfrom sqlalchemy import tuple_\n\nstmt = select(\n    func.sum(table.c.value),\n    table.c.col_1, table.c.col_2,\n    table.c.col_3\n).group_by(\n    func.grouping_sets(\n        tuple_(table.c.col_1, table.c.col_2),\n        tuple_(table.c.value, table.c.col_3),\n    )\n)\n```", "```py\nclass sqlalchemy.sql.functions.localtime\n```", "```py\nclass sqlalchemy.sql.functions.localtimestamp\n```", "```py\nclass sqlalchemy.sql.functions.max\n```", "```py\nclass sqlalchemy.sql.functions.min\n```", "```py\nclass sqlalchemy.sql.functions.mode\n```", "```py\nclass sqlalchemy.sql.functions.next_value\n```", "```py\nclass sqlalchemy.sql.functions.now\n```", "```py\nclass sqlalchemy.sql.functions.percent_rank\n```", "```py\nclass sqlalchemy.sql.functions.percentile_cont\n```", "```py\nclass sqlalchemy.sql.functions.percentile_disc\n```", "```py\nclass sqlalchemy.sql.functions.random\n```", "```py\nclass sqlalchemy.sql.functions.rank\n```", "```py\nclass sqlalchemy.sql.functions.rollup\n```", "```py\nstmt = select(\n    func.sum(table.c.value), table.c.col_1, table.c.col_2\n).group_by(func.rollup(table.c.col_1, table.c.col_2))\n```", "```py\nclass sqlalchemy.sql.functions.session_user\n```", "```py\nclass sqlalchemy.sql.functions.sum\n```", "```py\nclass sqlalchemy.sql.functions.sysdate\n```", "```py\nclass sqlalchemy.sql.functions.user\n```"]