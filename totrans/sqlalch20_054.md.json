["```py\nclass SomeClass(Base):\n    __tablename__ = \"some_table\"\n\n    # ...\n\n    value = mapped_column(Integer)\n\nsomeobject = session.get(SomeClass, 5)\n\n# set 'value' attribute to a SQL expression adding one\nsomeobject.value = SomeClass.value + 1\n\n# issues \"UPDATE some_table SET value=value+1\"\nsession.commit()\n```", "```py\nclass Foo(Base):\n    __tablename__ = \"foo\"\n    pk = mapped_column(Integer, primary_key=True)\n    bar = mapped_column(Integer)\n\ne = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\nBase.metadata.create_all(e)\n\nsession = Session(e)\n\nfoo = Foo(pk=sql.select(sql.func.coalesce(sql.func.max(Foo.pk) + 1, 1)))\nsession.add(foo)\nsession.commit()\n```", "```py\nINSERT  INTO  foo  (foopk,  bar)  VALUES\n((SELECT  coalesce(max(foo.foopk)  +  %(max_1)s,  %(coalesce_2)s)  AS  coalesce_1\nFROM  foo),  %(bar)s)  RETURNING  foo.foopk\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# execute a string statement\nresult = session.execute(text(\"select * from table where id=:id\"), {\"id\": 7})\n\n# execute a SQL expression construct\nresult = session.execute(select(mytable).where(mytable.c.id == 7))\n```", "```py\nconnection = session.connection()\n```", "```py\nSession = sessionmaker()\nsession = Session()\n\n# need to specify mapper or class when executing\nresult = session.execute(\n    text(\"select * from table where id=:id\"),\n    {\"id\": 7},\n    bind_arguments={\"mapper\": MyMappedClass},\n)\n\nresult = session.execute(\n    select(mytable).where(mytable.c.id == 7), bind_arguments={\"mapper\": MyMappedClass}\n)\n\nconnection = session.connection(MyMappedClass)\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True)\n\nobj = MyObject(id=1)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column omitted; the database\n# itself will persist this as the NULL value\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True, server_default=\"default\")\n\nobj = MyObject(id=1)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column omitted; the database\n# itself will persist this as the value 'default'\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True, server_default=\"default\")\n\nobj = MyObject(id=1, data=None)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set to None;\n# the ORM still omits it from the statement and the\n# database will still persist this as the value 'default'\n```", "```py\nfrom sqlalchemy import null\n\nobj = MyObject(id=1, data=null())\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set as null();\n# the ORM uses this directly, bypassing all client-\n# and server-side defaults, and the database will\n# persist this as the NULL value\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(\n        String(50).evaluates_none(),  # indicate that None should always be passed\n        nullable=True,\n        server_default=\"default\",\n    )\n\nobj = MyObject(id=1, data=None)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set to None;\n# the ORM uses this directly, bypassing all client-\n# and server-side defaults, and the database will\n# persist this as the NULL value\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    # server-side SQL date function generates a new timestamp\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # some other server-side function not named here, such as a trigger,\n    # populates a value into this column during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # set eager defaults to True.  This is usually optional, as if the\n    # backend supports RETURNING + insertmanyvalues, eager defaults\n    # will take place regardless on INSERT\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  DEFAULT  VALUES  RETURNING  my_table.id,  my_table.timestamp,  my_table.special_identifier\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # disable all use of RETURNING for the table\n    __table_args__ = {\"implicit_returning\": False}\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (?);  select  scope_identity()\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n```", "```py\nINSERT  INTO  my_table  ()  VALUES  ()\n\n-- when eager_defaults **is** used, but RETURNING is not supported\nSELECT  my_table.timestamp  AS  my_table_timestamp,  my_table.special_identifier  AS  my_table_special_identifier\nFROM  my_table  WHERE  my_table.id  =  %s\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Sequence(\"my_oracle_seq\"), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (my_oracle_seq.nextval,  :data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MySQLServerModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp: Mapped[datetime.datetime] = mapped_column(\n        TIMESTAMP(), server_default=FetchedValue(), primary_key=True\n    )\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  OUTPUT  inserted.timestamp  VALUES  (?)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(DateTime(), default=func.now(), primary_key=True)\n```", "```py\nSELECT  now()  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n('2018-08-09 13:08:46',)\n```", "```py\nfrom sqlalchemy import cast, Binary\n\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(\n        TIMESTAMP(), default=cast(func.now(), Binary), primary_key=True\n    )\n```", "```py\nSELECT  CAST(now()  AS  BINARY)  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n(b'2018-08-09 13:08:46',)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    created = mapped_column(\n        DateTime(), default=func.now(), server_default=FetchedValue()\n    )\n    updated = mapped_column(\n        DateTime(),\n        onupdate=func.now(),\n        server_default=FetchedValue(),\n        server_onupdate=FetchedValue(),\n    )\n\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  (created)  VALUES  (now())  RETURNING  my_table.id,  my_table.created,  my_table.updated\n\nUPDATE  my_table  SET  updated=now()  WHERE  my_table.id  =  %(my_table_id)s  RETURNING  my_table.updated\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker()\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Session\n\nclass BaseA(DeclarativeBase):\n    pass\n\nclass BaseB(DeclarativeBase):\n    pass\n\nclass User(BaseA): ...\n\nclass Address(BaseA): ...\n\nclass GameInfo(BaseB): ...\n\nclass GameStats(BaseB): ...\n\nSession = sessionmaker()\n\n# all User/Address operations will be on engine 1, all\n# Game operations will be on engine 2\nSession.configure(binds={BaseA: engine1, BaseB: engine2})\n```", "```py\nengines = {\n    \"leader\": create_engine(\"sqlite:///leader.db\"),\n    \"other\": create_engine(\"sqlite:///other.db\"),\n    \"follower1\": create_engine(\"sqlite:///follower1.db\"),\n    \"follower2\": create_engine(\"sqlite:///follower2.db\"),\n}\n\nfrom sqlalchemy.sql import Update, Delete\nfrom sqlalchemy.orm import Session, sessionmaker\nimport random\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None):\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines[\"other\"]\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            # NOTE: this is for example, however in practice reader/writer\n            # splits are likely more straightforward by using two distinct\n            # Sessions at the top of a \"reader\" or \"writer\" operation.\n            # See note below\n            return engines[\"leader\"]\n        else:\n            return engines[random.choice([\"follower1\", \"follower2\"])]\n```", "```py\nSession = sessionmaker(class_=RoutingSession)\n```", "```py\nclass SomeClass(Base):\n    __tablename__ = \"some_table\"\n\n    # ...\n\n    value = mapped_column(Integer)\n\nsomeobject = session.get(SomeClass, 5)\n\n# set 'value' attribute to a SQL expression adding one\nsomeobject.value = SomeClass.value + 1\n\n# issues \"UPDATE some_table SET value=value+1\"\nsession.commit()\n```", "```py\nclass Foo(Base):\n    __tablename__ = \"foo\"\n    pk = mapped_column(Integer, primary_key=True)\n    bar = mapped_column(Integer)\n\ne = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\nBase.metadata.create_all(e)\n\nsession = Session(e)\n\nfoo = Foo(pk=sql.select(sql.func.coalesce(sql.func.max(Foo.pk) + 1, 1)))\nsession.add(foo)\nsession.commit()\n```", "```py\nINSERT  INTO  foo  (foopk,  bar)  VALUES\n((SELECT  coalesce(max(foo.foopk)  +  %(max_1)s,  %(coalesce_2)s)  AS  coalesce_1\nFROM  foo),  %(bar)s)  RETURNING  foo.foopk\n```", "```py\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# execute a string statement\nresult = session.execute(text(\"select * from table where id=:id\"), {\"id\": 7})\n\n# execute a SQL expression construct\nresult = session.execute(select(mytable).where(mytable.c.id == 7))\n```", "```py\nconnection = session.connection()\n```", "```py\nSession = sessionmaker()\nsession = Session()\n\n# need to specify mapper or class when executing\nresult = session.execute(\n    text(\"select * from table where id=:id\"),\n    {\"id\": 7},\n    bind_arguments={\"mapper\": MyMappedClass},\n)\n\nresult = session.execute(\n    select(mytable).where(mytable.c.id == 7), bind_arguments={\"mapper\": MyMappedClass}\n)\n\nconnection = session.connection(MyMappedClass)\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True)\n\nobj = MyObject(id=1)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column omitted; the database\n# itself will persist this as the NULL value\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True, server_default=\"default\")\n\nobj = MyObject(id=1)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column omitted; the database\n# itself will persist this as the value 'default'\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(String(50), nullable=True, server_default=\"default\")\n\nobj = MyObject(id=1, data=None)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set to None;\n# the ORM still omits it from the statement and the\n# database will still persist this as the value 'default'\n```", "```py\nfrom sqlalchemy import null\n\nobj = MyObject(id=1, data=null())\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set as null();\n# the ORM uses this directly, bypassing all client-\n# and server-side defaults, and the database will\n# persist this as the NULL value\n```", "```py\nclass MyObject(Base):\n    __tablename__ = \"my_table\"\n    id = mapped_column(Integer, primary_key=True)\n    data = mapped_column(\n        String(50).evaluates_none(),  # indicate that None should always be passed\n        nullable=True,\n        server_default=\"default\",\n    )\n\nobj = MyObject(id=1, data=None)\nsession.add(obj)\nsession.commit()  # INSERT with the 'data' column explicitly set to None;\n# the ORM uses this directly, bypassing all client-\n# and server-side defaults, and the database will\n# persist this as the NULL value\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    # server-side SQL date function generates a new timestamp\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # some other server-side function not named here, such as a trigger,\n    # populates a value into this column during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # set eager defaults to True.  This is usually optional, as if the\n    # backend supports RETURNING + insertmanyvalues, eager defaults\n    # will take place regardless on INSERT\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  DEFAULT  VALUES  RETURNING  my_table.id,  my_table.timestamp,  my_table.special_identifier\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # disable all use of RETURNING for the table\n    __table_args__ = {\"implicit_returning\": False}\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (?);  select  scope_identity()\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n```", "```py\nINSERT  INTO  my_table  ()  VALUES  ()\n\n-- when eager_defaults **is** used, but RETURNING is not supported\nSELECT  my_table.timestamp  AS  my_table_timestamp,  my_table.special_identifier  AS  my_table_special_identifier\nFROM  my_table  WHERE  my_table.id  =  %s\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Sequence(\"my_oracle_seq\"), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (my_oracle_seq.nextval,  :data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MySQLServerModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp: Mapped[datetime.datetime] = mapped_column(\n        TIMESTAMP(), server_default=FetchedValue(), primary_key=True\n    )\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  OUTPUT  inserted.timestamp  VALUES  (?)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(DateTime(), default=func.now(), primary_key=True)\n```", "```py\nSELECT  now()  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n('2018-08-09 13:08:46',)\n```", "```py\nfrom sqlalchemy import cast, Binary\n\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(\n        TIMESTAMP(), default=cast(func.now(), Binary), primary_key=True\n    )\n```", "```py\nSELECT  CAST(now()  AS  BINARY)  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n(b'2018-08-09 13:08:46',)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    created = mapped_column(\n        DateTime(), default=func.now(), server_default=FetchedValue()\n    )\n    updated = mapped_column(\n        DateTime(),\n        onupdate=func.now(),\n        server_default=FetchedValue(),\n        server_onupdate=FetchedValue(),\n    )\n\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  (created)  VALUES  (now())  RETURNING  my_table.id,  my_table.created,  my_table.updated\n\nUPDATE  my_table  SET  updated=now()  WHERE  my_table.id  =  %(my_table_id)s  RETURNING  my_table.updated\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    # server-side SQL date function generates a new timestamp\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # some other server-side function not named here, such as a trigger,\n    # populates a value into this column during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # set eager defaults to True.  This is usually optional, as if the\n    # backend supports RETURNING + insertmanyvalues, eager defaults\n    # will take place regardless on INSERT\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  DEFAULT  VALUES  RETURNING  my_table.id,  my_table.timestamp,  my_table.special_identifier\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n\n    # disable all use of RETURNING for the table\n    __table_args__ = {\"implicit_returning\": False}\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (?);  select  scope_identity()\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n    timestamp = mapped_column(DateTime(), server_default=func.now())\n\n    # assume a database trigger populates a value into this column\n    # during INSERT\n    special_identifier = mapped_column(String(50), server_default=FetchedValue())\n```", "```py\nINSERT  INTO  my_table  ()  VALUES  ()\n\n-- when eager_defaults **is** used, but RETURNING is not supported\nSELECT  my_table.timestamp  AS  my_table_timestamp,  my_table.special_identifier  AS  my_table_special_identifier\nFROM  my_table  WHERE  my_table.id  =  %s\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MyOracleModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(Sequence(\"my_oracle_seq\"), primary_key=True)\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (my_oracle_seq.nextval,  :data)  RETURNING  my_table.id  INTO  :ret_0\n```", "```py\nclass MySQLServerModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp: Mapped[datetime.datetime] = mapped_column(\n        TIMESTAMP(), server_default=FetchedValue(), primary_key=True\n    )\n    data: Mapped[str] = mapped_column(String(50))\n```", "```py\nINSERT  INTO  my_table  (data)  OUTPUT  inserted.timestamp  VALUES  (?)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(DateTime(), default=func.now(), primary_key=True)\n```", "```py\nSELECT  now()  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n('2018-08-09 13:08:46',)\n```", "```py\nfrom sqlalchemy import cast, Binary\n\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(\n        TIMESTAMP(), default=cast(func.now(), Binary), primary_key=True\n    )\n```", "```py\nSELECT  CAST(now()  AS  BINARY)  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n(b'2018-08-09 13:08:46',)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(DateTime(), default=func.now(), primary_key=True)\n```", "```py\nSELECT  now()  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n('2018-08-09 13:08:46',)\n```", "```py\nfrom sqlalchemy import cast, Binary\n\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    timestamp = mapped_column(\n        TIMESTAMP(), default=cast(func.now(), Binary), primary_key=True\n    )\n```", "```py\nSELECT  CAST(now()  AS  BINARY)  AS  anon_1\nINSERT  INTO  my_table  (timestamp)  VALUES  (%s)\n(b'2018-08-09 13:08:46',)\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id = mapped_column(Integer, primary_key=True)\n\n    created = mapped_column(\n        DateTime(), default=func.now(), server_default=FetchedValue()\n    )\n    updated = mapped_column(\n        DateTime(),\n        onupdate=func.now(),\n        server_default=FetchedValue(),\n        server_onupdate=FetchedValue(),\n    )\n\n    __mapper_args__ = {\"eager_defaults\": True}\n```", "```py\nINSERT  INTO  my_table  (created)  VALUES  (now())  RETURNING  my_table.id,  my_table.created,  my_table.updated\n\nUPDATE  my_table  SET  updated=now()  WHERE  my_table.id  =  %(my_table_id)s  RETURNING  my_table.updated\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker()\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Session\n\nclass BaseA(DeclarativeBase):\n    pass\n\nclass BaseB(DeclarativeBase):\n    pass\n\nclass User(BaseA): ...\n\nclass Address(BaseA): ...\n\nclass GameInfo(BaseB): ...\n\nclass GameStats(BaseB): ...\n\nSession = sessionmaker()\n\n# all User/Address operations will be on engine 1, all\n# Game operations will be on engine 2\nSession.configure(binds={BaseA: engine1, BaseB: engine2})\n```", "```py\nengines = {\n    \"leader\": create_engine(\"sqlite:///leader.db\"),\n    \"other\": create_engine(\"sqlite:///other.db\"),\n    \"follower1\": create_engine(\"sqlite:///follower1.db\"),\n    \"follower2\": create_engine(\"sqlite:///follower2.db\"),\n}\n\nfrom sqlalchemy.sql import Update, Delete\nfrom sqlalchemy.orm import Session, sessionmaker\nimport random\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None):\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines[\"other\"]\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            # NOTE: this is for example, however in practice reader/writer\n            # splits are likely more straightforward by using two distinct\n            # Sessions at the top of a \"reader\" or \"writer\" operation.\n            # See note below\n            return engines[\"leader\"]\n        else:\n            return engines[random.choice([\"follower1\", \"follower2\"])]\n```", "```py\nSession = sessionmaker(class_=RoutingSession)\n```", "```py\nengine1 = create_engine(\"postgresql+psycopg2://db1\")\nengine2 = create_engine(\"postgresql+psycopg2://db2\")\n\nSession = sessionmaker()\n\n# bind User operations to engine 1, Account operations to engine 2\nSession.configure(binds={User: engine1, Account: engine2})\n\nsession = Session()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Session\n\nclass BaseA(DeclarativeBase):\n    pass\n\nclass BaseB(DeclarativeBase):\n    pass\n\nclass User(BaseA): ...\n\nclass Address(BaseA): ...\n\nclass GameInfo(BaseB): ...\n\nclass GameStats(BaseB): ...\n\nSession = sessionmaker()\n\n# all User/Address operations will be on engine 1, all\n# Game operations will be on engine 2\nSession.configure(binds={BaseA: engine1, BaseB: engine2})\n```", "```py\nengines = {\n    \"leader\": create_engine(\"sqlite:///leader.db\"),\n    \"other\": create_engine(\"sqlite:///other.db\"),\n    \"follower1\": create_engine(\"sqlite:///follower1.db\"),\n    \"follower2\": create_engine(\"sqlite:///follower2.db\"),\n}\n\nfrom sqlalchemy.sql import Update, Delete\nfrom sqlalchemy.orm import Session, sessionmaker\nimport random\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None):\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines[\"other\"]\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            # NOTE: this is for example, however in practice reader/writer\n            # splits are likely more straightforward by using two distinct\n            # Sessions at the top of a \"reader\" or \"writer\" operation.\n            # See note below\n            return engines[\"leader\"]\n        else:\n            return engines[random.choice([\"follower1\", \"follower2\"])]\n```", "```py\nSession = sessionmaker(class_=RoutingSession)\n```"]