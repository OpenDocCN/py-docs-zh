- en: custom_vjp and nondiff_argnums update guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jep/4008-custom-vjp-update.html`](https://jax.readthedocs.io/en/latest/jep/4008-custom-vjp-update.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*mattjj@* *Oct 14 2020*'
  prefs: []
  type: TYPE_NORMAL
- en: This doc assumes familiarity with `jax.custom_vjp`, as described in the [Custom
    derivative rules for JAX-transformable Python functions](https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html)
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: What to update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After JAX [PR #4008](https://github.com/google/jax/pull/4008), the arguments
    passed into a `custom_vjp` function’s `nondiff_argnums` can’t be `Tracer`s (or
    containers of `Tracer`s), which basically means to allow for arbitrarily-transformable
    code `nondiff_argnums` shouldn’t be used for array-valued arguments. Instead,
    `nondiff_argnums` should be used only for non-array values, like Python callables
    or shape tuples or strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Wherever we used to use `nondiff_argnums` for array values, we should just pass
    those as regular arguments. In the `bwd` rule, we need to produce values for them,
    but we can just produce `None` values to indicate there’s no corresponding gradient
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s the **old** way to write `clip_gradient`, which won’t work
    when `hi` and/or `lo` are `Tracer`s from some JAX transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the **new**, awesome way, which supports arbitrary transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you use the old way instead of the new way, you’ll get a loud error in any
    case where something might go wrong (namely when there’s a `Tracer` passed into
    a `nondiff_argnums` argument).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a case where we actually need `nondiff_argnums` with `custom_vjp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing `Tracer`s into `nondiff_argnums` arguments was always buggy. While there
    were some cases that worked correctly, others would lead to complex and confusing
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of the bug was that `nondiff_argnums` was implemented in a way that
    acted very much like lexical closure. But lexical closure over `Tracer`s wasn’t
    at the time intended to work with `custom_jvp`/`custom_vjp`. Implementing `nondiff_argnums`
    that way was a mistake!
  prefs: []
  type: TYPE_NORMAL
- en: '**[PR #4008](https://github.com/google/jax/pull/4008) fixes all lexical closure
    issues with `custom_jvp` and `custom_vjp`.** Woohoo! That is, now `custom_jvp`
    and `custom_vjp` functions and rules can close over `Tracer`s to our hearts’ content.
    For all non-autodiff transformations, things will Just Work. For autodiff transformations,
    we’ll get a clear error message about why we can’t differentiate with respect
    to values over which a `custom_jvp` or `custom_vjp` closes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detected differentiation of a custom_jvp function with respect to a closed-over
    value. That isn’t supported because the custom JVP rule only specifies how to
    differentiate the custom_jvp function with respect to explicit input parameters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try passing the closed-over value into the custom_jvp function as an argument,
    and adapting the custom_jvp rule.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In tightening up and robustifying `custom_jvp` and `custom_vjp` in this way,
    we found that allowing `custom_vjp` to accept `Tracer`s in its `nondiff_argnums`
    would take a significant amount of bookkeeping: we’d need to rewrite the user’s
    `fwd` function to return the values as residuals, and rewrite the user’s `bwd`
    function to accept them as normal residuals (rather than accepting them as special
    leading arguments, as happens with `nondiff_argnums`). This seems maybe manageable,
    until you think through how we have to handle arbitrary pytrees! Moreover, that
    complexity isn’t necessary: if user code treats array-like non-differentiable
    arguments just like regular arguments and residuals, everything already works.
    (Before [#4039](https://github.com/google/jax/pull/4039) JAX might’ve complained
    about involving integer-valued inputs and outputs in autodiff, but after [#4039](https://github.com/google/jax/pull/4039)
    those will just work!)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `custom_vjp`, it was easy to make `custom_jvp` work with `nondiff_argnums`
    arguments that were `Tracer`s. So these updates only need to happen with `custom_vjp`.
  prefs: []
  type: TYPE_NORMAL
