["```py\nclass Pixmap\n```", "```py\n__init__(self, colorspace, irect, alpha)\n```", "```py\n__init__(self, colorspace, source)\n```", "```py\n__init__(self, source, mask)\n```", "```py\n__init__(self, source, width, height[, clip])\n```", "```py\n__init__(self, source, alpha=1)\n```", "```py\n>>> # 'pix' is an RGBA pixmap\n>>> pixcolors = pymupdf.Pixmap(pix, 0)    # extract the RGB part (drop alpha)\n>>> pixalpha = pymupdf.Pixmap(None, pix)  # extract the alpha part\n>>> bm = wx.Bitmap.FromBufferAndAlpha(pix.width, pix.height, pixcolors.samples, pixalpha.samples) \n```", "```py\n__init__(self, filename)\n```", "```py\n__init__(self, stream)\n```", "```py\n__init__(self, colorspace, width, height, samples, alpha)\n```", "```py\n__init__(self, doc, xref)\n```", "```py\nclear_with([value[, irect]])\n```", "```py\ntint_with(black, white)\n```", "```py\ngamma_with(gamma)\n```", "```py\nshrink(n)\n```", "```py\npixel(x, y)\n```", "```py\nset_pixel(x, y, color)\n```", "```py\nset_rect(irect, color)\n```", "```py\nset_origin(x, y)\n```", "```py\nset_dpi(xres, yres)\n```", "```py\nset_alpha(alphavalues, premultiply=1, opaque=None)\n```", "```py\ninvert_irect([irect])\n```", "```py\ncopy(source, irect)\n```", "```py\n>>> # safeguard: set top-left of pix1 and pix2 to (0, 0)\n>>> pix1.set_origin(0, 0)\n>>> pix2.set_origin(0, 0)\n>>> # compute top-left coordinates of pix2 region to copy\n>>> x1 = int(pix2.width / 2)\n>>> y1 = int(pix2.height / 2)\n>>> # shift top-left of pix2 such, that the to-be-copied\n>>> # area starts at (0, 0):\n>>> pix2.set_origin(-x1, -y1)\n>>> # now copy ...\n>>> pix1.copy(pix2, (0, 0, x1, y1)) \n```", "```py\nsave(filename, output=None, jpg_quality=95)\n```", "```py\ntobytes(output='png', jpg_quality=95)\n```", "```py\npdfocr_save(filename, compress=True, language='eng', tessdata=None)\n```", "```py\npdfocr_tobytes(compress=True, language='eng', tessdata=None)\n```", "```py\ndoc = pymupdf.open()\nfor imgfile in os.listdir(folder):\n   pix = pymupdf.Pixmap(imgfile)\n   imgpdf = pymupdf.open(\"pdf\", pix.pdfocr_tobytes())\n   doc.insert_pdf(imgpdf)\n   pix = None\n   imgpdf.close()\ndoc.save(\"ocr-images.pdf\") \n```", "```py\npil_save(*args, unmultiply=False, **kwargs)\n```", "```py\npil_tobytes(*args, unmultiply=False, **kwargs)\n```", "```py\nwarp(quad, width, height)\n```", "```py\ncolor_count(colors=False, clip=None)\n```", "```py\ncolor_topusage(clip=None)\n```", "```py\nalpha\n```", "```py\ndigest\n```", "```py\ncolorspace\n```", "```py\nstride\n```", "```py\nis_monochrome\n```", "```py\nis_unicolor\n```", "```py\nirect\n```", "```py\nsamples\n```", "```py\nsamples_mv\n```", "```py\nIn [3]: %timeit len(pix.samples_mv)\n367 ns ± 1.75 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)\nIn [4]: %timeit len(pix.samples)\n3.52 ms ± 57.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) \n```", "```py\nsamples_ptr\n```", "```py\nimg = QtGui.QImage(pix.samples, pix.width, pix.height, format) # (1)\nimg = QtGui.QImage(pix.samples_ptr, pix.width, pix.height, format) # (2) \n```", "```py\nsize\n```", "```py\nwidth\n```", "```py\nw\n```", "```py\nheight\n```", "```py\nh\n```", "```py\nx\n```", "```py\ny\n```", "```py\nn\n```", "```py\nxres\n```", "```py\nyres\n```", "```py\ninterpolate\n```"]