["```py\ne = create_engine(\n    \"mysql+mysqldb://scott:tiger@localhost/test\", connect_args={\"encoding\": \"utf8\"}\n)\n```", "```py\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test?encoding=utf8\")\n```", "```py\nimport time\n\nfrom sqlalchemy import event\n\ndef reconnecting_engine(engine, num_retries, retry_interval):\n    def _run_with_retries(fn, context, cursor_obj, statement, *arg, **kw):\n        for retry in range(num_retries + 1):\n            try:\n                fn(cursor_obj, statement, context=context, *arg)\n            except engine.dialect.dbapi.Error as raw_dbapi_err:\n                connection = context.root_connection\n                if engine.dialect.is_disconnect(raw_dbapi_err, connection, cursor_obj):\n                    if retry > num_retries:\n                        raise\n                    engine.logger.error(\n                        \"disconnection error, retrying operation\",\n                        exc_info=True,\n                    )\n                    connection.invalidate()\n\n                    # use SQLAlchemy 2.0 API if available\n                    if hasattr(connection, \"rollback\"):\n                        connection.rollback()\n                    else:\n                        trans = connection.get_transaction()\n                        if trans:\n                            trans.rollback()\n\n                    time.sleep(retry_interval)\n                    context.cursor = cursor_obj = connection.connection.cursor()\n                else:\n                    raise\n            else:\n                return True\n\n    e = engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    @event.listens_for(e, \"do_execute_no_params\")\n    def do_execute_no_params(cursor_obj, statement, context):\n        return _run_with_retries(\n            context.dialect.do_execute_no_params, context, cursor_obj, statement\n        )\n\n    @event.listens_for(e, \"do_execute\")\n    def do_execute(cursor_obj, statement, parameters, context):\n        return _run_with_retries(\n            context.dialect.do_execute, context, cursor_obj, statement, parameters\n        )\n\n    return e\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\n\nif __name__ == \"__main__\":\n    engine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True)\n\n    def do_a_thing(engine):\n        with engine.begin() as conn:\n            while True:\n                print(\"ping: %s\" % conn.execute(select([1])).scalar())\n                time.sleep(5)\n\n    e = reconnecting_engine(\n        create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True),\n        num_retries=5,\n        retry_interval=2,\n    )\n\n    do_a_thing(e)\n```", "```py\n$ python reconnect_test.py\nping: 1\nping: 1\ndisconnection error, retrying operation\nTraceback (most recent call last):\n  ...\nMySQLdb._exceptions.OperationalError: (2006, 'MySQL server has gone away')\n2020-10-19 16:16:22,624 INFO sqlalchemy.pool.impl.QueuePool Invalidate connection <_mysql.connection open to 'localhost' at 0xf59240>\nping: 1\nping: 1\n...\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.pool import QueuePool\n\nengine = create_engine(\n    \"mysql+mysqldb://scott:tiger@localhost/myisam_database\",\n    pool=QueuePool(reset_on_return=False),\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mydsn\", pool=QueuePool(reset_on_return=\"commit\")\n)\n```", "```py\nengine = create_engine(...)\nconn = engine.connect()\n\n# pep-249 style PoolProxiedConnection (historically called a \"connection fairy\")\nconnection_fairy = conn.connection\n\n# typically to run statements one would get a cursor() from this\n# object\ncursor_obj = connection_fairy.cursor()\n# ... work with cursor_obj\n\n# to bypass \"connection_fairy\", such as to set attributes on the\n# unproxied pep-249 DBAPI connection, use .dbapi_connection\nraw_dbapi_connection = connection_fairy.dbapi_connection\n\n# the same thing is available as .driver_connection (more on this\n# in the next section)\nalso_raw_dbapi_connection = connection_fairy.driver_connection\n```", "```py\nasync def main():\n    engine = create_async_engine(...)\n    conn = await engine.connect()\n\n    # pep-249 style ConnectionFairy connection pool proxy object\n    # presents a sync interface\n    connection_fairy = await conn.get_raw_connection()\n\n    # beneath that proxy is a second proxy which adapts the\n    # asyncio driver into a pep-249 connection object, accessible\n    # via .dbapi_connection as is the same with a sync API\n    sqla_sync_conn = connection_fairy.dbapi_connection\n\n    # the really-real innermost driver connection is available\n    # from the .driver_connection attribute\n    raw_asyncio_connection = connection_fairy.driver_connection\n\n    # work with raw asyncio connection\n    result = await raw_asyncio_connection.execute(...)\n```", "```py\nconn = engine.connect()\nconn.detach()  # detaches the DBAPI connection from the connection pool\nconn.connection.<go nuts>\nconn.close()  # connection is closed for real, the pool replaces it with a new connection\n```", "```py\ne = create_engine(\n    \"mysql+mysqldb://scott:tiger@localhost/test\", connect_args={\"encoding\": \"utf8\"}\n)\n```", "```py\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test?encoding=utf8\")\n```", "```py\nimport time\n\nfrom sqlalchemy import event\n\ndef reconnecting_engine(engine, num_retries, retry_interval):\n    def _run_with_retries(fn, context, cursor_obj, statement, *arg, **kw):\n        for retry in range(num_retries + 1):\n            try:\n                fn(cursor_obj, statement, context=context, *arg)\n            except engine.dialect.dbapi.Error as raw_dbapi_err:\n                connection = context.root_connection\n                if engine.dialect.is_disconnect(raw_dbapi_err, connection, cursor_obj):\n                    if retry > num_retries:\n                        raise\n                    engine.logger.error(\n                        \"disconnection error, retrying operation\",\n                        exc_info=True,\n                    )\n                    connection.invalidate()\n\n                    # use SQLAlchemy 2.0 API if available\n                    if hasattr(connection, \"rollback\"):\n                        connection.rollback()\n                    else:\n                        trans = connection.get_transaction()\n                        if trans:\n                            trans.rollback()\n\n                    time.sleep(retry_interval)\n                    context.cursor = cursor_obj = connection.connection.cursor()\n                else:\n                    raise\n            else:\n                return True\n\n    e = engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    @event.listens_for(e, \"do_execute_no_params\")\n    def do_execute_no_params(cursor_obj, statement, context):\n        return _run_with_retries(\n            context.dialect.do_execute_no_params, context, cursor_obj, statement\n        )\n\n    @event.listens_for(e, \"do_execute\")\n    def do_execute(cursor_obj, statement, parameters, context):\n        return _run_with_retries(\n            context.dialect.do_execute, context, cursor_obj, statement, parameters\n        )\n\n    return e\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\n\nif __name__ == \"__main__\":\n    engine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True)\n\n    def do_a_thing(engine):\n        with engine.begin() as conn:\n            while True:\n                print(\"ping: %s\" % conn.execute(select([1])).scalar())\n                time.sleep(5)\n\n    e = reconnecting_engine(\n        create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True),\n        num_retries=5,\n        retry_interval=2,\n    )\n\n    do_a_thing(e)\n```", "```py\n$ python reconnect_test.py\nping: 1\nping: 1\ndisconnection error, retrying operation\nTraceback (most recent call last):\n  ...\nMySQLdb._exceptions.OperationalError: (2006, 'MySQL server has gone away')\n2020-10-19 16:16:22,624 INFO sqlalchemy.pool.impl.QueuePool Invalidate connection <_mysql.connection open to 'localhost' at 0xf59240>\nping: 1\nping: 1\n...\n```", "```py\nimport time\n\nfrom sqlalchemy import event\n\ndef reconnecting_engine(engine, num_retries, retry_interval):\n    def _run_with_retries(fn, context, cursor_obj, statement, *arg, **kw):\n        for retry in range(num_retries + 1):\n            try:\n                fn(cursor_obj, statement, context=context, *arg)\n            except engine.dialect.dbapi.Error as raw_dbapi_err:\n                connection = context.root_connection\n                if engine.dialect.is_disconnect(raw_dbapi_err, connection, cursor_obj):\n                    if retry > num_retries:\n                        raise\n                    engine.logger.error(\n                        \"disconnection error, retrying operation\",\n                        exc_info=True,\n                    )\n                    connection.invalidate()\n\n                    # use SQLAlchemy 2.0 API if available\n                    if hasattr(connection, \"rollback\"):\n                        connection.rollback()\n                    else:\n                        trans = connection.get_transaction()\n                        if trans:\n                            trans.rollback()\n\n                    time.sleep(retry_interval)\n                    context.cursor = cursor_obj = connection.connection.cursor()\n                else:\n                    raise\n            else:\n                return True\n\n    e = engine.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    @event.listens_for(e, \"do_execute_no_params\")\n    def do_execute_no_params(cursor_obj, statement, context):\n        return _run_with_retries(\n            context.dialect.do_execute_no_params, context, cursor_obj, statement\n        )\n\n    @event.listens_for(e, \"do_execute\")\n    def do_execute(cursor_obj, statement, parameters, context):\n        return _run_with_retries(\n            context.dialect.do_execute, context, cursor_obj, statement, parameters\n        )\n\n    return e\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\n\nif __name__ == \"__main__\":\n    engine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True)\n\n    def do_a_thing(engine):\n        with engine.begin() as conn:\n            while True:\n                print(\"ping: %s\" % conn.execute(select([1])).scalar())\n                time.sleep(5)\n\n    e = reconnecting_engine(\n        create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo_pool=True),\n        num_retries=5,\n        retry_interval=2,\n    )\n\n    do_a_thing(e)\n```", "```py\n$ python reconnect_test.py\nping: 1\nping: 1\ndisconnection error, retrying operation\nTraceback (most recent call last):\n  ...\nMySQLdb._exceptions.OperationalError: (2006, 'MySQL server has gone away')\n2020-10-19 16:16:22,624 INFO sqlalchemy.pool.impl.QueuePool Invalidate connection <_mysql.connection open to 'localhost' at 0xf59240>\nping: 1\nping: 1\n...\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.pool import QueuePool\n\nengine = create_engine(\n    \"mysql+mysqldb://scott:tiger@localhost/myisam_database\",\n    pool=QueuePool(reset_on_return=False),\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mydsn\", pool=QueuePool(reset_on_return=\"commit\")\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.pool import QueuePool\n\nengine = create_engine(\n    \"mysql+mysqldb://scott:tiger@localhost/myisam_database\",\n    pool=QueuePool(reset_on_return=False),\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mydsn\", pool=QueuePool(reset_on_return=\"commit\")\n)\n```", "```py\nengine = create_engine(...)\nconn = engine.connect()\n\n# pep-249 style PoolProxiedConnection (historically called a \"connection fairy\")\nconnection_fairy = conn.connection\n\n# typically to run statements one would get a cursor() from this\n# object\ncursor_obj = connection_fairy.cursor()\n# ... work with cursor_obj\n\n# to bypass \"connection_fairy\", such as to set attributes on the\n# unproxied pep-249 DBAPI connection, use .dbapi_connection\nraw_dbapi_connection = connection_fairy.dbapi_connection\n\n# the same thing is available as .driver_connection (more on this\n# in the next section)\nalso_raw_dbapi_connection = connection_fairy.driver_connection\n```", "```py\nasync def main():\n    engine = create_async_engine(...)\n    conn = await engine.connect()\n\n    # pep-249 style ConnectionFairy connection pool proxy object\n    # presents a sync interface\n    connection_fairy = await conn.get_raw_connection()\n\n    # beneath that proxy is a second proxy which adapts the\n    # asyncio driver into a pep-249 connection object, accessible\n    # via .dbapi_connection as is the same with a sync API\n    sqla_sync_conn = connection_fairy.dbapi_connection\n\n    # the really-real innermost driver connection is available\n    # from the .driver_connection attribute\n    raw_asyncio_connection = connection_fairy.driver_connection\n\n    # work with raw asyncio connection\n    result = await raw_asyncio_connection.execute(...)\n```", "```py\nconn = engine.connect()\nconn.detach()  # detaches the DBAPI connection from the connection pool\nconn.connection.<go nuts>\nconn.close()  # connection is closed for real, the pool replaces it with a new connection\n```", "```py\nasync def main():\n    engine = create_async_engine(...)\n    conn = await engine.connect()\n\n    # pep-249 style ConnectionFairy connection pool proxy object\n    # presents a sync interface\n    connection_fairy = await conn.get_raw_connection()\n\n    # beneath that proxy is a second proxy which adapts the\n    # asyncio driver into a pep-249 connection object, accessible\n    # via .dbapi_connection as is the same with a sync API\n    sqla_sync_conn = connection_fairy.dbapi_connection\n\n    # the really-real innermost driver connection is available\n    # from the .driver_connection attribute\n    raw_asyncio_connection = connection_fairy.driver_connection\n\n    # work with raw asyncio connection\n    result = await raw_asyncio_connection.execute(...)\n```", "```py\nconn = engine.connect()\nconn.detach()  # detaches the DBAPI connection from the connection pool\nconn.connection.<go nuts>\nconn.close()  # connection is closed for real, the pool replaces it with a new connection\n```"]