- en: Tracking queries, object and Session Changes with Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件跟踪查询、对象和会话更改
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_events.html](https://docs.sqlalchemy.org/en/20/orm/session_events.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_events.html](https://docs.sqlalchemy.org/en/20/orm/session_events.html)
- en: SQLAlchemy features an extensive [Event Listening](../core/event.html) system
    used throughout the Core and ORM. Within the ORM, there are a wide variety of
    event listener hooks, which are documented at an API level at [ORM Events](events.html).
    This collection of events has grown over the years to include lots of very useful
    new events as well as some older events that aren’t as relevant as they once were.
    This section will attempt to introduce the major event hooks and when they might
    be used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 特色是一个广泛的[事件监听](../core/event.html)系统，贯穿于核心和 ORM 中。在 ORM 中，有各种各样的事件监听器钩子，这些钩子在[ORM
    事件](events.html)的 API 级别有文档记录。这些事件的集合多年来已经增长，包括许多非常有用的新事件，以及一些曾经不那么相关的旧事件。本节将尝试介绍主要的事件钩子以及它们何时可能被使用。
- en: '## Execute Events'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '## 执行事件'
- en: 'New in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now features a single comprehensive hook designed to
    intercept all SELECT statements made on behalf of the ORM as well as bulk UPDATE
    and DELETE statements. This hook supersedes the previous [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event as well [`QueryEvents.before_compile_update()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_update
    "sqlalchemy.orm.QueryEvents.before_compile_update") and [`QueryEvents.before_compile_delete()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_delete
    "sqlalchemy.orm.QueryEvents.before_compile_delete").'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.4 新增：现在[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")提供了一个单一全面的钩子，用于拦截
    ORM 代表进行的所有 SELECT 语句，以及大量的 UPDATE 和 DELETE 语句。这个钩子取代了以前的[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile")事件以及[`QueryEvents.before_compile_update()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_update
    "sqlalchemy.orm.QueryEvents.before_compile_update")和[`QueryEvents.before_compile_delete()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_delete
    "sqlalchemy.orm.QueryEvents.before_compile_delete")。
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    features a comprehensive system by which all queries invoked via the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which includes all SELECT statements
    emitted by [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    as well as all SELECT statements emitted on behalf of column and relationship
    loaders, may be intercepted and modified. The system makes use of the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook as well as the [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") object to represent the event state.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")提供了一个全面的系统，通过该系统，通过[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法调用的所有查询，包括由[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")发出的所有 SELECT 语句以及代表列和关系加载器发出的所有 SELECT 语句，都可以被拦截和修改。该系统使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件钩子以及[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState")对象来表示事件状态。'
- en: Basic Query Interception
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本查询拦截
- en: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") is firstly useful for any kind
    of interception of a query, which includes those emitted by [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") with [1.x style](../glossary.html#term-1.x-style) as well
    as when an ORM-enabled [2.0 style](../glossary.html#term-2.0-style) [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct is delivered to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") construct provides accessors to allow modifications
    to statements, parameters, and options:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 首先对查询的任何拦截都是有用的，包括由 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 以 [1.x 风格](../glossary.html#term-1.x-style) 发出的查询，以及当
    ORM 启用的 [2.0 风格](../glossary.html#term-2.0-style) 下传递给 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 或 [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 构造。[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") 构造提供了访问器，以允许修改语句、参数和选项：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above example illustrates some simple modifications to SELECT statements.
    At this level, the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook intends to replace the
    previous use of the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, which was not fired off consistently
    for various kinds of loaders; additionally, the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") only applies to [1.x style](../glossary.html#term-1.x-style)
    use with [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    and not with [2.0 style](../glossary.html#term-2.0-style) use of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了对 SELECT 语句进行的一些简单修改。在这个层次上，[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 事件钩子旨在取代之前使用的 [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") 事件，该事件对各种加载器的各种类型并不一致地触发；此外，[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") 仅适用于与 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的 [1.x 风格](../glossary.html#term-1.x-style) 一起使用，而不适用于
    [2.0 风格](../glossary.html#term-2.0-style) 下使用 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")。
- en: '### Adding global WHERE / ON criteria'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加全局的 WHERE / ON 条件'
- en: 'One of the most requested query-extension features is the ability to add WHERE
    criteria to all occurrences of an entity in all queries. This is achievable by
    making use of the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") query option, which may be used on its
    own, or is ideally suited to be used within the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最常请求的查询扩展功能之一是向所有查询中的所有实体添加 WHERE 条件的能力。这可以通过使用 [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 查询选项来实现，该选项可以单独使用，也可以在 [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 事件中使用：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Above, an option is added to all SELECT statements that will limit all queries
    against `MyEntity` to filter on `public == True`. The criteria will be applied
    to **all** loads of that class within the scope of the immediate query. The [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by default will automatically propagate
    to relationship loaders as well, which will apply to subsequent relationship loads,
    which includes lazy loads, selectinloads, etc.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述内容中，为所有SELECT语句添加了一个选项，该选项将限制针对`MyEntity`的所有查询以在`public == True`上进行过滤。该条件将应用于立即查询范围内该类的**所有**加载。[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")选项默认情况下还会自动传播到关系加载程序，这将应用于后续的关系加载，包括惰性加载，selectinloads等。
- en: 'For a series of classes that all feature some common column structure, if the
    classes are composed using a [declarative mixin](extensions/declarative/mixins.html#declarative-mixins),
    the mixin class itself may be used in conjunction with the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by making use of a Python lambda.
    The Python lambda will be invoked at query compilation time against the specific
    entities which match the criteria. Given a series of classes based on a mixin
    called `HasTimestamp`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一系列具有某些共同列结构的类，如果使用[声明性混合](extensions/declarative/mixins.html#declarative-mixins)来组合类，那么混合类本身可以与[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")选项结合使用，通过使用Python lambda来使用。 Python lambda将针对与条件匹配的特定实体在查询编译时调用。假设一系列基于名为`HasTimestamp`的混合物的类：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above classes `SomeEntity` and `SomeOtherEntity` will each have a column
    `timestamp` that defaults to the current date and time. An event may be used to
    intercept all objects that extend from `HasTimestamp` and filter their `timestamp`
    column on a date that is no older than one month ago:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类`SomeEntity`和`SomeOtherEntity`将分别具有一个`timestamp`列，其默认值为当前日期和时间。可以使用事件拦截所有扩展自`HasTimestamp`并过滤其`timestamp`列的对象，使其日期不晚于一个月前：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The use of a lambda inside of the call to [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") is only invoked **once per unique class**.
    Custom functions should not be invoked within this lambda. See [Using Lambdas
    to add significant speed gains to statement production](../core/connections.html#engine-lambda-caching)
    for an overview of the “lambda SQL” feature, which is for advanced use only.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")时使用lambda仅被调用**一次每个唯一类**。在此lambda内部不应调用自定义函数。请参阅[使用Lambda将重要的速度增益添加到语句生成](../core/connections.html#engine-lambda-caching)以获取“lambda
    SQL”功能的概述，该功能仅用于高级用途。
- en: See also
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Query Events](examples.html#examples-session-orm-events) - includes working
    examples of the above [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") recipes.  ### Re-Executing Statements'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询事件](examples.html#examples-session-orm-events) - 包括上述[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")配方的工作示例。 ### 重新执行语句'
- en: Deep Alchemy
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 深度炼金术
- en: the statement re-execution feature involves a slightly intricate recursive sequence,
    and is intended to solve the fairly hard problem of being able to re-route the
    execution of a SQL statement into various non-SQL contexts. The twin examples
    of “dogpile caching” and “horizontal sharding”, linked below, should be used as
    a guide for when this rather advanced feature is appropriate to be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 语句重新执行功能涉及稍微复杂的递归序列，并旨在解决将SQL语句的执行重新路由到各种非SQL上下文的相当困难的问题。下面链接的“狗窝缓存”和“水平分片”的双例应该用作指导，以确定何时适合使用此相当高级的功能。
- en: The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")
    is capable of controlling the execution of the given statement; this includes
    the ability to either not invoke the statement at all, allowing a pre-constructed
    result set retrieved from a cache to be returned instead, as well as the ability
    to invoke the same statement repeatedly with different state, such as invoking
    it against multiple database connections and then merging the results together
    in memory. Both of these advanced patterns are demonstrated in SQLAlchemy’s example
    suite as detailed below.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")能够控制给定语句的执行；这包括能力要么根本不调用语句，而是返回一个从缓存中检索到的预先构建的结果集，要么调用相同的语句多次，每次使用不同的状态，例如对多个数据库连接调用它，然后在内存中合并结果。这两种高级模式都在SQLAlchemy的示例套件中有详细说明。'
- en: When inside the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook, the [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may be used to invoke
    the statement using a new nested invocation of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), which will then preempt the subsequent handling
    of the current execution in progress and instead return the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returned by the inner execution. The event handlers
    thus far invoked for the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook within this process will be
    skipped within this nested call as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件钩子内部时，可以使用[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法来使用新的嵌套调用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来调用语句，这将抢占当前正在进行的执行的后续处理，而是返回内部执行返回的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")。因此，在此过程中已调用的[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")钩子的事件处理程序也将在此嵌套调用中被跳过。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object; this object then features the ability for
    it to be “frozen” into a cacheable format and “unfrozen” into a new [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, as well as for its data to be merged with
    that of other [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象；然后该对象具有冻结为可缓存格式和解冻为新的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的能力，以及将其数据与其他[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的数据合并的能力。'
- en: 'E.g., using [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") to implement a cache:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")来实现缓存：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the above hook in place, an example of using the cache would look like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述钩子生效时，使用缓存的示例如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, a custom execution option is passed to [`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options") in order to establish a
    “cache key” that will then be intercepted by the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. This cache key is then matched
    to a [`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult") object that may be present in the cache, and
    if present, the object is re-used. The recipe makes use of the [`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze") method to “freeze” a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, which above will contain ORM results, such
    that it can be stored in a cache and used multiple times. In order to return a
    live result from the “frozen” result, the `merge_frozen_result()` function is
    used to merge the “frozen” data from the result object into the current session.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子中，自定义的执行选项被传递给[`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options")，以建立一个“缓存键”，然后该键将被[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")钩子拦截。然后，这个缓存键将与可能存在于缓存中的[`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult")对象进行匹配，并且如果存在，则重新使用该对象。该示例利用了[`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze")方法来“冻结”一个包含ORM结果的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，以便它可以被存储在缓存中并多次使用。为了从“冻结”结果中返回一个活动结果，使用`merge_frozen_result()`函数将结果对象中的“冻结”数据合并到当前会话中。
- en: The above example is implemented as a complete example in [Dogpile Caching](examples.html#examples-caching).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子在[Dogpile 缓存](examples.html#examples-caching)中作为一个完整的例子实现。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may also be called multiple
    times, passing along different information to the [`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") parameter such that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will make use of different [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects each time. This will return a different [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object each time; these results can be merged together
    using the [`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge") method. This is the technique employed by the
    [Horizontal Sharding](extensions/horizontal_shard.html) extension; see the source
    code to familiarize.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法也可以被多次调用，传递不同的信息给[`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")参数，以便[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")每次都使用不同的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象。这将每次返回一个不同的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象；这些结果可以使用[`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge")方法合并在一起。这是[水平分片](extensions/horizontal_shard.html)扩展所采用的技术；请查看源代码以熟悉它。'
- en: See also
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dogpile Caching](examples.html#examples-caching)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile 缓存](examples.html#examples-caching)'
- en: '[Horizontal Sharding](examples.html#examples-sharding)  ## Persistence Events'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](examples.html#examples-sharding)  ## 持久化事件'
- en: Probably the most widely used series of events are the “persistence” events,
    which correspond to the [flush process](session_basics.html#session-flushing).
    The flush is where all the decisions are made about pending changes to objects
    and are then emitted out to the database in the form of INSERT, UPDATE, and DELETE
    statements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是最广泛使用的一系列事件是“持久化”事件，它们对应于[刷新过程](session_basics.html#session-flushing)。刷新是所有关于待处理对象更改的决定都会被做出，并以INSERT、UPDATE和DELETE语句的形式发送到数据库的地方。
- en: '`before_flush()`'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`before_flush()`'
- en: The [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook is by far the most generally
    useful event to use when an application wants to ensure that additional persistence
    changes to the database are made when a flush proceeds. Use [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") in order to operate upon objects
    to validate their state as well as to compose additional objects and references
    before they are persisted. Within this event, it is **safe to manipulate the Session’s
    state**, that is, new objects can be attached to it, objects can be deleted, and
    individual attributes on objects can be changed freely, and these changes will
    be pulled into the flush process when the event hook completes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 钩子是当应用程序希望在提交刷新时确保额外的持久性更改被执行时最常用的事件。
    使用 [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 来验证对象的状态并在持久化之前组合其他对象和引用。在此事件中，**可以安全地操纵会话的状态**，即可以附加新对象，删除对象，并且可以自由更改对象上的单个属性，这些更改将在事件钩子完成时被纳入刷新过程中。'
- en: The typical [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook will be tasked with scanning
    the collections [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    in order to look for objects where something will be happening.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 钩子将被指示扫描集合 [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")，以查找将要发生更改的对象。
- en: For illustrations of [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), see examples such as [Versioning
    with a History Table](examples.html#examples-versioned-history) and [Versioning
    using Temporal Rows](examples.html#examples-versioned-rows).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 的示例，请参见[具有历史表的版本控制](examples.html#examples-versioned-history)和[使用时间行进行版本控制](examples.html#examples-versioned-rows)等示例。
- en: '`after_flush()`'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush()`'
- en: The [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook is called after the SQL has been
    emitted for a flush process, but **before** the state of the objects that were
    flushed has been altered. That is, you can still inspect the [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new"), [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collections to see what was just flushed, and
    you can also use history tracking features like the ones provided by [`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState") to see what changes were just persisted. In the
    [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") event, additional SQL can be emitted
    to the database based on what’s observed to have changed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 钩子在刷新过程的 SQL 被生成之后，但在被刷新的对象状态被更改之前调用。也就是说，您仍然可以检查
    [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合，以查看刚刷新的内容，并且还可以使用像 [`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState") 这样的历史跟踪功能来查看刚刚持久化的更改。在 [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 事件中，可以根据观察到的更改向数据库发送额外的 SQL。'
- en: '`after_flush_postexec()`'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush_postexec()`'
- en: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") is called soon after [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush"), but is invoked **after** the state
    of the objects has been modified to account for the flush that just took place.
    The [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    collections are normally completely empty here. Use [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") to inspect the identity map
    for finalized objects and possibly emit additional SQL. In this hook, there is
    the ability to make new changes on objects, which means the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will again go into a “dirty” state; the mechanics of
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    here will cause it to flush **again** if new changes are detected in this hook
    if the flush were invoked in the context of [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"); otherwise, the pending changes will be bundled
    as part of the next normal flush. When the hook detects new changes within a [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), a counter ensures that an endless loop in this
    regard is stopped after 100 iterations, in the case that an [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") hook continually adds new
    state to be flushed each time it is called.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 在[`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 之后不久调用，但是在对象状态已经被修改以考虑刚刚发生的刷新之后调用。[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合通常在此时完全为空。使用 [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 检查最终对象的标识映射，并可能发出附加的 SQL。在这个钩子中，有能力对对象进行新的更改，这意味着
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    再次进入“脏”状态；[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的机制会导致如果在此钩子中检测到新的更改，那么再次刷新如果在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的上下文中调用了刷新；否则，待定更改将作为下一个正常刷新的一部分进行捆绑。当钩子在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 中检测到新的更改时，一个计数器确保在每次调用时，如果 [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 钩子持续添加新状态以刷新，则此方面的无限循环在 100
    次迭代后停止。'
- en: '### Mapper-level Flush Events'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射器级刷新事件'
- en: In addition to the flush-level hooks, there is also a suite of hooks that are
    more fine-grained, in that they are called on a per-object basis and are broken
    out based on INSERT, UPDATE or DELETE within the flush process. These are the
    mapper persistence hooks, and they too are very popular, however these events
    need to be approached more cautiously, as they proceed within the context of the
    flush process that is already ongoing; many operations are not safe to proceed
    here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刷新级别的钩子外，还有一套更精细的钩子，这些钩子更加细致，因为它们是基于每个对象调用的，并且根据刷新过程中的INSERT、UPDATE或DELETE进行分组。这些是映射器持久性钩子，它们也非常受欢迎，但是需要更加谨慎地对待这些事件，因为它们在已经进行的刷新过程的上下文中进行；在这里进行许多操作是不安全的。
- en: 'The events are:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件是：
- en: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert")'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert") '
- en: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert")'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert") '
- en: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
- en: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
- en: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
- en: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that these events apply **only** to the [session flush
    operation](session_basics.html#session-flushing) , and **not** to the ORM-level
    INSERT/UPDATE/DELETE functionality described at [ORM-Enabled INSERT, UPDATE, and
    DELETE statements](queryguide/dml.html#orm-expression-update-delete). To intercept
    ORM-level DML, use the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些事件仅适用于[会话刷新操作](session_basics.html#session-flushing)，而不适用于在[ORM-启用的INSERT、UPDATE和DELETE语句](queryguide/dml.html#orm-expression-update-delete)中描述的ORM级别的INSERT/UPDATE/DELETE功能。要拦截ORM级别的DML，请使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。
- en: Each event is passed the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    the mapped object itself, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which is being used to emit an INSERT, UPDATE
    or DELETE statement. The appeal of these events is clear, in that if an application
    wants to tie some activity to when a specific type of object is persisted with
    an INSERT, the hook is very specific; unlike the [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") event, there’s no need to search
    through collections like [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new") in order to find targets. However, the flush plan
    which represents the full list of every single INSERT, UPDATE, DELETE statement
    to be emitted has *already been decided* when these events are called, and no
    changes may be made at this stage. Therefore the only changes that are even possible
    to the given objects are upon attributes **local** to the object’s row. Any other
    change to the object or other objects will impact the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), which will fail to function properly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都会传递[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")、映射对象本身以及用于发出INSERT、UPDATE或DELETE语句的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。这些事件的吸引力显而易见，因为如果应用程序想要将某些活动绑定到特定类型的对象在INSERT时被持久化的时间，钩子就非常具体；不像[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")事件，不需要搜索诸如[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")之类的集合以找到目标。然而，当调用这些事件时，表示完整列表的刷新计划，即将发出的每个单独的INSERT、UPDATE、DELETE语句已经**已经决定**，在这个阶段不允许进行任何更改。因此，甚至对于给定对象的其他属性也只能进行**局部**更改。对对象或其他对象的任何其他更改将影响[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态，这将导致其无法正常运行。
- en: 'Operations that are not supported within these mapper-level persistence events
    include:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些映射器级持久性事件中不支持的操作包括：
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
- en: Mapped collection append, add, remove, delete, discard, etc.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射集合追加、添加、移除、删除、丢弃等操作。
- en: Mapped relationship attribute set/del events, i.e. `someobject.related = someotherobject`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射关系属性设置/删除事件，即`someobject.related = someotherobject`
- en: The reason the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is passed is that it is encouraged that **simple
    SQL operations take place here**, directly on the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), such as incrementing counters or inserting extra
    rows within log tables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 传递[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")的原因是鼓励**在这里进行简单的
    SQL 操作**，直接在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上进行，例如在日志表中递增计数器或插入额外行。
- en: 'There are also many per-object operations that don’t need to be handled within
    a flush event at all. The most common alternative is to simply establish additional
    state along with an object inside its `__init__()` method, such as creating additional
    objects that are to be associated with the new object. Using validators as described
    in [Simple Validators](mapped_attributes.html#simple-validators) is another approach;
    these functions can intercept changes to attributes and establish additional state
    changes on the target object in response to the attribute change. With both of
    these approaches, the object is in the correct state before it ever gets to the
    flush step.  ## Object Lifecycle Events'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 也有许多每个对象操作根本不需要在刷新事件中处理。最常见的替代方法是在对象的`__init__()`方法中简单地建立额外的状态，例如创建要与新对象关联的其他对象。使用[Simple
    Validators](mapped_attributes.html#simple-validators)中描述的验证器是另一种方法；这些函数可以拦截属性的更改，并在响应属性更改时在目标对象上建立额外的状态更改。使用这两种方法，对象在到达刷新步骤之前就处于正确的状态。##
    对象生命周期事件
- en: Another use case for events is to track the lifecycle of objects. This refers
    to the states first introduced at [Quickie Intro to Object States](session_state_management.html#session-object-states).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的另一个用例是跟踪对象的生命周期。这指的是首次介绍于[Quickie Intro to Object States](session_state_management.html#session-object-states)的状态。
- en: 'All the states above can be tracked fully with events. Each event represents
    a distinct state transition, meaning, the starting state and the destination state
    are both part of what are tracked. With the exception of the initial transient
    event, all the events are in terms of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object or class, meaning they can be associated either
    with a specific [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述状态都可以完全通过事件进行跟踪。每个事件代表着一个独立的状态转换，意味着起始状态和目标状态都是被跟踪的一部分。除了初始的瞬态事件之外，所有事件都是以[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象或类的形式出现的，这意味着它们可以与特定的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象关联：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class itself, as well as with a specific [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"), which is likely the most useful form:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")类本身，以及特定的[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")，这可能是最有用的形式：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The listeners can of course be stacked on top of one function, as is likely
    to be common. For example, to track all objects that are entering the persistent
    state:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器当然可以堆叠在一个函数上，这很可能是常见的情况。例如，要跟踪所有进入持久状态的对象：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Transient
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瞬态
- en: 'All mapped objects when first constructed start out as [transient](../glossary.html#term-transient).
    In this state, the object exists alone and doesn’t have an association with any
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    For this initial state, there’s no specific “transition” event since there is
    no [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    however if one wanted to intercept when any transient object is created, the [`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init") method is probably the best event. This
    event is applied to a specific class or superclass. For example, to intercept
    all new objects for a particular declarative base:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有映射对象在首次构建时都是[瞬态](../glossary.html#term-transient)的。在这种状态下，对象独立存在，不与任何[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。对于这种初始状态，没有特定的“转换”事件，因为没有[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，但是如果想要拦截任何瞬态对象被创建时，[`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init")方法可能是最好的事件。此事件应用于特定类或超类。例如，要拦截特定声明基类的所有新对象：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Transient to Pending
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瞬态到待定
- en: 'The transient object becomes [pending](../glossary.html#term-pending) when
    it is first associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") method. An object may also become part of a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as a result of a [“cascade”](cascades.html#unitofwork-cascades) from a referencing
    object that was explicitly added. The transient to pending transition is detectable
    using the [`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending") event:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当瞬态对象首次通过[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")或[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")方法与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联时，瞬态对象变为[待定](../glossary.html#term-pending)。对象也可能作为引用对象的“级联”结果成为[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的一部分，该引用对象是显式添加的。使用[`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending")事件检测瞬态到待定的转换过程：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pending to Persistent
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 待定到持久化
- en: 'The [pending](../glossary.html#term-pending) object becomes [persistent](../glossary.html#term-persistent)
    when a flush proceeds and an INSERT statement takes place for the instance. The
    object now has an identity key. Track pending to persistent with the [`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent") event:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个刷新操作进行并且为实例执行INSERT语句时，[待定](../glossary.html#term-pending)对象变为[持久化](../glossary.html#term-persistent)。该对象现在具有标识键。使用[`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent")事件跟踪待定到持久化的过程：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pending to Transient
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 待定到瞬态
- en: 'The [pending](../glossary.html#term-pending) object can revert back to [transient](../glossary.html#term-transient)
    if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called before the pending object
    has been flushed, or if the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") method is called for the object before it is
    flushed. Track pending to transient with the [`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient") event:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在待定对象被刷新之前调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，或者在刷新对象之前调用[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")方法，则[待定](../glossary.html#term-pending)对象可以回退到[瞬态](../glossary.html#term-transient)状态。使用[`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient")事件跟踪待定到瞬态的过程：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Loaded as Persistent
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为持久化加载
- en: 'Objects can appear in the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") directly in the [persistent](../glossary.html#term-persistent)
    state when they are loaded from the database. Tracking this state transition is
    synonymous with tracking objects as they are loaded, and is synonymous with using
    the [`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load "sqlalchemy.orm.InstanceEvents.load")
    instance-level event. However, the [`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") event is provided as a session-centric
    hook for intercepting objects as they enter the persistent state via this particular
    avenue:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象从数据库加载时，它们可以直接进入 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的 [persistent](../glossary.html#term-persistent) 状态。跟踪此状态转换等同于跟踪对象加载的方式，并且等同于使用
    [`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load "sqlalchemy.orm.InstanceEvents.load")
    实例级事件。但是，[`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") 事件作为一个会话中心的钩子提供，用于拦截通过这种特定方式进入持久化状态的对象：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Persistent to Transient
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化到瞬时
- en: 'The persistent object can revert to the transient state if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called for a transaction where the
    object was first added as pending. In the case of the ROLLBACK, the INSERT statement
    that made this object persistent is rolled back, and the object is evicted from
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to again become transient. Track objects that were reverted to transient from
    persistent using the [`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient") event hook:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果针对对象首次作为待处理对象添加的事务调用了 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，持久化对象可以恢复到瞬时状态。在 ROLLBACK 的情况下，将该对象持久化的
    INSERT 语句回滚，并将对象从 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中驱逐，使其再次成为瞬时状态。使用 [`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient") 事件钩子跟踪从持久化恢复为瞬时的对象：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Persistent to Deleted
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化到删除
- en: The persistent object enters the [deleted](../glossary.html#term-deleted) state
    when an object marked for deletion is deleted from the database within the flush
    process. Note that this is **not the same** as when the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method is called for a target object. The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method only **marks** the object for deletion;
    the actual DELETE statement is not emitted until the flush proceeds. It is subsequent
    to the flush that the “deleted” state is present for the target object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 flush 过程中从数据库中删除了标记为删除的对象时，持久化对象进入 [deleted](../glossary.html#term-deleted)
    状态。请注意，这**与**调用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 方法删除目标对象时**并不相同**。[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 方法只是将对象标记为删除；直到 flush 进行之后才会发出实际的 DELETE 语句。在
    flush 进行之后，目标对象的“deleted”状态才存在。
- en: Within the “deleted” state, the object is only marginally associated with the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    It is not present in the identity map nor is it present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection that refers to when it was pending
    for deletion.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在“deleted”状态中，对象与 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仅有轻微关联。它既不在标识映射中，也不在指示其曾待删除的 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合中。
- en: From the “deleted” state, the object can go either to the detached state when
    the transaction is committed, or back to the persistent state if the transaction
    is instead rolled back.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从“deleted”状态，当事务提交时，对象可以进入分离状态，或者如果事务被回滚，则可以重新进入持久化状态。
- en: 'Track the persistent to deleted transition with [`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted"):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") 跟踪持久化到删除的转换：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleted to Detached
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已删除到已分离
- en: 'The deleted object becomes [detached](../glossary.html#term-detached) when
    the session’s transaction is committed. After the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method is called, the database transaction is
    final and the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    now fully discards the deleted object and removes all associations to it. Track
    the deleted to detached transition using [`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached"):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话的事务提交时，已删除对象将变为[分离](../glossary.html#term-detached)。在调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 方法后，数据库事务已完成，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 现在完全丢弃了已删除对象并删除了所有与其相关的关联。使用 [`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") 跟踪已删除到分离的转换：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the object is in the deleted state, the [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") attribute, accessible using `inspect(object).deleted`,
    returns True. However when the object is detached, [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") will again return False. To detect that
    an object was deleted, regardless of whether or not it is detached, use the [`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象处于已删除状态时，[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 属性，可使用 `inspect(object).deleted` 访问，将返回
    True。但是，当对象分离时，[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") 将再次返回 False。要检测对象是否已删除，无论它是否已分离，请使用 [`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") 访问器。
- en: Persistent to Detached
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久到分离
- en: The persistent object becomes [detached](../glossary.html#term-detached) when
    the object is de-associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), via the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge"), [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象与 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    解除关联时，通过 [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")、[`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") 或 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法，持久对象将变为[分离](../glossary.html#term-detached)状态。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An object may also become **implicitly detached** if its owning [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is dereferenced by the application and discarded due
    to garbage collection. In this case, **no event is emitted**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象的拥有者 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    被应用程序解除引用并由于垃圾回收而被丢弃，该对象也可能会**隐式分离**。在这种情况下，**不会发出任何事件**。
- en: 'Track objects as they move from persistent to detached using the [`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached") event:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached") 事件跟踪对象从持久状态转为分离状态：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Detached to Persistent
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离到持久
- en: 'The detached object becomes persistent when it is re-associated with a session
    using the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    or equivalent method. Track objects moving back to persistent from detached using
    the [`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent") event:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当分离对象使用 [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    或等效方法重新关联到会话时，它将变为持久对象。跟踪对象从分离状态返回持久状态时使用 [`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent") 事件：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deleted to Persistent
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已删除到持久
- en: 'The [deleted](../glossary.html#term-deleted) object can be reverted to the
    [persistent](../glossary.html#term-persistent) state when the transaction in which
    it was DELETEd was rolled back using the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method. Track deleted objects moving back to
    the persistent state using the [`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") event:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除对象在其所在的事务被回滚时，可以将其恢复为[持久](../glossary.html#term-persistent)状态，使用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法回滚。使用[`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent")事件跟踪将删除的对象移回持久状态：
- en: '[PRE19]  ## Transaction Events'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]  ## 事务事件'
- en: Transaction events allow an application to be notified when transaction boundaries
    occur at the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    level as well as when the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") changes the transactional state on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事务事件允许应用在[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")级别上发生事务边界时收到通知，以及当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")更改[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象上的事务状态时。
- en: '[`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create"), [`SessionEvents.after_transaction_end()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end") - these events track the
    logical transaction scopes of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in a way that is not specific to individual database
    connections. These events are intended to help with integration of transaction-tracking
    systems such as `zope.sqlalchemy`. Use these events when the application needs
    to align some external scope with the transactional scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). These hooks mirror the “nested” transactional behavior
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    in that they track logical “subtransactions” as well as “nested” (e.g. SAVEPOINT)
    transactions.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")，[`SessionEvents.after_transaction_end()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end") - 这些事件跟踪[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的逻辑事务范围，不特定于单个数据库连接。这些事件旨在帮助集成事务跟踪系统，如`zope.sqlalchemy`。当应用程序需要将某些外部范围与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的事务范围对齐时，请使用这些事件。这些挂钩反映了[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的“嵌套”事务行为，因为它们跟踪逻辑“子事务”以及“嵌套”（例如，SAVEPOINT）事务。'
- en: '[`SessionEvents.before_commit()`](events.html#sqlalchemy.orm.SessionEvents.before_commit
    "sqlalchemy.orm.SessionEvents.before_commit"), [`SessionEvents.after_commit()`](events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit"), [`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin"), [`SessionEvents.after_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback"), [`SessionEvents.after_soft_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_soft_rollback
    "sqlalchemy.orm.SessionEvents.after_soft_rollback") - These events allow tracking
    of transaction events from the perspective of database connections. [`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin") in particular is a per-connection
    event; a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that maintains more than one connection will emit this event for each connection
    individually as those connections become used within the current transaction.
    The rollback and commit events then refer to when the DBAPI connections themselves
    have received rollback or commit instructions directly.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SessionEvents.before_commit()`](events.html#sqlalchemy.orm.SessionEvents.before_commit
    "sqlalchemy.orm.SessionEvents.before_commit")、[`SessionEvents.after_commit()`](events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit")、[`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin")、[`SessionEvents.after_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback")、[`SessionEvents.after_soft_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_soft_rollback
    "sqlalchemy.orm.SessionEvents.after_soft_rollback") - 这些事件允许从数据库连接的角度跟踪事务事件。特别是[`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin")是一个每个连接的事件；一个维护多个连接的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将为每个连接在当前事务中使用时单独发出此事件。然后回滚和提交事件指的是 DBAPI 连接自身直接接收回滚或提交指令的时候。'
- en: Attribute Change Events
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性更改事件
- en: The attribute change events allow interception of when specific attributes on
    an object are modified. These events include [`AttributeEvents.set()`](events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), and [`AttributeEvents.remove()`](events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove"). These events are extremely useful, particularly
    for per-object validation operations; however, it is often much more convenient
    to use a “validator” hook, which uses these hooks behind the scenes; see [Simple
    Validators](mapped_attributes.html#simple-validators) for background on this.
    The attribute events are also behind the mechanics of backreferences. An example
    illustrating use of attribute events is in [Attribute Instrumentation](examples.html#examples-instrumentation).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 属性更改事件允许拦截对象上特定属性被修改的时机。这些事件包括[`AttributeEvents.set()`](events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set")、[`AttributeEvents.append()`](events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append")和[`AttributeEvents.remove()`](events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove")。这些事件非常有用，特别是对于每个对象的验证操作；然而，使用“验证器”钩子通常更加方便，它在幕后使用这些钩子；请参阅[Simple
    Validators](mapped_attributes.html#simple-validators)以了解背景信息。属性事件也是反向引用机制的基础。一个说明属性事件使用的示例在[Attribute
    Instrumentation](examples.html#examples-instrumentation)中。
- en: '## Execute Events'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '## 执行事件'
- en: 'New in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now features a single comprehensive hook designed to
    intercept all SELECT statements made on behalf of the ORM as well as bulk UPDATE
    and DELETE statements. This hook supersedes the previous [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event as well [`QueryEvents.before_compile_update()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_update
    "sqlalchemy.orm.QueryEvents.before_compile_update") and [`QueryEvents.before_compile_delete()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_delete
    "sqlalchemy.orm.QueryEvents.before_compile_delete").'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4中新增：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")现在具有一个全面的钩子，旨在拦截所有代表ORM执行的SELECT语句以及批量UPDATE和DELETE语句。这个钩子取代了之前的[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile")事件以及[`QueryEvents.before_compile_update()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_update
    "sqlalchemy.orm.QueryEvents.before_compile_update")和[`QueryEvents.before_compile_delete()`](events.html#sqlalchemy.orm.QueryEvents.before_compile_delete
    "sqlalchemy.orm.QueryEvents.before_compile_delete")。
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    features a comprehensive system by which all queries invoked via the [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which includes all SELECT statements
    emitted by [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    as well as all SELECT statements emitted on behalf of column and relationship
    loaders, may be intercepted and modified. The system makes use of the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook as well as the [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") object to represent the event state.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")具有一个全面的系统，通过该系统可以拦截和修改通过[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法调用的所有查询，其中包括由[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")发出的所有SELECT语句以及所有代表列和关系加载程序发出的SELECT语句。该系统利用了[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件钩子以及[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState")对象来表示事件状态。'
- en: Basic Query Interception
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本查询拦截
- en: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") is firstly useful for any kind
    of interception of a query, which includes those emitted by [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") with [1.x style](../glossary.html#term-1.x-style) as well
    as when an ORM-enabled [2.0 style](../glossary.html#term-2.0-style) [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct is delivered to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") construct provides accessors to allow modifications
    to statements, parameters, and options:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")首先对查询的任何拦截都是有用的，这包括由[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")发出的[1.x风格](../glossary.html#term-1.x-style)以及当ORM启用的[2.0风格](../glossary.html#term-2.0-style)的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")或[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造被传递给[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时。[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState")构造提供了访问器，允许修改语句、参数和选项：'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The above example illustrates some simple modifications to SELECT statements.
    At this level, the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook intends to replace the
    previous use of the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, which was not fired off consistently
    for various kinds of loaders; additionally, the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") only applies to [1.x style](../glossary.html#term-1.x-style)
    use with [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    and not with [2.0 style](../glossary.html#term-2.0-style) use of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例说明了对 SELECT 语句的一些简单修改。在这个级别上，[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 事件钩子旨在替换以前对各种加载器不一致触发的 [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") 事件的使用；此外，[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") 仅适用于 [1.x 样式](../glossary.html#term-1.x-style)
    与 [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    一起使用，并不适用于 [2.0 样式](../glossary.html#term-2.0-style) 与 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 一起使用。
- en: '### Adding global WHERE / ON criteria'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加全局 WHERE / ON 条件'
- en: 'One of the most requested query-extension features is the ability to add WHERE
    criteria to all occurrences of an entity in all queries. This is achievable by
    making use of the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") query option, which may be used on its
    own, or is ideally suited to be used within the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最常请求的查询扩展功能之一是能够向所有查询中的所有实体添加 WHERE 条件。通过使用 [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 查询选项，可以实现此目的，该选项可以单独使用，或者最好在 [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 事件中使用：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Above, an option is added to all SELECT statements that will limit all queries
    against `MyEntity` to filter on `public == True`. The criteria will be applied
    to **all** loads of that class within the scope of the immediate query. The [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by default will automatically propagate
    to relationship loaders as well, which will apply to subsequent relationship loads,
    which includes lazy loads, selectinloads, etc.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，所有 SELECT 语句都添加了一个选项，将限制针对 `MyEntity` 的所有查询，以在 `public == True` 上进行过滤。这些条件将应用于立即查询范围内该类的**所有**加载。[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 选项默认情况下也会自动传播到关系加载器，这将应用于后续的关系加载，包括延迟加载、selectinloads
    等。
- en: 'For a series of classes that all feature some common column structure, if the
    classes are composed using a [declarative mixin](extensions/declarative/mixins.html#declarative-mixins),
    the mixin class itself may be used in conjunction with the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by making use of a Python lambda.
    The Python lambda will be invoked at query compilation time against the specific
    entities which match the criteria. Given a series of classes based on a mixin
    called `HasTimestamp`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一系列具有某些共同列结构的类，如果这些类使用 [declarative mixin](extensions/declarative/mixins.html#declarative-mixins)
    进行组合，那么 mixin 类本身可以与 [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 选项结合使用，方法是使用 Python lambda。Python lambda
    将在查询编译时针对符合条件的特定实体被调用。假设有一系列基于名为 `HasTimestamp` 的 mixin 的类：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The above classes `SomeEntity` and `SomeOtherEntity` will each have a column
    `timestamp` that defaults to the current date and time. An event may be used to
    intercept all objects that extend from `HasTimestamp` and filter their `timestamp`
    column on a date that is no older than one month ago:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类 `SomeEntity` 和 `SomeOtherEntity` 将分别具有一个默认为当前日期和时间的列 `timestamp`。可以使用事件拦截从
    `HasTimestamp` 扩展的所有对象，并在一个月前之内的日期上过滤它们的 `timestamp` 列：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Warning
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The use of a lambda inside of the call to [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") is only invoked **once per unique class**.
    Custom functions should not be invoked within this lambda. See [Using Lambdas
    to add significant speed gains to statement production](../core/connections.html#engine-lambda-caching)
    for an overview of the “lambda SQL” feature, which is for advanced use only.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")时使用 lambda 只会**每个唯一类调用一次**。在此 lambda 内部不应调用自定义函数。有关“lambda
    SQL”功能的概述，请参阅[使用 Lambda 为语句生成带来显著速度提升](../core/connections.html#engine-lambda-caching)，这仅适用于高级用法。
- en: See also
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Query Events](examples.html#examples-session-orm-events) - includes working
    examples of the above [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") recipes.  ### Re-Executing Statements'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询事件](examples.html#examples-session-orm-events) - 包括上述[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")示例的工作示例。### 重新执行语句'
- en: Deep Alchemy
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 深度炼金术
- en: the statement re-execution feature involves a slightly intricate recursive sequence,
    and is intended to solve the fairly hard problem of being able to re-route the
    execution of a SQL statement into various non-SQL contexts. The twin examples
    of “dogpile caching” and “horizontal sharding”, linked below, should be used as
    a guide for when this rather advanced feature is appropriate to be used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重新执行功能涉及稍微复杂的递归序列，并旨在解决能够将 SQL 语句的执行重新路由到各种非 SQL 上下文的相当困难的问题。下面链接的“狗窝缓存”和“水平分片”这两个示例应该作为指导，指出何时适合使用这个相当高级的功能。
- en: The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")
    is capable of controlling the execution of the given statement; this includes
    the ability to either not invoke the statement at all, allowing a pre-constructed
    result set retrieved from a cache to be returned instead, as well as the ability
    to invoke the same statement repeatedly with different state, such as invoking
    it against multiple database connections and then merging the results together
    in memory. Both of these advanced patterns are demonstrated in SQLAlchemy’s example
    suite as detailed below.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")能够控制给定语句的执行；这包括不执行语句的能力，允许从缓存中检索到的预构建结果集返回，以及多次以不同状态调用相同语句的能力，例如针对多个数据库连接调用它，然后在内存中合并结果。这两种高级模式在
    SQLAlchemy 的示例套件中有详细展示。'
- en: When inside the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook, the [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may be used to invoke
    the statement using a new nested invocation of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), which will then preempt the subsequent handling
    of the current execution in progress and instead return the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returned by the inner execution. The event handlers
    thus far invoked for the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook within this process will be
    skipped within this nested call as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当在[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件钩子内部时，可以使用[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法来使用新的嵌套调用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来调用语句，这将预先中断当前正在进行的执行的后续处理，而是返回内部执行返回的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")。在此过程中为[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")钩子调用的事件处理程序也将在此嵌套调用中被跳过。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object; this object then features the ability for
    it to be “frozen” into a cacheable format and “unfrozen” into a new [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, as well as for its data to be merged with
    that of other [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    objects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象；该对象具有将其“冻结”为可缓存格式并“解冻”为新的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的能力，以及将其数据与其他[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的数据合并的能力。'
- en: 'E.g., using [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") to implement a cache:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")来实现缓存：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the above hook in place, an example of using the cache would look like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述钩子，使用缓存的示例如下：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Above, a custom execution option is passed to [`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options") in order to establish a
    “cache key” that will then be intercepted by the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. This cache key is then matched
    to a [`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult") object that may be present in the cache, and
    if present, the object is re-used. The recipe makes use of the [`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze") method to “freeze” a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, which above will contain ORM results, such
    that it can be stored in a cache and used multiple times. In order to return a
    live result from the “frozen” result, the `merge_frozen_result()` function is
    used to merge the “frozen” data from the result object into the current session.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，在[`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options")中传递了一个自定义执行选项，以建立一个“缓存键”，然后会被[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")钩子拦截。这个缓存键然后会与可能存在于缓存中的[`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult")对象匹配，如果存在，则会重新使用该对象。该示例利用了[`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze")方法来“冻结”一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，其中将包含ORM结果，以便将其存储在缓存中并多次使用。为了从“冻结”结果中返回一个实时结果，使用`merge_frozen_result()`函数将结果对象中的“冻结”数据合并到当前会话中。
- en: The above example is implemented as a complete example in [Dogpile Caching](examples.html#examples-caching).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例在[Dogpile Caching](examples.html#examples-caching)中作为一个完整示例实现。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may also be called multiple
    times, passing along different information to the [`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") parameter such that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will make use of different [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects each time. This will return a different [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object each time; these results can be merged together
    using the [`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge") method. This is the technique employed by the
    [Horizontal Sharding](extensions/horizontal_shard.html) extension; see the source
    code to familiarize.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") 方法也可以被多次调用，传递不同的信息给 [`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") 参数，以便 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 每次都使用不同的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象。每次都会返回一个不同的 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象；这些结果可以使用 [`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge") 方法合并在一起。这是 [水平分片](extensions/horizontal_shard.html)
    扩展所使用的技术；请查看源代码以熟悉。'
- en: See also
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dogpile Caching](examples.html#examples-caching)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile Caching](examples.html#examples-caching)'
- en: '[Horizontal Sharding](examples.html#examples-sharding)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](examples.html#examples-sharding)'
- en: Basic Query Interception
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本查询拦截
- en: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") is firstly useful for any kind
    of interception of a query, which includes those emitted by [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") with [1.x style](../glossary.html#term-1.x-style) as well
    as when an ORM-enabled [2.0 style](../glossary.html#term-2.0-style) [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct is delivered to [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") construct provides accessors to allow modifications
    to statements, parameters, and options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 首先适用于任何类型的查询拦截，包括由 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 以 [1.x 样式](../glossary.html#term-1.x-style) 发出的查询，以及当启用
    ORM 的 [2.0 样式](../glossary.html#term-2.0-style) [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 或 [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 构造传递给 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 时。 [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState
    "sqlalchemy.orm.ORMExecuteState") 构造提供了访问器，允许对语句、参数和选项进行修改：'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The above example illustrates some simple modifications to SELECT statements.
    At this level, the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook intends to replace the
    previous use of the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, which was not fired off consistently
    for various kinds of loaders; additionally, the [`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") only applies to [1.x style](../glossary.html#term-1.x-style)
    use with [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    and not with [2.0 style](../glossary.html#term-2.0-style) use of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '上述示例说明了对 SELECT 语句的一些简单修改。在此级别上，[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件挂钩旨在替换先前使用的[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile")事件，该事件对各种加载程序未始终触发；另外，[`QueryEvents.before_compile()`](events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile")仅适用于 [1.x 样式](../glossary.html#term-1.x-style)与[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")一起使用，而不适用于[2.0 样式](../glossary.html#term-2.0-style)使用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")。  '
- en: '### Adding global WHERE / ON criteria'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加全局 WHERE / ON 条件'
- en: 'One of the most requested query-extension features is the ability to add WHERE
    criteria to all occurrences of an entity in all queries. This is achievable by
    making use of the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") query option, which may be used on its
    own, or is ideally suited to be used within the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最常请求的查询扩展功能之一是能够向所有查询中的实体添加 WHERE 条件的能力。这可以通过使用[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")查询选项来实现，该选项可以单独使用，或者最好在[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件中使用：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Above, an option is added to all SELECT statements that will limit all queries
    against `MyEntity` to filter on `public == True`. The criteria will be applied
    to **all** loads of that class within the scope of the immediate query. The [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by default will automatically propagate
    to relationship loaders as well, which will apply to subsequent relationship loads,
    which includes lazy loads, selectinloads, etc.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，一个选项被添加到所有 SELECT 语句中，该选项将限制所有针对`MyEntity`的查询以在`public == True`上进行过滤。这些条件将应用于立即查询范围内该类的**所有**加载。[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")选项默认情况下也会自动传播到关系加载程序，这将应用于后续的关系加载，包括惰性加载、selectinloads等。
- en: 'For a series of classes that all feature some common column structure, if the
    classes are composed using a [declarative mixin](extensions/declarative/mixins.html#declarative-mixins),
    the mixin class itself may be used in conjunction with the [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option by making use of a Python lambda.
    The Python lambda will be invoked at query compilation time against the specific
    entities which match the criteria. Given a series of classes based on a mixin
    called `HasTimestamp`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一系列具有一些共同列结构的类，如果使用[声明性混合](extensions/declarative/mixins.html#declarative-mixins)组合类，那么混合类本身可以与[`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria")选项一起使用，方法是使用 Python lambda。Python lambda
    将在与条件匹配的特定实体的查询编译时间调用。假设有一系列基于名为`HasTimestamp`的混合类的类：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The above classes `SomeEntity` and `SomeOtherEntity` will each have a column
    `timestamp` that defaults to the current date and time. An event may be used to
    intercept all objects that extend from `HasTimestamp` and filter their `timestamp`
    column on a date that is no older than one month ago:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类`SomeEntity`和`SomeOtherEntity`将各自具有一个列`timestamp`，默认值为当前日期和时间。可以使用事件拦截所有从`HasTimestamp`扩展的对象，并将它们的`timestamp`列过滤为一个月前的日期：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Warning
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The use of a lambda inside of the call to [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") is only invoked **once per unique class**.
    Custom functions should not be invoked within this lambda. See [Using Lambdas
    to add significant speed gains to statement production](../core/connections.html#engine-lambda-caching)
    for an overview of the “lambda SQL” feature, which is for advanced use only.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 时，使用 lambda 内部的调用**每个唯一类仅调用一次**。自定义函数不应在此
    lambda 内部调用。请参阅 [使用 Lambda 来为语句生成带来显著的速度提升](../core/connections.html#engine-lambda-caching)
    以获得“lambda SQL”功能的概述，该功能仅供高级使用。
- en: See also
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Query Events](examples.html#examples-session-orm-events) - includes working
    examples of the above [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") recipes.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询事件](examples.html#examples-session-orm-events) - 包括上述 [`with_loader_criteria()`](queryguide/api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 配方的工作示例。'
- en: '### Re-Executing Statements'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '### 重新执行语句'
- en: Deep Alchemy
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 深度炼金术
- en: the statement re-execution feature involves a slightly intricate recursive sequence,
    and is intended to solve the fairly hard problem of being able to re-route the
    execution of a SQL statement into various non-SQL contexts. The twin examples
    of “dogpile caching” and “horizontal sharding”, linked below, should be used as
    a guide for when this rather advanced feature is appropriate to be used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 语句重新执行功能涉及稍微复杂的递归序列，并且旨在解决将 SQL 语句的执行重新路由到各种非 SQL 上下文的相当困难的问题。下面链接的“狗窝缓存”和“水平分片”两个示例应该用作指导，以确定何时使用此相当高级的功能。
- en: The [`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")
    is capable of controlling the execution of the given statement; this includes
    the ability to either not invoke the statement at all, allowing a pre-constructed
    result set retrieved from a cache to be returned instead, as well as the ability
    to invoke the same statement repeatedly with different state, such as invoking
    it against multiple database connections and then merging the results together
    in memory. Both of these advanced patterns are demonstrated in SQLAlchemy’s example
    suite as detailed below.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState`](session_api.html#sqlalchemy.orm.ORMExecuteState "sqlalchemy.orm.ORMExecuteState")
    能够控制给定语句的执行；这包括不执行该语句的能力，允许从缓存中检索到的预构造结果集被返回，以及多次以不同状态调用相同语句的能力，例如对多个数据库连接执行它，然后在内存中合并结果。这两种高级模式都在下面详细介绍了
    SQLAlchemy 的示例套件中进行了演示。'
- en: When inside the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event hook, the [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may be used to invoke
    the statement using a new nested invocation of [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), which will then preempt the subsequent handling
    of the current execution in progress and instead return the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returned by the inner execution. The event handlers
    thus far invoked for the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook within this process will be
    skipped within this nested call as well.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 事件钩子内部时，可以使用 [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") 方法来使用新的嵌套调用 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 来调用语句，这将预先阻止当前正在进行的执行的后续处理，并返回内部执行的 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")。在此过程中对 [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") 钩子所调用的事件处理程序也将在此嵌套调用中被跳过。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object; this object then features the ability for
    it to be “frozen” into a cacheable format and “unfrozen” into a new [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, as well as for its data to be merged with
    that of other [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement")方法返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象；此对象具有将其“冻结”为可缓存格式并“解冻”为新的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的能力，以及将其数据与其他[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的数据合并的能力。'
- en: 'E.g., using [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") to implement a cache:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")实现缓存：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the above hook in place, an example of using the cache would look like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述钩子，使用缓存的示例如下所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Above, a custom execution option is passed to [`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options") in order to establish a
    “cache key” that will then be intercepted by the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. This cache key is then matched
    to a [`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult") object that may be present in the cache, and
    if present, the object is re-used. The recipe makes use of the [`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze") method to “freeze” a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, which above will contain ORM results, such
    that it can be stored in a cache and used multiple times. In order to return a
    live result from the “frozen” result, the `merge_frozen_result()` function is
    used to merge the “frozen” data from the result object into the current session.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，在[`Select.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.execution_options
    "sqlalchemy.sql.expression.Select.execution_options")中传递了自定义执行选项，以建立一个“缓存键”，然后会被[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")钩子拦截。然后将该缓存键与可能存在于缓存中的[`FrozenResult`](../core/connections.html#sqlalchemy.engine.FrozenResult
    "sqlalchemy.engine.FrozenResult")对象进行匹配，如果存在，则重新使用该对象。该方案利用了[`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze
    "sqlalchemy.engine.Result.freeze")方法来“冻结”一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，其中包含上面的ORM结果，以便将其存储在缓存中并多次使用。为了从“冻结”的结果中返回实时结果，使用了`merge_frozen_result()`函数将结果对象中的“冻结”数据合并到当前会话中。
- en: The above example is implemented as a complete example in [Dogpile Caching](examples.html#examples-caching).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例已作为一个完整示例在[Dogpile Caching](examples.html#examples-caching)中实现。
- en: The [`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") method may also be called multiple
    times, passing along different information to the [`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") parameter such that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will make use of different [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects each time. This will return a different [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object each time; these results can be merged together
    using the [`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge") method. This is the technique employed by the
    [Horizontal Sharding](extensions/horizontal_shard.html) extension; see the source
    code to familiarize.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ORMExecuteState.invoke_statement()`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") 方法也可能被多次调用，传递不同的信息给 [`ORMExecuteState.invoke_statement.bind_arguments`](session_api.html#sqlalchemy.orm.ORMExecuteState.invoke_statement.params.bind_arguments
    "sqlalchemy.orm.ORMExecuteState.invoke_statement") 参数，以便 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 每次使用不同的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象。这将每次返回一个不同的 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象；这些结果可以使用 [`Result.merge()`](../core/connections.html#sqlalchemy.engine.Result.merge
    "sqlalchemy.engine.Result.merge") 方法合并在一起。这是[水平分片](extensions/horizontal_shard.html)扩展所采用的技术；请参阅源代码以熟悉。'
- en: See also
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dogpile Caching](examples.html#examples-caching)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile 缓存](examples.html#examples-caching)'
- en: '[Horizontal Sharding](examples.html#examples-sharding)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[水平分片](examples.html#examples-sharding)'
- en: '## Persistence Events'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '## 持久性事件'
- en: Probably the most widely used series of events are the “persistence” events,
    which correspond to the [flush process](session_basics.html#session-flushing).
    The flush is where all the decisions are made about pending changes to objects
    and are then emitted out to the database in the form of INSERT, UPDATE, and DELETE
    statements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的系列事件可能是“持久性”事件，它们对应于[刷新过程](session_basics.html#session-flushing)。 刷新是关于对对象的待定更改的所有决定都是在这里做出的，然后以
    INSERT、UPDATE 和 DELETE 语句的形式发出到数据库。
- en: '`before_flush()`'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`before_flush()`'
- en: The [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook is by far the most generally
    useful event to use when an application wants to ensure that additional persistence
    changes to the database are made when a flush proceeds. Use [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") in order to operate upon objects
    to validate their state as well as to compose additional objects and references
    before they are persisted. Within this event, it is **safe to manipulate the Session’s
    state**, that is, new objects can be attached to it, objects can be deleted, and
    individual attributes on objects can be changed freely, and these changes will
    be pulled into the flush process when the event hook completes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 钩子是应用程序希望在提交时确保对数据库进行额外持久性更改时最常用的事件。使用
    [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 来在对象上操作以验证它们的状态，以及在它们持久化之前组合额外的对象和引用。在此事件中，**操纵会话状态是安全的**，也就是说，新对象可以附加到它，对象可以被删除，并且可以自由更改对象上的单个属性，并且这些更改将在事件挂钩完成时被纳入到刷新过程中。'
- en: The typical [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook will be tasked with scanning
    the collections [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    in order to look for objects where something will be happening.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")挂钩将负责扫描集合[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty")和[`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")，以查找将要发生变化的对象。
- en: For illustrations of [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), see examples such as [Versioning
    with a History Table](examples.html#examples-versioned-history) and [Versioning
    using Temporal Rows](examples.html#examples-versioned-rows).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")的示例，请参阅[使用历史表进行版本控制](examples.html#examples-versioned-history)和[使用时间行进行版本控制](examples.html#examples-versioned-rows)等示例。
- en: '`after_flush()`'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush()`'
- en: The [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook is called after the SQL has been
    emitted for a flush process, but **before** the state of the objects that were
    flushed has been altered. That is, you can still inspect the [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new"), [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collections to see what was just flushed, and
    you can also use history tracking features like the ones provided by [`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState") to see what changes were just persisted. In the
    [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") event, additional SQL can be emitted
    to the database based on what’s observed to have changed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL被发出进行刷新过程后，但是在被刷新的对象的状态被改变之前，会调用[`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush")挂钩。也就是说，你仍然可以检查[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty")和[`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")这些集合，看看刚刚刷新了什么，你也可以使用像[`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState")提供的历史跟踪功能来查看刚刚持久化了什么更改。在[`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush")事件中，可以根据观察到的变化向数据库发出其他SQL。
- en: '`after_flush_postexec()`'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush_postexec()`'
- en: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") is called soon after [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush"), but is invoked **after** the state
    of the objects has been modified to account for the flush that just took place.
    The [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    collections are normally completely empty here. Use [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") to inspect the identity map
    for finalized objects and possibly emit additional SQL. In this hook, there is
    the ability to make new changes on objects, which means the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will again go into a “dirty” state; the mechanics of
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    here will cause it to flush **again** if new changes are detected in this hook
    if the flush were invoked in the context of [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"); otherwise, the pending changes will be bundled
    as part of the next normal flush. When the hook detects new changes within a [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), a counter ensures that an endless loop in this
    regard is stopped after 100 iterations, in the case that an [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") hook continually adds new
    state to be flushed each time it is called.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 在 [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 之后不久被调用，但在考虑了刚刚发生的刷新后对象状态被修改的情况下调用。[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合通常在这里是完全空的。使用 [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 来检查已完成对象的标识映射并可能发出额外的SQL。在这个钩子中，有能力对对象进行新的更改，这意味着
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    将再次进入“dirty”状态；如果在此钩子中检测到新的更改，则会导致 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的机制再次刷新**一次**，如果在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的上下文中调用刷新并检测到新的更改，则否则，挂起的更改将作为下一个正常刷新的一部分捆绑在一起。当钩子在
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    中检测到新的更改时，计数器确保在每次调用时都添加新的状态时不会无限循环，以防止无休止的循环在这方面在经过100次迭代后停止。'
- en: '### Mapper-level Flush Events'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '### Mapper级别的刷新事件'
- en: In addition to the flush-level hooks, there is also a suite of hooks that are
    more fine-grained, in that they are called on a per-object basis and are broken
    out based on INSERT, UPDATE or DELETE within the flush process. These are the
    mapper persistence hooks, and they too are very popular, however these events
    need to be approached more cautiously, as they proceed within the context of the
    flush process that is already ongoing; many operations are not safe to proceed
    here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刷新级别的钩子外，还有一组更细粒度的钩子，它们是基于每个对象的并且根据刷新过程中的INSERT、UPDATE或DELETE而分开的。这些是映射器持久性钩子，它们也非常受欢迎，但是需要更加谨慎地对待这些事件，因为它们在已经进行中的刷新过程的上下文中进行；在这里进行许多操作是不安全的。
- en: 'The events are:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 事件包括：
- en: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert")'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert")'
- en: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert")'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert")'
- en: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
- en: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
- en: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
- en: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that these events apply **only** to the [session flush
    operation](session_basics.html#session-flushing) , and **not** to the ORM-level
    INSERT/UPDATE/DELETE functionality described at [ORM-Enabled INSERT, UPDATE, and
    DELETE statements](queryguide/dml.html#orm-expression-update-delete). To intercept
    ORM-level DML, use the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些事件**仅适用于**[会话刷新操作](session_basics.html#session-flushing)，而**不适用于**在[ORM-Enabled
    INSERT、UPDATE 和 DELETE 语句](queryguide/dml.html#orm-expression-update-delete)中描述的
    ORM 级别的 INSERT/UPDATE/DELETE 功能。要拦截 ORM 级别的 DML，请使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。
- en: Each event is passed the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    the mapped object itself, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which is being used to emit an INSERT, UPDATE
    or DELETE statement. The appeal of these events is clear, in that if an application
    wants to tie some activity to when a specific type of object is persisted with
    an INSERT, the hook is very specific; unlike the [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") event, there’s no need to search
    through collections like [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new") in order to find targets. However, the flush plan
    which represents the full list of every single INSERT, UPDATE, DELETE statement
    to be emitted has *already been decided* when these events are called, and no
    changes may be made at this stage. Therefore the only changes that are even possible
    to the given objects are upon attributes **local** to the object’s row. Any other
    change to the object or other objects will impact the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), which will fail to function properly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都会传递[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")、映射对象本身以及正在用于发出
    INSERT、UPDATE 或 DELETE 语句的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。这些事件的吸引力是显而易见的，因为如果一个应用程序想要将某些活动与特定类型的对象被插入时联系起来，那么钩子就非常具体；不像[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")事件那样，不需要搜索像[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")这样的集合以找到目标。然而，在调用这些事件时，表示将要发出的每个单独的 INSERT、UPDATE、DELETE
    语句的 flush 计划已经*已经决定*，并且在此阶段不能做出任何更改。因此，对给定对象的唯一可能的更改是对对象行**本地**的属性进行。对对象或其他对象的任何其他更改将影响[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态，这将导致其无法正常工作。
- en: 'Operations that are not supported within these mapper-level persistence events
    include:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持这些映射器级别持久性事件中的操作包括：
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
- en: Mapped collection append, add, remove, delete, discard, etc.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射集合的附加、添加、删除、丢弃等操作。
- en: Mapped relationship attribute set/del events, i.e. `someobject.related = someotherobject`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射关系属性设置/删除事件，即`someobject.related = someotherobject`
- en: The reason the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is passed is that it is encouraged that **simple
    SQL operations take place here**, directly on the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), such as incrementing counters or inserting extra
    rows within log tables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '传递[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")的原因是鼓励**在此处执行简单的
    SQL 操作**，直接在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上，例如增加计数器或在日志表中插入额外行。  '
- en: There are also many per-object operations that don’t need to be handled within
    a flush event at all. The most common alternative is to simply establish additional
    state along with an object inside its `__init__()` method, such as creating additional
    objects that are to be associated with the new object. Using validators as described
    in [Simple Validators](mapped_attributes.html#simple-validators) is another approach;
    these functions can intercept changes to attributes and establish additional state
    changes on the target object in response to the attribute change. With both of
    these approaches, the object is in the correct state before it ever gets to the
    flush step.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '也有许多不需要在刷新事件中处理的每个对象操作。最常见的替代方法是简单地在对象的`__init__()`方法中与对象一起建立附加状态，例如创建与新对象关联的其他对象。使用如[简单验证器](mapped_attributes.html#simple-validators)中所述的验证器是另一种方法；这些函数可以拦截对属性的更改，并在响应属性更改时在目标对象上建立额外的状态更改。使用这两种方法，对象在到达刷新步骤之前处于正确的状态。  '
- en: '`before_flush()`'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`before_flush()`  '
- en: The [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook is by far the most generally
    useful event to use when an application wants to ensure that additional persistence
    changes to the database are made when a flush proceeds. Use [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") in order to operate upon objects
    to validate their state as well as to compose additional objects and references
    before they are persisted. Within this event, it is **safe to manipulate the Session’s
    state**, that is, new objects can be attached to it, objects can be deleted, and
    individual attributes on objects can be changed freely, and these changes will
    be pulled into the flush process when the event hook completes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 钩子是应用程序希望确保在提交刷新时进行额外持久化更改时最常用的事件。使用[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 来操作对象以验证其状态，并在持久化之前组成额外的对象和引用。在此事件中，**操作会话的状态是安全的**，即，新对象可以附加到其中，对象可以被删除，并且可以自由更改对象上的单个属性，并且这些更改将在事件钩子完成时被引入到刷新过程中。  '
- en: The typical [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") hook will be tasked with scanning
    the collections [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    in order to look for objects where something will be happening.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '典型的[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") 钩子将负责扫描集合[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和[`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")，以查找将发生事情的对象。  '
- en: For illustrations of [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), see examples such as [Versioning
    with a History Table](examples.html#examples-versioned-history) and [Versioning
    using Temporal Rows](examples.html#examples-versioned-rows).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '有关[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")的示例，请参见[带有历史表的版本控制](examples.html#examples-versioned-history)和[使用时间行进行版本控制](examples.html#examples-versioned-rows)等示例。  '
- en: '`after_flush()`'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush()`  '
- en: The [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook is called after the SQL has been
    emitted for a flush process, but **before** the state of the objects that were
    flushed has been altered. That is, you can still inspect the [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new"), [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collections to see what was just flushed, and
    you can also use history tracking features like the ones provided by [`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState") to see what changes were just persisted. In the
    [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") event, additional SQL can be emitted
    to the database based on what’s observed to have changed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 钩子在 flush 过程中的 SQL 已经被发出，但是在被刷新的对象状态被改变之前被调用。也就是说，您仍然可以检查
    [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合，看看刚刚被刷新了什么，您还可以使用像 [`AttributeState`](internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState") 提供的历史跟踪功能来查看刚刚持久化的更改。在 [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 事件中，根据观察到的更改，可以向数据库发出其他 SQL。'
- en: '`after_flush_postexec()`'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_flush_postexec()`'
- en: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") is called soon after [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush"), but is invoked **after** the state
    of the objects has been modified to account for the flush that just took place.
    The [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"),
    [`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty "sqlalchemy.orm.Session.dirty")
    and [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted "sqlalchemy.orm.Session.deleted")
    collections are normally completely empty here. Use [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") to inspect the identity map
    for finalized objects and possibly emit additional SQL. In this hook, there is
    the ability to make new changes on objects, which means the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will again go into a “dirty” state; the mechanics of
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    here will cause it to flush **again** if new changes are detected in this hook
    if the flush were invoked in the context of [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"); otherwise, the pending changes will be bundled
    as part of the next normal flush. When the hook detects new changes within a [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), a counter ensures that an endless loop in this
    regard is stopped after 100 iterations, in the case that an [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") hook continually adds new
    state to be flushed each time it is called.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 在 [`SessionEvents.after_flush()`](events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") 之后不久调用，但是在对象的状态已经修改以反映刚刚发生的刷新之后调用。这里
    [`Session.new`](session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new")、[`Session.dirty`](session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty") 和 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合通常完全为空。使用 [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 来检查最终化对象的标识映射，并可能发出其他 SQL。在这个钩子中，有能力对对象进行新的更改，这意味着
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    将再次进入“dirty”状态；如果在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的上下文中调用此钩子时检测到新的更改，那么[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的机制会导致它再次刷新；否则，待定的更改将作为下一个正常刷新的一部分捆绑在一起。当钩子在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 中检测到新的更改时，计数器会在此方面的无限循环在100次迭代后停止，在这种情况下，如果 [`SessionEvents.after_flush_postexec()`](events.html#sqlalchemy.orm.SessionEvents.after_flush_postexec
    "sqlalchemy.orm.SessionEvents.after_flush_postexec") 钩子每次调用时都持续添加新的要刷新的状态，就会停止。'
- en: '### Mapper-level Flush Events'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射器级别的刷新事件'
- en: In addition to the flush-level hooks, there is also a suite of hooks that are
    more fine-grained, in that they are called on a per-object basis and are broken
    out based on INSERT, UPDATE or DELETE within the flush process. These are the
    mapper persistence hooks, and they too are very popular, however these events
    need to be approached more cautiously, as they proceed within the context of the
    flush process that is already ongoing; many operations are not safe to proceed
    here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刷新级别的钩子外，还有一套更精细的钩子，因为它们是基于每个对象调用的，并根据刷新过程中的 INSERT、UPDATE 或 DELETE 进行分组。这些是映射器持久性钩子，它们也非常受欢迎，但是这些事件需要更谨慎地处理，因为它们在已经进行的刷新过程的上下文中进行；许多操作在这里进行不安全。
- en: 'The events are:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 事件包括：
- en: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert")'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_insert()`](events.html#sqlalchemy.orm.MapperEvents.before_insert
    "sqlalchemy.orm.MapperEvents.before_insert")'
- en: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert")'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_insert()`](events.html#sqlalchemy.orm.MapperEvents.after_insert
    "sqlalchemy.orm.MapperEvents.after_insert")'
- en: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_update()`](events.html#sqlalchemy.orm.MapperEvents.before_update
    "sqlalchemy.orm.MapperEvents.before_update")'
- en: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_update()`](events.html#sqlalchemy.orm.MapperEvents.after_update
    "sqlalchemy.orm.MapperEvents.after_update")'
- en: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.before_delete()`](events.html#sqlalchemy.orm.MapperEvents.before_delete
    "sqlalchemy.orm.MapperEvents.before_delete")'
- en: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MapperEvents.after_delete()`](events.html#sqlalchemy.orm.MapperEvents.after_delete
    "sqlalchemy.orm.MapperEvents.after_delete")'
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that these events apply **only** to the [session flush
    operation](session_basics.html#session-flushing) , and **not** to the ORM-level
    INSERT/UPDATE/DELETE functionality described at [ORM-Enabled INSERT, UPDATE, and
    DELETE statements](queryguide/dml.html#orm-expression-update-delete). To intercept
    ORM-level DML, use the [`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些事件**仅**适用于[会话刷新操作](session_basics.html#session-flushing)，**而不是**描述的ORM级别的INSERT/UPDATE/DELETE功能
    [ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html#orm-expression-update-delete)。要拦截ORM级别的DML，请使用[`SessionEvents.do_orm_execute()`](events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。
- en: Each event is passed the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    the mapped object itself, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which is being used to emit an INSERT, UPDATE
    or DELETE statement. The appeal of these events is clear, in that if an application
    wants to tie some activity to when a specific type of object is persisted with
    an INSERT, the hook is very specific; unlike the [`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush") event, there’s no need to search
    through collections like [`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new") in order to find targets. However, the flush plan
    which represents the full list of every single INSERT, UPDATE, DELETE statement
    to be emitted has *already been decided* when these events are called, and no
    changes may be made at this stage. Therefore the only changes that are even possible
    to the given objects are upon attributes **local** to the object’s row. Any other
    change to the object or other objects will impact the state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), which will fail to function properly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都会传递[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")、映射对象本身和用于发出INSERT、UPDATE或DELETE语句的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。这些事件的吸引力是显而易见的，因为如果应用程序想要将某些活动与在INSERT时持久化特定类型的对象绑定起来，这个钩子就非常具体；与[`SessionEvents.before_flush()`](events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush")事件不同，不需要搜索像[`Session.new`](session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")这样的集合来找到目标。然而，在调用这些事件时，表示要发出的每个单独的INSERT、UPDATE、DELETE语句的刷新计划已经**已经确定**，在此阶段无法进行任何更改。因此，甚至可能对给定对象进行的唯一更改是对对象行的**本地**属性。对于对象或其他对象的任何其他更改都将影响到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态，这将导致其无法正常工作。
- en: 'Operations that are not supported within these mapper-level persistence events
    include:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些映射器级别的持久性事件中不支持的操作包括：
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")'
- en: Mapped collection append, add, remove, delete, discard, etc.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的集合追加、添加、移除、删除、丢弃等操作。
- en: Mapped relationship attribute set/del events, i.e. `someobject.related = someotherobject`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的关系属性设置/删除事件，即`someobject.related = someotherobject`
- en: The reason the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is passed is that it is encouraged that **simple
    SQL operations take place here**, directly on the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), such as incrementing counters or inserting extra
    rows within log tables.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 传递[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")的原因是鼓励**在这里进行简单的
    SQL 操作**，直接在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上进行，比如增加计数器或在日志表中插入额外行。
- en: There are also many per-object operations that don’t need to be handled within
    a flush event at all. The most common alternative is to simply establish additional
    state along with an object inside its `__init__()` method, such as creating additional
    objects that are to be associated with the new object. Using validators as described
    in [Simple Validators](mapped_attributes.html#simple-validators) is another approach;
    these functions can intercept changes to attributes and establish additional state
    changes on the target object in response to the attribute change. With both of
    these approaches, the object is in the correct state before it ever gets to the
    flush step.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多不需要在刷新事件中处理的每个对象操作。最常见的替代方法是在对象的`__init__()`方法中简单地建立额外状态，比如创建要与新对象关联的其他对象。另一种方法是使用[简单验证器](mapped_attributes.html#simple-validators)中描述的验证器；这些函数可以拦截属性的更改，并在响应属性更改时在目标对象上建立额外的状态更改。使用这两种方法，对象在进入刷新步骤之前就处于正确状态。
- en: '## Object Lifecycle Events'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '## 对象生命周期事件'
- en: Another use case for events is to track the lifecycle of objects. This refers
    to the states first introduced at [Quickie Intro to Object States](session_state_management.html#session-object-states).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的另一个用例是跟踪对象的生命周期。这指的是首次介绍的状态，即[快速介绍对象状态](session_state_management.html#session-object-states)。
- en: 'All the states above can be tracked fully with events. Each event represents
    a distinct state transition, meaning, the starting state and the destination state
    are both part of what are tracked. With the exception of the initial transient
    event, all the events are in terms of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object or class, meaning they can be associated either
    with a specific [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述状态都可以通过事件完全跟踪。每个事件代表一个不同的状态转换，意味着起始状态和目标状态都是被跟踪的一部分。除了初始瞬态事件之外，所有事件都是以[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象或类的形式，意味着它们可以与特定的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象关联：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    class itself, as well as with a specific [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker"), which is likely the most useful form:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")类本身一起，以及与特定的[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")一起，这可能是最有用的形式：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The listeners can of course be stacked on top of one function, as is likely
    to be common. For example, to track all objects that are entering the persistent
    state:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，监听器可以堆叠在一个函数之上，这很常见。例如，要跟踪进入持久状态的所有对象：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Transient
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瞬态
- en: 'All mapped objects when first constructed start out as [transient](../glossary.html#term-transient).
    In this state, the object exists alone and doesn’t have an association with any
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    For this initial state, there’s no specific “transition” event since there is
    no [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    however if one wanted to intercept when any transient object is created, the [`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init") method is probably the best event. This
    event is applied to a specific class or superclass. For example, to intercept
    all new objects for a particular declarative base:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有映射对象首次构建时，它们都是[瞬态](../glossary.html#term-transient)的。在此状态下，对象单独存在，并且不与任何[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。对于这种初始状态，没有特定的“转换”事件，因为没有[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，但是如果想要拦截任何瞬态对象被创建时，[`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init") 方法可能是最好的事件。此事件适用于特定的类或超类。例如，要拦截特定声明基类的所有新对象：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Transient to Pending
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瞬态到挂起
- en: 'The transient object becomes [pending](../glossary.html#term-pending) when
    it is first associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") method. An object may also become part of a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as a result of a [“cascade”](cascades.html#unitofwork-cascades) from a referencing
    object that was explicitly added. The transient to pending transition is detectable
    using the [`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending") event:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当瞬态对象首次通过[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")或[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")方法与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联时，瞬态对象变为[挂起](../glossary.html#term-pending)。对象也可能作为显式添加的引用对象的[“级联”](cascades.html#unitofwork-cascades)的结果之一而成为[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的一部分。可以使用[`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending")事件检测瞬态到挂起的转换：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Pending to Persistent
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起到持久
- en: 'The [pending](../glossary.html#term-pending) object becomes [persistent](../glossary.html#term-persistent)
    when a flush proceeds and an INSERT statement takes place for the instance. The
    object now has an identity key. Track pending to persistent with the [`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent") event:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当刷新继续并且针对实例进行INSERT语句时，[挂起](../glossary.html#term-pending)对象变为[持久](../glossary.html#term-persistent)。对象现在具有标识键。使用[`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent")事件跟踪挂起到持久的转换：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pending to Transient
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起到瞬态
- en: 'The [pending](../glossary.html#term-pending) object can revert back to [transient](../glossary.html#term-transient)
    if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called before the pending object
    has been flushed, or if the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") method is called for the object before it is
    flushed. Track pending to transient with the [`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient") event:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在挂起对象刷新之前调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，或者在刷新对象之前调用[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")方法，则[挂起](../glossary.html#term-pending)对象可以恢复为[瞬态](../glossary.html#term-transient)。使用[`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient")事件跟踪挂起到瞬态的转换：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Loaded as Persistent
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载为持久对象
- en: 'Objects can appear in the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") directly in the [persistent](../glossary.html#term-persistent)
    state when they are loaded from the database. Tracking this state transition is
    synonymous with tracking objects as they are loaded, and is synonymous with using
    the [`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load "sqlalchemy.orm.InstanceEvents.load")
    instance-level event. However, the [`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") event is provided as a session-centric
    hook for intercepting objects as they enter the persistent state via this particular
    avenue:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当从数据库加载对象时，对象可以直接进入 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的 [persistent](../glossary.html#term-persistent) 状态。跟踪这种状态转换与跟踪对象的加载是同义的，并且等同于使用
    [`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load "sqlalchemy.orm.InstanceEvents.load")
    实例级事件。然而，[`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") 事件作为一个针对会话的钩子，用于拦截对象通过这种特定途径进入持久状态：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Persistent to Transient
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久到瞬态
- en: 'The persistent object can revert to the transient state if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called for a transaction where the
    object was first added as pending. In the case of the ROLLBACK, the INSERT statement
    that made this object persistent is rolled back, and the object is evicted from
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to again become transient. Track objects that were reverted to transient from
    persistent using the [`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient") event hook:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象处于持久状态时，如果调用了 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，该对象会恢复到瞬态状态，前提是它最初是作为待定对象添加的事务。在回滚的情况下，使该对象持久的
    INSERT 语句将被回滚，并且该对象将从 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中驱逐出去，再次变为瞬态。使用 [`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient") 事件钩子来跟踪从持久状态恢复到瞬态状态的对象：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Persistent to Deleted
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久到已删除
- en: The persistent object enters the [deleted](../glossary.html#term-deleted) state
    when an object marked for deletion is deleted from the database within the flush
    process. Note that this is **not the same** as when the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method is called for a target object. The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method only **marks** the object for deletion;
    the actual DELETE statement is not emitted until the flush proceeds. It is subsequent
    to the flush that the “deleted” state is present for the target object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当标记为删除的对象在刷新过程中从数据库中删除时，持久对象进入了 [deleted](../glossary.html#term-deleted) 状态。请注意，这与调用
    [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    方法删除目标对象时**不同**。[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 方法只是**标记**对象为删除；直到刷新进行时，实际的 DELETE 语句才会被发出。在刷新之后，目标对象将处于“deleted”状态。
- en: Within the “deleted” state, the object is only marginally associated with the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    It is not present in the identity map nor is it present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection that refers to when it was pending
    for deletion.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在“deleted”状态下，对象与 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仅有轻微关联。它不在标识映射中，也不在指示它何时待删除的 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合中。
- en: From the “deleted” state, the object can go either to the detached state when
    the transaction is committed, or back to the persistent state if the transaction
    is instead rolled back.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从“deleted”状态，对象可以在事务提交时进入分离状态，或者如果事务回滚，则返回持久状态。
- en: 'Track the persistent to deleted transition with [`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted"):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") 跟踪从持久到已删除的转换：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Deleted to Detached
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除到分离
- en: 'The deleted object becomes [detached](../glossary.html#term-detached) when
    the session’s transaction is committed. After the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method is called, the database transaction is
    final and the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    now fully discards the deleted object and removes all associations to it. Track
    the deleted to detached transition using [`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached"):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话的事务提交后，删除的对象会变成[分离](../glossary.html#term-detached)。在调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法后，数据库事务已经完成，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")现在完全丢弃了删除的对象并删除了所有与之相关的关联。使用[`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached")跟踪删除到分离的转换：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the object is in the deleted state, the [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") attribute, accessible using `inspect(object).deleted`,
    returns True. However when the object is detached, [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") will again return False. To detect that
    an object was deleted, regardless of whether or not it is detached, use the [`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象处于删除状态时，可通过`inspect(object).deleted`访问[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")属性，返回True。然而，当对象被分离时，[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")将再次返回False。要检测对象是否已被删除，无论它是否分离，都可以使用[`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted")访问器。
- en: Persistent to Detached
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久到分离
- en: The persistent object becomes [detached](../glossary.html#term-detached) when
    the object is de-associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), via the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge"), [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象使用[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge "sqlalchemy.orm.Session.expunge")、[`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")或[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")解除关联时，持久对象将变为[分离](../glossary.html#term-detached)。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An object may also become **implicitly detached** if its owning [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is dereferenced by the application and discarded due
    to garbage collection. In this case, **no event is emitted**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序解除引用并由于垃圾回收而丢弃了拥有的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，则对象也可能**隐式分离**。在这种情况下，**不会触发任何事件**。
- en: 'Track objects as they move from persistent to detached using the [`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached") event:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached")事件跟踪对象从持久到分离的移动：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Detached to Persistent
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离到持久
- en: 'The detached object becomes persistent when it is re-associated with a session
    using the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    or equivalent method. Track objects moving back to persistent from detached using
    the [`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent") event:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当分离的对象使用[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")或等效方法重新关联到会话时，它将变成持久对象。使用[`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent")事件跟踪从分离返回到持久的对象：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Deleted to Persistent
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除到持久
- en: 'The [deleted](../glossary.html#term-deleted) object can be reverted to the
    [persistent](../glossary.html#term-persistent) state when the transaction in which
    it was DELETEd was rolled back using the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method. Track deleted objects moving back to
    the persistent state using the [`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") event:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于DELETE的事务使用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法回滚时，[已删除](../glossary.html#term-deleted)对象可以恢复为[持久](../glossary.html#term-persistent)状态。使用[`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent")事件跟踪已删除对象移回持久状态：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Transient
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂时
- en: 'All mapped objects when first constructed start out as [transient](../glossary.html#term-transient).
    In this state, the object exists alone and doesn’t have an association with any
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    For this initial state, there’s no specific “transition” event since there is
    no [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    however if one wanted to intercept when any transient object is created, the [`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init") method is probably the best event. This
    event is applied to a specific class or superclass. For example, to intercept
    all new objects for a particular declarative base:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有映射对象在首次构造时都作为[暂时](../glossary.html#term-transient)状态开始。在这种状态下，对象单独存在，并且不与任何[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。对于这种初始状态，没有特定的“转换”事件，因为没有[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，但是如果想要拦截任何暂时对象被创建的情况，[`InstanceEvents.init()`](events.html#sqlalchemy.orm.InstanceEvents.init
    "sqlalchemy.orm.InstanceEvents.init")方法可能是最好的事件。此事件适用于特定类或超类。例如，要拦截特定声明基类的所有新对象：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Transient to Pending
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂时到待定
- en: 'The transient object becomes [pending](../glossary.html#term-pending) when
    it is first associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all") method. An object may also become part of a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    as a result of a [“cascade”](cascades.html#unitofwork-cascades) from a referencing
    object that was explicitly added. The transient to pending transition is detectable
    using the [`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending") event:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当暂时对象首次通过[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")或[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")方法与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联时，暂时对象变为[待定](../glossary.html#term-pending)状态。对象也可能作为引用对象的“级联”结果成为[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的一部分，该引用对象已明确添加。可以使用[`SessionEvents.transient_to_pending()`](events.html#sqlalchemy.orm.SessionEvents.transient_to_pending
    "sqlalchemy.orm.SessionEvents.transient_to_pending")事件检测从暂时到待定的转换：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Pending to Persistent
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 待定到持久
- en: 'The [pending](../glossary.html#term-pending) object becomes [persistent](../glossary.html#term-persistent)
    when a flush proceeds and an INSERT statement takes place for the instance. The
    object now has an identity key. Track pending to persistent with the [`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent") event:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[待定](../glossary.html#term-pending)对象在执行冲洗并为该实例执行插入语句时变为[持久](../glossary.html#term-persistent)状态。对象现在具有标识键。使用[`SessionEvents.pending_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_persistent
    "sqlalchemy.orm.SessionEvents.pending_to_persistent")事件跟踪待定对象到持久状态的转换：'
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Pending to Transient
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 待定到暂时
- en: 'The [pending](../glossary.html#term-pending) object can revert back to [transient](../glossary.html#term-transient)
    if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called before the pending object
    has been flushed, or if the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") method is called for the object before it is
    flushed. Track pending to transient with the [`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient") event:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在待定对象被刷新之前调用了[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，或者在对象被刷新之前调用了[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")方法，则[待定](../glossary.html#term-pending)对象可以恢复到[瞬态](../glossary.html#term-transient)状态。使用[`SessionEvents.pending_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.pending_to_transient
    "sqlalchemy.orm.SessionEvents.pending_to_transient")事件跟踪从待定到瞬态的对象：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Loaded as Persistent
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载为持久化
- en: 'Objects can appear in the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") directly in the [persistent](../glossary.html#term-persistent)
    state when they are loaded from the database. Tracking this state transition is
    synonymous with tracking objects as they are loaded, and is synonymous with using
    the [`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load "sqlalchemy.orm.InstanceEvents.load")
    instance-level event. However, the [`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") event is provided as a session-centric
    hook for intercepting objects as they enter the persistent state via this particular
    avenue:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以直接以[持久化](../glossary.html#term-persistent)状态出现在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，当它们从数据库中加载时。跟踪这种状态转换与跟踪对象的加载是同义的，并且与使用[`InstanceEvents.load()`](events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load")实例级事件是同义的。但是，提供了[`SessionEvents.loaded_as_persistent()`](events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent")事件作为一个会话中心的钩子，用于拦截通过这种特定途径进入持久化状态的对象：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Persistent to Transient
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化到瞬态
- en: 'The persistent object can revert to the transient state if the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is called for a transaction where the
    object was first added as pending. In the case of the ROLLBACK, the INSERT statement
    that made this object persistent is rolled back, and the object is evicted from
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to again become transient. Track objects that were reverted to transient from
    persistent using the [`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient") event hook:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象首次被添加为待定的事务中调用了[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，则持久化对象可以恢复到瞬态状态。在回滚的情况下，使该对象持久化的 INSERT 语句被回滚，对象被从[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中驱逐，再次成为瞬态。使用[`SessionEvents.persistent_to_transient()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_transient
    "sqlalchemy.orm.SessionEvents.persistent_to_transient")事件钩子跟踪从持久化到瞬态的对象：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Persistent to Deleted
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化到已删除
- en: The persistent object enters the [deleted](../glossary.html#term-deleted) state
    when an object marked for deletion is deleted from the database within the flush
    process. Note that this is **not the same** as when the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method is called for a target object. The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method only **marks** the object for deletion;
    the actual DELETE statement is not emitted until the flush proceeds. It is subsequent
    to the flush that the “deleted” state is present for the target object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在刷新过程中，如果标记为删除的对象从数据库中被删除，则持久化对象进入[已删除](../glossary.html#term-deleted)状态。请注意，这**与**调用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法删除目标对象时不同。[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法仅**标记**对象以进行删除；直到刷新进行之后，实际的 DELETE 语句才会被发出。在刷新之后，目标对象的“已删除”状态才存在。
- en: Within the “deleted” state, the object is only marginally associated with the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    It is not present in the identity map nor is it present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection that refers to when it was pending
    for deletion.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在“删除”状态中，对象与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")仅具有较弱的关联。它不在标识映射中，也不在指向它曾经等待删除的[`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")集合中。
- en: From the “deleted” state, the object can go either to the detached state when
    the transaction is committed, or back to the persistent state if the transaction
    is instead rolled back.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从“删除”状态，对象可以通过提交事务进入分离状态，或者如果事务被回滚，则返回持久状态。
- en: 'Track the persistent to deleted transition with [`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted"):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`SessionEvents.persistent_to_deleted()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted")来追踪持久到删除的转变：
- en: '[PRE52]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Deleted to Detached
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除到分离
- en: 'The deleted object becomes [detached](../glossary.html#term-detached) when
    the session’s transaction is committed. After the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method is called, the database transaction is
    final and the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    now fully discards the deleted object and removes all associations to it. Track
    the deleted to detached transition using [`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached"):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话的事务提交后，被删除的对象会变成[分离状态](../glossary.html#term-detached)。在调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法后，数据库事务已经最终化，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")现在完全丢弃了被删除的对象并移除了所有与其相关的关联。使用[`SessionEvents.deleted_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached")来追踪从删除到分离的转变：
- en: '[PRE53]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the object is in the deleted state, the [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") attribute, accessible using `inspect(object).deleted`,
    returns True. However when the object is detached, [`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") will again return False. To detect that
    an object was deleted, regardless of whether or not it is detached, use the [`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象处于删除状态时，可以通过`inspect(object).deleted`访问的[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")属性返回True。但是当对象分离时，[`InstanceState.deleted`](internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted")将再次返回False。要检测对象是否已被删除，无论它是否分离，请使用[`InstanceState.was_deleted`](internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted")访问器。
- en: Persistent to Detached
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久到分离
- en: The persistent object becomes [detached](../glossary.html#term-detached) when
    the object is de-associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), via the [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge"), [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")取消关联时，通过[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")、[`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")或[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法，持久对象会变成[分离状态](../glossary.html#term-detached)。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An object may also become **implicitly detached** if its owning [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is dereferenced by the application and discarded due
    to garbage collection. In this case, **no event is emitted**.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于垃圾回收应用程序取消引用并丢弃了拥有对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，则对象也可能**隐式分离**。在这种情况下，**不会发出任何事件**。
- en: 'Track objects as they move from persistent to detached using the [`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached") event:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`SessionEvents.persistent_to_detached()`](events.html#sqlalchemy.orm.SessionEvents.persistent_to_detached
    "sqlalchemy.orm.SessionEvents.persistent_to_detached")事件跟踪对象从持久化到分离的移动：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Detached to Persistent
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离到持久化
- en: 'The detached object becomes persistent when it is re-associated with a session
    using the [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    or equivalent method. Track objects moving back to persistent from detached using
    the [`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent") event:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当将分离的对象重新关联到会话时，该分离对象变为持久化状态，可使用[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")或等效方法。跟踪对象从分离状态回到持久化状态时，请使用[`SessionEvents.detached_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.detached_to_persistent
    "sqlalchemy.orm.SessionEvents.detached_to_persistent")事件：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Deleted to Persistent
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除到持久化
- en: 'The [deleted](../glossary.html#term-deleted) object can be reverted to the
    [persistent](../glossary.html#term-persistent) state when the transaction in which
    it was DELETEd was rolled back using the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method. Track deleted objects moving back to
    the persistent state using the [`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") event:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当以DELETE方式删除对象的事务被使用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法回滚时，[删除](../glossary.html#term-deleted)对象可以恢复到[持久化](../glossary.html#term-persistent)状态。跟踪已删除对象从删除状态返回持久化状态，请使用[`SessionEvents.deleted_to_persistent()`](events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent")事件：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '## Transaction Events'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '## 事务事件'
- en: Transaction events allow an application to be notified when transaction boundaries
    occur at the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    level as well as when the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") changes the transactional state on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 事务事件允许应用程序在[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")级别发生事务边界以及[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象上更改事务状态时得到通知。
- en: '[`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create"), [`SessionEvents.after_transaction_end()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end") - these events track the
    logical transaction scopes of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in a way that is not specific to individual database
    connections. These events are intended to help with integration of transaction-tracking
    systems such as `zope.sqlalchemy`. Use these events when the application needs
    to align some external scope with the transactional scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). These hooks mirror the “nested” transactional behavior
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    in that they track logical “subtransactions” as well as “nested” (e.g. SAVEPOINT)
    transactions.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SessionEvents.after_transaction_create()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create"), [`SessionEvents.after_transaction_end()`](events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end") - 这些事件跟踪[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的逻辑事务范围，与个别数据库连接无关。这些事件旨在帮助集成诸如`zope.sqlalchemy`之类的事务跟踪系统。当应用程序需要将某些外部范围与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的事务范围对齐时，请使用这些事件。这些钩子反映了[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的“嵌套”事务行为，因为它们不仅跟踪逻辑“子事务”，还跟踪“嵌套”（例如SAVEPOINT）事务。'
- en: '[`SessionEvents.before_commit()`](events.html#sqlalchemy.orm.SessionEvents.before_commit
    "sqlalchemy.orm.SessionEvents.before_commit"), [`SessionEvents.after_commit()`](events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit"), [`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin"), [`SessionEvents.after_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback"), [`SessionEvents.after_soft_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_soft_rollback
    "sqlalchemy.orm.SessionEvents.after_soft_rollback") - These events allow tracking
    of transaction events from the perspective of database connections. [`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin") in particular is a per-connection
    event; a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that maintains more than one connection will emit this event for each connection
    individually as those connections become used within the current transaction.
    The rollback and commit events then refer to when the DBAPI connections themselves
    have received rollback or commit instructions directly.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SessionEvents.before_commit()`](events.html#sqlalchemy.orm.SessionEvents.before_commit
    "sqlalchemy.orm.SessionEvents.before_commit"), [`SessionEvents.after_commit()`](events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit"), [`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin"), [`SessionEvents.after_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback"), [`SessionEvents.after_soft_rollback()`](events.html#sqlalchemy.orm.SessionEvents.after_soft_rollback
    "sqlalchemy.orm.SessionEvents.after_soft_rollback") - 这些事件允许从数据库连接的角度跟踪事务事件。特别是[`SessionEvents.after_begin()`](events.html#sqlalchemy.orm.SessionEvents.after_begin
    "sqlalchemy.orm.SessionEvents.after_begin") 是一个每个连接的事件；一个维护多个连接的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将在当前事务中使用这些连接时为每个连接单独发出此事件。然后回滚和提交事件是指 DBAPI 连接本身何时直接收到回滚或提交指令。'
- en: Attribute Change Events
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性更改事件
- en: The attribute change events allow interception of when specific attributes on
    an object are modified. These events include [`AttributeEvents.set()`](events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), and [`AttributeEvents.remove()`](events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove"). These events are extremely useful, particularly
    for per-object validation operations; however, it is often much more convenient
    to use a “validator” hook, which uses these hooks behind the scenes; see [Simple
    Validators](mapped_attributes.html#simple-validators) for background on this.
    The attribute events are also behind the mechanics of backreferences. An example
    illustrating use of attribute events is in [Attribute Instrumentation](examples.html#examples-instrumentation).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 属性更改事件允许拦截对象上特定属性被修改的情况。这些事件包括[`AttributeEvents.set()`](events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), 和 [`AttributeEvents.remove()`](events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove")。这些事件非常有用，特别是用于每个对象的验证操作；然而，通常更方便使用“验证器”钩子，该钩子在幕后使用这些钩子；请参阅[简单验证器](mapped_attributes.html#simple-validators)
    了解背景信息。属性事件也在反向引用的机制后面。一个示例说明了属性事件的使用在[属性检测](examples.html#examples-instrumentation)。
