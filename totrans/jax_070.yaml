- en: 'JEP 9263: Typed keys & pluggable RNGs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jep/9263-typed-keys.html`](https://jax.readthedocs.io/en/latest/jep/9263-typed-keys.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Jake VanderPlas, Roy Frostig*'
  prefs: []
  type: TYPE_NORMAL
- en: '*August 2023*'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going forward, RNG keys in JAX will be more type-safe and customizable. Rather
    than representing a single PRNG key by a length-2 `uint32` array, it will be represented
    as a scalar array with a special RNG dtype that satisfies `jnp.issubdtype(key.dtype,
    jax.dtypes.prng_key)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, old-style RNG keys can still be created with `jax.random.PRNGKey()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting now, new-style RNG keys can be created with `jax.random.key()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This (scalar-shaped) array behaves the same as any other JAX array, except
    that its element type is a key (and associated metadata). We can make non-scalar
    key arrays as well, for example by applying `jax.vmap()` to `jax.random.key()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside from switching to a new constructor, most PRNG-related code should continue
    to work as expected. You can continue to use keys in `jax.random` APIs as before;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, not all numerical operations work on key arrays. They now intentionally
    raise errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason you need to recover the underlying buffer (the old-style
    key), you can do so with `jax.random.key_data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For old-style keys, `key_data()` is an identity operation.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for users?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For JAX users, this change does not require any code changes now, but we hope
    that you will find the upgrade worthwhile and switch to using typed keys. To try
    this out, replace uses of jax.random.PRNGKey() with jax.random.key(). This may
    introduce breakages in your code that fall into one of a few categories:'
  prefs: []
  type: TYPE_NORMAL
- en: If your code performs unsafe/unsupported operations on keys (such as indexing,
    arithmetic, transposition, etc; see Type Safety section below), this change will
    catch it. You can update your code to avoid such unsupported operations, or use
    `jax.random.key_data()` and `jax.random.wrap_key_data()` to manipulate raw key
    buffers in an unsafe way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code includes explicit logic about `key.shape`, you may need to update
    this logic to account for the fact that the trailing key buffer dimension is no
    longer an explicit part of the shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code includes explicit logic about `key.dtype`, you will need to upgrade
    it to use the new public APIs for reasoning about RNG dtypes, such as `dtypes.issubdtype(dtype,
    dtypes.prng_key)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you call a JAX-based library which does not yet handle typed PRNG keys, you
    can use `raw_key = jax.random.key_data(key)` for now to recover the raw buffer,
    but please keep a TODO to remove this once the downstream library supports typed
    RNG keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point in the future, we plan to deprecate `jax.random.PRNGKey()` and
    require the use of `jax.random.key()`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting new-style typed keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check whether an object is a new-style typed PRNG key, you can use `jax.dtypes.issubdtype`
    or `jax.numpy.issubdtype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Type annotations for PRNG Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recommended type annotation for both old and new-style PRNG keys is `jax.Array`.
    A PRNG key is distinguished from other arrays based on its `dtype`, and it is
    not currently possible to specify dtypes of JAX arrays within a type annotation.
    Previously it was possible to use `jax.random.KeyArray` or `jax.random.PRNGKeyArray`
    as type annotations, but these have always been aliased to `Any` under type checking,
    and so `jax.Array` has much more specificity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: `jax.random.KeyArray` and `jax.random.PRNGKeyArray` were deprecated
    in JAX version 0.4.16, and removed in JAX version 0.4.24*.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes for JAX library authors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you maintain a JAX-based library, your users are also JAX users. Know that
    JAX will continue to support “raw” old-style keys in `jax.random` for now, so
    callers may expect them to remain accepted everywhere. If you prefer to require
    new-style typed keys in your library, then you may want to enforce them with a
    check along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two major motivating factors for this change are customizability and safety.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing PRNG implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX currently operates with a single, globally configured PRNG algorithm. A
    PRNG key is a vector of unsigned 32-bit integers, which jax.random APIs consume
    to produce pseudorandom streams. Any higher-rank uint32 array is interpreted as
    an array of such key buffers, where the trailing dimension represents keys.
  prefs: []
  type: TYPE_NORMAL
- en: The drawbacks of this design became clearer as we introduced alternative PRNG
    implementations, which must be selected by setting a global or local configuration
    flag. Different PRNG implementations have different size key buffers, and different
    algorithms for generating random bits. Determining this behavior with a global
    flag is error-prone, especially when there is more than one key implementation
    in use process-wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new approach is to carry the implementation as part of the PRNG key type,
    i.e. with the element type of the key array. Using the new key API, here is an
    example of generating pseudorandom values under the default threefry2x32 implementation
    (which is implemented in pure Python and compiled with JAX), and under the non-default
    rbg implementation (which corresponds to a single XLA random-bit generation operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Safe PRNG key use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PRNG keys are really only meant to support a few operations in principle, namely
    key derivation (e.g. splitting) and random number generation. The PRNG is designed
    to generate independent pseudorandom numbers, provided keys are properly split
    and that every key is consumed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code that manipulates or consumes key data in other ways often indicates an
    accidental bug, and representing key arrays as raw uint32 buffers has allowed
    for easy misuse along these lines. Here are a few example misuses that we’ve encountered
    in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: Key buffer indexing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Access to the underlying integer buffers makes it easy to try and derive keys
    in non-standard ways, sometimes with unexpectedly bad consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If this key were a new-style typed key made with `random.key(999)`, indexing
    into the key buffer would error instead.
  prefs: []
  type: TYPE_NORMAL
- en: Key arithmetic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Key arithmetic is a similarly treacherous way to derive keys from other keys.
    Deriving keys in a way that avoids `jax.random.split()` or `jax.random.fold_in()`
    by manipulating key data directly produces a batch of keys that—depending on the
    PRNG implementation—might then generate correlated random numbers within the batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: New-style typed keys created with `random.key(0)` address this by disallowing
    arithmetic operations on keys.
  prefs: []
  type: TYPE_NORMAL
- en: Inadvertent transposing of key buffers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With “raw” old-style key arrays, it’s easy to accidentally swap batch (leading)
    dimensions and key buffer (trailing) dimensions. Again this possibly results in
    keys that produce correlated pseudorandomness. A pattern that we’ve seen over
    time boils down to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The bug here is subtle. By mapping over `in_axes=1`, this code makes new keys
    by combining a single element from each key buffer in the batch. The resulting
    keys are different from one another, but are effectively “derived” in a non-standard
    way. Again, the PRNG is not designed or tested to produce independent random streams
    from such a key batch.
  prefs: []
  type: TYPE_NORMAL
- en: New-style typed keys created with `random.key(0)` address this by hiding the
    buffer representation of individual keys, instead treating keys as opaque elements
    of a key array. Key arrays have no trailing “buffer” dimension to index, transpose,
    or map over.
  prefs: []
  type: TYPE_NORMAL
- en: Key reuse
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike state-based PRNG APIs like [`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0)"), JAX’s functional PRNG does not implicitly update a key when
    it has been used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’re actively working on tools to detect and prevent unintended key reuse.
    This is still work in progress, but it relies on typed key arrays. Upgrading to
    typed keys now sets us up to introduce these safety features as we build them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Design of typed PRNG keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typed PRNG keys are implemented as an instance of extended dtypes within JAX,
    of which the new PRNG dtypes are a sub-dtype.
  prefs: []
  type: TYPE_NORMAL
- en: Extended dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the user perspective, an extended dtype dt has the following user-visible
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jax.dtypes.issubdtype(dt, jax.dtypes.extended)` returns `True`: this is the
    public API that should be used to detect whether a dtype is an extended dtype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a class-level attribute `dt.type`, which returns a typeclass in the hierarchy
    of `numpy.generic`. This is analogous to how `np.dtype('int32').type` returns
    `numpy.int32`, which is not a dtype but rather a scalar type, and a subclass of
    `numpy.generic`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike numpy scalar types, we do not allow instantiation of `dt.type` scalar
    objects: this is in accordance with JAX’s decision to represent scalar values
    as zero-dimensional arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a non-public implementation perspective, an extended dtype has the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Its type is a subclass of the private base class `jax._src.dtypes.ExtendedDtype`,
    the non-public base class used for extended dtypes. An instance of `ExtendedDtype`
    is analogous to an instance of `np.dtype`, like `np.dtype('int32')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a private `_rules` attribute which allows the dtype to define how it
    behaves under particular operations. For example, `jax.lax.full(shape, fill_value,
    dtype)` will delegate to `dtype._rules.full(shape, fill_value, dtype)` when `dtype`
    is an extended dtype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why introduce extended dtypes in generality, beyond PRNGs? We reuse this same
    extended dtype mechanism elsewhere internally. For example, the `jax._src.core.bint`
    object, a bounded integer type used for experimental work on dynamic shapes, is
    another extended dtype. In recent JAX versions it satisfies the properties above
    (See [jax/_src/core.py#L1789-L1802](https://github.com/google/jax/blob/jax-v0.4.14/jax/_src/core.py#L1789-L1802)).
  prefs: []
  type: TYPE_NORMAL
- en: PRNG dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PRNG dtypes are defined as a particular case of extended dtypes. Specifically,
    this change introduces a new public scalar type class jax.dtypes.prng_key, which
    has the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'PRNG key arrays then have a dtype with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And in addition to `key.dtype._rules` as outlined for extended dtypes in general,
    PRNG dtypes define `key.dtype._impl`, which contains the metadata that defines
    the PRNG implementation. The PRNG implementation is currently defined by the non-public
    `jax._src.prng.PRNGImpl` class. For now, `PRNGImpl` isn’t meant to be a public
    API, but we might revisit this soon to allow for fully custom PRNG implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following is a non-comprehensive list of key Pull Requests implementing the
    above design. The main tracking issue is [#9263](https://github.com/google/jax/issues/9263).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement pluggable PRNG via `PRNGImpl`: [#6899](https://github.com/google/jax/issues/6899)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement `PRNGKeyArray`, without dtype: [#11952](https://github.com/google/jax/issues/11952)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a “custom element” dtype property to `PRNGKeyArray` with `_rules` attribute:
    [#12167](https://github.com/google/jax/issues/12167)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rename “custom element type” to “opaque dtype”: [#12170](https://github.com/google/jax/issues/12170)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refactor `bint` to use the opaque dtype infrastructure: [#12707](https://github.com/google/jax/issues/12707)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add `jax.random.key` to create typed keys directly: [#16086](https://github.com/google/jax/issues/16086)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add `impl` argument to `key` and `PRNGKey`: [#16589](https://github.com/google/jax/issues/16589)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rename “opaque dtype” to “extended dtype” & define `jax.dtypes.extended`: [#16824](https://github.com/google/jax/issues/16824)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduce `jax.dtypes.prng_key` and unify PRNG dtype with Extended dtype: [#16781](https://github.com/google/jax/issues/16781)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a `jax_legacy_prng_key` flag to support warning or erroring when using
    legacy (raw) PRNG keys: [#17225](https://github.com/google/jax/issues/17225)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
