- en: Pseudorandom numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/random-numbers.html`](https://jax.readthedocs.io/en/latest/random-numbers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section we focus on `jax.random` and pseudo random number generation
    (PRNG); that is, the process of algorithmically generating sequences of numbers
    whose properties approximate the properties of sequences of random numbers sampled
    from an appropriate distribution.
  prefs: []
  type: TYPE_NORMAL
- en: PRNG-generated sequences are not truly random because they are actually determined
    by their initial value, which is typically referred to as the `seed`, and each
    step of random sampling is a deterministic function of some `state` that is carried
    over from a sample to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo random number generation is an essential component of any machine learning
    or scientific computing framework. Generally, JAX strives to be compatible with
    NumPy, but pseudo random number generation is a notable exception.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the difference between the approaches taken by JAX and
    NumPy when it comes to random number generation we will discuss both approaches
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pseudo random number generation is natively supported in NumPy by the [`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0)") module. In NumPy, pseudo random number generation is based
    on a global `state`, which can be set to a deterministic initial condition using
    [`numpy.random.seed()`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.seed.html#numpy.random.seed
    "(in NumPy v2.0)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can inspect the content of the state using the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `state` is updated by each call to a random function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy allows you to sample both individual numbers, or entire vectors of numbers
    in a single function call. For instance, you may sample a vector of 3 scalars
    from a uniform distribution by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy provides a *sequential equivalent guarantee*, meaning that sampling N
    numbers in a row individually or sampling a vector of N numbers results in the
    same pseudo-random sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Random numbers in JAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JAX’s random number generation differs from NumPy’s in important ways, because
    NumPy’s PRNG design makes it hard to simultaneously guarantee a number of desirable
    properties. Specifically, in JAX we want PRNG generation to be:'
  prefs: []
  type: TYPE_NORMAL
- en: reproducible,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: parallelizable,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: vectorisable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will discuss why in the following. First, we will focus on the implications
    of a PRNG design based on a global state. Consider the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function `foo` sums two scalars sampled from a uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code can only satisfy requirement #1 if we assume a predictable
    order of execution for `bar()` and `baz()`. This is not a problem in NumPy, which
    always evaluates code in the order defined by the Python interpreter. In JAX,
    however, this is more problematic: for efficient execution, we want the JIT compiler
    to be free to reorder, elide, and fuse various operations in the function we define.
    Further, when executing in multi-device environments, execution efficiency would
    be hampered by the need for each process to synchronize a global state.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit random state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To avoid this issue, JAX avoids implicit global random state, and instead tracks
    state explicitly via a random `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This section uses the new-style typed PRNG keys produced by `jax.random.key()`,
    rather than the old-style raw PRNG keys produced by `jax.random.PRNGKey()`. For
    details, see JEP 9263: Typed keys & pluggable RNGs.'
  prefs: []
  type: TYPE_NORMAL
- en: A key is an array with a special dtype corresponding to the particular PRNG
    implementation being used; in the default implementation each key is backed by
    a pair of `uint32` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is effectively a stand-in for NumPy’s hidden state object, but we pass
    it explicitly to `jax.random()` functions. Importantly, random functions consume
    the key, but do not modify it: feeding the same key object to a random function
    will always result in the same sample being generated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Re-using the same key, even with different `random` APIs, can result in correlated
    outputs, which is generally undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: '**The rule of thumb is: never reuse keys (unless you want identical outputs).**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate different and independent samples, you must `split()`
    the key explicitly before passing it to a random function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: (Calling `del` here is not required, but we do so to emphasize that the key
    should not be reused once consumed.)
  prefs: []
  type: TYPE_NORMAL
- en: '`jax.random.split()` is a deterministic function that converts one `key` into
    several independent (in the pseudorandomness sense) keys. We keep one of the outputs
    as the `new_key`, and can safely use the unique extra key (called `subkey`) as
    input into a random function, and then discard it forever. If you wanted to get
    another sample from the normal distribution, you would split `key` again, and
    so on: the crucial point is that you never use the same key twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn’t matter which part of the output of `split(key)` we call `key`, and
    which we call `subkey`. They are all independent keys with equal status. The key/subkey
    naming convention is a typical usage pattern that helps track how keys are consumed:
    subkeys are destined for immediate consumption by random functions, while the
    key is retained to generate more randomness later.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the above example would be written concisely as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'which discards the old key automatically. It’s worth noting that `split()`
    can create as many keys as you need, not just 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Lack of sequential equivalence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another difference between NumPy’s and JAX’s random modules relates to the sequential
    equivalence guarantee mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in NumPy, JAX’s random module also allows sampling of vectors of numbers.
    However, JAX does not provide a sequential equivalence guarantee, because doing
    so would interfere with the vectorization on SIMD hardware (requirement #3 above).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, sampling 3 values out of a normal distribution individually
    using three subkeys gives a different result to using giving a single key and
    specifying `shape=(3,)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The lack of sequential equivalence gives us freedom to write code more efficiently;
    for example, instead of generating `sequence` above via a sequential loop, we
    can use `jax.vmap()` to compute the same result in a vectorized manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on JAX random numbers, refer to the documentation of the
    `jax.random` module. If you’re interested in the details of the design of JAX’s
    random number generator, see JAX PRNG Design.
  prefs: []
  type: TYPE_NORMAL
