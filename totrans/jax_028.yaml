- en: External Callbacks in JAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/notebooks/external_callbacks.html`](https://jax.readthedocs.io/en/latest/notebooks/external_callbacks.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This guide outlines the uses of various callback functions, which allow JAX
    runtimes to execute Python code on the host, even while running under `jit`, `vmap`,
    `grad`, or another transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Why callbacks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A callback routine is a way to perform **host-side** execution of code at runtime.
    As a simple example, suppose you’d like to print the *value* of some variable
    during the course of a computation. Using a simple Python `print` statement, it
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What is printed is not the runtime value, but the trace-time abstract value
    (if you’re not famililar with *tracing* in JAX, a good primer can be found in
    [How To Think In JAX](https://jax.readthedocs.io/en/latest/notebooks/thinking_in_jax.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the value at runtime we need a callback, for example `jax.debug.print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This works by passing the runtime value represented by `y` back to the host
    process, where the host can print the value.
  prefs: []
  type: TYPE_NORMAL
- en: Flavors of Callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier versions of JAX, there was only one kind of callback available,
    implemented in `jax.experimental.host_callback`. The `host_callback` routines
    had some deficiencies, and are now deprecated in favor of several callbacks designed
    for different situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jax.pure_callback()`: appropriate for pure functions: i.e. functions with
    no side effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jax.experimental.io_callback()`: appropriate for impure functions: e.g. functions
    which read or write data to disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jax.debug.callback()`: appropriate for functions that should reflect the execution
    behavior of the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (The `jax.debug.print()` function we used above is a wrapper around `jax.debug.callback()`).
  prefs: []
  type: TYPE_NORMAL
- en: From the user perspective, these three flavors of callback are mainly distinguished
    by what transformations and compiler optimizations they allow.
  prefs: []
  type: TYPE_NORMAL
- en: '| callback function | supports return value | `jit` | `vmap` | `grad` | `scan`/`while_loop`
    | guaranteed execution |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `jax.pure_callback` | ✅ | ✅ | ✅ | ❌¹ | ✅ | ❌ |'
  prefs: []
  type: TYPE_TB
- en: '| `jax.experimental.io_callback` | ✅ | ✅ | ✅/❌² | ❌ | ✅³ | ✅ |'
  prefs: []
  type: TYPE_TB
- en: '| `jax.debug.callback` | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ |'
  prefs: []
  type: TYPE_TB
- en: ¹ `jax.pure_callback` can be used with `custom_jvp` to make it compatible with
    autodiff
  prefs: []
  type: TYPE_NORMAL
- en: ² `jax.experimental.io_callback` is compatible with `vmap` only if `ordered=False`.
  prefs: []
  type: TYPE_NORMAL
- en: ³ Note that `vmap` of `scan`/`while_loop` of `io_callback` has complicated semantics,
    and its behavior may change in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring `jax.pure_callback`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`jax.pure_callback` is generally the callback function you should reach for
    when you want host-side execution of a pure function: i.e. a function that has
    no side-effects (such as printing values, reading data from disk, updating a global
    state, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: The function you pass to `jax.pure_callback` need not actually be pure, but
    it will be assumed pure by JAX’s transformations and higher-order functions, which
    means that it may be silently elided or called multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because `pure_callback` can be elided or duplicated, it is compatible out-of-the-box
    with transformations like `jit` and `vmap`, as well as higher-order primitives
    like `scan` and `while_loop`:”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because there is no way for JAX to introspect the content of the callback,
    `pure_callback` has undefined autodiff semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For an example of using `pure_callback` with `jax.custom_jvp`, see *Example:
    `pure_callback` with `custom_jvp`* below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By design functions passed to `pure_callback` are treated as if they have no
    side-effects: one consequence of this is that if the output of the function is
    not used, the compiler may eliminate the callback entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In `f1`, the output of the callback is used in the return value of the function,
    so the callback is executed and we see the printed output. In `f2` on the other
    hand, the output of the callback is unused, and so the compiler notices this and
    eliminates the function call. These are the correct semantics for a callback to
    a function with no side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring `jax.experimental.io_callback`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to `jax.pure_callback()`, `jax.experimental.io_callback()` is explicitly
    meant to be used with impure functions, i.e. functions that do have side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, here is a callback to a global host-side numpy random generator.
    This is an impure operation because a side-effect of generating a random number
    in numpy is that the random state is updated (Please note that this is meant as
    a toy example of `io_callback` and not necessarily a recommended way of generating
    random numbers in JAX!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `io_callback` is compatible with `vmap` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that this may execute the mapped callbacks in any order. So,
    for example, if you ran this on a GPU, the order of the mapped outputs might differ
    from run to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is important that the order of callbacks be preserved, you can set `ordered=True`,
    in which case attempting to `vmap` will raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `scan` and `while_loop` work with `io_callback` regardless
    of whether ordering is enforced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `pure_callback`, `io_callback` fails under automatic differentiation if
    it is passed a differentiated variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the callback is not dependent on a differentiated variable, it
    will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `pure_callback`, the compiler will not remove the callback execution
    in this case, even though the output of the callback is unused in the subsequent
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring `debug.callback`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both `pure_callback` and `io_callback` enforce some assumptions about the purity
    of the function they’re calling, and limit in various ways what JAX transforms
    and compilation machinery may do. `debug.callback` essentially assumes *nothing*
    about the callback function, such that the action of the callback reflects exactly
    what JAX is doing during the course of a program. Further, `debug.callback` *cannot*
    return any value to the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The debug callback is compatible with `vmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And is also compatible with `grad` and other autodiff transformations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This can make `debug.callback` more useful for general-purpose debugging than
    either `pure_callback` or `io_callback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `pure_callback` with `custom_jvp`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One powerful way to take advantage of `jax.pure_callback()` is to combine it
    with `jax.custom_jvp` (see [Custom derivative rules](https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html)
    for more details on `custom_jvp`). Suppose we want to create a JAX-compatible
    wrapper for a scipy or numpy function that is not yet available in the `jax.scipy`
    or `jax.numpy` wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ll consider creating a wrapper for the Bessel function of the first
    kind, implemented in `scipy.special.jv`. We can start by defining a straightforward
    `pure_callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us call into `scipy.special.jv` from transformed JAX code, including
    when transformed by `jit` and `vmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same result with `jit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the same result again with `vmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we call `jax.grad`, we see an error because there is no autodiff
    rule defined for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define a custom gradient rule for this. Looking at the definition of
    the [Bessel Function of the First Kind](https://en.wikipedia.org/?title=Bessel_function_of_the_first_kind),
    we find that there is a relatively straightforward recurrence relationship for
    the derivative with respect to the argument `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} d J_\nu(z) = \left\{ \begin{eqnarray} -J_1(z),\ &\nu=0\\ [J_{\nu
    - 1}(z) - J_{\nu + 1}(z)]/2,\ &\nu\ne 0 \end{eqnarray}\right. \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: The gradient with respect to \(\nu\) is more complicated, but since we’ve restricted
    the `v` argument to integer types we don’t need to worry about its gradient for
    the sake of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `jax.custom_jvp` to define this automatic differentiation rule for
    our callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now computing the gradient of our function will work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, since we’ve defined our gradient in terms of `jv` itself, JAX’s architecture
    means that we get second-order and higher derivatives for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that although this all works correctly with JAX, each call to our
    callback-based `jv` function will result in passing the input data from the device
    to the host, and passing the output of `scipy.special.jv` from the host back to
    the device. When running on accelerators like GPU or TPU, this data movement and
    host synchronization can lead to significant overhead each time `jv` is called.
    However, if you are running JAX on a single CPU (where the “host” and “device”
    are on the same hardware), JAX will generally do this data transfer in a fast,
    zero-copy fashion, making this pattern is a relatively straightforward way extend
    JAX’s capabilities.
  prefs: []
  type: TYPE_NORMAL
