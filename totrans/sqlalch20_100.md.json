["```py\nengine = create_engine(\n    \"postgresql+psycopg2://me@localhost/mydb\", pool_size=20, max_overflow=0\n)\n```", "```py\nfrom sqlalchemy.pool import NullPool\n\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\", poolclass=NullPool\n)\n```", "```py\nimport sqlalchemy.pool as pool\nimport psycopg2\n\ndef getconn():\n    c = psycopg2.connect(user=\"ed\", host=\"127.0.0.1\", dbname=\"test\")\n    return c\n\nmypool = pool.QueuePool(getconn, max_overflow=10, pool_size=5)\n```", "```py\n# get a connection\nconn = mypool.connect()\n\n# use it\ncursor_obj = conn.cursor()\ncursor_obj.execute(\"select foo\")\n```", "```py\n# \"close\" the connection.  Returns\n# it to the pool.\nconn.close()\n```", "```py\nnon_acid_engine = create_engine(\n    \"mysql://scott:tiger@host/db\",\n    pool_reset_on_return=None,\n    isolation_level=\"AUTOCOMMIT\",\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\n\nmssql_engine = create_engine(\n    \"mssql+pyodbc://scott:tiger^5HHH@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    # disable default reset-on-return scheme\n    pool_reset_on_return=None,\n)\n\n@event.listens_for(mssql_engine, \"reset\")\ndef _reset_mssql(dbapi_connection, connection_record, reset_state):\n    if not reset_state.terminate_only:\n        dbapi_connection.execute(\"{call sys.sp_reset_connection}\")\n\n    # so that the DBAPI itself knows that the connection has been\n    # reset\n    dbapi_connection.rollback()\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> engine = create_engine(\"postgresql://scott:tiger@localhost/test\", echo_pool=\"debug\")\n```", "```py\n>>> c1 = engine.connect()\nDEBUG sqlalchemy.pool.impl.QueuePool Created new connection <connection object ...>\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> checked out from pool\n>>> c1.close()\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> being returned to pool\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> rollback-on-return\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pw@host/db\", pool_pre_ping=True)\n```", "```py\nfrom sqlalchemy import exc\nfrom sqlalchemy import event\nfrom sqlalchemy import select\n\nsome_engine = create_engine(...)\n\n@event.listens_for(some_engine, \"engine_connect\")\ndef ping_connection(connection, branch):\n    if branch:\n        # this parameter is always False as of SQLAlchemy 2.0,\n        # but is still accepted by the event hook.  In 1.x versions\n        # of SQLAlchemy, \"branched\" connections should be skipped.\n        return\n\n    try:\n        # run a SELECT 1\\.   use a core select() so that\n        # the SELECT of a scalar value without a table is\n        # appropriately formatted for the backend\n        connection.scalar(select(1))\n    except exc.DBAPIError as err:\n        # catch SQLAlchemy's DBAPIError, which is a wrapper\n        # for the DBAPI's exception.  It includes a .connection_invalidated\n        # attribute which specifies if this connection is a \"disconnect\"\n        # condition, which is based on inspection of the original exception\n        # by the dialect in use.\n        if err.connection_invalidated:\n            # run the same SELECT again - the connection will re-validate\n            # itself and establish a new connection.  The disconnect detection\n            # here also causes the whole connection pool to be invalidated\n            # so that all stale connections are discarded.\n            connection.scalar(select(1))\n        else:\n            raise\n```", "```py\nfrom sqlalchemy import create_engine, exc\n\ne = create_engine(...)\nc = e.connect()\n\ntry:\n    # suppose the database has been restarted.\n    c.execute(text(\"SELECT * FROM table\"))\n    c.close()\nexcept exc.DBAPIError as e:\n    # an exception is raised, Connection is invalidated.\n    if e.connection_invalidated:\n        print(\"Connection was invalidated!\")\n\n# after the invalidate event, a new connection\n# starts with a new Pool\nc = e.connect()\nc.execute(text(\"SELECT * FROM table\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", pool_recycle=3600)\n```", "```py\nimport re\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle://scott:tiger@dnsname\")\n\n@event.listens_for(engine, \"handle_error\")\ndef handle_exception(context: ExceptionContext) -> None:\n    if not context.is_disconnect and re.match(\n        r\"^(?:DPI-1001|DPI-4011)\", str(context.original_exception)\n    ):\n        context.is_disconnect = True\n\n    return None\n```", "```py\nengine = create_engine(\"postgreql://\", pool_use_lifo=True, pool_pre_ping=True)\n```", "```py\n    from sqlalchemy.pool import NullPool\n\n    engine = create_engine(\"mysql+mysqldb://user:pass@host/dbname\", poolclass=NullPool)\n    ```", "```py\n    from multiprocessing import Pool\n\n    engine = create_engine(\"mysql+mysqldb://user:pass@host/dbname\")\n\n    def run_in_process(some_data_record):\n        with engine.connect() as conn:\n            conn.execute(text(\"...\"))\n\n    def initializer():\n      \"\"\"ensure the parent proc's database connections are not touched\n     in the new connection pool\"\"\"\n        engine.dispose(close=False)\n\n    with Pool(10, initializer=initializer) as p:\n        p.map(run_in_process, data)\n    ```", "```py\n    engine = create_engine(\"mysql://user:pass@host/dbname\")\n\n    def run_in_process():\n        with engine.connect() as conn:\n            conn.execute(text(\"...\"))\n\n    # before process starts, ensure engine.dispose() is called\n    engine.dispose()\n    p = Process(target=run_in_process)\n    p.start()\n    ```", "```py\n    from sqlalchemy import event\n    from sqlalchemy import exc\n    import os\n\n    engine = create_engine(\"...\")\n\n    @event.listens_for(engine, \"connect\")\n    def connect(dbapi_connection, connection_record):\n        connection_record.info[\"pid\"] = os.getpid()\n\n    @event.listens_for(engine, \"checkout\")\n    def checkout(dbapi_connection, connection_record, connection_proxy):\n        pid = os.getpid()\n        if connection_record.info[\"pid\"] != pid:\n            connection_record.dbapi_connection = connection_proxy.dbapi_connection = None\n            raise exc.DisconnectionError(\n                \"Connection record belongs to pid %s, \"\n                \"attempting to check out in pid %s\" % (connection_record.info[\"pid\"], pid)\n            )\n    ```", "```py\nfrom sqlalchemy import create_pool_from_url\n\nmy_pool = create_pool_from_url(\n    \"mysql+mysqldb://\", max_overflow=5, pool_size=5, pre_ping=True\n)\n\ncon = my_pool.connect()\n# use the connection\n...\n# then close it\ncon.close()\n```", "```py\nfrom sqlalchemy import create_pool_from_url\nfrom sqlalchemy import NullPool\n\nmy_pool = create_pool_from_url(\"mysql+mysqldb://\", poolclass=NullPool)\n```", "```py\nclass sqlalchemy.pool.Pool\n```", "```py\nmethod __init__(creator: _CreatorFnType | _CreatorWRecFnType, recycle: int = -1, echo: log._EchoFlagType = None, logging_name: str | None = None, reset_on_return: _ResetStyleArgType = True, events: List[Tuple[_ListenerFnType, str]] | None = None, dialect: _ConnDialect | Dialect | None = None, pre_ping: bool = False, _dispatch: _DispatchCommon[Pool] | None = None)\n```", "```py\nmethod connect() \u2192 PoolProxiedConnection\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 Pool\n```", "```py\nclass sqlalchemy.pool.QueuePool\n```", "```py\nmethod __init__(creator: _CreatorFnType | _CreatorWRecFnType, pool_size: int = 5, max_overflow: int = 10, timeout: float = 30.0, use_lifo: bool = False, **kw: Any)\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 QueuePool\n```", "```py\nclass sqlalchemy.pool.AsyncAdaptedQueuePool\n```", "```py\nclass sqlalchemy.pool.SingletonThreadPool\n```", "```py\nmethod connect() \u2192 PoolProxiedConnection\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 SingletonThreadPool\n```", "```py\nclass sqlalchemy.pool.AssertionPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 AssertionPool\n```", "```py\nclass sqlalchemy.pool.NullPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 NullPool\n```", "```py\nclass sqlalchemy.pool.StaticPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 StaticPool\n```", "```py\nclass sqlalchemy.pool.ManagesConnection\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool.ConnectionPoolEntry\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute in_use\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool.PoolProxiedConnection\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nmethod detach() \u2192 None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute is_detached\n```", "```py\nattribute is_valid\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool._ConnectionFairy\n```", "```py\nclass sqlalchemy.pool._ConnectionRecord\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://me@localhost/mydb\", pool_size=20, max_overflow=0\n)\n```", "```py\nfrom sqlalchemy.pool import NullPool\n\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\", poolclass=NullPool\n)\n```", "```py\nimport sqlalchemy.pool as pool\nimport psycopg2\n\ndef getconn():\n    c = psycopg2.connect(user=\"ed\", host=\"127.0.0.1\", dbname=\"test\")\n    return c\n\nmypool = pool.QueuePool(getconn, max_overflow=10, pool_size=5)\n```", "```py\n# get a connection\nconn = mypool.connect()\n\n# use it\ncursor_obj = conn.cursor()\ncursor_obj.execute(\"select foo\")\n```", "```py\n# \"close\" the connection.  Returns\n# it to the pool.\nconn.close()\n```", "```py\nnon_acid_engine = create_engine(\n    \"mysql://scott:tiger@host/db\",\n    pool_reset_on_return=None,\n    isolation_level=\"AUTOCOMMIT\",\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\n\nmssql_engine = create_engine(\n    \"mssql+pyodbc://scott:tiger^5HHH@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    # disable default reset-on-return scheme\n    pool_reset_on_return=None,\n)\n\n@event.listens_for(mssql_engine, \"reset\")\ndef _reset_mssql(dbapi_connection, connection_record, reset_state):\n    if not reset_state.terminate_only:\n        dbapi_connection.execute(\"{call sys.sp_reset_connection}\")\n\n    # so that the DBAPI itself knows that the connection has been\n    # reset\n    dbapi_connection.rollback()\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> engine = create_engine(\"postgresql://scott:tiger@localhost/test\", echo_pool=\"debug\")\n```", "```py\n>>> c1 = engine.connect()\nDEBUG sqlalchemy.pool.impl.QueuePool Created new connection <connection object ...>\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> checked out from pool\n>>> c1.close()\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> being returned to pool\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> rollback-on-return\n```", "```py\nnon_acid_engine = create_engine(\n    \"mysql://scott:tiger@host/db\",\n    pool_reset_on_return=None,\n    isolation_level=\"AUTOCOMMIT\",\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\n\nmssql_engine = create_engine(\n    \"mssql+pyodbc://scott:tiger^5HHH@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    # disable default reset-on-return scheme\n    pool_reset_on_return=None,\n)\n\n@event.listens_for(mssql_engine, \"reset\")\ndef _reset_mssql(dbapi_connection, connection_record, reset_state):\n    if not reset_state.terminate_only:\n        dbapi_connection.execute(\"{call sys.sp_reset_connection}\")\n\n    # so that the DBAPI itself knows that the connection has been\n    # reset\n    dbapi_connection.rollback()\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> engine = create_engine(\"postgresql://scott:tiger@localhost/test\", echo_pool=\"debug\")\n```", "```py\n>>> c1 = engine.connect()\nDEBUG sqlalchemy.pool.impl.QueuePool Created new connection <connection object ...>\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> checked out from pool\n>>> c1.close()\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> being returned to pool\nDEBUG sqlalchemy.pool.impl.QueuePool Connection <connection object ...> rollback-on-return\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pw@host/db\", pool_pre_ping=True)\n```", "```py\nfrom sqlalchemy import exc\nfrom sqlalchemy import event\nfrom sqlalchemy import select\n\nsome_engine = create_engine(...)\n\n@event.listens_for(some_engine, \"engine_connect\")\ndef ping_connection(connection, branch):\n    if branch:\n        # this parameter is always False as of SQLAlchemy 2.0,\n        # but is still accepted by the event hook.  In 1.x versions\n        # of SQLAlchemy, \"branched\" connections should be skipped.\n        return\n\n    try:\n        # run a SELECT 1\\.   use a core select() so that\n        # the SELECT of a scalar value without a table is\n        # appropriately formatted for the backend\n        connection.scalar(select(1))\n    except exc.DBAPIError as err:\n        # catch SQLAlchemy's DBAPIError, which is a wrapper\n        # for the DBAPI's exception.  It includes a .connection_invalidated\n        # attribute which specifies if this connection is a \"disconnect\"\n        # condition, which is based on inspection of the original exception\n        # by the dialect in use.\n        if err.connection_invalidated:\n            # run the same SELECT again - the connection will re-validate\n            # itself and establish a new connection.  The disconnect detection\n            # here also causes the whole connection pool to be invalidated\n            # so that all stale connections are discarded.\n            connection.scalar(select(1))\n        else:\n            raise\n```", "```py\nfrom sqlalchemy import create_engine, exc\n\ne = create_engine(...)\nc = e.connect()\n\ntry:\n    # suppose the database has been restarted.\n    c.execute(text(\"SELECT * FROM table\"))\n    c.close()\nexcept exc.DBAPIError as e:\n    # an exception is raised, Connection is invalidated.\n    if e.connection_invalidated:\n        print(\"Connection was invalidated!\")\n\n# after the invalidate event, a new connection\n# starts with a new Pool\nc = e.connect()\nc.execute(text(\"SELECT * FROM table\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", pool_recycle=3600)\n```", "```py\nimport re\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle://scott:tiger@dnsname\")\n\n@event.listens_for(engine, \"handle_error\")\ndef handle_exception(context: ExceptionContext) -> None:\n    if not context.is_disconnect and re.match(\n        r\"^(?:DPI-1001|DPI-4011)\", str(context.original_exception)\n    ):\n        context.is_disconnect = True\n\n    return None\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pw@host/db\", pool_pre_ping=True)\n```", "```py\nfrom sqlalchemy import exc\nfrom sqlalchemy import event\nfrom sqlalchemy import select\n\nsome_engine = create_engine(...)\n\n@event.listens_for(some_engine, \"engine_connect\")\ndef ping_connection(connection, branch):\n    if branch:\n        # this parameter is always False as of SQLAlchemy 2.0,\n        # but is still accepted by the event hook.  In 1.x versions\n        # of SQLAlchemy, \"branched\" connections should be skipped.\n        return\n\n    try:\n        # run a SELECT 1\\.   use a core select() so that\n        # the SELECT of a scalar value without a table is\n        # appropriately formatted for the backend\n        connection.scalar(select(1))\n    except exc.DBAPIError as err:\n        # catch SQLAlchemy's DBAPIError, which is a wrapper\n        # for the DBAPI's exception.  It includes a .connection_invalidated\n        # attribute which specifies if this connection is a \"disconnect\"\n        # condition, which is based on inspection of the original exception\n        # by the dialect in use.\n        if err.connection_invalidated:\n            # run the same SELECT again - the connection will re-validate\n            # itself and establish a new connection.  The disconnect detection\n            # here also causes the whole connection pool to be invalidated\n            # so that all stale connections are discarded.\n            connection.scalar(select(1))\n        else:\n            raise\n```", "```py\nfrom sqlalchemy import exc\nfrom sqlalchemy import event\nfrom sqlalchemy import select\n\nsome_engine = create_engine(...)\n\n@event.listens_for(some_engine, \"engine_connect\")\ndef ping_connection(connection, branch):\n    if branch:\n        # this parameter is always False as of SQLAlchemy 2.0,\n        # but is still accepted by the event hook.  In 1.x versions\n        # of SQLAlchemy, \"branched\" connections should be skipped.\n        return\n\n    try:\n        # run a SELECT 1\\.   use a core select() so that\n        # the SELECT of a scalar value without a table is\n        # appropriately formatted for the backend\n        connection.scalar(select(1))\n    except exc.DBAPIError as err:\n        # catch SQLAlchemy's DBAPIError, which is a wrapper\n        # for the DBAPI's exception.  It includes a .connection_invalidated\n        # attribute which specifies if this connection is a \"disconnect\"\n        # condition, which is based on inspection of the original exception\n        # by the dialect in use.\n        if err.connection_invalidated:\n            # run the same SELECT again - the connection will re-validate\n            # itself and establish a new connection.  The disconnect detection\n            # here also causes the whole connection pool to be invalidated\n            # so that all stale connections are discarded.\n            connection.scalar(select(1))\n        else:\n            raise\n```", "```py\nfrom sqlalchemy import create_engine, exc\n\ne = create_engine(...)\nc = e.connect()\n\ntry:\n    # suppose the database has been restarted.\n    c.execute(text(\"SELECT * FROM table\"))\n    c.close()\nexcept exc.DBAPIError as e:\n    # an exception is raised, Connection is invalidated.\n    if e.connection_invalidated:\n        print(\"Connection was invalidated!\")\n\n# after the invalidate event, a new connection\n# starts with a new Pool\nc = e.connect()\nc.execute(text(\"SELECT * FROM table\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", pool_recycle=3600)\n```", "```py\nfrom sqlalchemy import create_engine\n\ne = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", pool_recycle=3600)\n```", "```py\nimport re\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle://scott:tiger@dnsname\")\n\n@event.listens_for(engine, \"handle_error\")\ndef handle_exception(context: ExceptionContext) -> None:\n    if not context.is_disconnect and re.match(\n        r\"^(?:DPI-1001|DPI-4011)\", str(context.original_exception)\n    ):\n        context.is_disconnect = True\n\n    return None\n```", "```py\nengine = create_engine(\"postgreql://\", pool_use_lifo=True, pool_pre_ping=True)\n```", "```py\n    from sqlalchemy.pool import NullPool\n\n    engine = create_engine(\"mysql+mysqldb://user:pass@host/dbname\", poolclass=NullPool)\n    ```", "```py\n    from multiprocessing import Pool\n\n    engine = create_engine(\"mysql+mysqldb://user:pass@host/dbname\")\n\n    def run_in_process(some_data_record):\n        with engine.connect() as conn:\n            conn.execute(text(\"...\"))\n\n    def initializer():\n      \"\"\"ensure the parent proc's database connections are not touched\n     in the new connection pool\"\"\"\n        engine.dispose(close=False)\n\n    with Pool(10, initializer=initializer) as p:\n        p.map(run_in_process, data)\n    ```", "```py\n    engine = create_engine(\"mysql://user:pass@host/dbname\")\n\n    def run_in_process():\n        with engine.connect() as conn:\n            conn.execute(text(\"...\"))\n\n    # before process starts, ensure engine.dispose() is called\n    engine.dispose()\n    p = Process(target=run_in_process)\n    p.start()\n    ```", "```py\n    from sqlalchemy import event\n    from sqlalchemy import exc\n    import os\n\n    engine = create_engine(\"...\")\n\n    @event.listens_for(engine, \"connect\")\n    def connect(dbapi_connection, connection_record):\n        connection_record.info[\"pid\"] = os.getpid()\n\n    @event.listens_for(engine, \"checkout\")\n    def checkout(dbapi_connection, connection_record, connection_proxy):\n        pid = os.getpid()\n        if connection_record.info[\"pid\"] != pid:\n            connection_record.dbapi_connection = connection_proxy.dbapi_connection = None\n            raise exc.DisconnectionError(\n                \"Connection record belongs to pid %s, \"\n                \"attempting to check out in pid %s\" % (connection_record.info[\"pid\"], pid)\n            )\n    ```", "```py\nfrom sqlalchemy import create_pool_from_url\n\nmy_pool = create_pool_from_url(\n    \"mysql+mysqldb://\", max_overflow=5, pool_size=5, pre_ping=True\n)\n\ncon = my_pool.connect()\n# use the connection\n...\n# then close it\ncon.close()\n```", "```py\nfrom sqlalchemy import create_pool_from_url\nfrom sqlalchemy import NullPool\n\nmy_pool = create_pool_from_url(\"mysql+mysqldb://\", poolclass=NullPool)\n```", "```py\nclass sqlalchemy.pool.Pool\n```", "```py\nmethod __init__(creator: _CreatorFnType | _CreatorWRecFnType, recycle: int = -1, echo: log._EchoFlagType = None, logging_name: str | None = None, reset_on_return: _ResetStyleArgType = True, events: List[Tuple[_ListenerFnType, str]] | None = None, dialect: _ConnDialect | Dialect | None = None, pre_ping: bool = False, _dispatch: _DispatchCommon[Pool] | None = None)\n```", "```py\nmethod connect() \u2192 PoolProxiedConnection\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 Pool\n```", "```py\nclass sqlalchemy.pool.QueuePool\n```", "```py\nmethod __init__(creator: _CreatorFnType | _CreatorWRecFnType, pool_size: int = 5, max_overflow: int = 10, timeout: float = 30.0, use_lifo: bool = False, **kw: Any)\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 QueuePool\n```", "```py\nclass sqlalchemy.pool.AsyncAdaptedQueuePool\n```", "```py\nclass sqlalchemy.pool.SingletonThreadPool\n```", "```py\nmethod connect() \u2192 PoolProxiedConnection\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 SingletonThreadPool\n```", "```py\nclass sqlalchemy.pool.AssertionPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 AssertionPool\n```", "```py\nclass sqlalchemy.pool.NullPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 NullPool\n```", "```py\nclass sqlalchemy.pool.StaticPool\n```", "```py\nmethod dispose() \u2192 None\n```", "```py\nmethod recreate() \u2192 StaticPool\n```", "```py\nclass sqlalchemy.pool.ManagesConnection\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool.ConnectionPoolEntry\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute in_use\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool.PoolProxiedConnection\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute dbapi_connection: DBAPIConnection | None\n```", "```py\nmethod detach() \u2192 None\n```", "```py\nattribute driver_connection: Any | None\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(e: BaseException | None = None, soft: bool = False) \u2192 None\n```", "```py\nattribute is_detached\n```", "```py\nattribute is_valid\n```", "```py\nattribute record_info\n```", "```py\nclass sqlalchemy.pool._ConnectionFairy\n```", "```py\nclass sqlalchemy.pool._ConnectionRecord\n```"]