- en: Writing custom Jaxpr interpreters in JAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/notebooks/Writing_custom_interpreters_in_Jax.html`](https://jax.readthedocs.io/en/latest/notebooks/Writing_custom_interpreters_in_Jax.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Writing_custom_interpreters_in_Jax.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Writing_custom_interpreters_in_Jax.ipynb)'
  prefs: []
  type: TYPE_IMG
- en: JAX offers several composable function transformations (`jit`, `grad`, `vmap`,
    etc.) that enable writing concise, accelerated code.
  prefs: []
  type: TYPE_NORMAL
- en: Here we show how to add your own function transformations to the system, by
    writing a custom Jaxpr interpreter. And we’ll get composability with all the other
    transformations for free.
  prefs: []
  type: TYPE_NORMAL
- en: '**This example uses internal JAX APIs, which may break at any time. Anything
    not in [the API Documentation](https://jax.readthedocs.io/en/latest/jax.html)
    should be assumed internal.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is JAX doing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JAX provides a NumPy-like API for numerical computing which can be used as is,
    but JAX’s true power comes from composable function transformations. Take the
    `jit` function transformation, which takes in a function and returns a semantically
    identical function but is lazily compiled by XLA for accelerators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we call `fast_f`, what happens? JAX traces the function and constructs
    an XLA computation graph. The graph is then JIT-compiled and executed. Other transformations
    work similarly in that they first trace the function and handle the output trace
    in some way. To learn more about Jax’s tracing machinery, you can refer to the
    [“How it works”](https://github.com/google/jax#how-it-works) section in the README.
  prefs: []
  type: TYPE_NORMAL
- en: Jaxpr tracer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tracer of special importance in Jax is the Jaxpr tracer, which records ops
    into a Jaxpr (Jax expression). A Jaxpr is a data structure that can be evaluated
    like a mini functional programming language and thus Jaxprs are a useful intermediate
    representation for function transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a first look at Jaxprs, consider the `make_jaxpr` transformation. `make_jaxpr`
    is essentially a “pretty-printing” transformation: it transforms a function into
    one that, given example arguments, produces a Jaxpr representation of its computation.
    `make_jaxpr` is useful for debugging and introspection. Let’s use it to look at
    how some example Jaxprs are structured.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`jaxpr.invars` - the `invars` of a Jaxpr are a list of the input variables
    to Jaxpr, analogous to arguments in Python functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jaxpr.outvars` - the `outvars` of a Jaxpr are the variables that are returned
    by the Jaxpr. Every Jaxpr has multiple outputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jaxpr.constvars` - the `constvars` are a list of variables that are also inputs
    to the Jaxpr, but correspond to constants from the trace (we’ll go over these
    in more detail later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jaxpr.eqns` - a list of equations, which are essentially let-bindings. Each
    equation is a list of input variables, a list of output variables, and a *primitive*,
    which is used to evaluate inputs to produce outputs. Each equation also has a
    `params`, a dictionary of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altogether, a Jaxpr encapsulates a simple program that can be evaluated with
    inputs to produce an output. We’ll go over how exactly to do this later. The important
    thing to note now is that a Jaxpr is a data structure that can be manipulated
    and evaluated in whatever way we want.
  prefs: []
  type: TYPE_NORMAL
- en: Why are Jaxprs useful?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jaxprs are simple program representations that are easy to transform. And because
    Jax lets us stage out Jaxprs from Python functions, it gives us a way to transform
    numerical programs written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first interpreter: `invert`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try to implement a simple function “inverter”, which takes in the output
    of the original function and returns the inputs that produced those outputs. For
    now, let’s focus on simple, unary functions which are composed of other invertible
    unary functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The way we’ll implement this is by (1) tracing `f` into a Jaxpr, then (2) interpreting
    the Jaxpr *backwards*. While interpreting the Jaxpr backwards, for each equation
    we’ll look up the primitive’s inverse in a table and apply it.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Tracing a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s use `make_jaxpr` to trace a function into a Jaxpr.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`jax.make_jaxpr` returns a *closed* Jaxpr, which is a Jaxpr that has been bundled
    with the constants (`literals`) from the trace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Evaluating a Jaxpr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we write a custom Jaxpr interpreter, let’s first implement the “default”
    interpreter, `eval_jaxpr`, which evaluates the Jaxpr as-is, computing the same
    values that the original, un-transformed Python function would.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first create an environment to store the values for each of the
    variables, and update the environment with each equation we evaluate in the Jaxpr.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `eval_jaxpr` will always return a flat list even if the original
    function does not.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this interpreter does not handle higher-order primitives (like
    `jit` and `pmap`), which we will not cover in this guide. You can refer to `core.eval_jaxpr`
    ([link](https://github.com/google/jax/blob/main/jax/core.py)) to see the edge
    cases that this interpreter does not cover.
  prefs: []
  type: TYPE_NORMAL
- en: Custom `inverse` Jaxpr interpreter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `inverse` interpreter doesn’t look too different from `eval_jaxpr`. We’ll
    first set up the registry which will map primitives to their inverses. We’ll then
    write a custom interpreter that looks up primitives in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that this interpreter will also look similar to the “transpose”
    interpreter used in reverse-mode autodifferentiation [found here](https://github.com/google/jax/blob/main/jax/interpreters/ad.py#L164-L234).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll now register inverses for some of the primitives. By convention, primitives
    in Jax end in `_p` and a lot of the popular ones live in `lax`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`inverse` will first trace the function, then custom-interpret the Jaxpr. Let’s
    set up a simple skeleton.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we just need to define `inverse_jaxpr`, which will walk through the Jaxpr
    backward and invert primitives when it can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That’s it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, you can trace through a Jaxpr interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That’s all it takes to add a new transformation to a system, and you get composition
    with all the others for free! For example, we can use `jit`, `vmap`, and `grad`
    with `inverse`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exercises for the reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handle primitives with multiple arguments where inputs are partially known,
    for example `lax.add_p`, `lax.mul_p`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle `xla_call` and `xla_pmap` primitives, which will not work with both `eval_jaxpr`
    and `inverse_jaxpr` as written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
