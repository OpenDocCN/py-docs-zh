["```py\n# This function runs on the host\ndef host_eig(m: np.ndarray) -> np.ndarray:\n  return np.linalg.eigvals(m)\n\n# This function is used in JAX\ndef device_fun(m):\n  # We send \"m\" to the host, asking it to call \"host_eig\" and return the result.\n  # We have to specify the result shape and dtype, either in the form of an\n  # example return value or any object that has `shape` and `dtype` attributes,\n  # e.g., a NumPy array or a `jax.ShapeDtypeStruct`.\n  return hcb.call(host_eig, m,\n                  # Given an input of shape (..., d, d), eig output has shape (..., d)\n                  result_shape=jax.ShapeDtypeStruct(m.shape[:-1], m.dtype)) \n```", "```py\ndef host_sin(x, *, device):\n  # The ``device`` argument is passed due to ``call_with_device=True`` below.\n  print(f\"Invoking host_sin with {x.shape} on {device}\")\n  return np.sin(x)\n\n# Use pmap to run the computation on two devices\njax.pmap(lambda x: hcb.call(host_sin, x,\n                            result_shape=x,\n                            # Ask that the `host_sin` function be passed `device=dev`\n                            call_with_device=True))(\n         np.ones((2, 4), dtype=np.float32))\n\n# prints (in arbitrary order)\n# Invoking host_sin with (4,) on cpu:0\n# Invoking host_sin with (4,) on cpu:1 \n```", "```py\ndef host_func(arg, transforms):\n   ...do something with arg...\n\n# calls host_func(2x, []) on host\nid_tap(host_func, 2 * x)\n\n# calls host_func((2x, 3x), [])\nid_tap(host_func, (2 * x, 3 * x))  # The argument can be a pytree\n\n# calls host_func(2x, [], device=jax.devices()[0])\nid_tap(host_func, 2 * x, tap_with_device=True)  # Pass the device to the tap\n\n# calls host_func(2x, [], what='activation')\nid_tap(functools.partial(host_func, what='activation'), 2 * x)\n\n# calls host_func(dict(x=x, y=y), what='data')\nid_tap(lambda tap, transforms: host_func(tap, what='data'), dict(x=x, y=y)) \n```", "```py\naccumulator = []\ndef host_log(arg, transforms):\n  # We just record the arguments in a list\n  accumulator.append(arg)\n\ndef device_fun(x):\n  id_tap(host_log, x)\n  id_tap(host_log, 2. * x)\n\njax.jit(device_fun)(1.)\njax.jit(device_fun)(1.)\n\n# At this point, we have started two computations, each with two\n# taps, but they may not have yet executed.\nbarrier_wait()\n# Now we know that all the computations started before `barrier_wait`\n# on all devices, have finished, and all the callbacks have finished\n# executing. \n```", "```py\naccumulator = p[]\ndef host_log(arg):\n  # We just record the arguments in a list\n  accumulator.append(arg)\n  return 0.  #  return something\n\ndef device_fun(c):\n  y = call(host_log, x, result_shape=jax.ShapeDtypeStruct((), np.float32))\n  z = call(host_log, 2. * x, result_shape=jax.ShapeDtypeStruct((), np.float32))\n  return y + z  # return something that uses both results\n\nres1 = jax.jit(device_fun)(1.)\nres2 = jax.jit(device_fun)(1.)\nres1.block_until_ready()\nres2.block_until_ready() \n```", "```py\njax.pmap(power3, devices=jax.local_devices()[:2])(np.array([3., 4.])\n# device=cpu:0 what=x,x^2: (3., 9.)  # from the first device\n# device=cpu:1 what=x,x^2: (4., 16.)  # from the second device \n```", "```py\nwith jax.sharding.Mesh(jax.local_devices()[:2], [\"d\"]):\n  pjit.pjit(power3, in_shardings=(P(\"d\"),),\n            out_shardings=(P(\"d\"),))(np.array([3., 4.]))\n\n# device=TPU:0 what=x,x^2: ( [3., 4.],\n#                            [9., 16.] ) \n```", "```py\ndef power3(x):\n  y = x * x\n  # Print both 'x' and 'x^2'. Must pack as a tuple.\n  hcb.id_print((x, y), what=\"x,x^2\")\n  return y * x\n\npower3(3.)\n# what: x,x^2 : (3., 9.) \n```", "```py\njax.jvp(power3, (3.,), (0.1,))\n# what: x,x^2 : (3., 9.) \n```", "```py\njax.grad(power3)(3.)\n# what: x,x^2 : (3., 9.) \n```", "```py\n@jax.custom_jvp\ndef print_tangents(arg):\n  return None\n\n@print_tangents.defjvp\ndef print_tangents_jvp(primals, tangents):\n  arg_dot, = tangents\n  hcb.id_print(arg_dot, what=\"tangents\")\n  return primals, tangents \n```", "```py\ndef power3_with_tangents(x):\n  y = x * x\n  # Print both 'x' and 'x^2'. Must pack as a tuple.\n  hcb.id_print((x, y), what=\"x,x^2\")\n  print_tangents((x, y))\n  return y * x\n\njax.jvp(power3_with_tangents, (3.,), (0.1,))\n# what: x,x^2 : (3., 9.)\n# what: tangents : (0.1, 0.6) \n```", "```py\n@jax.custom_vjp\ndef print_cotangents(arg):\n  # Must return the argument for which we want the cotangent.\n  return arg\n\n# f_fwd: a -> (b, residual)\ndef print_cotangents_fwd(arg):\n  return print_cotangents(arg), None\n# f_bwd: (residual, CT b) -> [CT a]\ndef print_cotangents_bwd(residual, ct_b):\n  hcb.id_print(ct_b, what=\"cotangents\", output_stream=testing_stream)\n  return ct_b,\n\nprint_cotangents.defvjp(print_cotangents_fwd, print_cotangents_bwd)\n\ndef power3_with_cotangents(x):\n  y = x * x\n  # Print both 'x' and 'x^2'. Must pack as a tuple.\n  hcb.id_print((x, y), what=\"x,x^2\", output_stream=testing_stream)\n  (x1, y1) = print_cotangents((x, y))\n  # Must use the output of print_cotangents\n  return y1 * x1\n\njax.grad(power3_with_cotangents)(3.)\n# what: x,x^2 : (3., 9.)\n# what: cotangents : (9., 3.) \n```", "```py\njax.grad(lambda x: power3(ad_checkpoint.checkpoint(power3)(x)))(3.)\n# what: x,x^2 : (3., 9.)\n# what: x,x^2 : (27., 729.)\n# what: x,x^2 : (3., 9.) \n```"]