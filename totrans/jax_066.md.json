["```py\ndef foo(): return bar() + baz()\ndef bar(): return rand(RNG, (3, 4))\ndef baz(): return rand(RNG, (3, 4))\ndef main():\n  global RNG\n  RNG = RandomState(0)\n  return foo() \n```", "```py\nIn [1]: rng = np.random.RandomState(0)\n\nIn [2]: rng.randn(2)\nOut[2]: array([1.76405235, 0.40015721])\n\nIn [3]: rng = np.random.RandomState(0)\n\nIn [4]: np.stack([rng.randn() for _ in range(2)])\nOut[4]: array([1.76405235, 0.40015721]) \n```", "```py\ndef foo(rng_1):\n   y, rng_2 = baz(rng_1)\n   z, rng_3 = bar(rng_2)\n   return y + z, rng_3\n\ndef bar(x, rng):\n  val, new_rng = rand(rng, (3, 4))\n  return val, new_rng\n\ndef baz(x, rng):\n  val, new_rng = rand(rng, (3, 4))\n  return val, new_rng\n\ndef main():\n  foo(RandomState(0)) \n```", "```py\ndef foo(rng_1):\n   rng_2, rng_3 = split(rng_1, 2)\n   return bar(rng_2) + baz(rng_3)\n\ndef bar(x, rng):\n  return rand(rng, (3, 4))\n\ndef baz(x, rng):\n  return rand(rng, (3, 4))\n\ndef main():\n  foo(RandomState(0)) \n```", "```py\ntype  Sample  =  Int256\ntype  Key  =  Sample  -- important identification for splitting\ntype  Count  =  Int32\n\nhash  ::  Key  ->  Count  ->  Int256  -- output type equal to Key and Sample\n\nsplit  ::  Key  ->  (Key,  Key)\nsplit  key  =  (hash  key  0,  hash  key  1)\n\ndraw_samples  ::  Key  ->  Int  ->  [Sample]\ndraw_samples  key  n  =  map  (hash  key)  [1..n] \n```", "```py\nrng = lax.rng.new_rng()\nfor i in xrange(num_steps):\n  rng, rng_input = lax.rng.split(rng)\n  params = compiled_update(rng_input, params, next(batches)) \n```", "```py\ndef Dropout(rate, mode='train'):\n  def init_fun(input_shape):\n    return input_shape, ()\n  def apply_fun(rng, params, inputs):\n    if mode == 'train':\n      keep = lax.random.bernoulli(rng, rate, inputs.shape)\n      return np.where(keep, inputs / rate, 0)\n    else:\n      return inputs\n  return init_fun, apply_fun \n```", "```py\ndef serial(*layers):\n  init_funs, apply_funs = zip(*layers)\n  def init_fun(input_shape):\n    ...\n  def apply_fun(rng, params, inputs):\n    rngs = split(rng, len(layers))\n    for rng, param, apply_fun in zip(rngs, params, apply_funs):\n      inputs = apply_fun(rng, param, inputs)\n    return inputs\n  return init_fun, apply_fun\n\ndef parallel(*layers):\n  init_funs, apply_funs = zip(*layers)\n  def init_fun(input_shape):\n    ...\n  def apply_fun(rng, params, inputs):\n    rngs = split(rng, len(layers))\n    return [f(r, p, x) for f, r, p, x in zip(apply_funs, rngs, params, inputs)]\n  return init_fun, apply_fun \n```"]