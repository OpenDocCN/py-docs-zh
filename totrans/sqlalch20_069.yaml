- en: Mutation Tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/extensions/mutable.html](https://docs.sqlalchemy.org/en/20/orm/extensions/mutable.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Provide support for tracking of in-place changes to scalar values, which are
    propagated into ORM change events on owning parent objects.
  prefs: []
  type: TYPE_NORMAL
- en: '## Establishing Mutability on Scalar Column Values'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of a “mutable” structure is a Python dictionary. Following
    the example introduced in [SQL Datatype Objects](../../core/types.html), we begin
    with a custom type that marshals Python dictionaries into JSON strings before
    being persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `json` is only for the purposes of example. The [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension can be used with any type whose target Python
    type may be mutable, including [`PickleType`](../../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), [`ARRAY`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable "sqlalchemy.ext.mutable")
    extension, the value itself tracks all parents which reference it. Below, we illustrate
    a simple version of the [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    dictionary object, which applies the [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable") mixin to a plain Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above dictionary class takes the approach of subclassing the Python built-in
    `dict` to produce a dict subclass which routes all mutation events through `__setitem__`.
    There are variants on this approach, such as subclassing `UserDict.UserDict` or
    `collections.MutableMapping`; the part that’s important to this example is that
    the [`Mutable.changed()`](#sqlalchemy.ext.mutable.Mutable.changed "sqlalchemy.ext.mutable.Mutable.changed")
    method is called whenever an in-place change to the datastructure takes place.
  prefs: []
  type: TYPE_NORMAL
- en: We also redefine the [`Mutable.coerce()`](#sqlalchemy.ext.mutable.Mutable.coerce
    "sqlalchemy.ext.mutable.Mutable.coerce") method which will be used to convert
    any values that are not instances of `MutableDict`, such as the plain dictionaries
    returned by the `json` module, into the appropriate type. Defining this method
    is optional; we could just as well created our `JSONEncodedDict` such that it
    always returns an instance of `MutableDict`, and additionally ensured that all
    calling code uses `MutableDict` explicitly. When [`Mutable.coerce()`](#sqlalchemy.ext.mutable.Mutable.coerce
    "sqlalchemy.ext.mutable.Mutable.coerce") is not overridden, any values applied
    to a parent object which are not instances of the mutable type will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new `MutableDict` type offers a class method [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") which we can use within column metadata
    to associate with types. This method grabs the given type object or class and
    associates a listener that will detect all future mappings of this type, applying
    event listening instrumentation to the mapped attribute. Such as, with classical
    table metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") returns an instance of `JSONEncodedDict`
    (if the type object was not an instance already), which will intercept any attributes
    which are mapped against this type. Below we establish a simple mapping against
    the `my_data` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `MyDataClass.data` member will now be notified of in place changes to its
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any in-place changes to the `MyDataClass.data` member will flag the attribute
    as “dirty” on the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MutableDict` can be associated with all future instances of `JSONEncodedDict`
    in one step, using [`Mutable.associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with"). This is similar to [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") except it will intercept all occurrences
    of `MutableDict` in all mappings unconditionally, without the need to declare
    it individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key to the [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable "sqlalchemy.ext.mutable")
    extension relies upon the placement of a `weakref.WeakKeyDictionary` upon the
    value object, which stores a mapping of parent mapped objects keyed to the attribute
    name under which they are associated with this value. `WeakKeyDictionary` objects
    are not picklable, due to the fact that they contain weakrefs and function callbacks.
    In our case, this is a good thing, since if this dictionary were picklable, it
    could lead to an excessively large pickle size for our value objects that are
    pickled by themselves outside of the context of the parent. The developer responsibility
    here is only to provide a `__getstate__` method that excludes the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") collection from the pickle stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With our dictionary example, we need to return the contents of the dict itself
    (and also restore them on __setstate__):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the case that our mutable value object is pickled as it is attached to one
    or more parent objects that are also part of the pickle, the [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable") mixin will re-establish the [`Mutable._parents`](#sqlalchemy.ext.mutable.Mutable._parents
    "sqlalchemy.ext.mutable.Mutable._parents") collection on each value object as
    the owning parents themselves are unpickled.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`AttributeEvents.modified()`](../events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") event handler may be used to receive
    an event when a mutable scalar emits a change event. This event handler is called
    when the [`flag_modified()`](../session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is called from within the
    mutable extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]  ## Establishing Mutability on Composites'
  prefs: []
  type: TYPE_NORMAL
- en: Composites are a special ORM feature which allow a single scalar attribute to
    be assigned an object value which represents information “composed” from one or
    more columns from the underlying mapped table. The usual example is that of a
    geometric “point”, and is introduced in [Composite Column Types](../composites.html#mapper-composite).
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the user-defined composite class subclasses [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") as a mixin, and detects and delivers
    change events to its parents via the [`MutableComposite.changed()`](#sqlalchemy.ext.mutable.MutableComposite.changed
    "sqlalchemy.ext.mutable.MutableComposite.changed") method. In the case of a composite
    class, the detection is usually via the usage of the special Python method `__setattr__()`.
    In the example below, we expand upon the `Point` class introduced in [Composite
    Column Types](../composites.html#mapper-composite) to include [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") in its bases and to route attribute
    set events via `__setattr__` to the [`MutableComposite.changed()`](#sqlalchemy.ext.mutable.MutableComposite.changed
    "sqlalchemy.ext.mutable.MutableComposite.changed") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    class makes use of class mapping events to automatically establish listeners for
    any usage of [`composite()`](../composites.html#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    that specifies our `Point` type. Below, when `Point` is mapped to the `Vertex`
    class, listeners are established which will route change events from `Point` objects
    to each of the `Vertex.start` and `Vertex.end` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Any in-place changes to the `Vertex.start` or `Vertex.end` members will flag
    the attribute as “dirty” on the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Coercing Mutable Composites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce "sqlalchemy.ext.mutable.MutableBase.coerce")
    method is also supported on composite types. In the case of [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite"), the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is only called for attribute
    set operations, not load operations. Overriding the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is essentially equivalent
    to using a [`validates()`](../mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") validation routine for all attributes which make use
    of the custom composite type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As is the case with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    helper class uses a `weakref.WeakKeyDictionary` available via the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") attribute which isn’t picklable.
    If we need to pickle instances of `Point` or its owning class `Vertex`, we at
    least need to define a `__getstate__` that doesn’t include the `_parents` dictionary.
    Below we define both a `__getstate__` and a `__setstate__` that package up the
    minimal form of our `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    augments the pickling process of the parent’s object-relational state so that
    the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents "sqlalchemy.ext.mutable.MutableBase._parents")
    collection is restored to all `Point` objects.
  prefs: []
  type: TYPE_NORMAL
- en: API Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Mutable](#sqlalchemy.ext.mutable.Mutable) | Mixin that defines transparent
    propagation of change events to a parent object. |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableBase](#sqlalchemy.ext.mutable.MutableBase) | Common base class to
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    and [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableComposite](#sqlalchemy.ext.mutable.MutableComposite) | Mixin that
    defines transparent propagation of change events on a SQLAlchemy “composite” object
    to its owning parent or parents. |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableDict](#sqlalchemy.ext.mutable.MutableDict) | A dictionary type that
    implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableList](#sqlalchemy.ext.mutable.MutableList) | A list type that implements
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableSet](#sqlalchemy.ext.mutable.MutableSet) | A set type that implements
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_parents](#sqlalchemy.ext.mutable.MutableBase._parents), [coerce()](#sqlalchemy.ext.mutable.MutableBase.coerce)'
  prefs: []
  type: TYPE_NORMAL
- en: Common base class to [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    and [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary of parent object’s [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")->attribute name on the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is a so-called “memoized” property. It initializes itself with
    a new `weakref.WeakKeyDictionary` the first time it is accessed, returning the
    same object upon subsequent access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") is now used as the key in the weak dictionary
    rather than the instance itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Given a value, coerce it into the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Can be overridden by custom subclasses to coerce incoming data into a particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: By default, raises `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in different scenarios depending on if the parent class
    is of type [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    or of type [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    In the case of the former, it is called for both attribute-set operations as well
    as during ORM loading operations. For the latter, it is only called during attribute-set
    operations; the mechanics of the [`composite()`](../composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct handle coercion during load operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` – string name of the ORM-mapped attribute being set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` – the incoming value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the method should return the coerced value, or raise `ValueError` if the coercion
    cannot be completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines transparent propagation of change events to a parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the example in [Establishing Mutability on Scalar Column Values](#mutable-scalars)
    for usage information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_get_listen_keys()](#sqlalchemy.ext.mutable.Mutable._get_listen_keys), [_listen_on_attribute()](#sqlalchemy.ext.mutable.Mutable._listen_on_attribute),
    [_parents](#sqlalchemy.ext.mutable.Mutable._parents), [as_mutable()](#sqlalchemy.ext.mutable.Mutable.as_mutable),
    [associate_with()](#sqlalchemy.ext.mutable.Mutable.associate_with), [associate_with_attribute()](#sqlalchemy.ext.mutable.Mutable.associate_with_attribute),
    [changed()](#sqlalchemy.ext.mutable.Mutable.changed), [coerce()](#sqlalchemy.ext.mutable.Mutable.coerce)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    ([`sqlalchemy.ext.mutable.MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._get_listen_keys`
    *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Given a descriptor attribute, return a `set()` of the attribute keys which indicate
    a change in the state of this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: This is normally just `set([attribute.key])`, but can be overridden to provide
    for additional keys. E.g. a [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") augments this set with the attribute
    keys associated with the columns that comprise the composite value.
  prefs: []
  type: TYPE_NORMAL
- en: This collection is consulted in the case of intercepting the [`InstanceEvents.refresh()`](../events.html#sqlalchemy.orm.InstanceEvents.refresh
    "sqlalchemy.orm.InstanceEvents.refresh") and [`InstanceEvents.refresh_flush()`](../events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") events, which pass along a list
    of attribute names that have been refreshed; the list is compared against this
    set to determine if action needs to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._listen_on_attribute`
    *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Establish this type as a mutation listener for the given mapped descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._parents` *attribute
    of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary of parent object’s [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")->attribute name on the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is a so-called “memoized” property. It initializes itself with
    a new `weakref.WeakKeyDictionary` the first time it is accessed, returning the
    same object upon subsequent access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") is now used as the key in the weak dictionary
    rather than the instance itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Associate a SQL type with this mutable Python type.
  prefs: []
  type: TYPE_NORMAL
- en: This establishes listeners that will detect ORM mappings against the given type,
    adding mutation event trackers to those mappings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type is returned, unconditionally as an instance, so that [`as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") can be used inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the returned type is always an instance, even if a class is given,
    and that only columns which are declared specifically with that type instance
    receive additional instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: To associate a particular mutable type with all occurrences of a particular
    type, use the [`Mutable.associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with") classmethod of the particular
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    subclass to establish a global association.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The listeners established by this method are *global* to all mappers, and are
    *not* garbage collected. Only use [`as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") for types that are permanent to an
    application, not with ad-hoc types else this will cause unbounded growth in memory
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Associate this wrapper with all future mapped columns of the given type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a convenience method that calls `associate_with_attribute` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The listeners established by this method are *global* to all mappers, and are
    *not* garbage collected. Only use [`associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with") for types that are permanent
    to an application, not with ad-hoc types else this will cause unbounded growth
    in memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Establish this type as a mutation listener for the given mapped descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses should call this method whenever change events occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase
    "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Given a value, coerce it into the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Can be overridden by custom subclasses to coerce incoming data into a particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: By default, raises `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in different scenarios depending on if the parent class
    is of type [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    or of type [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    In the case of the former, it is called for both attribute-set operations as well
    as during ORM loading operations. For the latter, it is only called during attribute-set
    operations; the mechanics of the [`composite()`](../composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct handle coercion during load operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` – string name of the ORM-mapped attribute being set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` – the incoming value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the method should return the coerced value, or raise `ValueError` if the coercion
    cannot be completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines transparent propagation of change events on a SQLAlchemy
    “composite” object to its owning parent or parents.
  prefs: []
  type: TYPE_NORMAL
- en: See the example in [Establishing Mutability on Composites](#mutable-composites)
    for usage information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[changed()](#sqlalchemy.ext.mutable.MutableComposite.changed)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") ([`sqlalchemy.ext.mutable.MutableBase`](#sqlalchemy.ext.mutable.MutableBase
    "sqlalchemy.ext.mutable.MutableBase"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses should call this method whenever change events occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A dictionary type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    object implements a dictionary that will emit change events to the underlying
    mapping when the contents of the dictionary are altered, including when values
    are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    does **not** apply mutable tracking to the *values themselves* inside the dictionary.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* dictionary structure, such as a JSON structure. To support this
    use case, build a subclass of [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") that provides appropriate coercion to the
    values placed in the dictionary so that they too are “mutable”, and emit events
    up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[clear()](#sqlalchemy.ext.mutable.MutableDict.clear), [coerce()](#sqlalchemy.ext.mutable.MutableDict.coerce),
    [pop()](#sqlalchemy.ext.mutable.MutableDict.pop), [popitem()](#sqlalchemy.ext.mutable.MutableDict.popitem),
    [setdefault()](#sqlalchemy.ext.mutable.MutableDict.setdefault), [update()](#sqlalchemy.ext.mutable.MutableDict.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableDict`](#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.dict`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain dictionary to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the key is not found, return the default if given; otherwise, raise a KeyError.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return a (key, value) pair as a 2-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the
    dict is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Insert key with a value of default if key is not in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Return the value for key if key is in the dictionary, else default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v
    In either case, this is followed by: for k in F: D[k] = F[k]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A list type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")
    object implements a list that will emit change events to the underlying mapping
    when the contents of the list are altered, including when values are added or
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")
    does **not** apply mutable tracking to the *values themselves* inside the list.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* mutable structure, such as a JSON structure. To support this
    use case, build a subclass of [`MutableList`](#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") that provides appropriate coercion to the
    values placed in the dictionary so that they too are “mutable”, and emit events
    up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[append()](#sqlalchemy.ext.mutable.MutableList.append), [clear()](#sqlalchemy.ext.mutable.MutableList.clear),
    [coerce()](#sqlalchemy.ext.mutable.MutableList.coerce), [extend()](#sqlalchemy.ext.mutable.MutableList.extend),
    [insert()](#sqlalchemy.ext.mutable.MutableList.insert), [is_iterable()](#sqlalchemy.ext.mutable.MutableList.is_iterable),
    [is_scalar()](#sqlalchemy.ext.mutable.MutableList.is_scalar), [pop()](#sqlalchemy.ext.mutable.MutableList.pop),
    [remove()](#sqlalchemy.ext.mutable.MutableList.remove), [reverse()](#sqlalchemy.ext.mutable.MutableList.reverse),
    [sort()](#sqlalchemy.ext.mutable.MutableList.sort)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableList`](#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.list`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Append object to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Remove all items from list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain list to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Extend list by appending elements from the iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Insert object before index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return item at index (default last).
  prefs: []
  type: TYPE_NORMAL
- en: Raises IndexError if list is empty or index is out of range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remove first occurrence of value.
  prefs: []
  type: TYPE_NORMAL
- en: Raises ValueError if the value is not present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Reverse *IN PLACE*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Sort the list in ascending order and return None.
  prefs: []
  type: TYPE_NORMAL
- en: The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
    order of two equal elements is maintained).
  prefs: []
  type: TYPE_NORMAL
- en: If a key function is given, apply it once to each list item and sort them, ascending
    or descending, according to their function values.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse flag can be set to sort in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A set type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    object implements a set that will emit change events to the underlying mapping
    when the contents of the set are altered, including when values are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    does **not** apply mutable tracking to the *values themselves* inside the set.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* mutable structure. To support this use case, build a subclass
    of [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    that provides appropriate coercion to the values placed in the dictionary so that
    they too are “mutable”, and emit events up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.ext.mutable.MutableSet.add), [clear()](#sqlalchemy.ext.mutable.MutableSet.clear),
    [coerce()](#sqlalchemy.ext.mutable.MutableSet.coerce), [difference_update()](#sqlalchemy.ext.mutable.MutableSet.difference_update),
    [discard()](#sqlalchemy.ext.mutable.MutableSet.discard), [intersection_update()](#sqlalchemy.ext.mutable.MutableSet.intersection_update),
    [pop()](#sqlalchemy.ext.mutable.MutableSet.pop), [remove()](#sqlalchemy.ext.mutable.MutableSet.remove),
    [symmetric_difference_update()](#sqlalchemy.ext.mutable.MutableSet.symmetric_difference_update),
    [update()](#sqlalchemy.ext.mutable.MutableSet.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableSet`](#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.set`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Add an element to a set.
  prefs: []
  type: TYPE_NORMAL
- en: This has no effect if the element is already present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Remove all elements from this set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain set to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Remove all elements of another set from this set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Remove an element from a set if it is a member.
  prefs: []
  type: TYPE_NORMAL
- en: If the element is not a member, do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the intersection of itself and another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return an arbitrary set element. Raises KeyError if the set is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Remove an element from a set; it must be a member.
  prefs: []
  type: TYPE_NORMAL
- en: If the element is not a member, raise a KeyError.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the symmetric difference of itself and another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the union of itself and others.
  prefs: []
  type: TYPE_NORMAL
- en: '## Establishing Mutability on Scalar Column Values'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of a “mutable” structure is a Python dictionary. Following
    the example introduced in [SQL Datatype Objects](../../core/types.html), we begin
    with a custom type that marshals Python dictionaries into JSON strings before
    being persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `json` is only for the purposes of example. The [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension can be used with any type whose target Python
    type may be mutable, including [`PickleType`](../../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), [`ARRAY`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable "sqlalchemy.ext.mutable")
    extension, the value itself tracks all parents which reference it. Below, we illustrate
    a simple version of the [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    dictionary object, which applies the [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable") mixin to a plain Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The above dictionary class takes the approach of subclassing the Python built-in
    `dict` to produce a dict subclass which routes all mutation events through `__setitem__`.
    There are variants on this approach, such as subclassing `UserDict.UserDict` or
    `collections.MutableMapping`; the part that’s important to this example is that
    the [`Mutable.changed()`](#sqlalchemy.ext.mutable.Mutable.changed "sqlalchemy.ext.mutable.Mutable.changed")
    method is called whenever an in-place change to the datastructure takes place.
  prefs: []
  type: TYPE_NORMAL
- en: We also redefine the [`Mutable.coerce()`](#sqlalchemy.ext.mutable.Mutable.coerce
    "sqlalchemy.ext.mutable.Mutable.coerce") method which will be used to convert
    any values that are not instances of `MutableDict`, such as the plain dictionaries
    returned by the `json` module, into the appropriate type. Defining this method
    is optional; we could just as well created our `JSONEncodedDict` such that it
    always returns an instance of `MutableDict`, and additionally ensured that all
    calling code uses `MutableDict` explicitly. When [`Mutable.coerce()`](#sqlalchemy.ext.mutable.Mutable.coerce
    "sqlalchemy.ext.mutable.Mutable.coerce") is not overridden, any values applied
    to a parent object which are not instances of the mutable type will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new `MutableDict` type offers a class method [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") which we can use within column metadata
    to associate with types. This method grabs the given type object or class and
    associates a listener that will detect all future mappings of this type, applying
    event listening instrumentation to the mapped attribute. Such as, with classical
    table metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") returns an instance of `JSONEncodedDict`
    (if the type object was not an instance already), which will intercept any attributes
    which are mapped against this type. Below we establish a simple mapping against
    the `my_data` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `MyDataClass.data` member will now be notified of in place changes to its
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any in-place changes to the `MyDataClass.data` member will flag the attribute
    as “dirty” on the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MutableDict` can be associated with all future instances of `JSONEncodedDict`
    in one step, using [`Mutable.associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with"). This is similar to [`Mutable.as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") except it will intercept all occurrences
    of `MutableDict` in all mappings unconditionally, without the need to declare
    it individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key to the [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable "sqlalchemy.ext.mutable")
    extension relies upon the placement of a `weakref.WeakKeyDictionary` upon the
    value object, which stores a mapping of parent mapped objects keyed to the attribute
    name under which they are associated with this value. `WeakKeyDictionary` objects
    are not picklable, due to the fact that they contain weakrefs and function callbacks.
    In our case, this is a good thing, since if this dictionary were picklable, it
    could lead to an excessively large pickle size for our value objects that are
    pickled by themselves outside of the context of the parent. The developer responsibility
    here is only to provide a `__getstate__` method that excludes the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") collection from the pickle stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With our dictionary example, we need to return the contents of the dict itself
    (and also restore them on __setstate__):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the case that our mutable value object is pickled as it is attached to one
    or more parent objects that are also part of the pickle, the [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable") mixin will re-establish the [`Mutable._parents`](#sqlalchemy.ext.mutable.Mutable._parents
    "sqlalchemy.ext.mutable.Mutable._parents") collection on each value object as
    the owning parents themselves are unpickled.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`AttributeEvents.modified()`](../events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") event handler may be used to receive
    an event when a mutable scalar emits a change event. This event handler is called
    when the [`flag_modified()`](../session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is called from within the
    mutable extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key to the [`sqlalchemy.ext.mutable`](#module-sqlalchemy.ext.mutable "sqlalchemy.ext.mutable")
    extension relies upon the placement of a `weakref.WeakKeyDictionary` upon the
    value object, which stores a mapping of parent mapped objects keyed to the attribute
    name under which they are associated with this value. `WeakKeyDictionary` objects
    are not picklable, due to the fact that they contain weakrefs and function callbacks.
    In our case, this is a good thing, since if this dictionary were picklable, it
    could lead to an excessively large pickle size for our value objects that are
    pickled by themselves outside of the context of the parent. The developer responsibility
    here is only to provide a `__getstate__` method that excludes the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") collection from the pickle stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'With our dictionary example, we need to return the contents of the dict itself
    (and also restore them on __setstate__):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the case that our mutable value object is pickled as it is attached to one
    or more parent objects that are also part of the pickle, the [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable") mixin will re-establish the [`Mutable._parents`](#sqlalchemy.ext.mutable.Mutable._parents
    "sqlalchemy.ext.mutable.Mutable._parents") collection on each value object as
    the owning parents themselves are unpickled.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`AttributeEvents.modified()`](../events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") event handler may be used to receive
    an event when a mutable scalar emits a change event. This event handler is called
    when the [`flag_modified()`](../session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is called from within the
    mutable extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '## Establishing Mutability on Composites'
  prefs: []
  type: TYPE_NORMAL
- en: Composites are a special ORM feature which allow a single scalar attribute to
    be assigned an object value which represents information “composed” from one or
    more columns from the underlying mapped table. The usual example is that of a
    geometric “point”, and is introduced in [Composite Column Types](../composites.html#mapper-composite).
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the user-defined composite class subclasses [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") as a mixin, and detects and delivers
    change events to its parents via the [`MutableComposite.changed()`](#sqlalchemy.ext.mutable.MutableComposite.changed
    "sqlalchemy.ext.mutable.MutableComposite.changed") method. In the case of a composite
    class, the detection is usually via the usage of the special Python method `__setattr__()`.
    In the example below, we expand upon the `Point` class introduced in [Composite
    Column Types](../composites.html#mapper-composite) to include [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") in its bases and to route attribute
    set events via `__setattr__` to the [`MutableComposite.changed()`](#sqlalchemy.ext.mutable.MutableComposite.changed
    "sqlalchemy.ext.mutable.MutableComposite.changed") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    class makes use of class mapping events to automatically establish listeners for
    any usage of [`composite()`](../composites.html#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    that specifies our `Point` type. Below, when `Point` is mapped to the `Vertex`
    class, listeners are established which will route change events from `Point` objects
    to each of the `Vertex.start` and `Vertex.end` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Any in-place changes to the `Vertex.start` or `Vertex.end` members will flag
    the attribute as “dirty” on the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Coercing Mutable Composites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce "sqlalchemy.ext.mutable.MutableBase.coerce")
    method is also supported on composite types. In the case of [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite"), the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is only called for attribute
    set operations, not load operations. Overriding the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is essentially equivalent
    to using a [`validates()`](../mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") validation routine for all attributes which make use
    of the custom composite type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As is the case with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    helper class uses a `weakref.WeakKeyDictionary` available via the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") attribute which isn’t picklable.
    If we need to pickle instances of `Point` or its owning class `Vertex`, we at
    least need to define a `__getstate__` that doesn’t include the `_parents` dictionary.
    Below we define both a `__getstate__` and a `__setstate__` that package up the
    minimal form of our `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    augments the pickling process of the parent’s object-relational state so that
    the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents "sqlalchemy.ext.mutable.MutableBase._parents")
    collection is restored to all `Point` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Coercing Mutable Composites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce "sqlalchemy.ext.mutable.MutableBase.coerce")
    method is also supported on composite types. In the case of [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite"), the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is only called for attribute
    set operations, not load operations. Overriding the [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") method is essentially equivalent
    to using a [`validates()`](../mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") validation routine for all attributes which make use
    of the custom composite type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Supporting Pickling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As is the case with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    helper class uses a `weakref.WeakKeyDictionary` available via the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents
    "sqlalchemy.ext.mutable.MutableBase._parents") attribute which isn’t picklable.
    If we need to pickle instances of `Point` or its owning class `Vertex`, we at
    least need to define a `__getstate__` that doesn’t include the `_parents` dictionary.
    Below we define both a `__getstate__` and a `__setstate__` that package up the
    minimal form of our `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As with [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable"),
    the [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite")
    augments the pickling process of the parent’s object-relational state so that
    the [`MutableBase._parents()`](#sqlalchemy.ext.mutable.MutableBase._parents "sqlalchemy.ext.mutable.MutableBase._parents")
    collection is restored to all `Point` objects.
  prefs: []
  type: TYPE_NORMAL
- en: API Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Mutable](#sqlalchemy.ext.mutable.Mutable) | Mixin that defines transparent
    propagation of change events to a parent object. |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableBase](#sqlalchemy.ext.mutable.MutableBase) | Common base class to
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    and [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableComposite](#sqlalchemy.ext.mutable.MutableComposite) | Mixin that
    defines transparent propagation of change events on a SQLAlchemy “composite” object
    to its owning parent or parents. |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableDict](#sqlalchemy.ext.mutable.MutableDict) | A dictionary type that
    implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableList](#sqlalchemy.ext.mutable.MutableList) | A list type that implements
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MutableSet](#sqlalchemy.ext.mutable.MutableSet) | A set type that implements
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_parents](#sqlalchemy.ext.mutable.MutableBase._parents), [coerce()](#sqlalchemy.ext.mutable.MutableBase.coerce)'
  prefs: []
  type: TYPE_NORMAL
- en: Common base class to [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    and [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary of parent object’s [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")->attribute name on the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is a so-called “memoized” property. It initializes itself with
    a new `weakref.WeakKeyDictionary` the first time it is accessed, returning the
    same object upon subsequent access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") is now used as the key in the weak dictionary
    rather than the instance itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Given a value, coerce it into the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Can be overridden by custom subclasses to coerce incoming data into a particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: By default, raises `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in different scenarios depending on if the parent class
    is of type [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    or of type [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    In the case of the former, it is called for both attribute-set operations as well
    as during ORM loading operations. For the latter, it is only called during attribute-set
    operations; the mechanics of the [`composite()`](../composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct handle coercion during load operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` – string name of the ORM-mapped attribute being set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` – the incoming value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the method should return the coerced value, or raise `ValueError` if the coercion
    cannot be completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines transparent propagation of change events to a parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the example in [Establishing Mutability on Scalar Column Values](#mutable-scalars)
    for usage information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[_get_listen_keys()](#sqlalchemy.ext.mutable.Mutable._get_listen_keys), [_listen_on_attribute()](#sqlalchemy.ext.mutable.Mutable._listen_on_attribute),
    [_parents](#sqlalchemy.ext.mutable.Mutable._parents), [as_mutable()](#sqlalchemy.ext.mutable.Mutable.as_mutable),
    [associate_with()](#sqlalchemy.ext.mutable.Mutable.associate_with), [associate_with_attribute()](#sqlalchemy.ext.mutable.Mutable.associate_with_attribute),
    [changed()](#sqlalchemy.ext.mutable.Mutable.changed), [coerce()](#sqlalchemy.ext.mutable.Mutable.coerce)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    ([`sqlalchemy.ext.mutable.MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._get_listen_keys`
    *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Given a descriptor attribute, return a `set()` of the attribute keys which indicate
    a change in the state of this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: This is normally just `set([attribute.key])`, but can be overridden to provide
    for additional keys. E.g. a [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") augments this set with the attribute
    keys associated with the columns that comprise the composite value.
  prefs: []
  type: TYPE_NORMAL
- en: This collection is consulted in the case of intercepting the [`InstanceEvents.refresh()`](../events.html#sqlalchemy.orm.InstanceEvents.refresh
    "sqlalchemy.orm.InstanceEvents.refresh") and [`InstanceEvents.refresh_flush()`](../events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") events, which pass along a list
    of attribute names that have been refreshed; the list is compared against this
    set to determine if action needs to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._listen_on_attribute`
    *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Establish this type as a mutation listener for the given mapped descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.ext.mutable.MutableBase._parents` *attribute
    of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary of parent object’s [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")->attribute name on the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute is a so-called “memoized” property. It initializes itself with
    a new `weakref.WeakKeyDictionary` the first time it is accessed, returning the
    same object upon subsequent access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`InstanceState`](../internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") is now used as the key in the weak dictionary
    rather than the instance itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Associate a SQL type with this mutable Python type.
  prefs: []
  type: TYPE_NORMAL
- en: This establishes listeners that will detect ORM mappings against the given type,
    adding mutation event trackers to those mappings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type is returned, unconditionally as an instance, so that [`as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") can be used inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note that the returned type is always an instance, even if a class is given,
    and that only columns which are declared specifically with that type instance
    receive additional instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: To associate a particular mutable type with all occurrences of a particular
    type, use the [`Mutable.associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with") classmethod of the particular
    [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    subclass to establish a global association.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The listeners established by this method are *global* to all mappers, and are
    *not* garbage collected. Only use [`as_mutable()`](#sqlalchemy.ext.mutable.Mutable.as_mutable
    "sqlalchemy.ext.mutable.Mutable.as_mutable") for types that are permanent to an
    application, not with ad-hoc types else this will cause unbounded growth in memory
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Associate this wrapper with all future mapped columns of the given type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a convenience method that calls `associate_with_attribute` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The listeners established by this method are *global* to all mappers, and are
    *not* garbage collected. Only use [`associate_with()`](#sqlalchemy.ext.mutable.Mutable.associate_with
    "sqlalchemy.ext.mutable.Mutable.associate_with") for types that are permanent
    to an application, not with ad-hoc types else this will cause unbounded growth
    in memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Establish this type as a mutation listener for the given mapped descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses should call this method whenever change events occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`MutableBase.coerce()`](#sqlalchemy.ext.mutable.MutableBase.coerce
    "sqlalchemy.ext.mutable.MutableBase.coerce") *method of* [`MutableBase`](#sqlalchemy.ext.mutable.MutableBase
    "sqlalchemy.ext.mutable.MutableBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Given a value, coerce it into the target type.
  prefs: []
  type: TYPE_NORMAL
- en: Can be overridden by custom subclasses to coerce incoming data into a particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: By default, raises `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in different scenarios depending on if the parent class
    is of type [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable")
    or of type [`MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite "sqlalchemy.ext.mutable.MutableComposite").
    In the case of the former, it is called for both attribute-set operations as well
    as during ORM loading operations. For the latter, it is only called during attribute-set
    operations; the mechanics of the [`composite()`](../composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct handle coercion during load operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` – string name of the ORM-mapped attribute being set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` – the incoming value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: the method should return the coerced value, or raise `ValueError` if the coercion
    cannot be completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines transparent propagation of change events on a SQLAlchemy
    “composite” object to its owning parent or parents.
  prefs: []
  type: TYPE_NORMAL
- en: See the example in [Establishing Mutability on Composites](#mutable-composites)
    for usage information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[changed()](#sqlalchemy.ext.mutable.MutableComposite.changed)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableComposite`](#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") ([`sqlalchemy.ext.mutable.MutableBase`](#sqlalchemy.ext.mutable.MutableBase
    "sqlalchemy.ext.mutable.MutableBase"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses should call this method whenever change events occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: A dictionary type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    object implements a dictionary that will emit change events to the underlying
    mapping when the contents of the dictionary are altered, including when values
    are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")
    does **not** apply mutable tracking to the *values themselves* inside the dictionary.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* dictionary structure, such as a JSON structure. To support this
    use case, build a subclass of [`MutableDict`](#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") that provides appropriate coercion to the
    values placed in the dictionary so that they too are “mutable”, and emit events
    up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[clear()](#sqlalchemy.ext.mutable.MutableDict.clear), [coerce()](#sqlalchemy.ext.mutable.MutableDict.coerce),
    [pop()](#sqlalchemy.ext.mutable.MutableDict.pop), [popitem()](#sqlalchemy.ext.mutable.MutableDict.popitem),
    [setdefault()](#sqlalchemy.ext.mutable.MutableDict.setdefault), [update()](#sqlalchemy.ext.mutable.MutableDict.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableDict`](#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.dict`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain dictionary to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If the key is not found, return the default if given; otherwise, raise a KeyError.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return a (key, value) pair as a 2-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the
    dict is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Insert key with a value of default if key is not in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Return the value for key if key is in the dictionary, else default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v
    In either case, this is followed by: for k in F: D[k] = F[k]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: A list type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")
    object implements a list that will emit change events to the underlying mapping
    when the contents of the list are altered, including when values are added or
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")
    does **not** apply mutable tracking to the *values themselves* inside the list.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* mutable structure, such as a JSON structure. To support this
    use case, build a subclass of [`MutableList`](#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") that provides appropriate coercion to the
    values placed in the dictionary so that they too are “mutable”, and emit events
    up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[append()](#sqlalchemy.ext.mutable.MutableList.append), [clear()](#sqlalchemy.ext.mutable.MutableList.clear),
    [coerce()](#sqlalchemy.ext.mutable.MutableList.coerce), [extend()](#sqlalchemy.ext.mutable.MutableList.extend),
    [insert()](#sqlalchemy.ext.mutable.MutableList.insert), [is_iterable()](#sqlalchemy.ext.mutable.MutableList.is_iterable),
    [is_scalar()](#sqlalchemy.ext.mutable.MutableList.is_scalar), [pop()](#sqlalchemy.ext.mutable.MutableList.pop),
    [remove()](#sqlalchemy.ext.mutable.MutableList.remove), [reverse()](#sqlalchemy.ext.mutable.MutableList.reverse),
    [sort()](#sqlalchemy.ext.mutable.MutableList.sort)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableList`](#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.list`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Append object to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Remove all items from list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain list to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Extend list by appending elements from the iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Insert object before index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return item at index (default last).
  prefs: []
  type: TYPE_NORMAL
- en: Raises IndexError if list is empty or index is out of range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Remove first occurrence of value.
  prefs: []
  type: TYPE_NORMAL
- en: Raises ValueError if the value is not present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Reverse *IN PLACE*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Sort the list in ascending order and return None.
  prefs: []
  type: TYPE_NORMAL
- en: The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
    order of two equal elements is maintained).
  prefs: []
  type: TYPE_NORMAL
- en: If a key function is given, apply it once to each list item and sort them, ascending
    or descending, according to their function values.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse flag can be set to sort in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: A set type that implements [`Mutable`](#sqlalchemy.ext.mutable.Mutable "sqlalchemy.ext.mutable.Mutable").
  prefs: []
  type: TYPE_NORMAL
- en: The [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    object implements a set that will emit change events to the underlying mapping
    when the contents of the set are altered, including when values are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    does **not** apply mutable tracking to the *values themselves* inside the set.
    Therefore it is not a sufficient solution for the use case of tracking deep changes
    to a *recursive* mutable structure. To support this use case, build a subclass
    of [`MutableSet`](#sqlalchemy.ext.mutable.MutableSet "sqlalchemy.ext.mutable.MutableSet")
    that provides appropriate coercion to the values placed in the dictionary so that
    they too are “mutable”, and emit events up to their parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableDict`](#sqlalchemy.ext.mutable.MutableDict "sqlalchemy.ext.mutable.MutableDict")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutableList`](#sqlalchemy.ext.mutable.MutableList "sqlalchemy.ext.mutable.MutableList")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.ext.mutable.MutableSet.add), [clear()](#sqlalchemy.ext.mutable.MutableSet.clear),
    [coerce()](#sqlalchemy.ext.mutable.MutableSet.coerce), [difference_update()](#sqlalchemy.ext.mutable.MutableSet.difference_update),
    [discard()](#sqlalchemy.ext.mutable.MutableSet.discard), [intersection_update()](#sqlalchemy.ext.mutable.MutableSet.intersection_update),
    [pop()](#sqlalchemy.ext.mutable.MutableSet.pop), [remove()](#sqlalchemy.ext.mutable.MutableSet.remove),
    [symmetric_difference_update()](#sqlalchemy.ext.mutable.MutableSet.symmetric_difference_update),
    [update()](#sqlalchemy.ext.mutable.MutableSet.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.ext.mutable.MutableSet`](#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") ([`sqlalchemy.ext.mutable.Mutable`](#sqlalchemy.ext.mutable.Mutable
    "sqlalchemy.ext.mutable.Mutable"), `builtins.set`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Add an element to a set.
  prefs: []
  type: TYPE_NORMAL
- en: This has no effect if the element is already present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Remove all elements from this set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Convert plain set to instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Remove all elements of another set from this set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Remove an element from a set if it is a member.
  prefs: []
  type: TYPE_NORMAL
- en: If the element is not a member, do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the intersection of itself and another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Remove and return an arbitrary set element. Raises KeyError if the set is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Remove an element from a set; it must be a member.
  prefs: []
  type: TYPE_NORMAL
- en: If the element is not a member, raise a KeyError.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the symmetric difference of itself and another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Update a set with the union of itself and others.
  prefs: []
  type: TYPE_NORMAL
