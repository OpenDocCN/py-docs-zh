- en: Writing SELECT statements for ORM Mapped Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 ORM 映射类编写 SELECT 语句
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/select.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This section makes use of ORM mappings first illustrated in the [SQLAlchemy
    Unified Tutorial](../../tutorial/index.html#unified-tutorial), shown in the section
    [Declaring Mapped Classes](../../tutorial/metadata.html#tutorial-declaring-mapped-classes).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节利用了首次在[SQLAlchemy 统一教程](../../tutorial/index.html#unified-tutorial)中展示的 ORM
    映射，显示在[声明映射类](../../tutorial/metadata.html#tutorial-declaring-mapped-classes)一节中。
- en: '[View the ORM setup for this page](_plain_setup.html).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看此页面的 ORM 设置](_plain_setup.html)。'
- en: 'SELECT statements are produced by the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function which returns a [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object. The entities and/or SQL expressions
    to return (i.e. the “columns” clause) are passed positionally to the function.
    From there, additional methods are used to generate the complete statement, such
    as the [`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method illustrated below:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT 语句由 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 函数生成，该函数返回一个 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象。要返回的实体和/或 SQL 表达式（即“columns”子句）按位置传递给该函数。然后，使用其他方法生成完整的语句，例如下面所示的
    [`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 方法：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given a completed [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, in order to execute it within the
    ORM to get rows back, the object is passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), where a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object is then returned:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个完成的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，为了在 ORM 中执行并获取行，对象被传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，然后返回一个 [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '## Selecting ORM Entities and Attributes'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '## 选择 ORM 实体和属性'
- en: The [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct accepts ORM entities, including
    mapped classes as well as class-level attributes representing mapped columns,
    which are converted into [ORM-annotated](../../glossary.html#term-ORM-annotated)
    [`FromClause`](../../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") and [`ColumnElement`](../../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") elements at construction time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造函数接受 ORM 实体，包括映射类以及表示映射列的类级别属性，这些属性在构造时转换为[ORM 注解的](../../glossary.html#term-ORM-annotated)
    [`FromClause`](../../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 和 [`ColumnElement`](../../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 元素。'
- en: A [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object that contains ORM-annotated entities is normally executed using a [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object, and not a [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, so that ORM-related features may take
    effect, including that instances of ORM-mapped objects may be returned. When using
    the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly, result rows will only contain column-level data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 ORM 注解实体的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象通常使用 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象执行，而不是 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象，以便 ORM 相关功能生效，包括可以返回 ORM 映射对象的实例。直接使用 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 时，结果行仅包含列级数据。
- en: '### Selecting ORM Entities'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择 ORM 实体'
- en: 'Below we select from the `User` entity, producing a [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that selects from the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们从`User`实体中进行选择，生成一个从`User`映射到的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")中进行选择的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When selecting from ORM entities, the entity itself is returned in the result
    as a row with a single element, as opposed to a series of individual columns;
    for example above, the [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have just a single element per row, that
    element holding onto a `User` object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 ORM 实体中进行选择时，实体本身作为具有单个元素的行返回结果，而不是一系列单独的列；例如上面，[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")返回仅在每行具有单个元素的[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，该元素保留着一个`User`对象：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When selecting a list of single-element rows containing ORM entities, it is
    typical to skip the generation of [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects and instead receive ORM entities directly. This
    is most easily achieved by using the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute, rather than the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, so that a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object which yields single elements rather than
    rows is returned:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择包含 ORM 实体的单元素行列表时，通常会跳过生成[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，而是直接接收 ORM 实体。最简单的方法是使用[`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")方法来执行，而不是[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法，这样就会返回一个[`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")对象，该对象产生单个元素而不是行：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Calling the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method is the equivalent to calling upon [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to receive a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, then calling upon [`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") to receive a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object.  ### Selecting Multiple ORM Entities
    Simultaneously'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用[`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")方法相当于调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来接收一个[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后调用[`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars")来接收一个[`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")对象。###同时选择多个 ORM 实体
- en: 'The [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function accepts any number of ORM classes
    and/or column expressions at once, including that multiple ORM classes may be
    requested. When SELECTing from multiple ORM classes, they are named in each result
    row based on their class name. In the example below, the result rows for a SELECT
    against `User` and `Address` will refer to them under the names `User` and `Address`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")函数一次接受任意数量的
    ORM 类和/或列表达式，包括可以请求多个 ORM 类的情况。当从多个 ORM 类中选择时，它们在每个结果行中根据其类名命名。在下面的示例中，针对`User`和`Address`进行
    SELECT 的结果行将以`User`和`Address`的名称引用它们：'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we wanted to assign different names to these entities in the rows, we would
    use the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct using the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter to alias them with an explicit name:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为这些实体在行中分配不同的名称，我们将使用[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，使用[`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased")参数将它们别名为显式名称：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The aliased form above is discussed further at [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述别名形式在[使用关系连接别名目标](#orm-queryguide-joining-relationships-aliased)中进一步讨论。
- en: 'An existing [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct may also have ORM classes and/or
    column expressions added to its columns clause using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. We can produce the same
    statement as above using this form as well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")构造来向其列子句添加ORM类和/或列表达式，方法是使用[`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns")方法。我们也可以使用这种形式来生成上述语句：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Selecting Individual Attributes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择单个属性
- en: 'The attributes on a mapped class, such as `User.name` and `Address.email_address`,
    can be used just like [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression objects when passed to [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"). Creating a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that is against specific columns will return
    [`Row`](../../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, and **not** entities like `User` or `Address` objects. Each [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") will have each column represented individually:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类上的属性，如`User.name`和`Address.email_address`，当传递给[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")时，可以像[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或其他SQL表达式对象一样使用。针对特定列创建一个[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")将返回[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，而**不是**像`User`或`Address`对象那样的实体。每个[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")将单独表示每一列：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The above statement returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects with `name` and `email_address` columns, as illustrated
    in the runtime demonstration below:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句返回具有`name`和`email_address`列的[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，如下所示的运行时演示：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '### Grouping Selected Attributes with Bundles'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用Bundle对选定属性进行分组'
- en: 'The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") construct
    is an extensible ORM-only construct that allows sets of column expressions to
    be grouped in result rows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") 构造是一个可扩展的仅限ORM的构造，允许将列表达式集合分组在结果行中：'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") is potentially
    useful for creating lightweight views and custom column groupings. [`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") may also be subclassed in order to return alternate data
    structures; see [`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor") for an example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") 可能对创建轻量级视图和自定义列分组很有用。[`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") 也可以被子类化以返回替代数据结构；参见[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor") 以获取示例。'
- en: See also
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
- en: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")  ### Selecting ORM Aliases'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")  ### 选择ORM别名'
- en: 'As discussed in the tutorial at [Using Aliases](../../tutorial/data_select.html#tutorial-using-aliases),
    to create a SQL alias of an ORM entity is achieved using the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[使用别名](../../tutorial/data_select.html#tutorial-using-aliases)的教程中讨论的那样，要创建ORM实体的SQL别名，可以使用针对映射类的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造实现：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As is the case when using [`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias"), the SQL alias is anonymously named. For the
    case of selecting the entity from a row with an explicit name, the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter may be passed as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用[`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias")时的情况一样，SQL 别名是匿名命名的。对于从具有显式名称的行中选择实体的情况，也可以传递[`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased")参数：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: 'The [`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct
    is central for several use cases, including:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") 构造在几种情况下都很重要，包括：'
- en: making use of subqueries with the ORM; the sections [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries) and [Joining to Subqueries](#orm-queryguide-join-subqueries)
    discuss this further.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ORM 的子查询；章节[从子查询中选择实体](#orm-queryguide-subqueries)和[加入子查询](#orm-queryguide-join-subqueries)进一步讨论了这一点。
- en: Controlling the name of an entity in a result set; see [Selecting Multiple ORM
    Entities Simultaneously](#orm-queryguide-select-multiple-entities) for an example
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结果集中实体的名称；参见[同时选择多个 ORM 实体](#orm-queryguide-select-multiple-entities)以查看示例
- en: 'Joining to the same ORM entity multiple times; see [Using Relationship to join
    between aliased targets](#orm-queryguide-joining-relationships-aliased) for an
    example.  ### Getting ORM Results from Textual Statements'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次连接到相同的 ORM 实体；参见[使用关系连接到别名目标](#orm-queryguide-joining-relationships-aliased)以查看示例。###从文本语句获取
    ORM 结果
- en: The ORM supports loading of entities from SELECT statements that come from other
    sources. The typical use case is that of a textual SELECT statement, which in
    SQLAlchemy is represented using the [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. A [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be augmented with information
    about the ORM-mapped columns that the statement would load; this can then be associated
    with the ORM entity itself so that ORM objects can be loaded based on this statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 支持从其他来源的 SELECT 语句加载实体。典型的用例是文本 SELECT 语句，在 SQLAlchemy 中使用[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造表示。可以使用[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造增强关于该语句将加载的 ORM 映射列的信息；然后可以将其与 ORM 实体本身关联，以便基于此语句加载
    ORM 对象。
- en: 'Given a textual SQL statement we’d like to load from:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个文本 SQL 语句，我们希望从中加载：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can add column information to the statement by using the [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method; when this method is invoked,
    the [`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") object is converted into a [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object, which takes on a role that
    is comparable to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct. The [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method is typically passed [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or equivalent, and in this case we can make
    use of the ORM-mapped attributes on the `User` class directly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法，我们可以为语句添加列信息；当调用此方法时，[`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")对象被转换为一个[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象，该对象扮演的角色类似于[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造。[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法通常传递[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象或等效对象，在这种情况下，我们可以直接使用`User`类上映射的属性：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We now have an ORM-configured SQL construct that as given, can load the “id”,
    “name” and “fullname” columns separately. To use this SELECT statement as a source
    of complete `User` entities instead, we can link these columns to a regular ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个经过ORM配置的SQL构造，按照给定的方式，可以单独加载“id”、“name”和“fullname”列。要将此SELECT语句用作完整`User`实体的源，则可以使用[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")方法将这些列链接到常规的ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object can also be converted into a
    subquery using the [`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") method, and linked to the
    `User` entity to it using the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, in a similar manner as discussed below in [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象也可以使用[`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery")方法转换为子查询，并使用[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造将其链接到`User`实体，方式与下面讨论的[从子查询中选择实体](#orm-queryguide-subqueries)类似：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The difference between using the [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") directly with [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") versus making use of `aliased()`
    is that in the former case, no subquery is produced in the resulting SQL. This
    can in some scenarios be advantageous from a performance or complexity perspective.  ###
    Selecting Entities from Subqueries'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '直接使用[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")与[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")相比，使用`aliased()`的区别在于，在前一种情况下，生成的SQL中不会产生子查询。在某些情景下，这样做从性能或复杂性的角度来看可能是有利的。  ###
    从子查询中选择实体'
- en: 'The [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct discussed in the previous section can be used with any `Subuqery` construct
    that comes from a method such as [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") to link ORM entities to the columns
    returned by that subquery; there must be a **column correspondence** relationship
    between the columns delivered by the subquery and the columns to which the entity
    is mapped, meaning, the subquery needs to be ultimately derived from those entities,
    such as in the example below:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节讨论的[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造中，可以与任何来自诸如[`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery")之类的方法的`Subuqery`构造一起使用，以将ORM实体链接到该子查询返回的列；子查询返回的列与实体映射的列之间必须存在**列对应**关系，这意味着子查询最终需要来自这些实体，就像下面的示例中一样：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Entity Subqueries/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM实体子查询/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - 在[SQLAlchemy统一教程](../../tutorial/index.html#unified-tutorial)中'
- en: '[Joining to Subqueries](#orm-queryguide-join-subqueries)  ### Selecting Entities
    from UNIONs and other set operations'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入到子查询](#orm-queryguide-join-subqueries)  ### 从UNION和其他集合操作中选择实体'
- en: 'The [`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union") and [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") functions are the most common set operations,
    which along with other set operations such as [`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), [`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and others deliver an object known as a
    [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is composed of multiple [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs joined by a set-operation keyword.
    ORM entities may be selected from simple compound selects using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method illustrated previously
    at [Getting ORM Results from Textual Statements](#orm-queryguide-selecting-text).
    In this method, the UNION statement is the complete statement that will be rendered,
    no additional criteria can be added after [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union "sqlalchemy.sql.expression.union")和[`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 函数是最常见的集合操作之一，与[`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_")、[`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect")等其他集合操作一起，它们生成一个称为[`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect")的对象，该对象由多个使用集合操作关键字连接的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造组成。ORM 实体可以使用[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")方法从简单的复合选择中选择，该方法如在[从文本语句中获取
    ORM 结果](#orm-queryguide-selecting-text)中所示。在这种方法中，UNION 语句是将呈现的完整语句，不能在使用[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")之后添加额外的条件：'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct can be more flexibly used
    within a query that can be further modified by organizing it into a subquery and
    linking it to an ORM entity using [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased"), as illustrated previously at [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries). In the example below, we first use [`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery") to create a subquery of the
    UNION ALL statement, we then package that into the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct where it can be used like any other mapped
    entity in a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, including that we can add filtering
    and order by criteria based on its exported columns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect")构造可以更灵活地在查询中使用，可以通过将其组织成子查询并使用[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")将其链接到 ORM 实体来进一步修改，如在[从子查询中选择实体](#orm-queryguide-subqueries)中所示。在下面的示例中，我们首先使用[`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery")创建 UNION ALL 语句的子查询，然后将其打包到[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造中，在其中可以像其他映射实体一样在[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造中使用，包括我们可以基于其导出的列添加过滤和排序条件：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting ORM Entities from Unions](../../tutorial/data_select.html#tutorial-orm-union)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)  ##
    Joins'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[从联合中选择 ORM 实体](../../tutorial/data_select.html#tutorial-orm-union) - 在[SQLAlchemy
    统一教程](../../tutorial/index.html#unified-tutorial)中##连接'
- en: The [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods are used to construct SQL
    JOINs against a SELECT statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法用于构建针对SELECT语句的SQL JOINs。'
- en: This section will detail ORM use cases for these methods. For a general overview
    of their use from a Core perspective, see [Explicit FROM clauses and JOINs](../../tutorial/data_select.html#tutorial-select-join)
    in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细介绍这些方法的ORM用例。有关从核心角度使用它们的通用概述，请参阅[明确的FROM子句和JOINs](../../tutorial/data_select.html#tutorial-select-join)中的[SQLAlchemy统一教程](../../tutorial/index.html#unified-tutorial)。
- en: The usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") in an ORM context for [2.0 style](../../glossary.html#term-2.0-style)
    queries is mostly equivalent, minus legacy use cases, to the usage of the [`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method in [1.x style](../../glossary.html#term-1.x-style)
    queries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在ORM上下文中使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")进行[2.0风格](../../glossary.html#term-2.0-style)查询的用法大致相同，除了遗留用例外，与[1.x风格](../../glossary.html#term-1.x-style)查询中的[`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法的用法相似。
- en: '### Simple Relationship Joins'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '### 简单的关系连接'
- en: 'Consider a mapping between two classes `User` and `Address`, with a relationship
    `User.addresses` representing a collection of `Address` objects associated with
    each `User`. The most common usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to create a JOIN along this relationship,
    using the `User.addresses` attribute as an indicator for how this should occur:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个类`User`和`Address`之间的映射，其中关系`User.addresses`表示与每个`User`关联的`Address`对象的集合。
    [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的最常见用法是沿着这个关系创建JOIN，使用`User.addresses`属性作为指示器来指示这应该如何发生：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Where above, the call to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") along `User.addresses` will result in
    SQL approximately equivalent to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，对`User.addresses`的[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用将导致SQL大致等效于：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the above example we refer to `User.addresses` as passed to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") as the “on clause”, that is, it indicates
    how the “ON” portion of the JOIN should be constructed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们将`User.addresses`称为传递给[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的“on clause”，即它指示如何构造JOIN语句中的“ON”部分。
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Tip
- en: Note that using [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to JOIN from one entity to another affects
    the FROM clause of the SELECT statement, but not the columns clause; the SELECT
    statement in this example will continue to return rows from only the `User` entity.
    To SELECT columns / entities from both `User` and `Address` at the same time,
    the `Address` entity must also be named in the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, or added to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct afterwards using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. See the section [Selecting
    Multiple ORM Entities Simultaneously](#orm-queryguide-select-multiple-entities)
    for examples of both of these forms.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")从一个实体连接到另一个实体会影响SELECT语句的FROM子句，但不会影响列子句；此示例中的SELECT语句将继续只返回`User`实体的行。要同时从`User`和`Address`选择列/实体，必须在[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")函数中命名`Address`实体，或者使用[`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns")方法在之后将其添加到[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中。请参阅 [同时选择多个ORM实体](#orm-queryguide-select-multiple-entities)
    部分以了解这两种形式的示例。
- en: Chaining Multiple Joins
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式多重连接
- en: 'To construct a chain of joins, multiple [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls may be used. The relationship-bound
    attribute implies both the left and right side of the join at once. Consider additional
    entities `Order` and `Item`, where the `User.orders` relationship refers to the
    `Order` entity, and the `Order.items` relationship refers to the `Item` entity,
    via an association table `order_items`. Two [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls will result in a JOIN first from
    `User` to `Order`, and a second from `Order` to `Item`. However, since `Order.items`
    is a [many to many](../basic_relationships.html#relationships-many-to-many) relationship,
    it results in two separate JOIN elements, for a total of three JOIN elements in
    the resulting SQL:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一系列连接，可以使用多个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用。关系绑定属性一次暗示了连接的左侧和右侧。考虑额外的实体`Order`和`Item`，其中`User.orders`关系引用了`Order`实体，而`Order.items`关系通过关联表`order_items`引用了`Item`实体。两个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用将首先从`User`到`Order`进行连接，然后从`Order`到`Item`进行第二次连接。但是，由于`Order.items`是[多对多](../basic_relationships.html#relationships-many-to-many)关系，它导致两个单独的JOIN元素，总共在生成的SQL中有三个JOIN元素：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The order in which each call to the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is significant only to the degree
    that the “left” side of what we would like to join from needs to be present in
    the list of FROMs before we indicate a new target. [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would not, for example, know how to join
    correctly if we were to specify `select(User).join(Order.items).join(User.orders)`,
    and would raise an error. In correct practice, the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is invoked in such a way that
    lines up with how we would want the JOIN clauses in SQL to be rendered, and each
    call should represent a clear link from what precedes it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法的顺序只有在我们想要连接的“左”侧需要在FROM列表中出现时才有意义；如果我们指定`select(User).join(Order.items).join(User.orders)`，则[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")将不知道如何正确连接，并引发错误。在正确的做法中，应以使JOIN子句在SQL中呈现方式对齐的方式调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，并且每次调用应表示从之前的内容清晰地链接过来。
- en: 'All of the elements that we target in the FROM clause remain available as potential
    points to continue joining FROM. We can continue to add other elements to join
    FROM the `User` entity above, for example adding on the `User.addresses` relationship
    to our chain of joins:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 FROM 子句中目标的所有元素仍然可以作为继续连接 FROM 的潜在点。例如，我们可以继续添加其他元素来连接 FROM 上面的`User`实体，例如在连接链中添加`User.addresses`关系：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Joins to a Target Entity
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到目标实体
- en: 'A second form of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") allows any mapped entity or core selectable
    construct as a target. In this usage, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") will attempt to **infer** the ON clause
    for the JOIN, using the natural foreign key relationship between two entities:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式的[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")允许任何映射实体或核心可选择的构造作为目标。在这种用法中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")将尝试**推断**JOIN的ON子句，使用两个实体之间的自然外键关系：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the above calling form, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is called upon to infer the “on clause”
    automatically. This calling form will ultimately raise an error if either there
    are no [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") setup between the two mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs, or if there are multiple [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") linkages between them such that the
    appropriate constraint to use is ambiguous.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述调用形式中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")被调用以自动推断“on 子句”。如果两个映射的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造之间没有[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")设置，或者存在多个使适当约束使用变得模糊的 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 链接时，此调用形式最终会引发错误。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When making use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") without indicating an ON clause,
    ORM configured [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs are **not taken into account**. Only
    the configured [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") relationships between the entities at
    the level of the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects are consulted when an attempt is made to infer
    an ON clause for the JOIN.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")或 [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 而不指示 ON 子句时，ORM 配置的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造不会被考虑。只有在尝试推断 JOIN 的 ON 子句时，才会查阅映射的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象级别上的实体之间配置的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")关系。
- en: '### Joins to a Target with an ON Clause'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '### 连接到具有 ON 子句的目标'
- en: 'The third calling form allows both the target entity as well as the ON clause
    to be passed explicitly. A example that includes a SQL expression as the ON clause
    is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种调用形式允许目标实体以及 ON 子句都明确传递。包含 SQL 表达式作为 ON 子句的示例如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The expression-based ON clause may also be a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, in the same way it’s used in [Simple
    Relationship Joins](#orm-queryguide-simple-relationship-join):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表达式的 ON 子句也可以是一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-绑定属性，就像在[简单关系连接](#orm-queryguide-simple-relationship-join)中使用的那样：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The above example seems redundant in that it indicates the target of `Address`
    in two different ways; however, the utility of this form becomes apparent when
    joining to aliased entities; see the section [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased) for an example.  ###
    Combining Relationship with Custom ON Criteria'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子看起来是多余的，因为它以两种不同的方式指示了 `Address` 的目标；然而，当连接到别名实体时，这种形式的效用就变得明显了；请参阅 [Using
    Relationship to join between aliased targets](#orm-queryguide-joining-relationships-aliased)
    部分以查看示例。### 结合 Relationship 与自定义 ON 条件
- en: 'The ON clause generated by the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct may be augmented with additional criteria.
    This is useful both for quick ways to limit the scope of a particular join over
    a relationship path, as well as for cases like configuring loader strategies such
    as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method accepts a series of SQL expressions
    positionally that will be joined to the ON clause of the JOIN via AND. For example
    if we wanted to JOIN from `User` to `Address` but also limit the ON criteria to
    only certain email addresses:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    构造生成的 ON 子句可能会通过附加条件进行增强。这对于快速限制特定连接的范围以及配置加载器策略（如 [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）等情况非常有用。[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") 方法按位置接受一系列 SQL 表达式，这些表达式将通过 AND 连接到 JOIN
    的 ON 子句。例如，如果我们想要从 `User` 连接到 `Address`，但也只限制 ON 条件为特定的电子邮件地址：'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: 'The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method also works with loader strategies
    such as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    See the section [Adding Criteria to loader options](relationships.html#loader-option-criteria).  ###
    Using Relationship to join between aliased targets'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") 方法也适用于加载器策略，如 [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")。请参阅 [Adding Criteria to loader options](relationships.html#loader-option-criteria)
    部分。### 使用 Relationship 在别名目标之间进行连接'
- en: 'When constructing joins using [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attributes to indicate the ON clause, the
    two-argument syntax illustrated in [Joins to a Target with an ON Clause](#queryguide-join-onclause)
    can be expanded to work with the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct, to indicate a SQL alias as the target of
    a join while still making use of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute to indicate the ON clause, as in
    the example below, where the `User` entity is joined twice to two different [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs against the `Address` entity:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-绑定属性指示 ON 子句构建连接时，可以将 [Joins to a Target with an
    ON Clause](#queryguide-join-onclause) 中说明的两个参数语法扩展到与 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造一起使用，以指示 SQL 别名作为连接的目标，同时仍然利用 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-绑定属性指示 ON 子句，如下例所示，其中 `User` 实体两次与两个不同的 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造连接到 `Address` 实体：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same pattern may be expressed more succinctly using the modifier [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type"), which may be applied to the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, passing along the target entity
    in order to indicate the target in one step. The example below uses [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") to produce the same SQL statement as
    the one just illustrated:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用修饰符 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 来更简洁地表达相同的模式，该修饰符可应用于与 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 绑定的属性，一次性传递目标实体以指示一步中的目标。下面的示例使用 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 来生成与刚刚展示的相同的 SQL 语句：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make use of a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to construct a join **from** an aliased entity,
    the attribute is available from the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 来构建来自别名实体的连接，直接从 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造中获取属性即可：
- en: '[PRE30]  ### Joining to Subqueries'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]  ### 加入到子查询'
- en: 'The target of a join may be any “selectable” entity which includes subuqeries.
    When using the ORM, it is typical that these targets are stated in terms of an
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct,
    but this is not strictly required, particularly if the joined entity is not being
    returned in the results. For example, to join from the `User` entity to the `Address`
    entity, where the `Address` entity is represented as a row limited subquery, we
    first construct a [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object using [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery"), which may then be used as the target
    of the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的目标可以是任何“可选择”的实体，包括子查询。在使用 ORM 时，通常将这些目标陈述为 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造的术语，但这不是严格要求的，特别是如果连接的实体不在结果中返回。例如，要从 `User` 实体连接到
    `Address` 实体，其中 `Address` 实体表示为行限制的子查询，我们首先使用 [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") 构造了一个 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象，然后可以将其用作 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法的目标：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The above SELECT statement when invoked via [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will return rows that contain `User` entities,
    but not `Address` entities. In order to include `Address` entities to the set
    of entities that would be returned in result sets, we construct an [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object against the `Address` entity and [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object. We also may wish to apply a name
    to the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, such as `"address"` used below, so that we can refer to it by name
    in the result row:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 SELECT 语句在通过 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用时，将返回包含 `User` 实体但不包含 `Address` 实体的行。为了将 `Address`
    实体包含到将在结果集中返回的实体集合中，我们对 `Address` 实体和 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象构造了一个 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 对象。我们还可能希望对 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造应用一个名称，如下面使用的 `"address"`，这样我们就可以在结果行中按名称引用它：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Joining to Subqueries along Relationship paths
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入到子查询的关联路径
- en: 'The subquery form illustrated in the previous section may be expressed with
    more specificity using a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute using one of the forms indicated
    at [Using Relationship to join between aliased targets](#orm-queryguide-joining-relationships-aliased).
    For example, to create the same join while ensuring the join is along that of
    a particular [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), we may use the [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method, passing the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct containing the [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object that’s the target of the join:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中说明的子查询形式可以使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定属性更具体地表示，使用[使用Relationship在别名目标之间进行连接](#orm-queryguide-joining-relationships-aliased)中指示的形式之一。例如，要创建相同的连接，同时确保连接是沿着特定[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")进行的，我们可以使用[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法，传递包含连接目标的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造，该目标是[`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")对象的。
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Subqueries that Refer to Multiple Entities
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用多个实体的子查询
- en: A subquery that contains columns spanning more than one ORM entity may be applied
    to more than one [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct at once, and used in the same [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in terms of each entity separately.
    The rendered SQL will continue to treat all such [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs as the same subquery, however from the ORM
    / Python perspective the different return values and object attributes can be
    referenced by using the appropriate [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 包含跨越多个ORM实体列的子查询可以一次应用于多个[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造，并在同一[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中针对每个实体分别使用。然而，从ORM / Python的角度来看，渲染的SQL将继续将所有这些[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造视为相同的子查询，但可以通过使用适当的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造引用不同的返回值和对象属性。
- en: 'Given for example a subquery that refers to both `User` and `Address`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定同时引用`User`和`Address`的子查询：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can create [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    constructs against both `User` and `Address` that each refer to the same object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对`User`和`Address`分别创建对同一对象的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct selecting from both entities will render the subquery once, but in a
    result-row context can return objects of both `User` and `Address` classes at
    the same time:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个实体中选择的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造将一次渲染子查询，但在结果行上下文中可以同时返回`User`和`Address`类的对象：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '### Setting the leftmost FROM clause in a join'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置连接中最左侧的FROM子句'
- en: 'In cases where the left side of the current state of [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") is not in line with what we want to join from,
    the [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method may be used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")状态的左侧与我们要连接的内容不一致的情况下，可以使用[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 方法：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method accepts two or three arguments,
    either in the form `(<join from>, <onclause>)`, or `(<join from>, <join to>, [<onclause>])`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 方法接受两个或三个参数，形式可以是 `(<join from>,
    <onclause>)`，或者 `(<join from>, <join to>, [<onclause>])`：'
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To set up the initial FROM clause for a SELECT such that [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") can be used subsequent, the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method may also be used:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为SELECT设置初始的FROM子句，以便随后可以使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，也可以使用[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")方法：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method does not actually have
    the final say on the order of tables in the FROM clause. If the statement also
    refers to a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct that refers to existing tables in
    a different order, the [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct takes precedence. When we use methods
    like [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from"), these methods are ultimately creating
    such a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    object. Therefore we can see the contents of [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") being overridden in a case like
    this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")方法实际上并不决定FROM子句中表的顺序。如果语句还引用了引用不同顺序的现有表的[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")构造，那么[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")构造将优先。当我们使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")等方法时，这些方法最终会创建这样一个[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象。因此，在这种情况下，我们可以看到[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")的内容被覆盖：'
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Where above, we see that the FROM clause is `address JOIN user_account`, even
    though we stated `select_from(User)` first. Because of the `.join(Address.user)`
    method call, the statement is ultimately equivalent to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到FROM子句是`address JOIN user_account`，尽管我们首先声明了`select_from(User)`。由于`.join(Address.user)`方法调用，该语句最终等同于以下内容：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    construct above is added as another entry in the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") list which supersedes the previous
    entry.  ## Relationship WHERE Operators'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")构造被添加为[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")列表中的另一个条目，它取代了之前的条目。## 关系WHERE运算符
- en: Besides the use of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs within the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods, [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") also plays a role in helping to construct SQL expressions
    that are typically for use in the WHERE clause, using the [`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法中使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造之外，[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")还在帮助构建通常用于WHERE子句的SQL表达式，使用[`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where")方法。
- en: '### EXISTS forms: has() / any()'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '### EXISTS 形式：has() / any()'
- en: The [`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")
    construct was first introduced in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)
    in the section [EXISTS subqueries](../../tutorial/data_select.html#tutorial-exists).
    This object is used to render the SQL EXISTS keyword in conjunction with a scalar
    subquery. The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct provides for some helper methods that
    may be used to generate some common EXISTS styles of queries in terms of the relationship.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")
    构造首次出现在 [SQLAlchemy 统一教程](../../tutorial/index.html#unified-tutorial) 的 [EXISTS
    子查询](../../tutorial/data_select.html#tutorial-exists) 部分。此对象用于在标量子查询中与 SQL EXISTS
    关键字一起呈现。[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造提供了一些辅助方法，可用于生成一些常见的 EXISTS 样式的查询，这些查询涉及关系。'
- en: 'For a one-to-many relationship such as `User.addresses`, an EXISTS against
    the `address` table that correlates back to the `user_account` table can be produced
    using [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"). This method accepts an optional WHERE criteria
    to limit the rows matched by the subquery:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一对多关系，例如 `User.addresses`，可以使用与 `user_account` 表相关联的 `address` 表的 EXISTS 来产生一个
    [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any "sqlalchemy.orm.PropComparator.any")。此方法接受一个可选的
    WHERE 条件来限制子查询匹配的行数：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As EXISTS tends to be more efficient for negative lookups, a common query is
    to locate entities where there are no related entities present. This is succinct
    using a phrase such as `~User.addresses.any()`, to select for `User` entities
    that have no related `Address` rows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EXISTS 对于负查找更有效，因此一个常见的查询是定位不存在相关实体的实体。这可以通过短语 `~User.addresses.any()` 来简洁地实现，以选择没有相关
    `Address` 行的 `User` 实体：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The [`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has") method works in mostly the same way as [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"), except that it’s used for many-to-one relationships,
    such as if we wanted to locate all `Address` objects which belonged to “sandy”:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has") 方法的工作方式基本与 [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any") 相同，不同之处在于它用于多对一关系，例如，如果我们想要定位所有属于 “sandy”
    的 `Address` 对象。'
- en: '[PRE44]  ### Relationship Instance Comparison Operators'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]  ### 关系实例比较运算符'
- en: The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute also offers a few SQL construction
    implementations that are geared towards filtering a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute in terms of a specific instance
    of a related object, which can unpack the appropriate attribute values from a
    given [persistent](../../glossary.html#term-persistent) (or less commonly a [detached](../../glossary.html#term-detached))
    object instance and construct WHERE criteria in terms of the target [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    绑定属性还提供了一些 SQL 构造实现，这些实现旨在根据相关对象的特定实例来过滤 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 绑定属性，该实例可以从给定的 [持久化](../../glossary.html#term-persistent)（或不太常见的
    [分离](../../glossary.html#term-detached)）对象实例中拆解适当的属性值，并按照目标 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造 WHERE 条件。'
- en: '**many to one equals comparison** - a specific object instance can be compared
    to many-to-one relationship, to select rows where the foreign key of the target
    entity matches the primary key value of the object given:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一等于比较** - 可以将特定对象实例与多对一关系进行比较，以选择目标实体的外键与给定对象的主键值匹配的行：'
- en: '[PRE45]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**many to one not equals comparison** - the not equals operator may also be
    used:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一不等于比较** - 也可以使用不等于运算符：'
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**object is contained in a one-to-many collection** - this is essentially the
    one-to-many version of the “equals” comparison, select rows where the primary
    key equals the value of the foreign key in a related object:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象包含在一对多集合中** - 这本质上是“等于”比较的一对多版本，选择主键等于相关对象中外键值的行：'
- en: '[PRE47]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**An object has a particular parent from a one-to-many perspective** - the
    [`with_parent()`](api.html#sqlalchemy.orm.with_parent "sqlalchemy.orm.with_parent")
    function produces a comparison that returns rows which are referenced by a given
    parent, this is essentially the same as using the `==` operator with the many-to-one
    side:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从一对多的角度看，对象有一个特定的父对象** - [`with_parent()`](api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") 函数生成一个比较，返回被给定父对象引用的行，这本质上与在多对一侧使用 `==` 操作符相同：'
- en: '[PRE48]  ## Selecting ORM Entities and Attributes'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE48]  ## 选择 ORM 实体和属性'
- en: The [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct accepts ORM entities, including
    mapped classes as well as class-level attributes representing mapped columns,
    which are converted into [ORM-annotated](../../glossary.html#term-ORM-annotated)
    [`FromClause`](../../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") and [`ColumnElement`](../../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") elements at construction time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造接受 ORM 实体，包括映射类以及表示映射列的类级属性，这些在构建时转换为 [ORM 注释](../../glossary.html#term-ORM-annotated)
    的 [`FromClause`](../../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 和 [`ColumnElement`](../../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 元素。'
- en: A [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object that contains ORM-annotated entities is normally executed using a [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object, and not a [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, so that ORM-related features may take
    effect, including that instances of ORM-mapped objects may be returned. When using
    the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly, result rows will only contain column-level data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 ORM 注释实体的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象通常使用 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象执行，而不是使用 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象，以便 ORM 相关功能生效，包括可以返回 ORM 映射对象的实例。直接使用 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 时，结果行将仅包含列级数据。
- en: '### Selecting ORM Entities'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择 ORM 实体'
- en: 'Below we select from the `User` entity, producing a [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that selects from the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们从 `User` 实体中选择，生成一个从 `User` 映射到的映射 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中选择的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")：
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When selecting from ORM entities, the entity itself is returned in the result
    as a row with a single element, as opposed to a series of individual columns;
    for example above, the [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have just a single element per row, that
    element holding onto a `User` object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 ORM 实体时，实体本身作为具有单个元素的行返回结果，而不是一系列单独的列；例如上面，[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 返回仅具有每行单个元素的 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，该元素保持一个 `User` 对象：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When selecting a list of single-element rows containing ORM entities, it is
    typical to skip the generation of [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects and instead receive ORM entities directly. This
    is most easily achieved by using the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute, rather than the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, so that a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object which yields single elements rather than
    rows is returned:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择包含ORM实体的单元素行列表时，通常会跳过生成[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，并直接接收ORM实体。这最容易通过使用[`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")方法执行，而不是使用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法来实现，因此返回一个[`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")对象，该对象产生单个元素而不是行：
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Calling the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method is the equivalent to calling upon [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to receive a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, then calling upon [`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") to receive a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object.  ### Selecting Multiple ORM Entities
    Simultaneously'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '调用[`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")方法相当于调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来接收一个[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后调用[`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars")来接收一个[`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")对象。 ### 同时选择多个ORM实体'
- en: 'The [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function accepts any number of ORM classes
    and/or column expressions at once, including that multiple ORM classes may be
    requested. When SELECTing from multiple ORM classes, they are named in each result
    row based on their class name. In the example below, the result rows for a SELECT
    against `User` and `Address` will refer to them under the names `User` and `Address`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")函数一次接受任意数量的ORM类和/或列表达式，包括可以请求多个ORM类。当从多个ORM类中选择时，它们在每个结果行中根据其类名命名。在下面的示例中，对`User`和`Address`进行SELECT的结果行将以`User`和`Address`的名称引用它们：'
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we wanted to assign different names to these entities in the rows, we would
    use the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct using the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter to alias them with an explicit name:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在这些实体中的行上分配不同的名称，我们将使用[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，使用[`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased.params.name")参数将它们别名为一个明确的名称：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The aliased form above is discussed further at [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的别名形式在[使用关系连接别名目标之间](#orm-queryguide-joining-relationships-aliased)有进一步讨论。
- en: 'An existing [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct may also have ORM classes and/or
    column expressions added to its columns clause using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. We can produce the same
    statement as above using this form as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现有的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造也可以使用[`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns")方法将ORM类和/或列表达式添加到其列子句中。我们也可以使用这种形式生成与上述相同的语句：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Selecting Individual Attributes
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择单个属性
- en: 'The attributes on a mapped class, such as `User.name` and `Address.email_address`,
    can be used just like [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression objects when passed to [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"). Creating a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that is against specific columns will return
    [`Row`](../../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, and **not** entities like `User` or `Address` objects. Each [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") will have each column represented individually:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类上的属性，如`User.name`和`Address.email_address`，可以像传递给[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")的[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或其他SQL表达式对象一样使用。创建针对特定列的[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")将返回[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象，而**不是**像`User`或`Address`对象那样的实体。每个[`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")将分别表示每个列：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The above statement returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects with `name` and `email_address` columns, as illustrated
    in the runtime demonstration below:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句返回[`Row`](../../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")对象，具有`name`和`email_address`列，如下所示的运行时演示：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '### Grouping Selected Attributes with Bundles'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用Bundles分组选择的属性'
- en: 'The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") construct
    is an extensible ORM-only construct that allows sets of column expressions to
    be grouped in result rows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")构造是一个可扩展的仅ORM构造，允许将列表达式集合分组在结果行中：'
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") is potentially
    useful for creating lightweight views and custom column groupings. [`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") may also be subclassed in order to return alternate data
    structures; see [`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor") for an example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")可能对创建轻量级视图和自定义列分组有用。[`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle")也可以被子类化以返回替代数据结构；请参阅[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")获取示例。'
- en: See also
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
- en: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")  ### Selecting ORM Aliases'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")  ### 选择ORM别名'
- en: 'As discussed in the tutorial at [Using Aliases](../../tutorial/data_select.html#tutorial-using-aliases),
    to create a SQL alias of an ORM entity is achieved using the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[使用别名](../../tutorial/data_select.html#tutorial-using-aliases)的教程中所讨论的，要创建ORM实体的SQL别名是使用针对映射类的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造实现的：
- en: '[PRE58]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As is the case when using [`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias"), the SQL alias is anonymously named. For the
    case of selecting the entity from a row with an explicit name, the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter may be passed as well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用[`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias")时一样，SQL别名是匿名命名的。对于从具有显式名称的行中选择实体的情况，还可以传递[`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased")参数：
- en: '[PRE59]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct
    is central for several use cases, including:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造在几个用例中都很重要，包括：'
- en: making use of subqueries with the ORM; the sections [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries) and [Joining to Subqueries](#orm-queryguide-join-subqueries)
    discuss this further.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用ORM进行子查询；章节[从子查询中选择实体](#orm-queryguide-subqueries)和[加入子查询](#orm-queryguide-join-subqueries)进一步讨论了这一点。
- en: Controlling the name of an entity in a result set; see [Selecting Multiple ORM
    Entities Simultaneously](#orm-queryguide-select-multiple-entities) for an example
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结果集中实体的名称；参见[同时选择多个ORM实体](#orm-queryguide-select-multiple-entities)的示例。
- en: 'Joining to the same ORM entity multiple times; see [Using Relationship to join
    between aliased targets](#orm-queryguide-joining-relationships-aliased) for an
    example.  ### Getting ORM Results from Textual Statements'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入到同一个ORM实体多次；参见[使用关系连接别名目标之间](#orm-queryguide-joining-relationships-aliased)的示例。###
    从文本语句中获取ORM结果
- en: The ORM supports loading of entities from SELECT statements that come from other
    sources. The typical use case is that of a textual SELECT statement, which in
    SQLAlchemy is represented using the [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. A [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be augmented with information
    about the ORM-mapped columns that the statement would load; this can then be associated
    with the ORM entity itself so that ORM objects can be loaded based on this statement.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ORM支持从来自其他来源的SELECT语句加载实体。典型用例是文本SELECT语句，在SQLAlchemy中使用[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造表示。[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造可以通过有关将加载该语句的ORM映射列的信息进行增强；然后可以将其与ORM实体本身关联，以便基于此语句加载ORM对象。
- en: 'Given a textual SQL statement we’d like to load from:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个文本SQL语句，我们希望从中加载：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can add column information to the statement by using the [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method; when this method is invoked,
    the [`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") object is converted into a [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object, which takes on a role that
    is comparable to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct. The [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method is typically passed [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or equivalent, and in this case we can make
    use of the ORM-mapped attributes on the `User` class directly:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法向语句添加列信息；当调用此方法时，[`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")对象转换为[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象，其扮演与[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造类似的角色。[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法通常传递[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象或等效对象，在这种情况下，我们可以直接使用`User`类上的ORM映射属性：
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We now have an ORM-configured SQL construct that as given, can load the “id”,
    “name” and “fullname” columns separately. To use this SELECT statement as a source
    of complete `User` entities instead, we can link these columns to a regular ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个经过ORM配置的SQL构造，可以分别加载“id”、“name”和“fullname”列。要将此SELECT语句作为完整`User`实体的来源，我们可以使用[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")方法将这些列链接到常规的ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The same [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object can also be converted into a
    subquery using the [`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") method, and linked to the
    `User` entity to it using the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, in a similar manner as discussed below in [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象也可以使用[`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery")方法转换为子查询，并使用[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造将其链接到`User`实体中，方式与下文中[从子查询中选择实体](#orm-queryguide-subqueries)中所讨论的类似：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The difference between using the [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") directly with [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") versus making use of `aliased()`
    is that in the former case, no subquery is produced in the resulting SQL. This
    can in some scenarios be advantageous from a performance or complexity perspective.  ###
    Selecting Entities from Subqueries'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")和[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")与使用`aliased()`之间的区别在于，在前一种情况下，结果SQL中不会生成子查询。在某些情况下，从性能或复杂性的角度来看，这可能是有利的。###
    从子查询中选择实体
- en: 'The [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct discussed in the previous section can be used with any `Subuqery` construct
    that comes from a method such as [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") to link ORM entities to the columns
    returned by that subquery; there must be a **column correspondence** relationship
    between the columns delivered by the subquery and the columns to which the entity
    is mapped, meaning, the subquery needs to be ultimately derived from those entities,
    such as in the example below:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论的[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造可以与任何`Subquery`构造一起使用，该构造来自诸如[`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery")之类的方法，以将ORM实体链接到该子查询返回的列；子查询返回的列与实体映射的列之间必须存在**列对应**关系，这意味着子查询最终需要源自这些实体，就像下面的示例中所示：
- en: '[PRE64]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: See also
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 也请参见
- en: '[ORM Entity Subqueries/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM实体子查询/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - 在[SQLAlchemy统一教程](../../tutorial/index.html#unified-tutorial)中'
- en: '[Joining to Subqueries](#orm-queryguide-join-subqueries)  ### Selecting Entities
    from UNIONs and other set operations'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接到子查询](#orm-queryguide-join-subqueries) ### 从UNION和其他集合操作中选择实体'
- en: 'The [`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union") and [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") functions are the most common set operations,
    which along with other set operations such as [`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), [`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and others deliver an object known as a
    [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is composed of multiple [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs joined by a set-operation keyword.
    ORM entities may be selected from simple compound selects using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method illustrated previously
    at [Getting ORM Results from Textual Statements](#orm-queryguide-selecting-text).
    In this method, the UNION statement is the complete statement that will be rendered,
    no additional criteria can be added after [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union "sqlalchemy.sql.expression.union")
    和 [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 函数是最常见的集合操作，与其他集合操作（例如 [`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_")、[`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") 等）一起提供了一个称为 [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 的对象，该对象由多个由集合操作关键字连接的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造组成。ORM 实体可以使用 [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") 方法从简单的复合选择中选择，如前面在[从文本语句中获取
    ORM 结果](#orm-queryguide-selecting-text)中所示。在此方法中，UNION 语句是将呈现的完整语句，不能在使用 [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") 后添加额外的条件：'
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct can be more flexibly used
    within a query that can be further modified by organizing it into a subquery and
    linking it to an ORM entity using [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased"), as illustrated previously at [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries). In the example below, we first use [`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery") to create a subquery of the
    UNION ALL statement, we then package that into the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct where it can be used like any other mapped
    entity in a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, including that we can add filtering
    and order by criteria based on its exported columns:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中，[`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 构造可以更灵活地使用，可以通过将其组织成子查询并使用 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 连接到 ORM 实体来进一步修改，如前面在[从子查询中选择实体](#orm-queryguide-subqueries)中所示。在下面的示例中，我们首先使用
    [`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery") 创建 UNION ALL 语句的子查询，然后将其打包到
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") 构造中，在这里它可以像任何其他映射实体一样在
    [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造中使用，包括我们可以基于其导出列添加过滤和排序条件：
- en: '[PRE66]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: See also
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Selecting ORM Entities from Unions](../../tutorial/data_select.html#tutorial-orm-union)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)  ###
    Selecting ORM Entities'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[从联合中选择 ORM 实体](../../tutorial/data_select.html#tutorial-orm-union) - 在[SQLAlchemy
    统一教程](../../tutorial/index.html#unified-tutorial)中 ### 选择 ORM 实体'
- en: 'Below we select from the `User` entity, producing a [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") that selects from the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们从 `User` 实体中进行选择，生成一个从 `User` 映射到的映射 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中进行选择的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")：
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When selecting from ORM entities, the entity itself is returned in the result
    as a row with a single element, as opposed to a series of individual columns;
    for example above, the [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that have just a single element per row, that
    element holding onto a `User` object:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 ORM 实体中进行选择时，实体本身作为包含单个元素的行返回结果，而不是一系列单独的列；例如上面的例子，[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 返回仅具有每行单个元素的 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，该元素保存一个 `User` 对象：
- en: '[PRE68]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When selecting a list of single-element rows containing ORM entities, it is
    typical to skip the generation of [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects and instead receive ORM entities directly. This
    is most easily achieved by using the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method to execute, rather than the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, so that a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object which yields single elements rather than
    rows is returned:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择包含 ORM 实体的单元素行列表时，通常会跳过生成 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，而是直接接收 ORM 实体。这最容易通过使用 [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 方法执行，而不是 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法来实现，以便返回一个 [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 对象，该对象产生单个元素而不是行：
- en: '[PRE69]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Calling the [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method is the equivalent to calling upon [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to receive a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, then calling upon [`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") to receive a [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 方法相当于调用 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 来接收一个 [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象，然后调用 [`Result.scalars()`](../../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") 来接收一个 [`ScalarResult`](../../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 对象。
- en: '### Selecting Multiple ORM Entities Simultaneously'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '### 同时选择多个 ORM 实体'
- en: 'The [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function accepts any number of ORM classes
    and/or column expressions at once, including that multiple ORM classes may be
    requested. When SELECTing from multiple ORM classes, they are named in each result
    row based on their class name. In the example below, the result rows for a SELECT
    against `User` and `Address` will refer to them under the names `User` and `Address`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    函数一次接受任意数量的 ORM 类和/或列表达式，包括可以请求多个 ORM 类的情况。当从多个 ORM 类中进行 SELECT 时，它们在每个结果行中基于其类名命名。在下面的示例中，对
    `User` 和 `Address` 进行 SELECT 的结果行将以 `User` 和 `Address` 为名称进行引用：'
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we wanted to assign different names to these entities in the rows, we would
    use the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct using the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter to alias them with an explicit name:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为这些实体在行中分配不同的名称，我们将使用 [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造，并使用 [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name "sqlalchemy.orm.aliased")
    参数将它们别名为具有显式名称的实体：
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The aliased form above is discussed further at [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的别名形式在[使用关系来在别名目标之间进行连接](#orm-queryguide-joining-relationships-aliased)中进一步讨论。
- en: 'An existing [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct may also have ORM classes and/or
    column expressions added to its columns clause using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. We can produce the same
    statement as above using this form as well:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    结构也可以使用 [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") 方法将 ORM 类和/或列表达式添加到其列子句中。我们也可以使用这种形式来生成与上面相同的语句：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Selecting Individual Attributes
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择单个属性
- en: 'The attributes on a mapped class, such as `User.name` and `Address.email_address`,
    can be used just like [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or other SQL expression objects when passed to [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"). Creating a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that is against specific columns will return
    [`Row`](../../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, and **not** entities like `User` or `Address` objects. Each [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") will have each column represented individually:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类上的属性，如 `User.name` 和 `Address.email_address`，当传递给 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 时，可以像 [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 或其他 SQL 表达式对象一样使用。创建针对特定列的 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 将返回 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，而不是像 `User` 或 `Address` 对象那样的实体。每个 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 将分别表示每个列：
- en: '[PRE73]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The above statement returns [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects with `name` and `email_address` columns, as illustrated
    in the runtime demonstration below:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的语句返回具有 `name` 和 `email_address` 列的 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，如下运行时演示所示：
- en: '[PRE74]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '### Grouping Selected Attributes with Bundles'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 Bundle 分组选择的属性'
- en: 'The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") construct
    is an extensible ORM-only construct that allows sets of column expressions to
    be grouped in result rows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") 构造是一个可扩展的仅限
    ORM 的构造，允许将列表达式集合分组在结果行中：'
- en: '[PRE75]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The [`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") is potentially
    useful for creating lightweight views and custom column groupings. [`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") may also be subclassed in order to return alternate data
    structures; see [`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor") for an example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle") 可能对创建轻量级视图和自定义列分组很有用。[`Bundle`](api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") 也可以被子类化以返回替代数据结构；请参见 [`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor") 以获取示例。'
- en: See also
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle`](api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")'
- en: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Bundle.create_row_processor()`](api.html#sqlalchemy.orm.Bundle.create_row_processor
    "sqlalchemy.orm.Bundle.create_row_processor")'
- en: '### Selecting ORM Aliases'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择 ORM 别名'
- en: 'As discussed in the tutorial at [Using Aliases](../../tutorial/data_select.html#tutorial-using-aliases),
    to create a SQL alias of an ORM entity is achieved using the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如[使用别名](../../tutorial/data_select.html#tutorial-using-aliases)教程中所述，创建 ORM
    实体的 SQL 别名是通过对映射类使用 [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造完成的：
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As is the case when using [`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias"), the SQL alias is anonymously named. For the
    case of selecting the entity from a row with an explicit name, the [`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased") parameter may be passed as well:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用[`Table.alias()`](../../core/metadata.html#sqlalchemy.schema.Table.alias
    "sqlalchemy.schema.Table.alias")时一样，SQL别名是匿名命名的。对于从具有显式名称的行中选择实体的情况，也可以传递[`aliased.name`](api.html#sqlalchemy.orm.aliased.params.name
    "sqlalchemy.orm.aliased")参数：
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct
    is central for several use cases, including:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")结构对于多种用例至关重要，包括：'
- en: making use of subqueries with the ORM; the sections [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries) and [Joining to Subqueries](#orm-queryguide-join-subqueries)
    discuss this further.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用ORM的子查询；章节[从子查询中选择实体](#orm-queryguide-subqueries)和[与子查询连接](#orm-queryguide-join-subqueries)进一步讨论了这一点。
- en: Controlling the name of an entity in a result set; see [Selecting Multiple ORM
    Entities Simultaneously](#orm-queryguide-select-multiple-entities) for an example
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结果集中实体的名称；参见[同时选择多个ORM实体](#orm-queryguide-select-multiple-entities)以获取示例
- en: Joining to the same ORM entity multiple times; see [Using Relationship to join
    between aliased targets](#orm-queryguide-joining-relationships-aliased) for an
    example.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次连接到同一ORM实体；参见[使用关系在别名目标之间连接](#orm-queryguide-joining-relationships-aliased)以获取示例。
- en: '### Getting ORM Results from Textual Statements'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从文本语句中获取ORM结果'
- en: The ORM supports loading of entities from SELECT statements that come from other
    sources. The typical use case is that of a textual SELECT statement, which in
    SQLAlchemy is represented using the [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. A [`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct can be augmented with information
    about the ORM-mapped columns that the statement would load; this can then be associated
    with the ORM entity itself so that ORM objects can be loaded based on this statement.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对象关系映射（ORM）支持从其他来源的SELECT语句加载实体。典型用例是文本SELECT语句，在SQLAlchemy中使用[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")结构表示。[`text()`](../../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")结构可以附加有关语句将加载的ORM映射列的信息；然后可以将其与ORM实体本身关联，以便基于此语句加载ORM对象。
- en: 'Given a textual SQL statement we’d like to load from:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 给定要加载的文本SQL语句：
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can add column information to the statement by using the [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method; when this method is invoked,
    the [`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") object is converted into a [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object, which takes on a role that
    is comparable to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct. The [`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method is typically passed [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or equivalent, and in this case we can make
    use of the ORM-mapped attributes on the `User` class directly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法向语句添加列信息；当调用此方法时，[`TextClause`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")对象将转换为[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象，其承担的角色可与[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造类似。[`TextClause.columns()`](../../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns")方法通常传递[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象或等效对象，在这种情况下，我们可以直接使用`User`类上的ORM映射属性：
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We now have an ORM-configured SQL construct that as given, can load the “id”,
    “name” and “fullname” columns separately. To use this SELECT statement as a source
    of complete `User` entities instead, we can link these columns to a regular ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个经过ORM配置的SQL构造，可以分别加载“id”、“name”和“fullname”列。要将此SELECT语句用作完整`User`实体的来源，我们可以使用[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")方法将这些列链接到常规的ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中：
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The same [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object can also be converted into a
    subquery using the [`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") method, and linked to the
    `User` entity to it using the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, in a similar manner as discussed below in [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")对象也可以使用[`TextualSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery")方法转换为子查询，并使用[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造将其链接到`User`实体，方式与下面讨论的[从子查询中选择实体](#orm-queryguide-subqueries)类似：
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The difference between using the [`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") directly with [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") versus making use of `aliased()`
    is that in the former case, no subquery is produced in the resulting SQL. This
    can in some scenarios be advantageous from a performance or complexity perspective.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用[`TextualSelect`](../../core/selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect")与[`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")相比，使用`aliased()`的区别在于，在前一种情况下，生成的SQL中不会产生子查询。在某些情况下，这可能有利于性能或复杂性方面。
- en: '### Selecting Entities from Subqueries'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从子查询中选择实体'
- en: 'The [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct discussed in the previous section can be used with any `Subuqery` construct
    that comes from a method such as [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") to link ORM entities to the columns
    returned by that subquery; there must be a **column correspondence** relationship
    between the columns delivered by the subquery and the columns to which the entity
    is mapped, meaning, the subquery needs to be ultimately derived from those entities,
    such as in the example below:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节讨论的[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造中，可以与任何`Subuqery`构造一起使用，该构造来自诸如[`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery")之类的方法，以将ORM实体链接到该子查询返回的列；子查询返回的列与实体映射的列之间必须存在**列对应**关系，这意味着子查询最终需要源自这些实体，例如下面的示例：
- en: '[PRE82]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: See also
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Entity Subqueries/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM实体子查询/CTEs](../../tutorial/data_select.html#tutorial-subqueries-orm-aliased)
    - 在[SQLAlchemy统一教程](../../tutorial/index.html#unified-tutorial)中'
- en: '[Joining to Subqueries](#orm-queryguide-join-subqueries)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入子查询](#orm-queryguide-join-subqueries)'
- en: '### Selecting Entities from UNIONs and other set operations'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从UNION和其他集合操作中选择实体'
- en: 'The [`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union
    "sqlalchemy.sql.expression.union") and [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") functions are the most common set operations,
    which along with other set operations such as [`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_"), [`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") and others deliver an object known as a
    [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect"), which is composed of multiple [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs joined by a set-operation keyword.
    ORM entities may be selected from simple compound selects using the [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") method illustrated previously
    at [Getting ORM Results from Textual Statements](#orm-queryguide-selecting-text).
    In this method, the UNION statement is the complete statement that will be rendered,
    no additional criteria can be added after [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") is used:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[`union()`](../../core/selectable.html#sqlalchemy.sql.expression.union "sqlalchemy.sql.expression.union")
    和 [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 函数是最常见的集合操作，与其他集合操作（如 [`except_()`](../../core/selectable.html#sqlalchemy.sql.expression.except_
    "sqlalchemy.sql.expression.except_")、[`intersect()`](../../core/selectable.html#sqlalchemy.sql.expression.intersect
    "sqlalchemy.sql.expression.intersect") 等）一起，提供了一个称为 [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 的对象，它由多个通过集合操作关键字连接的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造组成。ORM 实体可以通过简单的复合选择使用 [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") 方法进行选择，该方法在 [从文本语句中获取 ORM 结果](#orm-queryguide-selecting-text)
    中已经说明。在这种方法中，UNION 语句是将被渲染的完整语句，不能在使用 [`Select.from_statement()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") 后添加额外的条件：'
- en: '[PRE83]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A [`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") construct can be more flexibly used
    within a query that can be further modified by organizing it into a subquery and
    linking it to an ORM entity using [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased"), as illustrated previously at [Selecting Entities from
    Subqueries](#orm-queryguide-subqueries). In the example below, we first use [`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery") to create a subquery of the
    UNION ALL statement, we then package that into the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct where it can be used like any other mapped
    entity in a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, including that we can add filtering
    and order by criteria based on its exported columns:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CompoundSelect`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect
    "sqlalchemy.sql.expression.CompoundSelect") 构造可以在更灵活的查询中更灵活地使用，该查询可以通过将其组织成子查询并使用
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") 将其链接到
    ORM 实体来进一步修改，如 [从子查询中选择实体](#orm-queryguide-subqueries) 中已说明。在下面的示例中，我们首先使用 [`CompoundSelect.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery
    "sqlalchemy.sql.expression.CompoundSelect.subquery") 创建 UNION ALL 语句的子查询，然后将其打包到
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") 构造中，在这里它可以像其他映射实体一样用于
    [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造中，包括我们可以根据其导出的列添加过滤和排序条件：'
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: See also
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting ORM Entities from Unions](../../tutorial/data_select.html#tutorial-orm-union)
    - in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[从 Union 中选择 ORM 实体](../../tutorial/data_select.html#tutorial-orm-union) -
    在 [SQLAlchemy 统一教程](../../tutorial/index.html#unified-tutorial) 中'
- en: '## Joins'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '## 连接'
- en: The [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods are used to construct SQL
    JOINs against a SELECT statement.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法用于构建针对 SELECT 语句的 SQL JOINs。'
- en: This section will detail ORM use cases for these methods. For a general overview
    of their use from a Core perspective, see [Explicit FROM clauses and JOINs](../../tutorial/data_select.html#tutorial-select-join)
    in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细介绍这些方法在 ORM 中的用例。有关从 Core 视角的使用的一般概述，请参阅[显式 FROM 子句和 JOINs](../../tutorial/data_select.html#tutorial-select-join)中的[SQLAlchemy
    统一教程](../../tutorial/index.html#unified-tutorial)。
- en: The usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") in an ORM context for [2.0 style](../../glossary.html#term-2.0-style)
    queries is mostly equivalent, minus legacy use cases, to the usage of the [`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method in [1.x style](../../glossary.html#term-1.x-style)
    queries.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 上下文中使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")进行[2.0 风格](../../glossary.html#term-2.0-style)查询的用法基本上等同于除了遗留用例之外，在[1.x
    风格](../../glossary.html#term-1.x-style)查询中使用[`Query.join()`](query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法的用法。
- en: '### Simple Relationship Joins'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '### 简单的关系连接'
- en: 'Consider a mapping between two classes `User` and `Address`, with a relationship
    `User.addresses` representing a collection of `Address` objects associated with
    each `User`. The most common usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to create a JOIN along this relationship,
    using the `User.addresses` attribute as an indicator for how this should occur:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个类`User`和`Address`之间的映射，其中关系`User.addresses`表示与每个`User`关联的`Address`对象的集合。[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")最常见的用法是沿着这种关系创建一个 JOIN，使用`User.addresses`属性作为指示器来指示应该如何发生这种情况：
- en: '[PRE85]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Where above, the call to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") along `User.addresses` will result in
    SQL approximately equivalent to:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，对[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和`User.addresses`的调用将导致大致等效的 SQL 语句：
- en: '[PRE86]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the above example we refer to `User.addresses` as passed to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") as the “on clause”, that is, it indicates
    how the “ON” portion of the JOIN should be constructed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将`User.addresses`称为传递给[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的“on clause”，即它指示如何构建 JOIN 的“ON”部分。
- en: Tip
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that using [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to JOIN from one entity to another affects
    the FROM clause of the SELECT statement, but not the columns clause; the SELECT
    statement in this example will continue to return rows from only the `User` entity.
    To SELECT columns / entities from both `User` and `Address` at the same time,
    the `Address` entity must also be named in the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, or added to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct afterwards using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. See the section [Selecting
    Multiple ORM Entities Simultaneously](#orm-queryguide-select-multiple-entities)
    for examples of both of these forms.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")从一个实体连接到另一个实体会影响SELECT语句的FROM子句，但不会影响列子句；在这个示例中，SELECT语句将继续仅返回`User`实体的行。要同时从`User`和`Address`中选择列/实体，必须在[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")函数中也命名`Address`实体，或者在使用[`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns")方法后将其添加到[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中。有关这两种形式的示例，请参阅[同时选择多个ORM实体](#orm-queryguide-select-multiple-entities)部分。
- en: Chaining Multiple Joins
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式多重连接
- en: 'To construct a chain of joins, multiple [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls may be used. The relationship-bound
    attribute implies both the left and right side of the join at once. Consider additional
    entities `Order` and `Item`, where the `User.orders` relationship refers to the
    `Order` entity, and the `Order.items` relationship refers to the `Item` entity,
    via an association table `order_items`. Two [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls will result in a JOIN first from
    `User` to `Order`, and a second from `Order` to `Item`. However, since `Order.items`
    is a [many to many](../basic_relationships.html#relationships-many-to-many) relationship,
    it results in two separate JOIN elements, for a total of three JOIN elements in
    the resulting SQL:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建连接链，可以使用多个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用。关联属性同时涵盖连接的左侧和右侧。考虑额外的实体`Order`和`Item`，其中`User.orders`关系指向`Order`实体，而`Order.items`关系指向`Item`实体，通过一个关联表`order_items`。两个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用将导致第一个JOIN从`User`到`Order`，第二个从`Order`到`Item`。然而，由于`Order.items`是[多对多](../basic_relationships.html#relationships-many-to-many)关系，它会导致两个独立的JOIN元素，总共有三个JOIN元素在结果SQL中：
- en: '[PRE87]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The order in which each call to the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is significant only to the degree
    that the “left” side of what we would like to join from needs to be present in
    the list of FROMs before we indicate a new target. [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would not, for example, know how to join
    correctly if we were to specify `select(User).join(Order.items).join(User.orders)`,
    and would raise an error. In correct practice, the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is invoked in such a way that
    lines up with how we would want the JOIN clauses in SQL to be rendered, and each
    call should represent a clear link from what precedes it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法的顺序只有在我们想要从中连接的“左”侧需要出现在FROM列表中时才重要，然后我们才能指示一个新的目标。例如，如果我们指定`select(User).join(Order.items).join(User.orders)`，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")就不会知道如何正确地进行连接，它会引发错误。在正确的实践中，应该以与我们希望在SQL中呈现JOIN子句相匹配的方式调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，并且每次调用都应该表示从前面的内容清晰链接。
- en: 'All of the elements that we target in the FROM clause remain available as potential
    points to continue joining FROM. We can continue to add other elements to join
    FROM the `User` entity above, for example adding on the `User.addresses` relationship
    to our chain of joins:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在FROM子句中定位的所有元素仍然可用作继续连接FROM的潜在点。例如，我们可以继续将其他元素添加到上述`User`实体的FROM连接中，例如在我们的连接链中添加`User.addresses`关系：
- en: '[PRE88]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Joins to a Target Entity
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到目标实体
- en: 'A second form of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") allows any mapped entity or core selectable
    construct as a target. In this usage, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") will attempt to **infer** the ON clause
    for the JOIN, using the natural foreign key relationship between two entities:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式的[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")允许将任何映射实体或核心可选择的构造作为目标。在此用法中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 将尝试**推断**JOIN的ON子句，使用两个实体之间的自然外键关系：
- en: '[PRE89]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the above calling form, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is called upon to infer the “on clause”
    automatically. This calling form will ultimately raise an error if either there
    are no [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") setup between the two mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs, or if there are multiple [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") linkages between them such that the
    appropriate constraint to use is ambiguous.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述调用形式中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 被调用以自动推断“on clause”。如果两个映射的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造之间没有设置任何[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，或者如果它们之间有多个[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")链接，使得要使用的适当约束不明确，此调用形式最终将引发错误。
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When making use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") without indicating an ON clause,
    ORM configured [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs are **not taken into account**. Only
    the configured [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") relationships between the entities at
    the level of the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects are consulted when an attempt is made to infer
    an ON clause for the JOIN.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")或[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")而不指定ON子句时，ORM配置的[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造**不会被考虑**。仅在尝试为JOIN推断ON子句时，才会在映射的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象级别上查阅配置的[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")关系。
- en: '### Joins to a Target with an ON Clause'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '### 到具有ON子句的目标的连接'
- en: 'The third calling form allows both the target entity as well as the ON clause
    to be passed explicitly. A example that includes a SQL expression as the ON clause
    is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种调用形式允许显式传递目标实体以及ON子句。包含SQL表达式作为ON子句的示例如下：
- en: '[PRE90]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The expression-based ON clause may also be a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, in the same way it’s used in [Simple
    Relationship Joins](#orm-queryguide-simple-relationship-join):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表达式的ON子句也可以是一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定属性，就像在[简单关系连接](#orm-queryguide-simple-relationship-join)中使用的方式一样：
- en: '[PRE91]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The above example seems redundant in that it indicates the target of `Address`
    in two different ways; however, the utility of this form becomes apparent when
    joining to aliased entities; see the section [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased) for an example.  ###
    Combining Relationship with Custom ON Criteria'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例似乎多余，因为它以两种不同的方式指示了`Address`的目标；然而，当加入到别名实体时，这种形式的实用性变得明显；请参见[使用关系连接别名目标](#orm-queryguide-joining-relationships-aliased)中的示例。###
    将关系与自定义ON条件结合使用
- en: 'The ON clause generated by the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct may be augmented with additional criteria.
    This is useful both for quick ways to limit the scope of a particular join over
    a relationship path, as well as for cases like configuring loader strategies such
    as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method accepts a series of SQL expressions
    positionally that will be joined to the ON clause of the JOIN via AND. For example
    if we wanted to JOIN from `User` to `Address` but also limit the ON criteria to
    only certain email addresses:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构造生成的ON子句可以通过附加的额外条件进行增强。这对于快速限制特定关系路径上连接范围的方式以及配置加载策略（如[`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）非常有用。[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")方法按位置接受一系列SQL表达式，这些表达式将通过AND连接到JOIN的ON子句。例如，如果我们想要从`User`
    JOIN到`Address`，但也限制ON条件仅适用于某些电子邮件地址：
- en: '[PRE92]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See also
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method also works with loader strategies
    such as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    See the section [Adding Criteria to loader options](relationships.html#loader-option-criteria).  ###
    Using Relationship to join between aliased targets'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")方法也适用于加载策略，如[`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")。请参见[向加载选项添加条件](relationships.html#loader-option-criteria)部分。###
    使用关系连接别名目标'
- en: 'When constructing joins using [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attributes to indicate the ON clause, the
    two-argument syntax illustrated in [Joins to a Target with an ON Clause](#queryguide-join-onclause)
    can be expanded to work with the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct, to indicate a SQL alias as the target of
    a join while still making use of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute to indicate the ON clause, as in
    the example below, where the `User` entity is joined twice to two different [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs against the `Address` entity:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")绑定属性构建连接以指示ON子句时，[使用带有ON子句的目标的连接](#queryguide-join-onclause)中说明的两参数语法可以扩展为与[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造一起使用，以指示SQL别名作为连接的目标，同时仍然利用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定属性来指示ON子句，如下例所示，其中`User`实体两次与两个不同的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造连接到`Address`实体：
- en: '[PRE93]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The same pattern may be expressed more succinctly using the modifier [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type"), which may be applied to the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, passing along the target entity
    in order to indicate the target in one step. The example below uses [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") to produce the same SQL statement as
    the one just illustrated:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的模式可以更简洁地使用修饰符 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 表达，该修饰符可以应用于 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 绑定的属性，传递目标实体以一步指示目标。下面的示例使用 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 来生成与刚刚示例相同的 SQL 语句：
- en: '[PRE94]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To make use of a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to construct a join **from** an aliased entity,
    the attribute is available from the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct directly:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用一个 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 来构建一个从别名实体连接的连接，该属性直接从 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造中可用：
- en: '[PRE95]  ### Joining to Subqueries'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE95]  ### 连接到子查询'
- en: 'The target of a join may be any “selectable” entity which includes subuqeries.
    When using the ORM, it is typical that these targets are stated in terms of an
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct,
    but this is not strictly required, particularly if the joined entity is not being
    returned in the results. For example, to join from the `User` entity to the `Address`
    entity, where the `Address` entity is represented as a row limited subquery, we
    first construct a [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object using [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery"), which may then be used as the target
    of the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的目标可以是任何可选择的实体，包括子查询。在使用 ORM 时，通常会以 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造来表示这些目标，但这并不是严格要求的，特别是如果连接的实体不会在结果中返回时。例如，要从 `User`
    实体连接到 `Address` 实体，在这里 `Address` 实体被表示为一行限制的子查询，我们首先使用 [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") 构造一个 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象，然后可以将其用作 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法的目标：
- en: '[PRE96]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The above SELECT statement when invoked via [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will return rows that contain `User` entities,
    but not `Address` entities. In order to include `Address` entities to the set
    of entities that would be returned in result sets, we construct an [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object against the `Address` entity and [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object. We also may wish to apply a name
    to the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, such as `"address"` used below, so that we can refer to it by name
    in the result row:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 SELECT 语句在通过 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用时将返回包含 `User` 实体的行，但不包含 `Address` 实体。为了将 `Address`
    实体包含到将在结果集中返回的实体集合中，我们构造了一个针对 `Address` 实体和 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象的 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 对象。我们还可以希望对 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造应用一个名称，例如下面使用的 `"address"`，这样我们就可以在结果行中通过名称引用它：
- en: '[PRE97]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Joining to Subqueries along Relationship paths
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沿关系路径连接到子查询
- en: 'The subquery form illustrated in the previous section may be expressed with
    more specificity using a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute using one of the forms indicated
    at [Using Relationship to join between aliased targets](#orm-queryguide-joining-relationships-aliased).
    For example, to create the same join while ensuring the join is along that of
    a particular [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), we may use the [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method, passing the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct containing the [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object that’s the target of the join:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中示例的子查询形式可以使用更具体的方式来表达，使用一个[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定的属性，使用[使用关系在别名目标之间进行连接](#orm-queryguide-joining-relationships-aliased)中指示的形式之一。例如，要创建相同的连接，并确保连接沿着特定[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")进行，我们可以使用[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法，传递包含要连接的[`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")对象的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造：
- en: '[PRE98]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Subqueries that Refer to Multiple Entities
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用多个实体的子查询
- en: A subquery that contains columns spanning more than one ORM entity may be applied
    to more than one [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct at once, and used in the same [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in terms of each entity separately.
    The rendered SQL will continue to treat all such [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs as the same subquery, however from the ORM
    / Python perspective the different return values and object attributes can be
    referenced by using the appropriate [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 包含跨越多个ORM实体的列的子查询可以同时应用于多个[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，并在相同的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中按照每个实体分别处理。然而，生成的SQL仍将所有这些[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造视为相同的子查询，但是从ORM / Python的角度来看，可以使用适当的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造来引用不同的返回值和对象属性。
- en: 'Given for example a subquery that refers to both `User` and `Address`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个同时引用`User`和`Address`的子查询：
- en: '[PRE99]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can create [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    constructs against both `User` and `Address` that each refer to the same object:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对`User`和`Address`分别创建[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，它们各自指向相同的对象：
- en: '[PRE100]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct selecting from both entities will render the subquery once, but in a
    result-row context can return objects of both `User` and `Address` classes at
    the same time:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个实体中进行选择的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造将会渲染子查询一次，但在结果行上下文中可以同时返回`User`和`Address`类的对象：
- en: '[PRE101]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '### Setting the leftmost FROM clause in a join'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置连接中最左侧的FROM子句'
- en: 'In cases where the left side of the current state of [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") is not in line with what we want to join from,
    the [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method may be used:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")状态的左侧与我们想要连接的内容不符合的情况下，可以使用[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法：
- en: '[PRE102]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method accepts two or three arguments,
    either in the form `(<join from>, <onclause>)`, or `(<join from>, <join to>, [<onclause>])`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法接受两个或三个参数，可以是`(<join from>, <onclause>)`形式，也可以是`(<join
    from>, <join to>, [<onclause>])`形式：'
- en: '[PRE103]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To set up the initial FROM clause for a SELECT such that [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") can be used subsequent, the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method may also be used:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置初始的 FROM 子句，以便之后可以使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，可以使用 [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 方法：
- en: '[PRE104]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Tip
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method does not actually have
    the final say on the order of tables in the FROM clause. If the statement also
    refers to a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct that refers to existing tables in
    a different order, the [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct takes precedence. When we use methods
    like [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from"), these methods are ultimately creating
    such a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    object. Therefore we can see the contents of [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") being overridden in a case like
    this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 方法实际上并不决定 FROM 子句中表的顺序。如果语句还引用了指向不同顺序的现有表的
    [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    结构，那么 [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    结构将优先。当我们使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 等方法时，这些方法最终创建了这样一个 [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") 对象。因此，在这种情况下，我们可以看到 [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 的内容被覆盖了：'
- en: '[PRE105]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Where above, we see that the FROM clause is `address JOIN user_account`, even
    though we stated `select_from(User)` first. Because of the `.join(Address.user)`
    method call, the statement is ultimately equivalent to the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们看到 FROM 子句是 `address JOIN user_account`，尽管我们首先声明了 `select_from(User)`。由于
    `.join(Address.user)` 方法调用，该语句最终等同于以下内容：
- en: '[PRE106]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    construct above is added as another entry in the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") list which supersedes the previous
    entry.  ### Simple Relationship Joins'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '上述的 [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    结构被添加为 [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") 列表中的另一个条目，它取代了先前的条目。 ### 简单的关系连接'
- en: 'Consider a mapping between two classes `User` and `Address`, with a relationship
    `User.addresses` representing a collection of `Address` objects associated with
    each `User`. The most common usage of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is to create a JOIN along this relationship,
    using the `User.addresses` attribute as an indicator for how this should occur:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个类 `User` 和 `Address` 之间的映射，其中关系 `User.addresses` 表示与每个 `User` 关联的 `Address`
    对象的集合。[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 的最常见用法是沿着这种关系创建 JOIN，使用 `User.addresses`
    属性作为指示器指示应该如何进行连接：
- en: '[PRE107]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Where above, the call to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") along `User.addresses` will result in
    SQL approximately equivalent to:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，对 `User.addresses` 使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 的调用将导致大致等效于以下 SQL：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In the above example we refer to `User.addresses` as passed to [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") as the “on clause”, that is, it indicates
    how the “ON” portion of the JOIN should be constructed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们将`User.addresses`称为传递给[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的“on clause”，即指示如何构建JOIN的“ON”部分。
- en: Tip
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that using [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to JOIN from one entity to another affects
    the FROM clause of the SELECT statement, but not the columns clause; the SELECT
    statement in this example will continue to return rows from only the `User` entity.
    To SELECT columns / entities from both `User` and `Address` at the same time,
    the `Address` entity must also be named in the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function, or added to the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct afterwards using the [`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns") method. See the section [Selecting
    Multiple ORM Entities Simultaneously](#orm-queryguide-select-multiple-entities)
    for examples of both of these forms.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")从一个实体JOIN到另一个实体会影响SELECT语句的FROM子句，但不影响列子句；在这个示例中，SELECT语句仍将只返回来自`User`实体的行。要同时从`User`和`Address`中SELECT列/实体，必须在[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")函数中也命名`Address`实体，或者使用[`Select.add_columns()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.add_columns
    "sqlalchemy.sql.expression.Select.add_columns")方法在之后将其添加到[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中。有关这两种形式的示例，请参见[同时选择多个ORM实体](#orm-queryguide-select-multiple-entities)部分。
- en: Chaining Multiple Joins
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接多个表
- en: 'To construct a chain of joins, multiple [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls may be used. The relationship-bound
    attribute implies both the left and right side of the join at once. Consider additional
    entities `Order` and `Item`, where the `User.orders` relationship refers to the
    `Order` entity, and the `Order.items` relationship refers to the `Item` entity,
    via an association table `order_items`. Two [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") calls will result in a JOIN first from
    `User` to `Order`, and a second from `Order` to `Item`. However, since `Order.items`
    is a [many to many](../basic_relationships.html#relationships-many-to-many) relationship,
    it results in two separate JOIN elements, for a total of three JOIN elements in
    the resulting SQL:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一系列JOIN，可以使用多个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用。关系绑定属性同时暗示JOIN的左侧和右侧。考虑额外的实体`Order`和`Item`，其中`User.orders`关系指向`Order`实体，而`Order.items`关系通过关联表`order_items`指向`Item`实体。两个[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")调用将导致从`User`到`Order`的第一个JOIN，以及从`Order`到`Item`的第二个JOIN。然而，由于`Order.items`是[多对多](../basic_relationships.html#relationships-many-to-many)关系，它会导致两个独立的JOIN元素，总共在生成的SQL中有三个JOIN元素：
- en: '[PRE109]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The order in which each call to the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is significant only to the degree
    that the “left” side of what we would like to join from needs to be present in
    the list of FROMs before we indicate a new target. [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would not, for example, know how to join
    correctly if we were to specify `select(User).join(Order.items).join(User.orders)`,
    and would raise an error. In correct practice, the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method is invoked in such a way that
    lines up with how we would want the JOIN clauses in SQL to be rendered, and each
    call should represent a clear link from what precedes it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法的顺序只有在我们希望连接的“左”侧需要在FROM列表中存在之前才会产生影响。例如，如果我们指定了`select(User).join(Order.items).join(User.orders)`，那么[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")将无法正确连接，并且会引发错误。在正确的实践中，应以类似于SQL中JOIN子句应该呈现的方式调用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，并且每次调用应该代表与其前面的内容之间的清晰链接。
- en: 'All of the elements that we target in the FROM clause remain available as potential
    points to continue joining FROM. We can continue to add other elements to join
    FROM the `User` entity above, for example adding on the `User.addresses` relationship
    to our chain of joins:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在FROM子句中定位的所有元素仍然可以作为继续连接FROM的潜在点。例如，我们可以在上面的`User`实体上继续添加其他元素以连接FROM，例如在我们的连接链中添加`User.addresses`关系：
- en: '[PRE110]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Joins to a Target Entity
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到目标实体
- en: 'A second form of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") allows any mapped entity or core selectable
    construct as a target. In this usage, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") will attempt to **infer** the ON clause
    for the JOIN, using the natural foreign key relationship between two entities:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")的第二种形式允许任何映射实体或核心可选择的构造作为目标。在这种用法中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")将尝试**推断**连接的ON子句，使用两个实体之间的自然外键关系：'
- en: '[PRE111]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In the above calling form, [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") is called upon to infer the “on clause”
    automatically. This calling form will ultimately raise an error if either there
    are no [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") setup between the two mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs, or if there are multiple [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") linkages between them such that the
    appropriate constraint to use is ambiguous.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述调用形式中，[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")被调用来自动推断“on子句”。如果两个映射的[`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造之间没有设置任何[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，或者如果它们之间存在多个[`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")链接，使得要使用的适当约束不明确，这种调用形式最终将引发错误。
- en: Note
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When making use of [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") without indicating an ON clause,
    ORM configured [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs are **not taken into account**. Only
    the configured [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") relationships between the entities at
    the level of the mapped [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects are consulted when an attempt is made to infer
    an ON clause for the JOIN.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 或 [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 而没有指定 ON 子句时，ORM 配置的 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构建**不会考虑**。只有在尝试推断 JOIN 的 ON 子句时，才会查询映射的 [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象级别的实体之间配置的 [`ForeignKeyConstraint`](../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 关系。
- en: '### Joins to a Target with an ON Clause'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '### 加入带有 ON 子句的目标'
- en: 'The third calling form allows both the target entity as well as the ON clause
    to be passed explicitly. A example that includes a SQL expression as the ON clause
    is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种调用形式允许同时显式传递目标实体和 ON 子句。一个包含 SQL 表达式作为 ON 子句的示例如下：
- en: '[PRE112]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The expression-based ON clause may also be a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, in the same way it’s used in [Simple
    Relationship Joins](#orm-queryguide-simple-relationship-join):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式基于的 ON 子句也可以是 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 绑定的属性，就像在 [简单 Relationship 加入](#orm-queryguide-simple-relationship-join)
    中使用的方式一样：
- en: '[PRE113]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The above example seems redundant in that it indicates the target of `Address`
    in two different ways; however, the utility of this form becomes apparent when
    joining to aliased entities; see the section [Using Relationship to join between
    aliased targets](#orm-queryguide-joining-relationships-aliased) for an example.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例似乎冗余，因为它以两种不同的方式指示了 `Address` 的目标；然而，当加入别名实体时，这种形式的实用性就变得明显了；请参见 [使用 Relationship
    在别名目标之间加入](#orm-queryguide-joining-relationships-aliased) 部分的示例。
- en: '### Combining Relationship with Custom ON Criteria'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将 Relationship 与自定义 ON 条件相结合'
- en: 'The ON clause generated by the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct may be augmented with additional criteria.
    This is useful both for quick ways to limit the scope of a particular join over
    a relationship path, as well as for cases like configuring loader strategies such
    as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method accepts a series of SQL expressions
    positionally that will be joined to the ON clause of the JOIN via AND. For example
    if we wanted to JOIN from `User` to `Address` but also limit the ON criteria to
    only certain email addresses:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    构建生成的 ON 子句可以通过附加的条件进行增强。这对于快速限制特定关系路径上连接的范围的方法以及配置加载器策略（例如 [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）等情况都很有用。[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") 方法接受一系列 SQL 表达式，这些表达式将通过 AND 连接到 JOIN 的
    ON 子句中。例如，如果我们想要从 `User` 加入到 `Address`，但也只限制 ON 条件到某些电子邮件地址：'
- en: '[PRE114]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: See also
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: The [`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_") method also works with loader strategies
    such as [`joinedload()`](relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload").
    See the section [Adding Criteria to loader options](relationships.html#loader-option-criteria).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.and_()`](../internals.html#sqlalchemy.orm.PropComparator.and_
    "sqlalchemy.orm.PropComparator.and_")方法也适用于加载策略，如[`joinedload()`](relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")和[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")。参见[向加载选项添加条件](relationships.html#loader-option-criteria)一节。'
- en: '### Using Relationship to join between aliased targets'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用关系连接别名目标'
- en: 'When constructing joins using [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attributes to indicate the ON clause, the
    two-argument syntax illustrated in [Joins to a Target with an ON Clause](#queryguide-join-onclause)
    can be expanded to work with the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct, to indicate a SQL alias as the target of
    a join while still making use of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute to indicate the ON clause, as in
    the example below, where the `User` entity is joined twice to two different [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs against the `Address` entity:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")绑定的属性来指示ON子句构建连接时，可以将[具有ON子句的目标的连接](#queryguide-join-onclause)中示例的二参数语法扩展到与[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造一起工作，以指示SQL别名作为连接的目标，同时仍然利用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定的属性来指示ON子句，如下例所示，其中`User`实体两次与两个不同的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造连接到`Address`实体：
- en: '[PRE115]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The same pattern may be expressed more succinctly using the modifier [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type"), which may be applied to the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute, passing along the target entity
    in order to indicate the target in one step. The example below uses [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") to produce the same SQL statement as
    the one just illustrated:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修饰符[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")可以更简洁地表达相同的模式，该修饰符可以应用于[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定的属性，通过传递目标实体以一步指示目标。下面的示例使用[`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")来生成与刚刚示例相同的SQL语句：
- en: '[PRE116]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To make use of a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to construct a join **from** an aliased entity,
    the attribute is available from the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct directly:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构建从别名实体的连接，可以直接从[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造中使用属性：
- en: '[PRE117]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '### Joining to Subqueries'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '### 连接到子查询'
- en: 'The target of a join may be any “selectable” entity which includes subuqeries.
    When using the ORM, it is typical that these targets are stated in terms of an
    [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased") construct,
    but this is not strictly required, particularly if the joined entity is not being
    returned in the results. For example, to join from the `User` entity to the `Address`
    entity, where the `Address` entity is represented as a row limited subquery, we
    first construct a [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object using [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery"), which may then be used as the target
    of the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 加入的目标可以是任何“可选择”的实体，包括子查询。在使用 ORM 时，通常会使用 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造来表示这些目标，但这不是严格要求的，特别是如果加入的实体不会在结果中返回的情况下。例如，要从 `User`
    实体加入到 `Address` 实体，其中 `Address` 实体被表示为一行限制的子查询，我们首先使用 [`Select.subquery()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.subquery
    "sqlalchemy.sql.expression.Select.subquery") 构造一个 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象，然后可以将其用作 [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法的目标：
- en: '[PRE118]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The above SELECT statement when invoked via [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will return rows that contain `User` entities,
    but not `Address` entities. In order to include `Address` entities to the set
    of entities that would be returned in result sets, we construct an [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object against the `Address` entity and [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object. We also may wish to apply a name
    to the [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct, such as `"address"` used below, so that we can refer to it by name
    in the result row:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 SELECT 语句在通过 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用时将返回包含 `User` 实体但不包含 `Address` 实体的行。为了将 `Address`
    实体包含到将在结果集中返回的实体集中，我们针对 `Address` 实体和 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象构造了一个 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 对象。我们可能还希望对 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造应用一个名称，例如下面使用的 `"address"`，以便我们可以通过名称在结果行中引用它：
- en: '[PRE119]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Joining to Subqueries along Relationship paths
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沿着关系路径加入子查询
- en: 'The subquery form illustrated in the previous section may be expressed with
    more specificity using a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute using one of the forms indicated
    at [Using Relationship to join between aliased targets](#orm-queryguide-joining-relationships-aliased).
    For example, to create the same join while ensuring the join is along that of
    a particular [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), we may use the [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method, passing the [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct containing the [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object that’s the target of the join:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 前面部分中示例的子查询形式可以使用一个 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 绑定属性更具体地表示，使用 [使用 Relationship 在别名目标之间加入](#orm-queryguide-joining-relationships-aliased)
    中指示的其中一种形式。例如，为了创建相同的加入并确保加入是沿着特定 [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 进行的，我们可以使用 [`PropComparator.of_type()`](../internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 方法，传递包含加入目标的 [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 构造的 [`Subquery`](../../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 对象：
- en: '[PRE120]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Subqueries that Refer to Multiple Entities
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用多个实体的子查询
- en: A subquery that contains columns spanning more than one ORM entity may be applied
    to more than one [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct at once, and used in the same [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in terms of each entity separately.
    The rendered SQL will continue to treat all such [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs as the same subquery, however from the ORM
    / Python perspective the different return values and object attributes can be
    referenced by using the appropriate [`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 包含跨越多个ORM实体的列的子查询可以同时应用于多个[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，并且在每个实体的情况下都可以在相同的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造中使用。生成的SQL将继续将所有这样的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造视为相同的子查询，但是从ORM / Python的角度来看，可以通过使用适当的[`aliased()`](api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造来引用不同的返回值和对象属性。
- en: 'Given for example a subquery that refers to both `User` and `Address`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个同时引用`User`和`Address`的子查询，例如：
- en: '[PRE121]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can create [`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    constructs against both `User` and `Address` that each refer to the same object:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建针对`User`和`Address`的[`aliased()`](api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造，它们各自都引用相同的对象：
- en: '[PRE122]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'A [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct selecting from both entities will render the subquery once, but in a
    result-row context can return objects of both `User` and `Address` classes at
    the same time:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个实体中选择的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造将只渲染子查询一次，但在结果行上下文中可以同时返回`User`和`Address`类的对象：
- en: '[PRE123]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '### Setting the leftmost FROM clause in a join'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置连接中最左边的FROM子句'
- en: 'In cases where the left side of the current state of [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") is not in line with what we want to join from,
    the [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method may be used:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")状态的左侧与我们要连接的内容不一致的情况下，可以使用[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法：
- en: '[PRE124]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method accepts two or three arguments,
    either in the form `(<join from>, <onclause>)`, or `(<join from>, <join to>, [<onclause>])`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法接受两个或三个参数，形式可以是`(<join from>, <onclause>)`，或者是`(<join
    from>, <join to>, [<onclause>])`：'
- en: '[PRE125]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To set up the initial FROM clause for a SELECT such that [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") can be used subsequent, the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method may also be used:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为SELECT设置初始FROM子句，以便之后可以使用[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，也可以使用[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")方法：
- en: '[PRE126]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Tip
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") method does not actually have
    the final say on the order of tables in the FROM clause. If the statement also
    refers to a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct that refers to existing tables in
    a different order, the [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct takes precedence. When we use methods
    like [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from"), these methods are ultimately creating
    such a [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    object. Therefore we can see the contents of [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") being overridden in a case like
    this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")方法实际上并没有最终决定FROM子句中表的顺序。如果语句还引用了一个[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")构造，该构造引用了不同顺序的现有表，则[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")构造优先。当我们使用像[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")这样的方法时，这些方法最终会创建这样一个[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象。因此，在这种情况下，我们可以看到[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")的内容被覆盖：'
- en: '[PRE127]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Where above, we see that the FROM clause is `address JOIN user_account`, even
    though we stated `select_from(User)` first. Because of the `.join(Address.user)`
    method call, the statement is ultimately equivalent to the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，我们看到FROM子句是`address JOIN user_account`，尽管我们首先声明了`select_from(User)`。由于`.join(Address.user)`方法调用，语句最终等效于以下内容：
- en: '[PRE128]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The [`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    construct above is added as another entry in the [`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from") list which supersedes the previous
    entry.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Join`](../../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")构造是作为[`Select.select_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")列表中的另一个条目添加的，它取代了先前的条目。
- en: '## Relationship WHERE Operators'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '## 关系 WHERE 运算符'
- en: Besides the use of [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs within the [`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods, [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") also plays a role in helping to construct SQL expressions
    that are typically for use in the WHERE clause, using the [`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[`Select.join()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法中使用[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造之外，[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")还在帮助构造通常用于WHERE子句的SQL表达式，使用[`Select.where()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where")方法。
- en: '### EXISTS forms: has() / any()'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '### EXISTS 形式：has() / any()'
- en: The [`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")
    construct was first introduced in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)
    in the section [EXISTS subqueries](../../tutorial/data_select.html#tutorial-exists).
    This object is used to render the SQL EXISTS keyword in conjunction with a scalar
    subquery. The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct provides for some helper methods that
    may be used to generate some common EXISTS styles of queries in terms of the relationship.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")构造首次在[SQLAlchemy统一教程](../../tutorial/index.html#unified-tutorial)的[EXISTS子查询](../../tutorial/data_select.html#tutorial-exists)部分中介绍。该对象用于在标量子查询与SQL
    EXISTS关键字一起呈现。[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造提供了一些辅助方法，可以用于以关系的方式生成一些常见的EXISTS风格的查询。'
- en: 'For a one-to-many relationship such as `User.addresses`, an EXISTS against
    the `address` table that correlates back to the `user_account` table can be produced
    using [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"). This method accepts an optional WHERE criteria
    to limit the rows matched by the subquery:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`User.addresses`这样的一对多关系，可以使用[`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")针对与`user_account`表相关联的`address`表进行EXISTS查询。此方法接受一个可选的WHERE条件来限制子查询匹配的行：
- en: '[PRE129]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'As EXISTS tends to be more efficient for negative lookups, a common query is
    to locate entities where there are no related entities present. This is succinct
    using a phrase such as `~User.addresses.any()`, to select for `User` entities
    that have no related `Address` rows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于EXISTS倾向于更有效地进行负查找，一个常见的查询是定位没有相关实体的实体。这可以简洁地使用短语`~User.addresses.any()`来实现，以选择没有相关`Address`行的`User`实体：
- en: '[PRE130]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The [`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has") method works in mostly the same way as [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"), except that it’s used for many-to-one relationships,
    such as if we wanted to locate all `Address` objects which belonged to “sandy”:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has")方法的工作方式与[`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")基本相同，只是它用于一对多关系，例如，如果我们想要定位所有属于“sandy”的`Address`对象：'
- en: '[PRE131]  ### Relationship Instance Comparison Operators'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE131]  ### 关系实例比较运算符'
- en: The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute also offers a few SQL construction
    implementations that are geared towards filtering a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute in terms of a specific instance
    of a related object, which can unpack the appropriate attribute values from a
    given [persistent](../../glossary.html#term-persistent) (or less commonly a [detached](../../glossary.html#term-detached))
    object instance and construct WHERE criteria in terms of the target [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")-绑定的属性还提供了一些SQL构造实现，这些实现旨在根据相关对象的特定实例来过滤[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-绑定的属性，它可以从给定的[持久](../../glossary.html#term-persistent)（或较少见的[分离](../../glossary.html#term-detached)）对象实例中解包适当的属性值，并构造WHERE条件，以便针对目标[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。'
- en: '**many to one equals comparison** - a specific object instance can be compared
    to many-to-one relationship, to select rows where the foreign key of the target
    entity matches the primary key value of the object given:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多等于比较** - 可以将特定对象实例与一对多关系进行比较，以选择外键与给定对象的主键值匹配的行：'
- en: '[PRE132]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '**many to one not equals comparison** - the not equals operator may also be
    used:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多不等于比较** - 也可以使用不等于运算符：'
- en: '[PRE133]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '**object is contained in a one-to-many collection** - this is essentially the
    one-to-many version of the “equals” comparison, select rows where the primary
    key equals the value of the foreign key in a related object:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象包含在一对多集合中** - 这基本上是“等于”比较的一对多版本，选择主键等于相关对象中的外键值的行：'
- en: '[PRE134]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '**An object has a particular parent from a one-to-many perspective** - the
    [`with_parent()`](api.html#sqlalchemy.orm.with_parent "sqlalchemy.orm.with_parent")
    function produces a comparison that returns rows which are referenced by a given
    parent, this is essentially the same as using the `==` operator with the many-to-one
    side:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从一对多的角度来看，对象有一个特定的父对象** - [`with_parent()`](api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent")函数生成一个比较，返回被给定父对象引用的行，这本质上与使用一对多方的`==`运算符相同：'
- en: '[PRE135]  ### EXISTS forms: has() / any()'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE135]  ### EXISTS forms: has() / any()'
- en: The [`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")
    construct was first introduced in the [SQLAlchemy Unified Tutorial](../../tutorial/index.html#unified-tutorial)
    in the section [EXISTS subqueries](../../tutorial/data_select.html#tutorial-exists).
    This object is used to render the SQL EXISTS keyword in conjunction with a scalar
    subquery. The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct provides for some helper methods that
    may be used to generate some common EXISTS styles of queries in terms of the relationship.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Exists`](../../core/selectable.html#sqlalchemy.sql.expression.Exists "sqlalchemy.sql.expression.Exists")构造首次在[SQLAlchemy
    统一教程](../../tutorial/index.html#unified-tutorial)中的[EXISTS 子查询](../../tutorial/data_select.html#tutorial-exists)一节中引入。该对象用于在标量子查询与
    SQL EXISTS 关键字一起渲染。[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造提供了一些辅助方法，可以用于根据关系生成一些常见的 EXISTS 风格的查询。'
- en: 'For a one-to-many relationship such as `User.addresses`, an EXISTS against
    the `address` table that correlates back to the `user_account` table can be produced
    using [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"). This method accepts an optional WHERE criteria
    to limit the rows matched by the subquery:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`User.addresses`这样的一对多关系，可以使用与`user_account`表关联的`address`表的 EXISTS 来生成 [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")。此方法接受一个可选的 WHERE 条件来限制子查询匹配的行：
- en: '[PRE136]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'As EXISTS tends to be more efficient for negative lookups, a common query is
    to locate entities where there are no related entities present. This is succinct
    using a phrase such as `~User.addresses.any()`, to select for `User` entities
    that have no related `Address` rows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EXISTS 倾向于对负查询更有效，一个常见的查询是定位那些不存在相关实体的实体。这可以用如`~User.addresses.any()`这样的短语来简洁地实现，以选择没有相关`Address`行的`User`实体：
- en: '[PRE137]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The [`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has") method works in mostly the same way as [`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any"), except that it’s used for many-to-one relationships,
    such as if we wanted to locate all `Address` objects which belonged to “sandy”:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.has()`](../internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has")方法的工作方式基本与[`PropComparator.any()`](../internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")相同，只是它用于多对一的关系，比如我们想要定位所有属于“sandy”的`Address`对象：'
- en: '[PRE138]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '### Relationship Instance Comparison Operators'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '### Relationship Instance Comparison Operators'
- en: The [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute also offers a few SQL construction
    implementations that are geared towards filtering a [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")-bound attribute in terms of a specific instance
    of a related object, which can unpack the appropriate attribute values from a
    given [persistent](../../glossary.html#term-persistent) (or less commonly a [detached](../../glossary.html#term-detached))
    object instance and construct WHERE criteria in terms of the target [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")绑定属性还提供了一些
    SQL 构建实现，用于基于特定相关对象的实例来过滤[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")绑定属性，这可以从给定的[持久](../../glossary.html#term-persistent)（或更少见的[分离](../../glossary.html#term-detached)）对象实例中解包适当的属性值，并根据目标[`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造 WHERE 条件。'
- en: '**many to one equals comparison** - a specific object instance can be compared
    to many-to-one relationship, to select rows where the foreign key of the target
    entity matches the primary key value of the object given:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一等于比较** - 一个特定的对象实例可以与多对一关系进行比较，以选择外键与目标实体的主键值匹配的行：'
- en: '[PRE139]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '**many to one not equals comparison** - the not equals operator may also be
    used:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对一不等于比较** - 也可以使用不等于运算符：'
- en: '[PRE140]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '**object is contained in a one-to-many collection** - this is essentially the
    one-to-many version of the “equals” comparison, select rows where the primary
    key equals the value of the foreign key in a related object:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象包含在一对多集合中** - 这基本上是“等于”比较的一对多版本，选择主键等于相关对象中外键值的行：'
- en: '[PRE141]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '**An object has a particular parent from a one-to-many perspective** - the
    [`with_parent()`](api.html#sqlalchemy.orm.with_parent "sqlalchemy.orm.with_parent")
    function produces a comparison that returns rows which are referenced by a given
    parent, this is essentially the same as using the `==` operator with the many-to-one
    side:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从一对多的角度看，对象有一个特定的父对象** - [`with_parent()`](api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") 函数生成一个比较，返回由给定父对象引用的行，这与使用`==`运算符与多对一方面基本相同：'
- en: '[PRE142]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
