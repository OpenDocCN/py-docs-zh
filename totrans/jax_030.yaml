- en: Pytrees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/pytrees.html`](https://jax.readthedocs.io/en/latest/pytrees.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## What is a pytree?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JAX, we use the term *pytree* to refer to a tree-like structure built out
    of container-like Python objects. Classes are considered container-like if they
    are in the pytree registry, which by default includes lists, tuples, and dicts.
    That is:'
  prefs: []
  type: TYPE_NORMAL
- en: any object whose type is *not* in the pytree container registry is considered
    a *leaf* pytree;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: any object whose type is in the pytree container registry, and which contains
    pytrees, is considered a pytree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each entry in the pytree container registry, a container-like type is registered
    with a pair of functions that specify how to convert an instance of the container
    type to a `(children, metadata)` pair and how to convert such a pair back to an
    instance of the container type. Using these functions, JAX can canonicalize any
    tree of registered container objects into tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pytrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JAX can be extended to consider other container types as pytrees; see Extending
    pytrees below.
  prefs: []
  type: TYPE_NORMAL
- en: Pytrees and JAX functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many JAX functions, like `jax.lax.scan()`, operate over pytrees of arrays. JAX
    function transformations can be applied to functions that accept as input and
    produce as output pytrees of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Applying optional parameters to pytrees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some JAX function transformations take optional parameters that specify how
    certain input or output values should be treated (e.g. the `in_axes` and `out_axes`
    arguments to `vmap()`). These parameters can also be pytrees, and their structure
    must correspond to the pytree structure of the corresponding arguments. In particular,
    to be able to “match up” leaves in these parameter pytrees with values in the
    argument pytrees, the parameter pytrees are often constrained to be tree prefixes
    of the argument pytrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we pass the following input to `vmap()` (note that the input
    arguments to a function are considered a tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following `in_axes` pytree to specify that only the `k2` argument
    is mapped (`axis=0`) and the rest aren’t mapped over (`axis=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional parameter pytree structure must match that of the main input pytree.
    However, the optional parameters can optionally be specified as a “prefix” pytree,
    meaning that a single leaf value can be applied to an entire sub-pytree. For example,
    if we have the same `vmap()` input as above, but wish to only map over the dictionary
    argument, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want every argument to be mapped, we can simply write a single leaf
    value that is applied over the entire argument tuple pytree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This happens to be the default `in_axes` value for `vmap()`!
  prefs: []
  type: TYPE_NORMAL
- en: The same logic applies to other optional parameters that refer to specific input
    or output values of a transformed function, e.g. `vmap`’s `out_axes`.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the pytree definition of an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view the pytree definition of an arbitrary `object` for debugging purposes,
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Developer information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This is primarily JAX internal documentation, end-users are not supposed to
    need to understand this to use JAX, except when registering new user-defined container
    types with JAX. Some of these details may change.*'
  prefs: []
  type: TYPE_NORMAL
- en: Internal pytree handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JAX flattens pytrees into lists of leaves at the `api.py` boundary (and also
    in control flow primitives). This keeps downstream JAX internals simpler: transformations
    like `grad()`, `jit()`, and `vmap()` can handle user functions that accept and
    return the myriad different Python containers, while all the other parts of the
    system can operate on functions that only take (multiple) array arguments and
    always return a flat list of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: When JAX flattens a pytree it will produce a list of leaves and a `treedef`
    object that encodes the structure of the original value. The `treedef` can then
    be used to construct a matching structured value after transforming the leaves.
    Pytrees are tree-like, rather than DAG-like or graph-like, in that we handle them
    assuming referential transparency and that they can’t contain reference cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, pytree containers can be lists, tuples, dicts, namedtuple, None,
    OrderedDict. Other types of values, including numeric and ndarray values, are
    treated as leaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '### Extending pytrees'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, any part of a structured value that is not recognized as an internal
    pytree node (i.e. container-like) is treated as a leaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The set of Python types that are considered internal pytree nodes is extensible,
    through a global registry of types, and values of registered types are traversed
    recursively. To register a new type, you can use `register_pytree_node()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can define appropriate `tree_flatten` and `tree_unflatten`
    methods on your class and decorate it with `register_pytree_node_class()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When defining unflattening functions, in general `children` should contain all
    the dynamic elements of the data structure (arrays, dynamic scalars, and pytrees),
    while `aux_data` should contain all the static elements that will be rolled into
    the `treedef` structure. JAX sometimes needs to compare `treedef` for equality,
    or compute its hash for use in the JIT cache, and so care must be taken to ensure
    that the auxiliary data specified in the flattening recipe supports meaningful
    hashing and equality comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: The whole set of functions for operating on pytrees are in `jax.tree_util`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom PyTrees and Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common gotcha with user-defined PyTree objects is that JAX transformations
    occasionally initialize them with unexpected values, so that any input validation
    done at initialization may fail. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, JAX’s internals use arrays of `object()` values to infer
    the structure of the tree; in the second case, the jacobian of a function mapping
    a tree to a tree is defined as a tree of trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, the `__init__` and `__new__` methods of custom PyTree classes
    should generally avoid doing any array conversion or other input validation, or
    else anticipate and handle these special cases. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is to structure your `tree_unflatten` function so that
    it avoids calling `__init__`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you go this route, make sure that your `tree_unflatten` function stays in-sync
    with `__init__` if and when the code is updated.
  prefs: []
  type: TYPE_NORMAL
