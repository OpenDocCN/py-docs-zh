- en: Column Elements and Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/sqlelement.html](https://docs.sqlalchemy.org/en/20/core/sqlelement.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The expression API consists of a series of classes each of which represents
    a specific lexical element within a SQL string. Composed together into a larger
    structure, they form a statement construct that may be *compiled* into a string
    representation that can be passed to a database. The classes are organized into
    a hierarchy that begins at the basemost [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") class. Key subclasses include [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"), which represents the role of any column-based
    expression in a SQL statement, such as in the columns clause, WHERE clause, and
    ORDER BY clause, and [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause"), which represents the role of a token
    that is placed in the FROM clause of a SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: '## Column Element Foundational Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone functions imported from the `sqlalchemy` namespace which are used
    when building up SQLAlchemy Expression Language constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [and_](#sqlalchemy.sql.expression.and_)(*clauses) | Produce a conjunction
    of expressions joined by `AND`. |'
  prefs: []
  type: TYPE_TB
- en: '| [bindparam](#sqlalchemy.sql.expression.bindparam)(key[, value, type_, unique,
    ...]) | Produce a “bound expression”. |'
  prefs: []
  type: TYPE_TB
- en: '| [bitwise_not](#sqlalchemy.sql.expression.bitwise_not)(expr) | Produce a unary
    bitwise NOT clause, typically via the `~` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [case](#sqlalchemy.sql.expression.case)(*whens, [value, else_]) | Produce
    a `CASE` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [cast](#sqlalchemy.sql.expression.cast)(expression, type_) | Produce a `CAST`
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [column](#sqlalchemy.sql.expression.column)(text[, type_, is_literal, _selectable])
    | Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| [custom_op](#sqlalchemy.sql.expression.custom_op) | Represent a ‘custom’
    operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [distinct](#sqlalchemy.sql.expression.distinct)(expr) | Produce an column-expression-level
    unary `DISTINCT` clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [extract](#sqlalchemy.sql.expression.extract)(field, expr) | Return a [`Extract`](#sqlalchemy.sql.expression.Extract
    "sqlalchemy.sql.expression.Extract") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [false](#sqlalchemy.sql.expression.false)() | Return a [`False_`](#sqlalchemy.sql.expression.False_
    "sqlalchemy.sql.expression.False_") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [func](#sqlalchemy.sql.expression.func) | Generate SQL function expressions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [lambda_stmt](#sqlalchemy.sql.expression.lambda_stmt)(lmb[, enable_tracking,
    track_closure_variables, track_on, ...]) | Produce a SQL statement that is cached
    as a lambda. |'
  prefs: []
  type: TYPE_TB
- en: '| [literal](#sqlalchemy.sql.expression.literal)(value[, type_, literal_execute])
    | Return a literal clause, bound to a bind parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| [literal_column](#sqlalchemy.sql.expression.literal_column)(text[, type_])
    | Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object that has the [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal
    "sqlalchemy.sql.expression.column") flag set to True. |'
  prefs: []
  type: TYPE_TB
- en: '| [not_](#sqlalchemy.sql.expression.not_)(clause) | Return a negation of the
    given clause, i.e. `NOT(clause)`. |'
  prefs: []
  type: TYPE_TB
- en: '| [null](#sqlalchemy.sql.expression.null)() | Return a constant [`Null`](#sqlalchemy.sql.expression.Null
    "sqlalchemy.sql.expression.Null") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [or_](#sqlalchemy.sql.expression.or_)(*clauses) | Produce a conjunction of
    expressions joined by `OR`. |'
  prefs: []
  type: TYPE_TB
- en: '| [outparam](#sqlalchemy.sql.expression.outparam)(key[, type_]) | Create an
    ‘OUT’ parameter for usage in functions (stored procedures), for databases which
    support them. |'
  prefs: []
  type: TYPE_TB
- en: '| [quoted_name](#sqlalchemy.sql.expression.quoted_name) | Represent a SQL identifier
    combined with quoting preferences. |'
  prefs: []
  type: TYPE_TB
- en: '| [text](#sqlalchemy.sql.expression.text)(text) | Construct a new [`TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") clause, representing a textual SQL string
    directly. |'
  prefs: []
  type: TYPE_TB
- en: '| [true](#sqlalchemy.sql.expression.true)() | Return a constant [`True_`](#sqlalchemy.sql.expression.True_
    "sqlalchemy.sql.expression.True_") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [try_cast](#sqlalchemy.sql.expression.try_cast)(expression, type_) | Produce
    a `TRY_CAST` expression for backends which support it; this is a `CAST` which
    returns NULL for un-castable conversions. |'
  prefs: []
  type: TYPE_TB
- en: '| [tuple_](#sqlalchemy.sql.expression.tuple_)(*clauses, [types]) | Return a
    [`Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [type_coerce](#sqlalchemy.sql.expression.type_coerce)(expression, type_)
    | Associate a SQL expression with a particular type, without rendering `CAST`.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Produce a conjunction of expressions joined by `AND`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    conjunction is also available using the Python `&` operator (though note that
    compound expressions need to be parenthesized in order to function with Python
    operator precedence behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    operation is also implicit in some cases; the [`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method for example can be invoked multiple
    times against a statement, which will have the effect of each clause being combined
    using [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct must be given at least one positional argument in order to be valid;
    a [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct with no arguments is ambiguous. To produce an “empty” or dynamically
    generated [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    expression, from a given list of expressions, a “default” element of [`true()`](#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") (or just `True`) should be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The above expression will compile to SQL as the expression `true` or `1 = 1`,
    depending on backend, if no other expressions are present. If expressions are
    present, then the [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    value is ignored as it does not affect the outcome of an AND expression that has
    other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") element now requires that at least one argument
    is passed; creating the [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct with no arguments is deprecated, and will emit a deprecation warning
    while continuing to produce a blank SQL string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Produce a “bound expression”.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an instance of [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter"); this is a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass which represents a so-called
    “placeholder” value in a SQL expression, the value of which is supplied at the
    point at which the statement in executed against a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, the [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    construct has the ability to carry along the actual value that will be ultimately
    used at expression time. In this way, it serves not just as a “placeholder” for
    eventual population, but also as a means of representing so-called “unsafe” values
    which should not be rendered directly in a SQL statement, but rather should be
    passed along to the [DBAPI](../glossary.html#term-DBAPI) as values which need
    to be correctly escaped and potentially handled for type-safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    explicitly, the use case is typically one of traditional deferment of parameters;
    the [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    construct accepts a name which can then be referred to at execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement, when rendered, will produce SQL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to populate the value of `:username` above, the value would typically
    be applied at execution time to a method like [`Connection.execute()`](connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicit use of [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is also common when producing UPDATE or DELETE statements that are to be invoked
    multiple times, where the WHERE criterion of the statement is to change on each
    invocation, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy’s Core expression system makes wide use of [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") in an implicit sense. It is typical that
    Python literal values passed to virtually all SQL expression functions are coerced
    into fixed [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    constructs. For example, given a comparison operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The above expression will produce a [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") construct, where the left side is
    the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object representing the `name` column, and the right side is a [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") representing the literal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression above will render SQL such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `:name_1` parameter name is an anonymous name. The actual string
    `Wendy` is not in the rendered string, but is carried along where it is later
    used within statement execution. If we invoke a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We would see SQL logging output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that `Wendy` is passed as a parameter to the database, while the
    placeholder `:name_1` is rendered in the appropriate form for the target database,
    in this case the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is invoked automatically when working with [CRUD](../glossary.html#term-CRUD)
    statements as far as the “VALUES” portion is concerned. The [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct produces an `INSERT` expression
    which will, at statement execution time, generate bound placeholders based on
    the arguments passed, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will produce SQL output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The [`Insert`](dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct, at compilation/execution time, rendered a single [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") mirroring the column name `name` as a result
    of the single `name` parameter we passed to the [`Connection.execute()`](connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the key (e.g. the name) for this bind param. Will be used in the generated SQL
    statement for dialects that use named parameters. This value may be modified when
    part of a compilation operation, if other [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects exist with the same key, or
    if its length is too long and truncation is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If omitted, an “anonymous” name is generated for the bound parameter; when given
    a value to bind, the end result is equivalent to calling upon the [`literal()`](#sqlalchemy.sql.expression.literal
    "sqlalchemy.sql.expression.literal") function with a value to bind, particularly
    if the [`bindparam.unique`](#sqlalchemy.sql.expression.bindparam.params.unique
    "sqlalchemy.sql.expression.bindparam") parameter is also provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`value` – Initial value for this bind param. Will be used at statement execution
    time as the value for this parameter passed to the DBAPI, if no other value is
    indicated to the statement execution method for this particular parameter name.
    Defaults to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – A callable function that takes the place of “value”. The function
    will be called at statement execution time to determine the ultimate value. Used
    for scenarios where the actual bind value cannot be determined at the point at
    which the clause construct is created, but embedded bind values are still desirable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance representing an optional datatype for this [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"). If not passed, a type may be determined
    automatically for the bind, based on the given value; for example, trivial Python
    types such as `str`, `int`, `bool` may result in the [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") types being automatically selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type of a [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is significant especially in that the type will apply pre-processing to the value
    before it is passed to the database. For example, a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") which refers to a datetime value, and is
    specified as holding the [`DateTime`](type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") type, may apply conversion needed to the value (such
    as stringification on SQLite) before passing the value to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unique` – if True, the key name of this [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") will be modified if another [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") of the same name already has been located
    within the containing expression. This flag is used generally by the internals
    when producing so-called “anonymous” bound expressions, it isn’t generally applicable
    to explicitly-named [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    constructs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` – If `True`, a value is required at execution time. If not passed,
    it defaults to `True` if neither [`bindparam.value`](#sqlalchemy.sql.expression.bindparam.params.value
    "sqlalchemy.sql.expression.bindparam") or [`bindparam.callable`](#sqlalchemy.sql.expression.bindparam.params.callable
    "sqlalchemy.sql.expression.bindparam") were passed. If either of these parameters
    are present, then [`bindparam.required`](#sqlalchemy.sql.expression.bindparam.params.required
    "sqlalchemy.sql.expression.bindparam") defaults to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quote` – True if this parameter name requires quoting and is not currently
    known as a SQLAlchemy reserved word; this currently only applies to the Oracle
    backend, where bound names must sometimes be quoted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isoutparam` – if True, the parameter should be treated like a stored procedure
    “OUT” parameter. This applies to backends such as Oracle which support OUT parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expanding` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, this parameter will be treated as an “expanding” parameter at execution
    time; the parameter value is expected to be a sequence, rather than a scalar value,
    and the string SQL statement will be transformed on a per-execution basis to accommodate
    the sequence with a variable number of parameter slots passed to the DBAPI. This
    is to allow statement caching to be used in conjunction with an IN clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using IN expressions](../orm/extensions/baked.html#baked-in) - with baked
    queries'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The “expanding” feature does not support “executemany”- style parameter sets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.3: the “expanding” bound parameter feature now supports
    empty lists.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`literal_execute` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, the bound parameter will be rendered in the compile phase with a special
    “POSTCOMPILE” token, and the SQLAlchemy compiler will render the final value of
    the parameter into the SQL statement at statement execution time, omitting the
    value from the parameter dictionary / list passed to DBAPI `cursor.execute()`.
    This produces a similar effect as that of using the `literal_binds`, compilation
    flag, however takes place as the statement is sent to the DBAPI `cursor.execute()`
    method, rather than when the statement is compiled. The primary use of this capability
    is for rendering LIMIT / OFFSET clauses for database drivers that can’t accommodate
    for bound parameters in these contexts, while allowing SQL constructs to be cacheable
    at the compilation level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added “post compile” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](../changelog/migration_14.html#change-4808).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Parameters](../tutorial/dbapi_transactions.html#tutorial-sending-parameters)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Produce a unary bitwise NOT clause, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not to be confused with boolean negation [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `CASE` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `CASE` construct in SQL is a conditional object that acts somewhat analogously
    to an “if/then” construct in other languages. It returns an instance of [`Case`](#sqlalchemy.sql.expression.Case
    "sqlalchemy.sql.expression.Case").
  prefs: []
  type: TYPE_NORMAL
- en: '[`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    in its usual form is passed a series of “when” constructs, that is, a list of
    conditions and results as tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When simple equality expressions of several values against a single parent
    column are needed, [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    also has a “shorthand” format used via the [`case.value`](#sqlalchemy.sql.expression.case.params.value
    "sqlalchemy.sql.expression.case") parameter, which is passed a column expression
    to be compared. In this form, the [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") parameter is passed as a dictionary containing
    expressions to be compared against keyed to result expressions. The statement
    below is equivalent to the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The values which are accepted as result values in [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") as well as with [`case.else_`](#sqlalchemy.sql.expression.case.params.else_
    "sqlalchemy.sql.expression.case") are coerced from Python literals into [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs. SQL expressions, e.g. [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs, are accepted as well. To
    coerce a literal string expression into a constant expression rendered inline,
    use the [`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    construct, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render the given constants without using bound parameters for
    the result values (but still for the comparison values), as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*whens` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The criteria to be compared against, [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") accepts two different forms, based on whether
    or not [`case.value`](#sqlalchemy.sql.expression.case.params.value "sqlalchemy.sql.expression.case")
    is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    function now accepts the series of WHEN conditions positionally'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the first form, it accepts multiple 2-tuples passed as positional arguments;
    each 2-tuple consists of `(<sql expression>, <value>)`, where the SQL expression
    is a boolean expression and “value” is a resulting value, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second form, it accepts a Python dictionary of comparison values mapped
    to a resulting value; this form requires [`case.value`](#sqlalchemy.sql.expression.case.params.value
    "sqlalchemy.sql.expression.case") to be present, and values will be compared using
    the `==` operator, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`value` – An optional SQL expression which will be used as a fixed “comparison
    point” for candidate values within a dictionary passed to [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else_` – An optional SQL expression which will be the evaluated result of
    the `CASE` construct if all expressions within [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") evaluate to false. When omitted, most databases
    will produce a result of NULL if none of the “when” expressions evaluate to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `CAST` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    returns an instance of [`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast").'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function performs two distinct functions when used. The first is that it renders
    the `CAST` expression within the resulting SQL string. The second is that it associates
    the given type (e.g. [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or instance) with the column expression on
    the Python side, which means the expression will take on the expression operator
    behavior associated with that type, as well as the bound-value handling and result-row-handling
    behavior of the type.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    is the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    function. This function performs the second task of associating an expression
    with a specific type, but does not render the `CAST` expression in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expression` – A SQL expression, such as a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression or a Python string which
    will be coerced into a bound literal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance indicating the type to which the `CAST` should apply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    - an alternative to CAST that results in NULLs when the cast fails, instead of
    raising an error. Only supported by some dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    - an alternative to CAST that coerces the type on the Python side only, which
    is often sufficient to generate the correct SQL and data coercion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    is a lightweight analogue to the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class. The [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") function can be invoked with just a name alone,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once constructed, [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    may be used like any other SQL expression element such as within [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The text handled by [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    is assumed to be handled like the name of a database column; if the string contains
    mixed case, special characters, or matches a known reserved word on the target
    backend, the column expression will render using the quoting behavior determined
    by the backend. To produce a textual SQL expression that is rendered exactly without
    any quoting, use [`literal_column()`](#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") instead, or pass `True` as the value
    of [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal "sqlalchemy.sql.expression.column").
    Additionally, full SQL statements are best handled using the [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    can be used in a table-like fashion by combining it with the [`table()`](selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") function (which is the lightweight analogue
    to [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    ) to produce a working table construct with minimal boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    / [`table()`](selectable.html#sqlalchemy.sql.expression.table "sqlalchemy.sql.expression.table")
    construct like that illustrated above can be created in an ad-hoc fashion and
    is not associated with any [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), DDL, or events, unlike its [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text` – the text of the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` – [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object which can associate this [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") with a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_literal` – if True, the [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") is assumed to be an exact expression
    that will be delivered to the output with no quoting rules applied regardless
    of case sensitive settings. the [`literal_column()`](#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") function essentially invokes [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") while passing `is_literal=True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`table()`](selectable.html#sqlalchemy.sql.expression.table "sqlalchemy.sql.expression.table")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Represent a ‘custom’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`custom_op`](#sqlalchemy.sql.expression.custom_op "sqlalchemy.sql.expression.custom_op")
    is normally instantiated when the [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") methods are used to create a custom
    operator callable. The class can also be used directly when programmatically constructing
    expressions. E.g. to represent the “factorial” operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.custom_op`](#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") (`sqlalchemy.sql.expression.OperatorType`,
    `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Produce an column-expression-level unary `DISTINCT` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'This applies the `DISTINCT` keyword to an **individual column expression**
    (e.g. not the whole statement), and renders **specifically in that column position**;
    this is used for containment within an aggregate function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would produce an statement resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    function does **not** apply DISTINCT to the full SELECT statement, instead applying
    a DISTINCT modifier to **individual column expressions**. For general `SELECT
    DISTINCT` support, use the [`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct") method on [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    function is also available as a column-level method, e.g. [`ColumnElement.distinct()`](#sqlalchemy.sql.expression.ColumnElement.distinct
    "sqlalchemy.sql.expression.ColumnElement.distinct"), as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    operator is different from the [`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct") method of [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), which produces a `SELECT` statement with
    `DISTINCT` applied to the result set as a whole, e.g. a `SELECT DISTINCT` expression.
    See that method for further information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.distinct()`](#sqlalchemy.sql.expression.ColumnElement.distinct
    "sqlalchemy.sql.expression.ColumnElement.distinct")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Extract`](#sqlalchemy.sql.expression.Extract "sqlalchemy.sql.expression.Extract")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically available as [`extract()`](#sqlalchemy.sql.expression.extract
    "sqlalchemy.sql.expression.extract") as well as `func.extract` from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`field` – The field to extract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expr` – A column or Python scalar expression serving as the right side of
    the `EXTRACT` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the statement is used to select ids from the database
    where the `YEAR` component matches a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, one can also select an extracted component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `EXTRACT` may vary across database backends. Users are
    reminded to consult their database documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`False_`](#sqlalchemy.sql.expression.False_ "sqlalchemy.sql.expression.False_")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A backend which does not support true/false constants will render as an expression
    against 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    constants also feature “short circuit” operation within an [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") or [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") conjunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Generate SQL function expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    is a special object instance which generates SQL functions based on name-based
    attributes, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned object is an instance of [`Function`](functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function"), and is a column-oriented SQL element like
    any other, and is used in that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Any name can be given to [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    If the function name is unknown to SQLAlchemy, it will be rendered exactly as
    is. For common SQL functions which SQLAlchemy is aware of, the name may be interpreted
    as a *generic function* which will be compiled appropriately to the target database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To call functions which are present in dot-separated packages, specify them
    in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy can be made aware of the return type of functions to enable type-specific
    lexical and result-based behavior. For example, to ensure that a string-based
    function returns a Unicode value and is similarly treated as a string in expressions,
    specify [`Unicode`](type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The object returned by a [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    call is usually an instance of [`Function`](functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function"). This object meets the “column” interface,
    including comparison and labeling functions. The object can also be passed the
    `Connectable.execute()` method of a [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), where it will be wrapped inside of a SELECT statement
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In a few exception cases, the [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    accessor will redirect a name to a built-in expression such as [`cast()`](#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`extract()`](#sqlalchemy.sql.expression.extract
    "sqlalchemy.sql.expression.extract"), as these names have well-known meaning but
    are not exactly the same as “functions” from a SQLAlchemy perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Functions which are interpreted as “generic” functions know how to calculate
    their return type automatically. For a listing of known generic functions, see
    [SQL and Generic Functions](functions.html#generic-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    construct has only limited support for calling standalone “stored procedures”,
    especially those with special parameterization concerns.
  prefs: []
  type: TYPE_NORMAL
- en: See the section [Calling Stored Procedures and User Defined Functions](connections.html#stored-procedures)
    for details on how to use the DBAPI-level `callproc()` method for fully traditional
    stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with SQL Functions](../tutorial/data_select.html#tutorial-functions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Function`](functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Produce a SQL statement that is cached as a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code object within the lambda is scanned for both Python literals
    that will become bound parameters as well as closure variables that refer to Core
    or ORM constructs that may vary. The lambda itself will be invoked only once per
    particular set of constructs detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The object returned is an instance of [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lmb` – a Python function, typically a lambda, which takes no arguments and
    returns a SQL expression construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable_tracking` – when False, all scanning of the given lambda for changes
    in closure variables or bound parameters is disabled. Use for a lambda that produces
    the identical results in all cases with no parameterization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`track_closure_variables` – when False, changes in closure variables within
    the lambda will not be scanned. Use for a lambda where the state of its closure
    variables will never change the SQL structure returned by the lambda.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`track_bound_values` – when False, bound parameter tracking will be disabled
    for the given lambda. Use for a lambda that either does not produce any bound
    values, or where the initial bound values never change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global_track_bound_values` – when False, bound parameter tracking will be
    disabled for the entire statement including additional links added via the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda_cache` – a dictionary or other mapping-like object where information
    about the lambda’s Python code as well as the tracked closure variables in the
    lambda itself will be stored. Defaults to a global LRU cache. This cache is independent
    of the “compiled_cache” used by the [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Lambdas to add significant speed gains to statement production](connections.html#engine-lambda-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Return a literal clause, bound to a bind parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Literal clauses are created automatically when non- [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") objects (such as strings, ints, dates,
    etc.) are used in a comparison operation with a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass, such as a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. Use this function to force the generation
    of a literal clause, which will be created as a [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") with a bound value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` – the value to be bound. Can be any Python object supported by the
    underlying DB-API, or is translatable via the given type argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – an optional [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") which will provide bind-parameter translation for
    this literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`literal_execute` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional bool, when True, the SQL engine will attempt to render the bound value
    directly in the SQL statement at execution time rather than providing as a parameter
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object that has the [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal
    "sqlalchemy.sql.expression.column") flag set to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    is similar to [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column"),
    except that it is more often used as a “standalone” column expression that renders
    exactly as stated; while [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    stores a string name that will be assumed to be part of a table and may be quoted
    as such, [`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    can be that, or any other arbitrary column-oriented expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text` – the text of the expression; can be any SQL expression. Quoting rules
    will not be applied. To specify a column-name expression which should be subject
    to quoting rules, use the [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – an optional [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object which will provide result-set translation
    and additional expression semantics for this column. If left as `None` the type
    will be [`NullType`](type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Return a negation of the given clause, i.e. `NOT(clause)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `~` operator is also overloaded on all [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclasses to produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Return a constant [`Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Produce a conjunction of expressions joined by `OR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    conjunction is also available using the Python `|` operator (though note that
    compound expressions need to be parenthesized in order to function with Python
    operator precedence behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    construct must be given at least one positional argument in order to be valid;
    a [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_") construct
    with no arguments is ambiguous. To produce an “empty” or dynamically generated
    [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_") expression,
    from a given list of expressions, a “default” element of [`false()`](#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") (or just `False`) should be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The above expression will compile to SQL as the expression `false` or `0 = 1`,
    depending on backend, if no other expressions are present. If expressions are
    present, then the [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    value is ignored as it does not affect the outcome of an OR expression which has
    other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") element now requires that at least one argument
    is passed; creating the [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    construct with no arguments is deprecated, and will emit a deprecation warning
    while continuing to produce a blank SQL string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Create an ‘OUT’ parameter for usage in functions (stored procedures), for databases
    which support them.
  prefs: []
  type: TYPE_NORMAL
- en: The `outparam` can be used like a regular function parameter. The “output” value
    will be available from the [`CursorResult`](connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") object via its `out_parameters` attribute, which
    returns a dictionary containing the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    clause, representing a textual SQL string directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The advantages [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    provides over a plain string are backend-neutral support for bind parameters,
    per-statement execution options, as well as bind parameter and result-column typing
    behavior, allowing SQLAlchemy type constructs to play a role when executing a
    statement that is specified literally. The construct can also be provided with
    a `.c` collection of column elements, allowing it to be embedded in other SQL
    expression constructs as a subquery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind parameters are specified by name, using the format `:name`. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQL statements where a colon is required verbatim, as within an inline
    string, use a backslash to escape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    construct includes methods which can provide information about the bound parameters
    as well as the column values which would be returned from the textual statement,
    assuming it’s an executable SELECT type of statement. The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method is used to provide bound
    parameter detail, and [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method allows specification of
    return columns including names and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct is used in cases when a literal string SQL fragment is specified as
    part of a larger query, such as for the WHERE clause of a SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    is also used for the construction of a full, standalone statement using plain
    text. As such, SQLAlchemy refers to it as an [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable") object and may be used like any other
    statement passed to an `.execute()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**text** –'
  prefs: []
  type: TYPE_NORMAL
- en: the text of the SQL statement to be created. Use `:<param>` to specify bind
    parameters; they will be compiled to their engine-specific format.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`text.text`](#sqlalchemy.sql.expression.text.params.text "sqlalchemy.sql.expression.text")
    argument to [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    can be passed as a Python string argument, which will be treated as **trusted
    SQL text** and rendered as given. **DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Return a constant [`True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A backend which does not support true/false constants will render as an expression
    against 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    constants also feature “short circuit” operation within an [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") or [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") conjunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `TRY_CAST` expression for backends which support it; this is a `CAST`
    which returns NULL for un-castable conversions.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, this construct is supported **only** by the SQL Server dialect,
    and will raise a [`CompileError`](exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") if used on other included backends. However, third
    party backends may also support this construct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    originates from the SQL Server dialect, it’s importable both from `sqlalchemy.`
    as well as from `sqlalchemy.dialects.mssql`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    returns an instance of [`TryCast`](#sqlalchemy.sql.expression.TryCast "sqlalchemy.sql.expression.TryCast")
    and generally behaves similarly to the [`Cast`](#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast") construct; at the SQL level, the difference
    between `CAST` and `TRY_CAST` is that `TRY_CAST` returns NULL for an un-castable
    expression, such as attempting to cast a string `"hi"` to an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would render on Microsoft SQL Server as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.14: [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    has been generalized from the SQL Server dialect into a general use construct
    that may be supported by additional dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple").
  prefs: []
  type: TYPE_NORMAL
- en: Main usage is to produce a composite IN construct using [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3.6: Added support for SQLite IN tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The composite IN construct is not supported by all backends, and is currently
    known to work on PostgreSQL, MySQL, and SQLite. Unsupported backends will raise
    a subclass of [`DBAPIError`](exceptions.html#sqlalchemy.exc.DBAPIError "sqlalchemy.exc.DBAPIError")
    when such an expression is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Associate a SQL expression with a particular type, without rendering `CAST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The above construct will produce a [`TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") object, which does not modify the rendering
    in any way on the SQL side, with the possible exception of a generated label if
    used in a columns clause context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: When result rows are fetched, the `StringDateTime` type processor will be applied
    to result rows on behalf of the `date_string` column.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    construct does not render any SQL syntax of its own, including that it does not
    imply parenthesization. Please use [`TypeCoerce.self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") if explicit parenthesization
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide a named label for the expression, use [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A type that features bound-value handling will also have that behavior take
    effect when literal values or [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs are passed to [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") as targets. For example, if a type implements
    the [`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") method or [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method or equivalent, these functions
    will take effect at statement compilation/execution time when a literal value
    is passed, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When using [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    with composed expressions, note that **parenthesis are not applied**. If [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is being used in an operator context
    where the parenthesis normally present from CAST are necessary, use the [`TypeCoerce.self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expression` – A SQL expression, such as a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression or a Python string which
    will be coerced into a bound literal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance indicating the type to which the expression is coerced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL identifier combined with quoting preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '[`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    is a Python unicode/str subclass which represents a particular identifier name
    along with a `quote` flag. This `quote` flag, when set to `True` or `False`, overrides
    automatic quoting behavior for this identifier in order to either unconditionally
    quote or to not quote the name. If left at its default of `None`, quoting behavior
    is applied to the identifier on a per-backend basis based on an examination of
    the token itself.'
  prefs: []
  type: TYPE_NORMAL
- en: A [`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    object with `quote=True` is also prevented from being modified in the case of
    a so-called “name normalize” option. Certain database backends, such as Oracle,
    Firebird, and DB2 “normalize” case-insensitive names as uppercase. The SQLAlchemy
    dialects for these backends convert from SQLAlchemy’s lower-case-means-insensitive
    convention to the upper-case-means-insensitive conventions of those backends.
    The `quote=True` flag here will prevent this conversion from occurring to support
    an identifier that’s quoted as all lower case against such a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    object is normally created automatically when specifying the name for key schema
    constructs such as [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    and others. The class can also be passed explicitly as the name to any function
    that receives a name which can be quoted. Such as to use the `Engine.has_table()`
    method with an unconditionally quoted name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The above logic will run the “has table” logic against the Oracle backend, passing
    the name exactly as `"some_table"` without converting to upper case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`quoted_name`](#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now importable from `sqlalchemy.sql`,
    in addition to the previous location of `sqlalchemy.sql.elements`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[quote](#sqlalchemy.sql.expression.quoted_name.quote)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.quoted_name`](#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") (`sqlalchemy.util.langhelpers.MemoizedSlots`,
    `builtins.str`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'whether the string should be unconditionally quoted  ## Column Element Modifier
    Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: Functions listed here are more commonly available as methods from any [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") construct, for example, the [`label()`](#sqlalchemy.sql.expression.label
    "sqlalchemy.sql.expression.label") function is usually invoked via the [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [all_](#sqlalchemy.sql.expression.all_)(expr) | Produce an ALL expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [any_](#sqlalchemy.sql.expression.any_)(expr) | Produce an ANY expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [asc](#sqlalchemy.sql.expression.asc)(column) | Produce an ascending `ORDER
    BY` clause element. |'
  prefs: []
  type: TYPE_TB
- en: '| [between](#sqlalchemy.sql.expression.between)(expr, lower_bound, upper_bound[,
    symmetric]) | Produce a `BETWEEN` predicate clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [collate](#sqlalchemy.sql.expression.collate)(expression, collation) | Return
    the clause `expression COLLATE collation`. |'
  prefs: []
  type: TYPE_TB
- en: '| [desc](#sqlalchemy.sql.expression.desc)(column) | Produce a descending `ORDER
    BY` clause element. |'
  prefs: []
  type: TYPE_TB
- en: '| [funcfilter](#sqlalchemy.sql.expression.funcfilter)(func, *criterion) | Produce
    a [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter "sqlalchemy.sql.expression.FunctionFilter")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [label](#sqlalchemy.sql.expression.label)(name, element[, type_]) | Return
    a [`Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    object for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"). |'
  prefs: []
  type: TYPE_TB
- en: '| [nulls_first](#sqlalchemy.sql.expression.nulls_first)(column) | Produce the
    `NULLS FIRST` modifier for an `ORDER BY` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [nulls_last](#sqlalchemy.sql.expression.nulls_last)(column) | Produce the
    `NULLS LAST` modifier for an `ORDER BY` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [nullsfirst](#sqlalchemy.sql.expression.nullsfirst) | Synonym for the [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first
    "sqlalchemy.sql.expression.nulls_first") function. |'
  prefs: []
  type: TYPE_TB
- en: '| [nullslast](#sqlalchemy.sql.expression.nullslast) | Legacy synonym for the
    [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    function. |'
  prefs: []
  type: TYPE_TB
- en: '| [over](#sqlalchemy.sql.expression.over)(element[, partition_by, order_by,
    range_, ...]) | Produce an [`Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [within_group](#sqlalchemy.sql.expression.within_group)(element, *order_by)
    | Produce a [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ALL expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dialects such as that of PostgreSQL, this operator applies to usage of
    the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    datatype, for that of MySQL, it may apply to a subquery. e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparison to NULL may work using `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The any_() / all_() operators also feature a special “operand flipping” behavior
    such that if any_() / all_() are used on the left side of a comparison using a
    standalone operator such as `==`, `!=`, etc. (not including operator methods such
    as [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_"))
    the rendered expression is flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `None`, which note will not perform the usual step of rendering “IS”
    as is normally the case for NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.26: repaired the use of any_() / all_() comparing to
    NULL on the right side to be flipped to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The column-level [`ColumnElement.all_()`](#sqlalchemy.sql.expression.ColumnElement.all_
    "sqlalchemy.sql.expression.ColumnElement.all_") method (not to be confused with
    [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") level
    [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all "sqlalchemy.types.ARRAY.Comparator.all"))
    is shorthand for `all_(col)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ANY expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dialects such as that of PostgreSQL, this operator applies to usage of
    the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    datatype, for that of MySQL, it may apply to a subquery. e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparison to NULL may work using `None` or [`null()`](#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The any_() / all_() operators also feature a special “operand flipping” behavior
    such that if any_() / all_() are used on the left side of a comparison using a
    standalone operator such as `==`, `!=`, etc. (not including operator methods such
    as [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_"))
    the rendered expression is flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `None`, which note will not perform the usual step of rendering “IS”
    as is normally the case for NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.26: repaired the use of any_() / all_() comparing to
    NULL on the right side to be flipped to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The column-level [`ColumnElement.any_()`](#sqlalchemy.sql.expression.ColumnElement.any_
    "sqlalchemy.sql.expression.ColumnElement.any_") method (not to be confused with
    [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") level
    [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any "sqlalchemy.types.ARRAY.Comparator.any"))
    is shorthand for `any_(col)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ascending `ORDER BY` clause element.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'will produce SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    function is a standalone version of the [`ColumnElement.asc()`](#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") method available on all SQL expressions,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**column** – A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    (e.g. scalar SQL expression) with which to apply the [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") operation.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `BETWEEN` predicate clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    function is a standalone version of the [`ColumnElement.between()`](#sqlalchemy.sql.expression.ColumnElement.between
    "sqlalchemy.sql.expression.ColumnElement.between") method available on all SQL
    expressions, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'All arguments passed to [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between"),
    including the left side column expression, are coerced from Python scalar values
    if a the value is not a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass. For example, three fixed
    values can be compared as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expr` – a column expression, typically a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") instance or alternatively a Python
    scalar expression to be coerced into a column expression, serving as the left
    side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` – a column or Python scalar expression serving as the lower bound
    of the right side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper_bound` – a column or Python scalar expression serving as the upper bound
    of the right side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetric` – if True, will render “ BETWEEN SYMMETRIC “. Note that not all
    databases support this syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.between()`](#sqlalchemy.sql.expression.ColumnElement.between
    "sqlalchemy.sql.expression.ColumnElement.between")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return the clause `expression COLLATE collation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The collation expression is also quoted if it is a case sensitive identifier,
    e.g. contains uppercase characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: quoting is automatically applied to COLLATE expressions
    if they are case sensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Produce a descending `ORDER BY` clause element.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'will produce SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    function is a standalone version of the [`ColumnElement.desc()`](#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") method available on all SQL expressions,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**column** – A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    (e.g. scalar SQL expression) with which to apply the [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") operation.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter "sqlalchemy.sql.expression.FunctionFilter")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate and window functions, for database backends that support
    the “FILTER” clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Would produce “COUNT(1) FILTER (WHERE myclass.name = ‘some name’)”.
  prefs: []
  type: TYPE_NORMAL
- en: This function is also available from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct itself via the [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Special Modifiers WITHIN GROUP, FILTER](../tutorial/data_select.html#tutorial-functions-within-group)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    object for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: A label changes the name of an element in the columns clause of a `SELECT` statement,
    typically via the `AS` SQL keyword.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is more conveniently available via the [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method on [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – label name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` – a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Produce the `NULLS FIRST` modifier for an `ORDER BY` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    is intended to modify the expression produced by [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") or [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), and indicates how NULL values should be handled
    when they are encountered during ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL expression from the above would resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Like [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    and [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc"),
    [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    is typically invoked from the column expression itself using [`ColumnElement.nulls_first()`](#sqlalchemy.sql.expression.ColumnElement.nulls_first
    "sqlalchemy.sql.expression.ColumnElement.nulls_first"), rather than as its standalone
    function version, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first
    "sqlalchemy.sql.expression.nulls_first") is renamed from [`nullsfirst()`](#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst") in previous releases. The previous name
    remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Synonym for the [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: restored missing legacy symbol [`nullsfirst()`](#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Produce the `NULLS LAST` modifier for an `ORDER BY` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    is intended to modify the expression produced by [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") or [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), and indicates how NULL values should be handled
    when they are encountered during ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL expression from the above would resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Like [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    and [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc"),
    [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    is typically invoked from the column expression itself using [`ColumnElement.nulls_last()`](#sqlalchemy.sql.expression.ColumnElement.nulls_last
    "sqlalchemy.sql.expression.ColumnElement.nulls_last"), rather than as its standalone
    function version, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last
    "sqlalchemy.sql.expression.nulls_last") is renamed from [`nullslast()`](#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast") in previous releases. The previous name
    remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Legacy synonym for the [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last
    "sqlalchemy.sql.expression.nulls_last") function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: restored missing legacy symbol [`nullslast()`](#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate or so-called “window” functions, for database backends
    that support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")
    is usually called using the [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are also possible using the [`over.range_`](#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters. These mutually-exclusive parameters
    each accept a 2-tuple, which contains a combination of integers and None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of `None` indicates “unbounded”, a value of zero indicates “current
    row”, and negative / positive integers indicate “preceding” and “following”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element` – a [`FunctionElement`](functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement"), [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup"), or other compatible construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partition_by` – a column element or string, or a list of such, that will be
    used as the PARTITION BY clause of the OVER construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order_by` – a column element or string, or a list of such, that will be used
    as the ORDER BY clause of the OVER construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range_` – optional range clause for the window. This is a tuple value which
    can contain integer values or `None`, and will render a RANGE BETWEEN PRECEDING
    / FOLLOWING clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rows` – optional rows clause for the window. This is a tuple value which can
    contain integer values or None, and will render a ROWS BETWEEN PRECEDING / FOLLOWING
    clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is also available from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct itself via the [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`within_group()`](#sqlalchemy.sql.expression.within_group "sqlalchemy.sql.expression.within_group")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against so-called “ordered set aggregate” and “hypothetical set aggregate”
    functions, including [`percentile_cont`](functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`rank`](functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[`within_group()`](#sqlalchemy.sql.expression.within_group "sqlalchemy.sql.expression.within_group")
    is usually called using the [`FunctionElement.within_group()`](functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The above statement would produce SQL similar to `SELECT department.id, percentile_cont(0.5)
    WITHIN GROUP (ORDER BY department.salary DESC)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element` – a [`FunctionElement`](functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement") construct, typically generated by
    [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*order_by` – one or more column elements that will be used as the ORDER BY
    clause of the WITHIN GROUP construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Special Modifiers WITHIN GROUP, FILTER](../tutorial/data_select.html#tutorial-functions-within-group)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")'
  prefs: []
  type: TYPE_NORMAL
- en: Column Element Class Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classes here are generated using the constructors listed at [Column Element
    Foundational Constructors](#sqlelement-foundational-constructors) and [Column
    Element Modifier Constructors](#sqlelement-modifier-constructors).
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BinaryExpression](#sqlalchemy.sql.expression.BinaryExpression) | Represent
    an expression that is `LEFT <operator> RIGHT`. |'
  prefs: []
  type: TYPE_TB
- en: '| [BindParameter](#sqlalchemy.sql.expression.BindParameter) | Represent a “bound
    expression”. |'
  prefs: []
  type: TYPE_TB
- en: '| [Case](#sqlalchemy.sql.expression.Case) | Represent a `CASE` expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Cast](#sqlalchemy.sql.expression.Cast) | Represent a `CAST` expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ClauseList](#sqlalchemy.sql.expression.ClauseList) | Describe a list of
    clauses, separated by an operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnClause](#sqlalchemy.sql.expression.ColumnClause) | Represents a column
    expression from any textual string. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollection](#sqlalchemy.sql.expression.ColumnCollection) | Collection
    of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    instances, typically for [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnElement](#sqlalchemy.sql.expression.ColumnElement) | Represent a column-oriented
    SQL expression suitable for usage in the “columns” clause, WHERE clause etc. of
    a statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnExpressionArgument](#sqlalchemy.sql.expression.ColumnExpressionArgument)
    | General purpose “column expression” argument. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnOperators](#sqlalchemy.sql.expression.ColumnOperators) | Defines boolean,
    comparison, and other operators for [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| [Extract](#sqlalchemy.sql.expression.Extract) | Represent a SQL EXTRACT clause,
    `extract(field FROM expr)`. |'
  prefs: []
  type: TYPE_TB
- en: '| [False_](#sqlalchemy.sql.expression.False_) | Represent the `false` keyword,
    or equivalent, in a SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [FunctionFilter](#sqlalchemy.sql.expression.FunctionFilter) | Represent a
    function FILTER clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [Label](#sqlalchemy.sql.expression.Label) | Represents a column label (AS).
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Null](#sqlalchemy.sql.expression.Null) | Represent the NULL keyword in a
    SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [Operators](#sqlalchemy.sql.expression.Operators) | Base of comparison and
    logical operators. |'
  prefs: []
  type: TYPE_TB
- en: '| [Over](#sqlalchemy.sql.expression.Over) | Represent an OVER clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [SQLColumnExpression](#sqlalchemy.sql.expression.SQLColumnExpression) | A
    type that may be used to indicate any SQL column element or object that acts in
    place of one. |'
  prefs: []
  type: TYPE_TB
- en: '| [TextClause](#sqlalchemy.sql.expression.TextClause) | Represent a literal
    SQL text fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| [True_](#sqlalchemy.sql.expression.True_) | Represent the `true` keyword,
    or equivalent, in a SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [TryCast](#sqlalchemy.sql.expression.TryCast) | Represent a TRY_CAST expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Tuple](#sqlalchemy.sql.expression.Tuple) | Represent a SQL tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| [TypeCoerce](#sqlalchemy.sql.expression.TypeCoerce) | Represent a Python-side
    type-coercion wrapper. |'
  prefs: []
  type: TYPE_TB
- en: '| [UnaryExpression](#sqlalchemy.sql.expression.UnaryExpression) | Define a
    ‘unary’ expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [WithinGroup](#sqlalchemy.sql.expression.WithinGroup) | Represent a WITHIN
    GROUP (ORDER BY) clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [WrapsColumnExpression](#sqlalchemy.sql.elements.WrapsColumnExpression) |
    Mixin that defines a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as a wrapper with special labeling
    behavior for an expression that already has a name. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Represent an expression that is `LEFT <operator> RIGHT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression "sqlalchemy.sql.expression.BinaryExpression")
    is generated automatically whenever two column expressions are used in a Python
    binary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") (`sqlalchemy.sql.expression.OperatorExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Represent a “bound expression”.
  prefs: []
  type: TYPE_NORMAL
- en: '[`BindParameter`](#sqlalchemy.sql.expression.BindParameter "sqlalchemy.sql.expression.BindParameter")
    is invoked explicitly using the [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Detailed discussion of how [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") is used is at [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[effective_value](#sqlalchemy.sql.expression.BindParameter.effective_value),
    [inherit_cache](#sqlalchemy.sql.expression.BindParameter.inherit_cache), [render_literal_execute()](#sqlalchemy.sql.expression.BindParameter.render_literal_execute)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") (`sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.expression.KeyedColumnElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Return the value of this bound parameter, taking into account if the `callable`
    parameter was set.
  prefs: []
  type: TYPE_NORMAL
- en: The `callable` value will be evaluated and returned if present, else `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Produce a copy of this bound parameter that will enable the [`BindParameter.literal_execute`](#sqlalchemy.sql.expression.BindParameter.params.literal_execute
    "sqlalchemy.sql.expression.BindParameter") flag.
  prefs: []
  type: TYPE_NORMAL
- en: The [`BindParameter.literal_execute`](#sqlalchemy.sql.expression.BindParameter.params.literal_execute
    "sqlalchemy.sql.expression.BindParameter") flag will have the effect of the parameter
    rendered in the compiled SQL string using `[POSTCOMPILE]` form, which is a special
    form that is converted to be a rendering of the literal value of the parameter
    at SQL execution time. The rationale is to support caching of SQL statement strings
    that can embed per-statement literal values, such as LIMIT and OFFSET parameters,
    in the final SQL string that is passed to the DBAPI. Dialects in particular may
    want to use this method within custom compilation schemes.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Caching for Third Party Dialects](connections.html#engine-thirdparty-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Represent a `CASE` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    is produced using the [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    factory function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Details on [`Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    usage is at [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Represent a `CAST` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    is produced using the [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    factory function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Details on [`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    usage is at [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    - an alternative to CAST that coerces the type on the Python side only, which
    is often sufficient to generate the correct SQL and data coercion.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    (`sqlalchemy.sql.expression.WrapsColumnExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Describe a list of clauses, separated by an operator.
  prefs: []
  type: TYPE_NORMAL
- en: By default, is comma-separated, such as a column listing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.ClauseList.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ClauseList`](#sqlalchemy.sql.expression.ClauseList
    "sqlalchemy.sql.expression.ClauseList") (`sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.roles.OrderByRole`, `sqlalchemy.sql.roles.ColumnsClauseRole`,
    `sqlalchemy.sql.roles.DMLColumnRole`, `sqlalchemy.sql.expression.DQLDMLClauseElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.ClauseList.self_group
    "sqlalchemy.sql.expression.ClauseList.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.ClauseList.self_group "sqlalchemy.sql.expression.ClauseList.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Represents a column expression from any textual string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause"),
    a lightweight analogue to the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is typically invoked using the [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    is the immediate superclass of the schema-specific [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. While the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class has all the same capabilities as [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause"), the [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") class is usable by itself in those cases
    where behavioral requirements are limited to simple SQL expression generation.
    The object has none of the associations with schema-level metadata or with execution-time
    behavior that [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    does, so in that sense is a “lightweight” version of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs: []
  type: TYPE_NORMAL
- en: Full details on [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    usage is at [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_children()](#sqlalchemy.sql.expression.ColumnClause.get_children)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") (`sqlalchemy.sql.roles.DDLReferredColumnRole`,
    `sqlalchemy.sql.roles.LabeledColumnExprRole`, `sqlalchemy.sql.roles.StrAsPlainColumnRole`,
    `sqlalchemy.sql.expression.Immutable`, `sqlalchemy.sql.expression.NamedColumn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used for visit traversal.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Collection of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    instances, typically for [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object is most commonly available as the [`Table.c`](metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") or [`Table.columns`](metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection on the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, introduced at [Accessing Tables and Columns](metadata.html#metadata-tables-and-columns).
  prefs: []
  type: TYPE_NORMAL
- en: The [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    has both mapping- and sequence- like behaviors. A [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") usually stores [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, which are then accessible both via mapping
    style access as well as attribute access style.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects using ordinary attribute-style access, specify the name like any other
    object attribute, such as below a column named `employee_name` is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'To access columns that have names with special characters or spaces, index-style
    access is used, such as below which illustrates a column named `employee '' payment`
    is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'As the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object provides a Python dictionary interface, common dictionary method names
    like [`ColumnCollection.keys()`](#sqlalchemy.sql.expression.ColumnCollection.keys
    "sqlalchemy.sql.expression.ColumnCollection.keys"), [`ColumnCollection.values()`](#sqlalchemy.sql.expression.ColumnCollection.values
    "sqlalchemy.sql.expression.ColumnCollection.values"), and [`ColumnCollection.items()`](#sqlalchemy.sql.expression.ColumnCollection.items
    "sqlalchemy.sql.expression.ColumnCollection.items") are available, which means
    that database columns that are keyed under these names also need to use indexed
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The name for which a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    would be present is normally that of the [`Column.key`](metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") parameter. In some contexts, such as a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object that uses a label style set using the
    [`Select.set_label_style()`](selectable.html#sqlalchemy.sql.expression.Select.set_label_style
    "sqlalchemy.sql.expression.Select.set_label_style") method, a column of a certain
    key may instead be represented under a particular label name such as `tablename_columnname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    also indexes the columns in order and allows them to be accessible by their integer
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") allows integer-based index access
    to the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating the collection yields the column expressions in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The base [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object can store duplicates, which can mean either two columns with the same key,
    in which case the column returned by key access is **arbitrary**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Or it can also mean the same column multiple times. These cases are supported
    as [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    is used to represent the columns in a SELECT statement which may include duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: A special subclass `DedupeColumnCollection` exists which instead maintains SQLAlchemy’s
    older behavior of not allowing duplicates; this collection is used for schema
    level objects like [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") where this deduping is helpful. The
    `DedupeColumnCollection` class also has additional mutation methods as the schema
    constructs have more use cases that require removal and replacement of columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") now stores duplicate column keys
    as well as the same column in multiple positions. The `DedupeColumnCollection`
    class is added to maintain the former behavior in those cases where deduplication
    as well as additional replace/remove operations are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.sql.expression.ColumnCollection.add), [as_readonly()](#sqlalchemy.sql.expression.ColumnCollection.as_readonly),
    [clear()](#sqlalchemy.sql.expression.ColumnCollection.clear), [compare()](#sqlalchemy.sql.expression.ColumnCollection.compare),
    [contains_column()](#sqlalchemy.sql.expression.ColumnCollection.contains_column),
    [corresponding_column()](#sqlalchemy.sql.expression.ColumnCollection.corresponding_column),
    [get()](#sqlalchemy.sql.expression.ColumnCollection.get), [items()](#sqlalchemy.sql.expression.ColumnCollection.items),
    [keys()](#sqlalchemy.sql.expression.ColumnCollection.keys), [update()](#sqlalchemy.sql.expression.ColumnCollection.update),
    [values()](#sqlalchemy.sql.expression.ColumnCollection.values)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Add a column to this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is **not normally used by user-facing code**, as the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") is usually part of an existing object
    such as a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
    To add a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to an existing [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, use the [`Table.append_column()`](metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Return a “read only” form of this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary clear() is not implemented for [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Compare this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") to another based on the names of
    the keys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Checks if a column object exists in this collection
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Given a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement"),
    return the exported [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") object from this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which corresponds to that original
    [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    via a common ancestor column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`column` – the target [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") to be matched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require_embedded` – only return corresponding columns for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"), if the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") is actually present within a sub-element
    of this [`Selectable`](selectable.html#sqlalchemy.sql.expression.Selectable "sqlalchemy.sql.expression.Selectable").
    Normally the column will match if it merely shares a common ancestor with one
    of the exported columns of this [`Selectable`](selectable.html#sqlalchemy.sql.expression.Selectable
    "sqlalchemy.sql.expression.Selectable").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Selectable.corresponding_column()`](selectable.html#sqlalchemy.sql.expression.Selectable.corresponding_column
    "sqlalchemy.sql.expression.Selectable.corresponding_column") - invokes this method
    against the collection returned by [`Selectable.exported_columns`](selectable.html#sqlalchemy.sql.expression.Selectable.exported_columns
    "sqlalchemy.sql.expression.Selectable.exported_columns").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the implementation for `corresponding_column` was moved
    onto the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Get a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    or [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object based on a string key name from this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of (key, column) tuples for all columns in this collection
    each consisting of a string key name and a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") or [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of string key names for all columns in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary update() is not implemented for [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") or [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects for all columns in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Represent a column-oriented SQL expression suitable for usage in the “columns”
    clause, WHERE clause etc. of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: While the most familiar kind of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") is the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") serves as the basis for any unit that
    may be present in a SQL expression, including the expressions themselves, SQL
    functions, bound parameters, literal expressions, keywords such as `NULL`, etc.
    [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    is the ultimate base class for all such elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A wide variety of SQLAlchemy Core functions work at the SQL expression level,
    and are intended to accept instances of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as arguments. These functions will
    typically document that they accept a “SQL expression” as an argument. What this
    means in terms of SQLAlchemy usually refers to an input which is either already
    in the form of a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    object, or a value which can be **coerced** into one. The coercion rules followed
    by most, but not all, SQLAlchemy Core functions with regards to SQL expressions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a literal Python value, such as a string, integer or floating point value, boolean,
    datetime, `Decimal` object, or virtually any other Python object, will be coerced
    into a “literal bound value”. This generally means that a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") will be produced featuring the given value
    embedded into the construct; the resulting [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") object is an instance of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"). The Python value will ultimately be
    sent to the DBAPI at execution time as a parameterized argument to the `execute()`
    or `executemany()` methods, after SQLAlchemy type-specific converters (e.g. those
    provided by any associated [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) are applied to the value.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: any special object value, typically ORM-level constructs, which feature an accessor
    called `__clause_element__()`. The Core expression system looks for this method
    when an object of otherwise unknown type is passed to a function that is looking
    to coerce the argument into a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") and sometimes a [`SelectBase`](selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") expression. It is used within the ORM
    to convert from ORM-specific objects like mapped classes and mapped attributes
    into Core expression objects.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The Python `None` value is typically interpreted as `NULL`, which in SQLAlchemy
    Core produces an instance of [`null()`](#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null").
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    provides the ability to generate new [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects using Python expressions. This
    means that Python operators such as `==`, `!=` and `<` are overloaded to mimic
    SQL operations, and allow the instantiation of further [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") instances which are composed from other,
    more fundamental [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    objects. For example, two [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") objects can be added together with the
    addition operator `+` to produce a [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression"). Both [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") and [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") are subclasses of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__eq__()](#sqlalchemy.sql.expression.ColumnElement.__eq__), [__le__()](#sqlalchemy.sql.expression.ColumnElement.__le__),
    [__lt__()](#sqlalchemy.sql.expression.ColumnElement.__lt__), [__ne__()](#sqlalchemy.sql.expression.ColumnElement.__ne__),
    [all_()](#sqlalchemy.sql.expression.ColumnElement.all_), [allows_lambda](#sqlalchemy.sql.expression.ColumnElement.allows_lambda),
    [anon_key_label](#sqlalchemy.sql.expression.ColumnElement.anon_key_label), [anon_label](#sqlalchemy.sql.expression.ColumnElement.anon_label),
    [any_()](#sqlalchemy.sql.expression.ColumnElement.any_), [asc()](#sqlalchemy.sql.expression.ColumnElement.asc),
    [base_columns](#sqlalchemy.sql.expression.ColumnElement.base_columns), [between()](#sqlalchemy.sql.expression.ColumnElement.between),
    [bitwise_and()](#sqlalchemy.sql.expression.ColumnElement.bitwise_and), [bitwise_lshift()](#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift),
    [bitwise_not()](#sqlalchemy.sql.expression.ColumnElement.bitwise_not), [bitwise_or()](#sqlalchemy.sql.expression.ColumnElement.bitwise_or),
    [bitwise_rshift()](#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift), [bitwise_xor()](#sqlalchemy.sql.expression.ColumnElement.bitwise_xor),
    [bool_op()](#sqlalchemy.sql.expression.ColumnElement.bool_op), [cast()](#sqlalchemy.sql.expression.ColumnElement.cast),
    [collate()](#sqlalchemy.sql.expression.ColumnElement.collate), [comparator](#sqlalchemy.sql.expression.ColumnElement.comparator),
    [compare()](#sqlalchemy.sql.expression.ColumnElement.compare), [compile()](#sqlalchemy.sql.expression.ColumnElement.compile),
    [concat()](#sqlalchemy.sql.expression.ColumnElement.concat), [contains()](#sqlalchemy.sql.expression.ColumnElement.contains),
    [desc()](#sqlalchemy.sql.expression.ColumnElement.desc), [description](#sqlalchemy.sql.expression.ColumnElement.description),
    [distinct()](#sqlalchemy.sql.expression.ColumnElement.distinct), [endswith()](#sqlalchemy.sql.expression.ColumnElement.endswith),
    [entity_namespace](#sqlalchemy.sql.expression.ColumnElement.entity_namespace),
    [expression](#sqlalchemy.sql.expression.ColumnElement.expression), [foreign_keys](#sqlalchemy.sql.expression.ColumnElement.foreign_keys),
    [get_children()](#sqlalchemy.sql.expression.ColumnElement.get_children), [icontains()](#sqlalchemy.sql.expression.ColumnElement.icontains),
    [iendswith()](#sqlalchemy.sql.expression.ColumnElement.iendswith), [ilike()](#sqlalchemy.sql.expression.ColumnElement.ilike),
    [in_()](#sqlalchemy.sql.expression.ColumnElement.in_), [inherit_cache](#sqlalchemy.sql.expression.ColumnElement.inherit_cache),
    [is_()](#sqlalchemy.sql.expression.ColumnElement.is_), [is_clause_element](#sqlalchemy.sql.expression.ColumnElement.is_clause_element),
    [is_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.is_distinct_from),
    [is_dml](#sqlalchemy.sql.expression.ColumnElement.is_dml), [is_not()](#sqlalchemy.sql.expression.ColumnElement.is_not),
    [is_not_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from),
    [is_selectable](#sqlalchemy.sql.expression.ColumnElement.is_selectable), [isnot()](#sqlalchemy.sql.expression.ColumnElement.isnot),
    [isnot_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from),
    [istartswith()](#sqlalchemy.sql.expression.ColumnElement.istartswith), [key](#sqlalchemy.sql.expression.ColumnElement.key),
    [label()](#sqlalchemy.sql.expression.ColumnElement.label), [like()](#sqlalchemy.sql.expression.ColumnElement.like),
    [match()](#sqlalchemy.sql.expression.ColumnElement.match), [negation_clause](#sqlalchemy.sql.expression.ColumnElement.negation_clause),
    [not_ilike()](#sqlalchemy.sql.expression.ColumnElement.not_ilike), [not_in()](#sqlalchemy.sql.expression.ColumnElement.not_in),
    [not_like()](#sqlalchemy.sql.expression.ColumnElement.not_like), [notilike()](#sqlalchemy.sql.expression.ColumnElement.notilike),
    [notin_()](#sqlalchemy.sql.expression.ColumnElement.notin_), [notlike()](#sqlalchemy.sql.expression.ColumnElement.notlike),
    [nulls_first()](#sqlalchemy.sql.expression.ColumnElement.nulls_first), [nulls_last()](#sqlalchemy.sql.expression.ColumnElement.nulls_last),
    [nullsfirst()](#sqlalchemy.sql.expression.ColumnElement.nullsfirst), [nullslast()](#sqlalchemy.sql.expression.ColumnElement.nullslast),
    [op()](#sqlalchemy.sql.expression.ColumnElement.op), [operate()](#sqlalchemy.sql.expression.ColumnElement.operate),
    [params()](#sqlalchemy.sql.expression.ColumnElement.params), [primary_key](#sqlalchemy.sql.expression.ColumnElement.primary_key),
    [proxy_set](#sqlalchemy.sql.expression.ColumnElement.proxy_set), [regexp_match()](#sqlalchemy.sql.expression.ColumnElement.regexp_match),
    [regexp_replace()](#sqlalchemy.sql.expression.ColumnElement.regexp_replace), [reverse_operate()](#sqlalchemy.sql.expression.ColumnElement.reverse_operate),
    [self_group()](#sqlalchemy.sql.expression.ColumnElement.self_group), [shares_lineage()](#sqlalchemy.sql.expression.ColumnElement.shares_lineage),
    [startswith()](#sqlalchemy.sql.expression.ColumnElement.startswith), [stringify_dialect](#sqlalchemy.sql.expression.ColumnElement.stringify_dialect),
    [supports_execution](#sqlalchemy.sql.expression.ColumnElement.supports_execution),
    [timetuple](#sqlalchemy.sql.expression.ColumnElement.timetuple), [type](#sqlalchemy.sql.expression.ColumnElement.type),
    [unique_params()](#sqlalchemy.sql.expression.ColumnElement.unique_params), [uses_inspection](#sqlalchemy.sql.expression.ColumnElement.uses_inspection)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") (`sqlalchemy.sql.roles.ColumnArgumentOrKeyRole`,
    `sqlalchemy.sql.roles.StatementOptionRole`, `sqlalchemy.sql.roles.WhereHavingRole`,
    `sqlalchemy.sql.roles.BinaryElementRole`, `sqlalchemy.sql.roles.OrderByRole`,
    `sqlalchemy.sql.roles.ColumnsClauseRole`, `sqlalchemy.sql.roles.LimitOffsetRole`,
    `sqlalchemy.sql.roles.DMLColumnRole`, `sqlalchemy.sql.roles.DDLConstraintColumnRole`,
    `sqlalchemy.sql.roles.DDLExpressionRole`, [`sqlalchemy.sql.expression.SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression
    "sqlalchemy.sql.expression.SQLColumnExpression"), `sqlalchemy.sql.expression.DQLDMLClauseElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__eq__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a = b`. If the target is `None`, produces
    `a IS NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__le__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `<=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a <= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__lt__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a < b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__ne__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `!=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a != b`. If the target is `None`,
    produces `a IS NOT NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce an [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method with the **legacy** version
    of this method, the [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnElement.anon_key_label`](#sqlalchemy.sql.expression.ColumnElement.anon_key_label
    "sqlalchemy.sql.expression.ColumnElement.anon_key_label") attribute is now private,
    and the public accessor is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnElement.anon_label`](#sqlalchemy.sql.expression.ColumnElement.anon_label
    "sqlalchemy.sql.expression.ColumnElement.anon_label") attribute is now private,
    and the public accessor is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce an [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method with the **legacy** version
    of this method, the [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.asc()`](#sqlalchemy.sql.expression.ColumnOperators.asc
    "sqlalchemy.sql.expression.ColumnOperators.asc") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.between()`](#sqlalchemy.sql.expression.ColumnOperators.between
    "sqlalchemy.sql.expression.ColumnOperators.between") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    clause against the parent object, given the lower and upper range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_and()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_and
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_and") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise AND operation, typically via the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_lshift()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise LSHIFT operation, typically via the `<<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_not()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_not
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_not") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise NOT operation, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_or()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_or
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_or") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise OR operation, typically via the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_rshift()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise RSHIFT operation, typically via the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_xor()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_xor") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise XOR operation, typically via the `^` operator, or `#` for
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Produce a type cast, i.e. `CAST(<expression> AS <type>)`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a shortcut to the [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.collate()`](#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")
    clause against the parent object, given the collation string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.compare()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.compare
    "sqlalchemy.sql.expression.ClauseElement.compare") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") to the given [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses should override the default behavior, which is a straight identity
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw are arguments consumed by subclass `compare()` methods and may be used
    to modify the criteria for comparison (see [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `CompilerElement.compile()` *method of* `CompilerElement`'
  prefs: []
  type: TYPE_NORMAL
- en: Compile this SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. Calling `str()` or `unicode()` on the returned
    value will yield a string representation of the result. The [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object also can return a dictionary of bind parameter
    names and values using the `params` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – An [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    which can provide a [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in order to generate a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. If the `bind` and `dialect` parameters are
    both omitted, a default SQL compiler is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column_keys` – Used for INSERT and UPDATE statements, a list of column names
    which should be present in the VALUES clause of the compiled statement. If `None`,
    all columns from the target table object are rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dialect` – A [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    instance which can generate a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. This argument takes precedence over the
    `bind` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile_kwargs` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional dictionary of additional parameters that will be passed through to
    the compiler within all “visit” methods. This allows any custom flag to be passed
    through to a custom compilation construct, for example. It is also used for the
    case of passing the `literal_binds` flag through:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](../faq/sqlexpressions.html#faq-sql-expression-string)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.concat()`](#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘concat’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a || b`, or uses the `concat()` operator
    on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘contains’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the middle of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.contains.escape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.contains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.desc()`](#sqlalchemy.sql.expression.ColumnOperators.desc
    "sqlalchemy.sql.expression.ColumnOperators.desc") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ClauseElement.description` *attribute of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.distinct()`](#sqlalchemy.sql.expression.ColumnOperators.distinct
    "sqlalchemy.sql.expression.ColumnOperators.distinct") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘endswith’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the end of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.endswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ClauseElement.entity_namespace` *attribute of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Return a column expression.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the inspection interface; returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `HasTraverseInternals.get_children()` *method of* `HasTraverseInternals`'
  prefs: []
  type: TYPE_NORMAL
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used for visit traversal.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.icontains()`](#sqlalchemy.sql.expression.ColumnOperators.icontains
    "sqlalchemy.sql.expression.ColumnOperators.icontains") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `icontains` operator, e.g. case insensitive version of [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    middle of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.icontains.escape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.iendswith()`](#sqlalchemy.sql.expression.ColumnOperators.iendswith
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `iendswith` operator, e.g. case insensitive version of [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    end of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.iendswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `ilike` operator, e.g. case insensitive LIKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces an expression either of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on backends that support the ILIKE operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `column IN <other>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given parameter `other` may be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of literal values, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the list of items is converted to a set of bound parameters
    the same length as the list given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A list of tuples may be provided if the comparison is against a [`tuple_()`](#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") containing multiple expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An empty list, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders an “empty set” expression. These
    expressions are tailored to individual backends and are generally trying to get
    an empty SELECT statement as a subquery. Such as on SQLite, the expression is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 1.4: empty IN expressions now use an execution-time generated
    SELECT subquery in all cases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A bound parameter, e.g. [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"), may be used if it includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders a special non-SQL placeholder
    expression that looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This placeholder expression is intercepted at statement execution time to be
    converted into the variable number of bound parameter form illustrated earlier.
    If the statement were executed as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The database would be passed a bound parameter for each value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.2: added “expanding” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If an empty list is passed, a special “empty list” expression, which is specific
    to the database in use, is rendered. On SQLite this would be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.3: “expanding” bound parameters now support empty lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is usually a correlated scalar select:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") renders as given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** – a list of literals, a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, or a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct that includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag set to True.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `HasCacheKey.inherit_cache` *attribute of* [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey")'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS` may be desirable if
    comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS DISTINCT FROM b” on most platforms; on some such as SQLite may
    render “a IS NOT b”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_not_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from") *method of*
    [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.isnot()`](#sqlalchemy.sql.expression.ColumnOperators.isnot
    "sqlalchemy.sql.expression.ColumnOperators.isnot") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.isnot_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.istartswith()`](#sqlalchemy.sql.expression.ColumnOperators.istartswith
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `istartswith` operator, e.g. case insensitive version of [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    start of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.istartswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The ‘key’ that in some circumstances refers to this object in a Python namespace.
  prefs: []
  type: TYPE_NORMAL
- en: This typically refers to the “key” of the column as present in the `.c` collection
    of a selectable, e.g. `sometable.c["somekey"]` would return a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with a `.key` of “somekey”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Produce a column label, i.e. `<columnname> AS <name>`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a shortcut to the [`label()`](#sqlalchemy.sql.expression.label "sqlalchemy.sql.expression.label")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘name’ is `None`, an anonymous label name will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `like` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") attempts to resolve to a MATCH-like
    function or operator provided by the backend. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x @@ plainto_tsquery(y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `plainto_tsquery()` is used instead of `to_tsquery()`
    for PostgreSQL now; for compatibility with other forms, see [Full Text Search](../dialects/postgresql.html#postgresql-match).'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: MySQL - renders `MATCH (x) AGAINST (y IN BOOLEAN MODE)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    - MySQL specific construct with additional features.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Oracle - renders `CONTAINS(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “MATCH”.
    This is compatible with SQLite, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_ilike()`](#sqlalchemy.sql.expression.ColumnOperators.not_ilike
    "sqlalchemy.sql.expression.ColumnOperators.not_ilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_like()`](#sqlalchemy.sql.expression.ColumnOperators.not_like
    "sqlalchemy.sql.expression.ColumnOperators.not_like") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notilike()`](#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notin_()`](#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notlike()`](#sqlalchemy.sql.expression.ColumnOperators.notlike
    "sqlalchemy.sql.expression.ColumnOperators.notlike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nulls_first()`](#sqlalchemy.sql.expression.ColumnOperators.nulls_first
    "sqlalchemy.sql.expression.ColumnOperators.nulls_first") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nulls_last()`](#sqlalchemy.sql.expression.ColumnOperators.nulls_last
    "sqlalchemy.sql.expression.ColumnOperators.nulls_last") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nullsfirst()`](#sqlalchemy.sql.expression.ColumnOperators.nullsfirst
    "sqlalchemy.sql.expression.ColumnOperators.nullsfirst") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nullslast()`](#sqlalchemy.sql.expression.ColumnOperators.nullslast
    "sqlalchemy.sql.expression.ColumnOperators.nullslast") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.params
    "sqlalchemy.sql.expression.ClauseElement.params") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    elements replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a copy of this ClauseElement with [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") elements replaced with values taken from
    the given dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: set of all columns we are proxying
  prefs: []
  type: TYPE_NORMAL
- en: as of 2.0 this is explicitly deannotated columns. previously it was effectively
    deannotated columns but wasn’t enforced. annotated columns should basically not
    go into sets if at all possible because their hashing behavior is very non-performant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘regexp match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") attempts to resolve
    to a REGEXP-like function or operator provided by the backend, however the specific
    regular expression syntax and flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x ~ y` or `x !~ y` when negated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - renders `REGEXP_LIKE(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite - uses SQLite’s `REGEXP` placeholder operator and calls into the Python
    `re.match()` builtin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “REGEXP”
    or “NOT REGEXP”. This is compatible with SQLite and MySQL, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression support is currently implemented for Oracle, PostgreSQL,
    MySQL and MariaDB. Partial support is available for SQLite. Support among third-party
    dialects may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern. When
    using the ignore case flag ‘i’ in PostgreSQL, the ignore case regexp match operator
    `~*` or `!~*` will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘regexp replace’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") attempts to resolve
    to a REGEXP_REPLACE-like function provided by the backend, that usually emit the
    function `REGEXP_REPLACE()`. However, the specific regular expression syntax and
    flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression replacement support is currently implemented for Oracle,
    PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` – The replacement string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.ColumnElement.operate
    "sqlalchemy.sql.expression.ColumnElement.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") has a common ancestor to this [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `startswith` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the start of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.startswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.timetuple`](#sqlalchemy.sql.expression.ColumnOperators.timetuple
    "sqlalchemy.sql.expression.ColumnOperators.timetuple") *attribute of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Hack, allows datetime objects to be compared on the LHS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.unique_params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.unique_params
    "sqlalchemy.sql.expression.ClauseElement.unique_params") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    elements replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Same functionality as [`ClauseElement.params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.params
    "sqlalchemy.sql.expression.ClauseElement.params"), except adds unique=True to
    affected bind parameters so that multiple statements can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: General purpose “column expression” argument.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.13.
  prefs: []
  type: TYPE_NORMAL
- en: This type is used for “column” kinds of expressions that typically represent
    a single SQL column expression, including [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"), as well as ORM-mapped attributes that
    will have a `__clause_element__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Defines boolean, comparison, and other operators for [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all methods call down to [`operate()`](#sqlalchemy.sql.expression.ColumnOperators.operate
    "sqlalchemy.sql.expression.ColumnOperators.operate") or [`reverse_operate()`](#sqlalchemy.sql.expression.ColumnOperators.reverse_operate
    "sqlalchemy.sql.expression.ColumnOperators.reverse_operate"), passing in the appropriate
    operator function from the Python builtin `operator` module or a SQLAlchemy-specific
    operator function from `sqlalchemy.expression.operators`. For example the `__eq__`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `operators.eq` is essentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: The core column expression unit [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") overrides [`Operators.operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate") and others to return further [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs, so that the `==` operation
    above is replaced by a clause construct.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator "sqlalchemy.orm.PropComparator")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__add__()](#sqlalchemy.sql.expression.ColumnOperators.__add__), [__and__()](#sqlalchemy.sql.expression.ColumnOperators.__and__),
    [__eq__()](#sqlalchemy.sql.expression.ColumnOperators.__eq__), [__floordiv__()](#sqlalchemy.sql.expression.ColumnOperators.__floordiv__),
    [__ge__()](#sqlalchemy.sql.expression.ColumnOperators.__ge__), [__getitem__()](#sqlalchemy.sql.expression.ColumnOperators.__getitem__),
    [__gt__()](#sqlalchemy.sql.expression.ColumnOperators.__gt__), [__hash__()](#sqlalchemy.sql.expression.ColumnOperators.__hash__),
    [__invert__()](#sqlalchemy.sql.expression.ColumnOperators.__invert__), [__le__()](#sqlalchemy.sql.expression.ColumnOperators.__le__),
    [__lshift__()](#sqlalchemy.sql.expression.ColumnOperators.__lshift__), [__lt__()](#sqlalchemy.sql.expression.ColumnOperators.__lt__),
    [__mod__()](#sqlalchemy.sql.expression.ColumnOperators.__mod__), [__mul__()](#sqlalchemy.sql.expression.ColumnOperators.__mul__),
    [__ne__()](#sqlalchemy.sql.expression.ColumnOperators.__ne__), [__neg__()](#sqlalchemy.sql.expression.ColumnOperators.__neg__),
    [__or__()](#sqlalchemy.sql.expression.ColumnOperators.__or__), [__radd__()](#sqlalchemy.sql.expression.ColumnOperators.__radd__),
    [__rfloordiv__()](#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__), [__rmod__()](#sqlalchemy.sql.expression.ColumnOperators.__rmod__),
    [__rmul__()](#sqlalchemy.sql.expression.ColumnOperators.__rmul__), [__rshift__()](#sqlalchemy.sql.expression.ColumnOperators.__rshift__),
    [__rsub__()](#sqlalchemy.sql.expression.ColumnOperators.__rsub__), [__rtruediv__()](#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__),
    [__sa_operate__()](#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__),
    [__sub__()](#sqlalchemy.sql.expression.ColumnOperators.__sub__), [__truediv__()](#sqlalchemy.sql.expression.ColumnOperators.__truediv__),
    [all_()](#sqlalchemy.sql.expression.ColumnOperators.all_), [any_()](#sqlalchemy.sql.expression.ColumnOperators.any_),
    [asc()](#sqlalchemy.sql.expression.ColumnOperators.asc), [between()](#sqlalchemy.sql.expression.ColumnOperators.between),
    [bitwise_and()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_and), [bitwise_lshift()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift),
    [bitwise_not()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_not), [bitwise_or()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_or),
    [bitwise_rshift()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift),
    [bitwise_xor()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor), [bool_op()](#sqlalchemy.sql.expression.ColumnOperators.bool_op),
    [collate()](#sqlalchemy.sql.expression.ColumnOperators.collate), [concat()](#sqlalchemy.sql.expression.ColumnOperators.concat),
    [contains()](#sqlalchemy.sql.expression.ColumnOperators.contains), [desc()](#sqlalchemy.sql.expression.ColumnOperators.desc),
    [distinct()](#sqlalchemy.sql.expression.ColumnOperators.distinct), [endswith()](#sqlalchemy.sql.expression.ColumnOperators.endswith),
    [icontains()](#sqlalchemy.sql.expression.ColumnOperators.icontains), [iendswith()](#sqlalchemy.sql.expression.ColumnOperators.iendswith),
    [ilike()](#sqlalchemy.sql.expression.ColumnOperators.ilike), [in_()](#sqlalchemy.sql.expression.ColumnOperators.in_),
    [is_()](#sqlalchemy.sql.expression.ColumnOperators.is_), [is_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from),
    [is_not()](#sqlalchemy.sql.expression.ColumnOperators.is_not), [is_not_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from),
    [isnot()](#sqlalchemy.sql.expression.ColumnOperators.isnot), [isnot_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from),
    [istartswith()](#sqlalchemy.sql.expression.ColumnOperators.istartswith), [like()](#sqlalchemy.sql.expression.ColumnOperators.like),
    [match()](#sqlalchemy.sql.expression.ColumnOperators.match), [not_ilike()](#sqlalchemy.sql.expression.ColumnOperators.not_ilike),
    [not_in()](#sqlalchemy.sql.expression.ColumnOperators.not_in), [not_like()](#sqlalchemy.sql.expression.ColumnOperators.not_like),
    [notilike()](#sqlalchemy.sql.expression.ColumnOperators.notilike), [notin_()](#sqlalchemy.sql.expression.ColumnOperators.notin_),
    [notlike()](#sqlalchemy.sql.expression.ColumnOperators.notlike), [nulls_first()](#sqlalchemy.sql.expression.ColumnOperators.nulls_first),
    [nulls_last()](#sqlalchemy.sql.expression.ColumnOperators.nulls_last), [nullsfirst()](#sqlalchemy.sql.expression.ColumnOperators.nullsfirst),
    [nullslast()](#sqlalchemy.sql.expression.ColumnOperators.nullslast), [op()](#sqlalchemy.sql.expression.ColumnOperators.op),
    [operate()](#sqlalchemy.sql.expression.ColumnOperators.operate), [regexp_match()](#sqlalchemy.sql.expression.ColumnOperators.regexp_match),
    [regexp_replace()](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace),
    [reverse_operate()](#sqlalchemy.sql.expression.ColumnOperators.reverse_operate),
    [startswith()](#sqlalchemy.sql.expression.ColumnOperators.startswith), [timetuple](#sqlalchemy.sql.expression.ColumnOperators.timetuple)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") ([`sqlalchemy.sql.expression.Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a + b` if the parent object has non-string
    affinity. If the parent object has a string affinity, produces the concatenation
    operator, `a || b` - see [`ColumnOperators.concat()`](#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__and__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an AND operation, equivalent to
    [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"),
    that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `&` regarding operator precedence; the `&`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a = b`. If the target is `None`, produces
    `a IS NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `//` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a / b`, which is the same as “truediv”,
    but considers the result type to be integer.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `>=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a >= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Implement the [] operator.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used by some database-specific types such as PostgreSQL ARRAY and
    HSTORE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a > b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Return hash(self).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__invert__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in a NOT operation, equivalent to [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `<=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a <= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: implement the << operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not used by SQLAlchemy core, this is provided for custom operator systems which
    want to use << as an extension point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a < b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `%` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a % b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a * b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `!=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a != b`. If the target is `None`,
    produces `a IS NOT NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `-a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__or__` *method of*
    [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an OR operation, equivalent to [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `|` regarding operator precedence; the `|`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `+` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__add__()`](#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `//` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__floordiv__()`](#sqlalchemy.sql.expression.ColumnOperators.__floordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__floordiv__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `%` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__mod__()`](#sqlalchemy.sql.expression.ColumnOperators.__mod__
    "sqlalchemy.sql.expression.ColumnOperators.__mod__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `*` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__mul__()`](#sqlalchemy.sql.expression.ColumnOperators.__mul__
    "sqlalchemy.sql.expression.ColumnOperators.__mul__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: implement the >> operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not used by SQLAlchemy core, this is provided for custom operator systems which
    want to use >> as an extension point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__sub__()`](#sqlalchemy.sql.expression.ColumnOperators.__sub__
    "sqlalchemy.sql.expression.ColumnOperators.__sub__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `/` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__truediv__()`](#sqlalchemy.sql.expression.ColumnOperators.__truediv__
    "sqlalchemy.sql.expression.ColumnOperators.__truediv__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__sa_operate__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a - b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `/` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a / b`, and considers the result type
    to be numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The truediv operator against two integers is now considered
    to return a numeric value. Behavior on specific backends may vary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method with the **legacy** version
    of this method, the [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method with the **legacy** version
    of this method, the [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    clause against the parent object, given the lower and upper range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise AND operation, typically via the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise LSHIFT operation, typically via the `<<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise NOT operation, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise OR operation, typically via the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise RSHIFT operation, typically via the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise XOR operation, typically via the `^` operator, or `#` for
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")
    clause against the parent object, given the collation string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘concat’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a || b`, or uses the `concat()` operator
    on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘contains’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the middle of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.contains.escape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.contains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘endswith’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the end of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.endswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `icontains` operator, e.g. case insensitive version of [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    middle of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.icontains.escape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `iendswith` operator, e.g. case insensitive version of [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    end of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.iendswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `ilike` operator, e.g. case insensitive LIKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces an expression either of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on backends that support the ILIKE operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `column IN <other>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given parameter `other` may be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of literal values, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the list of items is converted to a set of bound parameters
    the same length as the list given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A list of tuples may be provided if the comparison is against a [`tuple_()`](#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") containing multiple expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An empty list, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders an “empty set” expression. These
    expressions are tailored to individual backends and are generally trying to get
    an empty SELECT statement as a subquery. Such as on SQLite, the expression is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 1.4: empty IN expressions now use an execution-time generated
    SELECT subquery in all cases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A bound parameter, e.g. [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"), may be used if it includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders a special non-SQL placeholder
    expression that looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This placeholder expression is intercepted at statement execution time to be
    converted into the variable number of bound parameter form illustrated earlier.
    If the statement were executed as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The database would be passed a bound parameter for each value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.2: added “expanding” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If an empty list is passed, a special “empty list” expression, which is specific
    to the database in use, is rendered. On SQLite this would be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.3: “expanding” bound parameters now support empty lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is usually a correlated scalar select:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") renders as given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** – a list of literals, a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, or a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct that includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag set to True.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS` may be desirable if
    comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS DISTINCT FROM b” on most platforms; on some such as SQLite may
    render “a IS NOT b”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `istartswith` operator, e.g. case insensitive version of [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    start of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.istartswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `like` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") attempts to resolve to a MATCH-like
    function or operator provided by the backend. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x @@ plainto_tsquery(y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `plainto_tsquery()` is used instead of `to_tsquery()`
    for PostgreSQL now; for compatibility with other forms, see [Full Text Search](../dialects/postgresql.html#postgresql-match).'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: MySQL - renders `MATCH (x) AGAINST (y IN BOOLEAN MODE)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    - MySQL specific construct with additional features.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Oracle - renders `CONTAINS(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “MATCH”.
    This is compatible with SQLite, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘regexp match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") attempts to resolve
    to a REGEXP-like function or operator provided by the backend, however the specific
    regular expression syntax and flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x ~ y` or `x !~ y` when negated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - renders `REGEXP_LIKE(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite - uses SQLite’s `REGEXP` placeholder operator and calls into the Python
    `re.match()` builtin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “REGEXP”
    or “NOT REGEXP”. This is compatible with SQLite and MySQL, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression support is currently implemented for Oracle, PostgreSQL,
    MySQL and MariaDB. Partial support is available for SQLite. Support among third-party
    dialects may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern. When
    using the ignore case flag ‘i’ in PostgreSQL, the ignore case regexp match operator
    `~*` or `!~*` will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘regexp replace’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") attempts to resolve
    to a REGEXP_REPLACE-like function provided by the backend, that usually emit the
    function `REGEXP_REPLACE()`. However, the specific regular expression syntax and
    flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression replacement support is currently implemented for Oracle,
    PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` – The replacement string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.reverse_operate()`](#sqlalchemy.sql.expression.Operators.reverse_operate
    "sqlalchemy.sql.expression.Operators.reverse_operate") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.ColumnOperators.operate
    "sqlalchemy.sql.expression.ColumnOperators.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `startswith` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the start of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.startswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: Hack, allows datetime objects to be compared on the LHS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL EXTRACT clause, `extract(field FROM expr)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Extract`](#sqlalchemy.sql.expression.Extract
    "sqlalchemy.sql.expression.Extract") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Represent the `false` keyword, or equivalent, in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`False_`](#sqlalchemy.sql.expression.False_ "sqlalchemy.sql.expression.False_")
    is accessed as a constant via the [`false()`](#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.False_`](#sqlalchemy.sql.expression.False_
    "sqlalchemy.sql.expression.False_") (`sqlalchemy.sql.expression.SingletonConstant`,
    `sqlalchemy.sql.roles.ConstExprRole`, [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Represent a function FILTER clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against aggregate and window functions, which controls
    which rows are passed to it. It’s supported only by certain database backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invocation of [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter") is via [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[filter()](#sqlalchemy.sql.expression.FunctionFilter.filter), [over()](#sqlalchemy.sql.expression.FunctionFilter.over),
    [self_group()](#sqlalchemy.sql.expression.FunctionFilter.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Produce an additional FILTER against the function.
  prefs: []
  type: TYPE_NORMAL
- en: This method adds additional criteria to the initial criteria set up by [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter").
  prefs: []
  type: TYPE_NORMAL
- en: Multiple criteria are joined together at SQL render time via `AND`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Produce an OVER clause against this filtered function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate or so-called “window” functions, for database backends
    that support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'is shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: See [`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")
    for a full description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.FunctionFilter.self_group
    "sqlalchemy.sql.expression.FunctionFilter.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.FunctionFilter.self_group
    "sqlalchemy.sql.expression.FunctionFilter.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Represents a column label (AS).
  prefs: []
  type: TYPE_NORMAL
- en: Represent a label, as typically applied to any column-level element using the
    `AS` sql keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[foreign_keys](#sqlalchemy.sql.expression.Label.foreign_keys), [primary_key](#sqlalchemy.sql.expression.Label.primary_key),
    [self_group()](#sqlalchemy.sql.expression.Label.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    (`sqlalchemy.sql.roles.LabeledColumnExprRole`, `sqlalchemy.sql.expression.NamedColumn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.Label.self_group
    "sqlalchemy.sql.expression.Label.self_group") is automatic - end-user code should
    never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.Label.self_group "sqlalchemy.sql.expression.Label.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Represent the NULL keyword in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    is accessed as a constant via the [`null()`](#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    (`sqlalchemy.sql.expression.SingletonConstant`, `sqlalchemy.sql.roles.ConstExprRole`,
    [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: Base of comparison and logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Implements base methods `Operators.operate()` and `Operators.reverse_operate()`,
    as well as `Operators.__and__()`, `Operators.__or__()`, `Operators.__invert__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__and__()](#sqlalchemy.sql.expression.Operators.__and__), [__invert__()](#sqlalchemy.sql.expression.Operators.__invert__),
    [__or__()](#sqlalchemy.sql.expression.Operators.__or__), [__sa_operate__()](#sqlalchemy.sql.expression.Operators.__sa_operate__),
    [bool_op()](#sqlalchemy.sql.expression.Operators.bool_op), [op()](#sqlalchemy.sql.expression.Operators.op),
    [operate()](#sqlalchemy.sql.expression.Operators.operate), [reverse_operate()](#sqlalchemy.sql.expression.Operators.reverse_operate)'
  prefs: []
  type: TYPE_NORMAL
- en: Usually is used via its most common subclass [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an AND operation, equivalent to
    [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"),
    that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `&` regarding operator precedence; the `&`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in a NOT operation, equivalent to [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an OR operation, equivalent to [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `|` regarding operator precedence; the `|`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Represent an OVER clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against a so-called “window” function, as well as
    any aggregate function, which produces results relative to the result set itself.
    Most modern SQL backends now support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[element](#sqlalchemy.sql.expression.Over.element)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: The underlying expression object to which this [`Over`](#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") object refers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: A type that may be used to indicate any SQL column element or object that acts
    in place of one.
  prefs: []
  type: TYPE_NORMAL
- en: '[`SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression "sqlalchemy.sql.expression.SQLColumnExpression")
    is a base of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement"),
    as well as within the bases of ORM elements such as [`InstrumentedAttribute`](../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute"), and may be used in [**PEP 484**](https://peps.python.org/pep-0484/)
    typing to indicate arguments or return values that should behave as column expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0b4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression
    "sqlalchemy.sql.expression.SQLColumnExpression") (`sqlalchemy.sql.expression.SQLCoreOperations`,
    `sqlalchemy.sql.roles.ExpressionElementRole`, `sqlalchemy.util.langhelpers.TypingOnly`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Represent a literal SQL text fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: The [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    construct is produced using the [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    function; see that function for full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[bindparams()](#sqlalchemy.sql.expression.TextClause.bindparams), [columns()](#sqlalchemy.sql.expression.TextClause.columns),
    [self_group()](#sqlalchemy.sql.expression.TextClause.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") (`sqlalchemy.sql.roles.DDLConstraintColumnRole`,
    `sqlalchemy.sql.roles.DDLExpressionRole`, `sqlalchemy.sql.roles.StatementOptionRole`,
    `sqlalchemy.sql.roles.WhereHavingRole`, `sqlalchemy.sql.roles.OrderByRole`, `sqlalchemy.sql.roles.FromClauseRole`,
    `sqlalchemy.sql.roles.SelectStatementRole`, `sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.expression.Generative`, [`sqlalchemy.sql.expression.Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable"), `sqlalchemy.sql.expression.DQLDMLClauseElement`,
    `sqlalchemy.sql.roles.BinaryElementRole`, `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Establish the values and/or types of bound parameters within this [`TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a text construct such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'the [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method can be used to establish
    the initial value of `:name` and `:timestamp`, using simple keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Where above, new [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects will be generated with the
    names `name` and `timestamp`, and values of `jack` and `datetime.datetime(2012,
    10, 8, 15, 12, 5)`, respectively. The types will be inferred from the values given,
    in this case [`String`](type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`DateTime`](type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'When specific typing behavior is needed, the positional `*binds` argument can
    be used in which to specify [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs directly. These constructs must
    include at least the `key` argument, then an optional value and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Above, we specified the type of [`DateTime`](type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") for the `timestamp` bind, and the type of [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") for the `name` bind. In the case of `name` we also
    set the default value of `"jack"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional bound parameters can be supplied at statement execution time, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method can be called repeatedly,
    where it will re-use existing [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects to add new information. For
    example, we can call [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") first with typing information,
    and a second time with value information, and it will be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method also supports the concept
    of **unique** bound parameters. These are parameters that are “uniquified” on
    name at statement compilation time, so that multiple [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs may be combined together without
    the names conflicting. To use this feature, specify the [`BindParameter.unique`](#sqlalchemy.sql.expression.BindParameter.params.unique
    "sqlalchemy.sql.expression.BindParameter") flag on each [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.11: Added support for the [`BindParameter.unique`](#sqlalchemy.sql.expression.BindParameter.params.unique
    "sqlalchemy.sql.expression.BindParameter") flag to work with [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: Turn this [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    object into a [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object that serves the same role as
    a SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: The [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") is part of the [`SelectBase`](selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") hierarchy and can be embedded into another
    statement by using the [`TextualSelect.subquery()`](selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") method to produce a [`Subquery`](selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, which can then be SELECTed from.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function essentially bridges the gap between an entirely textual SELECT
    statement and the SQL expression language concept of a “selectable”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: Above, we pass a series of [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    elements to the [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method positionally. These [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") elements now become first class elements upon
    the [`TextualSelect.selected_columns`](selectable.html#sqlalchemy.sql.expression.TextualSelect.selected_columns
    "sqlalchemy.sql.expression.TextualSelect.selected_columns") column collection,
    which then become part of the `Subquery.c` collection after [`TextualSelect.subquery()`](selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The column expressions we pass to [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") may also be typed; when we do
    so, these [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects become the effective return type of the column, so that SQLAlchemy’s result-set-processing
    systems may be used on the return values. This is often needed for types such
    as date or boolean types, as well as for unicode processing on some dialect configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'As a shortcut to the above syntax, keyword arguments referring to types alone
    may be used, if only type conversion is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'The positional form of [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") also provides the unique feature
    of **positional column targeting**, which is particularly useful when using the
    ORM with complex textual queries. If we specify the columns from our model to
    [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns "sqlalchemy.sql.expression.TextClause.columns"),
    the result set will match to those columns positionally, meaning the name or origin
    of the column in the textual SQL doesn’t matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method provides a direct route
    to calling `FromClause.subquery()` as well as [`SelectBase.cte()`](selectable.html#sqlalchemy.sql.expression.SelectBase.cte
    "sqlalchemy.sql.expression.SelectBase.cte") against a textual SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*cols` – A series of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects, typically [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects from a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or ORM level column-mapped attributes, representing
    a set of columns that this textual string will SELECT from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**types` – A mapping of string names to [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") type objects indicating the datatypes to use for
    names that are SELECTed from the textual string. Prefer to use the `*cols` argument
    as it also indicates positional ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.TextClause.self_group
    "sqlalchemy.sql.expression.TextClause.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.TextClause.self_group "sqlalchemy.sql.expression.TextClause.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Represent a TRY_CAST expression.
  prefs: []
  type: TYPE_NORMAL
- en: Details on [`TryCast`](#sqlalchemy.sql.expression.TryCast "sqlalchemy.sql.expression.TryCast")
    usage is at [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.sql.expression.TryCast.inherit_cache)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TryCast`](#sqlalchemy.sql.expression.TryCast
    "sqlalchemy.sql.expression.TryCast") ([`sqlalchemy.sql.expression.Cast`](#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.Tuple.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple")
    ([`sqlalchemy.sql.expression.ClauseList`](#sqlalchemy.sql.expression.ClauseList
    "sqlalchemy.sql.expression.ClauseList"), [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.Tuple.self_group
    "sqlalchemy.sql.expression.Tuple.self_group") is automatic - end-user code should
    never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.Tuple.self_group "sqlalchemy.sql.expression.Tuple.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: Represent a WITHIN GROUP (ORDER BY) clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against so-called “ordered set aggregate” and “hypothetical
    set aggregate” functions, including `percentile_cont()`, `rank()`, `dense_rank()`,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: It’s supported only by certain database backends, such as PostgreSQL, Oracle
    and MS SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    construct extracts its type from the method [`FunctionElement.within_group_type()`](functions.html#sqlalchemy.sql.functions.FunctionElement.within_group_type
    "sqlalchemy.sql.functions.FunctionElement.within_group_type"). If this returns
    `None`, the function’s `.type` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[over()](#sqlalchemy.sql.expression.WithinGroup.over)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Produce an OVER clause against this [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup") construct.
  prefs: []
  type: TYPE_NORMAL
- en: This function has the same signature as that of [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as a wrapper with special labeling
    behavior for an expression that already has a name.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved column labeling for simple column expressions using CAST or similar](../changelog/migration_14.html#change-4449)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.sql.expression.WrapsColumnExpression` ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: Represent the `true` keyword, or equivalent, in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    is accessed as a constant via the [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    (`sqlalchemy.sql.expression.SingletonConstant`, `sqlalchemy.sql.roles.ConstExprRole`,
    [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python-side type-coercion wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce "sqlalchemy.sql.expression.TypeCoerce")
    supplies the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    function; see that function for usage details.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.TypeCoerce.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") (`sqlalchemy.sql.expression.WrapsColumnExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group "sqlalchemy.sql.expression.TypeCoerce.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Define a ‘unary’ expression.
  prefs: []
  type: TYPE_NORMAL
- en: A unary expression has a single column expression and an operator. The operator
    can be placed on the left (where it is called the ‘operator’) or right (where
    it is called the ‘modifier’) of the column expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`UnaryExpression`](#sqlalchemy.sql.expression.UnaryExpression "sqlalchemy.sql.expression.UnaryExpression")
    is the basis for several unary operators including those used by [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc"),
    [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct"),
    [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    and [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.UnaryExpression.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.UnaryExpression`](#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.UnaryExpression.self_group
    "sqlalchemy.sql.expression.UnaryExpression.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.UnaryExpression.self_group
    "sqlalchemy.sql.expression.UnaryExpression.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: Column Element Typing Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standalone utility functions imported from the `sqlalchemy` namespace to improve
    support by type checkers.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [NotNullable](#sqlalchemy.NotNullable)(val) | Types a column or ORM class
    as not nullable. |'
  prefs: []
  type: TYPE_TB
- en: '| [Nullable](#sqlalchemy.Nullable)(val) | Types a column or ORM class as nullable.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Types a column or ORM class as not nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be used in select and other contexts to express that the value of
    a column cannot be null, for example due to a where condition on a nullable column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: At runtime this method returns the input unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.20.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Types a column or ORM class as nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be used in select and other contexts to express that the value of
    a column can be null, for example due to an outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: At runtime this method returns the input unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.20.
  prefs: []
  type: TYPE_NORMAL
- en: '## Column Element Foundational Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone functions imported from the `sqlalchemy` namespace which are used
    when building up SQLAlchemy Expression Language constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [and_](#sqlalchemy.sql.expression.and_)(*clauses) | Produce a conjunction
    of expressions joined by `AND`. |'
  prefs: []
  type: TYPE_TB
- en: '| [bindparam](#sqlalchemy.sql.expression.bindparam)(key[, value, type_, unique,
    ...]) | Produce a “bound expression”. |'
  prefs: []
  type: TYPE_TB
- en: '| [bitwise_not](#sqlalchemy.sql.expression.bitwise_not)(expr) | Produce a unary
    bitwise NOT clause, typically via the `~` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [case](#sqlalchemy.sql.expression.case)(*whens, [value, else_]) | Produce
    a `CASE` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [cast](#sqlalchemy.sql.expression.cast)(expression, type_) | Produce a `CAST`
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [column](#sqlalchemy.sql.expression.column)(text[, type_, is_literal, _selectable])
    | Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| [custom_op](#sqlalchemy.sql.expression.custom_op) | Represent a ‘custom’
    operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [distinct](#sqlalchemy.sql.expression.distinct)(expr) | Produce an column-expression-level
    unary `DISTINCT` clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [extract](#sqlalchemy.sql.expression.extract)(field, expr) | Return a [`Extract`](#sqlalchemy.sql.expression.Extract
    "sqlalchemy.sql.expression.Extract") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [false](#sqlalchemy.sql.expression.false)() | Return a [`False_`](#sqlalchemy.sql.expression.False_
    "sqlalchemy.sql.expression.False_") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [func](#sqlalchemy.sql.expression.func) | Generate SQL function expressions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [lambda_stmt](#sqlalchemy.sql.expression.lambda_stmt)(lmb[, enable_tracking,
    track_closure_variables, track_on, ...]) | Produce a SQL statement that is cached
    as a lambda. |'
  prefs: []
  type: TYPE_TB
- en: '| [literal](#sqlalchemy.sql.expression.literal)(value[, type_, literal_execute])
    | Return a literal clause, bound to a bind parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| [literal_column](#sqlalchemy.sql.expression.literal_column)(text[, type_])
    | Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object that has the [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal
    "sqlalchemy.sql.expression.column") flag set to True. |'
  prefs: []
  type: TYPE_TB
- en: '| [not_](#sqlalchemy.sql.expression.not_)(clause) | Return a negation of the
    given clause, i.e. `NOT(clause)`. |'
  prefs: []
  type: TYPE_TB
- en: '| [null](#sqlalchemy.sql.expression.null)() | Return a constant [`Null`](#sqlalchemy.sql.expression.Null
    "sqlalchemy.sql.expression.Null") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [or_](#sqlalchemy.sql.expression.or_)(*clauses) | Produce a conjunction of
    expressions joined by `OR`. |'
  prefs: []
  type: TYPE_TB
- en: '| [outparam](#sqlalchemy.sql.expression.outparam)(key[, type_]) | Create an
    ‘OUT’ parameter for usage in functions (stored procedures), for databases which
    support them. |'
  prefs: []
  type: TYPE_TB
- en: '| [quoted_name](#sqlalchemy.sql.expression.quoted_name) | Represent a SQL identifier
    combined with quoting preferences. |'
  prefs: []
  type: TYPE_TB
- en: '| [text](#sqlalchemy.sql.expression.text)(text) | Construct a new [`TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") clause, representing a textual SQL string
    directly. |'
  prefs: []
  type: TYPE_TB
- en: '| [true](#sqlalchemy.sql.expression.true)() | Return a constant [`True_`](#sqlalchemy.sql.expression.True_
    "sqlalchemy.sql.expression.True_") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [try_cast](#sqlalchemy.sql.expression.try_cast)(expression, type_) | Produce
    a `TRY_CAST` expression for backends which support it; this is a `CAST` which
    returns NULL for un-castable conversions. |'
  prefs: []
  type: TYPE_TB
- en: '| [tuple_](#sqlalchemy.sql.expression.tuple_)(*clauses, [types]) | Return a
    [`Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple").
    |'
  prefs: []
  type: TYPE_TB
- en: '| [type_coerce](#sqlalchemy.sql.expression.type_coerce)(expression, type_)
    | Associate a SQL expression with a particular type, without rendering `CAST`.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: Produce a conjunction of expressions joined by `AND`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    conjunction is also available using the Python `&` operator (though note that
    compound expressions need to be parenthesized in order to function with Python
    operator precedence behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    operation is also implicit in some cases; the [`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method for example can be invoked multiple
    times against a statement, which will have the effect of each clause being combined
    using [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct must be given at least one positional argument in order to be valid;
    a [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct with no arguments is ambiguous. To produce an “empty” or dynamically
    generated [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    expression, from a given list of expressions, a “default” element of [`true()`](#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") (or just `True`) should be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: The above expression will compile to SQL as the expression `true` or `1 = 1`,
    depending on backend, if no other expressions are present. If expressions are
    present, then the [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    value is ignored as it does not affect the outcome of an AND expression that has
    other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") element now requires that at least one argument
    is passed; creating the [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    construct with no arguments is deprecated, and will emit a deprecation warning
    while continuing to produce a blank SQL string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: Produce a “bound expression”.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an instance of [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter"); this is a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass which represents a so-called
    “placeholder” value in a SQL expression, the value of which is supplied at the
    point at which the statement in executed against a database connection.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, the [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    construct has the ability to carry along the actual value that will be ultimately
    used at expression time. In this way, it serves not just as a “placeholder” for
    eventual population, but also as a means of representing so-called “unsafe” values
    which should not be rendered directly in a SQL statement, but rather should be
    passed along to the [DBAPI](../glossary.html#term-DBAPI) as values which need
    to be correctly escaped and potentially handled for type-safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    explicitly, the use case is typically one of traditional deferment of parameters;
    the [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    construct accepts a name which can then be referred to at execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement, when rendered, will produce SQL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to populate the value of `:username` above, the value would typically
    be applied at execution time to a method like [`Connection.execute()`](connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicit use of [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is also common when producing UPDATE or DELETE statements that are to be invoked
    multiple times, where the WHERE criterion of the statement is to change on each
    invocation, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy’s Core expression system makes wide use of [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") in an implicit sense. It is typical that
    Python literal values passed to virtually all SQL expression functions are coerced
    into fixed [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    constructs. For example, given a comparison operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: 'The above expression will produce a [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") construct, where the left side is
    the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object representing the `name` column, and the right side is a [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") representing the literal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression above will render SQL such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `:name_1` parameter name is an anonymous name. The actual string
    `Wendy` is not in the rendered string, but is carried along where it is later
    used within statement execution. If we invoke a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'We would see SQL logging output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that `Wendy` is passed as a parameter to the database, while the
    placeholder `:name_1` is rendered in the appropriate form for the target database,
    in this case the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is invoked automatically when working with [CRUD](../glossary.html#term-CRUD)
    statements as far as the “VALUES” portion is concerned. The [`insert()`](dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct produces an `INSERT` expression
    which will, at statement execution time, generate bound placeholders based on
    the arguments passed, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will produce SQL output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: The [`Insert`](dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct, at compilation/execution time, rendered a single [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") mirroring the column name `name` as a result
    of the single `name` parameter we passed to the [`Connection.execute()`](connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the key (e.g. the name) for this bind param. Will be used in the generated SQL
    statement for dialects that use named parameters. This value may be modified when
    part of a compilation operation, if other [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects exist with the same key, or
    if its length is too long and truncation is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If omitted, an “anonymous” name is generated for the bound parameter; when given
    a value to bind, the end result is equivalent to calling upon the [`literal()`](#sqlalchemy.sql.expression.literal
    "sqlalchemy.sql.expression.literal") function with a value to bind, particularly
    if the [`bindparam.unique`](#sqlalchemy.sql.expression.bindparam.params.unique
    "sqlalchemy.sql.expression.bindparam") parameter is also provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`value` – Initial value for this bind param. Will be used at statement execution
    time as the value for this parameter passed to the DBAPI, if no other value is
    indicated to the statement execution method for this particular parameter name.
    Defaults to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – A callable function that takes the place of “value”. The function
    will be called at statement execution time to determine the ultimate value. Used
    for scenarios where the actual bind value cannot be determined at the point at
    which the clause construct is created, but embedded bind values are still desirable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance representing an optional datatype for this [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"). If not passed, a type may be determined
    automatically for the bind, based on the given value; for example, trivial Python
    types such as `str`, `int`, `bool` may result in the [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") or [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") types being automatically selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type of a [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    is significant especially in that the type will apply pre-processing to the value
    before it is passed to the database. For example, a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") which refers to a datetime value, and is
    specified as holding the [`DateTime`](type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") type, may apply conversion needed to the value (such
    as stringification on SQLite) before passing the value to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unique` – if True, the key name of this [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") will be modified if another [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") of the same name already has been located
    within the containing expression. This flag is used generally by the internals
    when producing so-called “anonymous” bound expressions, it isn’t generally applicable
    to explicitly-named [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    constructs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` – If `True`, a value is required at execution time. If not passed,
    it defaults to `True` if neither [`bindparam.value`](#sqlalchemy.sql.expression.bindparam.params.value
    "sqlalchemy.sql.expression.bindparam") or [`bindparam.callable`](#sqlalchemy.sql.expression.bindparam.params.callable
    "sqlalchemy.sql.expression.bindparam") were passed. If either of these parameters
    are present, then [`bindparam.required`](#sqlalchemy.sql.expression.bindparam.params.required
    "sqlalchemy.sql.expression.bindparam") defaults to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quote` – True if this parameter name requires quoting and is not currently
    known as a SQLAlchemy reserved word; this currently only applies to the Oracle
    backend, where bound names must sometimes be quoted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isoutparam` – if True, the parameter should be treated like a stored procedure
    “OUT” parameter. This applies to backends such as Oracle which support OUT parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expanding` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, this parameter will be treated as an “expanding” parameter at execution
    time; the parameter value is expected to be a sequence, rather than a scalar value,
    and the string SQL statement will be transformed on a per-execution basis to accommodate
    the sequence with a variable number of parameter slots passed to the DBAPI. This
    is to allow statement caching to be used in conjunction with an IN clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Using IN expressions](../orm/extensions/baked.html#baked-in) - with baked
    queries'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The “expanding” feature does not support “executemany”- style parameter sets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.3: the “expanding” bound parameter feature now supports
    empty lists.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`literal_execute` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, the bound parameter will be rendered in the compile phase with a special
    “POSTCOMPILE” token, and the SQLAlchemy compiler will render the final value of
    the parameter into the SQL statement at statement execution time, omitting the
    value from the parameter dictionary / list passed to DBAPI `cursor.execute()`.
    This produces a similar effect as that of using the `literal_binds`, compilation
    flag, however takes place as the statement is sent to the DBAPI `cursor.execute()`
    method, rather than when the statement is compiled. The primary use of this capability
    is for rendering LIMIT / OFFSET clauses for database drivers that can’t accommodate
    for bound parameters in these contexts, while allowing SQL constructs to be cacheable
    at the compilation level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added “post compile” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](../changelog/migration_14.html#change-4808).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Parameters](../tutorial/dbapi_transactions.html#tutorial-sending-parameters)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Produce a unary bitwise NOT clause, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not to be confused with boolean negation [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `CASE` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `CASE` construct in SQL is a conditional object that acts somewhat analogously
    to an “if/then” construct in other languages. It returns an instance of [`Case`](#sqlalchemy.sql.expression.Case
    "sqlalchemy.sql.expression.Case").
  prefs: []
  type: TYPE_NORMAL
- en: '[`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    in its usual form is passed a series of “when” constructs, that is, a list of
    conditions and results as tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'When simple equality expressions of several values against a single parent
    column are needed, [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    also has a “shorthand” format used via the [`case.value`](#sqlalchemy.sql.expression.case.params.value
    "sqlalchemy.sql.expression.case") parameter, which is passed a column expression
    to be compared. In this form, the [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") parameter is passed as a dictionary containing
    expressions to be compared against keyed to result expressions. The statement
    below is equivalent to the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'The values which are accepted as result values in [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") as well as with [`case.else_`](#sqlalchemy.sql.expression.case.params.else_
    "sqlalchemy.sql.expression.case") are coerced from Python literals into [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs. SQL expressions, e.g. [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs, are accepted as well. To
    coerce a literal string expression into a constant expression rendered inline,
    use the [`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    construct, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render the given constants without using bound parameters for
    the result values (but still for the comparison values), as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*whens` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The criteria to be compared against, [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") accepts two different forms, based on whether
    or not [`case.value`](#sqlalchemy.sql.expression.case.params.value "sqlalchemy.sql.expression.case")
    is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    function now accepts the series of WHEN conditions positionally'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the first form, it accepts multiple 2-tuples passed as positional arguments;
    each 2-tuple consists of `(<sql expression>, <value>)`, where the SQL expression
    is a boolean expression and “value” is a resulting value, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second form, it accepts a Python dictionary of comparison values mapped
    to a resulting value; this form requires [`case.value`](#sqlalchemy.sql.expression.case.params.value
    "sqlalchemy.sql.expression.case") to be present, and values will be compared using
    the `==` operator, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`value` – An optional SQL expression which will be used as a fixed “comparison
    point” for candidate values within a dictionary passed to [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else_` – An optional SQL expression which will be the evaluated result of
    the `CASE` construct if all expressions within [`case.whens`](#sqlalchemy.sql.expression.case.params.whens
    "sqlalchemy.sql.expression.case") evaluate to false. When omitted, most databases
    will produce a result of NULL if none of the “when” expressions evaluate to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `CAST` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    returns an instance of [`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast").'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: The [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function performs two distinct functions when used. The first is that it renders
    the `CAST` expression within the resulting SQL string. The second is that it associates
    the given type (e.g. [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or instance) with the column expression on
    the Python side, which means the expression will take on the expression operator
    behavior associated with that type, as well as the bound-value handling and result-row-handling
    behavior of the type.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    is the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    function. This function performs the second task of associating an expression
    with a specific type, but does not render the `CAST` expression in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expression` – A SQL expression, such as a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression or a Python string which
    will be coerced into a bound literal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance indicating the type to which the `CAST` should apply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    - an alternative to CAST that results in NULLs when the cast fails, instead of
    raising an error. Only supported by some dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    - an alternative to CAST that coerces the type on the Python side only, which
    is often sufficient to generate the correct SQL and data coercion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    is a lightweight analogue to the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class. The [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") function can be invoked with just a name alone,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'Once constructed, [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    may be used like any other SQL expression element such as within [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: The text handled by [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    is assumed to be handled like the name of a database column; if the string contains
    mixed case, special characters, or matches a known reserved word on the target
    backend, the column expression will render using the quoting behavior determined
    by the backend. To produce a textual SQL expression that is rendered exactly without
    any quoting, use [`literal_column()`](#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") instead, or pass `True` as the value
    of [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal "sqlalchemy.sql.expression.column").
    Additionally, full SQL statements are best handled using the [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    can be used in a table-like fashion by combining it with the [`table()`](selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") function (which is the lightweight analogue
    to [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    ) to produce a working table construct with minimal boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: A [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    / [`table()`](selectable.html#sqlalchemy.sql.expression.table "sqlalchemy.sql.expression.table")
    construct like that illustrated above can be created in an ad-hoc fashion and
    is not associated with any [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), DDL, or events, unlike its [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text` – the text of the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` – [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object which can associate this [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") with a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_literal` – if True, the [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") is assumed to be an exact expression
    that will be delivered to the output with no quoting rules applied regardless
    of case sensitive settings. the [`literal_column()`](#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") function essentially invokes [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") while passing `is_literal=True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`table()`](selectable.html#sqlalchemy.sql.expression.table "sqlalchemy.sql.expression.table")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Represent a ‘custom’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`custom_op`](#sqlalchemy.sql.expression.custom_op "sqlalchemy.sql.expression.custom_op")
    is normally instantiated when the [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") methods are used to create a custom
    operator callable. The class can also be used directly when programmatically constructing
    expressions. E.g. to represent the “factorial” operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.custom_op`](#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") (`sqlalchemy.sql.expression.OperatorType`,
    `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: Produce an column-expression-level unary `DISTINCT` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'This applies the `DISTINCT` keyword to an **individual column expression**
    (e.g. not the whole statement), and renders **specifically in that column position**;
    this is used for containment within an aggregate function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would produce an statement resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    function does **not** apply DISTINCT to the full SELECT statement, instead applying
    a DISTINCT modifier to **individual column expressions**. For general `SELECT
    DISTINCT` support, use the [`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct") method on [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select").
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    function is also available as a column-level method, e.g. [`ColumnElement.distinct()`](#sqlalchemy.sql.expression.ColumnElement.distinct
    "sqlalchemy.sql.expression.ColumnElement.distinct"), as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: The [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    operator is different from the [`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct") method of [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), which produces a `SELECT` statement with
    `DISTINCT` applied to the result set as a whole, e.g. a `SELECT DISTINCT` expression.
    See that method for further information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.distinct()`](#sqlalchemy.sql.expression.ColumnElement.distinct
    "sqlalchemy.sql.expression.ColumnElement.distinct")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.distinct()`](selectable.html#sqlalchemy.sql.expression.Select.distinct
    "sqlalchemy.sql.expression.Select.distinct")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Extract`](#sqlalchemy.sql.expression.Extract "sqlalchemy.sql.expression.Extract")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically available as [`extract()`](#sqlalchemy.sql.expression.extract
    "sqlalchemy.sql.expression.extract") as well as `func.extract` from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`field` – The field to extract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expr` – A column or Python scalar expression serving as the right side of
    the `EXTRACT` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the statement is used to select ids from the database
    where the `YEAR` component matches a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, one can also select an extracted component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `EXTRACT` may vary across database backends. Users are
    reminded to consult their database documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`False_`](#sqlalchemy.sql.expression.False_ "sqlalchemy.sql.expression.False_")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: 'A backend which does not support true/false constants will render as an expression
    against 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    constants also feature “short circuit” operation within an [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") or [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") conjunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Generate SQL function expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    is a special object instance which generates SQL functions based on name-based
    attributes, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned object is an instance of [`Function`](functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function"), and is a column-oriented SQL element like
    any other, and is used in that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: 'Any name can be given to [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").
    If the function name is unknown to SQLAlchemy, it will be rendered exactly as
    is. For common SQL functions which SQLAlchemy is aware of, the name may be interpreted
    as a *generic function* which will be compiled appropriately to the target database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'To call functions which are present in dot-separated packages, specify them
    in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy can be made aware of the return type of functions to enable type-specific
    lexical and result-based behavior. For example, to ensure that a string-based
    function returns a Unicode value and is similarly treated as a string in expressions,
    specify [`Unicode`](type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: 'The object returned by a [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    call is usually an instance of [`Function`](functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function"). This object meets the “column” interface,
    including comparison and labeling functions. The object can also be passed the
    `Connectable.execute()` method of a [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") or [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), where it will be wrapped inside of a SELECT statement
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: In a few exception cases, the [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    accessor will redirect a name to a built-in expression such as [`cast()`](#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`extract()`](#sqlalchemy.sql.expression.extract
    "sqlalchemy.sql.expression.extract"), as these names have well-known meaning but
    are not exactly the same as “functions” from a SQLAlchemy perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Functions which are interpreted as “generic” functions know how to calculate
    their return type automatically. For a listing of known generic functions, see
    [SQL and Generic Functions](functions.html#generic-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    construct has only limited support for calling standalone “stored procedures”,
    especially those with special parameterization concerns.
  prefs: []
  type: TYPE_NORMAL
- en: See the section [Calling Stored Procedures and User Defined Functions](connections.html#stored-procedures)
    for details on how to use the DBAPI-level `callproc()` method for fully traditional
    stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with SQL Functions](../tutorial/data_select.html#tutorial-functions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Function`](functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Produce a SQL statement that is cached as a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code object within the lambda is scanned for both Python literals
    that will become bound parameters as well as closure variables that refer to Core
    or ORM constructs that may vary. The lambda itself will be invoked only once per
    particular set of constructs detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: The object returned is an instance of [`StatementLambdaElement`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement
    "sqlalchemy.sql.expression.StatementLambdaElement").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lmb` – a Python function, typically a lambda, which takes no arguments and
    returns a SQL expression construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable_tracking` – when False, all scanning of the given lambda for changes
    in closure variables or bound parameters is disabled. Use for a lambda that produces
    the identical results in all cases with no parameterization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`track_closure_variables` – when False, changes in closure variables within
    the lambda will not be scanned. Use for a lambda where the state of its closure
    variables will never change the SQL structure returned by the lambda.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`track_bound_values` – when False, bound parameter tracking will be disabled
    for the given lambda. Use for a lambda that either does not produce any bound
    values, or where the initial bound values never change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global_track_bound_values` – when False, bound parameter tracking will be
    disabled for the entire statement including additional links added via the [`StatementLambdaElement.add_criteria()`](foundation.html#sqlalchemy.sql.expression.StatementLambdaElement.add_criteria
    "sqlalchemy.sql.expression.StatementLambdaElement.add_criteria") method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda_cache` – a dictionary or other mapping-like object where information
    about the lambda’s Python code as well as the tracked closure variables in the
    lambda itself will be stored. Defaults to a global LRU cache. This cache is independent
    of the “compiled_cache” used by the [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Lambdas to add significant speed gains to statement production](connections.html#engine-lambda-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Return a literal clause, bound to a bind parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Literal clauses are created automatically when non- [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") objects (such as strings, ints, dates,
    etc.) are used in a comparison operation with a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass, such as a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. Use this function to force the generation
    of a literal clause, which will be created as a [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") with a bound value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` – the value to be bound. Can be any Python object supported by the
    underlying DB-API, or is translatable via the given type argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – an optional [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") which will provide bind-parameter translation for
    this literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`literal_execute` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional bool, when True, the SQL engine will attempt to render the bound value
    directly in the SQL statement at execution time rather than providing as a parameter
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    object that has the [`column.is_literal`](#sqlalchemy.sql.expression.column.params.is_literal
    "sqlalchemy.sql.expression.column") flag set to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    is similar to [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column"),
    except that it is more often used as a “standalone” column expression that renders
    exactly as stated; while [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    stores a string name that will be assumed to be part of a table and may be quoted
    as such, [`literal_column()`](#sqlalchemy.sql.expression.literal_column "sqlalchemy.sql.expression.literal_column")
    can be that, or any other arbitrary column-oriented expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text` – the text of the expression; can be any SQL expression. Quoting rules
    will not be applied. To specify a column-name expression which should be subject
    to quoting rules, use the [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – an optional [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object which will provide result-set translation
    and additional expression semantics for this column. If left as `None` the type
    will be [`NullType`](type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Return a negation of the given clause, i.e. `NOT(clause)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `~` operator is also overloaded on all [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclasses to produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: Return a constant [`Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Produce a conjunction of expressions joined by `OR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    conjunction is also available using the Python `|` operator (though note that
    compound expressions need to be parenthesized in order to function with Python
    operator precedence behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    construct must be given at least one positional argument in order to be valid;
    a [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_") construct
    with no arguments is ambiguous. To produce an “empty” or dynamically generated
    [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_") expression,
    from a given list of expressions, a “default” element of [`false()`](#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") (or just `False`) should be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: The above expression will compile to SQL as the expression `false` or `0 = 1`,
    depending on backend, if no other expressions are present. If expressions are
    present, then the [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    value is ignored as it does not affect the outcome of an OR expression which has
    other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") element now requires that at least one argument
    is passed; creating the [`or_()`](#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    construct with no arguments is deprecated, and will emit a deprecation warning
    while continuing to produce a blank SQL string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: Create an ‘OUT’ parameter for usage in functions (stored procedures), for databases
    which support them.
  prefs: []
  type: TYPE_NORMAL
- en: The `outparam` can be used like a regular function parameter. The “output” value
    will be available from the [`CursorResult`](connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") object via its `out_parameters` attribute, which
    returns a dictionary containing the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    clause, representing a textual SQL string directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: The advantages [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    provides over a plain string are backend-neutral support for bind parameters,
    per-statement execution options, as well as bind parameter and result-column typing
    behavior, allowing SQLAlchemy type constructs to play a role when executing a
    statement that is specified literally. The construct can also be provided with
    a `.c` collection of column elements, allowing it to be embedded in other SQL
    expression constructs as a subquery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind parameters are specified by name, using the format `:name`. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQL statements where a colon is required verbatim, as within an inline
    string, use a backslash to escape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    construct includes methods which can provide information about the bound parameters
    as well as the column values which would be returned from the textual statement,
    assuming it’s an executable SELECT type of statement. The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method is used to provide bound
    parameter detail, and [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method allows specification of
    return columns including names and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct is used in cases when a literal string SQL fragment is specified as
    part of a larger query, such as for the WHERE clause of a SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    is also used for the construction of a full, standalone statement using plain
    text. As such, SQLAlchemy refers to it as an [`Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable") object and may be used like any other
    statement passed to an `.execute()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**text** –'
  prefs: []
  type: TYPE_NORMAL
- en: the text of the SQL statement to be created. Use `:<param>` to specify bind
    parameters; they will be compiled to their engine-specific format.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`text.text`](#sqlalchemy.sql.expression.text.params.text "sqlalchemy.sql.expression.text")
    argument to [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    can be passed as a Python string argument, which will be treated as **trusted
    SQL text** and rendered as given. **DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: Return a constant [`True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: 'A backend which does not support true/false constants will render as an expression
    against 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    constants also feature “short circuit” operation within an [`and_()`](#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") or [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") conjunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`false()`](#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `TRY_CAST` expression for backends which support it; this is a `CAST`
    which returns NULL for un-castable conversions.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, this construct is supported **only** by the SQL Server dialect,
    and will raise a [`CompileError`](exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") if used on other included backends. However, third
    party backends may also support this construct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    originates from the SQL Server dialect, it’s importable both from `sqlalchemy.`
    as well as from `sqlalchemy.dialects.mssql`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    returns an instance of [`TryCast`](#sqlalchemy.sql.expression.TryCast "sqlalchemy.sql.expression.TryCast")
    and generally behaves similarly to the [`Cast`](#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast") construct; at the SQL level, the difference
    between `CAST` and `TRY_CAST` is that `TRY_CAST` returns NULL for an un-castable
    expression, such as attempting to cast a string `"hi"` to an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would render on Microsoft SQL Server as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.14: [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    has been generalized from the SQL Server dialect into a general use construct
    that may be supported by additional dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple").
  prefs: []
  type: TYPE_NORMAL
- en: Main usage is to produce a composite IN construct using [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3.6: Added support for SQLite IN tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The composite IN construct is not supported by all backends, and is currently
    known to work on PostgreSQL, MySQL, and SQLite. Unsupported backends will raise
    a subclass of [`DBAPIError`](exceptions.html#sqlalchemy.exc.DBAPIError "sqlalchemy.exc.DBAPIError")
    when such an expression is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: Associate a SQL expression with a particular type, without rendering `CAST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: 'The above construct will produce a [`TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") object, which does not modify the rendering
    in any way on the SQL side, with the possible exception of a generated label if
    used in a columns clause context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: When result rows are fetched, the `StringDateTime` type processor will be applied
    to result rows on behalf of the `date_string` column.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    construct does not render any SQL syntax of its own, including that it does not
    imply parenthesization. Please use [`TypeCoerce.self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") if explicit parenthesization
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide a named label for the expression, use [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'A type that features bound-value handling will also have that behavior take
    effect when literal values or [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs are passed to [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") as targets. For example, if a type implements
    the [`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") method or [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method or equivalent, these functions
    will take effect at statement compilation/execution time when a literal value
    is passed, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: 'When using [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    with composed expressions, note that **parenthesis are not applied**. If [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") is being used in an operator context
    where the parenthesis normally present from CAST are necessary, use the [`TypeCoerce.self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expression` – A SQL expression, such as a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression or a Python string which
    will be coerced into a bound literal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_` – A [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance indicating the type to which the expression is coerced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL identifier combined with quoting preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '[`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    is a Python unicode/str subclass which represents a particular identifier name
    along with a `quote` flag. This `quote` flag, when set to `True` or `False`, overrides
    automatic quoting behavior for this identifier in order to either unconditionally
    quote or to not quote the name. If left at its default of `None`, quoting behavior
    is applied to the identifier on a per-backend basis based on an examination of
    the token itself.'
  prefs: []
  type: TYPE_NORMAL
- en: A [`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    object with `quote=True` is also prevented from being modified in the case of
    a so-called “name normalize” option. Certain database backends, such as Oracle,
    Firebird, and DB2 “normalize” case-insensitive names as uppercase. The SQLAlchemy
    dialects for these backends convert from SQLAlchemy’s lower-case-means-insensitive
    convention to the upper-case-means-insensitive conventions of those backends.
    The `quote=True` flag here will prevent this conversion from occurring to support
    an identifier that’s quoted as all lower case against such a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`quoted_name`](#sqlalchemy.sql.expression.quoted_name "sqlalchemy.sql.expression.quoted_name")
    object is normally created automatically when specifying the name for key schema
    constructs such as [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    and others. The class can also be passed explicitly as the name to any function
    that receives a name which can be quoted. Such as to use the `Engine.has_table()`
    method with an unconditionally quoted name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: The above logic will run the “has table” logic against the Oracle backend, passing
    the name exactly as `"some_table"` without converting to upper case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`quoted_name`](#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now importable from `sqlalchemy.sql`,
    in addition to the previous location of `sqlalchemy.sql.elements`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[quote](#sqlalchemy.sql.expression.quoted_name.quote)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.quoted_name`](#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") (`sqlalchemy.util.langhelpers.MemoizedSlots`,
    `builtins.str`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: whether the string should be unconditionally quoted
  prefs: []
  type: TYPE_NORMAL
- en: '## Column Element Modifier Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: Functions listed here are more commonly available as methods from any [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") construct, for example, the [`label()`](#sqlalchemy.sql.expression.label
    "sqlalchemy.sql.expression.label") function is usually invoked via the [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [all_](#sqlalchemy.sql.expression.all_)(expr) | Produce an ALL expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [any_](#sqlalchemy.sql.expression.any_)(expr) | Produce an ANY expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [asc](#sqlalchemy.sql.expression.asc)(column) | Produce an ascending `ORDER
    BY` clause element. |'
  prefs: []
  type: TYPE_TB
- en: '| [between](#sqlalchemy.sql.expression.between)(expr, lower_bound, upper_bound[,
    symmetric]) | Produce a `BETWEEN` predicate clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [collate](#sqlalchemy.sql.expression.collate)(expression, collation) | Return
    the clause `expression COLLATE collation`. |'
  prefs: []
  type: TYPE_TB
- en: '| [desc](#sqlalchemy.sql.expression.desc)(column) | Produce a descending `ORDER
    BY` clause element. |'
  prefs: []
  type: TYPE_TB
- en: '| [funcfilter](#sqlalchemy.sql.expression.funcfilter)(func, *criterion) | Produce
    a [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter "sqlalchemy.sql.expression.FunctionFilter")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [label](#sqlalchemy.sql.expression.label)(name, element[, type_]) | Return
    a [`Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    object for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"). |'
  prefs: []
  type: TYPE_TB
- en: '| [nulls_first](#sqlalchemy.sql.expression.nulls_first)(column) | Produce the
    `NULLS FIRST` modifier for an `ORDER BY` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [nulls_last](#sqlalchemy.sql.expression.nulls_last)(column) | Produce the
    `NULLS LAST` modifier for an `ORDER BY` expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [nullsfirst](#sqlalchemy.sql.expression.nullsfirst) | Synonym for the [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first
    "sqlalchemy.sql.expression.nulls_first") function. |'
  prefs: []
  type: TYPE_TB
- en: '| [nullslast](#sqlalchemy.sql.expression.nullslast) | Legacy synonym for the
    [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    function. |'
  prefs: []
  type: TYPE_TB
- en: '| [over](#sqlalchemy.sql.expression.over)(element[, partition_by, order_by,
    range_, ...]) | Produce an [`Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [within_group](#sqlalchemy.sql.expression.within_group)(element, *order_by)
    | Produce a [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    object against a function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ALL expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dialects such as that of PostgreSQL, this operator applies to usage of
    the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    datatype, for that of MySQL, it may apply to a subquery. e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparison to NULL may work using `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: 'The any_() / all_() operators also feature a special “operand flipping” behavior
    such that if any_() / all_() are used on the left side of a comparison using a
    standalone operator such as `==`, `!=`, etc. (not including operator methods such
    as [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_"))
    the rendered expression is flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `None`, which note will not perform the usual step of rendering “IS”
    as is normally the case for NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.26: repaired the use of any_() / all_() comparing to
    NULL on the right side to be flipped to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The column-level [`ColumnElement.all_()`](#sqlalchemy.sql.expression.ColumnElement.all_
    "sqlalchemy.sql.expression.ColumnElement.all_") method (not to be confused with
    [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") level
    [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all "sqlalchemy.types.ARRAY.Comparator.all"))
    is shorthand for `all_(col)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ANY expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dialects such as that of PostgreSQL, this operator applies to usage of
    the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    datatype, for that of MySQL, it may apply to a subquery. e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparison to NULL may work using `None` or [`null()`](#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'The any_() / all_() operators also feature a special “operand flipping” behavior
    such that if any_() / all_() are used on the left side of a comparison using a
    standalone operator such as `==`, `!=`, etc. (not including operator methods such
    as [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_"))
    the rendered expression is flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `None`, which note will not perform the usual step of rendering “IS”
    as is normally the case for NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.26: repaired the use of any_() / all_() comparing to
    NULL on the right side to be flipped to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The column-level [`ColumnElement.any_()`](#sqlalchemy.sql.expression.ColumnElement.any_
    "sqlalchemy.sql.expression.ColumnElement.any_") method (not to be confused with
    [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") level
    [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any "sqlalchemy.types.ARRAY.Comparator.any"))
    is shorthand for `any_(col)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: Produce an ascending `ORDER BY` clause element.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: 'will produce SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    function is a standalone version of the [`ColumnElement.asc()`](#sqlalchemy.sql.expression.ColumnElement.asc
    "sqlalchemy.sql.expression.ColumnElement.asc") method available on all SQL expressions,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**column** – A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    (e.g. scalar SQL expression) with which to apply the [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") operation.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `BETWEEN` predicate clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    function is a standalone version of the [`ColumnElement.between()`](#sqlalchemy.sql.expression.ColumnElement.between
    "sqlalchemy.sql.expression.ColumnElement.between") method available on all SQL
    expressions, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: 'All arguments passed to [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between"),
    including the left side column expression, are coerced from Python scalar values
    if a the value is not a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") subclass. For example, three fixed
    values can be compared as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expr` – a column expression, typically a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") instance or alternatively a Python
    scalar expression to be coerced into a column expression, serving as the left
    side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` – a column or Python scalar expression serving as the lower bound
    of the right side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper_bound` – a column or Python scalar expression serving as the upper bound
    of the right side of the `BETWEEN` expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetric` – if True, will render “ BETWEEN SYMMETRIC “. Note that not all
    databases support this syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.between()`](#sqlalchemy.sql.expression.ColumnElement.between
    "sqlalchemy.sql.expression.ColumnElement.between")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Return the clause `expression COLLATE collation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: The collation expression is also quoted if it is a case sensitive identifier,
    e.g. contains uppercase characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: quoting is automatically applied to COLLATE expressions
    if they are case sensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: Produce a descending `ORDER BY` clause element.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'will produce SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    function is a standalone version of the [`ColumnElement.desc()`](#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") method available on all SQL expressions,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**column** – A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    (e.g. scalar SQL expression) with which to apply the [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") operation.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter "sqlalchemy.sql.expression.FunctionFilter")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate and window functions, for database backends that support
    the “FILTER” clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Would produce “COUNT(1) FILTER (WHERE myclass.name = ‘some name’)”.
  prefs: []
  type: TYPE_NORMAL
- en: This function is also available from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct itself via the [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Special Modifiers WITHIN GROUP, FILTER](../tutorial/data_select.html#tutorial-functions-within-group)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    object for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: A label changes the name of an element in the columns clause of a `SELECT` statement,
    typically via the `AS` SQL keyword.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is more conveniently available via the [`ColumnElement.label()`](#sqlalchemy.sql.expression.ColumnElement.label
    "sqlalchemy.sql.expression.ColumnElement.label") method on [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – label name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` – a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: Produce the `NULLS FIRST` modifier for an `ORDER BY` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    is intended to modify the expression produced by [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") or [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), and indicates how NULL values should be handled
    when they are encountered during ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL expression from the above would resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'Like [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    and [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc"),
    [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    is typically invoked from the column expression itself using [`ColumnElement.nulls_first()`](#sqlalchemy.sql.expression.ColumnElement.nulls_first
    "sqlalchemy.sql.expression.ColumnElement.nulls_first"), rather than as its standalone
    function version, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first
    "sqlalchemy.sql.expression.nulls_first") is renamed from [`nullsfirst()`](#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst") in previous releases. The previous name
    remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: Synonym for the [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: restored missing legacy symbol [`nullsfirst()`](#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Produce the `NULLS LAST` modifier for an `ORDER BY` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    is intended to modify the expression produced by [`asc()`](#sqlalchemy.sql.expression.asc
    "sqlalchemy.sql.expression.asc") or [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), and indicates how NULL values should be handled
    when they are encountered during ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL expression from the above would resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'Like [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    and [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc"),
    [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    is typically invoked from the column expression itself using [`ColumnElement.nulls_last()`](#sqlalchemy.sql.expression.ColumnElement.nulls_last
    "sqlalchemy.sql.expression.ColumnElement.nulls_last"), rather than as its standalone
    function version, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last
    "sqlalchemy.sql.expression.nulls_last") is renamed from [`nullslast()`](#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast") in previous releases. The previous name
    remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.order_by()`](selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: Legacy synonym for the [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last
    "sqlalchemy.sql.expression.nulls_last") function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: restored missing legacy symbol [`nullslast()`](#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate or so-called “window” functions, for database backends
    that support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")
    is usually called using the [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are also possible using the [`over.range_`](#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters. These mutually-exclusive parameters
    each accept a 2-tuple, which contains a combination of integers and None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of `None` indicates “unbounded”, a value of zero indicates “current
    row”, and negative / positive integers indicate “preceding” and “following”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element` – a [`FunctionElement`](functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement"), [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup"), or other compatible construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partition_by` – a column element or string, or a list of such, that will be
    used as the PARTITION BY clause of the OVER construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order_by` – a column element or string, or a list of such, that will be used
    as the ORDER BY clause of the OVER construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range_` – optional range clause for the window. This is a tuple value which
    can contain integer values or `None`, and will render a RANGE BETWEEN PRECEDING
    / FOLLOWING clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rows` – optional rows clause for the window. This is a tuple value which can
    contain integer values or None, and will render a ROWS BETWEEN PRECEDING / FOLLOWING
    clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is also available from the [`func`](#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct itself via the [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`within_group()`](#sqlalchemy.sql.expression.within_group "sqlalchemy.sql.expression.within_group")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    object against a function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against so-called “ordered set aggregate” and “hypothetical set aggregate”
    functions, including [`percentile_cont`](functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`rank`](functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[`within_group()`](#sqlalchemy.sql.expression.within_group "sqlalchemy.sql.expression.within_group")
    is usually called using the [`FunctionElement.within_group()`](functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: The above statement would produce SQL similar to `SELECT department.id, percentile_cont(0.5)
    WITHIN GROUP (ORDER BY department.salary DESC)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element` – a [`FunctionElement`](functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement") construct, typically generated by
    [`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*order_by` – one or more column elements that will be used as the ORDER BY
    clause of the WITHIN GROUP construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Special Modifiers WITHIN GROUP, FILTER](../tutorial/data_select.html#tutorial-functions-within-group)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`func`](#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")'
  prefs: []
  type: TYPE_NORMAL
- en: Column Element Class Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classes here are generated using the constructors listed at [Column Element
    Foundational Constructors](#sqlelement-foundational-constructors) and [Column
    Element Modifier Constructors](#sqlelement-modifier-constructors).
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BinaryExpression](#sqlalchemy.sql.expression.BinaryExpression) | Represent
    an expression that is `LEFT <operator> RIGHT`. |'
  prefs: []
  type: TYPE_TB
- en: '| [BindParameter](#sqlalchemy.sql.expression.BindParameter) | Represent a “bound
    expression”. |'
  prefs: []
  type: TYPE_TB
- en: '| [Case](#sqlalchemy.sql.expression.Case) | Represent a `CASE` expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Cast](#sqlalchemy.sql.expression.Cast) | Represent a `CAST` expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ClauseList](#sqlalchemy.sql.expression.ClauseList) | Describe a list of
    clauses, separated by an operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnClause](#sqlalchemy.sql.expression.ColumnClause) | Represents a column
    expression from any textual string. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollection](#sqlalchemy.sql.expression.ColumnCollection) | Collection
    of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    instances, typically for [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnElement](#sqlalchemy.sql.expression.ColumnElement) | Represent a column-oriented
    SQL expression suitable for usage in the “columns” clause, WHERE clause etc. of
    a statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnExpressionArgument](#sqlalchemy.sql.expression.ColumnExpressionArgument)
    | General purpose “column expression” argument. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnOperators](#sqlalchemy.sql.expression.ColumnOperators) | Defines boolean,
    comparison, and other operators for [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| [Extract](#sqlalchemy.sql.expression.Extract) | Represent a SQL EXTRACT clause,
    `extract(field FROM expr)`. |'
  prefs: []
  type: TYPE_TB
- en: '| [False_](#sqlalchemy.sql.expression.False_) | Represent the `false` keyword,
    or equivalent, in a SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [FunctionFilter](#sqlalchemy.sql.expression.FunctionFilter) | Represent a
    function FILTER clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [Label](#sqlalchemy.sql.expression.Label) | Represents a column label (AS).
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Null](#sqlalchemy.sql.expression.Null) | Represent the NULL keyword in a
    SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [Operators](#sqlalchemy.sql.expression.Operators) | Base of comparison and
    logical operators. |'
  prefs: []
  type: TYPE_TB
- en: '| [Over](#sqlalchemy.sql.expression.Over) | Represent an OVER clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [SQLColumnExpression](#sqlalchemy.sql.expression.SQLColumnExpression) | A
    type that may be used to indicate any SQL column element or object that acts in
    place of one. |'
  prefs: []
  type: TYPE_TB
- en: '| [TextClause](#sqlalchemy.sql.expression.TextClause) | Represent a literal
    SQL text fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| [True_](#sqlalchemy.sql.expression.True_) | Represent the `true` keyword,
    or equivalent, in a SQL statement. |'
  prefs: []
  type: TYPE_TB
- en: '| [TryCast](#sqlalchemy.sql.expression.TryCast) | Represent a TRY_CAST expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Tuple](#sqlalchemy.sql.expression.Tuple) | Represent a SQL tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| [TypeCoerce](#sqlalchemy.sql.expression.TypeCoerce) | Represent a Python-side
    type-coercion wrapper. |'
  prefs: []
  type: TYPE_TB
- en: '| [UnaryExpression](#sqlalchemy.sql.expression.UnaryExpression) | Define a
    ‘unary’ expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [WithinGroup](#sqlalchemy.sql.expression.WithinGroup) | Represent a WITHIN
    GROUP (ORDER BY) clause. |'
  prefs: []
  type: TYPE_TB
- en: '| [WrapsColumnExpression](#sqlalchemy.sql.elements.WrapsColumnExpression) |
    Mixin that defines a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as a wrapper with special labeling
    behavior for an expression that already has a name. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Represent an expression that is `LEFT <operator> RIGHT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression "sqlalchemy.sql.expression.BinaryExpression")
    is generated automatically whenever two column expressions are used in a Python
    binary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") (`sqlalchemy.sql.expression.OperatorExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: Represent a “bound expression”.
  prefs: []
  type: TYPE_NORMAL
- en: '[`BindParameter`](#sqlalchemy.sql.expression.BindParameter "sqlalchemy.sql.expression.BindParameter")
    is invoked explicitly using the [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: Detailed discussion of how [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") is used is at [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[effective_value](#sqlalchemy.sql.expression.BindParameter.effective_value),
    [inherit_cache](#sqlalchemy.sql.expression.BindParameter.inherit_cache), [render_literal_execute()](#sqlalchemy.sql.expression.BindParameter.render_literal_execute)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") (`sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.expression.KeyedColumnElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: Return the value of this bound parameter, taking into account if the `callable`
    parameter was set.
  prefs: []
  type: TYPE_NORMAL
- en: The `callable` value will be evaluated and returned if present, else `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: Produce a copy of this bound parameter that will enable the [`BindParameter.literal_execute`](#sqlalchemy.sql.expression.BindParameter.params.literal_execute
    "sqlalchemy.sql.expression.BindParameter") flag.
  prefs: []
  type: TYPE_NORMAL
- en: The [`BindParameter.literal_execute`](#sqlalchemy.sql.expression.BindParameter.params.literal_execute
    "sqlalchemy.sql.expression.BindParameter") flag will have the effect of the parameter
    rendered in the compiled SQL string using `[POSTCOMPILE]` form, which is a special
    form that is converted to be a rendering of the literal value of the parameter
    at SQL execution time. The rationale is to support caching of SQL statement strings
    that can embed per-statement literal values, such as LIMIT and OFFSET parameters,
    in the final SQL string that is passed to the DBAPI. Dialects in particular may
    want to use this method within custom compilation schemes.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Caching for Third Party Dialects](connections.html#engine-thirdparty-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: Represent a `CASE` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    is produced using the [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    factory function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: Details on [`Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    usage is at [`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`case()`](#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Case`](#sqlalchemy.sql.expression.Case "sqlalchemy.sql.expression.Case")
    ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: Represent a `CAST` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    is produced using the [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    factory function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: Details on [`Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    usage is at [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    - an alternative to CAST that coerces the type on the Python side only, which
    is often sufficient to generate the correct SQL and data coercion.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Cast`](#sqlalchemy.sql.expression.Cast "sqlalchemy.sql.expression.Cast")
    (`sqlalchemy.sql.expression.WrapsColumnExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Describe a list of clauses, separated by an operator.
  prefs: []
  type: TYPE_NORMAL
- en: By default, is comma-separated, such as a column listing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.ClauseList.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ClauseList`](#sqlalchemy.sql.expression.ClauseList
    "sqlalchemy.sql.expression.ClauseList") (`sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.roles.OrderByRole`, `sqlalchemy.sql.roles.ColumnsClauseRole`,
    `sqlalchemy.sql.roles.DMLColumnRole`, `sqlalchemy.sql.expression.DQLDMLClauseElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.ClauseList.self_group
    "sqlalchemy.sql.expression.ClauseList.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.ClauseList.self_group "sqlalchemy.sql.expression.ClauseList.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: Represents a column expression from any textual string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause"),
    a lightweight analogue to the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is typically invoked using the [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") function, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    is the immediate superclass of the schema-specific [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. While the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class has all the same capabilities as [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause"), the [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") class is usable by itself in those cases
    where behavioral requirements are limited to simple SQL expression generation.
    The object has none of the associations with schema-level metadata or with execution-time
    behavior that [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    does, so in that sense is a “lightweight” version of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs: []
  type: TYPE_NORMAL
- en: Full details on [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    usage is at [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_children()](#sqlalchemy.sql.expression.ColumnClause.get_children)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") (`sqlalchemy.sql.roles.DDLReferredColumnRole`,
    `sqlalchemy.sql.roles.LabeledColumnExprRole`, `sqlalchemy.sql.roles.StrAsPlainColumnRole`,
    `sqlalchemy.sql.expression.Immutable`, `sqlalchemy.sql.expression.NamedColumn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used for visit traversal.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: Collection of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    instances, typically for [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object is most commonly available as the [`Table.c`](metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") or [`Table.columns`](metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection on the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, introduced at [Accessing Tables and Columns](metadata.html#metadata-tables-and-columns).
  prefs: []
  type: TYPE_NORMAL
- en: The [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    has both mapping- and sequence- like behaviors. A [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") usually stores [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, which are then accessible both via mapping
    style access as well as attribute access style.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects using ordinary attribute-style access, specify the name like any other
    object attribute, such as below a column named `employee_name` is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'To access columns that have names with special characters or spaces, index-style
    access is used, such as below which illustrates a column named `employee '' payment`
    is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'As the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object provides a Python dictionary interface, common dictionary method names
    like [`ColumnCollection.keys()`](#sqlalchemy.sql.expression.ColumnCollection.keys
    "sqlalchemy.sql.expression.ColumnCollection.keys"), [`ColumnCollection.values()`](#sqlalchemy.sql.expression.ColumnCollection.values
    "sqlalchemy.sql.expression.ColumnCollection.values"), and [`ColumnCollection.items()`](#sqlalchemy.sql.expression.ColumnCollection.items
    "sqlalchemy.sql.expression.ColumnCollection.items") are available, which means
    that database columns that are keyed under these names also need to use indexed
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: 'The name for which a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    would be present is normally that of the [`Column.key`](metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") parameter. In some contexts, such as a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object that uses a label style set using the
    [`Select.set_label_style()`](selectable.html#sqlalchemy.sql.expression.Select.set_label_style
    "sqlalchemy.sql.expression.Select.set_label_style") method, a column of a certain
    key may instead be represented under a particular label name such as `tablename_columnname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    also indexes the columns in order and allows them to be accessible by their integer
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") allows integer-based index access
    to the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating the collection yields the column expressions in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'The base [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    object can store duplicates, which can mean either two columns with the same key,
    in which case the column returned by key access is **arbitrary**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: Or it can also mean the same column multiple times. These cases are supported
    as [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    is used to represent the columns in a SELECT statement which may include duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: A special subclass `DedupeColumnCollection` exists which instead maintains SQLAlchemy’s
    older behavior of not allowing duplicates; this collection is used for schema
    level objects like [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") where this deduping is helpful. The
    `DedupeColumnCollection` class also has additional mutation methods as the schema
    constructs have more use cases that require removal and replacement of columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") now stores duplicate column keys
    as well as the same column in multiple positions. The `DedupeColumnCollection`
    class is added to maintain the former behavior in those cases where deduplication
    as well as additional replace/remove operations are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.sql.expression.ColumnCollection.add), [as_readonly()](#sqlalchemy.sql.expression.ColumnCollection.as_readonly),
    [clear()](#sqlalchemy.sql.expression.ColumnCollection.clear), [compare()](#sqlalchemy.sql.expression.ColumnCollection.compare),
    [contains_column()](#sqlalchemy.sql.expression.ColumnCollection.contains_column),
    [corresponding_column()](#sqlalchemy.sql.expression.ColumnCollection.corresponding_column),
    [get()](#sqlalchemy.sql.expression.ColumnCollection.get), [items()](#sqlalchemy.sql.expression.ColumnCollection.items),
    [keys()](#sqlalchemy.sql.expression.ColumnCollection.keys), [update()](#sqlalchemy.sql.expression.ColumnCollection.update),
    [values()](#sqlalchemy.sql.expression.ColumnCollection.values)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: Add a column to this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is **not normally used by user-facing code**, as the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") is usually part of an existing object
    such as a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
    To add a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to an existing [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, use the [`Table.append_column()`](metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Return a “read only” form of this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary clear() is not implemented for [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Compare this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") to another based on the names of
    the keys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Checks if a column object exists in this collection
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Given a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement"),
    return the exported [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") object from this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which corresponds to that original
    [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    via a common ancestor column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`column` – the target [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") to be matched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require_embedded` – only return corresponding columns for the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"), if the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") is actually present within a sub-element
    of this [`Selectable`](selectable.html#sqlalchemy.sql.expression.Selectable "sqlalchemy.sql.expression.Selectable").
    Normally the column will match if it merely shares a common ancestor with one
    of the exported columns of this [`Selectable`](selectable.html#sqlalchemy.sql.expression.Selectable
    "sqlalchemy.sql.expression.Selectable").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Selectable.corresponding_column()`](selectable.html#sqlalchemy.sql.expression.Selectable.corresponding_column
    "sqlalchemy.sql.expression.Selectable.corresponding_column") - invokes this method
    against the collection returned by [`Selectable.exported_columns`](selectable.html#sqlalchemy.sql.expression.Selectable.exported_columns
    "sqlalchemy.sql.expression.Selectable.exported_columns").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: the implementation for `corresponding_column` was moved
    onto the [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection "sqlalchemy.sql.expression.ColumnCollection")
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: Get a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause "sqlalchemy.sql.expression.ColumnClause")
    or [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object based on a string key name from this [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of (key, column) tuples for all columns in this collection
    each consisting of a string key name and a [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") or [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of string key names for all columns in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary update() is not implemented for [`ColumnCollection`](#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Return a sequence of [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") or [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects for all columns in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: Represent a column-oriented SQL expression suitable for usage in the “columns”
    clause, WHERE clause etc. of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: While the most familiar kind of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") is the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") serves as the basis for any unit that
    may be present in a SQL expression, including the expressions themselves, SQL
    functions, bound parameters, literal expressions, keywords such as `NULL`, etc.
    [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    is the ultimate base class for all such elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A wide variety of SQLAlchemy Core functions work at the SQL expression level,
    and are intended to accept instances of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as arguments. These functions will
    typically document that they accept a “SQL expression” as an argument. What this
    means in terms of SQLAlchemy usually refers to an input which is either already
    in the form of a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    object, or a value which can be **coerced** into one. The coercion rules followed
    by most, but not all, SQLAlchemy Core functions with regards to SQL expressions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a literal Python value, such as a string, integer or floating point value, boolean,
    datetime, `Decimal` object, or virtually any other Python object, will be coerced
    into a “literal bound value”. This generally means that a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") will be produced featuring the given value
    embedded into the construct; the resulting [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") object is an instance of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"). The Python value will ultimately be
    sent to the DBAPI at execution time as a parameterized argument to the `execute()`
    or `executemany()` methods, after SQLAlchemy type-specific converters (e.g. those
    provided by any associated [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) are applied to the value.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: any special object value, typically ORM-level constructs, which feature an accessor
    called `__clause_element__()`. The Core expression system looks for this method
    when an object of otherwise unknown type is passed to a function that is looking
    to coerce the argument into a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") and sometimes a [`SelectBase`](selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") expression. It is used within the ORM
    to convert from ORM-specific objects like mapped classes and mapped attributes
    into Core expression objects.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The Python `None` value is typically interpreted as `NULL`, which in SQLAlchemy
    Core produces an instance of [`null()`](#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null").
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    provides the ability to generate new [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects using Python expressions. This
    means that Python operators such as `==`, `!=` and `<` are overloaded to mimic
    SQL operations, and allow the instantiation of further [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") instances which are composed from other,
    more fundamental [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    objects. For example, two [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") objects can be added together with the
    addition operator `+` to produce a [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression"). Both [`ColumnClause`](#sqlalchemy.sql.expression.ColumnClause
    "sqlalchemy.sql.expression.ColumnClause") and [`BinaryExpression`](#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") are subclasses of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__eq__()](#sqlalchemy.sql.expression.ColumnElement.__eq__), [__le__()](#sqlalchemy.sql.expression.ColumnElement.__le__),
    [__lt__()](#sqlalchemy.sql.expression.ColumnElement.__lt__), [__ne__()](#sqlalchemy.sql.expression.ColumnElement.__ne__),
    [all_()](#sqlalchemy.sql.expression.ColumnElement.all_), [allows_lambda](#sqlalchemy.sql.expression.ColumnElement.allows_lambda),
    [anon_key_label](#sqlalchemy.sql.expression.ColumnElement.anon_key_label), [anon_label](#sqlalchemy.sql.expression.ColumnElement.anon_label),
    [any_()](#sqlalchemy.sql.expression.ColumnElement.any_), [asc()](#sqlalchemy.sql.expression.ColumnElement.asc),
    [base_columns](#sqlalchemy.sql.expression.ColumnElement.base_columns), [between()](#sqlalchemy.sql.expression.ColumnElement.between),
    [bitwise_and()](#sqlalchemy.sql.expression.ColumnElement.bitwise_and), [bitwise_lshift()](#sqlalchemy.sql.expression.ColumnElement.bitwise_lshift),
    [bitwise_not()](#sqlalchemy.sql.expression.ColumnElement.bitwise_not), [bitwise_or()](#sqlalchemy.sql.expression.ColumnElement.bitwise_or),
    [bitwise_rshift()](#sqlalchemy.sql.expression.ColumnElement.bitwise_rshift), [bitwise_xor()](#sqlalchemy.sql.expression.ColumnElement.bitwise_xor),
    [bool_op()](#sqlalchemy.sql.expression.ColumnElement.bool_op), [cast()](#sqlalchemy.sql.expression.ColumnElement.cast),
    [collate()](#sqlalchemy.sql.expression.ColumnElement.collate), [comparator](#sqlalchemy.sql.expression.ColumnElement.comparator),
    [compare()](#sqlalchemy.sql.expression.ColumnElement.compare), [compile()](#sqlalchemy.sql.expression.ColumnElement.compile),
    [concat()](#sqlalchemy.sql.expression.ColumnElement.concat), [contains()](#sqlalchemy.sql.expression.ColumnElement.contains),
    [desc()](#sqlalchemy.sql.expression.ColumnElement.desc), [description](#sqlalchemy.sql.expression.ColumnElement.description),
    [distinct()](#sqlalchemy.sql.expression.ColumnElement.distinct), [endswith()](#sqlalchemy.sql.expression.ColumnElement.endswith),
    [entity_namespace](#sqlalchemy.sql.expression.ColumnElement.entity_namespace),
    [expression](#sqlalchemy.sql.expression.ColumnElement.expression), [foreign_keys](#sqlalchemy.sql.expression.ColumnElement.foreign_keys),
    [get_children()](#sqlalchemy.sql.expression.ColumnElement.get_children), [icontains()](#sqlalchemy.sql.expression.ColumnElement.icontains),
    [iendswith()](#sqlalchemy.sql.expression.ColumnElement.iendswith), [ilike()](#sqlalchemy.sql.expression.ColumnElement.ilike),
    [in_()](#sqlalchemy.sql.expression.ColumnElement.in_), [inherit_cache](#sqlalchemy.sql.expression.ColumnElement.inherit_cache),
    [is_()](#sqlalchemy.sql.expression.ColumnElement.is_), [is_clause_element](#sqlalchemy.sql.expression.ColumnElement.is_clause_element),
    [is_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.is_distinct_from),
    [is_dml](#sqlalchemy.sql.expression.ColumnElement.is_dml), [is_not()](#sqlalchemy.sql.expression.ColumnElement.is_not),
    [is_not_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.is_not_distinct_from),
    [is_selectable](#sqlalchemy.sql.expression.ColumnElement.is_selectable), [isnot()](#sqlalchemy.sql.expression.ColumnElement.isnot),
    [isnot_distinct_from()](#sqlalchemy.sql.expression.ColumnElement.isnot_distinct_from),
    [istartswith()](#sqlalchemy.sql.expression.ColumnElement.istartswith), [key](#sqlalchemy.sql.expression.ColumnElement.key),
    [label()](#sqlalchemy.sql.expression.ColumnElement.label), [like()](#sqlalchemy.sql.expression.ColumnElement.like),
    [match()](#sqlalchemy.sql.expression.ColumnElement.match), [negation_clause](#sqlalchemy.sql.expression.ColumnElement.negation_clause),
    [not_ilike()](#sqlalchemy.sql.expression.ColumnElement.not_ilike), [not_in()](#sqlalchemy.sql.expression.ColumnElement.not_in),
    [not_like()](#sqlalchemy.sql.expression.ColumnElement.not_like), [notilike()](#sqlalchemy.sql.expression.ColumnElement.notilike),
    [notin_()](#sqlalchemy.sql.expression.ColumnElement.notin_), [notlike()](#sqlalchemy.sql.expression.ColumnElement.notlike),
    [nulls_first()](#sqlalchemy.sql.expression.ColumnElement.nulls_first), [nulls_last()](#sqlalchemy.sql.expression.ColumnElement.nulls_last),
    [nullsfirst()](#sqlalchemy.sql.expression.ColumnElement.nullsfirst), [nullslast()](#sqlalchemy.sql.expression.ColumnElement.nullslast),
    [op()](#sqlalchemy.sql.expression.ColumnElement.op), [operate()](#sqlalchemy.sql.expression.ColumnElement.operate),
    [params()](#sqlalchemy.sql.expression.ColumnElement.params), [primary_key](#sqlalchemy.sql.expression.ColumnElement.primary_key),
    [proxy_set](#sqlalchemy.sql.expression.ColumnElement.proxy_set), [regexp_match()](#sqlalchemy.sql.expression.ColumnElement.regexp_match),
    [regexp_replace()](#sqlalchemy.sql.expression.ColumnElement.regexp_replace), [reverse_operate()](#sqlalchemy.sql.expression.ColumnElement.reverse_operate),
    [self_group()](#sqlalchemy.sql.expression.ColumnElement.self_group), [shares_lineage()](#sqlalchemy.sql.expression.ColumnElement.shares_lineage),
    [startswith()](#sqlalchemy.sql.expression.ColumnElement.startswith), [stringify_dialect](#sqlalchemy.sql.expression.ColumnElement.stringify_dialect),
    [supports_execution](#sqlalchemy.sql.expression.ColumnElement.supports_execution),
    [timetuple](#sqlalchemy.sql.expression.ColumnElement.timetuple), [type](#sqlalchemy.sql.expression.ColumnElement.type),
    [unique_params()](#sqlalchemy.sql.expression.ColumnElement.unique_params), [uses_inspection](#sqlalchemy.sql.expression.ColumnElement.uses_inspection)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") (`sqlalchemy.sql.roles.ColumnArgumentOrKeyRole`,
    `sqlalchemy.sql.roles.StatementOptionRole`, `sqlalchemy.sql.roles.WhereHavingRole`,
    `sqlalchemy.sql.roles.BinaryElementRole`, `sqlalchemy.sql.roles.OrderByRole`,
    `sqlalchemy.sql.roles.ColumnsClauseRole`, `sqlalchemy.sql.roles.LimitOffsetRole`,
    `sqlalchemy.sql.roles.DMLColumnRole`, `sqlalchemy.sql.roles.DDLConstraintColumnRole`,
    `sqlalchemy.sql.roles.DDLExpressionRole`, [`sqlalchemy.sql.expression.SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression
    "sqlalchemy.sql.expression.SQLColumnExpression"), `sqlalchemy.sql.expression.DQLDMLClauseElement`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__eq__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a = b`. If the target is `None`, produces
    `a IS NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__le__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `<=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a <= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__lt__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a < b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.ColumnOperators.__ne__` *method
    of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `!=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a != b`. If the target is `None`,
    produces `a IS NOT NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce an [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method with the **legacy** version
    of this method, the [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnElement.anon_key_label`](#sqlalchemy.sql.expression.ColumnElement.anon_key_label
    "sqlalchemy.sql.expression.ColumnElement.anon_key_label") attribute is now private,
    and the public accessor is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnElement.anon_label`](#sqlalchemy.sql.expression.ColumnElement.anon_label
    "sqlalchemy.sql.expression.ColumnElement.anon_label") attribute is now private,
    and the public accessor is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce an [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method with the **legacy** version
    of this method, the [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.asc()`](#sqlalchemy.sql.expression.ColumnOperators.asc
    "sqlalchemy.sql.expression.ColumnOperators.asc") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.between()`](#sqlalchemy.sql.expression.ColumnOperators.between
    "sqlalchemy.sql.expression.ColumnOperators.between") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    clause against the parent object, given the lower and upper range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_and()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_and
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_and") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise AND operation, typically via the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_lshift()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise LSHIFT operation, typically via the `<<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_not()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_not
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_not") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise NOT operation, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_or()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_or
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_or") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise OR operation, typically via the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_rshift()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise RSHIFT operation, typically via the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.bitwise_xor()`](#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_xor") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a bitwise XOR operation, typically via the `^` operator, or `#` for
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: Produce a type cast, i.e. `CAST(<expression> AS <type>)`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a shortcut to the [`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.collate()`](#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")
    clause against the parent object, given the collation string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.compare()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.compare
    "sqlalchemy.sql.expression.ClauseElement.compare") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") to the given [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses should override the default behavior, which is a straight identity
    comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw are arguments consumed by subclass `compare()` methods and may be used
    to modify the criteria for comparison (see [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `CompilerElement.compile()` *method of* `CompilerElement`'
  prefs: []
  type: TYPE_NORMAL
- en: Compile this SQL expression.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. Calling `str()` or `unicode()` on the returned
    value will yield a string representation of the result. The [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object also can return a dictionary of bind parameter
    names and values using the `params` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – An [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    which can provide a [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in order to generate a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. If the `bind` and `dialect` parameters are
    both omitted, a default SQL compiler is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column_keys` – Used for INSERT and UPDATE statements, a list of column names
    which should be present in the VALUES clause of the compiled statement. If `None`,
    all columns from the target table object are rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dialect` – A [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    instance which can generate a [`Compiled`](internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object. This argument takes precedence over the
    `bind` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile_kwargs` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional dictionary of additional parameters that will be passed through to
    the compiler within all “visit” methods. This allows any custom flag to be passed
    through to a custom compilation construct, for example. It is also used for the
    case of passing the `literal_binds` flag through:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](../faq/sqlexpressions.html#faq-sql-expression-string)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.concat()`](#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘concat’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a || b`, or uses the `concat()` operator
    on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘contains’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the middle of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.contains.escape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.contains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.desc()`](#sqlalchemy.sql.expression.ColumnOperators.desc
    "sqlalchemy.sql.expression.ColumnOperators.desc") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ClauseElement.description` *attribute of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.distinct()`](#sqlalchemy.sql.expression.ColumnOperators.distinct
    "sqlalchemy.sql.expression.ColumnOperators.distinct") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the ‘endswith’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the end of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.endswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ClauseElement.entity_namespace` *attribute of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: Return a column expression.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the inspection interface; returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `HasTraverseInternals.get_children()` *method of* `HasTraverseInternals`'
  prefs: []
  type: TYPE_NORMAL
- en: Return immediate child `HasTraverseInternals` elements of this `HasTraverseInternals`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used for visit traversal.
  prefs: []
  type: TYPE_NORMAL
- en: '**kw may contain flags that change the collection that is returned, for example
    to return a subset of items in order to cut down on larger traversals, or to return
    child items from a different context (such as schema-level collections instead
    of clause-level).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.icontains()`](#sqlalchemy.sql.expression.ColumnOperators.icontains
    "sqlalchemy.sql.expression.ColumnOperators.icontains") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `icontains` operator, e.g. case insensitive version of [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    middle of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.icontains.escape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.iendswith()`](#sqlalchemy.sql.expression.ColumnOperators.iendswith
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `iendswith` operator, e.g. case insensitive version of [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    end of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.iendswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `ilike` operator, e.g. case insensitive LIKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces an expression either of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on backends that support the ILIKE operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `column IN <other>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given parameter `other` may be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of literal values, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the list of items is converted to a set of bound parameters
    the same length as the list given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A list of tuples may be provided if the comparison is against a [`tuple_()`](#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") containing multiple expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An empty list, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders an “empty set” expression. These
    expressions are tailored to individual backends and are generally trying to get
    an empty SELECT statement as a subquery. Such as on SQLite, the expression is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 1.4: empty IN expressions now use an execution-time generated
    SELECT subquery in all cases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A bound parameter, e.g. [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"), may be used if it includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders a special non-SQL placeholder
    expression that looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This placeholder expression is intercepted at statement execution time to be
    converted into the variable number of bound parameter form illustrated earlier.
    If the statement were executed as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The database would be passed a bound parameter for each value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.2: added “expanding” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If an empty list is passed, a special “empty list” expression, which is specific
    to the database in use, is rendered. On SQLite this would be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.3: “expanding” bound parameters now support empty lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is usually a correlated scalar select:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") renders as given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** – a list of literals, a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, or a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct that includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag set to True.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `HasCacheKey.inherit_cache` *attribute of* [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.cache_key.HasCacheKey")'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS` may be desirable if
    comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS DISTINCT FROM b” on most platforms; on some such as SQLite may
    render “a IS NOT b”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.is_not_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from") *method of*
    [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.isnot()`](#sqlalchemy.sql.expression.ColumnOperators.isnot
    "sqlalchemy.sql.expression.ColumnOperators.isnot") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.isnot_distinct_from()`](#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.istartswith()`](#sqlalchemy.sql.expression.ColumnOperators.istartswith
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `istartswith` operator, e.g. case insensitive version of [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    start of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.istartswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: The ‘key’ that in some circumstances refers to this object in a Python namespace.
  prefs: []
  type: TYPE_NORMAL
- en: This typically refers to the “key” of the column as present in the `.c` collection
    of a selectable, e.g. `sometable.c["somekey"]` would return a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with a `.key` of “somekey”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: Produce a column label, i.e. `<columnname> AS <name>`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a shortcut to the [`label()`](#sqlalchemy.sql.expression.label "sqlalchemy.sql.expression.label")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘name’ is `None`, an anonymous label name will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `like` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") attempts to resolve to a MATCH-like
    function or operator provided by the backend. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x @@ plainto_tsquery(y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `plainto_tsquery()` is used instead of `to_tsquery()`
    for PostgreSQL now; for compatibility with other forms, see [Full Text Search](../dialects/postgresql.html#postgresql-match).'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: MySQL - renders `MATCH (x) AGAINST (y IN BOOLEAN MODE)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    - MySQL specific construct with additional features.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Oracle - renders `CONTAINS(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “MATCH”.
    This is compatible with SQLite, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_ilike()`](#sqlalchemy.sql.expression.ColumnOperators.not_ilike
    "sqlalchemy.sql.expression.ColumnOperators.not_ilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.not_like()`](#sqlalchemy.sql.expression.ColumnOperators.not_like
    "sqlalchemy.sql.expression.ColumnOperators.not_like") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notilike()`](#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notin_()`](#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.notlike()`](#sqlalchemy.sql.expression.ColumnOperators.notlike
    "sqlalchemy.sql.expression.ColumnOperators.notlike") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nulls_first()`](#sqlalchemy.sql.expression.ColumnOperators.nulls_first
    "sqlalchemy.sql.expression.ColumnOperators.nulls_first") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nulls_last()`](#sqlalchemy.sql.expression.ColumnOperators.nulls_last
    "sqlalchemy.sql.expression.ColumnOperators.nulls_last") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nullsfirst()`](#sqlalchemy.sql.expression.ColumnOperators.nullsfirst
    "sqlalchemy.sql.expression.ColumnOperators.nullsfirst") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.nullslast()`](#sqlalchemy.sql.expression.ColumnOperators.nullslast
    "sqlalchemy.sql.expression.ColumnOperators.nullslast") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.params
    "sqlalchemy.sql.expression.ClauseElement.params") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    elements replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a copy of this ClauseElement with [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") elements replaced with values taken from
    the given dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: set of all columns we are proxying
  prefs: []
  type: TYPE_NORMAL
- en: as of 2.0 this is explicitly deannotated columns. previously it was effectively
    deannotated columns but wasn’t enforced. annotated columns should basically not
    go into sets if at all possible because their hashing behavior is very non-performant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘regexp match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") attempts to resolve
    to a REGEXP-like function or operator provided by the backend, however the specific
    regular expression syntax and flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x ~ y` or `x !~ y` when negated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - renders `REGEXP_LIKE(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite - uses SQLite’s `REGEXP` placeholder operator and calls into the Python
    `re.match()` builtin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “REGEXP”
    or “NOT REGEXP”. This is compatible with SQLite and MySQL, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression support is currently implemented for Oracle, PostgreSQL,
    MySQL and MariaDB. Partial support is available for SQLite. Support among third-party
    dialects may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern. When
    using the ignore case flag ‘i’ in PostgreSQL, the ignore case regexp match operator
    `~*` or `!~*` will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a database-specific ‘regexp replace’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") attempts to resolve
    to a REGEXP_REPLACE-like function provided by the backend, that usually emit the
    function `REGEXP_REPLACE()`. However, the specific regular expression syntax and
    flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression replacement support is currently implemented for Oracle,
    PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` – The replacement string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.ColumnElement.operate
    "sqlalchemy.sql.expression.ColumnElement.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the given [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") has a common ancestor to this [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") *method of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `startswith` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the start of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.startswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnOperators.timetuple`](#sqlalchemy.sql.expression.ColumnOperators.timetuple
    "sqlalchemy.sql.expression.ColumnOperators.timetuple") *attribute of* [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: Hack, allows datetime objects to be compared on the LHS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ClauseElement.unique_params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.unique_params
    "sqlalchemy.sql.expression.ClauseElement.unique_params") *method of* [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with [`bindparam()`](#sqlalchemy.sql.expression.bindparam "sqlalchemy.sql.expression.bindparam")
    elements replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Same functionality as [`ClauseElement.params()`](foundation.html#sqlalchemy.sql.expression.ClauseElement.params
    "sqlalchemy.sql.expression.ClauseElement.params"), except adds unique=True to
    affected bind parameters so that multiple statements can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: General purpose “column expression” argument.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.13.
  prefs: []
  type: TYPE_NORMAL
- en: This type is used for “column” kinds of expressions that typically represent
    a single SQL column expression, including [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"), as well as ORM-mapped attributes that
    will have a `__clause_element__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Defines boolean, comparison, and other operators for [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all methods call down to [`operate()`](#sqlalchemy.sql.expression.ColumnOperators.operate
    "sqlalchemy.sql.expression.ColumnOperators.operate") or [`reverse_operate()`](#sqlalchemy.sql.expression.ColumnOperators.reverse_operate
    "sqlalchemy.sql.expression.ColumnOperators.reverse_operate"), passing in the appropriate
    operator function from the Python builtin `operator` module or a SQLAlchemy-specific
    operator function from `sqlalchemy.expression.operators`. For example the `__eq__`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `operators.eq` is essentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: The core column expression unit [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") overrides [`Operators.operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate") and others to return further [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs, so that the `==` operation
    above is replaced by a clause construct.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators "sqlalchemy.sql.expression.ColumnOperators")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator "sqlalchemy.orm.PropComparator")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__add__()](#sqlalchemy.sql.expression.ColumnOperators.__add__), [__and__()](#sqlalchemy.sql.expression.ColumnOperators.__and__),
    [__eq__()](#sqlalchemy.sql.expression.ColumnOperators.__eq__), [__floordiv__()](#sqlalchemy.sql.expression.ColumnOperators.__floordiv__),
    [__ge__()](#sqlalchemy.sql.expression.ColumnOperators.__ge__), [__getitem__()](#sqlalchemy.sql.expression.ColumnOperators.__getitem__),
    [__gt__()](#sqlalchemy.sql.expression.ColumnOperators.__gt__), [__hash__()](#sqlalchemy.sql.expression.ColumnOperators.__hash__),
    [__invert__()](#sqlalchemy.sql.expression.ColumnOperators.__invert__), [__le__()](#sqlalchemy.sql.expression.ColumnOperators.__le__),
    [__lshift__()](#sqlalchemy.sql.expression.ColumnOperators.__lshift__), [__lt__()](#sqlalchemy.sql.expression.ColumnOperators.__lt__),
    [__mod__()](#sqlalchemy.sql.expression.ColumnOperators.__mod__), [__mul__()](#sqlalchemy.sql.expression.ColumnOperators.__mul__),
    [__ne__()](#sqlalchemy.sql.expression.ColumnOperators.__ne__), [__neg__()](#sqlalchemy.sql.expression.ColumnOperators.__neg__),
    [__or__()](#sqlalchemy.sql.expression.ColumnOperators.__or__), [__radd__()](#sqlalchemy.sql.expression.ColumnOperators.__radd__),
    [__rfloordiv__()](#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__), [__rmod__()](#sqlalchemy.sql.expression.ColumnOperators.__rmod__),
    [__rmul__()](#sqlalchemy.sql.expression.ColumnOperators.__rmul__), [__rshift__()](#sqlalchemy.sql.expression.ColumnOperators.__rshift__),
    [__rsub__()](#sqlalchemy.sql.expression.ColumnOperators.__rsub__), [__rtruediv__()](#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__),
    [__sa_operate__()](#sqlalchemy.sql.expression.ColumnOperators.__sa_operate__),
    [__sub__()](#sqlalchemy.sql.expression.ColumnOperators.__sub__), [__truediv__()](#sqlalchemy.sql.expression.ColumnOperators.__truediv__),
    [all_()](#sqlalchemy.sql.expression.ColumnOperators.all_), [any_()](#sqlalchemy.sql.expression.ColumnOperators.any_),
    [asc()](#sqlalchemy.sql.expression.ColumnOperators.asc), [between()](#sqlalchemy.sql.expression.ColumnOperators.between),
    [bitwise_and()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_and), [bitwise_lshift()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift),
    [bitwise_not()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_not), [bitwise_or()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_or),
    [bitwise_rshift()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift),
    [bitwise_xor()](#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor), [bool_op()](#sqlalchemy.sql.expression.ColumnOperators.bool_op),
    [collate()](#sqlalchemy.sql.expression.ColumnOperators.collate), [concat()](#sqlalchemy.sql.expression.ColumnOperators.concat),
    [contains()](#sqlalchemy.sql.expression.ColumnOperators.contains), [desc()](#sqlalchemy.sql.expression.ColumnOperators.desc),
    [distinct()](#sqlalchemy.sql.expression.ColumnOperators.distinct), [endswith()](#sqlalchemy.sql.expression.ColumnOperators.endswith),
    [icontains()](#sqlalchemy.sql.expression.ColumnOperators.icontains), [iendswith()](#sqlalchemy.sql.expression.ColumnOperators.iendswith),
    [ilike()](#sqlalchemy.sql.expression.ColumnOperators.ilike), [in_()](#sqlalchemy.sql.expression.ColumnOperators.in_),
    [is_()](#sqlalchemy.sql.expression.ColumnOperators.is_), [is_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from),
    [is_not()](#sqlalchemy.sql.expression.ColumnOperators.is_not), [is_not_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.is_not_distinct_from),
    [isnot()](#sqlalchemy.sql.expression.ColumnOperators.isnot), [isnot_distinct_from()](#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from),
    [istartswith()](#sqlalchemy.sql.expression.ColumnOperators.istartswith), [like()](#sqlalchemy.sql.expression.ColumnOperators.like),
    [match()](#sqlalchemy.sql.expression.ColumnOperators.match), [not_ilike()](#sqlalchemy.sql.expression.ColumnOperators.not_ilike),
    [not_in()](#sqlalchemy.sql.expression.ColumnOperators.not_in), [not_like()](#sqlalchemy.sql.expression.ColumnOperators.not_like),
    [notilike()](#sqlalchemy.sql.expression.ColumnOperators.notilike), [notin_()](#sqlalchemy.sql.expression.ColumnOperators.notin_),
    [notlike()](#sqlalchemy.sql.expression.ColumnOperators.notlike), [nulls_first()](#sqlalchemy.sql.expression.ColumnOperators.nulls_first),
    [nulls_last()](#sqlalchemy.sql.expression.ColumnOperators.nulls_last), [nullsfirst()](#sqlalchemy.sql.expression.ColumnOperators.nullsfirst),
    [nullslast()](#sqlalchemy.sql.expression.ColumnOperators.nullslast), [op()](#sqlalchemy.sql.expression.ColumnOperators.op),
    [operate()](#sqlalchemy.sql.expression.ColumnOperators.operate), [regexp_match()](#sqlalchemy.sql.expression.ColumnOperators.regexp_match),
    [regexp_replace()](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace),
    [reverse_operate()](#sqlalchemy.sql.expression.ColumnOperators.reverse_operate),
    [startswith()](#sqlalchemy.sql.expression.ColumnOperators.startswith), [timetuple](#sqlalchemy.sql.expression.ColumnOperators.timetuple)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") ([`sqlalchemy.sql.expression.Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a + b` if the parent object has non-string
    affinity. If the parent object has a string affinity, produces the concatenation
    operator, `a || b` - see [`ColumnOperators.concat()`](#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__and__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an AND operation, equivalent to
    [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"),
    that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `&` regarding operator precedence; the `&`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a = b`. If the target is `None`, produces
    `a IS NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `//` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a / b`, which is the same as “truediv”,
    but considers the result type to be integer.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `>=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a >= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: Implement the [] operator.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used by some database-specific types such as PostgreSQL ARRAY and
    HSTORE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a > b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: Return hash(self).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__invert__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in a NOT operation, equivalent to [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `<=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a <= b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: implement the << operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not used by SQLAlchemy core, this is provided for custom operator systems which
    want to use << as an extension point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a < b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `%` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a % b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a * b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `!=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a != b`. If the target is `None`,
    produces `a IS NOT NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `-a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__or__` *method of*
    [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an OR operation, equivalent to [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `|` regarding operator precedence; the `|`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `+` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__add__()`](#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `//` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__floordiv__()`](#sqlalchemy.sql.expression.ColumnOperators.__floordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__floordiv__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `%` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__mod__()`](#sqlalchemy.sql.expression.ColumnOperators.__mod__
    "sqlalchemy.sql.expression.ColumnOperators.__mod__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `*` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__mul__()`](#sqlalchemy.sql.expression.ColumnOperators.__mul__
    "sqlalchemy.sql.expression.ColumnOperators.__mul__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: implement the >> operator.
  prefs: []
  type: TYPE_NORMAL
- en: Not used by SQLAlchemy core, this is provided for custom operator systems which
    want to use >> as an extension point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__sub__()`](#sqlalchemy.sql.expression.ColumnOperators.__sub__
    "sqlalchemy.sql.expression.ColumnOperators.__sub__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `/` operator in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: See [`ColumnOperators.__truediv__()`](#sqlalchemy.sql.expression.ColumnOperators.__truediv__
    "sqlalchemy.sql.expression.ColumnOperators.__truediv__").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.sql.expression.Operators.__sa_operate__` *method
    of* [`Operators`](#sqlalchemy.sql.expression.Operators "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `-` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a - b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `/` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a / b`, and considers the result type
    to be numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The truediv operator against two integers is now considered
    to return a numeric value. Behavior on specific backends may vary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`all_()`](#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.all_()`](#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method with the **legacy** version
    of this method, the [`Comparator.all()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: Produce an [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation for [`any_()`](#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: be sure to not confuse the newer [`ColumnOperators.any_()`](#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method with the **legacy** version
    of this method, the [`Comparator.any()`](type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method that’s specific to [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), which uses a different calling style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`between()`](#sqlalchemy.sql.expression.between "sqlalchemy.sql.expression.between")
    clause against the parent object, given the lower and upper range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise AND operation, typically via the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise LSHIFT operation, typically via the `<<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise NOT operation, typically via the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise OR operation, typically via the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise RSHIFT operation, typically via the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: Produce a bitwise XOR operation, typically via the `^` operator, or `#` for
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitwise Operators](operators.html#operators-bitwise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")
    clause against the parent object, given the collation string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`collate()`](#sqlalchemy.sql.expression.collate "sqlalchemy.sql.expression.collate")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘concat’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `a || b`, or uses the `concat()` operator
    on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘contains’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the middle of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.contains.escape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.contains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`desc()`](#sqlalchemy.sql.expression.desc "sqlalchemy.sql.expression.desc")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: Implement the ‘endswith’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the end of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.endswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.endswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.endswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `icontains` operator, e.g. case insensitive version of [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    middle of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.icontains.escape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.icontains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.icontains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.icontains") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.contains.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.contains.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `iendswith` operator, e.g. case insensitive version of [`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    end of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.iendswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.iendswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.iendswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.iendswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `ilike` operator, e.g. case insensitive LIKE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces an expression either of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on backends that support the ILIKE operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a column context, produces the clause `column IN <other>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given parameter `other` may be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of literal values, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the list of items is converted to a set of bound parameters
    the same length as the list given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A list of tuples may be provided if the comparison is against a [`tuple_()`](#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") containing multiple expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An empty list, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders an “empty set” expression. These
    expressions are tailored to individual backends and are generally trying to get
    an empty SELECT statement as a subquery. Such as on SQLite, the expression is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 1.4: empty IN expressions now use an execution-time generated
    SELECT subquery in all cases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A bound parameter, e.g. [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"), may be used if it includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, the expression renders a special non-SQL placeholder
    expression that looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This placeholder expression is intercepted at statement execution time to be
    converted into the variable number of bound parameter form illustrated earlier.
    If the statement were executed as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The database would be passed a bound parameter for each value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.2: added “expanding” bound parameters'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If an empty list is passed, a special “empty list” expression, which is specific
    to the database in use, is rendered. On SQLite this would be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 1.3: “expanding” bound parameters now support empty lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is usually a correlated scalar select:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this calling form, [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") renders as given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** – a list of literals, a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, or a [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct that includes the [`bindparam.expanding`](#sqlalchemy.sql.expression.bindparam.params.expanding
    "sqlalchemy.sql.expression.bindparam") flag set to True.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS` may be desirable if
    comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS DISTINCT FROM b” on most platforms; on some such as SQLite may
    render “a IS NOT b”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `IS NOT` is generated automatically when comparing to a value of `None`,
    which resolves to `NULL`. However, explicit usage of `IS NOT` may be desirable
    if comparing to boolean values on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not()` operator is renamed from `isnot()` in
    previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](#sqlalchemy.sql.expression.ColumnOperators.is_ "sqlalchemy.sql.expression.ColumnOperators.is_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `IS NOT DISTINCT FROM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Renders “a IS NOT DISTINCT FROM b” on most platforms; on some such as SQLite
    may render “a IS b”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `is_not_distinct_from()` operator is renamed from
    `isnot_distinct_from()` in previous releases. The previous name remains available
    for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `istartswith` operator, e.g. case insensitive version of [`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith").
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against an insensitive match for the
    start of a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.istartswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.istartswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.istartswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.istartswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `like` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a column context, produces the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional escape character, renders the `ESCAPE` keyword, e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") attempts to resolve to a MATCH-like
    function or operator provided by the backend. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x @@ plainto_tsquery(y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `plainto_tsquery()` is used instead of `to_tsquery()`
    for PostgreSQL now; for compatibility with other forms, see [Full Text Search](../dialects/postgresql.html#postgresql-match).'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: MySQL - renders `MATCH (x) AGAINST (y IN BOOLEAN MODE)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    - MySQL specific construct with additional features.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Oracle - renders `CONTAINS(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “MATCH”.
    This is compatible with SQLite, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT ILIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"), i.e. `~x.ilike(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_ilike()` operator is renamed from `notilike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.ilike()`](#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT IN` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), i.e. `~x.in_(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `other` is an empty sequence, the compiler produces an “empty
    not in” expression. This defaults to the expression “1 = 1” to produce true in
    all cases. The [`create_engine.empty_in_strategy`](engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") may be used to alter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_in()` operator is renamed from `notin_()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: The [`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators now produce a “static”
    expression for an empty IN sequence by default.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.in_()`](#sqlalchemy.sql.expression.ColumnOperators.in_ "sqlalchemy.sql.expression.ColumnOperators.in_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: implement the `NOT LIKE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using negation with [`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"), i.e. `~x.like(y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `not_like()` operator is renamed from `notlike()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_first()` operator is renamed from `nullsfirst()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last")
    clause against the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `nulls_last()` operator is renamed from `nullslast()`
    in previous releases. The previous name remains available for backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘regexp match’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") attempts to resolve
    to a REGEXP-like function or operator provided by the backend, however the specific
    regular expression syntax and flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - renders `x ~ y` or `x !~ y` when negated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle - renders `REGEXP_LIKE(x, y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite - uses SQLite’s `REGEXP` placeholder operator and calls into the Python
    `re.match()` builtin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other backends may provide special implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backends without any special implementation will emit the operator as “REGEXP”
    or “NOT REGEXP”. This is compatible with SQLite and MySQL, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression support is currently implemented for Oracle, PostgreSQL,
    MySQL and MariaDB. Partial support is available for SQLite. Support among third-party
    dialects may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern. When
    using the ignore case flag ‘i’ in PostgreSQL, the ignore case regexp match operator
    `~*` or `!~*` will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: Implements a database-specific ‘regexp replace’ operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") attempts to resolve
    to a REGEXP_REPLACE-like function provided by the backend, that usually emit the
    function `REGEXP_REPLACE()`. However, the specific regular expression syntax and
    flags available are **not backend agnostic**.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression replacement support is currently implemented for Oracle,
    PostgreSQL, MySQL 8 or greater and MariaDB. Support among third-party dialects
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern` – The regular expression pattern string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` – The replacement string or column clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` – Any regular expression string flags to apply, passed as plain Python
    string only. These flags are backend specific. Some backends, like PostgreSQL
    and MariaDB, may alternatively specify the flags as part of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.48,: 2.0.18 Note that due to an implementation error,
    the “flags” parameter previously accepted SQL expression objects such as column
    expressions in addition to plain Python strings. This implementation did not work
    correctly with caching and was removed; strings only should be passed for the
    “flags” parameter, as these flags are rendered as literal inline values within
    SQL expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.regexp_match()`](#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`Operators.reverse_operate()`](#sqlalchemy.sql.expression.Operators.reverse_operate
    "sqlalchemy.sql.expression.Operators.reverse_operate") *method of* [`Operators`](#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators")'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.ColumnOperators.operate
    "sqlalchemy.sql.expression.ColumnOperators.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `startswith` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Produces a LIKE expression that tests against a match for the start of a string
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: Since the operator uses `LIKE`, wildcard characters `"%"` and `"_"` that are
    present inside the <other> expression will behave like wildcards as well. For
    literal string values, the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag may be set to `True`
    to apply escaping to occurrences of these characters within the string value so
    that they match as themselves and not as wildcard characters. Alternatively, the
    [`ColumnOperators.startswith.escape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.escape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") parameter will establish
    a given character as an escape character which can be of use when the target expression
    is not a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared. This is usually a plain string value,
    but can also be an arbitrary SQL expression. LIKE wildcard characters `%` and
    `_` are not escaped by default unless the [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith") flag is set to True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoescape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean; when True, establishes an escape character within the LIKE expression,
    then applies it to all occurrences of `"%"`, `"_"` and the escape character itself
    within the comparison value, which is assumed to be a literal string and not a
    SQL expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the value of `:param` as `"foo/%bar"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`escape` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a character which when given will render with the `ESCAPE` keyword to establish
    that character as the escape character. This character can then be placed preceding
    occurrences of `%` and `_` to allow them to act as themselves and not wildcard
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Will render as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter may also be combined with [`ColumnOperators.startswith.autoescape`](#sqlalchemy.sql.expression.ColumnOperators.startswith.params.autoescape
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where above, the given literal parameter will be converted to `"foo^%bar^^bat"`
    before being passed to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.endswith()`](#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: Hack, allows datetime objects to be compared on the LHS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL EXTRACT clause, `extract(field FROM expr)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Extract`](#sqlalchemy.sql.expression.Extract
    "sqlalchemy.sql.expression.Extract") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: Represent the `false` keyword, or equivalent, in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`False_`](#sqlalchemy.sql.expression.False_ "sqlalchemy.sql.expression.False_")
    is accessed as a constant via the [`false()`](#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.False_`](#sqlalchemy.sql.expression.False_
    "sqlalchemy.sql.expression.False_") (`sqlalchemy.sql.expression.SingletonConstant`,
    `sqlalchemy.sql.roles.ConstExprRole`, [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: Represent a function FILTER clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against aggregate and window functions, which controls
    which rows are passed to it. It’s supported only by certain database backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invocation of [`FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter") is via [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[filter()](#sqlalchemy.sql.expression.FunctionFilter.filter), [over()](#sqlalchemy.sql.expression.FunctionFilter.over),
    [self_group()](#sqlalchemy.sql.expression.FunctionFilter.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.FunctionFilter`](#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: Produce an additional FILTER against the function.
  prefs: []
  type: TYPE_NORMAL
- en: This method adds additional criteria to the initial criteria set up by [`FunctionElement.filter()`](functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter").
  prefs: []
  type: TYPE_NORMAL
- en: Multiple criteria are joined together at SQL render time via `AND`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: Produce an OVER clause against this filtered function.
  prefs: []
  type: TYPE_NORMAL
- en: Used against aggregate or so-called “window” functions, for database backends
    that support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: 'is shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: See [`over()`](#sqlalchemy.sql.expression.over "sqlalchemy.sql.expression.over")
    for a full description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.FunctionFilter.self_group
    "sqlalchemy.sql.expression.FunctionFilter.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.FunctionFilter.self_group
    "sqlalchemy.sql.expression.FunctionFilter.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: Represents a column label (AS).
  prefs: []
  type: TYPE_NORMAL
- en: Represent a label, as typically applied to any column-level element using the
    `AS` sql keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[foreign_keys](#sqlalchemy.sql.expression.Label.foreign_keys), [primary_key](#sqlalchemy.sql.expression.Label.primary_key),
    [self_group()](#sqlalchemy.sql.expression.Label.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Label`](#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    (`sqlalchemy.sql.roles.LabeledColumnExprRole`, `sqlalchemy.sql.expression.NamedColumn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.Label.self_group
    "sqlalchemy.sql.expression.Label.self_group") is automatic - end-user code should
    never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.Label.self_group "sqlalchemy.sql.expression.Label.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: Represent the NULL keyword in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    is accessed as a constant via the [`null()`](#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Null`](#sqlalchemy.sql.expression.Null "sqlalchemy.sql.expression.Null")
    (`sqlalchemy.sql.expression.SingletonConstant`, `sqlalchemy.sql.roles.ConstExprRole`,
    [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: Base of comparison and logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Implements base methods `Operators.operate()` and `Operators.reverse_operate()`,
    as well as `Operators.__and__()`, `Operators.__or__()`, `Operators.__invert__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__and__()](#sqlalchemy.sql.expression.Operators.__and__), [__invert__()](#sqlalchemy.sql.expression.Operators.__invert__),
    [__or__()](#sqlalchemy.sql.expression.Operators.__or__), [__sa_operate__()](#sqlalchemy.sql.expression.Operators.__sa_operate__),
    [bool_op()](#sqlalchemy.sql.expression.Operators.bool_op), [op()](#sqlalchemy.sql.expression.Operators.op),
    [operate()](#sqlalchemy.sql.expression.Operators.operate), [reverse_operate()](#sqlalchemy.sql.expression.Operators.reverse_operate)'
  prefs: []
  type: TYPE_NORMAL
- en: Usually is used via its most common subclass [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an AND operation, equivalent to
    [`and_()`](#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_"),
    that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `&` regarding operator precedence; the `&`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in a NOT operation, equivalent to [`not_()`](#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with SQL expressions, results in an OR operation, equivalent to [`or_()`](#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'Care should be taken when using `|` regarding operator precedence; the `|`
    operator has the highest precedence. The operands should be enclosed in parenthesis
    if they contain further sub expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: Return a custom boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: This method is shorthand for calling [`Operators.op()`](#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") and passing the [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag with True. A key advantage to using
    [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")
    is that when using column constructs, the “boolean” nature of the returned expression
    will be present for [**PEP 484**](https://peps.python.org/pep-0484/) purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.op()`](#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: Produce a generic operator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: 'produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also be used to make bitwise operators explicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: is a bitwise AND of the value in `somecolumn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opstring` – a string which will be output as the infix operator between this
    element and the expression passed to the generated function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precedence` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: precedence which the database is expected to apply to the operator in SQL expressions.
    This integer value acts as a hint for the SQL compiler to know when explicit parenthesis
    should be rendered around a particular operation. A lower number will cause the
    expression to be parenthesized when applied against another operator with higher
    precedence. The default value of `0` is lower than all operators except for the
    comma (`,`) and `AS` operators. A value of 100 will be higher or equal to all
    operators, and -100 will be lower than or equal to all operators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](../faq/sqlexpressions.html#faq-sql-expression-op-parenthesis) -
    detailed description of how the SQLAlchemy SQL compiler renders parenthesis'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`is_comparison` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: legacy; if True, the operator will be considered as a “comparison” operator,
    that is which evaluates to a boolean true/false value, like `==`, `>`, etc. This
    flag is provided so that ORM relationships can establish that the operator is
    a comparison operator when used in a custom join condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `is_comparison` parameter is superseded by using the [`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method instead; this more succinct
    operator sets this parameter automatically, but also provides correct [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support as the returned object will express a “boolean” datatype, i.e.
    `BinaryExpression[bool]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`return_type` – a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class or object that will force the return type
    of an expression produced by this operator to be of that type. By default, operators
    that specify [`Operators.op.is_comparison`](#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") will resolve to [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), and those that do not will be of the same type as
    the left-hand operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python_impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional Python function that can evaluate two Python values in the same
    way as this operator works when run on the database server. Useful for in-Python
    SQL expression evaluation functions, such as for ORM hybrid attributes, and the
    ORM “evaluator” used to match objects in a session after a multi-row update or
    delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator for the above expression will also work for non-SQL left and right
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.bool_op()`](#sqlalchemy.sql.expression.Operators.bool_op "sqlalchemy.sql.expression.Operators.bool_op")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Redefining and Creating New Operators](custom_types.html#types-operators)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using custom operators in join conditions](../orm/join_conditions.html#relationship-custom-operator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: Operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op` – Operator callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` – modifiers. These may be passed by special operators such as [`ColumnOperators.contains()`](#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: Reverse operate on an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Usage is the same as [`operate()`](#sqlalchemy.sql.expression.Operators.operate
    "sqlalchemy.sql.expression.Operators.operate").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: Represent an OVER clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against a so-called “window” function, as well as
    any aggregate function, which produces results relative to the result set itself.
    Most modern SQL backends now support window functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[element](#sqlalchemy.sql.expression.Over.element)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Over`](#sqlalchemy.sql.expression.Over "sqlalchemy.sql.expression.Over")
    ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: The underlying expression object to which this [`Over`](#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") object refers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: A type that may be used to indicate any SQL column element or object that acts
    in place of one.
  prefs: []
  type: TYPE_NORMAL
- en: '[`SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression "sqlalchemy.sql.expression.SQLColumnExpression")
    is a base of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement"),
    as well as within the bases of ORM elements such as [`InstrumentedAttribute`](../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute"), and may be used in [**PEP 484**](https://peps.python.org/pep-0484/)
    typing to indicate arguments or return values that should behave as column expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0b4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.SQLColumnExpression`](#sqlalchemy.sql.expression.SQLColumnExpression
    "sqlalchemy.sql.expression.SQLColumnExpression") (`sqlalchemy.sql.expression.SQLCoreOperations`,
    `sqlalchemy.sql.roles.ExpressionElementRole`, `sqlalchemy.util.langhelpers.TypingOnly`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: Represent a literal SQL text fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: The [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    construct is produced using the [`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    function; see that function for full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`text()`](#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[bindparams()](#sqlalchemy.sql.expression.TextClause.bindparams), [columns()](#sqlalchemy.sql.expression.TextClause.columns),
    [self_group()](#sqlalchemy.sql.expression.TextClause.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") (`sqlalchemy.sql.roles.DDLConstraintColumnRole`,
    `sqlalchemy.sql.roles.DDLExpressionRole`, `sqlalchemy.sql.roles.StatementOptionRole`,
    `sqlalchemy.sql.roles.WhereHavingRole`, `sqlalchemy.sql.roles.OrderByRole`, `sqlalchemy.sql.roles.FromClauseRole`,
    `sqlalchemy.sql.roles.SelectStatementRole`, `sqlalchemy.sql.roles.InElementRole`,
    `sqlalchemy.sql.expression.Generative`, [`sqlalchemy.sql.expression.Executable`](selectable.html#sqlalchemy.sql.expression.Executable
    "sqlalchemy.sql.expression.Executable"), `sqlalchemy.sql.expression.DQLDMLClauseElement`,
    `sqlalchemy.sql.roles.BinaryElementRole`, `sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: Establish the values and/or types of bound parameters within this [`TextClause`](#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a text construct such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: 'the [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method can be used to establish
    the initial value of `:name` and `:timestamp`, using simple keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: Where above, new [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects will be generated with the
    names `name` and `timestamp`, and values of `jack` and `datetime.datetime(2012,
    10, 8, 15, 12, 5)`, respectively. The types will be inferred from the values given,
    in this case [`String`](type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`DateTime`](type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'When specific typing behavior is needed, the positional `*binds` argument can
    be used in which to specify [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") constructs directly. These constructs must
    include at least the `key` argument, then an optional value and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: Above, we specified the type of [`DateTime`](type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") for the `timestamp` bind, and the type of [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") for the `name` bind. In the case of `name` we also
    set the default value of `"jack"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional bound parameters can be supplied at statement execution time, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method can be called repeatedly,
    where it will re-use existing [`BindParameter`](#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects to add new information. For
    example, we can call [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") first with typing information,
    and a second time with value information, and it will be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.bindparams()`](#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") method also supports the concept
    of **unique** bound parameters. These are parameters that are “uniquified” on
    name at statement compilation time, so that multiple [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs may be combined together without
    the names conflicting. To use this feature, specify the [`BindParameter.unique`](#sqlalchemy.sql.expression.BindParameter.params.unique
    "sqlalchemy.sql.expression.BindParameter") flag on each [`bindparam()`](#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.11: Added support for the [`BindParameter.unique`](#sqlalchemy.sql.expression.BindParameter.params.unique
    "sqlalchemy.sql.expression.BindParameter") flag to work with [`text()`](#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: Turn this [`TextClause`](#sqlalchemy.sql.expression.TextClause "sqlalchemy.sql.expression.TextClause")
    object into a [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") object that serves the same role as
    a SELECT statement.
  prefs: []
  type: TYPE_NORMAL
- en: The [`TextualSelect`](selectable.html#sqlalchemy.sql.expression.TextualSelect
    "sqlalchemy.sql.expression.TextualSelect") is part of the [`SelectBase`](selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") hierarchy and can be embedded into another
    statement by using the [`TextualSelect.subquery()`](selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") method to produce a [`Subquery`](selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, which can then be SELECTed from.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function essentially bridges the gap between an entirely textual SELECT
    statement and the SQL expression language concept of a “selectable”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: Above, we pass a series of [`column()`](#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    elements to the [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method positionally. These [`column()`](#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") elements now become first class elements upon
    the [`TextualSelect.selected_columns`](selectable.html#sqlalchemy.sql.expression.TextualSelect.selected_columns
    "sqlalchemy.sql.expression.TextualSelect.selected_columns") column collection,
    which then become part of the `Subquery.c` collection after [`TextualSelect.subquery()`](selectable.html#sqlalchemy.sql.expression.TextualSelect.subquery
    "sqlalchemy.sql.expression.TextualSelect.subquery") is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The column expressions we pass to [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") may also be typed; when we do
    so, these [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects become the effective return type of the column, so that SQLAlchemy’s result-set-processing
    systems may be used on the return values. This is often needed for types such
    as date or boolean types, as well as for unicode processing on some dialect configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: 'As a shortcut to the above syntax, keyword arguments referring to types alone
    may be used, if only type conversion is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: 'The positional form of [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") also provides the unique feature
    of **positional column targeting**, which is particularly useful when using the
    ORM with complex textual queries. If we specify the columns from our model to
    [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns "sqlalchemy.sql.expression.TextClause.columns"),
    the result set will match to those columns positionally, meaning the name or origin
    of the column in the textual SQL doesn’t matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TextClause.columns()`](#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method provides a direct route
    to calling `FromClause.subquery()` as well as [`SelectBase.cte()`](selectable.html#sqlalchemy.sql.expression.SelectBase.cte
    "sqlalchemy.sql.expression.SelectBase.cte") against a textual SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*cols` – A series of [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects, typically [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects from a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or ORM level column-mapped attributes, representing
    a set of columns that this textual string will SELECT from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**types` – A mapping of string names to [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") type objects indicating the datatypes to use for
    names that are SELECTed from the textual string. Prefer to use the `*cols` argument
    as it also indicates positional ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.TextClause.self_group
    "sqlalchemy.sql.expression.TextClause.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.TextClause.self_group "sqlalchemy.sql.expression.TextClause.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: Represent a TRY_CAST expression.
  prefs: []
  type: TYPE_NORMAL
- en: Details on [`TryCast`](#sqlalchemy.sql.expression.TryCast "sqlalchemy.sql.expression.TryCast")
    usage is at [`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Casts and Type Coercion](../tutorial/data_select.html#tutorial-casts)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.sql.expression.TryCast.inherit_cache)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TryCast`](#sqlalchemy.sql.expression.TryCast
    "sqlalchemy.sql.expression.TryCast") ([`sqlalchemy.sql.expression.Cast`](#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.Tuple.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.Tuple`](#sqlalchemy.sql.expression.Tuple "sqlalchemy.sql.expression.Tuple")
    ([`sqlalchemy.sql.expression.ClauseList`](#sqlalchemy.sql.expression.ClauseList
    "sqlalchemy.sql.expression.ClauseList"), [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.Tuple.self_group
    "sqlalchemy.sql.expression.Tuple.self_group") is automatic - end-user code should
    never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.Tuple.self_group "sqlalchemy.sql.expression.Tuple.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: Represent a WITHIN GROUP (ORDER BY) clause.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special operator against so-called “ordered set aggregate” and “hypothetical
    set aggregate” functions, including `percentile_cont()`, `rank()`, `dense_rank()`,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: It’s supported only by certain database backends, such as PostgreSQL, Oracle
    and MS SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup "sqlalchemy.sql.expression.WithinGroup")
    construct extracts its type from the method [`FunctionElement.within_group_type()`](functions.html#sqlalchemy.sql.functions.FunctionElement.within_group_type
    "sqlalchemy.sql.functions.FunctionElement.within_group_type"). If this returns
    `None`, the function’s `.type` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[over()](#sqlalchemy.sql.expression.WithinGroup.over)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: Produce an OVER clause against this [`WithinGroup`](#sqlalchemy.sql.expression.WithinGroup
    "sqlalchemy.sql.expression.WithinGroup") construct.
  prefs: []
  type: TYPE_NORMAL
- en: This function has the same signature as that of [`FunctionElement.over()`](functions.html#sqlalchemy.sql.functions.FunctionElement.over
    "sqlalchemy.sql.functions.FunctionElement.over").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: Mixin that defines a [`ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") as a wrapper with special labeling
    behavior for an expression that already has a name.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved column labeling for simple column expressions using CAST or similar](../changelog/migration_14.html#change-4449)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.sql.expression.WrapsColumnExpression` ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: Represent the `true` keyword, or equivalent, in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[`True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    is accessed as a constant via the [`true()`](#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.True_`](#sqlalchemy.sql.expression.True_ "sqlalchemy.sql.expression.True_")
    (`sqlalchemy.sql.expression.SingletonConstant`, `sqlalchemy.sql.roles.ConstExprRole`,
    [`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python-side type-coercion wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce "sqlalchemy.sql.expression.TypeCoerce")
    supplies the [`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    function; see that function for usage details.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`type_coerce()`](#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`cast()`](#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.TypeCoerce.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.TypeCoerce`](#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") (`sqlalchemy.sql.expression.WrapsColumnExpression`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group
    "sqlalchemy.sql.expression.TypeCoerce.self_group") is automatic - end-user code
    should never need to use this method directly. Note that SQLAlchemy’s clause constructs
    take operator precedence into account - so parenthesis might not be needed, for
    example, in an expression like `x OR (y AND z)` - AND takes precedence over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.TypeCoerce.self_group "sqlalchemy.sql.expression.TypeCoerce.self_group")
    method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: Define a ‘unary’ expression.
  prefs: []
  type: TYPE_NORMAL
- en: A unary expression has a single column expression and an operator. The operator
    can be placed on the left (where it is called the ‘operator’) or right (where
    it is called the ‘modifier’) of the column expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[`UnaryExpression`](#sqlalchemy.sql.expression.UnaryExpression "sqlalchemy.sql.expression.UnaryExpression")
    is the basis for several unary operators including those used by [`desc()`](#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc"), [`asc()`](#sqlalchemy.sql.expression.asc "sqlalchemy.sql.expression.asc"),
    [`distinct()`](#sqlalchemy.sql.expression.distinct "sqlalchemy.sql.expression.distinct"),
    [`nulls_first()`](#sqlalchemy.sql.expression.nulls_first "sqlalchemy.sql.expression.nulls_first")
    and [`nulls_last()`](#sqlalchemy.sql.expression.nulls_last "sqlalchemy.sql.expression.nulls_last").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[self_group()](#sqlalchemy.sql.expression.UnaryExpression.self_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.sql.expression.UnaryExpression`](#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") ([`sqlalchemy.sql.expression.ColumnElement`](#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: Apply a ‘grouping’ to this [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement").
  prefs: []
  type: TYPE_NORMAL
- en: This method is overridden by subclasses to return a “grouping” construct, i.e.
    parenthesis. In particular it’s used by “binary” expressions to provide a grouping
    around themselves when placed into a larger expression, as well as by [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs when placed into the FROM clause
    of another [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select").
    (Note that subqueries should be normally created using the [`Select.alias()`](selectable.html#sqlalchemy.sql.expression.Select.alias
    "sqlalchemy.sql.expression.Select.alias") method, as many platforms require nested
    SELECT statements to be named).
  prefs: []
  type: TYPE_NORMAL
- en: As expressions are composed together, the application of [`self_group()`](#sqlalchemy.sql.expression.UnaryExpression.self_group
    "sqlalchemy.sql.expression.UnaryExpression.self_group") is automatic - end-user
    code should never need to use this method directly. Note that SQLAlchemy’s clause
    constructs take operator precedence into account - so parenthesis might not be
    needed, for example, in an expression like `x OR (y AND z)` - AND takes precedence
    over OR.
  prefs: []
  type: TYPE_NORMAL
- en: The base [`self_group()`](#sqlalchemy.sql.expression.UnaryExpression.self_group
    "sqlalchemy.sql.expression.UnaryExpression.self_group") method of [`ClauseElement`](foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") just returns self.
  prefs: []
  type: TYPE_NORMAL
- en: Column Element Typing Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standalone utility functions imported from the `sqlalchemy` namespace to improve
    support by type checkers.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [NotNullable](#sqlalchemy.NotNullable)(val) | Types a column or ORM class
    as not nullable. |'
  prefs: []
  type: TYPE_TB
- en: '| [Nullable](#sqlalchemy.Nullable)(val) | Types a column or ORM class as nullable.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: Types a column or ORM class as not nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be used in select and other contexts to express that the value of
    a column cannot be null, for example due to a where condition on a nullable column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: At runtime this method returns the input unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.20.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: Types a column or ORM class as nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be used in select and other contexts to express that the value of
    a column can be null, for example due to an outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: At runtime this method returns the input unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.20.
  prefs: []
  type: TYPE_NORMAL
