["```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\n\nengine = create_engine(\"sqlite://\")\n\nengine.execute(\"CREATE TABLE foo (id integer)\")\nengine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n\nfoo = table(\"foo\", column(\"id\"))\nresult = engine.execute(select([foo.c.id]))\n\nprint(result.fetchall())\n```", "```py\n$ python test3.py\n[(1,)]\n```", "```py\nSQLALCHEMY_WARN_20=1 python -W always::DeprecationWarning test3.py\n```", "```py\n$ SQLALCHEMY_WARN_20=1 python2 -W always::DeprecationWarning test3.py\ntest3.py:9: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"CREATE TABLE foo (id integer)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\ntest3.py:10: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/sql/selectable.py:4271: RemovedIn20Warning: The legacy calling style of select() is deprecated and will be removed in SQLAlchemy 2.0\\.  Please use the new calling style described at select(). (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return cls.create_legacy_select(*args, **kw)\ntest3.py:14: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  result = engine.execute(select([foo.c.id]))\n[(1,)]\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\nfrom sqlalchemy import text\n\nengine = create_engine(\"sqlite://\")\n\n# don't rely on autocommit for DML and DDL\nwith engine.begin() as connection:\n    # use connection.execute(), not engine.execute()\n    # use the text() construct to execute textual SQL\n    connection.execute(text(\"CREATE TABLE foo (id integer)\"))\n    connection.execute(text(\"INSERT INTO foo (id) VALUES (1)\"))\n\nfoo = table(\"foo\", column(\"id\"))\n\nwith engine.connect() as connection:\n    # use connection.execute(), not engine.execute()\n    # select() now accepts column / table expressions positionally\n    result = connection.execute(select(foo.c.id))\n\n    print(result.fetchall())\n```", "```py\n    import warnings\n    from sqlalchemy import exc\n\n    # for warnings not included in regex-based filter below, just log\n    warnings.filterwarnings(\"always\", category=exc.RemovedIn20Warning)\n\n    # for warnings related to execute() / scalar(), raise\n    for msg in [\n        r\"The (?:Executable|Engine)\\.(?:execute|scalar)\\(\\) function\",\n        r\"The current statement is being autocommitted using implicit autocommit,\",\n        r\"The connection.execute\\(\\) method in SQLAlchemy 2.0 will accept \"\n        \"parameters as a single dictionary or a single sequence of \"\n        \"dictionaries only.\",\n        r\"The Connection.connect\\(\\) function/method is considered legacy\",\n        r\".*DefaultGenerator.execute\\(\\)\",\n    ]:\n        warnings.filterwarnings(\n            \"error\",\n            message=msg,\n            category=exc.RemovedIn20Warning,\n        )\n    ```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"postgresql+psycopg2:///\")\n\nwith engine.connect() as conn:\n    conn.execute(text(\"insert into table (x) values (:some_x)\"), {\"some_x\": 10})\n\n    conn.commit()  # commit as you go\n```", "```py\nfrom sqlalchemy.orm import Session\n\nwith Session(engine) as session:\n    session.add(MyObject())\n    session.commit()\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\n\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add(MyObject())\n```", "```py\nBase = declarative_base()\n\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    # will raise\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    # will raise\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\n# qualify the base with __allow_unmapped__.  Can also be\n# applied to classes directly if preferred\nclass Base:\n    __allow_unmapped__ = True\n\nBase = declarative_base(cls=Base)\n\n# existing mapping proceeds, Declarative will ignore any annotations\n# which don't include ``Mapped[]``\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"INSERT INTO table (foo) VALUES ('bar')\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"EXEC my_procedural_thing()\").execution_options(autocommit=True))\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.connect() as conn:\n    with conn.begin():\n        conn.execute(some_table.insert().values(foo=\"bar\"))\n        conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.begin() as conn:\n    conn.execute(text(\"EXEC my_procedural_thing()\"))\n```", "```py\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\n    conn.commit()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\n# 1.4 / 2.0 code\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(..., future=True)\n\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.commit()\n\n    conn.execute(text(\"some other SQL\"))\n    conn.rollback()\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData(bind=engine)  # no longer supported\n\nmetadata_obj.create_all()  # requires Engine or Connection\n\nmetadata_obj.reflect()  # requires Engine or Connection\n\nt = Table(\"t\", metadata_obj, autoload=True)  # use autoload_with=engine\n\nresult = engine.execute(t.select())  # no longer supported\n\nresult = t.select().execute()  # no longer supported\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData()\n\n# engine level:\n\n# create tables\nmetadata_obj.create_all(engine)\n\n# reflect all tables\nmetadata_obj.reflect(engine)\n\n# reflect individual table\nt = Table(\"t\", metadata_obj, autoload_with=engine)\n\n# connection level:\n\nwith engine.connect() as connection:\n    # create tables, requires explicit begin and/or commit:\n    with connection.begin():\n        metadata_obj.create_all(connection)\n\n    # reflect all tables\n    metadata_obj.reflect(connection)\n\n    # reflect individual table\n    t = Table(\"t\", metadata_obj, autoload_with=connection)\n\n    # execute SQL statements\n    result = connection.execute(t.select())\n```", "```py\nresult = engine.execute(some_statement)\n```", "```py\nresult = some_statement.execute()\n```", "```py\n# many choices\n\n# bound metadata?\nmetadata_obj = MetaData(engine)\n\n# or not?\nmetadata_obj = MetaData()\n\n# execute from engine?\nresult = engine.execute(stmt)\n\n# or execute the statement itself (but only if you did\n# \"bound metadata\" above, which means you can't get rid of \"bound\" if any\n# part of your program uses this form)\nresult = stmt.execute()\n\n# execute from connection, but it autocommits?\nconn = engine.connect()\nconn.execute(stmt)\n\n# execute from connection, but autocommit isn't working, so use the special\n# option?\nconn.execution_options(autocommit=True).execute(stmt)\n\n# or on the statement ?!\nconn.execute(stmt.execution_options(autocommit=True))\n\n# or execute from connection, and we use explicit transaction?\nwith conn.begin():\n    conn.execute(stmt)\n```", "```py\n# one choice - work with explicit connection, explicit transaction\n# (there remain a few variants on how to demarcate the transaction)\n\n# \"begin once\" - one transaction only per checkout\nwith engine.begin() as conn:\n    result = conn.execute(stmt)\n\n# \"commit as you go\" - zero or more commits per checkout\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n    conn.commit()\n\n# \"commit as you go\" but with a transaction block instead of autobegin\nwith engine.connect() as conn:\n    with conn.begin():\n        result = conn.execute(stmt)\n```", "```py\nconnection = engine.connect()\n\n# direct string SQL not supported; use text() or exec_driver_sql() method\nresult = connection.execute(\"select * from table\")\n\n# positional parameters no longer supported, only named\n# unless using exec_driver_sql()\nresult = connection.execute(table.insert(), (\"x\", \"y\", \"z\"))\n\n# **kwargs no longer accepted, pass a single dictionary\nresult = connection.execute(table.insert(), x=10, y=5)\n\n# multiple *args no longer accepted, pass a list\nresult = connection.execute(\n    table.insert(), {\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}\n)\n```", "```py\nconnection = engine.connect()\n\nfrom sqlalchemy import text\n\nresult = connection.execute(text(\"select * from table\"))\n\n# pass a single dictionary for single statement execution\nresult = connection.execute(table.insert(), {\"x\": 10, \"y\": 5})\n\n# pass a list of dictionaries for executemany\nresult = connection.execute(\n    table.insert(), [{\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}]\n)\n```", "```py\nengine = create_engine(..., future=True)  # using future mode\n\nwith engine.connect() as conn:\n    result = conn.execute(text(\"select x, y from table\"))\n\n    row = result.first()  # suppose the row is (1, 2)\n\n    \"x\" in row  # evaluates to False, in 1.x / future=False, this would be True\n\n    1 in row  # evaluates to True, in 1.x / future=False, this would be False\n```", "```py\nfrom sqlalchemy.future.orm import Session\n\nsession = Session(some_engine)\n\nresult = session.execute(stmt)\nfor row in result.mappings():\n    print(\"the user is: %s\" % row[\"User\"])\n```", "```py\nfrom sqlalchemy.future import select\n\nstmt = select(User, Address).join(User.addresses)\n\nfor row in session.execute(stmt).mappings():\n    print(\"the user is: %s the address is: %s\" % (row[User], row[Address]))\n```", "```py\n# select_from / order_by keywords no longer supported\nstmt = select([1], select_from=table, order_by=table.c.id)\n\n# whereclause parameter no longer supported\nstmt = select([table.c.x], table.c.id == 5)\n\n# whereclause parameter no longer supported\nstmt = table.select(table.c.id == 5)\n\n# list emits a deprecation warning\nstmt = select([table.c.x, table.c.y])\n\n# list emits a deprecation warning\ncase_clause = case(\n    [(table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\")],\n    else_=\"neither five nor seven\",\n)\n```", "```py\n# use generative methods\nstmt = select(1).select_from(table).order_by(table.c.id)\n\n# use generative methods\nstmt = select(table).where(table.c.id == 5)\n\n# use generative methods\nstmt = table.select().where(table.c.id == 5)\n\n# pass columns clause expressions positionally\nstmt = select(table.c.x, table.c.y)\n\n# case conditions passed positionally\ncase_clause = case(\n    (table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\"), else_=\"neither five nor seven\"\n)\n```", "```py\n# table columns for CREATE TABLE - structural\ntable = Table(\"table\", metadata_obj, Column(\"x\", Integer), Column(\"y\", Integer))\n\n# columns in a SELECT statement - structural\nstmt = select(table.c.x, table.c.y)\n\n# literal elements in an IN clause - data\nstmt = stmt.where(table.c.y.in_([1, 2, 3]))\n```", "```py\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, inline=True)\n\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, returning=[table.c.x])\n\n# no longer supported\nstmt = table.delete(table.c.x > 15)\n\n# no longer supported\nstmt = table.update(table.c.x < 15, preserve_parameter_order=True).values(\n    [(table.c.y, 20), (table.c.x, table.c.y + 10)]\n)\n```", "```py\n# use generative methods, **kwargs OK for values()\nstmt = insert(table).values(x=10, y=15).inline()\n\n# use generative methods, dictionary also still  OK for values()\nstmt = insert(table).values({\"x\": 10, \"y\": 15}).returning(table.c.x)\n\n# use generative methods\nstmt = table.delete().where(table.c.x > 15)\n\n# use generative methods, ordered_values() replaces preserve_parameter_order\nstmt = (\n    table.update()\n    .where(\n        table.c.x < 15,\n    )\n    .ordered_values((table.c.y, 20), (table.c.x, table.c.y + 10))\n)\n```", "```py\nfrom sqlalchemy.ext import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import mapper\n\nmapper(SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)})\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nmapper_reg.map_imperatively(\n    SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)}\n)\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nBase = mapper_reg.generate_base()\n\nclass SomeRelatedClass(Base):\n    __tablename__ = \"related\"\n\n    # ...\n\nmapper_reg.map_imperatively(\n    SomeClass,\n    some_table,\n    properties={\n        \"related\": relationship(\n            \"SomeRelatedClass\",\n            primaryjoin=\"SomeRelatedClass.related_id == SomeClass.id\",\n        )\n    },\n)\n```", "```py\nsession.query(User).get(42)\n```", "```py\nsession.get(User, 42)\n```", "```py\nsession.query(User).all()\n```", "```py\nsession.execute(\n  select(User)\n).scalars().all()\n\n# or\n\nsession.scalars(\n  select(User)\n).all()\n```", "```py\nsession.query(User).\\\n  filter_by(name=\"some user\").\\\n  one()\n```", "```py\nsession.execute(\n  select(User).\n  filter_by(name=\"some user\")\n).scalar_one()\n```", "```py\nsession.query(User).\\\n  filter_by(name=\"some user\").\\\n  first()\n```", "```py\nsession.scalars(\n  select(User).\n  filter_by(name=\"some user\").\n  limit(1)\n).first()\n```", "```py\nsession.query(User).options(\n  joinedload(User.addresses)\n).all()\n```", "```py\nsession.scalars(\n  select(User).\n  options(\n    joinedload(User.addresses)\n  )\n).unique().all()\n```", "```py\nsession.query(User).\\\n  join(Address).\\\n  filter(\n    Address.email == \"e@sa.us\"\n  ).\\\n  all()\n```", "```py\nsession.execute(\n  select(User).\n  join(Address).\n  where(\n    Address.email == \"e@sa.us\"\n  )\n).scalars().all()\n```", "```py\nsession.query(User).\\\n  from_statement(\n    text(\"select * from users\")\n  ).\\\n  all()\n```", "```py\nsession.scalars(\n  select(User).\n  from_statement(\n    text(\"select * from users\")\n  )\n).all()\n```", "```py\nsession.query(User).\\\n  join(User.addresses).\\\n  options(\n    contains_eager(User.addresses)\n  ).\\\n  populate_existing().all()\n```", "```py\nsession.execute(\n  select(User)\n  .join(User.addresses)\n  .options(\n    contains_eager(User.addresses)\n  )\n  .execution_options(\n      populate_existing=True\n  )\n).scalars().all()\n```", "```py\nsession.query(User).\\\n  filter(User.name == \"foo\").\\\n  update(\n    {\"fullname\": \"Foo Bar\"},\n    synchronize_session=\"evaluate\"\n  )\n```", "```py\nsession.execute(\n  update(User)\n  .where(User.name == \"foo\")\n  .values(fullname=\"Foo Bar\")\n  .execution_options(\n    synchronize_session=\"evaluate\"\n  )\n)\n```", "```py\nsession.query(User).count()\n```", "```py\nsession.scalar(\n  select(func.count()).\n  select_from(User)\n)\n\n# or\n\nsession.scalar(\n  select(func.count(User.id))\n)\n```", "```py\nsession = Session(engine)\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").one()\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").first()\n\n# becomes legacy use case\nuser = session.query(User).get(5)\n\n# becomes legacy use case\nfor user in (\n    session.query(User).join(User.addresses).filter(Address.email == \"some@email.com\")\n):\n    ...\n\n# becomes legacy use case\nusers = session.query(User).options(joinedload(User.addresses)).order_by(User.id).all()\n\n# becomes legacy use case\nusers = session.query(User).from_statement(text(\"select * from users\")).all()\n\n# etc\n```", "```py\nsession = Session(engine)\n\nuser = session.execute(select(User).filter_by(name=\"some user\")).scalar_one()\n\n# for first(), no LIMIT is applied automatically; add limit(1) if LIMIT\n# is desired on the query\nuser = (\n    session.execute(select(User).filter_by(name=\"some user\").limit(1)).scalars().first()\n)\n\n# get() moves to the Session directly\nuser = session.get(User, 5)\n\nfor user in session.execute(\n    select(User).join(User.addresses).filter(Address.email == \"some@email.case\")\n).scalars():\n    ...\n\n# when using joinedload() against collections, use unique() on the result\nusers = (\n    session.execute(select(User).options(joinedload(User.addresses)).order_by(User.id))\n    .unique()\n    .all()\n)\n\n# select() has ORM-ish methods like from_statement() that only work\n# if the statement is against ORM entities\nusers = (\n    session.execute(select(User).from_statement(text(\"select * from users\")))\n    .scalars()\n    .all()\n)\n```", "```py\n# legacy usage\nuser_obj = session.query(User).get(5)\n```", "```py\n# 1.4 / 2.0 cross-compatible use\nuser_obj = session.get(User, 5)\n```", "```py\n# string use removed\nq = session.query(User).join(\"addresses\")\n\n# string use removed\nq = session.query(User).options(joinedload(\"addresses\"))\n\n# string use removed\nq = session.query(Address).filter(with_parent(u1, \"addresses\"))\n```", "```py\n# compatible with all modern SQLAlchemy versions\n\nq = session.query(User).join(User.addresses)\n\nq = session.query(User).options(joinedload(User.addresses))\n\nq = session.query(Address).filter(with_parent(u1, User.addresses))\n```", "```py\n# SQLAlchemy 1.4 / 2.0 cross compatible use\n\nstmt = select(User).join(User.addresses)\nresult = session.execute(stmt)\n\nstmt = select(User).options(joinedload(User.addresses))\nresult = session.execute(stmt)\n\nstmt = select(Address).where(with_parent(u1, User.addresses))\nresult = session.execute(stmt)\n```", "```py\n# chaining removed\nq = session.query(User).join(\"orders\", \"items\", \"keywords\")\n```", "```py\nq = session.query(User).join(User.orders).join(Order.items).join(Item.keywords)\n```", "```py\n# 1.4 / 2.0 cross compatible\n\nstmt = select(User).join(User.orders).join(Order.items).join(Item.keywords)\nresult = session.execute(stmt)\n\n# join_from can also be helpful\nstmt = select(User).join_from(User, Order).join_from(Order, Item, Order.items)\nresult = session.execute(stmt)\n```", "```py\n# no longer supported\nq = (\n    session.query(Node)\n    .join(\"children\", aliased=True)\n    .filter(Node.name == \"some sub child\")\n    .join(\"children\", from_joinpoint=True, aliased=True)\n    .filter(Node.name == \"some sub sub child\")\n)\n```", "```py\nn1 = aliased(Node)\nn2 = aliased(Node)\n\nq = (\n    select(Node)\n    .join(Node.children.of_type(n1))\n    .where(n1.name == \"some sub child\")\n    .join(n1.children.of_type(n2))\n    .where(n2.name == \"some sub child\")\n)\n```", "```py\n# 1.xx code\n\nresult = (\n    session.query(User)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n    .all()\n)\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = (\n    select(User, Address.email_address)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n)\n\nresult = session.execute(stmt).columns(User).all()\n```", "```py\n# from_self is removed\nq = (\n    session.query(User, Address.email_address)\n    .join(User.addresses)\n    .from_self(User)\n    .order_by(Address.email_address)\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = session.query(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nq = session.query(ua, aa).order_by(aa.email_address)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = select(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\n\nresult = session.execute(stmt)\n```", "```py\n# 1.4 / 2.0 code\n\nsubq = select(User, Address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\nresult = session.execute(stmt)\n```", "```py\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.id_1  AS  anon_1_id_1,\n  anon_1.user_id  AS  anon_1_user_id,\n  anon_1.email_address  AS  anon_1_email_address\nFROM  (\n  SELECT  \"user\".id  AS  id,  address.id  AS  id_1,\n  address.user_id  AS  user_id,  address.email_address  AS  email_address\n  FROM  \"user\"  JOIN  address  ON  \"user\".id  =  address.user_id\n)  AS  anon_1  ORDER  BY  anon_1.email_address\n```", "```py\nsubquery = session.query(User).filter(User.id == 5).subquery()\n\nuser = session.query(User).select_entity_from(subquery).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = session.query(User).filter(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\nuser = session.query(ua).order_by(ua.id).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = select(User).where(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\n# note that LIMIT 1 is not automatically supplied, if needed\nuser = session.execute(select(ua).order_by(ua.id).limit(1)).scalars().first()\n```", "```py\n# In the legacy API, many rows each have the same User primary key, but\n# only one User per primary key is returned\nusers = session.query(User).options(joinedload(User.addresses))\n\n# In the new API, uniquing is available but not implicitly\n# enabled\nresult = session.execute(select(User).options(joinedload(User.addresses)))\n\n# this actually will raise an error to let the user know that\n# uniquing should be applied\nrows = result.all()\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = select(User).options(joinedload(User.addresses))\n\n# statement will raise if unique() is not used, due to joinedload()\n# of a collection.  in all other cases, unique() is not needed.\n# By stating unique() explicitly, confusion over discrepancies between\n# number of objects/ rows returned vs. \"SELECT COUNT(*)\" is resolved\nrows = session.execute(stmt).unique().all()\n```", "```py\n    class User(Base):\n        __tablename__ = \"user\"\n\n        posts = relationship(Post, lazy=\"dynamic\")\n\n    jack = session.get(User, 5)\n\n    # filter Jack's blog posts\n    posts = session.scalars(jack.posts.statement.where(Post.headline == \"this is a post\"))\n    ```", "```py\n    from sqlalchemy.orm import with_parent\n\n    jack = session.get(User, 5)\n\n    posts = session.scalars(\n        select(Post)\n        .where(with_parent(jack, User.posts))\n        .where(Post.headline == \"this is a post\")\n    )\n    ```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine, autocommit=True)\n\n# no transaction begun, but emits SQL, won't be supported\nobj = sess.query(Class).first()\n\n# session flushes in a transaction that it begins and\n# commits, won't be supported\nsess.flush()\n```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine)\n\nsess.begin()  # begin explicitly; if not called, will autobegin\n# when database access is needed\n\nsess.add(obj)\n\nsess.commit()\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef transaction(session):\n    if not session.in_transaction():\n        with session.begin():\n            yield\n    else:\n        yield\n```", "```py\n# method_a starts a transaction and calls method_b\ndef method_a(session):\n    with transaction(session):\n        method_b(session)\n\n# method_b also starts a transaction, but when\n# called from method_a participates in the ongoing\n# transaction.\ndef method_b(session):\n    with transaction(session):\n        session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    method_a(session)\n```", "```py\ndef method_a(session):\n    method_b(session)\n\ndef method_b(session):\n    session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    with session.begin():\n        method_a(session)\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\n\nengine = create_engine(\"sqlite://\")\n\nengine.execute(\"CREATE TABLE foo (id integer)\")\nengine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n\nfoo = table(\"foo\", column(\"id\"))\nresult = engine.execute(select([foo.c.id]))\n\nprint(result.fetchall())\n```", "```py\n$ python test3.py\n[(1,)]\n```", "```py\nSQLALCHEMY_WARN_20=1 python -W always::DeprecationWarning test3.py\n```", "```py\n$ SQLALCHEMY_WARN_20=1 python2 -W always::DeprecationWarning test3.py\ntest3.py:9: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"CREATE TABLE foo (id integer)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\ntest3.py:10: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/sql/selectable.py:4271: RemovedIn20Warning: The legacy calling style of select() is deprecated and will be removed in SQLAlchemy 2.0\\.  Please use the new calling style described at select(). (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return cls.create_legacy_select(*args, **kw)\ntest3.py:14: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  result = engine.execute(select([foo.c.id]))\n[(1,)]\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\nfrom sqlalchemy import text\n\nengine = create_engine(\"sqlite://\")\n\n# don't rely on autocommit for DML and DDL\nwith engine.begin() as connection:\n    # use connection.execute(), not engine.execute()\n    # use the text() construct to execute textual SQL\n    connection.execute(text(\"CREATE TABLE foo (id integer)\"))\n    connection.execute(text(\"INSERT INTO foo (id) VALUES (1)\"))\n\nfoo = table(\"foo\", column(\"id\"))\n\nwith engine.connect() as connection:\n    # use connection.execute(), not engine.execute()\n    # select() now accepts column / table expressions positionally\n    result = connection.execute(select(foo.c.id))\n\n    print(result.fetchall())\n```", "```py\n    import warnings\n    from sqlalchemy import exc\n\n    # for warnings not included in regex-based filter below, just log\n    warnings.filterwarnings(\"always\", category=exc.RemovedIn20Warning)\n\n    # for warnings related to execute() / scalar(), raise\n    for msg in [\n        r\"The (?:Executable|Engine)\\.(?:execute|scalar)\\(\\) function\",\n        r\"The current statement is being autocommitted using implicit autocommit,\",\n        r\"The connection.execute\\(\\) method in SQLAlchemy 2.0 will accept \"\n        \"parameters as a single dictionary or a single sequence of \"\n        \"dictionaries only.\",\n        r\"The Connection.connect\\(\\) function/method is considered legacy\",\n        r\".*DefaultGenerator.execute\\(\\)\",\n    ]:\n        warnings.filterwarnings(\n            \"error\",\n            message=msg,\n            category=exc.RemovedIn20Warning,\n        )\n    ```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"postgresql+psycopg2:///\")\n\nwith engine.connect() as conn:\n    conn.execute(text(\"insert into table (x) values (:some_x)\"), {\"some_x\": 10})\n\n    conn.commit()  # commit as you go\n```", "```py\nfrom sqlalchemy.orm import Session\n\nwith Session(engine) as session:\n    session.add(MyObject())\n    session.commit()\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\n\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add(MyObject())\n```", "```py\nBase = declarative_base()\n\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    # will raise\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    # will raise\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\n# qualify the base with __allow_unmapped__.  Can also be\n# applied to classes directly if preferred\nclass Base:\n    __allow_unmapped__ = True\n\nBase = declarative_base(cls=Base)\n\n# existing mapping proceeds, Declarative will ignore any annotations\n# which don't include ``Mapped[]``\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\n\nengine = create_engine(\"sqlite://\")\n\nengine.execute(\"CREATE TABLE foo (id integer)\")\nengine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n\nfoo = table(\"foo\", column(\"id\"))\nresult = engine.execute(select([foo.c.id]))\n\nprint(result.fetchall())\n```", "```py\n$ python test3.py\n[(1,)]\n```", "```py\nSQLALCHEMY_WARN_20=1 python -W always::DeprecationWarning test3.py\n```", "```py\n$ SQLALCHEMY_WARN_20=1 python2 -W always::DeprecationWarning test3.py\ntest3.py:9: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"CREATE TABLE foo (id integer)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\ntest3.py:10: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  engine.execute(\"INSERT INTO foo (id) VALUES (1)\")\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:2856: RemovedIn20Warning: Passing a string to Connection.execute() is deprecated and will be removed in version 2.0\\.  Use the text() construct, or the Connection.exec_driver_sql() method to invoke a driver-level SQL string. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return connection.execute(statement, *multiparams, **params)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/engine/base.py:1639: RemovedIn20Warning: The current statement is being autocommitted using implicit autocommit.Implicit autocommit will be removed in SQLAlchemy 2.0\\.   Use the .begin() method of Engine or Connection in order to use an explicit transaction for DML and DDL statements. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  self._commit_impl(autocommit=True)\n/home/classic/dev/sqlalchemy/lib/sqlalchemy/sql/selectable.py:4271: RemovedIn20Warning: The legacy calling style of select() is deprecated and will be removed in SQLAlchemy 2.0\\.  Please use the new calling style described at select(). (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  return cls.create_legacy_select(*args, **kw)\ntest3.py:14: RemovedIn20Warning: The Engine.execute() function/method is considered legacy as of the 1.x series of SQLAlchemy and will be removed in 2.0\\. All statement execution in SQLAlchemy 2.0 is performed by the Connection.execute() method of Connection, or in the ORM by the Session.execute() method of Session. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n  result = engine.execute(select([foo.c.id]))\n[(1,)]\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import table\nfrom sqlalchemy import text\n\nengine = create_engine(\"sqlite://\")\n\n# don't rely on autocommit for DML and DDL\nwith engine.begin() as connection:\n    # use connection.execute(), not engine.execute()\n    # use the text() construct to execute textual SQL\n    connection.execute(text(\"CREATE TABLE foo (id integer)\"))\n    connection.execute(text(\"INSERT INTO foo (id) VALUES (1)\"))\n\nfoo = table(\"foo\", column(\"id\"))\n\nwith engine.connect() as connection:\n    # use connection.execute(), not engine.execute()\n    # select() now accepts column / table expressions positionally\n    result = connection.execute(select(foo.c.id))\n\n    print(result.fetchall())\n```", "```py\n    import warnings\n    from sqlalchemy import exc\n\n    # for warnings not included in regex-based filter below, just log\n    warnings.filterwarnings(\"always\", category=exc.RemovedIn20Warning)\n\n    # for warnings related to execute() / scalar(), raise\n    for msg in [\n        r\"The (?:Executable|Engine)\\.(?:execute|scalar)\\(\\) function\",\n        r\"The current statement is being autocommitted using implicit autocommit,\",\n        r\"The connection.execute\\(\\) method in SQLAlchemy 2.0 will accept \"\n        \"parameters as a single dictionary or a single sequence of \"\n        \"dictionaries only.\",\n        r\"The Connection.connect\\(\\) function/method is considered legacy\",\n        r\".*DefaultGenerator.execute\\(\\)\",\n    ]:\n        warnings.filterwarnings(\n            \"error\",\n            message=msg,\n            category=exc.RemovedIn20Warning,\n        )\n    ```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"postgresql+psycopg2:///\")\n\nwith engine.connect() as conn:\n    conn.execute(text(\"insert into table (x) values (:some_x)\"), {\"some_x\": 10})\n\n    conn.commit()  # commit as you go\n```", "```py\nfrom sqlalchemy.orm import Session\n\nwith Session(engine) as session:\n    session.add(MyObject())\n    session.commit()\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\n\nSession = sessionmaker(engine)\n\nwith Session.begin() as session:\n    session.add(MyObject())\n```", "```py\nBase = declarative_base()\n\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    # will raise\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    # will raise\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\n# qualify the base with __allow_unmapped__.  Can also be\n# applied to classes directly if preferred\nclass Base:\n    __allow_unmapped__ = True\n\nBase = declarative_base(cls=Base)\n\n# existing mapping proceeds, Declarative will ignore any annotations\n# which don't include ``Mapped[]``\nclass Foo(Base):\n    __tablename__ = \"foo\"\n\n    id: int = Column(Integer, primary_key=True)\n\n    bars: List[\"Bar\"] = relationship(\"Bar\", back_populates=\"foo\")\n\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id: int = Column(Integer, primary_key=True)\n    foo_id = Column(ForeignKey(\"foo.id\"))\n\n    foo: Foo = relationship(Foo, back_populates=\"bars\", cascade=\"all\")\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"INSERT INTO table (foo) VALUES ('bar')\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"EXEC my_procedural_thing()\").execution_options(autocommit=True))\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.connect() as conn:\n    with conn.begin():\n        conn.execute(some_table.insert().values(foo=\"bar\"))\n        conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.begin() as conn:\n    conn.execute(text(\"EXEC my_procedural_thing()\"))\n```", "```py\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\n    conn.commit()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\n# 1.4 / 2.0 code\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(..., future=True)\n\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.commit()\n\n    conn.execute(text(\"some other SQL\"))\n    conn.rollback()\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData(bind=engine)  # no longer supported\n\nmetadata_obj.create_all()  # requires Engine or Connection\n\nmetadata_obj.reflect()  # requires Engine or Connection\n\nt = Table(\"t\", metadata_obj, autoload=True)  # use autoload_with=engine\n\nresult = engine.execute(t.select())  # no longer supported\n\nresult = t.select().execute()  # no longer supported\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData()\n\n# engine level:\n\n# create tables\nmetadata_obj.create_all(engine)\n\n# reflect all tables\nmetadata_obj.reflect(engine)\n\n# reflect individual table\nt = Table(\"t\", metadata_obj, autoload_with=engine)\n\n# connection level:\n\nwith engine.connect() as connection:\n    # create tables, requires explicit begin and/or commit:\n    with connection.begin():\n        metadata_obj.create_all(connection)\n\n    # reflect all tables\n    metadata_obj.reflect(connection)\n\n    # reflect individual table\n    t = Table(\"t\", metadata_obj, autoload_with=connection)\n\n    # execute SQL statements\n    result = connection.execute(t.select())\n```", "```py\nresult = engine.execute(some_statement)\n```", "```py\nresult = some_statement.execute()\n```", "```py\n# many choices\n\n# bound metadata?\nmetadata_obj = MetaData(engine)\n\n# or not?\nmetadata_obj = MetaData()\n\n# execute from engine?\nresult = engine.execute(stmt)\n\n# or execute the statement itself (but only if you did\n# \"bound metadata\" above, which means you can't get rid of \"bound\" if any\n# part of your program uses this form)\nresult = stmt.execute()\n\n# execute from connection, but it autocommits?\nconn = engine.connect()\nconn.execute(stmt)\n\n# execute from connection, but autocommit isn't working, so use the special\n# option?\nconn.execution_options(autocommit=True).execute(stmt)\n\n# or on the statement ?!\nconn.execute(stmt.execution_options(autocommit=True))\n\n# or execute from connection, and we use explicit transaction?\nwith conn.begin():\n    conn.execute(stmt)\n```", "```py\n# one choice - work with explicit connection, explicit transaction\n# (there remain a few variants on how to demarcate the transaction)\n\n# \"begin once\" - one transaction only per checkout\nwith engine.begin() as conn:\n    result = conn.execute(stmt)\n\n# \"commit as you go\" - zero or more commits per checkout\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n    conn.commit()\n\n# \"commit as you go\" but with a transaction block instead of autobegin\nwith engine.connect() as conn:\n    with conn.begin():\n        result = conn.execute(stmt)\n```", "```py\nconnection = engine.connect()\n\n# direct string SQL not supported; use text() or exec_driver_sql() method\nresult = connection.execute(\"select * from table\")\n\n# positional parameters no longer supported, only named\n# unless using exec_driver_sql()\nresult = connection.execute(table.insert(), (\"x\", \"y\", \"z\"))\n\n# **kwargs no longer accepted, pass a single dictionary\nresult = connection.execute(table.insert(), x=10, y=5)\n\n# multiple *args no longer accepted, pass a list\nresult = connection.execute(\n    table.insert(), {\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}\n)\n```", "```py\nconnection = engine.connect()\n\nfrom sqlalchemy import text\n\nresult = connection.execute(text(\"select * from table\"))\n\n# pass a single dictionary for single statement execution\nresult = connection.execute(table.insert(), {\"x\": 10, \"y\": 5})\n\n# pass a list of dictionaries for executemany\nresult = connection.execute(\n    table.insert(), [{\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}]\n)\n```", "```py\nengine = create_engine(..., future=True)  # using future mode\n\nwith engine.connect() as conn:\n    result = conn.execute(text(\"select x, y from table\"))\n\n    row = result.first()  # suppose the row is (1, 2)\n\n    \"x\" in row  # evaluates to False, in 1.x / future=False, this would be True\n\n    1 in row  # evaluates to True, in 1.x / future=False, this would be False\n```", "```py\nfrom sqlalchemy.future.orm import Session\n\nsession = Session(some_engine)\n\nresult = session.execute(stmt)\nfor row in result.mappings():\n    print(\"the user is: %s\" % row[\"User\"])\n```", "```py\nfrom sqlalchemy.future import select\n\nstmt = select(User, Address).join(User.addresses)\n\nfor row in session.execute(stmt).mappings():\n    print(\"the user is: %s the address is: %s\" % (row[User], row[Address]))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"INSERT INTO table (foo) VALUES ('bar')\"))\n```", "```py\nconn = engine.connect()\n\n# won't autocommit in 2.0\nconn.execute(text(\"EXEC my_procedural_thing()\").execution_options(autocommit=True))\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.connect() as conn:\n    with conn.begin():\n        conn.execute(some_table.insert().values(foo=\"bar\"))\n        conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\nwith engine.begin() as conn:\n    conn.execute(text(\"EXEC my_procedural_thing()\"))\n```", "```py\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.execute(some_other_table.insert().values(bat=\"hoho\"))\n\n    conn.commit()\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n```", "```py\n# 1.4 / 2.0 code\n\nfrom sqlalchemy import create_engine\n\nengine = create_engine(..., future=True)\n\nwith engine.connect() as conn:\n    conn.execute(some_table.insert().values(foo=\"bar\"))\n    conn.commit()\n\n    conn.execute(text(\"some other SQL\"))\n    conn.rollback()\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData(bind=engine)  # no longer supported\n\nmetadata_obj.create_all()  # requires Engine or Connection\n\nmetadata_obj.reflect()  # requires Engine or Connection\n\nt = Table(\"t\", metadata_obj, autoload=True)  # use autoload_with=engine\n\nresult = engine.execute(t.select())  # no longer supported\n\nresult = t.select().execute()  # no longer supported\n```", "```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData()\n\n# engine level:\n\n# create tables\nmetadata_obj.create_all(engine)\n\n# reflect all tables\nmetadata_obj.reflect(engine)\n\n# reflect individual table\nt = Table(\"t\", metadata_obj, autoload_with=engine)\n\n# connection level:\n\nwith engine.connect() as connection:\n    # create tables, requires explicit begin and/or commit:\n    with connection.begin():\n        metadata_obj.create_all(connection)\n\n    # reflect all tables\n    metadata_obj.reflect(connection)\n\n    # reflect individual table\n    t = Table(\"t\", metadata_obj, autoload_with=connection)\n\n    # execute SQL statements\n    result = connection.execute(t.select())\n```", "```py\nresult = engine.execute(some_statement)\n```", "```py\nresult = some_statement.execute()\n```", "```py\n# many choices\n\n# bound metadata?\nmetadata_obj = MetaData(engine)\n\n# or not?\nmetadata_obj = MetaData()\n\n# execute from engine?\nresult = engine.execute(stmt)\n\n# or execute the statement itself (but only if you did\n# \"bound metadata\" above, which means you can't get rid of \"bound\" if any\n# part of your program uses this form)\nresult = stmt.execute()\n\n# execute from connection, but it autocommits?\nconn = engine.connect()\nconn.execute(stmt)\n\n# execute from connection, but autocommit isn't working, so use the special\n# option?\nconn.execution_options(autocommit=True).execute(stmt)\n\n# or on the statement ?!\nconn.execute(stmt.execution_options(autocommit=True))\n\n# or execute from connection, and we use explicit transaction?\nwith conn.begin():\n    conn.execute(stmt)\n```", "```py\n# one choice - work with explicit connection, explicit transaction\n# (there remain a few variants on how to demarcate the transaction)\n\n# \"begin once\" - one transaction only per checkout\nwith engine.begin() as conn:\n    result = conn.execute(stmt)\n\n# \"commit as you go\" - zero or more commits per checkout\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n    conn.commit()\n\n# \"commit as you go\" but with a transaction block instead of autobegin\nwith engine.connect() as conn:\n    with conn.begin():\n        result = conn.execute(stmt)\n```", "```py\n# many choices\n\n# bound metadata?\nmetadata_obj = MetaData(engine)\n\n# or not?\nmetadata_obj = MetaData()\n\n# execute from engine?\nresult = engine.execute(stmt)\n\n# or execute the statement itself (but only if you did\n# \"bound metadata\" above, which means you can't get rid of \"bound\" if any\n# part of your program uses this form)\nresult = stmt.execute()\n\n# execute from connection, but it autocommits?\nconn = engine.connect()\nconn.execute(stmt)\n\n# execute from connection, but autocommit isn't working, so use the special\n# option?\nconn.execution_options(autocommit=True).execute(stmt)\n\n# or on the statement ?!\nconn.execute(stmt.execution_options(autocommit=True))\n\n# or execute from connection, and we use explicit transaction?\nwith conn.begin():\n    conn.execute(stmt)\n```", "```py\n# one choice - work with explicit connection, explicit transaction\n# (there remain a few variants on how to demarcate the transaction)\n\n# \"begin once\" - one transaction only per checkout\nwith engine.begin() as conn:\n    result = conn.execute(stmt)\n\n# \"commit as you go\" - zero or more commits per checkout\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n    conn.commit()\n\n# \"commit as you go\" but with a transaction block instead of autobegin\nwith engine.connect() as conn:\n    with conn.begin():\n        result = conn.execute(stmt)\n```", "```py\nconnection = engine.connect()\n\n# direct string SQL not supported; use text() or exec_driver_sql() method\nresult = connection.execute(\"select * from table\")\n\n# positional parameters no longer supported, only named\n# unless using exec_driver_sql()\nresult = connection.execute(table.insert(), (\"x\", \"y\", \"z\"))\n\n# **kwargs no longer accepted, pass a single dictionary\nresult = connection.execute(table.insert(), x=10, y=5)\n\n# multiple *args no longer accepted, pass a list\nresult = connection.execute(\n    table.insert(), {\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}\n)\n```", "```py\nconnection = engine.connect()\n\nfrom sqlalchemy import text\n\nresult = connection.execute(text(\"select * from table\"))\n\n# pass a single dictionary for single statement execution\nresult = connection.execute(table.insert(), {\"x\": 10, \"y\": 5})\n\n# pass a list of dictionaries for executemany\nresult = connection.execute(\n    table.insert(), [{\"x\": 10, \"y\": 5}, {\"x\": 15, \"y\": 12}, {\"x\": 9, \"y\": 8}]\n)\n```", "```py\nengine = create_engine(..., future=True)  # using future mode\n\nwith engine.connect() as conn:\n    result = conn.execute(text(\"select x, y from table\"))\n\n    row = result.first()  # suppose the row is (1, 2)\n\n    \"x\" in row  # evaluates to False, in 1.x / future=False, this would be True\n\n    1 in row  # evaluates to True, in 1.x / future=False, this would be False\n```", "```py\nfrom sqlalchemy.future.orm import Session\n\nsession = Session(some_engine)\n\nresult = session.execute(stmt)\nfor row in result.mappings():\n    print(\"the user is: %s\" % row[\"User\"])\n```", "```py\nfrom sqlalchemy.future import select\n\nstmt = select(User, Address).join(User.addresses)\n\nfor row in session.execute(stmt).mappings():\n    print(\"the user is: %s the address is: %s\" % (row[User], row[Address]))\n```", "```py\n# select_from / order_by keywords no longer supported\nstmt = select([1], select_from=table, order_by=table.c.id)\n\n# whereclause parameter no longer supported\nstmt = select([table.c.x], table.c.id == 5)\n\n# whereclause parameter no longer supported\nstmt = table.select(table.c.id == 5)\n\n# list emits a deprecation warning\nstmt = select([table.c.x, table.c.y])\n\n# list emits a deprecation warning\ncase_clause = case(\n    [(table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\")],\n    else_=\"neither five nor seven\",\n)\n```", "```py\n# use generative methods\nstmt = select(1).select_from(table).order_by(table.c.id)\n\n# use generative methods\nstmt = select(table).where(table.c.id == 5)\n\n# use generative methods\nstmt = table.select().where(table.c.id == 5)\n\n# pass columns clause expressions positionally\nstmt = select(table.c.x, table.c.y)\n\n# case conditions passed positionally\ncase_clause = case(\n    (table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\"), else_=\"neither five nor seven\"\n)\n```", "```py\n# table columns for CREATE TABLE - structural\ntable = Table(\"table\", metadata_obj, Column(\"x\", Integer), Column(\"y\", Integer))\n\n# columns in a SELECT statement - structural\nstmt = select(table.c.x, table.c.y)\n\n# literal elements in an IN clause - data\nstmt = stmt.where(table.c.y.in_([1, 2, 3]))\n```", "```py\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, inline=True)\n\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, returning=[table.c.x])\n\n# no longer supported\nstmt = table.delete(table.c.x > 15)\n\n# no longer supported\nstmt = table.update(table.c.x < 15, preserve_parameter_order=True).values(\n    [(table.c.y, 20), (table.c.x, table.c.y + 10)]\n)\n```", "```py\n# use generative methods, **kwargs OK for values()\nstmt = insert(table).values(x=10, y=15).inline()\n\n# use generative methods, dictionary also still  OK for values()\nstmt = insert(table).values({\"x\": 10, \"y\": 15}).returning(table.c.x)\n\n# use generative methods\nstmt = table.delete().where(table.c.x > 15)\n\n# use generative methods, ordered_values() replaces preserve_parameter_order\nstmt = (\n    table.update()\n    .where(\n        table.c.x < 15,\n    )\n    .ordered_values((table.c.y, 20), (table.c.x, table.c.y + 10))\n)\n```", "```py\n# select_from / order_by keywords no longer supported\nstmt = select([1], select_from=table, order_by=table.c.id)\n\n# whereclause parameter no longer supported\nstmt = select([table.c.x], table.c.id == 5)\n\n# whereclause parameter no longer supported\nstmt = table.select(table.c.id == 5)\n\n# list emits a deprecation warning\nstmt = select([table.c.x, table.c.y])\n\n# list emits a deprecation warning\ncase_clause = case(\n    [(table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\")],\n    else_=\"neither five nor seven\",\n)\n```", "```py\n# use generative methods\nstmt = select(1).select_from(table).order_by(table.c.id)\n\n# use generative methods\nstmt = select(table).where(table.c.id == 5)\n\n# use generative methods\nstmt = table.select().where(table.c.id == 5)\n\n# pass columns clause expressions positionally\nstmt = select(table.c.x, table.c.y)\n\n# case conditions passed positionally\ncase_clause = case(\n    (table.c.x == 5, \"five\"), (table.c.x == 7, \"seven\"), else_=\"neither five nor seven\"\n)\n```", "```py\n# table columns for CREATE TABLE - structural\ntable = Table(\"table\", metadata_obj, Column(\"x\", Integer), Column(\"y\", Integer))\n\n# columns in a SELECT statement - structural\nstmt = select(table.c.x, table.c.y)\n\n# literal elements in an IN clause - data\nstmt = stmt.where(table.c.y.in_([1, 2, 3]))\n```", "```py\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, inline=True)\n\n# no longer supported\nstmt = insert(table, values={\"x\": 10, \"y\": 15}, returning=[table.c.x])\n\n# no longer supported\nstmt = table.delete(table.c.x > 15)\n\n# no longer supported\nstmt = table.update(table.c.x < 15, preserve_parameter_order=True).values(\n    [(table.c.y, 20), (table.c.x, table.c.y + 10)]\n)\n```", "```py\n# use generative methods, **kwargs OK for values()\nstmt = insert(table).values(x=10, y=15).inline()\n\n# use generative methods, dictionary also still  OK for values()\nstmt = insert(table).values({\"x\": 10, \"y\": 15}).returning(table.c.x)\n\n# use generative methods\nstmt = table.delete().where(table.c.x > 15)\n\n# use generative methods, ordered_values() replaces preserve_parameter_order\nstmt = (\n    table.update()\n    .where(\n        table.c.x < 15,\n    )\n    .ordered_values((table.c.y, 20), (table.c.x, table.c.y + 10))\n)\n```", "```py\nfrom sqlalchemy.ext import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import mapper\n\nmapper(SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)})\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nmapper_reg.map_imperatively(\n    SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)}\n)\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nBase = mapper_reg.generate_base()\n\nclass SomeRelatedClass(Base):\n    __tablename__ = \"related\"\n\n    # ...\n\nmapper_reg.map_imperatively(\n    SomeClass,\n    some_table,\n    properties={\n        \"related\": relationship(\n            \"SomeRelatedClass\",\n            primaryjoin=\"SomeRelatedClass.related_id == SomeClass.id\",\n        )\n    },\n)\n```", "```py\nfrom sqlalchemy.ext import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import declarative_base, declared_attr\n```", "```py\nfrom sqlalchemy.orm import mapper\n\nmapper(SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)})\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nmapper_reg.map_imperatively(\n    SomeClass, some_table, properties={\"related\": relationship(SomeRelatedClass)}\n)\n```", "```py\nfrom sqlalchemy.orm import registry\n\nmapper_reg = registry()\n\nBase = mapper_reg.generate_base()\n\nclass SomeRelatedClass(Base):\n    __tablename__ = \"related\"\n\n    # ...\n\nmapper_reg.map_imperatively(\n    SomeClass,\n    some_table,\n    properties={\n        \"related\": relationship(\n            \"SomeRelatedClass\",\n            primaryjoin=\"SomeRelatedClass.related_id == SomeClass.id\",\n        )\n    },\n)\n```", "```py\nsession.query(User).get(42)\n```", "```py\nsession.get(User, 42)\n```", "```py\nsession.query(User).all()\n```", "```py\nsession.execute(\n  select(User)\n).scalars().all()\n\n# or\n\nsession.scalars(\n  select(User)\n).all()\n```", "```py\nsession.query(User).\\\n  filter_by(name=\"some user\").\\\n  one()\n```", "```py\nsession.execute(\n  select(User).\n  filter_by(name=\"some user\")\n).scalar_one()\n```", "```py\nsession.query(User).\\\n  filter_by(name=\"some user\").\\\n  first()\n```", "```py\nsession.scalars(\n  select(User).\n  filter_by(name=\"some user\").\n  limit(1)\n).first()\n```", "```py\nsession.query(User).options(\n  joinedload(User.addresses)\n).all()\n```", "```py\nsession.scalars(\n  select(User).\n  options(\n    joinedload(User.addresses)\n  )\n).unique().all()\n```", "```py\nsession.query(User).\\\n  join(Address).\\\n  filter(\n    Address.email == \"e@sa.us\"\n  ).\\\n  all()\n```", "```py\nsession.execute(\n  select(User).\n  join(Address).\n  where(\n    Address.email == \"e@sa.us\"\n  )\n).scalars().all()\n```", "```py\nsession.query(User).\\\n  from_statement(\n    text(\"select * from users\")\n  ).\\\n  all()\n```", "```py\nsession.scalars(\n  select(User).\n  from_statement(\n    text(\"select * from users\")\n  )\n).all()\n```", "```py\nsession.query(User).\\\n  join(User.addresses).\\\n  options(\n    contains_eager(User.addresses)\n  ).\\\n  populate_existing().all()\n```", "```py\nsession.execute(\n  select(User)\n  .join(User.addresses)\n  .options(\n    contains_eager(User.addresses)\n  )\n  .execution_options(\n      populate_existing=True\n  )\n).scalars().all()\n```", "```py\nsession.query(User).\\\n  filter(User.name == \"foo\").\\\n  update(\n    {\"fullname\": \"Foo Bar\"},\n    synchronize_session=\"evaluate\"\n  )\n```", "```py\nsession.execute(\n  update(User)\n  .where(User.name == \"foo\")\n  .values(fullname=\"Foo Bar\")\n  .execution_options(\n    synchronize_session=\"evaluate\"\n  )\n)\n```", "```py\nsession.query(User).count()\n```", "```py\nsession.scalar(\n  select(func.count()).\n  select_from(User)\n)\n\n# or\n\nsession.scalar(\n  select(func.count(User.id))\n)\n```", "```py\nsession = Session(engine)\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").one()\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").first()\n\n# becomes legacy use case\nuser = session.query(User).get(5)\n\n# becomes legacy use case\nfor user in (\n    session.query(User).join(User.addresses).filter(Address.email == \"some@email.com\")\n):\n    ...\n\n# becomes legacy use case\nusers = session.query(User).options(joinedload(User.addresses)).order_by(User.id).all()\n\n# becomes legacy use case\nusers = session.query(User).from_statement(text(\"select * from users\")).all()\n\n# etc\n```", "```py\nsession = Session(engine)\n\nuser = session.execute(select(User).filter_by(name=\"some user\")).scalar_one()\n\n# for first(), no LIMIT is applied automatically; add limit(1) if LIMIT\n# is desired on the query\nuser = (\n    session.execute(select(User).filter_by(name=\"some user\").limit(1)).scalars().first()\n)\n\n# get() moves to the Session directly\nuser = session.get(User, 5)\n\nfor user in session.execute(\n    select(User).join(User.addresses).filter(Address.email == \"some@email.case\")\n).scalars():\n    ...\n\n# when using joinedload() against collections, use unique() on the result\nusers = (\n    session.execute(select(User).options(joinedload(User.addresses)).order_by(User.id))\n    .unique()\n    .all()\n)\n\n# select() has ORM-ish methods like from_statement() that only work\n# if the statement is against ORM entities\nusers = (\n    session.execute(select(User).from_statement(text(\"select * from users\")))\n    .scalars()\n    .all()\n)\n```", "```py\n# legacy usage\nuser_obj = session.query(User).get(5)\n```", "```py\n# 1.4 / 2.0 cross-compatible use\nuser_obj = session.get(User, 5)\n```", "```py\n# string use removed\nq = session.query(User).join(\"addresses\")\n\n# string use removed\nq = session.query(User).options(joinedload(\"addresses\"))\n\n# string use removed\nq = session.query(Address).filter(with_parent(u1, \"addresses\"))\n```", "```py\n# compatible with all modern SQLAlchemy versions\n\nq = session.query(User).join(User.addresses)\n\nq = session.query(User).options(joinedload(User.addresses))\n\nq = session.query(Address).filter(with_parent(u1, User.addresses))\n```", "```py\n# SQLAlchemy 1.4 / 2.0 cross compatible use\n\nstmt = select(User).join(User.addresses)\nresult = session.execute(stmt)\n\nstmt = select(User).options(joinedload(User.addresses))\nresult = session.execute(stmt)\n\nstmt = select(Address).where(with_parent(u1, User.addresses))\nresult = session.execute(stmt)\n```", "```py\n# chaining removed\nq = session.query(User).join(\"orders\", \"items\", \"keywords\")\n```", "```py\nq = session.query(User).join(User.orders).join(Order.items).join(Item.keywords)\n```", "```py\n# 1.4 / 2.0 cross compatible\n\nstmt = select(User).join(User.orders).join(Order.items).join(Item.keywords)\nresult = session.execute(stmt)\n\n# join_from can also be helpful\nstmt = select(User).join_from(User, Order).join_from(Order, Item, Order.items)\nresult = session.execute(stmt)\n```", "```py\n# no longer supported\nq = (\n    session.query(Node)\n    .join(\"children\", aliased=True)\n    .filter(Node.name == \"some sub child\")\n    .join(\"children\", from_joinpoint=True, aliased=True)\n    .filter(Node.name == \"some sub sub child\")\n)\n```", "```py\nn1 = aliased(Node)\nn2 = aliased(Node)\n\nq = (\n    select(Node)\n    .join(Node.children.of_type(n1))\n    .where(n1.name == \"some sub child\")\n    .join(n1.children.of_type(n2))\n    .where(n2.name == \"some sub child\")\n)\n```", "```py\n# 1.xx code\n\nresult = (\n    session.query(User)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n    .all()\n)\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = (\n    select(User, Address.email_address)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n)\n\nresult = session.execute(stmt).columns(User).all()\n```", "```py\n# from_self is removed\nq = (\n    session.query(User, Address.email_address)\n    .join(User.addresses)\n    .from_self(User)\n    .order_by(Address.email_address)\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = session.query(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nq = session.query(ua, aa).order_by(aa.email_address)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = select(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\n\nresult = session.execute(stmt)\n```", "```py\n# 1.4 / 2.0 code\n\nsubq = select(User, Address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\nresult = session.execute(stmt)\n```", "```py\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.id_1  AS  anon_1_id_1,\n  anon_1.user_id  AS  anon_1_user_id,\n  anon_1.email_address  AS  anon_1_email_address\nFROM  (\n  SELECT  \"user\".id  AS  id,  address.id  AS  id_1,\n  address.user_id  AS  user_id,  address.email_address  AS  email_address\n  FROM  \"user\"  JOIN  address  ON  \"user\".id  =  address.user_id\n)  AS  anon_1  ORDER  BY  anon_1.email_address\n```", "```py\nsubquery = session.query(User).filter(User.id == 5).subquery()\n\nuser = session.query(User).select_entity_from(subquery).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = session.query(User).filter(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\nuser = session.query(ua).order_by(ua.id).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = select(User).where(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\n# note that LIMIT 1 is not automatically supplied, if needed\nuser = session.execute(select(ua).order_by(ua.id).limit(1)).scalars().first()\n```", "```py\n# In the legacy API, many rows each have the same User primary key, but\n# only one User per primary key is returned\nusers = session.query(User).options(joinedload(User.addresses))\n\n# In the new API, uniquing is available but not implicitly\n# enabled\nresult = session.execute(select(User).options(joinedload(User.addresses)))\n\n# this actually will raise an error to let the user know that\n# uniquing should be applied\nrows = result.all()\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = select(User).options(joinedload(User.addresses))\n\n# statement will raise if unique() is not used, due to joinedload()\n# of a collection.  in all other cases, unique() is not needed.\n# By stating unique() explicitly, confusion over discrepancies between\n# number of objects/ rows returned vs. \"SELECT COUNT(*)\" is resolved\nrows = session.execute(stmt).unique().all()\n```", "```py\n    class User(Base):\n        __tablename__ = \"user\"\n\n        posts = relationship(Post, lazy=\"dynamic\")\n\n    jack = session.get(User, 5)\n\n    # filter Jack's blog posts\n    posts = session.scalars(jack.posts.statement.where(Post.headline == \"this is a post\"))\n    ```", "```py\n    from sqlalchemy.orm import with_parent\n\n    jack = session.get(User, 5)\n\n    posts = session.scalars(\n        select(Post)\n        .where(with_parent(jack, User.posts))\n        .where(Post.headline == \"this is a post\")\n    )\n    ```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine, autocommit=True)\n\n# no transaction begun, but emits SQL, won't be supported\nobj = sess.query(Class).first()\n\n# session flushes in a transaction that it begins and\n# commits, won't be supported\nsess.flush()\n```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine)\n\nsess.begin()  # begin explicitly; if not called, will autobegin\n# when database access is needed\n\nsess.add(obj)\n\nsess.commit()\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef transaction(session):\n    if not session.in_transaction():\n        with session.begin():\n            yield\n    else:\n        yield\n```", "```py\n# method_a starts a transaction and calls method_b\ndef method_a(session):\n    with transaction(session):\n        method_b(session)\n\n# method_b also starts a transaction, but when\n# called from method_a participates in the ongoing\n# transaction.\ndef method_b(session):\n    with transaction(session):\n        session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    method_a(session)\n```", "```py\ndef method_a(session):\n    method_b(session)\n\ndef method_b(session):\n    session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    with session.begin():\n        method_a(session)\n```", "```py\nsession = Session(engine)\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").one()\n\n# becomes legacy use case\nuser = session.query(User).filter_by(name=\"some user\").first()\n\n# becomes legacy use case\nuser = session.query(User).get(5)\n\n# becomes legacy use case\nfor user in (\n    session.query(User).join(User.addresses).filter(Address.email == \"some@email.com\")\n):\n    ...\n\n# becomes legacy use case\nusers = session.query(User).options(joinedload(User.addresses)).order_by(User.id).all()\n\n# becomes legacy use case\nusers = session.query(User).from_statement(text(\"select * from users\")).all()\n\n# etc\n```", "```py\nsession = Session(engine)\n\nuser = session.execute(select(User).filter_by(name=\"some user\")).scalar_one()\n\n# for first(), no LIMIT is applied automatically; add limit(1) if LIMIT\n# is desired on the query\nuser = (\n    session.execute(select(User).filter_by(name=\"some user\").limit(1)).scalars().first()\n)\n\n# get() moves to the Session directly\nuser = session.get(User, 5)\n\nfor user in session.execute(\n    select(User).join(User.addresses).filter(Address.email == \"some@email.case\")\n).scalars():\n    ...\n\n# when using joinedload() against collections, use unique() on the result\nusers = (\n    session.execute(select(User).options(joinedload(User.addresses)).order_by(User.id))\n    .unique()\n    .all()\n)\n\n# select() has ORM-ish methods like from_statement() that only work\n# if the statement is against ORM entities\nusers = (\n    session.execute(select(User).from_statement(text(\"select * from users\")))\n    .scalars()\n    .all()\n)\n```", "```py\n# legacy usage\nuser_obj = session.query(User).get(5)\n```", "```py\n# 1.4 / 2.0 cross-compatible use\nuser_obj = session.get(User, 5)\n```", "```py\n# string use removed\nq = session.query(User).join(\"addresses\")\n\n# string use removed\nq = session.query(User).options(joinedload(\"addresses\"))\n\n# string use removed\nq = session.query(Address).filter(with_parent(u1, \"addresses\"))\n```", "```py\n# compatible with all modern SQLAlchemy versions\n\nq = session.query(User).join(User.addresses)\n\nq = session.query(User).options(joinedload(User.addresses))\n\nq = session.query(Address).filter(with_parent(u1, User.addresses))\n```", "```py\n# SQLAlchemy 1.4 / 2.0 cross compatible use\n\nstmt = select(User).join(User.addresses)\nresult = session.execute(stmt)\n\nstmt = select(User).options(joinedload(User.addresses))\nresult = session.execute(stmt)\n\nstmt = select(Address).where(with_parent(u1, User.addresses))\nresult = session.execute(stmt)\n```", "```py\n# chaining removed\nq = session.query(User).join(\"orders\", \"items\", \"keywords\")\n```", "```py\nq = session.query(User).join(User.orders).join(Order.items).join(Item.keywords)\n```", "```py\n# 1.4 / 2.0 cross compatible\n\nstmt = select(User).join(User.orders).join(Order.items).join(Item.keywords)\nresult = session.execute(stmt)\n\n# join_from can also be helpful\nstmt = select(User).join_from(User, Order).join_from(Order, Item, Order.items)\nresult = session.execute(stmt)\n```", "```py\n# no longer supported\nq = (\n    session.query(Node)\n    .join(\"children\", aliased=True)\n    .filter(Node.name == \"some sub child\")\n    .join(\"children\", from_joinpoint=True, aliased=True)\n    .filter(Node.name == \"some sub sub child\")\n)\n```", "```py\nn1 = aliased(Node)\nn2 = aliased(Node)\n\nq = (\n    select(Node)\n    .join(Node.children.of_type(n1))\n    .where(n1.name == \"some sub child\")\n    .join(n1.children.of_type(n2))\n    .where(n2.name == \"some sub child\")\n)\n```", "```py\n# 1.xx code\n\nresult = (\n    session.query(User)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n    .all()\n)\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = (\n    select(User, Address.email_address)\n    .join(User.addresses)\n    .distinct()\n    .order_by(Address.email_address)\n)\n\nresult = session.execute(stmt).columns(User).all()\n```", "```py\n# from_self is removed\nq = (\n    session.query(User, Address.email_address)\n    .join(User.addresses)\n    .from_self(User)\n    .order_by(Address.email_address)\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = session.query(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nq = session.query(ua, aa).order_by(aa.email_address)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubq = select(User, Address.email_address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\n\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\n\nresult = session.execute(stmt)\n```", "```py\n# 1.4 / 2.0 code\n\nsubq = select(User, Address).join(User.addresses).subquery()\n\nua = aliased(User, subq)\naa = aliased(Address, subq)\n\nstmt = select(ua, aa).order_by(aa.email_address)\nresult = session.execute(stmt)\n```", "```py\nSELECT  anon_1.id  AS  anon_1_id,  anon_1.id_1  AS  anon_1_id_1,\n  anon_1.user_id  AS  anon_1_user_id,\n  anon_1.email_address  AS  anon_1_email_address\nFROM  (\n  SELECT  \"user\".id  AS  id,  address.id  AS  id_1,\n  address.user_id  AS  user_id,  address.email_address  AS  email_address\n  FROM  \"user\"  JOIN  address  ON  \"user\".id  =  address.user_id\n)  AS  anon_1  ORDER  BY  anon_1.email_address\n```", "```py\nsubquery = session.query(User).filter(User.id == 5).subquery()\n\nuser = session.query(User).select_entity_from(subquery).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = session.query(User).filter(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\nuser = session.query(ua).order_by(ua.id).first()\n```", "```py\nfrom sqlalchemy.orm import aliased\n\nsubquery = select(User).where(User.name.like(\"%somename%\")).subquery()\n\nua = aliased(User, subquery)\n\n# note that LIMIT 1 is not automatically supplied, if needed\nuser = session.execute(select(ua).order_by(ua.id).limit(1)).scalars().first()\n```", "```py\n# In the legacy API, many rows each have the same User primary key, but\n# only one User per primary key is returned\nusers = session.query(User).options(joinedload(User.addresses))\n\n# In the new API, uniquing is available but not implicitly\n# enabled\nresult = session.execute(select(User).options(joinedload(User.addresses)))\n\n# this actually will raise an error to let the user know that\n# uniquing should be applied\nrows = result.all()\n```", "```py\n# 1.4 / 2.0 code\n\nstmt = select(User).options(joinedload(User.addresses))\n\n# statement will raise if unique() is not used, due to joinedload()\n# of a collection.  in all other cases, unique() is not needed.\n# By stating unique() explicitly, confusion over discrepancies between\n# number of objects/ rows returned vs. \"SELECT COUNT(*)\" is resolved\nrows = session.execute(stmt).unique().all()\n```", "```py\n    class User(Base):\n        __tablename__ = \"user\"\n\n        posts = relationship(Post, lazy=\"dynamic\")\n\n    jack = session.get(User, 5)\n\n    # filter Jack's blog posts\n    posts = session.scalars(jack.posts.statement.where(Post.headline == \"this is a post\"))\n    ```", "```py\n    from sqlalchemy.orm import with_parent\n\n    jack = session.get(User, 5)\n\n    posts = session.scalars(\n        select(Post)\n        .where(with_parent(jack, User.posts))\n        .where(Post.headline == \"this is a post\")\n    )\n    ```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine, autocommit=True)\n\n# no transaction begun, but emits SQL, won't be supported\nobj = sess.query(Class).first()\n\n# session flushes in a transaction that it begins and\n# commits, won't be supported\nsess.flush()\n```", "```py\nfrom sqlalchemy.orm import Session\n\nsess = Session(engine)\n\nsess.begin()  # begin explicitly; if not called, will autobegin\n# when database access is needed\n\nsess.add(obj)\n\nsess.commit()\n```", "```py\nimport contextlib\n\n@contextlib.contextmanager\ndef transaction(session):\n    if not session.in_transaction():\n        with session.begin():\n            yield\n    else:\n        yield\n```", "```py\n# method_a starts a transaction and calls method_b\ndef method_a(session):\n    with transaction(session):\n        method_b(session)\n\n# method_b also starts a transaction, but when\n# called from method_a participates in the ongoing\n# transaction.\ndef method_b(session):\n    with transaction(session):\n        session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    method_a(session)\n```", "```py\ndef method_a(session):\n    method_b(session)\n\ndef method_b(session):\n    session.add(SomeObject(\"bat\", \"lala\"))\n\nSession = sessionmaker(engine)\n\n# create a Session and call method_a\nwith Session() as session:\n    with session.begin():\n        method_a(session)\n```"]