- en: ORM-Enabled INSERT, UPDATE, and DELETE statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This section makes use of ORM mappings first illustrated in the [SQLAlchemy
    Unified Tutorial](../../tutorial/index.html#unified-tutorial), shown in the section
    [Declaring Mapped Classes](../../tutorial/metadata.html#tutorial-declaring-mapped-classes),
    as well as inheritance mappings shown in the section [Mapping Class Inheritance
    Hierarchies](../inheritance.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[View the ORM setup for this page](_dml_setup.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, in addition to handling ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    objects, can also accommodate ORM-enabled [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") objects, in various ways which are each used
    to INSERT, UPDATE, or DELETE many database rows at once. There is also dialect-specific
    support for ORM-enabled “upserts”, which are INSERT statements that automatically
    make use of UPDATE for rows that already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the calling forms that are discussed in this
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ORM Use Case | DML Construct Used | Data is passed using … | Supports RETURNING?
    | Supports Multi-Table Mappings? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [yes](#orm-queryguide-bulk-insert-returning)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM Bulk Insert with SQL Expressions](#orm-queryguide-bulk-insert-w-sql)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-bulk-insert-w-sql)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-insert-values)
    | no |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM “upsert” Statements](#orm-queryguide-upsert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-upsert-returning)
    | no |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | no | [yes](#orm-queryguide-bulk-update-joined-inh)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where)
    | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    | keywords to [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") | [yes](#orm-queryguide-update-delete-where-returning)
    | [partial, with manual steps](#orm-queryguide-update-delete-joined-inh) |'
  prefs: []
  type: TYPE_TB
- en: '## ORM Bulk INSERT Statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Getting new objects with RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Correlating RETURNING records with input data order'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  prefs: []
  type: TYPE_NORMAL
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  prefs: []
  type: TYPE_NORMAL
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#### Using RETURNING with upsert statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ## ORM Bulk
    UPDATE by Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  prefs: []
  type: TYPE_NORMAL
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  prefs: []
  type: TYPE_NORMAL
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  prefs: []
  type: TYPE_NORMAL
- en: the UPDATE statement given is against an ORM entity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parameters passed are a **list of dictionaries**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]  ### Legacy Session Bulk UPDATE Methods'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ##
    ORM UPDATE and DELETE with Custom WHERE Criteria'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  prefs: []
  type: TYPE_NORMAL
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following values for `synchronize_session` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")  ##
    ORM Bulk INSERT Statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  prefs: []
  type: TYPE_NORMAL
- en: '### Getting new objects with RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Correlating RETURNING records with input data order'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  prefs: []
  type: TYPE_NORMAL
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  prefs: []
  type: TYPE_NORMAL
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#### Using RETURNING with upsert statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ### Getting
    new objects with RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Correlating RETURNING records with input data order'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  #### Correlating RETURNING
    records with input data order'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance'
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Heterogeneous Parameter Dictionaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Sending NULL values in ORM bulk INSERT statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Bulk INSERT for Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Bulk Insert with SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  #### ORM Bulk Insert with
    Per Row SQL Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Legacy Session Bulk INSERT Methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM “upsert” Statements'
  prefs: []
  type: TYPE_NORMAL
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  prefs: []
  type: TYPE_NORMAL
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '#### Using RETURNING with upsert statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  #### Using
    RETURNING with upsert statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)'
  prefs: []
  type: TYPE_NORMAL
- en: '## ORM Bulk UPDATE by Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  prefs: []
  type: TYPE_NORMAL
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  prefs: []
  type: TYPE_NORMAL
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  prefs: []
  type: TYPE_NORMAL
- en: the UPDATE statement given is against an ORM entity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parameters passed are a **list of dictionaries**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]  ### Legacy Session Bulk UPDATE Methods'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ###
    Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  prefs: []
  type: TYPE_NORMAL
- en: the UPDATE statement given is against an ORM entity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parameters passed are a **list of dictionaries**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Bulk UPDATE by Primary Key for Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '### Legacy Session Bulk UPDATE Methods'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Is expressed using the new API as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: '## ORM UPDATE and DELETE with Custom WHERE Criteria'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  prefs: []
  type: TYPE_NORMAL
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following values for `synchronize_session` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Selecting a Synchronization Strategy'
  prefs: []
  type: TYPE_NORMAL
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following values for `synchronize_session` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: '### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  prefs: []
  type: TYPE_NORMAL
