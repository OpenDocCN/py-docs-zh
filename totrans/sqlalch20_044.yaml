- en: ORM-Enabled INSERT, UPDATE, and DELETE statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM-启用的INSERT、UPDATE和DELETE语句
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This section makes use of ORM mappings first illustrated in the [SQLAlchemy
    Unified Tutorial](../../tutorial/index.html#unified-tutorial), shown in the section
    [Declaring Mapped Classes](../../tutorial/metadata.html#tutorial-declaring-mapped-classes),
    as well as inheritance mappings shown in the section [Mapping Class Inheritance
    Hierarchies](../inheritance.html).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节利用了首次在[SQLAlchemy 统一教程](../../tutorial/index.html#unified-tutorial)中展示的ORM映射，如[声明映射类](../../tutorial/metadata.html#tutorial-declaring-mapped-classes)一节所示，以及[映射类继承层次结构](../inheritance.html)一节中展示的继承映射。
- en: '[View the ORM setup for this page](_dml_setup.html).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看此页面的ORM设置](_dml_setup.html)。'
- en: The [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, in addition to handling ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    objects, can also accommodate ORM-enabled [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") objects, in various ways which are each used
    to INSERT, UPDATE, or DELETE many database rows at once. There is also dialect-specific
    support for ORM-enabled “upserts”, which are INSERT statements that automatically
    make use of UPDATE for rows that already exist.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select)对象外，[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法还可以容纳ORM启用的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert)、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update)和[`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete)对象，它们分别以各种方式用于一次性插入、更新或删除多个数据库行。此外，还有特定于方言的支持ORM启用的“upserts”，这是一种自动使用UPDATE来处理已经存在的行的INSERT语句。
- en: 'The following table summarizes the calling forms that are discussed in this
    document:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了本文讨论的调用形式：
- en: '| ORM Use Case | DML Construct Used | Data is passed using … | Supports RETURNING?
    | Supports Multi-Table Mappings? |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| ORM用例 | 使用的DML构造 | 使用以下方式传递数据 | 是否支持RETURNING？ | 是否支持多表映射？ |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [yes](#orm-queryguide-bulk-insert-returning)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [ORM批量插入语句](#orm-queryguide-bulk-insert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表到[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [是](#orm-queryguide-bulk-insert-returning)
    | [是](#orm-queryguide-insert-joined-table-inheritance) |'
- en: '| [ORM Bulk Insert with SQL Expressions](#orm-queryguide-bulk-insert-w-sql)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-bulk-insert-w-sql)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| [使用SQL表达式的ORM批量插入](#orm-queryguide-bulk-insert-w-sql) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [是](#orm-queryguide-bulk-insert-w-sql) | [是](#orm-queryguide-insert-joined-table-inheritance)
    |'
- en: '| [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-insert-values)
    | no |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| [使用每行 SQL 表达式进行 ORM 批量插入](#orm-queryguide-insert-values) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [是](#orm-queryguide-insert-values)
    | 否 |'
- en: '| [ORM “upsert” Statements](#orm-queryguide-upsert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-upsert-returning)
    | no |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| [ORM “upsert” 语句](#orm-queryguide-upsert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [是](#orm-queryguide-upsert-returning)
    | 否 |'
- en: '| [ORM Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | no | [yes](#orm-queryguide-bulk-update-joined-inh)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| [通过主键进行 ORM 批量更新](#orm-queryguide-bulk-update) | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") | 字典列表[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | 否 | [是](#orm-queryguide-bulk-update-joined-inh)
    |'
- en: '| [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where)
    | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    | keywords to [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") | [yes](#orm-queryguide-update-delete-where-returning)
    | [partial, with manual steps](#orm-queryguide-update-delete-joined-inh) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| [使用自定义 WHERE 条件的 ORM UPDATE 和 DELETE](#orm-queryguide-update-delete-where)
    | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    | 关键字[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") | [是](#orm-queryguide-update-delete-where-returning)
    | [部分，需要手动步骤](#orm-queryguide-update-delete-joined-inh) |'
- en: '## ORM Bulk INSERT Statements'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '## ORM 批量插入语句'
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")构造可以根据
    ORM 类构建，并传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法。发送到[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数的参数字典列表，与[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")对象本身分开，将为语句调用**批量插入模式**，这基本上意味着该操作将尽可能地优化多行：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参数字典包含键/值对，这些对应于 ORM 映射属性，与映射的[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或[`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")声明以及[复合](../composites.html#mapper-composite)声明对齐，如果这两个名称恰好不同，则键应与**ORM
    映射属性名称**匹配，而不是实际数据库列名称。
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '在 2.0 版本中更改：将 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法现在会调用“批量插入”，这使用了与传统的 [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 方法相同的功能。这是与 1.x 系列相比的行为变更，在那里 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 将以 Core 为中心的方式解释，使用列名作为值键；现在接受 ORM 属性键。通过将执行选项
    `{"dml_strategy": "raw"}`传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 的 [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") 参数，可以使用 Core 风格的功能。'
- en: '### Getting new objects with RETURNING'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 RETURNING 获取新对象'
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能支持选定后端的 INSERT..RETURNING，该功能可以返回一个[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，该对象可能会返回单个列以及对应于新生成记录的完全构造的 ORM 对象。INSERT..RETURNING
    需要使用支持 SQL RETURNING 语法以及支持带 RETURNING 的 [executemany](../../glossary.html#term-executemany)
    的后端；除了 MySQL（MariaDB 已包含在内）外，此功能适用于所有 [SQLAlchemy 包含的](../../dialects/index.html#included-dialects)
    后端。
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以运行与之前相同的语句，同时使用 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法，将完整的 `User` 实体作为我们希望返回的内容传递进去。
    [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")
    用于允许迭代 `User` 对象：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，渲染的 SQL 采用了由 SQLite 后端请求的[插入多个值](../../core/connections.html#engine-insertmanyvalues)功能所使用的形式，在这里，单个参数字典被嵌入到一个单个的
    INSERT 语句中，以便可以使用 RETURNING。
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：ORM [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在在 ORM 上下文中解释来自 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 甚至 [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 构造的 RETURNING 子句，这意味着可以传递一种混合的列表达式和 ORM 映射实体到
    [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 方法中，然后将以 ORM 结果从构造物如 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 中提供的方式传递，包括映射实体将以 ORM 映射对象的形式在结果中提供。还存在对 ORM
    加载器选项（如 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")）的有限支持。
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将返回的记录与输入数据顺序相关联'
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带 RETURNING 的批量 INSERT 时，重要的是要注意，大多数数据库后端不提供返回的 RETURNING 记录的顺序的正式保证，包括不保证它们的顺序与输入记录的顺序相对应。对于需要确保
    RETURNING 记录能够与输入数据相关联的应用程序，可以指定额外的参数 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order")，这依赖于后端可能使用特殊的
    INSERT 形式来维护一个标记，该标记用于适当地重新排序返回的行，或者在某些情况下，例如在下面使用 SQLite 后端的示例中，该操作将逐行插入：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.10 新功能：添加了 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order")，该功能在
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) 架构中实现。
- en: See also
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[将返回的行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - 介绍了确保输入数据和结果行之间对应关系的方法背景，而不会显著降低性能 ### 使用异构参数字典'
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入功能支持“异构”的参数字典列表，这基本上意味着“各个字典可以具有不同的键”。当检测到这种情况时，ORM将根据每个键集将参数字典分组，并相应地批处理到单独的INSERT语句中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，传递的五个参数字典被转换为三个INSERT语句，按照每个字典中特定的键集分组，同时仍保持行顺序，即`("name", "fullname",
    "species")`，`("name", "species")`，`("name","fullname", "species")`。### 在ORM批量INSERT语句中发送NULL值
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 批量ORM插入功能利用了遗留“批量”插入行为以及总体ORM工作单元中存在的行为，即包含NULL值的行使用不引用这些列的语句进行INSERT；这样做的理由是，包含服务器端INSERT默认值的后端和模式可能对NULL值与没有值的存在敏感，并且会产生预期的服务器端值。这种默认行为会将批量插入的批次分解为更多的行数较少的批次：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，四行的批量INSERT被分解成三个单独的语句，第二个语句重新格式化，不再引用包含`None`值的单个参数字典的NULL列。当数据集中的许多行包含随机NULL值时，这种默认行为可能是不希望的，因为它会导致“executemany”操作被分解为更多的较小操作；特别是当依赖于[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)来减少总语句数时，这可能会产生更大的性能影响。
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用对参数中的`None`值进行分批处理的操作，请传递执行选项`render_nulls=True`；这将导致所有参数字典被等效处理，假定每个字典中具有相同的键集：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，所有的参数字典都被发送到一个单独的INSERT批处理中，包括第三个参数字典中存在的`None`值。
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本2.0.23中：添加了`render_nulls`执行选项，该选项反映了遗留的[`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings")参数的行为。### 用于连接表继承的批量INSERT
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入建立在传统的[工作单元](../../glossary.html#term-unit-of-work)系统使用的内部系统之上，以发出INSERT语句。这意味着对于映射到多个表的ORM实体，通常是使用[联接表继承](../inheritance.html#joined-inheritance)进行映射的实体，批量插入操作将为映射表示的每个表发出一个INSERT语句，正确地将服务器生成的主键值传递给依赖于它们的表行。此处还支持RETURNING功能，ORM将为执行的每个INSERT语句接收[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后“水平拼接”它们，以便返回的行包括插入的所有列的值：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 加入继承映射的批量插入要求ORM在内部使用[`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")参数，以便它可以将来自基表的RETURNING行的主键值与用于插入“子”表的参数集相关联，这就是为什么上面示例中的SQLite后端会透明地降级到使用非批量语句。有关此功能的背景信息，请参阅[将RETURNING行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)。###
    使用SQL表达式进行ORM批量插入
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入功能支持添加一组固定的参数，其中可能包括要应用于每个目标行的SQL表达式。为了实现这一点，结合使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法，传递一个将应用于所有行的参数字典，以及在调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时包含包含单个行值的参数字典列表的常规批量调用形式。
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个包含“timestamp”列的ORM映射：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要插入一系列具有唯一`message`字段的`LogRecord`元素，但是我们希望对所有行应用SQL函数`now()`，我们可以在[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")中传递`timestamp`，然后使用“bulk”模式传递额外的记录：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用每行SQL表达式进行ORM批量插入'
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法本身直接接受参数字典列表。当以这种方式使用[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造时，如果没有将参数字典列表传递给[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数，则不使用批量ORM插入模式，而是将INSERT语句完全按照给定的方式呈现并且仅调用一次。这种操作模式既对于逐行传递SQL表达式的情况有用，也适用于使用ORM的“upsert”语句时，本章后面的文档中有介绍，位于[ORM
    “upsert” Statements](#orm-queryguide-upsert)。'
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个构造性的示例，其中嵌入了每行SQL表达式的INSERT，还以这种形式演示了[`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为上面没有使用批量ORM插入模式，所以下面的功能不可用：
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[联接表继承](#orm-queryguide-insert-joined-table-inheritance)或其他多表映射，因为这将需要多个INSERT语句。
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[异构参数集](#orm-queryguide-insert-heterogeneous-params) - VALUES集合中的每个元素必须具有相同的列。
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提供核心级别的规模优化，例如[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)提供的批处理;
    语句需要确保参数的总数不超过后端数据库施加的限制。
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，通常不建议在ORM INSERT语句中使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")与多个参数集合，除非有明确的理由，即要么使用了“upsert”，要么需要在每个参数集合中嵌入每行SQL表达式。
- en: See also
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")包括用于执行“批量”INSERT和UPDATE语句的传统方法。
    这些方法与SQLAlchemy 2.0版本的这些功能共享实现，描述在[ORM批量INSERT语句](#orm-queryguide-bulk-insert)和[ORM按主键批量UPDATE](#orm-queryguide-bulk-update)，但缺少许多功能，即不支持RETURNING支持以及不支持会话同步。'
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 的代码，例如可以像下面这样移植代码，从这个映射示例开始：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The above is expressed using the new API as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容可使用新 API 表达为：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[传统会话批量更新方法](#orm-queryguide-legacy-bulk-update)  ### ORM “upsert” 语句'
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，选定的后端可能包括特定方言的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，这些构造还具有执行“upserts”或将参数集中的现有行转换为近似 UPDATE
    语句的能力。对于“现有行”，这可能意味着共享相同主键值的行，或者可能是指被视为唯一的行内其他索引列；这取决于正在使用的后端的能力。
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 包含有包含特定方言的“upsert” API 特性的方言，它们是：
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite - 使用[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")，文档位于[INSERT…ON CONFLICT（Upsert）](../../dialects/sqlite.html#sqlite-on-conflict-insert)
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL - 使用[`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert")，文档位于[INSERT…ON CONFLICT（Upsert）](../../dialects/postgresql.html#postgresql-insert-on-conflict)
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL/MariaDB - 使用[`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert")，文档位于[INSERT…ON DUPLICATE KEY UPDATE（Upsert）](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该查阅上述章节以了解正确构建这些对象的背景；特别是，“upsert” 方法通常需要参考原始语句，因此通常语句会分为两个独立的步骤构建。
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端，如在 [外部方言](../../dialects/index.html) 中提到的后端，也可能具有类似的构造。
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQLAlchemy 还没有与后端无关的 upsert 构造，但上述的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 变体仍然与 ORM 兼容，因为它们可以像在 [ORM Bulk Insert with
    Per Row SQL Expressions](#orm-queryguide-insert-values) 中所记录的那样使用与 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造本身相同的方式，即通过在 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法中嵌入要插入的所需行。在下面的例子中，使用 SQLite 的 [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数来生成包含 “ON CONFLICT DO UPDATE” 支持的 [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 构造。然后，将语句传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，它会正常进行，但额外的特点是传递给 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 的参数字典被解释为 ORM 映射的属性键，而不是列名：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用 RETURNING 与 upsert 语句'
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy ORM 的角度来看，upsert 语句看起来就像普通的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，其中包括 [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 与 upsert 语句的使用方式与在 [ORM Bulk Insert
    with Per Row SQL Expressions](#orm-queryguide-insert-values) 中演示的方式相同，因此可以传递任何列表达式或相关的
    ORM 实体类。接着上一节的例子继续：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用 RETURNING 来返回由语句插入或更新的每一行的 ORM 对象。该示例还添加了 [现有数据填充](api.html#orm-queryguide-populate-existing)
    执行选项的使用。此选项表示 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中已经存在的 `User` 对象应该使用新行的数据进行**刷新**。对于纯 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句来说，此选项并不重要，因为生成的每一行都是全新的主键标识。但是，当 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 还包括“upsert”选项时，它也可能会产生来自已经存在的行的结果，因此可能已经在
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的[标识映射](../../glossary.html#term-identity-map)中具有主键标识。
- en: See also
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ## ORM Bulk
    UPDATE by Primary Key'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[现有数据填充](api.html#orm-queryguide-populate-existing)  ## 按主键进行ORM批量更新'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    构造可以与 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 以类似的方式使用，就像[ORM批量插入语句](#orm-queryguide-bulk-insert)中描述的使用
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    语句一样，传递一个参数字典列表，每个字典表示对应单个主键值的单个行。这种用法不应与在ORM中更常见的使用 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 语句的方式混淆，该方式使用显式的 WHERE 子句，在[ORM UPDATE and
    DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where)中有文档记录。'
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“批量”版本的UPDATE，通过ORM类构造一个[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")语句，并传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法；生成的[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")对象不应具有任何值，通常也不应具有WHERE条件，也就是说，不使用[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values")方法，通常也不使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")方法，但在不寻常的情况下可能会使用，以添加额外的过滤条件。
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")构造与包含完整主键值的参数字典列表一起传递将触发**主键批量UPDATE模式**，生成适当的WHERE条件以按主键匹配每一行，并使用[executemany](../../glossary.html#term-executemany)对UPDATE语句运行每个参数集：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个参数字典必须为每个记录包含完整的主键，否则将引发错误。
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与批量INSERT功能类似，这里也支持异构参数列表，其中参数将被分组为UPDATE运行的子批次。
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.11版本中更改：可以使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")方法将附加的WHERE条件与[ORM主键批量UPDATE](#orm-queryguide-bulk-update)组合使用以添加额外的条件。但是，此条件始终是附加到已经存在的包括主键值在内的WHERE条件之上的。
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“主键批量UPDATE”功能时，不支持RETURNING功能；多个参数字典的列表必然使用了DBAPI [executemany](../../glossary.html#term-executemany)，通常情况下，这种形式不支持结果行。
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版中更改：将 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 结构传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法以及参数字典列表现在调用“批量更新”，这使用的是与旧版 [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") 方法相同的功能。这与 1.x 系列中的行为更改不同，在 1.x
    系列中，[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    仅受到显式 WHERE 条件和内联 VALUES 的支持。
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '### 禁用对具有多个参数集的 UPDATE 语句进行按主键的 ORM 批量更新'
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当：
- en: the UPDATE statement given is against an ORM entity
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出的 UPDATE 语句针对 ORM 实体
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    用于执行语句，而不是核心 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")'
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的参数是**字典列表**。
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用不使用“按主键的 ORM 批量更新”的 UPDATE 语句，直接使用 [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 方法对当前事务获取 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 执行语句：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键每行的 ORM 批量更新要求记录包含主键值](../../errors.html#error-bupq)  ### 联合表继承的按主键批量更新'
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有联合表继承的映射时，ORM 批量更新的行为与使用映射进行批量插入时类似；如 [联合表继承的批量插入](#orm-queryguide-insert-joined-table-inheritance)
    中所述，批量更新操作将为映射中表示的每个表发出一条 UPDATE 语句，其中给定的参数包括要更新的值（不受影响的表将被跳过）。
- en: 'Example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '示例:'
- en: '[PRE16]  ### Legacy Session Bulk UPDATE Methods'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]  ### 旧版会话批量更新方法'
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如[传统会话批量INSERT方法](#orm-queryguide-legacy-bulk-insert)所讨论的，[`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法是批量更新的传统形式，当解释具有给定主键参数的[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")语句时，ORM在内部使用它；但是，当使用传统版本时，诸如会话同步支持之类的功能是不包括的。
- en: 'The example below:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Is expressed using the new API as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新API表示为：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ##
    ORM UPDATE and DELETE with Custom WHERE Criteria'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[传统会话批量INSERT方法](#orm-queryguide-legacy-bulk-insert)  ## 使用自定义WHERE条件的ORM UPDATE和DELETE'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义WHERE条件构造[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")构造时（即使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")和[`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where")方法），可以通过将它们传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")在ORM上下文中调用，而不使用[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数。对于[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")，要更新的值应该使用[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values")传递。
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此使用模式与之前描述的功能不同[ORM按主键批量更新](#orm-queryguide-bulk-update)，ORM使用给定的WHERE子句，而不是将WHERE子句固定为主键。这意味着单个UPDATE或DELETE语句可以一次性影响许多行。
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，下面发出一个UPDATE，影响多行的“fullname”字段
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DELETE，基于条件删除行的示例：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Warning
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读以下部分[ORM启用更新和删除的重要注意事项和注意事项](#orm-queryguide-update-delete-caveats)，以了解ORM启用的UPDATE和DELETE功能与ORM
    [工作单元](../../glossary.html#term-unit-of-work) 功能的功能不同，例如使用[`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法删除单个对象。
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM-启用的 Update 和 Delete 的重要说明和注意事项'
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 启用的 UPDATE 和 DELETE 功能绕过 ORM [工作单元](../../glossary.html#term-unit-of-work)
    自动化，以便能够发出一条匹配多行的 UPDATE 或 DELETE 语句，而不会复杂化。
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作不提供 Python 中的关系级联功能 - 假定任何需要的外键引用都已配置为 ON UPDATE CASCADE 和/或 ON DELETE CASCADE，否则如果强制执行外键引用，则数据库可能会发出完整性违规。有关一些示例，请参阅[使用外键
    ON DELETE cascade 与 ORM 关系](../cascades.html#passive-deletes)的注意事项。
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 UPDATE 或 DELETE 之后，[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中受到影响的依赖对象，特别是那些引用现在已被删除的行的 ON UPDATE CASCADE 或 ON DELETE
    CASCADE 的相关表的对象，可能仍然引用这些对象。此问题在 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 过期时解决，通常发生在 [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时或可以通过使用 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 强制执行。
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 ORM 的 UPDATE 和 DELETE 不会自动处理连接的表继承。有关如何处理连接继承映射的说明，请参阅[具有自定义 WHERE 条件的连接表继承的
    UPDATE/DELETE](#orm-queryguide-update-delete-joined-inh)部分。
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将单表继承映射的多态标识限制为特定子类所需的 WHERE 条件**会自动包含**。这仅适用于没有自己表的子类映射器。
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 更新和删除操作支持 [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 选项；此处的条件将被添加到正在发出的 UPDATE 或 DELETE 语句的条件中，并在“同步”过程中考虑。
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要拦截启用 ORM 的 UPDATE 和 DELETE 操作以使用事件处理程序，请使用[`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。  ### 选择同步策略'
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")与启用 ORM 执行一起使用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，将存在额外的 ORM 特定功能，该功能将**同步**语句更改的状态与当前存在于[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[identity map](../../glossary.html#term-identity-map)中的对象的状态。通过“同步”，我们指的是更新的属性将使用新值刷新，或者至少[过期](../../glossary.html#term-expired)，以便在下次访问时重新填充其新值，并且删除的对象将移至[deleted](../../glossary.html#term-deleted)状态。
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此同步可通过“同步策略”控制，该策略作为字符串 ORM 执行选项传递，通常使用[`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") 字典：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行选项也可以与语句本身捆绑在一起，使用[`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") 方法：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下`synchronize_session`的值：
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''auto''` - 这是默认值。在支持 RETURNING 的后端上将使用 `''fetch''` 策略，这包括除 MySQL 外的所有 SQLAlchemy
    本机驱动程序。如果不支持 RETURNING，则将改为使用 `''evaluate''` 策略。'
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''fetch''` - 通过在执行 UPDATE 或 DELETE 之前执行 SELECT 或使用 RETURNING（如果数据库支持）来检索受影响行的主键标识，以便受操作影响的内存对象可以使用新值刷新（更新）或从[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中删除（删除）。即使给定的[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造明确指定实体或列使用[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning")，也可以使用此同步策略。'
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版中的更改：在使用启用 ORM 的 UPDATE 和 DELETE 以 WHERE 条件时，可以将明确的[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 与 `'fetch'` 同步策略结合使用。实际语句将包含`'fetch'`策略所需的列和请求的列之间的并集。
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''evaluate''` - 这表示在 Python 中评估 UPDATE 或 DELETE 语句中给定的 WHERE 条件，以定位[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的匹配对象。这种方法不会为操作添加任何 SQL 往返，并且在没有 RETURNING 支持的情况下，可能更有效。对于具有复杂条件的
    UPDATE 或 DELETE 语句，`''evaluate''` 策略可能无法在 Python 中评估表达式，并且会引发错误。如果发生这种情况，请改用该操作的
    `''fetch''` 策略。'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 SQL 表达式使用[`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 或 [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") 功能使用自定义运算符，则可以使用 [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") 参数指示将由`"evaluate"`同步策略使用的 Python 函数。
- en: New in version 2.0.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版中的新功能。
- en: Warning
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果要在具有许多已过期对象的[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")上运行
    UPDATE 操作，则应避免使用`"evaluate"`策略，因为它将必须刷新对象以便根据给定的 WHERE 条件测试它们，这将为每个对象发出一个 SELECT。在这种情况下，特别是如果后端支持
    RETURNING，则应优先选择`"fetch"`策略。
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False` - 不同步会话。该选项对于不支持 RETURNING 的后端可能很有用，其中无法使用`"evaluate"`策略。在这种情况下，[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中对象的状态不变，不会自动对应于发出的 UPDATE 或 DELETE 语句，如果存在通常与匹配行对应的对象。###
    使用 UPDATE/DELETE 和自定义 WHERE 条件的 RETURNING'
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法与启用 ORM 的 UPDATE 和 DELETE
    以 WHERE 条件完全兼容。完整的 ORM 对象和/或列可以用于 RETURNING：'
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: RETURNING 的支持也与 `fetch` 同步策略兼容，`fetch` 同样使用 RETURNING。ORM 将适当地组织 RETURNING 中的列，以便同步进程顺利进行，并且返回的
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    将以请求的实体和 SQL 列的请求顺序包含。
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版中的新功能：[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 可用于启用 ORM 的 UPDATE 和 DELETE，并仍保留与
    `fetch` 同步策略的完全兼容性。### 使用自定义 WHERE 条件进行连接表继承的 UPDATE/DELETE
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 WHERE 条件的 UPDATE/DELETE 功能，不像 [基于主键的 ORM 大规模 UPDATE](#orm-queryguide-bulk-update)，每次调用
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    时只发出单个 UPDATE 或 DELETE 语句。这意味着当针对多表映射运行 [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 或 [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 语句时，如连接表继承映射中的子类，该语句必须符合后端当前的功能，这可能包括后端不支持引用多个表的
    UPDATE 或 DELETE 语句，或者仅对此有限支持。这意味着对于诸如连接继承子类之类的映射，UPDATE/DELETE 功能的 ORM 版本只能在有限程度上使用或根本无法使用，具体取决于具体情况。
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接表子类发出多行 UPDATE 语句的最直接方法是仅引用子表。这意味着 [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 构造应仅引用本地于子类表的属性，如下例所示：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述形式，一个简单的方法是引用基表来定位任何 SQL 后端上的行，可以使用子查询：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持 UPDATE…FROM 的后端，子查询可以作为额外的普通 WHERE 条件陈述，但是两个表之间的条件必须以某种方式明确陈述：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DELETE 操作，预期基表和子表中的行将同时被 DELETE。要在不使用级联外键的情况下 DELETE 多行连接继承对象，应分别发出针对每个表的
    DELETE：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于更新和删除联合继承和其他多表映射的行，应**优先**使用普通的[工作单元](../../glossary.html#term-unit-of-work)流程，除非存在使用自定义
    WHERE 条件的性能原因。
- en: Legacy Query Methods
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧版查询方法
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 ORM 启用的带有 WHERE 功能的 UPDATE/DELETE 最初是 [`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象的一部分，位于 [`Query.update()`](query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法中。这些方法仍然可用，并提供与 [ORM UPDATE and DELETE with Custom
    WHERE Criteria](#orm-queryguide-update-delete-where) 描述的部分相同的功能。主要区别在于旧版方法不提供显式的
    RETURNING 支持。
- en: See also
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")  ##
    ORM Bulk INSERT Statements'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")  ##
    ORM 批量插入语句'
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以基于 ORM 类构建 [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 构造，并将其传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法。发送到 [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute.params.params") 参数的参数字典列表，与 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 对象本身分开，将为语句调用**批量插入模式**，这基本上意味着操作将尽可能地为许多行进行优化：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 参数字典包含键值对，这些键值对可能对应于与映射的 [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 或 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 声明相对应的 ORM 映射属性，以及与[组合](../composites.html#mapper-composite)声明相对应的映射。如果这两个名称恰好不同，则键应与**ORM
    映射属性名称**匹配，而**不是**实际的数据库列名称。
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '2.0 版本中的更改：将 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 结构传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法现在会调用“批量插入”，这利用了与传统的 [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 方法相同的功能。这与 1.x 系列中的行为变化相比，1.x 系列中
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    将以核心为中心的方式解释，使用列名作为值键；现在接受 ORM 属性键。通过将执行选项 `{"dml_strategy": "raw"}` 传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法的 [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") 参数，可以使用核心样式功能。'
- en: '### Getting new objects with RETURNING'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 RETURNING 获取新对象'
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能支持为选定的后端进行 INSERT..RETURNING，该功能可以返回一个 [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象，该对象可以返回单个列以及对应于新生成记录的完全构造的 ORM 对象。INSERT..RETURNING
    需要使用支持 SQL RETURNING 语法以及支持带有 RETURNING 的 [executemany](../../glossary.html#term-executemany)
    的后端；除了 MySQL（包括 MariaDB）之外，所有 [SQLAlchemy 包含的](../../dialects/index.html#included-dialects)
    后端都支持此功能。
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以运行与之前相同的语句，添加使用 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法，并将完整的 `User` 实体作为我们要返回的内容。使用
    [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")
    允许迭代 `User` 对象：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，渲染的 SQL 采用了由 SQLite 后端请求的 [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    功能使用的形式，其中个别参数字典被内联到单个 INSERT 语句中，以便使用 RETURNING。
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本中更改：ORM [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在在 ORM 上下文中解释来自 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 甚至 [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 构造的 RETURNING 子句，这意味着可以将一系列列表达式和 ORM 映射实体传递给
    [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 方法，然后以从构造物如 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 传递 ORM 结果的方式传递，包括映射实体将作为 ORM 映射对象在结果中传递。还存在对于
    ORM 加载器选项的有限支持，如 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")。
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将 RETURNING 记录与输入数据顺序相关联'
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 RETURNING 的批量 INSERT 时，重要的是要注意，大多数数据库后端不保证从 RETURNING 返回的记录的顺序，包括不能保证它们的顺序与输入记录的顺序对应。对于需要确保
    RETURNING 记录与输入数据相关联的应用程序，可以指定额外的参数 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，根据后端的不同，可能使用特殊的 INSERT 表单来维护一个标记，该标记用于适当地重新排序返回的行，或者在某些情况下，例如在下面使用
    SQLite 后端的示例中，操作将一次插入一行：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.10 新内容：添加了 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，该内容在 [insertmanyvalues](../../glossary.html#term-insertmanyvalues)
    架构中实现。
- en: See also
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[将 RETURNING 行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - 关于保证输入数据和结果行之间对应关系的方法的背景信息，而又不显著降低性能 ### 使用异构参数字典'
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入功能支持“异构”参数字典列表，这基本上意味着“各个字典可以具有不同的键”。当检测到这种条件时，ORM 将参数字典分组成对应于每个键集的组，并相应地批量处理成单独的
    INSERT 语句：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，传递的五个参数字典被转换为三个 INSERT 语句，按照每个字典中特定键的组合进行分组，同时保持行顺序，即 `("name", "fullname",
    "species")`、 `("name", "species")`、 `("name","fullname", "species")`。### 在 ORM
    批量 INSERT 语句中发送 NULL 值
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能借鉴了遗留的“批量”插入行为，以及 ORM 工作单元总体上的行为，即包含 NULL 值的行将使用不引用这些列的语句进行插入；这样做的理由是，包含服务器端插入默认值的后端和模式可能对
    NULL 值的存在与不存在敏感，将产生预期的服务器端值。这种默认行为会将批量插入的批次分解成更多行数较少的批次：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，四行的批量插入被分成三个单独的语句，第二个语句重新格式化以不引用包含 `None` 值的单个参数字典的 NULL 列。当数据集中的许多行包含随机
    NULL 值时，这种默认行为可能是不希望的，因为它会将“executemany”操作分解成更多的较小操作；特别是当依赖 [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    来减少总语句数时，这可能会产生更大的性能影响。
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用将参数中的 `None` 值处理为单独批次的行为，请传递执行选项 `render_nulls=True`；这将导致所有参数字典被视为等效处理，假定每个字典中具有相同的键集：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，所有参数字典都在单个 INSERT 批次中发送，包括第三个参数字典中的 `None` 值。
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0.23 开始：添加了 `render_nulls` 执行选项，其反映了遗留的 [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") 参数的行为。### 关于连接表继承的批量 INSERT
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入建立在传统的[unit of work](../../glossary.html#term-unit-of-work)系统使用的内部系统之上，以发出
    INSERT 语句。这意味着对于一个被映射到多个表的 ORM 实体，通常是使用[joined table inheritance](../inheritance.html#joined-inheritance)映射的实体，批量插入操作将为每个由映射表示的表发出一个
    INSERT 语句，正确地将服务器生成的主键值传递给依赖于它们的表行。RETURNING 特性在这里也受支持，ORM 将为每个执行的 INSERT 语句接收[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后将它们“水平拼接”在一起，以便返回的行包括插入的所有列的值：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 插入连接继承映射的批量操作要求 ORM 内部使用 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") 参数，以便它可以将来自 RETURNING 行的主键值从基表相关联到用于插入到“子”表中的参数集，这就是为什么上面示例中的
    SQLite 后端会透明地降级到使用非批处理语句的原因。关于此功能的背景请参阅[将 RETURNING 行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)。###
    带 SQL 表达式的 ORM 批量插入
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入功能支持添加一组固定的参数，其中可能包括要应用于每个目标行的 SQL 表达式。要实现这一点，请将[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法与通常的批量调用形式结合使用，方法是在调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时包含包含单独行值的参数字典列表。
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，考虑一个包含“timestamp”列的 ORM 映射：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要插入一系列具有唯一 `message` 字段的 `LogRecord` 元素，但是我们希望将 SQL 函数 `now()` 应用于所有行，我们可以在
    [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 中传递 `timestamp`，然后使用“批量”模式传递额外的记录：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 带每行 SQL 表达式的 ORM 批量插入'
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法本身直接适应参数字典列表。 当以这种方式使用 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造时，而不向 [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") 参数传递任何参数字典列表时，不会使用批量 ORM 插入模式，而是精确地按照给定的方式呈现
    INSERT 语句，并且仅调用一次。 这种操作模式在每行基础上传递 SQL 表达式的情况下可能有用，并且在使用 ORM 时使用“upsert”语句时也会使用，本章后面的文档中有描述，位于
    [ORM “upsert” 语句](#orm-queryguide-upsert)。'
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个人为的示例，展示了嵌入每行 SQL 表达式的 INSERT，并演示了此形式中的 [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为上面没有使用批量 ORM 插入模式，所以以下功能不可用：
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[联合表继承](#orm-queryguide-insert-joined-table-inheritance)或其他多表映射，因为这将需要多个
    INSERT 语句。
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[异构参数集](#orm-queryguide-insert-heterogeneous-params) - 值集中的每个元素必须具有相同的列。
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可用于核心级别的规模优化，例如 [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    提供的批处理；语句需要确保参数的总数不超过由支持数据库施加的限制。
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，通常不建议在 ORM INSERT 语句中使用多个参数集与 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")，除非有明确的理由，即正在使用“upsert”或需要在每个参数集中嵌入每行
    SQL 表达式。
- en: See also
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert” 语句](#orm-queryguide-upsert)  ### 传统会话批量插入方法'
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    包括执行“批量”插入和更新语句的传统方法。 这些方法与 SQLAlchemy 2.0 版本的这些功能共享实现，描述在 [ORM 批量插入语句](#orm-queryguide-bulk-insert)
    和 [ORM 按主键批量更新](#orm-queryguide-bulk-update)，但缺少许多功能，即不支持 RETURNING 和会话同步支持。'
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")等代码可以按照以下方式移植代码，从这个映射示例开始：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The above is expressed using the new API as:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容使用新API表达为：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[传统会话批量更新方法](#orm-queryguide-legacy-bulk-update)  ### ORM “upsert”语句'
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy的选定后端可能包括特定于方言的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造，这些构造还具有执行“upserts”或将参数集中的现有行转换为近似UPDATE语句的能力。通过“现有行”，这可能意味着共享相同主键值的行，或者可能指其他被视为唯一的行内索引列；这取决于所使用后端的功能。
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy包含的包括特定于方言的“upsert”API功能的方言有：
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite - 使用[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")，文档位于[INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL - 使用[`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert")，文档位于[INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL/MariaDB - 使用[`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert")，文档位于[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该查看上述部分以了解正确构建这些对象的背景；特别是，“upsert”方法通常需要参考原始语句，因此语句通常分两步构建。
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端，如在[外部方言](../../dialects/index.html)中提到的可能还具有类似的构造。
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQLAlchemy 尚未拥有与后端无关的 upsert 构造，但上述[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")变体在ORM兼容方面仍然可用，因为它们可以像文档中记录的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造本身一样使用，方法是将要插入的期望行嵌入到[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法中。在下面的示例中，使用 SQLite 的[`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert")函数生成了一个包含“ON CONFLICT DO UPDATE”支持的[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")构造。然后将该语句传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，它会正常进行，额外的特点是传递给[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的参数字典被解释为ORM映射的属性键，而不是列名：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用 RETURNING 语句与 upsert 语句'
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLAlchemy ORM的角度来看，upsert 语句看起来像是常规的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造，其中包括[`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")与在[ORM Bulk Insert with Per Row SQL
    Expressions](#orm-queryguide-insert-values)中演示的方式一样与 upsert 语句一起工作，以便传递任何列表达式或相关的ORM实体类。继续从前一节的示例继续进行：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以上示例使用 RETURNING 来返回由语句插入或更新的每一行的 ORM 对象。该示例还添加了对 [已有对象填充](api.html#orm-queryguide-populate-existing)
    执行选项的使用。此选项表示对于已存在的 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中已经存在的行的 `User` 对象应该使用新行的数据进行 **刷新**。对于纯 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句来说，此选项并不重要，因为每个生成的行都是全新的主键标识。但是当 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 还包括“upsert”选项时，它也可能会产生来自已存在行的结果，因此这些行可能已经在
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的 [标识映射](../../glossary.html#term-identity-map) 中表示了主键标识。
- en: See also
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ### Getting
    new objects with RETURNING'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[已有对象填充](api.html#orm-queryguide-populate-existing) ### 使用 RETURNING 获取新对象'
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能支持选定后端的 INSERT..RETURNING，它可以返回一个 [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象，该对象可以返回单独的列以及与新生成记录相对应的完全构造的 ORM 对象。INSERT..RETURNING
    需要使用支持 SQL RETURNING 语法以及支持带 RETURNING 的 [executemany](../../glossary.html#term-executemany)
    的后端；除了 MySQL（MariaDB 已包含在内）之外，此功能在所有 [SQLAlchemy 包含的](../../dialects/index.html#included-dialects)
    后端中都可用。
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以运行与之前相同的语句，添加对 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法的使用，并将完整的 `User` 实体作为我们想要返回的内容传递。使用
    [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")
    允许迭代 `User` 对象：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，呈现的 SQL 采用了由 SQLite 后端请求的 [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    功能使用的形式，其中个别参数字典被内联到单个 INSERT 语句中，以便使用 RETURNING。
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本中的更改：ORM [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在会在 ORM 上下文中解释来自 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 甚至 [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 构造的 RETURNING 子句，这意味着可以传递混合的列表达式和 ORM 映射实体给
    [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 方法，然后将以与 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 等构造中的 ORM 结果相同的方式传递，包括将映射实体作为 ORM 映射对象在结果中传递。还存在对
    ORM 加载器选项（例如 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")）的有限支持。
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将 RETURNING 记录与输入数据顺序相关联'
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带有 RETURNING 的批量 INSERT 时，重要的是要注意，大多数数据库后端没有明确保证返回的 RETURNING 记录的顺序，包括没有保证其顺序与输入记录的顺序相对应。对于需要确保
    RETURNING 记录与输入数据相关联的应用程序，可以指定额外的参数 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，这取决于后端可能使用特殊的 INSERT 形式，以保持适当地重新排序返回的行，或者在某些情况下，例如在使用
    SQLite 后端的下面示例中，该操作将逐行插入：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.10 中新增了 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，该功能是在 [insertmanyvalues](../../glossary.html#term-insertmanyvalues)
    架构内实现的。
- en: See also
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  #### Correlating RETURNING
    records with input data order'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[将 RETURNING 行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - 关于采取的方法背景，以确保输入数据与结果行之间的对应关系，而不会显著降低性能  #### 将 RETURNING 记录与输入数据顺序相关联'
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有 RETURNING 的批量 INSERT 时，重要的是要注意，大多数数据库后端不保证返回 RETURNING 记录的顺序，包括它们的顺序与输入记录的顺序相对应这一点。对于需要确保
    RETURNING 记录与输入数据相关联的应用程序，可以指定额外的参数 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，具体取决于后端，它可能使用特殊的 INSERT 形式来维护一个令牌，该令牌用于适当地重新排序返回的行，或者在某些情况下，例如使用
    SQLite 后端的以下示例中，该操作将一次插入一行：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.0.10 版开始：新增了 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")，它是在 [insertmanyvalues](../../glossary.html#term-insertmanyvalues)
    架构中实现的。
- en: See also
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[将 RETURNING 行与参数集对应起来](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - 关于采取的方法，以确保输入数据与结果行之间的对应关系而不会显著降低性能'
- en: '### Using Heterogeneous Parameter Dictionaries'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用异构参数字典'
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入功能支持“异构”参数字典列表，这基本上意味着“各个字典可以具有不同的键”。当检测到这种条件时，ORM 将参数字典分组为对应于每个键集的组，并相应地将它们分批成单独的
    INSERT 语句：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，传递的五个参数字典被转换为三个 INSERT 语句，根据每个字典中的特定键组合成组，同时保持行顺序，即 `("name", "fullname",
    "species")`，`("name", "species")`，`("name","fullname", "species")`。
- en: '### Sending NULL values in ORM bulk INSERT statements'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在 ORM 批量 INSERT 语句中发送 NULL 值'
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能利用了在传统“批量”插入行为以及整体 ORM 工作单元中也存在的行为，即包含 NULL 值的行将使用不引用这些列的语句进行 INSERT；其理由是后端和包含服务器端
    INSERT 默认值的模式可能对存在 NULL 值与不存在值的情况敏感，将产生预期的服务器端值。这种默认行为会导致批量插入的批次被分成更多的少行批次：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，四行的批量插入被分解为三个单独的语句，第二个语句重新格式化以不引用包含`None`值的单个参数字典的 NULL 列。当数据集中的许多行包含随机 NULL
    值时，此默认行为可能是不希望的，因为它会导致“executemany”操作被分解为更多的较小操作；特别是当依赖于[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)来减少总体语句数时，这可能会产生更大的性能影响。
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用对参数中的`None`值进行单独批处理的处理，请传递执行选项`render_nulls=True`；这将导致所有参数字典被等同对待，假设每个字典中都有相同的键：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，所有参数字典都在单个插入批次中发送，包括第三个参数字典中的`None`值。
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0.23 开始：添加了`render_nulls`执行选项，它镜像了传统[`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings")参数的行为。
- en: '### Bulk INSERT for Joined Table Inheritance'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '### 批量插入联合表继承'
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入建立在传统[工作单元](../../glossary.html#term-unit-of-work)系统中使用的内部系统之上，以发出 INSERT
    语句。这意味着对于映射到多个表的 ORM 实体，通常是使用[联合表继承](../inheritance.html#joined-inheritance)映射的实体，批量插入操作将为映射的每个表发出一个
    INSERT 语句，将服务器生成的主键值正确传递给依赖于它们的表行。此外，这里还支持 RETURNING 功能，ORM 将接收每个执行的 INSERT 语句的[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后将它们“横向拼接”起来，以便返回的行包括插入的所有列的值：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 批量插入联合继承映射要求 ORM 在内部使用[`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")参数，以便它可以将 RETURNING 表中的主键值与用于插入“子”表的参数集相关联，这就是为什么上面的
    SQLite 后端在透明地降级为使用非批处理语句的原因。关于此功能的背景信息，请参阅[将 RETURNING 行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)。
- en: '### ORM Bulk Insert with SQL Expressions'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 SQL 表达式进行 ORM 批量插入'
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量插入功能支持添加一组固定的参数，其中可以包括要应用于每个目标行的 SQL 表达式。为此，将使用 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法，传递一个参数字典，该字典将应用于所有行，与通常的批量调用形式结合使用，方法是在调用
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    时包含包含单独行值的参数字典列表。
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定包括“timestamp”列的 ORM 映射：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要插入一系列具有唯一 `message` 字段的 `LogRecord` 元素，但是我们希望将 SQL 函数 `now()` 应用于所有行，我们可以在
    [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 中传递 `timestamp`，然后使用“批量”模式传递附加记录：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 通过每行 SQL 表达式进行 ORM 批量插入'
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法本身直接支持参数字典列表。当以这种方式使用 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造时，如果没有将参数字典列表传递给 [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute.params") 参数，将不会使用批量 ORM 插入模式，而是将 INSERT 语句按原样呈现并精确调用一次。这种操作模式可能在按行基础上传递
    SQL 表达式的情况下非常有用，并且在使用 ORM 进行“upsert”语句时也会使用，后文会在本章节中的 [ORM “upsert” Statements](#orm-queryguide-upsert)
    进行详细记录。'
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是嵌入每行 SQL 表达式的 INSERT 的人为示例，同时也演示了这种形式中的 [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上面未使用批量 ORM 插入模式，因此以下特性不可用：
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[联接表继承](#orm-queryguide-insert-joined-table-inheritance)或其他多表映射，因为那将需要多个
    INSERT 语句。
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[异构参数集](#orm-queryguide-insert-heterogeneous-params) - VALUES 集合中的每个元素必须具有相同的列。
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提供诸如 [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    所提供的批处理等核心级别的规模优化；语句将需要确保参数总数不超过由后端数据库施加的限制。
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 出于上述原因，通常不建议在ORM INSERT语句中使用多个参数集合[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")，除非有明确的理由，即要么使用了“upsert”，要么需要在每个参数集合中嵌入每行SQL表达式。
- en: See also
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  #### ORM Bulk Insert with
    Per Row SQL Expressions'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM“upsert”语句](#orm-queryguide-upsert)  #### 使用每行SQL表达式进行ORM批量插入'
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法本身直接支持参数字典列表。当以这种方式使用[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造时，在不将任何参数字典列表传递给[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数的情况下，将不使用批量ORM插入模式，而是完全按照给定的方式呈现INSERT语句，并且仅调用一次。这种操作模式对于在每行基础上传递SQL表达式的情况可能很有用，并且在使用ORM时使用“upsert”语句时也会使用，后文将在本章的[ORM“upsert”语句](#orm-queryguide-upsert)中进行说明。'
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个虚构的示例，演示了嵌入每行SQL表达式的INSERT，并以这种形式演示了[`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述未使用批量ORM插入模式，因此不存在以下功能：
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连接表继承](#orm-queryguide-insert-joined-table-inheritance)或其他多表映射不受支持，因为这将需要多个INSERT语句。'
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持异构参数集合 - VALUES集合中的每个元素必须具有相同的列。
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可用核心级别的缩放优化，例如[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)提供的批处理；语句需要确保参数的总数不超过由支持数据库施加的限制。
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 出于上述原因，通常不建议在ORM INSERT语句中使用多个参数集合[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")，除非有明确的理由，即要么使用了“upsert”，要么需要在每个参数集合中嵌入每行SQL表达式。
- en: See also
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert”语句](#orm-queryguide-upsert)'
- en: '### Legacy Session Bulk INSERT Methods'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '### 旧版会话批量插入方法'
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")包括用于执行“批量”INSERT和UPDATE语句的传统方法。这些方法与
    SQLAlchemy 2.0 版本的这些特性共享实现，描述在[ORM 批量 INSERT 语句](#orm-queryguide-bulk-insert)和[ORM
    主键批量 UPDATE](#orm-queryguide-bulk-update)中，但缺少许多功能，特别是缺少对 RETURNING 的支持以及对会话同步的支持。'
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")的代码示例可以像下面这样移植代码，从这个映射示例开始：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The above is expressed using the new API as:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是使用新 API 表达的：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[旧版会话批量 UPDATE 方法](#orm-queryguide-legacy-bulk-update)'
- en: '### ORM “upsert” Statements'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM “upsert” 语句'
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的部分后端可能包含特定于方言的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造，此外还具有执行“upserts”或将参数集中的现有行转换为近似 UPDATE 语句的能力。通过“现有行”，这可能意味着具有相同主键值的行，或者可能是指其他被认为是唯一的行中的索引列；这取决于正在使用的后端的功能。
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 包含的方言特定“upsert”API功能的方言包括：
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite - 使用[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")，在[INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)有详细说明。
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL - 使用[`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert")，在[INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)有详细说明。
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL/MariaDB - 使用[`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert")，在[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)有详细说明。
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该查看上述部分了解这些对象的正确构造背景；特别是，“upsert”方法通常需要引用原始语句，因此语句通常是分两步构建的。
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端，如在[外部方言](../../dialects/index.html)中提到的那些，也可能具有类似的构造。
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLAlchemy还没有与后端无关的upsert构造，但以上的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")变体仍然与ORM兼容，因为它们可以像文档中记录的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造本身一样使用，即通过在[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法中嵌入要插入的行。在下面的示例中，使用SQLite [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert")函数生成一个包含“ON CONFLICT DO UPDATE”支持的[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")构造。然后，将语句传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，它会按照正常流程进行，额外的特点是传递给[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的参数字典被解释为ORM映射的属性键，而不是列名。
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用 RETURNING 与 upsert 语句'
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLAlchemy ORM的角度来看，upsert语句看起来像是常规的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造，其中包括[`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")与upsert语句的工作方式相同，就像在[ORM批量插入与每行SQL表达式](#orm-queryguide-insert-values)中演示的那样，因此可以传递任何列表达式或相关的ORM实体类。继续上一节中的示例：
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用 RETURNING 语句来返回每个被插入或合并的行的 ORM 对象。该示例还添加了对 [现有数据的填充](api.html#orm-queryguide-populate-existing)
    执行选项的使用。该选项指示对于已经存在于 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的行，应该使用新行的数据**刷新**`User`对象。对于纯粹的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句，此选项不重要，因为每个生成的行都是全新的主键标识。但是，当 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 还包括“upsert”选项时，它可能也会产生已经存在的行的结果，因此可能已经在 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的[身份映射](../../glossary.html#term-identity-map)中表示了主键标识。
- en: See also
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  #### Using
    RETURNING with upsert statements'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 RETURNING 的 upsert 语句](api.html#orm-queryguide-populate-existing)  ####
    使用 RETURNING 语句的合并插入'
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy ORM 的角度来看，upsert 语句看起来像是常规的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，这包括 [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 在与示例 [每行 SQL 表达式的 ORM 批量插入](#orm-queryguide-insert-values)
    中展示的方式上与 upsert 语句一样工作，因此可以传递任何列表达式或相关的 ORM 实体类。继续上一节中的示例：
- en: '[PRE57]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用 RETURNING 语句来返回每个被插入或合并的行的 ORM 对象。该示例还添加了对 [现有数据的填充](api.html#orm-queryguide-populate-existing)
    执行选项的使用。该选项指示对于已经存在于 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的行，应该使用新行的数据**刷新**`User`对象。对于纯粹的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句，此选项不重要，因为每个生成的行都是全新的主键标识。但是，当 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 还包括“upsert”选项时，它可能也会产生已经存在的行的结果，因此可能已经在 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象的[身份映射](../../glossary.html#term-identity-map)中表示了主键标识。
- en: See also
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[填充现有](api.html#orm-queryguide-populate-existing)'
- en: '## ORM Bulk UPDATE by Primary Key'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '## 根据主键进行 ORM 批量更新'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    构造可以与 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 一起使用，类似于描述的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句在 [ORM 批量插入语句](#orm-queryguide-bulk-insert)
    中的使用方式，传递许多参数字典的列表，每个字典代表一个对应于单个主键值的单独行。这种用法不应与更常见的使用 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 语句与 ORM 一起使用的方式混淆，使用显式的 WHERE 子句，该方式在 [ORM
    更新和删除自定义 WHERE 条件](#orm-queryguide-update-delete-where) 中有记录。'
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 UPDATE 的“批量”版本，将根据 ORM 类制作一个 [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 构造，并传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法；生成的 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 对象应该**没有值，通常也没有 WHERE 条件**，也就是说，不使用 [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") 方法，通常也不使用 [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")，但在需要添加额外过滤条件的不寻常情况下可能会使用。
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 传递包含完整主键值的参数字典列表以及 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 构造将调用**根据主键进行批量更新模式**的语句，生成适当的 WHERE 条件以匹配每个主键的行，并使用
    [executemany](../../glossary.html#term-executemany) 对 UPDATE 语句运行每个参数集：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个参数字典**必须包含每个记录的完整主键**，否则会引发错误。
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 像批量插入功能一样，这里也支持异构参数列表，其中参数将被分组为更新运行的子批次。
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.11版本中更改：可以使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")方法添加额外的WHERE条件与[ORM按主键批量更新](#orm-queryguide-bulk-update)相结合。但是，此条件始终是额外添加的，这包括主键值。
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用“按主键批量更新”功能时，不支持RETURNING功能；多个参数字典列表必须使用DBAPI的[executemany](../../glossary.html#term-executemany)，通常情况下不支持结果行。
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中更改：将[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")构造传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法，以及参数字典列表，现在会调用“批量更新”，这与传统的[`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法使用相同的功能。这是与1.x系列不同的行为更改，1.x系列中的[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")只支持显式的WHERE条件和内联VALUES。
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '### 禁用多参数集UPDATE语句的按主键批量ORM更新'
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下条件时，自动使用ORM按主键批量更新功能：
- en: the UPDATE statement given is against an ORM entity
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的UPDATE语句针对的是ORM实体。
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行语句，而不是核心[`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的参数是**字典列表**。
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不使用“ORM按主键批量更新”功能的情况下调用UPDATE语句，请直接针对[`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")使用[`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")方法来获取当前事务的[`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[按行ORM按主键批量更新需要记录包含主键值](../../errors.html#error-bupq)  ### 按主键批量更新联合表继承'
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有联合表继承的映射时，ORM批量更新与ORM批量插入具有类似的行为；如在[Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance)中所述，批量UPDATE操作将为映射中表示的每个表发出UPDATE语句，其中给定的参数包括要更新的值（不受影响的表将被跳过）。
- en: 'Example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE60]  ### Legacy Session Bulk UPDATE Methods'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE60]  ### 旧版Session批量更新方法'
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[旧版Session批量插入方法](#orm-queryguide-legacy-bulk-insert)中讨论的那样，[`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法是批量更新的旧版形式，ORM在解释给定带有主键参数的[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")语句时内部使用；但是，当使用旧版时，不包括诸如会话同步支持等功能。
- en: 'The example below:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Is expressed using the new API as:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新API表示为：
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: See also
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ###
    Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[旧版Session批量插入方法](#orm-queryguide-legacy-bulk-insert)  ### 禁用UPDATE语句的多参数集的基于主键的批量ORM更新'
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下条件时，会自动使用基于主键的ORM批量更新功能，该功能对每个包含主键值的记录运行UPDATE语句，并包括每个主键值的WHERE条件：
- en: the UPDATE statement given is against an ORM entity
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的UPDATE语句针对一个ORM实体
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行该语句，而不是使用核心[`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的参数是**字典列表**。
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用UPDATE语句而不使用“基于主键的ORM批量更新”，直接使用[`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")方法针对当前事务获取[`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")：
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[基于主键的逐行ORM批量更新要求记录包含主键值](../../errors.html#error-bupq)'
- en: '### Bulk UPDATE by Primary Key for Joined Table Inheritance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基于主键的联合表继承批量更新'
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 批量更新在使用具有联合表继承的映射时与 ORM 批量插入具有相似的行为；正如[联合表继承的批量插入](#orm-queryguide-insert-joined-table-inheritance)中所描述的，批量更新操作将为映射中表示的每个表发出一个更新语句，其中给定的参数包括要更新的值（未受影响的表将被跳过）。
- en: 'Example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '### Legacy Session Bulk UPDATE Methods'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '### 旧版会话批量更新方法'
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如[旧版会话批量插入方法](#orm-queryguide-legacy-bulk-insert)中所讨论的，[`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") 方法是批量更新的旧式形式，当给定主键参数时，ORM 在解释 [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 语句时内部使用它；然而，当使用旧版时，诸如会话同步支持之类的功能将不包括在内。
- en: 'The example below:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例：
- en: '[PRE65]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Is expressed using the new API as:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新 API 表达为：
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: See also
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[旧版会话批量插入方法](#orm-queryguide-legacy-bulk-insert)'
- en: '## ORM UPDATE and DELETE with Custom WHERE Criteria'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用自定义 WHERE 条件的 ORM 更新和删除'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义 WHERE 条件构建 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 和 [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 构造时（即使用 [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") 和 [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") 方法），可以通过将它们传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 在 ORM 上下文中调用它们，而不使用 [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") 参数。对于 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")，应该使用 [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") 传递要更新的值。
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用方式与之前描述的[ORM 按主键批量更新](#orm-queryguide-bulk-update)中的功能不同，ORM 使用给定的 WHERE
    子句如所示，而不是将 WHERE 子句修复为按主键。这意味着单个 UPDATE 或 DELETE 语句可以一次性影响许多行。
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，下面发出了一个更新，影响了多行的“fullname”字段
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DELETE，基于条件删除行的示例：
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Warning
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读以下部分 [Important Notes and Caveats for ORM-Enabled Update and Delete](#orm-queryguide-update-delete-caveats)，了解关于
    ORM 启用的 UPDATE 和 DELETE 功能与 ORM [工作单元](../../glossary.html#term-unit-of-work)
    功能的功能差异的重要说明，例如使用 [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 方法删除单个对象。
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关于 ORM 启用的更新和删除的重要说明和注意事项'
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 启用的 UPDATE 和 DELETE 功能绕过 ORM [工作单元](../../glossary.html#term-unit-of-work)
    自动化，以便能够发出一条匹配多行的单个 UPDATE 或 DELETE 语句，而不会增加复杂性。
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作不提供 Python 中的关系级联 - 假定对于需要它的任何外键引用已配置了 ON UPDATE CASCADE 和/或 ON DELETE CASCADE，否则如果正在执行外键引用，则数据库可能会发出完整性违规。请参阅
    [Using foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    中的说明，了解一些示例。
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 UPDATE 或 DELETE 之后，受到与相关表上的 ON UPDATE CASCADE 或 ON DELETE CASCADE 相关的影响的[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的依赖对象，特别是引用现在已被删除的行的对象，可能仍然引用这些对象。一旦[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期，通常发生在 [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或可以通过使用 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 强制进行。
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 ORM 的 UPDATE 和 DELETE 操作不会自动处理连接表继承。请参阅 [UPDATE/DELETE with Custom WHERE
    Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    部分，了解如何处理连接继承映射。
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将多态标识限制为单表继承映射的特定子类，**自动包含了** WHERE 条件。这仅适用于没有自己的表的子类映射。
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria "sqlalchemy.orm.with_loader_criteria")
    选项 **受支持** ，可用于 ORM 更新和删除操作；此处的条件将添加到正在发出的 UPDATE 或 DELETE 语句的条件中，并在“同步”过程中考虑到。'
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使用事件处理程序拦截启用ORM的UPDATE和DELETE操作，请使用[`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。### 选择同步策略
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合使用[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")与启用ORM的执行时，使用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，还会出现额外的ORM特定功能，该功能将**同步**语句更改的状态与当前存在于[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[身份映射](../../glossary.html#term-identity-map)中的对象的状态。我们所说的“同步”是指，更新的属性将使用新值刷新，或者至少会[过期](../../glossary.html#term-expired)，以便它们在下一次访问时重新填充其新值，并且删除的对象将移动到[已删除](../../glossary.html#term-deleted)状态。
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同步是可控的，作为“同步策略”，传递为字符串ORM执行选项，通常使用[`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute")字典：
- en: '[PRE69]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 执行选项也可以与语句本身捆绑在一起，使用[`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options")方法：
- en: '[PRE70]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`synchronize_session`的以下值：
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''auto''` - 这是默认值。对于支持RETURNING的后端将使用`''fetch''`策略，这包括除MySQL之外的所有SQLAlchemy本机驱动程序。如果不支持RETURNING，则将改用`''evaluate''`策略。'
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''fetch''` - 通过在执行 UPDATE 或 DELETE 之前执行 SELECT 或通过使用数据库支持的 RETURNING 来检索受影响行的主键标识，以便可以刷新受操作影响的内存中的对象（更新）或从
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中清除（删除）。即使给定的 [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 或 [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 构造显式指定了使用 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 的实体或列，也可以使用此同步策略。'
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：在使用 ORM 启用的 UPDATE 和 DELETE 与 WHERE 条件时，可以将显式的 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 与 `'fetch'` 同步策略结合使用。实际语句将包含
    `'fetch'` 策略所需的列与请求的列之间的并集。
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''evaluate''` - 这表示在 Python 中评估 UPDATE 或 DELETE 语句中给定的 WHERE 条件，以定位 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的匹配对象。该方法不会增加任何 SQL 往返到操作中，在没有 RETURNING 支持的情况下，可能更有效。对于具有复杂条件的
    UPDATE 或 DELETE 语句，`''evaluate''` 策略可能无法在 Python 中评估表达式并将引发错误。如果发生这种情况，请改用操作的
    `''fetch''` 策略。'
- en: Tip
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 SQL 表达式使用 [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 或 [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") 功能使用自定义运算符，则可以使用 [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") 参数指示将由 `"evaluate"` 同步策略使用的 Python 函数。
- en: New in version 2.0.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始新增。
- en: Warning
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果要在已过期的 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    上运行 UPDATE 操作，则应避免使用 `"evaluate"` 策略，因为它必然需要刷新对象以测试它们是否符合给定的 WHERE 条件，这将为每个对象发出一个
    SELECT。在这种情况下，特别是如果后端支持 RETURNING，则应首选 `"fetch"` 策略。
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False` - 不同步会话。此选项对于不支持 RETURNING 的后端可能很有用，其中无法使用 `"evaluate"` 策略。在这种情况下，[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中对象的状态不变，不会自动与生成的 UPDATE 或 DELETE 语句相对应，如果存在通常与匹配的行相对应的对象。
    ### 使用 RETURNING 进行 UPDATE/DELETE 和自定义 WHERE 条件'
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法与启用了 ORM 的带有 WHERE 条件的 UPDATE
    和 DELETE 完全兼容。可以指定完整的 ORM 对象和/或列用于 RETURNING：'
- en: '[PRE71]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对 RETURNING 的支持也与 `fetch` 同步策略兼容，该策略也使用 RETURNING。ORM 将适当地组织 RETURNING 中的列，以便同步进行，以及返回的[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")将按请求的顺序包含请求的实体和 SQL 列。
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '版本 2.0 中的新功能：[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 可用于启用 ORM 的 UPDATE 和 DELETE，同时保留与
    `fetch` 同步策略完全兼容。 ### 使用自定义 WHERE 条件进行联接表继承的 UPDATE/DELETE'
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与[基于主键的 ORM 批量 UPDATE](#orm-queryguide-bulk-update)不同，带有 WHERE 条件的 UPDATE/DELETE
    功能在每次调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时仅生成单个 UPDATE 或 DELETE 语句。这意味着当运行对多表映射进行`update()`或`delete()`操作时，例如联接表继承映射中的子类时，语句必须符合后端当前的能力，这可能包括后端不支持涉及多个表的
    UPDATE 或 DELETE 语句，或者对此仅有限支持。这意味着对于诸如联接继承子类之类的映射，带有 WHERE 条件的 ORM 版本 UPDATE/DELETE
    功能只能在一定程度上或根本不能使用，具体取决于具体情况。
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 发出联合表子类的多行UPDATE语句的最直接方法是仅引用子表。这意味着[`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 构造应该仅引用子类表本地的属性，如下例所示：
- en: '[PRE72]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述形式，一个简单的引用基本表以定位将在任何SQL后端上工作的行的方法是使用子查询：
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持UPDATE…FROM的后端，子查询可以作为额外的普通WHERE条件来陈述，但是两个表之间的条件必须以某种方式明确陈述：
- en: '[PRE74]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DELETE，预期基表和子表中的行将同时被DELETE。要删除多行联合继承对象，**而不使用**级联外键，请分别对每个表发出DELETE：
- en: '[PRE75]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，应该**优先选择**常规的[unit of work](../../glossary.html#term-unit-of-work)流程来更新和删除联合继承和其他多表映射的行，除非有使用自定义WHERE条件的性能原因。
- en: Legacy Query Methods
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧版查询方法
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 启用ORM的UPDATE/DELETE与WHERE功能最初是作为现在已过时的[`Query`](query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象的一部分，出现在[`Query.update()`](query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法中。这些方法仍然可用，并且提供与[ORM UPDATE和DELETE与自定义WHERE条件](#orm-queryguide-update-delete-where)中描述的相同功能的子集。主要区别在于旧版方法不提供显式的RETURNING支持。
- en: See also
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM-启用的更新和删除的重要注意事项和警告'
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 启用ORM的UPDATE和DELETE功能绕过ORM的[unit of work](../../glossary.html#term-unit-of-work)自动化，而是支持发出一条单独的UPDATE或DELETE语句，一次匹配多行，而不复杂。
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些操作不提供Python中关系的级联 - 假设对于需要的任何外键引用配置了ON UPDATE CASCADE和/或ON DELETE CASCADE，否则如果正在强制执行外键引用，则数据库可能会发出完整性违规。请参阅[使用ORM关系的外键ON
    DELETE级联](../cascades.html#passive-deletes)中的说明以获取一些示例。
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UPDATE或DELETE之后，[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的依赖对象，受到相关表上的ON
    UPDATE CASCADE或ON DELETE CASCADE的影响，特别是那些引用现已被删除的行的对象，可能仍然引用这些对象。一旦[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期，这个问题就会得到解决，通常发生在[`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时，或者可以通过使用[`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")来强制实现。
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用ORM的UPDATE和DELETE操作不会自动处理连接表继承。请参阅[UPDATE/DELETE with Custom WHERE Criteria
    for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)部分，了解如何处理连接继承映射。
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了限制多态标识仅适用于单表继承映射中的特定子类，**WHERE条件会自动包含**。这仅适用于没有自己的表的子类映射器。
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria "sqlalchemy.orm.with_loader_criteria")选项**支持**ORM更新和删除操作；这里的条件将被添加到正在发出的UPDATE或DELETE语句的条件中，并在“同步”过程中考虑到这些条件。'
- en: In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要拦截ORM启用的UPDATE和DELETE操作以使用事件处理程序，请使用[`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。
- en: '### Selecting a Synchronization Strategy'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择同步策略'
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")与ORM启用的执行结合使用时，还存在额外的ORM特定功能，将会**同步**语句所更改的状态与当前存在于[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[标识映射](../../glossary.html#term-identity-map)中的对象状态。通过“同步”，我们指的是UPDATE的属性将使用新值刷新，或者至少[过期](../../glossary.html#term-expired)，以便在下次访问时重新填充为新值，而DELETE的对象将移至[删除](../../glossary.html#term-deleted)状态。
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此同步可通过“同步策略”来控制，该策略作为字符串 ORM 执行选项传递，通常通过使用 [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") 字典：
- en: '[PRE76]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 执行选项也可以与语句本身捆绑在一起，使用 [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") 方法：
- en: '[PRE77]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下值作为 `synchronize_session`：
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''auto''` - 这是默认设置。在支持 RETURNING 的后端上将使用 `''fetch''` 策略，这包括除 MySQL 外的所有 SQLAlchemy
    本机驱动程序。如果不支持 RETURNING，则将使用 `''evaluate''` 策略。'
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''fetch''` - 通过在执行 UPDATE 或 DELETE 之前执行 SELECT 或使用 RETURNING（如果数据库支持），检索受影响行的主键标识，以便可以使用新值刷新受操作影响的内存对象（更新），或者从
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中清除（删除）。即使给定的 [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 或 [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 构造明确指定了使用 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 的实体或列，也可以使用此同步策略。'
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：当使用启用 ORM 的 UPDATE 和 DELETE 与 WHERE 条件时，可以将显式的 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 与 `'fetch'` 同步策略结合使用。实际语句将包含
    `'fetch'` 策略所需的列和请求的列之间的并集。
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''evaluate''` - 这表示在 Python 中评估 UPDATE 或 DELETE 语句中给定的 WHERE 条件，以在 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中定位匹配的对象。此方法不会为操作添加任何 SQL 往返，并且在没有 RETURNING 支持的情况下，可能更有效。对于具有复杂条件的
    UPDATE 或 DELETE 语句，`''evaluate''` 策略可能无法在 Python 中评估表达式，并将引发错误。如果发生这种情况，请改为使用
    `''fetch''` 策略执行操作。'
- en: Tip
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 SQL 表达式使用 [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 或 [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") 特性使用自定义运算符，则可以使用 [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") 参数指示一个 Python 函数，该函数将由 `"evaluate"`
    同步策略使用。
- en: New in version 2.0.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版本中新增。
- en: Warning
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果要在具有许多已过期对象的 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    上运行 UPDATE 操作，则应避免使用 `"evaluate"` 策略，因为它必然需要刷新对象以便根据给定的 WHERE 条件测试它们，这将为每个对象发出一个
    SELECT。在这种情况下，特别是如果后端支持 RETURNING，则应首选 `"fetch"` 策略。
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False` - 不同步会话。该选项对于不支持 RETURNING 的后端可能很有用，其中无法使用 `"evaluate"` 策略。在这种情况下，[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的对象状态保持不变，并且不会自动与发出的 UPDATE 或 DELETE 语句对应，如果存在通常会与匹配行对应的对象。'
- en: '### Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 RETURNING 进行 UPDATE/DELETE 和自定义 WHERE 条件'
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法与启用 ORM 的带有 WHERE 条件的 UPDATE
    和 DELETE 完全兼容。可以指定完整的 ORM 对象和/或列来进行 RETURNING：'
- en: '[PRE78]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: RETURNING 的支持也与 `fetch` 同步策略兼容，该策略也使用 RETURNING。ORM 将适当地组织 RETURNING 中的列，以使同步进行得很好，并且返回的
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    将按请求的顺序包含请求的实体和 SQL 列。
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本中新增：[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 可用于启用 ORM 的 UPDATE 和 DELETE，同时仍保留与
    `fetch` 同步策略的完全兼容性。
- en: '### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用于联接表继承的 UPDATE/DELETE 自定义 WHERE 条件'
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 与[ORM Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update)不同，具有WHERE条件的UPDATE/DELETE功能在每次调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时仅发出单个UPDATE或DELETE语句。这意味着当针对多表映射（如联接表继承映射中的子类）运行[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")语句时，语句必须符合后端的当前能力，这可能包括后端不支持引用多个表的UPDATE或DELETE语句，或者仅对此提供有限的支持。这意味着对于诸如联接继承子类之类的映射，ORM版本的具有WHERE条件的UPDATE/DELETE功能仅能在有限程度上或根据具体情况根本无法使用。
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是为联接表子类发出多行更新语句，只需引用子表即可。这意味着[`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造应仅引用子类表本地的属性，如下例所示：
- en: '[PRE79]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述形式，一种简单的引用基表以定位行的方法，可以在任何SQL后端上工作，即使用子查询：
- en: '[PRE80]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持UPDATE…FROM的后端，子查询可以改为额外的纯WHERE条件，但是两个表之间的条件必须以某种方式明确说明：
- en: '[PRE81]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DELETE操作，预期基表和子表中的行将同时被删除。要删除多行联接继承对象而**不使用**级联外键，需分别为每个表发出DELETE语句：
- en: '[PRE82]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，通常应**优先选择**普通的[工作单元](../../glossary.html#term-unit-of-work)流程来更新和删除联接继承和其他多表映射的行，除非使用自定义的WHERE条件有性能上的理由。
- en: Legacy Query Methods
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧式查询方法
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 原始[`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象的ORM启用的UPDATE/DELETE
    with WHERE功能最初是[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")和[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")方法的一部分。这些方法仍然可用，并且提供与[ORM UPDATE and DELETE with
    Custom WHERE Criteria](#orm-queryguide-update-delete-where)描述的相同功能的子集。主要区别在于旧式方法不支持显式的RETURNING支持。
- en: See also
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
