- en: ORM-Enabled INSERT, UPDATE, and DELETE statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM-启用的INSERT、UPDATE和DELETE语句
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/dml.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This section makes use of ORM mappings first illustrated in the [SQLAlchemy
    Unified Tutorial](../../tutorial/index.html#unified-tutorial), shown in the section
    [Declaring Mapped Classes](../../tutorial/metadata.html#tutorial-declaring-mapped-classes),
    as well as inheritance mappings shown in the section [Mapping Class Inheritance
    Hierarchies](../inheritance.html).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节利用了首次在[SQLAlchemy 统一教程](../../tutorial/index.html#unified-tutorial)中展示的ORM映射，如[声明映射类](../../tutorial/metadata.html#tutorial-declaring-mapped-classes)一节所示，以及[映射类继承层次结构](../inheritance.html)一节中展示的继承映射。
- en: '[View the ORM setup for this page](_dml_setup.html).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看此页面的ORM设置](_dml_setup.html)。'
- en: The [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, in addition to handling ORM-enabled
    [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    objects, can also accommodate ORM-enabled [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") objects, in various ways which are each used
    to INSERT, UPDATE, or DELETE many database rows at once. There is also dialect-specific
    support for ORM-enabled “upserts”, which are INSERT statements that automatically
    make use of UPDATE for rows that already exist.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理ORM启用的[`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select)对象外，[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法还可以容纳ORM启用的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert)、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update)和[`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete)对象，它们分别以各种方式用于一次性插入、更新或删除多个数据库行。此外，还有特定于方言的支持ORM启用的“upserts”，这是一种自动使用UPDATE来处理已经存在的行的INSERT语句。
- en: 'The following table summarizes the calling forms that are discussed in this
    document:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了本文讨论的调用形式：
- en: '| ORM Use Case | DML Construct Used | Data is passed using … | Supports RETURNING?
    | Supports Multi-Table Mappings? |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| ORM用例 | 使用的DML构造 | 使用以下方式传递数据 | 是否支持RETURNING？ | 是否支持多表映射？ |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [yes](#orm-queryguide-bulk-insert-returning)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [ORM批量插入语句](#orm-queryguide-bulk-insert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表到[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [是](#orm-queryguide-bulk-insert-returning)
    | [是](#orm-queryguide-insert-joined-table-inheritance) |'
- en: '| [ORM Bulk Insert with SQL Expressions](#orm-queryguide-bulk-insert-w-sql)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-bulk-insert-w-sql)
    | [yes](#orm-queryguide-insert-joined-table-inheritance) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| [使用SQL表达式的ORM批量插入](#orm-queryguide-bulk-insert-w-sql) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | [是](#orm-queryguide-bulk-insert-w-sql) | [是](#orm-queryguide-insert-joined-table-inheritance)
    |'
- en: '| [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values)
    | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-insert-values)
    | no |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| [使用每行 SQL 表达式进行 ORM 批量插入](#orm-queryguide-insert-values) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [是](#orm-queryguide-insert-values)
    | 否 |'
- en: '| [ORM “upsert” Statements](#orm-queryguide-upsert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | List of dictionaries to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [yes](#orm-queryguide-upsert-returning)
    | no |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| [ORM “upsert” 语句](#orm-queryguide-upsert) | [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") | 字典列表[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") | [是](#orm-queryguide-upsert-returning)
    | 否 |'
- en: '| [ORM Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") | List of dictionaries to [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | no | [yes](#orm-queryguide-bulk-update-joined-inh)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| [通过主键进行 ORM 批量更新](#orm-queryguide-bulk-update) | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") | 字典列表[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") | 否 | [是](#orm-queryguide-bulk-update-joined-inh)
    |'
- en: '| [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where)
    | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    | keywords to [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") | [yes](#orm-queryguide-update-delete-where-returning)
    | [partial, with manual steps](#orm-queryguide-update-delete-joined-inh) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| [使用自定义 WHERE 条件的 ORM UPDATE 和 DELETE](#orm-queryguide-update-delete-where)
    | [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    | 关键字[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") | [是](#orm-queryguide-update-delete-where-returning)
    | [部分，需要手动步骤](#orm-queryguide-update-delete-joined-inh) |'
- en: '## ORM Bulk INSERT Statements'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '## ORM 批量插入语句'
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")构造可以根据
    ORM 类构建，并传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法。发送到[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数的参数字典列表，与[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")对象本身分开，将为语句调用**批量插入模式**，这基本上意味着该操作将尽可能地优化多行：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参数字典包含键/值对，这些对应于 ORM 映射属性，与映射的[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或[`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")声明以及[复合](../composites.html#mapper-composite)声明对齐，如果这两个名称恰好不同，则键应与**ORM
    映射属性名称**匹配，而不是实际数据库列名称。
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '在 2.0 版本中更改：将 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法现在会调用“批量插入”，这使用了与传统的 [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 方法相同的功能。这是与 1.x 系列相比的行为变更，在那里 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 将以 Core 为中心的方式解释，使用列名作为值键；现在接受 ORM 属性键。通过将执行选项
    `{"dml_strategy": "raw"}`传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 的 [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") 参数，可以使用 Core 风格的功能。'
- en: '### Getting new objects with RETURNING'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 RETURNING 获取新对象'
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 批量 ORM 插入功能支持选定后端的 INSERT..RETURNING，该功能可以返回一个[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，该对象可能会返回单个列以及对应于新生成记录的完全构造的 ORM 对象。INSERT..RETURNING
    需要使用支持 SQL RETURNING 语法以及支持带 RETURNING 的 [executemany](../../glossary.html#term-executemany)
    的后端；除了 MySQL（MariaDB 已包含在内）外，此功能适用于所有 [SQLAlchemy 包含的](../../dialects/index.html#included-dialects)
    后端。
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以运行与之前相同的语句，同时使用 [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") 方法，将完整的 `User` 实体作为我们希望返回的内容传递进去。
    [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")
    用于允许迭代 `User` 对象：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，渲染的 SQL 采用了由 SQLite 后端请求的[插入多个值](../../core/connections.html#engine-insertmanyvalues)功能所使用的形式，在这里，单个参数字典被嵌入到一个单个的
    INSERT 语句中，以便可以使用 RETURNING。
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：ORM [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在在 ORM 上下文中解释来自 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")、[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 甚至 [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 构造的 RETURNING 子句，这意味着可以传递一种混合的列表达式和 ORM 映射实体到
    [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 方法中，然后将以 ORM 结果从构造物如 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 中提供的方式传递，包括映射实体将以 ORM 映射对象的形式在结果中提供。还存在对 ORM
    加载器选项（如 [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")）的有限支持。
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将返回的记录与输入数据顺序相关联'
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带 RETURNING 的批量 INSERT 时，重要的是要注意，大多数数据库后端不提供返回的 RETURNING 记录的顺序的正式保证，包括不保证它们的顺序与输入记录的顺序相对应。对于需要确保
    RETURNING 记录能够与输入数据相关联的应用程序，可以指定额外的参数 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order")，这依赖于后端可能使用特殊的
    INSERT 形式来维护一个标记，该标记用于适当地重新排序返回的行，或者在某些情况下，例如在下面使用 SQLite 后端的示例中，该操作将逐行插入：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.10 新功能：添加了 [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order")，该功能在
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) 架构中实现。
- en: See also
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[将返回的行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - 介绍了确保输入数据和结果行之间对应关系的方法背景，而不会显著降低性能 ### 使用异构参数字典'
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入功能支持“异构”的参数字典列表，这基本上意味着“各个字典可以具有不同的键”。当检测到这种情况时，ORM将根据每个键集将参数字典分组，并相应地批处理到单独的INSERT语句中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，传递的五个参数字典被转换为三个INSERT语句，按照每个字典中特定的键集分组，同时仍保持行顺序，即`("name", "fullname",
    "species")`，`("name", "species")`，`("name","fullname", "species")`。### 在ORM批量INSERT语句中发送NULL值
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 批量ORM插入功能利用了遗留“批量”插入行为以及总体ORM工作单元中存在的行为，即包含NULL值的行使用不引用这些列的语句进行INSERT；这样做的理由是，包含服务器端INSERT默认值的后端和模式可能对NULL值与没有值的存在敏感，并且会产生预期的服务器端值。这种默认行为会将批量插入的批次分解为更多的行数较少的批次：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，四行的批量INSERT被分解成三个单独的语句，第二个语句重新格式化，不再引用包含`None`值的单个参数字典的NULL列。当数据集中的许多行包含随机NULL值时，这种默认行为可能是不希望的，因为它会导致“executemany”操作被分解为更多的较小操作；特别是当依赖于[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)来减少总语句数时，这可能会产生更大的性能影响。
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用对参数中的`None`值进行分批处理的操作，请传递执行选项`render_nulls=True`；这将导致所有参数字典被等效处理，假定每个字典中具有相同的键集：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，所有的参数字典都被发送到一个单独的INSERT批处理中，包括第三个参数字典中存在的`None`值。
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本2.0.23中：添加了`render_nulls`执行选项，该选项反映了遗留的[`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings")参数的行为。### 用于连接表继承的批量INSERT
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入建立在传统的[工作单元](../../glossary.html#term-unit-of-work)系统使用的内部系统之上，以发出INSERT语句。这意味着对于映射到多个表的ORM实体，通常是使用[联接表继承](../inheritance.html#joined-inheritance)进行映射的实体，批量插入操作将为映射表示的每个表发出一个INSERT语句，正确地将服务器生成的主键值传递给依赖于它们的表行。此处还支持RETURNING功能，ORM将为执行的每个INSERT语句接收[`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象，然后“水平拼接”它们，以便返回的行包括插入的所有列的值：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 加入继承映射的批量插入要求ORM在内部使用[`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning")参数，以便它可以将来自基表的RETURNING行的主键值与用于插入“子”表的参数集相关联，这就是为什么上面示例中的SQLite后端会透明地降级到使用非批量语句。有关此功能的背景信息，请参阅[将RETURNING行与参数集相关联](../../core/connections.html#engine-insertmanyvalues-returning-order)。###
    使用SQL表达式进行ORM批量插入
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ORM批量插入功能支持添加一组固定的参数，其中可能包括要应用于每个目标行的SQL表达式。为了实现这一点，结合使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法，传递一个将应用于所有行的参数字典，以及在调用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时包含包含单个行值的参数字典列表的常规批量调用形式。
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个包含“timestamp”列的ORM映射：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要插入一系列具有唯一`message`字段的`LogRecord`元素，但是我们希望对所有行应用SQL函数`now()`，我们可以在[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")中传递`timestamp`，然后使用“bulk”模式传递额外的记录：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用每行SQL表达式进行ORM批量插入'
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法本身直接接受参数字典列表。当以这种方式使用[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造时，如果没有将参数字典列表传递给[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数，则不使用批量ORM插入模式，而是将INSERT语句完全按照给定的方式呈现并且仅调用一次。这种操作模式既对于逐行传递SQL表达式的情况有用，也适用于使用ORM的“upsert”语句时，本章后面的文档中有介绍，位于[ORM
    “upsert” Statements](#orm-queryguide-upsert)。'
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个构造性的示例，其中嵌入了每行SQL表达式的INSERT，还以这种形式演示了[`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为上面没有使用批量ORM插入模式，所以下面的功能不可用：
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[联接表继承](#orm-queryguide-insert-joined-table-inheritance)或其他多表映射，因为这将需要多个INSERT语句。
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持[异构参数集](#orm-queryguide-insert-heterogeneous-params) - VALUES集合中的每个元素必须具有相同的列。
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提供核心级别的规模优化，例如[insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)提供的批处理;
    语句需要确保参数的总数不超过后端数据库施加的限制。
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，通常不建议在ORM INSERT语句中使用[`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")与多个参数集合，除非有明确的理由，即要么使用了“upsert”，要么需要在每个参数集合中嵌入每行SQL表达式。
- en: See also
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")包括用于执行“批量”INSERT和UPDATE语句的传统方法。
    这些方法与SQLAlchemy 2.0版本的这些功能共享实现，描述在[ORM批量INSERT语句](#orm-queryguide-bulk-insert)和[ORM按主键批量UPDATE](#orm-queryguide-bulk-update)，但缺少许多功能，即不支持RETURNING支持以及不支持会话同步。'
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 的代码，例如可以像下面这样移植代码，从这个映射示例开始：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The above is expressed using the new API as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容可使用新 API 表达为：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[传统会话批量更新方法](#orm-queryguide-legacy-bulk-update)  ### ORM “upsert” 语句'
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，选定的后端可能包括特定方言的[`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，这些构造还具有执行“upserts”或将参数集中的现有行转换为近似 UPDATE
    语句的能力。对于“现有行”，这可能意味着共享相同主键值的行，或者可能是指被视为唯一的行内其他索引列；这取决于正在使用的后端的能力。
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 包含有包含特定方言的“upsert” API 特性的方言，它们是：
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite - 使用[`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")，文档位于[INSERT…ON CONFLICT（Upsert）](../../dialects/sqlite.html#sqlite-on-conflict-insert)
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL - 使用[`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert")，文档位于[INSERT…ON CONFLICT（Upsert）](../../dialects/postgresql.html#postgresql-insert-on-conflict)
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL/MariaDB - 使用[`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert")，文档位于[INSERT…ON DUPLICATE KEY UPDATE（Upsert）](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该查阅上述章节以了解正确构建这些对象的背景；特别是，“upsert” 方法通常需要参考原始语句，因此通常语句会分为两个独立的步骤构建。
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端，如在 [外部方言](../../dialects/index.html) 中提到的后端，也可能具有类似的构造。
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQLAlchemy 还没有与后端无关的 upsert 构造，但上述的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 变体仍然与 ORM 兼容，因为它们可以像在 [ORM Bulk Insert with
    Per Row SQL Expressions](#orm-queryguide-insert-values) 中所记录的那样使用与 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造本身相同的方式，即通过在 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法中嵌入要插入的所需行。在下面的例子中，使用 SQLite 的 [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数来生成包含 “ON CONFLICT DO UPDATE” 支持的 [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 构造。然后，将语句传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，它会正常进行，但额外的特点是传递给 [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 的参数字典被解释为 ORM 映射的属性键，而不是列名：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用 RETURNING 与 upsert 语句'
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy ORM 的角度来看，upsert 语句看起来就像普通的 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，其中包括 [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 与 upsert 语句的使用方式与在 [ORM Bulk Insert
    with Per Row SQL Expressions](#orm-queryguide-insert-values) 中演示的方式相同，因此可以传递任何列表达式或相关的
    ORM 实体类。接着上一节的例子继续：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用 RETURNING 来返回由语句插入或更新的每一行的 ORM 对象。该示例还添加了 [现有数据填充](api.html#orm-queryguide-populate-existing)
    执行选项的使用。此选项表示 [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中已经存在的 `User` 对象应该使用新行的数据进行**刷新**。对于纯 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 语句来说，此选项并不重要，因为生成的每一行都是全新的主键标识。但是，当 [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 还包括“upsert”选项时，它也可能会产生来自已经存在的行的结果，因此可能已经在
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的[标识映射](../../glossary.html#term-identity-map)中具有主键标识。
- en: See also
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ## ORM Bulk
    UPDATE by Primary Key'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[现有数据填充](api.html#orm-queryguide-populate-existing)  ## 按主键进行ORM批量更新'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    构造可以与 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 以类似的方式使用，就像[ORM批量插入语句](#orm-queryguide-bulk-insert)中描述的使用
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    语句一样，传递一个参数字典列表，每个字典表示对应单个主键值的单个行。这种用法不应与在ORM中更常见的使用 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 语句的方式混淆，该方式使用显式的 WHERE 子句，在[ORM UPDATE and
    DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where)中有文档记录。'
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“批量”版本的UPDATE，通过ORM类构造一个[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")语句，并传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")方法；生成的[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")对象不应具有任何值，通常也不应具有WHERE条件，也就是说，不使用[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values")方法，通常也不使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")方法，但在不寻常的情况下可能会使用，以添加额外的过滤条件。
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")构造与包含完整主键值的参数字典列表一起传递将触发**主键批量UPDATE模式**，生成适当的WHERE条件以按主键匹配每一行，并使用[executemany](../../glossary.html#term-executemany)对UPDATE语句运行每个参数集：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个参数字典必须为每个记录包含完整的主键，否则将引发错误。
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与批量INSERT功能类似，这里也支持异构参数列表，其中参数将被分组为UPDATE运行的子批次。
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.11版本中更改：可以使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")方法将附加的WHERE条件与[ORM主键批量UPDATE](#orm-queryguide-bulk-update)组合使用以添加额外的条件。但是，此条件始终是附加到已经存在的包括主键值在内的WHERE条件之上的。
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“主键批量UPDATE”功能时，不支持RETURNING功能；多个参数字典的列表必然使用了DBAPI [executemany](../../glossary.html#term-executemany)，通常情况下，这种形式不支持结果行。
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版中更改：将 [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 结构传递给 [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 方法以及参数字典列表现在调用“批量更新”，这使用的是与旧版 [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") 方法相同的功能。这与 1.x 系列中的行为更改不同，在 1.x
    系列中，[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    仅受到显式 WHERE 条件和内联 VALUES 的支持。
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '### 禁用对具有多个参数集的 UPDATE 语句进行按主键的 ORM 批量更新'
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当：
- en: the UPDATE statement given is against an ORM entity
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出的 UPDATE 语句针对 ORM 实体
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    用于执行语句，而不是核心 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")'
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的参数是**字典列表**。
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用不使用“按主键的 ORM 批量更新”的 UPDATE 语句，直接使用 [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 方法对当前事务获取 [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 执行语句：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键每行的 ORM 批量更新要求记录包含主键值](../../errors.html#error-bupq)  ### 联合表继承的按主键批量更新'
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有联合表继承的映射时，ORM 批量更新的行为与使用映射进行批量插入时类似；如 [联合表继承的批量插入](#orm-queryguide-insert-joined-table-inheritance)
    中所述，批量更新操作将为映射中表示的每个表发出一条 UPDATE 语句，其中给定的参数包括要更新的值（不受影响的表将被跳过）。
- en: 'Example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '示例:'
- en: '[PRE16]  ### Legacy Session Bulk UPDATE Methods'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]  ### 旧版会话批量更新方法'
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如[传统会话批量INSERT方法](#orm-queryguide-legacy-bulk-insert)所讨论的，[`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法是批量更新的传统形式，当解释具有给定主键参数的[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")语句时，ORM在内部使用它；但是，当使用传统版本时，诸如会话同步支持之类的功能是不包括的。
- en: 'The example below:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Is expressed using the new API as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新API表示为：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ##
    ORM UPDATE and DELETE with Custom WHERE Criteria'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[传统会话批量INSERT方法](#orm-queryguide-legacy-bulk-insert)  ## 使用自定义WHERE条件的ORM UPDATE和DELETE'
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义WHERE条件构造[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")构造时（即使用[`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where")和[`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where")方法），可以通过将它们传递给[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")在ORM上下文中调用，而不使用[`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute")参数。对于[`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")，要更新的值应该使用[`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values")传递。
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此使用模式与之前描述的功能不同[ORM按主键批量更新](#orm-queryguide-bulk-update)，ORM使用给定的WHERE子句，而不是将WHERE子句固定为主键。这意味着单个UPDATE或DELETE语句可以一次性影响许多行。
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，下面发出一个UPDATE，影响多行的“fullname”字段
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DELETE，基于条件删除行的示例：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Warning
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读以下部分[ORM启用更新和删除的重要注意事项和注意事项](#orm-queryguide-update-delete-caveats)，以了解ORM启用的UPDATE和DELETE功能与ORM
    [工作单元](../../glossary.html#term-unit-of-work) 功能的功能不同，例如使用[`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法删除单个对象。
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM-启用的 Update 和 Delete 的重要说明和注意事项'
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 启用的 UPDATE 和 DELETE 功能绕过 ORM [工作单元](../../glossary.html#term-unit-of-work)
    自动化，以便能够发出一条匹配多行的 UPDATE 或 DELETE 语句，而不会复杂化。
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作不提供 Python 中的关系级联功能 - 假定任何需要的外键引用都已配置为 ON UPDATE CASCADE 和/或 ON DELETE CASCADE，否则如果强制执行外键引用，则数据库可能会发出完整性违规。有关一些示例，请参阅[使用外键
    ON DELETE cascade 与 ORM 关系](../cascades.html#passive-deletes)的注意事项。
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 UPDATE 或 DELETE 之后，[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中受到影响的依赖对象，特别是那些引用现在已被删除的行的 ON UPDATE CASCADE 或 ON DELETE
    CASCADE 的相关表的对象，可能仍然引用这些对象。此问题在 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 过期时解决，通常发生在 [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时或可以通过使用 [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 强制执行。
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 ORM 的 UPDATE 和 DELETE 不会自动处理连接的表继承。有关如何处理连接继承映射的说明，请参阅[具有自定义 WHERE 条件的连接表继承的
    UPDATE/DELETE](#orm-queryguide-update-delete-joined-inh)部分。
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将单表继承映射的多态标识限制为特定子类所需的 WHERE 条件**会自动包含**。这仅适用于没有自己表的子类映射器。
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 更新和删除操作支持 [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") 选项；此处的条件将被添加到正在发出的 UPDATE 或 DELETE 语句的条件中，并在“同步”过程中考虑。
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要拦截启用 ORM 的 UPDATE 和 DELETE 操作以使用事件处理程序，请使用[`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute")事件。  ### 选择同步策略'
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")与启用 ORM 执行一起使用[`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，将存在额外的 ORM 特定功能，该功能将**同步**语句更改的状态与当前存在于[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的[identity map](../../glossary.html#term-identity-map)中的对象的状态。通过“同步”，我们指的是更新的属性将使用新值刷新，或者至少[过期](../../glossary.html#term-expired)，以便在下次访问时重新填充其新值，并且删除的对象将移至[deleted](../../glossary.html#term-deleted)状态。
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此同步可通过“同步策略”控制，该策略作为字符串 ORM 执行选项传递，通常使用[`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") 字典：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行选项也可以与语句本身捆绑在一起，使用[`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") 方法：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下`synchronize_session`的值：
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''auto''` - 这是默认值。在支持 RETURNING 的后端上将使用 `''fetch''` 策略，这包括除 MySQL 外的所有 SQLAlchemy
    本机驱动程序。如果不支持 RETURNING，则将改为使用 `''evaluate''` 策略。'
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''fetch''` - 通过在执行 UPDATE 或 DELETE 之前执行 SELECT 或使用 RETURNING（如果数据库支持）来检索受影响行的主键标识，以便受操作影响的内存对象可以使用新值刷新（更新）或从[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中删除（删除）。即使给定的[`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")或[`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造明确指定实体或列使用[`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning")，也可以使用此同步策略。'
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")  ##
    ORM Bulk INSERT Statements'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`insert()`](../../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")
    construct can be constructed in terms of an ORM class and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. A list of parameter dictionaries sent
    to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, separate from the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object itself, will invoke **bulk INSERT mode**
    for the statement, which essentially means the operation will optimize as much
    as possible for many rows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The parameter dictionaries contain key/value pairs which may correspond to ORM
    mapped attributes that line up with mapped [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") declarations, as well as with [composite](../composites.html#mapper-composite)
    declarations. The keys should match the **ORM mapped attribute name** and **not**
    the actual database column name, if these two names happen to be different.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method now invokes a “bulk insert”, which makes
    use of the same functionality as the legacy [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") would be interpreted in a Core-centric way,
    using column names for value keys; ORM attribute keys are now accepted. Core-style
    functionality is available by passing the execution option `{"dml_strategy": "raw"}`
    to the [`Session.execution_options`](../session_api.html#sqlalchemy.orm.Session.params.execution_options
    "sqlalchemy.orm.Session") parameter of [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute").'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '### Getting new objects with RETURNING'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  ### Using Heterogeneous
    Parameter Dictionaries'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.  ### Sending NULL values in ORM
    bulk INSERT statements'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.  ### Bulk INSERT for
    Joined Table Inheritance'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).  ###
    ORM Bulk Insert with SQL Expressions'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  ### Legacy Session Bulk
    INSERT Methods'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The above is expressed using the new API as:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)  ###
    ORM “upsert” Statements'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  ### Getting
    new objects with RETURNING'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The bulk ORM insert feature supports INSERT..RETURNING for selected backends,
    which can return a [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that may yield individual columns back as well
    as fully constructed ORM objects corresponding to the newly generated records.
    INSERT..RETURNING requires the use of a backend that supports SQL RETURNING syntax
    as well as support for [executemany](../../glossary.html#term-executemany) with
    RETURNING; this feature is available with all [SQLAlchemy-included](../../dialects/index.html#included-dialects)
    backends with the exception of MySQL (MariaDB is included).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can run the same statement as before, adding use of the [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method, passing the full `User`
    entity as what we’d like to return. [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") is used to allow iteration of `User` objects:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the above example, the rendered SQL takes on the form used by the [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    feature as requested by the SQLite backend, where individual parameter dictionaries
    are inlined into a single INSERT statement so that RETURNING may be used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The ORM [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now interprets RETURNING clauses from [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), and even [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs in an ORM context, meaning a mixture
    of column expressions and ORM mapped entities may be passed to the [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method which will then be delivered
    in the way that ORM results are delivered from constructs such as [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), including that mapped entities will be delivered
    in the result as ORM mapped objects. Limited support for ORM loader options such
    as [`load_only()`](columns.html#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload "sqlalchemy.orm.selectinload")
    is also present.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '#### Correlating RETURNING records with input data order'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance  #### Correlating RETURNING
    records with input data order'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'When using bulk INSERT with RETURNING, it’s important to note that most database
    backends provide no formal guarantee of the order in which the records from RETURNING
    are returned, including that there is no guarantee that their order will correspond
    to that of the input records. For applications that need to ensure RETURNING records
    can be correlated with input data, the additional parameter [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") may be specified, which depending
    on backend may use special INSERT forms that maintain a token which is used to
    reorder the returned rows appropriately, or in some cases, such as in the example
    below using the SQLite backend, the operation will INSERT one row at a time:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'New in version 2.0.10: Added [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") which is implemented within the
    [insertmanyvalues](../../glossary.html#term-insertmanyvalues) architecture.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order)
    - background on approaches taken to guarantee correspondence between input data
    and result rows without significant loss of performance'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Heterogeneous Parameter Dictionaries'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM bulk insert feature supports lists of parameter dictionaries that are
    “heterogeneous”, which basically means “individual dictionaries can have different
    keys”. When this condition is detected, the ORM will break up the parameter dictionaries
    into groups corresponding to each set of keys and batch accordingly into separate
    INSERT statements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the above example, the five parameter dictionaries passed translated into
    three INSERT statements, grouped along the specific sets of keys in each dictionary
    while still maintaining row order, i.e. `("name", "fullname", "species")`, `("name",
    "species")`, `("name","fullname", "species")`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '### Sending NULL values in ORM bulk INSERT statements'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk ORM insert feature draws upon a behavior that is also present in the
    legacy “bulk” insert behavior, as well as in the ORM unit of work overall, which
    is that rows which contain NULL values are INSERTed using a statement that does
    not refer to those columns; the rationale here is so that backends and schemas
    which contain server-side INSERT defaults that may be sensitive to the presence
    of a NULL value vs. no value present will produce a server side value as expected.
    This default behavior has the effect of breaking up the bulk inserted batches
    into more batches of fewer rows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Above, the bulk INSERT of four rows is broken into three separate statements,
    the second statement reformatted to not refer to the NULL column for the single
    parameter dictionary that contains a `None` value. This default behavior may be
    undesirable when many rows in the dataset contain random NULL values, as it causes
    the “executemany” operation to be broken into a larger number of smaller operations;
    particularly when relying upon [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    to reduce the overall number of statements, this can have a bigger performance
    impact.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the handling of `None` values in the parameters into separate batches,
    pass the execution option `render_nulls=True`; this will cause all parameter dictionaries
    to be treated equivalently, assuming the same set of keys in each dictionary:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Above, all parameter dictionaries are sent in a single INSERT batch, including
    the `None` value present in the third parameter dictionary.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the `render_nulls` execution option which mirrors
    the behavior of the legacy [`Session.bulk_insert_mappings.render_nulls`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings.params.render_nulls
    "sqlalchemy.orm.Session.bulk_insert_mappings") parameter.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '### Bulk INSERT for Joined Table Inheritance'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM bulk insert builds upon the internal system that is used by the traditional
    [unit of work](../../glossary.html#term-unit-of-work) system in order to emit
    INSERT statements. This means that for an ORM entity that is mapped to multiple
    tables, typically one which is mapped using [joined table inheritance](../inheritance.html#joined-inheritance),
    the bulk INSERT operation will emit an INSERT statement for each table represented
    by the mapping, correctly transferring server-generated primary key values to
    the table rows that depend upon them. The RETURNING feature is also supported
    here, where the ORM will receive [`Result`](../../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects for each INSERT statement executed, and will
    then “horizontally splice” them together so that the returned rows include values
    for all columns inserted:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT of joined inheritance mappings requires that the ORM make use of
    the [`Insert.returning.sort_by_parameter_order`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning.params.sort_by_parameter_order
    "sqlalchemy.sql.expression.Insert.returning") parameter internally, so that it
    can correlate primary key values from RETURNING rows from the base table into
    the parameter sets being used to INSERT into the “sub” table, which is why the
    SQLite backend illustrated above transparently degrades to using non-batched statements.
    Background on this feature is at [Correlating RETURNING rows to parameter sets](../../core/connections.html#engine-insertmanyvalues-returning-order).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Bulk Insert with SQL Expressions'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The ORM bulk insert feature supports the addition of a fixed set of parameters
    which may include SQL expressions to be applied to every target row. To achieve
    this, combine the use of the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, passing a dictionary of parameters
    that will be applied to all rows, with the usual bulk calling form by including
    a list of parameter dictionaries that contain individual row values when invoking
    [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute").
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given an ORM mapping that includes a “timestamp” column:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we wanted to INSERT a series of `LogRecord` elements, each with a unique
    `message` field, however we would like to apply the SQL function `now()` to all
    rows, we can pass `timestamp` within [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and then pass the additional records
    using “bulk” mode:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '#### ORM Bulk Insert with Per Row SQL Expressions'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)  #### ORM Bulk Insert with
    Per Row SQL Expressions'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method itself accommodates a list of
    parameter dictionaries directly. When using the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct in this way, without passing any
    list of parameter dictionaries to the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter, bulk ORM insert mode is not used,
    and instead the INSERT statement is rendered exactly as given and invoked exactly
    once. This mode of operation may be useful both for the case of passing SQL expressions
    on a per-row basis, and is also used when using “upsert” statements with the ORM,
    documented later in this chapter at [ORM “upsert” Statements](#orm-queryguide-upsert).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'A contrived example of an INSERT that embeds per-row SQL expressions, and also
    demonstrates [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") in this form, is below:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Because bulk ORM insert mode is not used above, the following features are
    not present:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined table inheritance](#orm-queryguide-insert-joined-table-inheritance)
    or other multi-table mappings are not supported, since that would require multiple
    INSERT statements.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneous parameter sets](#orm-queryguide-insert-heterogeneous-params)
    are not supported - each element in the VALUES set must have the same columns.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core-level scale optimizations such as the batching provided by [insertmanyvalues](../../core/connections.html#engine-insertmanyvalues)
    are not available; statements will need to ensure the total number of parameters
    does not exceed limits imposed by the backing database.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above reasons, it is generally not recommended to use multiple parameter
    sets with [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with ORM INSERT statements unless there
    is a clear rationale, which is either that “upsert” is being used or there is
    a need to embed per-row SQL expressions in each parameter set.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](#orm-queryguide-upsert)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '### Legacy Session Bulk INSERT Methods'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes legacy methods for performing “bulk” INSERT and UPDATE statements. These
    methods share implementations with the SQLAlchemy 2.0 versions of these features,
    described at [ORM Bulk INSERT Statements](#orm-queryguide-bulk-insert) and [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update), however lack many features,
    namely RETURNING support as well as support for session-synchronization.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Code which makes use of [`Session.bulk_insert_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") for example can port code as follows,
    starting with this mappings example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The above is expressed using the new API as:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk UPDATE Methods](#orm-queryguide-legacy-bulk-update)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM “upsert” Statements'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Selected backends with SQLAlchemy may include dialect-specific [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs which additionally have the ability
    to perform “upserts”, or INSERTs where an existing row in the parameter set is
    turned into an approximation of an UPDATE statement instead. By “existing row”
    , this may mean rows which share the same primary key value, or may refer to other
    indexed columns within the row that are considered to be unique; this is dependent
    on the capabilities of the backend in use.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialects included with SQLAlchemy that include dialect-specific “upsert”
    API features are:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: SQLite - using [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/sqlite.html#sqlite-on-conflict-insert)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL - using [`Insert`](../../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") documented at [INSERT…ON CONFLICT (Upsert)](../../dialects/postgresql.html#postgresql-insert-on-conflict)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL/MariaDB - using [`Insert`](../../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") documented at [INSERT…ON DUPLICATE KEY UPDATE
    (Upsert)](../../dialects/mysql.html#mysql-insert-on-duplicate-key-update)
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should review the above sections for background on proper construction
    of these objects; in particular, the “upsert” method typically needs to refer
    back to the original statement, so the statement is usually constructed in two
    separate steps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Third party backends such as those mentioned at [External Dialects](../../dialects/index.html)
    may also feature similar constructs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'While SQLAlchemy does not yet have a backend-agnostic upsert construct, the
    above [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    variants are nonetheless ORM compatible in that they may be used in the same way
    as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct itself as documented at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    that is, by embedding the desired rows to INSERT within the [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method. In the example below, the SQLite
    [`insert()`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    function is used to generate an [`Insert`](../../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct that includes “ON CONFLICT DO UPDATE”
    support. The statement is then passed to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") where it proceeds normally, with the additional
    characteristic that the parameter dictionaries passed to [`Insert.values()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") are interpreted as ORM mapped attribute
    keys, rather than column names:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '#### Using RETURNING with upsert statements'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)  #### Using
    RETURNING with upsert statements'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'From the SQLAlchemy ORM’s point of view, upsert statements look like regular
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    constructs, which includes that [`Insert.returning()`](../../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") works with upsert statements in
    the same way as was demonstrated at [ORM Bulk Insert with Per Row SQL Expressions](#orm-queryguide-insert-values),
    so that any column expression or relevant ORM entity class may be passed. Continuing
    from the example in the previous section:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The example above uses RETURNING to return ORM objects for each row inserted
    or upserted by the statement. The example also adds use of the [Populate Existing](api.html#orm-queryguide-populate-existing)
    execution option. This option indicates that `User` objects which are already
    present in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    for rows that already exist should be **refreshed** with the data from the new
    row. For a pure [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement, this option is not significant,
    because every row produced is a brand new primary key identity. However when the
    [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    also includes “upsert” options, it may also be yielding results from rows that
    already exist and therefore may already have a primary key identity represented
    in the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s [identity map](../../glossary.html#term-identity-map).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[Populate Existing](api.html#orm-queryguide-populate-existing)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '## ORM Bulk UPDATE by Primary Key'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct may be used with [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in a similar way as the [`Insert`](../../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") statement is used as described at [ORM Bulk
    INSERT Statements](#orm-queryguide-bulk-insert), passing a list of many parameter
    dictionaries, each dictionary representing an individual row that corresponds
    to a single primary key value. This use should not be confused with a more common
    way to use [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    statements with the ORM, using an explicit WHERE clause, which is documented at
    [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: For the “bulk” version of UPDATE, a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") construct is made in terms of an ORM class
    and passed to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method; the resulting [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") object should have **no values and typically
    no WHERE criteria**, that is, the [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is not used, and the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") is **usually** not used, but may be
    used in the unusual case that additional filtering criteria would be added.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a list of parameter dictionaries
    which each include a full primary key value will invoke **bulk UPDATE by primary
    key mode** for the statement, generating the appropriate WHERE criteria to match
    each row by primary key, and using [executemany](../../glossary.html#term-executemany)
    to run each parameter set against the UPDATE statement:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that each parameter dictionary **must include a full primary key for each
    record**, else an error is raised.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Like the bulk INSERT feature, heterogeneous parameter lists are supported here
    as well, where the parameters will be grouped into sub-batches of UPDATE runs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.11: Additional WHERE criteria can be combined with [ORM
    Bulk UPDATE by Primary Key](#orm-queryguide-bulk-update) by using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") method to add additional criteria. However
    this criteria is always in addition to the WHERE criteria that’s already made
    present which includes primary key values.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The RETURNING feature is not available when using the “bulk UPDATE by primary
    key” feature; the list of multiple parameter dictionaries necessarily makes use
    of DBAPI [executemany](../../glossary.html#term-executemany), which in its usual
    form does not typically support result rows.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Passing an [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct to the [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method along with a list of parameter dictionaries
    now invokes a “bulk update”, which makes use of the same functionality as the
    legacy [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This is a behavior change
    compared to the 1.x series where the [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") would only be supported with explicit WHERE
    criteria and inline VALUES.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '### Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: the UPDATE statement given is against an ORM entity
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)  ### Bulk UPDATE by Primary Key for
    Joined Table Inheritance'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]  ### Legacy Session Bulk UPDATE Methods'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Is expressed using the new API as:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: See also
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)  ###
    Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Bulk Update by Primary Key feature, which runs an UPDATE statement
    per record which includes WHERE criteria for each primary key value, is automatically
    used when:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: the UPDATE statement given is against an ORM entity
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is used to execute the statement, and not a Core [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parameters passed are a **list of dictionaries**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to invoke an UPDATE statement without using “ORM Bulk Update by Primary
    Key”, invoke the statement against the [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") directly using the [`Session.connection()`](../session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") method to acquire the current [`Connection`](../../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for the transaction:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values](../../errors.html#error-bupq)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '### Bulk UPDATE by Primary Key for Joined Table Inheritance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: ORM bulk update has similar behavior to ORM bulk insert when using mappings
    with joined table inheritance; as described at [Bulk INSERT for Joined Table Inheritance](#orm-queryguide-insert-joined-table-inheritance),
    the bulk UPDATE operation will emit an UPDATE statement for each table represented
    in the mapping, for which the given parameters include values to be updated (non-affected
    tables are skipped).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '### Legacy Session Bulk UPDATE Methods'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: As discussed at [Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert),
    the [`Session.bulk_update_mappings()`](../session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method of [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is the legacy form of bulk update, which the ORM makes
    use of internally when interpreting a [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") statement with primary key parameters given;
    however, when using the legacy version, features such as support for session-synchronization
    are not included.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Is expressed using the new API as:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: See also
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[Legacy Session Bulk INSERT Methods](#orm-queryguide-legacy-bulk-insert)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '## ORM UPDATE and DELETE with Custom WHERE Criteria'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    constructs, when constructed with custom WHERE criteria (that is, using the [`Update.where()`](../../core/dml.html#sqlalchemy.sql.expression.Update.where
    "sqlalchemy.sql.expression.Update.where") and [`Delete.where()`](../../core/dml.html#sqlalchemy.sql.expression.Delete.where
    "sqlalchemy.sql.expression.Delete.where") methods), may be invoked in an ORM context
    by passing them to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), without using the [`Session.execute.params`](../session_api.html#sqlalchemy.orm.Session.execute.params.params
    "sqlalchemy.orm.Session.execute") parameter. For [`Update`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"), the values to be updated should be passed
    using [`Update.values()`](../../core/dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: This mode of use differs from the feature described previously at [ORM Bulk
    UPDATE by Primary Key](#orm-queryguide-bulk-update) in that the ORM uses the given
    WHERE clause as is, rather than fixing the WHERE clause to be by primary key.
    This means that the single UPDATE or DELETE statement can affect many rows at
    once.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: As an example, below an UPDATE is emitted that affects the “fullname” field
    of multiple rows
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For a DELETE, an example of deleting rows based on criteria:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Warning
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Please read the following section [Important Notes and Caveats for ORM-Enabled
    Update and Delete](#orm-queryguide-update-delete-caveats) for important notes
    regarding how the functionality of ORM-Enabled UPDATE and DELETE diverges from
    that of ORM [unit of work](../../glossary.html#term-unit-of-work) features, such
    as using the [`Session.delete()`](../session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to delete individual objects.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.  ### Selecting a Synchronization
    Strategy'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.  ### Using RETURNING with UPDATE/DELETE
    and Custom WHERE Criteria'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.  ### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '### Important Notes and Caveats for ORM-Enabled Update and Delete'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The ORM-enabled UPDATE and DELETE features bypass ORM [unit of work](../../glossary.html#term-unit-of-work)
    automation in favor of being able to emit a single UPDATE or DELETE statement
    that matches multiple rows at once without complexity.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The operations do not offer in-Python cascading of relationships - it is assumed
    that ON UPDATE CASCADE and/or ON DELETE CASCADE is configured for any foreign
    key references which require it, otherwise the database may emit an integrity
    violation if foreign key references are being enforced. See the notes at [Using
    foreign key ON DELETE cascade with ORM relationships](../cascades.html#passive-deletes)
    for some examples.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the UPDATE or DELETE, dependent objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which were impacted by an ON UPDATE CASCADE or ON DELETE
    CASCADE on related tables, particularly objects that refer to rows that have now
    been deleted, may still reference those objects. This issue is resolved once the
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, which normally occurs upon [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or can be forced by using [`Session.expire_all()`](../session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all").
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM-enabled UPDATEs and DELETEs do not handle joined table inheritance automatically.
    See the section [UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance](#orm-queryguide-update-delete-joined-inh)
    for notes on how to work with joined-inheritance mappings.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WHERE criteria needed in order to limit the polymorphic identity to specific
    subclasses for single-table-inheritance mappings **is included automatically**
    . This only applies to a subclass mapper that has no table of its own.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`with_loader_criteria()`](api.html#sqlalchemy.orm.with_loader_criteria
    "sqlalchemy.orm.with_loader_criteria") option **is supported** by ORM update and
    delete operations; criteria here will be added to that of the UPDATE or DELETE
    statement being emitted, as well as taken into account during the “synchronize”
    process.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to intercept ORM-enabled UPDATE and DELETE operations with event handlers,
    use the [`SessionEvents.do_orm_execute()`](../events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") event.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Selecting a Synchronization Strategy'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: When making use of [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") in conjunction with ORM-enabled execution
    using [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), additional ORM-specific functionality is present
    which will **synchronize** the state being changed by the statement with that
    of the objects that are currently present within the [identity map](../../glossary.html#term-identity-map)
    of the [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    By “synchronize” we mean that UPDATEd attributes will be refreshed with the new
    value, or at the very least [expired](../../glossary.html#term-expired) so that
    they will re-populate with their new value on next access, and DELETEd objects
    will be moved into the [deleted](../../glossary.html#term-deleted) state.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'This synchronization is controllable as the “synchronization strategy”, which
    is passed as an string ORM execution option, typically by using the [`Session.execute.execution_options`](../session_api.html#sqlalchemy.orm.Session.execute.params.execution_options
    "sqlalchemy.orm.Session.execute") dictionary:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The execution option may also be bundled with the statement itself using the
    [`Executable.execution_options()`](../../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following values for `synchronize_session` are supported:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '`''auto''` - this is the default. The `''fetch''` strategy will be used on
    backends that support RETURNING, which includes all SQLAlchemy-native drivers
    except for MySQL. If RETURNING is not supported, the `''evaluate''` strategy will
    be used instead.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''fetch''` - Retrieves the primary key identity of affected rows by either
    performing a SELECT before the UPDATE or DELETE, or by using RETURNING if the
    database supports it, so that in-memory objects which are affected by the operation
    can be refreshed with new values (updates) or expunged from the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (deletes). This synchronization strategy may be used
    even if the given [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct explicitly specifies entities or
    columns using [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning").'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Explicit [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be combined with the `''fetch''`
    synchronization strategy when using ORM-enabled UPDATE and DELETE with WHERE criteria.
    The actual statement will contain the union of columns between that which the
    `''fetch''` strategy requires and those which were requested.'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''evaluate''` - This indicates to evaluate the WHERE criteria given in the
    UPDATE or DELETE statement in Python, to locate matching objects within the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This approach does not add any SQL round trips to the
    operation, and in the absence of RETURNING support, may be more efficient. For
    UPDATE or DELETE statements with complex criteria, the `''evaluate''` strategy
    may not be able to evaluate the expression in Python and will raise an error.
    If this occurs, use the `''fetch''` strategy for the operation instead.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If a SQL expression makes use of custom operators using the [`Operators.op()`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") or [`custom_op`](../../core/sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") feature, the [`Operators.op.python_impl`](../../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.python_impl
    "sqlalchemy.sql.expression.Operators.op") parameter may be used to indicate a
    Python function that will be used by the `"evaluate"` synchronization strategy.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `"evaluate"` strategy should be avoided if an UPDATE operation is to run
    on a [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that has many objects which have been expired, because it will necessarily need
    to refresh objects in order to test them against the given WHERE criteria, which
    will emit a SELECT for each one. In this case, and particularly if the backend
    supports RETURNING, the `"fetch"` strategy should be preferred.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`False` - don’t synchronize the session. This option may be useful for backends
    that don’t support RETURNING where the `"evaluate"` strategy is not able to be
    used. In this case, the state of objects in the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is unchanged and will not automatically correspond to
    the UPDATE or DELETE statement that was emitted, if such objects that would normally
    correspond to the rows matched are present.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") method is fully compatible with
    ORM-enabled UPDATE and DELETE with WHERE criteria. Full ORM objects and/or columns
    may be indicated for RETURNING:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The support for RETURNING is also compatible with the `fetch` synchronization
    strategy, which also uses RETURNING. The ORM will organize the columns in RETURNING
    appropriately so that the synchronization proceeds as well as that the returned
    [`Result`](../../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    will contain the requested entities and SQL columns in their requested order.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: [`UpdateBase.returning()`](../../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning
    "sqlalchemy.sql.expression.UpdateBase.returning") may be used for ORM enabled
    UPDATE and DELETE while still retaining full compatibility with the `fetch` synchronization
    strategy.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '### UPDATE/DELETE with Custom WHERE Criteria for Joined Table Inheritance'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE/DELETE with WHERE criteria feature, unlike the [ORM Bulk UPDATE by
    Primary Key](#orm-queryguide-bulk-update), only emits a single UPDATE or DELETE
    statement per call to [`Session.execute()`](../session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This means that when running an [`update()`](../../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") or [`delete()`](../../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") statement against a multi-table mapping, such
    as a subclass in a joined-table inheritance mapping, the statement must conform
    to the backend’s current capabilities, which may include that the backend does
    not support an UPDATE or DELETE statement that refers to multiple tables, or may
    have only limited support for this. This means that for mappings such as joined
    inheritance subclasses, the ORM version of the UPDATE/DELETE with WHERE criteria
    feature can only be used to a limited extent or not at all, depending on specifics.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to emit a multi-row UPDATE statement for a joined-table
    subclass is to refer to the sub-table alone. This means the [`Update()`](../../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct should only refer to attributes
    that are local to the subclass table, as in the example below:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the above form, a rudimentary way to refer to the base table in order
    to locate rows which will work on any SQL backend is so use a subquery:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For backends that support UPDATE…FROM, the subquery may be stated instead as
    additional plain WHERE criteria, however the criteria between the two tables must
    be stated explicitly in some way:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'For a DELETE, it’s expected that rows in both the base table and the sub-table
    would be DELETEd at the same time. To DELETE many rows of joined inheritance objects
    **without** using cascading foreign keys, emit DELETE for each table individually:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Overall, normal [unit of work](../../glossary.html#term-unit-of-work) processes
    should be **preferred** for updating and deleting rows for joined inheritance
    and other multi-table mappings, unless there is a performance rationale for using
    custom WHERE criteria.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Query Methods
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ORM enabled UPDATE/DELETE with WHERE feature was originally part of the
    now-legacy [`Query`](query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") object,
    in the [`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")
    methods. These methods remain available and provide a subset of the same functionality
    as that described at [ORM UPDATE and DELETE with Custom WHERE Criteria](#orm-queryguide-update-delete-where).
    The primary difference is that the legacy methods don’t provide for explicit RETURNING
    support.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.update()`](query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.delete()`](query.html#sqlalchemy.orm.Query.delete "sqlalchemy.orm.Query.delete")'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
