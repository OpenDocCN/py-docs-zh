["```py, which are discarded by the database when producing the column name.\n\n    References: [#7736](https://www.sqlalchemy.org/trac/ticket/7736)\n\n*   **[sqlite] [bug]**\n\n    Fixed issue where SQLite unique constraint reflection would fail to detect a column-inline UNIQUE constraint where the column name had an underscore in its name.\n\n    References: [#7736](https://www.sqlalchemy.org/trac/ticket/7736)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed issue in Oracle dialect where using a column name that requires quoting when written as a bound parameter, such as `\"_id\"`, would not correctly track a Python generated default value due to the bound-parameter rewriting missing this value, causing an Oracle error to be raised.\n\n    References: [#7676](https://www.sqlalchemy.org/trac/ticket/7676)\n\n*   **[oracle] [bug] [regression]**\n\n    Added support to parse \u201cDPI\u201d error codes from cx_Oracle exception objects such as `DPI-1080` and `DPI-1010`, both of which now indicate a disconnect scenario as of cx_Oracle 8.3.\n\n    References: [#7748](https://www.sqlalchemy.org/trac/ticket/7748)\n\n### tests\n\n*   **[tests] [bug]**\n\n    Improvements to the test suite\u2019s integration with pytest such that the \u201cwarnings\u201d plugin, if manually enabled, will not interfere with the test suite, such that third parties can enable the warnings plugin or make use of the `-W` parameter and SQLAlchemy\u2019s test suite will continue to pass. Additionally, modernized the detection of the \u201cpytest-xdist\u201d plugin so that plugins can be globally disabled using PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 without breaking the test suite if xdist were still installed. Warning filters that promote deprecation warnings to errors are now localized to SQLAlchemy-specific warnings, or within SQLAlchemy-specific sources for general Python deprecation warnings, so that non-SQLAlchemy deprecation warnings emitted from pytest plugins should also not impact the test suite.\n\n    References: [#7599](https://www.sqlalchemy.org/trac/ticket/7599)\n\n*   **[tests] [bug]**\n\n    Made corrections to the default pytest configuration regarding how test discovery is configured, to fix issue where the test suite would not configure warnings correctly and also attempt to load example suites as tests, in the specific case where the SQLAlchemy checkout were located in an absolute path that had a super-directory named \u201ctest\u201d.\n\n    References: [#7045](https://www.sqlalchemy.org/trac/ticket/7045)\n\n## 1.4.31\n\nReleased: January 20, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects \"sqlalchemy.orm.Session.bulk_save_objects\") where the sorting that takes place when the `preserve_order` parameter is set to False would sort partially on `Mapper` objects, which is rejected in Python 3.11.\n\n    References: [#7591](https://www.sqlalchemy.org/trac/ticket/7591)\n\n### postgresql\n\n*   **[postgresql] [bug] [regression]**\n\n    Fixed regression where the change in [#7148](https://www.sqlalchemy.org/trac/ticket/7148) to repair ENUM handling in PostgreSQL broke the use case of an empty ARRAY of ENUM, preventing rows that contained an empty array from being handled correctly when fetching results.\n\n    References: [#7590](https://www.sqlalchemy.org/trac/ticket/7590)\n\n### mysql\n\n*   **[mysql] [bug] [regression]**\n\n    Fixed regression in asyncmy dialect caused by [#7567](https://www.sqlalchemy.org/trac/ticket/7567) where removal of the PyMySQL dependency broke binary columns, due to the asyncmy dialect not being properly included within CI tests.\n\n    References: [#7593](https://www.sqlalchemy.org/trac/ticket/7593)\n\n### mssql\n\n*   **[mssql]**\n\n    Added support for `FILESTREAM` when using `VARBINARY(max)` in MSSQL.\n\n    See also\n\n    `VARBINARY.filestream`\n\n    References: [#7243](https://www.sqlalchemy.org/trac/ticket/7243)\n\n## 1.4.30\n\nReleased: January 19, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in joined-inheritance load of additional attributes functionality in deep multi-level inheritance where an intermediary table that contained no columns would not be included in the tables joined, instead linking those tables to their primary key identifiers. While this works fine, it nonetheless in 1.4 began producing the cartesian product compiler warning. The logic has been changed so that these intermediary tables are included regardless. While this does include additional tables in the query that are not technically necessary, this only occurs for the highly unusual case of deep 3+ level inheritance with intermediary tables that have no non primary key columns, potential performance impact is therefore expected to be negligible.\n\n    References: [#7507](https://www.sqlalchemy.org/trac/ticket/7507)\n\n*   **[orm] [bug]**\n\n    Fixed issue where calling upon [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively \"sqlalchemy.orm.registry.map_imperatively\") more than once for the same class would produce an unexpected error, rather than an informative error that the target class is already mapped. This behavior differed from that of the `mapper()` function which does report an informative message already.\n\n    References: [#7579](https://www.sqlalchemy.org/trac/ticket/7579)\n\n*   **[orm] [bug] [asyncio]**\n\n    Added missing method [`AsyncSession.invalidate()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.invalidate \"sqlalchemy.ext.asyncio.AsyncSession.invalidate\") to the [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") class.\n\n    References: [#7524](https://www.sqlalchemy.org/trac/ticket/7524)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression which appeared in 1.4.23 which could cause loader options to be mis-handled in some cases, in particular when using joined table inheritance in combination with the `polymorphic_load=\"selectin\"` option as well as relationship lazy loading, leading to a `TypeError`.\n\n    References: [#7557](https://www.sqlalchemy.org/trac/ticket/7557)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed ORM regression where calling the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") function against an existing [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct would fail to produce correct SQL if the existing construct were against a fixed table. The fix allows that the original [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct is disregarded if it were only against a table that\u2019s now being replaced. It also allows for correct behavior when constructing a [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") without a selectable argument against a [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") that\u2019s against a subuquery, to create an alias of that subquery (i.e. to change its name).\n\n    The nesting behavior of [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") remains in place for the case where the outer [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") object is against a subquery which in turn refers to the inner [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") object. This is a relatively new 1.4 feature that helps to suit use cases that were previously served by the deprecated `Query.from_self()` method.\n\n    References: [#7576](https://www.sqlalchemy.org/trac/ticket/7576)\n\n*   **[orm] [bug]**\n\n    Fixed issue where [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except \"sqlalchemy.sql.expression.Select.correlate_except\") method, when passed either the `None` value or no arguments, would not correlate any elements when used in an ORM context (that is, passing ORM entities as FROM clauses), rather than causing all FROM elements to be considered as \u201ccorrelated\u201d in the same way which occurs when using Core-only constructs.\n\n    References: [#7514](https://www.sqlalchemy.org/trac/ticket/7514)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression from 1.3 where the \u201csubqueryload\u201d loader strategy would fail with a stack trace if used against a query that made use of [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement \"sqlalchemy.orm.Query.from_statement\") or [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement \"sqlalchemy.sql.expression.Select.from_statement\"). As subqueryload requires modifying the original statement, it\u2019s not compatible with the \u201cfrom_statement\u201d use case, especially for statements made against the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") construct. The behavior now is equivalent to that of 1.3 and previously, which is that the loader strategy silently degrades to not be used for such statements, typically falling back to using the lazyload strategy.\n\n    References: [#7505](https://www.sqlalchemy.org/trac/ticket/7505)\n\n### sql\n\n*   **[sql] [bug] [postgresql]**\n\n    Added additional rule to the system that determines `TypeEngine` implementations from Python literals to apply a second level of adjustment to the type, so that a Python datetime with or without tzinfo can set the `timezone=True` parameter on the returned [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime \"sqlalchemy.types.DateTime\") object, as well as [`Time`](../core/type_basics.html#sqlalchemy.types.Time \"sqlalchemy.types.Time\"). This helps with some round-trip scenarios on type-sensitive PostgreSQL dialects such as asyncpg, psycopg3 (2.0 only).\n\n    References: [#7537](https://www.sqlalchemy.org/trac/ticket/7537)\n\n*   **[sql] [bug]**\n\n    Added an informative error message when a method object is passed to a SQL construct. Previously, when such a callable were passed, as is a common typographical error when dealing with method-chained SQL constructs, they were interpreted as \u201clambda SQL\u201d targets to be invoked at compilation time, which would lead to silent failures. As this feature was not intended to be used with methods, method objects are now rejected.\n\n    References: [#7032](https://www.sqlalchemy.org/trac/ticket/7032)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed Mypy crash when running id daemon mode caused by a missing attribute on an internal mypy `Var` instance.\n\n    References: [#7321](https://www.sqlalchemy.org/trac/ticket/7321)\n\n### asyncio\n\n*   **[asyncio] [usecase]**\n\n    Added new method [`AdaptedConnection.run_async()`](../core/internals.html#sqlalchemy.engine.AdaptedConnection.run_async \"sqlalchemy.engine.AdaptedConnection.run_async\") to the DBAPI connection interface used by asyncio drivers, which allows methods to be called against the underlying \u201cdriver\u201d connection directly within a sync-style function where the `await` keyword can\u2019t be used, such as within SQLAlchemy event handler functions. The method is analogous to the [`AsyncConnection.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync \"sqlalchemy.ext.asyncio.AsyncConnection.run_sync\") method which translates async-style calls to sync-style. The method is useful for things like connection-pool on-connect handlers that need to invoke awaitable methods on the driver connection when it\u2019s first created.\n\n    See also\n\n    [Using awaitable-only driver methods in connection pool and other events](../orm/extensions/asyncio.html#asyncio-events-run-async)\n\n    References: [#7580](https://www.sqlalchemy.org/trac/ticket/7580)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added string rendering to the `UUID` datatype, so that stringifying a statement with \u201cliteral_binds\u201d that uses this type will render an appropriate string value for the PostgreSQL backend. Pull request courtesy Jose\u0301 Duarte.\n\n    References: [#7561](https://www.sqlalchemy.org/trac/ticket/7561)\n\n*   **[postgresql] [bug] [asyncpg]**\n\n    Improved support for asyncpg handling of TIME WITH TIMEZONE, which was not fully implemented.\n\n    References: [#7537](https://www.sqlalchemy.org/trac/ticket/7537)\n\n*   **[postgresql] [bug] [mssql] [reflection]**\n\n    Fixed reflection of covering indexes to report `include_columns` as part of the `dialect_options` entry in the reflected index dictionary, thereby enabling round trips from reflection->create to be complete. Included columns continue to also be present under the `include_columns` key for backwards compatibility.\n\n    References: [#7382](https://www.sqlalchemy.org/trac/ticket/7382)\n\n*   **[postgresql] [bug]**\n\n    Fixed handling of array of enum values which require escape characters.\n\n    References: [#7418](https://www.sqlalchemy.org/trac/ticket/7418)\n\n### mysql\n\n*   **[mysql] [change]**\n\n    Replace `SHOW VARIABLES LIKE` statement with equivalent `SELECT @@variable` in MySQL and MariaDB dialect initialization. This should avoid mutex contention caused by `SHOW VARIABLES`, improving initialization performance.\n\n    References: [#7518](https://www.sqlalchemy.org/trac/ticket/7518)\n\n*   **[mysql] [bug]**\n\n    Removed unnecessary dependency on PyMySQL from the asyncmy dialect. Pull request courtesy long2ice.\n\n    References: [#7567](https://www.sqlalchemy.org/trac/ticket/7567)\n\n## 1.4.29\n\nReleased: December 22, 2021\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added [`Session.get.execution_options`](../orm/session_api.html#sqlalchemy.orm.Session.get.params.execution_options \"sqlalchemy.orm.Session.get\") parameter which was previously missing from the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get \"sqlalchemy.orm.Session.get\") method.\n\n    References: [#7410](https://www.sqlalchemy.org/trac/ticket/7410)\n\n*   **[orm] [bug]**\n\n    Fixed issue in new \u201cloader criteria\u201d method [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") where usage with a loader strategy like [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") against a column that was a member of the `.c.` collection of a subquery object, where the subquery would be dynamically added to the FROM clause of the statement, would be subject to stale parameter values within the subquery in the SQL statement cache, as the process used by the loader strategy to replace the parameters at execution time would fail to accommodate the subquery when received in this form.\n\n    References: [#7489](https://www.sqlalchemy.org/trac/ticket/7489)\n\n*   **[orm] [bug]**\n\n    Fixed recursion overflow which could occur within ORM statement compilation when using either the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature or the the [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") method within a loader strategy in conjunction with a subquery which referred to the same entity being altered by the criteria option, or loaded by the loader strategy. A check for coming across the same loader criteria option in a recursive fashion has been added to accommodate for this scenario.\n\n    References: [#7491](https://www.sqlalchemy.org/trac/ticket/7491)\n\n*   **[orm] [bug] [mypy]**\n\n    Fixed issue where the `__class_getitem__()` method of the generated declarative base class by [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative \"sqlalchemy.orm.as_declarative\") would lead to inaccessible class attributes such as `__table__`, for cases where a `Generic[T]` style typing declaration were used in the class hierarchy. This is in continuation from the basic addition of `__class_getitem__()` in [#7368](https://www.sqlalchemy.org/trac/ticket/7368). Pull request courtesy Kai Mueller.\n\n    References: [#7368](https://www.sqlalchemy.org/trac/ticket/7368), [#7462](https://www.sqlalchemy.org/trac/ticket/7462)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed caching-related issue where the use of a loader option of the form `lazyload(aliased(A).bs).joinedload(B.cs)` would fail to result in the joinedload being invoked for runs subsequent to the query being cached, due to a mismatch for the options / object path applied to the objects loaded for a query with a lead entity that used `aliased()`.\n\n    References: [#7447](https://www.sqlalchemy.org/trac/ticket/7447)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Corrected the error message for the `AttributeError` that\u2019s raised when attempting to write to an attribute on the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") class, which is immutable. The previous message claimed the column didn\u2019t exist which is misleading.\n\n    References: [#7432](https://www.sqlalchemy.org/trac/ticket/7432)\n\n*   **[engine] [bug] [regression]**\n\n    Fixed regression in the [`make_url()`](../core/engines.html#sqlalchemy.engine.make_url \"sqlalchemy.engine.make_url\") function used to parse URL strings where the query string parsing would go into a recursion overflow if a Python 2 `u''` string were used.\n\n    References: [#7446](https://www.sqlalchemy.org/trac/ticket/7446)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed mypy regression where the release of mypy 0.930 added additional internal checks to the format of \u201cnamed types\u201d, requiring that they be fully qualified and locatable. This broke the mypy plugin for SQLAlchemy, raising an assertion error, as there was use of symbols such as `__builtins__` and other un-locatable or unqualified names that previously had not raised any assertions.\n\n    References: [#7496](https://www.sqlalchemy.org/trac/ticket/7496)\n\n### asyncio\n\n*   **[asyncio] [usecase]**\n\n    Added `async_engine_config()` function to create an async engine from a configuration dict. This otherwise behaves the same as [`engine_from_config()`](../core/engines.html#sqlalchemy.engine_from_config \"sqlalchemy.engine_from_config\").\n\n    References: [#7301](https://www.sqlalchemy.org/trac/ticket/7301)\n\n### mariadb\n\n*   **[mariadb] [bug]**\n\n    Corrected the error classes inspected for the \u201cis_disconnect\u201d check for the `mariadbconnector` dialect, which was failing for disconnects that occurred due to common MySQL/MariaDB error codes such as 2006; the DBAPI appears to currently use the `mariadb.InterfaceError` exception class for disconnect errors such as error code 2006, which has been added to the list of classes checked.\n\n    References: [#7457](https://www.sqlalchemy.org/trac/ticket/7457)\n\n### tests\n\n*   **[tests] [bug] [regression]**\n\n    Fixed a regression in the test suite where the test called `CompareAndCopyTest::test_all_present` would fail on some platforms due to additional testing artifacts being detected. Pull request courtesy Nils Philippsen.\n\n    References: [#7450](https://www.sqlalchemy.org/trac/ticket/7450)\n\n## 1.4.28\n\nReleased: December 9, 2021\n\n### platform\n\n*   **[platform] [bug]**\n\n    Python 3.10 has deprecated \u201cdistutils\u201d in favor of explicit use of \u201csetuptools\u201d in [**PEP 632**](https://peps.python.org/pep-0632/); SQLAlchemy\u2019s setup.py has replaced imports accordingly. However, since setuptools itself only recently added the replacement symbols mentioned in pep-632 as of November of 2021 in version 59.0.1, `setup.py` still has fallback imports to distutils, as SQLAlchemy 1.4 does not have a hard setuptools versioning requirement at this time. SQLAlchemy 2.0 is expected to use a full [**PEP 517**](https://peps.python.org/pep-0517/) installation layout which will indicate appropriate setuptools versioning up front.\n\n    References: [#7311](https://www.sqlalchemy.org/trac/ticket/7311)\n\n### orm\n\n*   **[orm] [bug] [ext]**\n\n    Fixed issue where the internal cloning used by the [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any \"sqlalchemy.orm.PropComparator.any\") method on a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") in the case where the related class also makes use of ORM polymorphic loading, would fail if a hybrid property on the related, polymorphic class were used within the criteria for the `any()` operation.\n\n    References: [#7425](https://www.sqlalchemy.org/trac/ticket/7425)\n\n*   **[orm] [bug] [mypy]**\n\n    Fixed issue where the [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative \"sqlalchemy.orm.as_declarative\") decorator and similar functions used to generate the declarative base class would not copy the `__class_getitem__()` method from a given superclass, which prevented the use of pep-484 generics in conjunction with the `Base` class. Pull request courtesy Kai Mueller.\n\n    References: [#7368](https://www.sqlalchemy.org/trac/ticket/7368)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed ORM regression where the new behavior of \u201ceager loaders run on unexpire\u201d added in [#1763](https://www.sqlalchemy.org/trac/ticket/1763) would lead to loader option errors being raised inappropriately for the case where a single [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") or [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") were used to load multiple kinds of entities, along with loader options that apply to just one of those kinds of entity like a [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\"), and later the objects would be refreshed from expiration, where the loader options would attempt to be applied to the mismatched object type and then raise an exception. The check for this mismatch now bypasses raising an error for this case.\n\n    References: [#7318](https://www.sqlalchemy.org/trac/ticket/7318)\n\n*   **[orm] [bug]**\n\n    User defined ORM options, such as those illustrated in the dogpile.caching example which subclass `UserDefinedOption`, by definition are handled on every statement execution and do not need to be considered as part of the cache key for the statement. Caching of the base `ExecutableOption` class has been modified so that it is no longer a [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey \"sqlalchemy.sql.traversals.HasCacheKey\") subclass directly, so that the presence of user defined option objects will not have the unwanted side effect of disabling statement caching. Only ORM specific loader and criteria options, which are all internal to SQLAlchemy, now participate within the caching system.\n\n    References: [#7394](https://www.sqlalchemy.org/trac/ticket/7394)\n\n*   **[orm] [bug]**\n\n    Fixed issue where mappings that made use of [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym \"sqlalchemy.orm.synonym\") and potentially other kinds of \u201cproxy\u201d attributes would not in all cases successfully generate a cache key for their SQL statements, leading to degraded performance for those statements.\n\n    References: [#7394](https://www.sqlalchemy.org/trac/ticket/7394)\n\n*   **[orm] [bug]**\n\n    Fixed issue where a list mapped with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") would go into an endless loop if in-place added to itself, i.e. the `+=` operator were used, as well as if `.extend()` were given the same list.\n\n    References: [#7389](https://www.sqlalchemy.org/trac/ticket/7389)\n\n*   **[orm] [bug]**\n\n    Fixed issue where if an exception occurred when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") were to close the connection within the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit \"sqlalchemy.orm.Session.commit\") method, when using a context manager for [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin \"sqlalchemy.orm.Session.begin\") , it would attempt a rollback which would not be possible as the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") was in between where the transaction is committed and the connection is then to be returned to the pool, raising the exception \u201cthis sessiontransaction is in the committed state\u201d. This exception can occur mostly in an asyncio context where CancelledError can be raised.\n\n    References: [#7388](https://www.sqlalchemy.org/trac/ticket/7388)\n\n*   **[orm] [deprecated]**\n\n    Deprecated an undocumented loader option syntax `\".*\"`, which appears to be no different than passing a single asterisk, and will emit a deprecation warning if used. This syntax may have been intended for something but there is currently no need for it.\n\n    References: [#4390](https://www.sqlalchemy.org/trac/ticket/4390)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Added support for `copy()` and `deepcopy()` to the [`URL`](../core/engines.html#sqlalchemy.engine.URL \"sqlalchemy.engine.URL\") class. Pull request courtesy Tom Ritchford.\n\n    References: [#7400](https://www.sqlalchemy.org/trac/ticket/7400)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    \u201dCompound select\u201d methods like [`Select.union()`](../core/selectable.html#sqlalchemy.sql.expression.Select.union \"sqlalchemy.sql.expression.Select.union\"), [`Select.intersect_all()`](../core/selectable.html#sqlalchemy.sql.expression.Select.intersect_all \"sqlalchemy.sql.expression.Select.intersect_all\") etc. now accept `*other` as an argument rather than `other` to allow for multiple additional SELECTs to be compounded with the parent statement at once. In particular, the change as applied to [`CTE.union()`](../core/selectable.html#sqlalchemy.sql.expression.CTE.union \"sqlalchemy.sql.expression.CTE.union\") and [`CTE.union_all()`](../core/selectable.html#sqlalchemy.sql.expression.CTE.union_all \"sqlalchemy.sql.expression.CTE.union_all\") now allow for a so-called \u201cnon-linear CTE\u201d to be created with the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct, whereas previously there was no way to have more than two CTE sub-elements in a UNION together while still correctly calling upon the CTE in recursive fashion. Pull request courtesy Eric Masseran.\n\n    References: [#7259](https://www.sqlalchemy.org/trac/ticket/7259)\n\n*   **[sql] [usecase]**\n\n    Support multiple clause elements in the [`Exists.where()`](../core/selectable.html#sqlalchemy.sql.expression.Exists.where \"sqlalchemy.sql.expression.Exists.where\") method, unifying the api with the one presented by a normal [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct.\n\n    References: [#7386](https://www.sqlalchemy.org/trac/ticket/7386)\n\n*   **[sql] [bug] [regression]**\n\n    Extended the [`TypeDecorator.cache_ok`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.cache_ok \"sqlalchemy.types.TypeDecorator.cache_ok\") attribute and corresponding warning message if this flag is not defined, a behavior first established for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\") as part of [#6436](https://www.sqlalchemy.org/trac/ticket/6436), to also take place for [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType \"sqlalchemy.types.UserDefinedType\"), by generalizing the flag and associated caching logic to a new common base for these two types, [`ExternalType`](../core/type_api.html#sqlalchemy.types.ExternalType \"sqlalchemy.types.ExternalType\") to create [`UserDefinedType.cache_ok`](../core/custom_types.html#sqlalchemy.types.UserDefinedType.cache_ok \"sqlalchemy.types.UserDefinedType.cache_ok\").\n\n    The change means any current [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType \"sqlalchemy.types.UserDefinedType\") will now cause SQL statement caching to no longer take place for statements which make use of the datatype, along with a warning being emitted, unless the class defines the [`UserDefinedType.cache_ok`](../core/custom_types.html#sqlalchemy.types.UserDefinedType.cache_ok \"sqlalchemy.types.UserDefinedType.cache_ok\") flag as True. If the datatype cannot form a deterministic, hashable cache key derived from its arguments, the attribute may be set to False which will continue to keep caching disabled but will suppress the warning. In particular, custom datatypes currently used in packages such as SQLAlchemy-utils will need to implement this flag. The issue was observed as a result of a SQLAlchemy-utils datatype that is not currently cacheable.\n\n    See also\n\n    [`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok \"sqlalchemy.types.ExternalType.cache_ok\")\n\n    References: [#7319](https://www.sqlalchemy.org/trac/ticket/7319)\n\n*   **[sql] [bug]**\n\n    Custom SQL elements, third party dialects, custom or third party datatypes will all generate consistent warnings when they do not clearly opt in or out of SQL statement caching, which is achieved by setting the appropriate attributes on each type of class. The warning links to documentation sections which indicate the appropriate approach for each type of object in order for caching to be enabled.\n\n    References: [#7394](https://www.sqlalchemy.org/trac/ticket/7394)\n\n*   **[sql] [bug]**\n\n    Fixed missing caching directives for a few lesser used classes in SQL Core which would cause `[no key]` to be logged for elements which made use of these.\n\n    References: [#7394](https://www.sqlalchemy.org/trac/ticket/7394)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed Mypy crash which would occur when using Mypy plugin against code which made use of [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") methods for non-mapped names like `__mapper_args__`, `__table_args__`, or other dunder names, as the plugin would try to interpret these as mapped attributes which would then be later mis-handled. As part of this change, the decorated function is still converted by the plugin into a generic assignment statement (e.g. `__mapper_args__: Any`) so that the argument signature can continue to be annotated in the same way one would for any other `@classmethod` without Mypy complaining about the wrong argument type for a method that isn\u2019t explicitly `@classmethod`.\n\n    References: [#7321](https://www.sqlalchemy.org/trac/ticket/7321)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed missing caching directives for [`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore \"sqlalchemy.dialects.postgresql.hstore\") and [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array \"sqlalchemy.dialects.postgresql.array\") constructs which would cause `[no key]` to be logged for these elements.\n\n    References: [#7394](https://www.sqlalchemy.org/trac/ticket/7394)\n\n### tests\n\n*   **[tests] [bug]**\n\n    Implemented support for the test suite to run correctly under Pytest 7. Previously, only Pytest 6.x was supported for Python 3, however the version was not pinned on the upper bound in tox.ini. Pytest is not pinned in tox.ini to be lower than version 8 so that SQLAlchemy versions released with the current codebase will be able to be tested under tox without changes to the environment. Much thanks to the Pytest developers for their help with this issue.\n\n## 1.4.27\n\nReleased: November 11, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed bug in \u201crelationship to aliased class\u201d feature introduced at [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class) where it was not possible to create a loader strategy option targeting an attribute on the target using the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct directly in a second loader option, such as `selectinload(A.aliased_bs).joinedload(aliased_b.cs)`, without explicitly qualifying using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type \"sqlalchemy.orm.PropComparator.of_type\") on the preceding element of the path. Additionally, targeting the non-aliased class directly would be accepted (inappropriately), but would silently fail, such as `selectinload(A.aliased_bs).joinedload(B.cs)`; this now raises an error referring to the typing mismatch.\n\n    References: [#7224](https://www.sqlalchemy.org/trac/ticket/7224)\n\n*   **[orm] [bug]**\n\n    All [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") objects will now consistently raise [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError \"sqlalchemy.exc.ResourceClosedError\") if they are used after a hard close, which includes the \u201chard close\u201d that occurs after calling \u201csingle row or value\u201d methods like [`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first \"sqlalchemy.engine.Result.first\") and [`Result.scalar()`](../core/connections.html#sqlalchemy.engine.Result.scalar \"sqlalchemy.engine.Result.scalar\"). This was already the behavior of the most common class of result objects returned for Core statement executions, i.e. those based on [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult \"sqlalchemy.engine.CursorResult\"), so this behavior is not new. However, the change has been extended to properly accommodate for the ORM \u201cfiltering\u201d result objects returned when using 2.0 style ORM queries, which would previously behave in \u201csoft closed\u201d style of returning empty results, or wouldn\u2019t actually \u201csoft close\u201d at all and would continue yielding from the underlying cursor.\n\n    As part of this change, also added [`Result.close()`](../core/connections.html#sqlalchemy.engine.Result.close \"sqlalchemy.engine.Result.close\") to the base [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") class and implemented it for the filtered result implementations that are used by the ORM, so that it is possible to call the [`CursorResult.close()`](../core/connections.html#sqlalchemy.engine.CursorResult.close \"sqlalchemy.engine.CursorResult.close\") method on the underlying [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult \"sqlalchemy.engine.CursorResult\") when the `yield_per` execution option is in use to close a server side cursor before remaining ORM results have been fetched. This was again already available for Core result sets but the change makes it available for 2.0 style ORM results as well.\n\n    References: [#7274](https://www.sqlalchemy.org/trac/ticket/7274)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed 1.4 regression where [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") would not function correctly on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") that was produced from [`Query.union()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union \"sqlalchemy.orm.Query.union\"), `Query.from_self()` or similar.\n\n    References: [#7239](https://www.sqlalchemy.org/trac/ticket/7239)\n\n*   **[orm] [bug]**\n\n    Fixed issue where deferred polymorphic loading of attributes from a joined-table inheritance subclass would fail to populate the attribute correctly if the [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only \"sqlalchemy.orm.load_only\") option were used to originally exclude that attribute, in the case where the load_only were descending from a relationship loader option. The fix allows that other valid options such as `defer(..., raiseload=True)` etc. still function as expected.\n\n    References: [#7304](https://www.sqlalchemy.org/trac/ticket/7304)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed 1.4 regression where [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") would not function correctly when [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") were joined to an entity which made use of [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type \"sqlalchemy.orm.PropComparator.of_type\") to specify an aliased version of the target entity. The issue also applies to future style ORM queries constructed with [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\").\n\n    References: [#7244](https://www.sqlalchemy.org/trac/ticket/7244)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue in future [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") object where the [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute \"sqlalchemy.engine.Connection.execute\") method would not accept a non-dict mapping object, such as SQLAlchemy\u2019s own [`RowMapping`](../core/connections.html#sqlalchemy.engine.RowMapping \"sqlalchemy.engine.RowMapping\") or other `abc.collections.Mapping` object as a parameter dictionary.\n\n    References: [#7291](https://www.sqlalchemy.org/trac/ticket/7291)\n\n*   **[engine] [bug] [regression]**\n\n    Fixed regression where the [`CursorResult.fetchmany()`](../core/connections.html#sqlalchemy.engine.CursorResult.fetchmany \"sqlalchemy.engine.CursorResult.fetchmany\") method would fail to autoclose a server-side cursor (i.e. when `stream_results` or `yield_per` is in use, either Core or ORM oriented results) when the results were fully exhausted.\n\n    References: [#7274](https://www.sqlalchemy.org/trac/ticket/7274)\n\n*   **[engine] [bug]**\n\n    Fixed issue in future [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") where calling upon [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin \"sqlalchemy.engine.Engine.begin\") and entering the context manager would not close the connection if the actual BEGIN operation failed for some reason, such as an event handler raising an exception; this use case failed to be tested for the future version of the engine. Note that the \u201cfuture\u201d context managers which handle `begin()` blocks in Core and ORM don\u2019t actually run the \u201cBEGIN\u201d operation until the context managers are actually entered. This is different from the legacy version which runs the \u201cBEGIN\u201d operation up front.\n\n    References: [#7272](https://www.sqlalchemy.org/trac/ticket/7272)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Added `TupleType` to the top level `sqlalchemy` import namespace.\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where the row objects returned for ORM queries, which are now the normal `Row` objects, would not be interpreted by the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_ \"sqlalchemy.sql.expression.ColumnOperators.in_\") operator as tuple values to be broken out into individual bound parameters, and would instead pass them as single values to the driver leading to failures. The change to the \u201cexpanding IN\u201d system now accommodates for the expression already being of type `TupleType` and treats values accordingly if so. In the uncommon case of using \u201ctuple-in\u201d with an untyped statement such as a textual statement with no typing information, a tuple value is detected for values that implement `collections.abc.Sequence`, but that are not `str` or `bytes`, as always when testing for `Sequence`.\n\n    References: [#7292](https://www.sqlalchemy.org/trac/ticket/7292)\n\n*   **[sql] [bug]**\n\n    Fixed issue where using the feature of using a string label for ordering or grouping described at [Ordering or Grouping by a Label](../tutorial/data_select.html#tutorial-order-by-label) would fail to function correctly if used on a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct, when the CTE were embedded inside of an enclosing [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") statement that itself was set up as a scalar subquery.\n\n    References: [#7269](https://www.sqlalchemy.org/trac/ticket/7269)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") construct would no longer be accepted as a target case in the \u201cwhens\u201d list within a [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case \"sqlalchemy.sql.expression.case\") construct. The regression appears related to an attempt to guard against some forms of literal values that were considered to be ambiguous when passed here; however, there\u2019s no reason the target cases shouldn\u2019t be interpreted as open-ended SQL expressions just like anywhere else, and a literal string or tuple will be converted to a bound parameter as would be the case elsewhere.\n\n    References: [#7287](https://www.sqlalchemy.org/trac/ticket/7287)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed issue in [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") where the [`Table.implicit_returning`](../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning \"sqlalchemy.schema.Table\") parameter would not be accommodated correctly when passed along with [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing \"sqlalchemy.schema.Table\") to augment an existing [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\").\n\n    References: [#7295](https://www.sqlalchemy.org/trac/ticket/7295)\n\n### postgresql\n\n*   **[postgresql] [usecase] [asyncpg]**\n\n    Added overridable methods `PGDialect_asyncpg.setup_asyncpg_json_codec` and `PGDialect_asyncpg.setup_asyncpg_jsonb_codec` codec, which handle the required task of registering JSON/JSONB codecs for these datatypes when using asyncpg. The change is that methods are broken out as individual, overridable methods to support third party dialects that need to alter or disable how these particular codecs are set up.\n\n    References: [#7284](https://www.sqlalchemy.org/trac/ticket/7284)\n\n*   **[postgresql] [bug] [asyncpg]**\n\n    Changed the asyncpg dialect to bind the [`Float`](../core/type_basics.html#sqlalchemy.types.Float \"sqlalchemy.types.Float\") type to the \u201cfloat\u201d PostgreSQL type instead of \u201cnumeric\u201d so that the value `float(inf)` can be accommodated. Added test suite support for persistence of the \u201cinf\u201d value.\n\n    References: [#7283](https://www.sqlalchemy.org/trac/ticket/7283)\n\n*   **[postgresql] [pg8000]**\n\n    Improve array handling when using PostgreSQL with the pg8000 dialect.\n\n    References: [#7167](https://www.sqlalchemy.org/trac/ticket/7167)\n\n### mysql\n\n*   **[mysql] [bug] [mariadb]**\n\n    Reorganized the list of reserved words into two separate lists, one for MySQL and one for MariaDB, so that these diverging sets of words can be managed more accurately; adjusted the MySQL/MariaDB dialect to switch among these lists based on either explicitly configured or server-version-detected \u201cMySQL\u201d or \u201cMariaDB\u201d backend. Added all current reserved words through MySQL 8 and current MariaDB versions including recently added keywords like \u201clead\u201d . Pull request courtesy Kevin Kirsche.\n\n    References: [#7167](https://www.sqlalchemy.org/trac/ticket/7167)\n\n*   **[mysql] [bug]**\n\n    Fixed issue in MySQL [`Insert.on_duplicate_key_update()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update \"sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update\") which would render the wrong column name when an expression were used in a VALUES expression. Pull request courtesy Cristian Sabaila.\n\n    References: [#7281](https://www.sqlalchemy.org/trac/ticket/7281)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Adjusted the compiler\u2019s generation of \u201cpost compile\u201d symbols including those used for \u201cexpanding IN\u201d as well as for the \u201cschema translate map\u201d to not be based directly on plain bracketed strings with underscores, as this conflicts directly with SQL Server\u2019s quoting format of also using brackets, which produces false matches when the compiler replaces \u201cpost compile\u201d and \u201cschema translate\u201d symbols. The issue created easy to reproduce examples both with the [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names \"sqlalchemy.engine.reflection.Inspector.get_schema_names\") method when used in conjunction with the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map \"sqlalchemy.engine.Connection.execution_options\") feature, as well in the unlikely case that a symbol overlapping with the internal name \u201cPOSTCOMPILE\u201d would be used with a feature like \u201cexpanding in\u201d.\n\n    References: [#7300](https://www.sqlalchemy.org/trac/ticket/7300)\n\n## 1.4.26\n\nReleased: October 19, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Improved the exception message generated when configuring a mapping with joined table inheritance where the two tables either have no foreign key relationships set up, or where they have multiple foreign key relationships set up. The message is now ORM specific and includes context that the [`Mapper.inherit_condition`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.inherit_condition \"sqlalchemy.orm.Mapper\") parameter may be needed particularly for the ambiguous foreign keys case.\n\n*   **[orm] [bug]**\n\n    Fixed issue with [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature where ON criteria would not be added to a JOIN for a query of the form `select(A).join(B)`, stating a target while making use of an implicit ON clause.\n\n    References: [#7189](https://www.sqlalchemy.org/trac/ticket/7189)\n\n*   **[orm] [bug]**\n\n    Fixed bug where the ORM \u201cplugin\u201d, necessary for features such as [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") to work correctly, would not be applied to a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") which queried from an ORM column expression if it made use of the [`ColumnElement.label()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label \"sqlalchemy.sql.expression.ColumnElement.label\") modifier.\n\n    References: [#7205](https://www.sqlalchemy.org/trac/ticket/7205)\n\n*   **[orm] [bug]**\n\n    Add missing methods added in [#6991](https://www.sqlalchemy.org/trac/ticket/6991) to [`scoped_session`](../orm/contextual.html#sqlalchemy.orm.scoped_session \"sqlalchemy.orm.scoping.scoped_session\") and [`async_scoped_session()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session \"sqlalchemy.ext.asyncio.async_scoped_session\").\n\n    References: [#7103](https://www.sqlalchemy.org/trac/ticket/7103)\n\n*   **[orm] [bug]**\n\n    An extra layer of warning messages has been added to the functionality of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") and the ORM version of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\"), where a few places where \u201cautomatic aliasing\u201d continues to occur will now be called out as a pattern to avoid, mostly specific to the area of joined table inheritance where classes that share common base tables are being joined together without using explicit aliases. One case emits a legacy warning for a pattern that\u2019s not recommended, the other case is fully deprecated.\n\n    The automatic aliasing within ORM join() which occurs for overlapping mapped tables does not work consistently with all APIs such as [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\"), and rather than continue to try to make these use cases work everywhere, replacing with a more user-explicit pattern is clearer, less prone to bugs and simplifies SQLAlchemy\u2019s internals further.\n\n    The warnings include links to the errors.rst page where each pattern is demonstrated along with the recommended pattern to fix.\n\n    See also\n\n    [An alias is being generated automatically for raw clauseelement](../errors.html#error-xaj1)\n\n    [An alias is being generated automatically due to overlapping tables](../errors.html#error-xaj2)\n\n    References: [#6972](https://www.sqlalchemy.org/trac/ticket/6972), [#6974](https://www.sqlalchemy.org/trac/ticket/6974)\n\n*   **[orm] [bug]**\n\n    Fixed bug where iterating a [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") from a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") after that [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") were closed would partially attach objects to that session in an essentially invalid state. It now raises an exception with a link to new documentation if an **un-buffered** result is iterated from a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that was closed or otherwise had the [`Session.expunge_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge_all \"sqlalchemy.orm.Session.expunge_all\") method called after that [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") was generated. The `prebuffer_rows` execution option, as is used automatically by the asyncio extension for client-side result sets, may be used to produce a [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") where the ORM objects are prebuffered, and in this case iterating the result will produce a series of detached objects.\n\n    See also\n\n    [Object cannot be converted to \u2018persistent\u2019 state, as this identity map is no longer valid.](../errors.html#error-lkrp)\n\n    References: [#7128](https://www.sqlalchemy.org/trac/ticket/7128)\n\n*   **[orm] [bug]**\n\n    Related to [#7153](https://www.sqlalchemy.org/trac/ticket/7153), fixed an issue where result column lookups would fail for \u201cadapted\u201d SELECT statements that selected for \u201cconstant\u201d value expressions most typically the NULL expression, as would occur in such places as joined eager loading in conjunction with limit/offset. This was overall a regression due to issue [#6259](https://www.sqlalchemy.org/trac/ticket/6259) which removed all \u201cadaption\u201d for constants like NULL, \u201ctrue\u201d, and \u201cfalse\u201d when rewriting expressions in a SQL statement, but this broke the case where the same adaption logic were used to resolve the constant to a labeled expression for the purposes of result set targeting.\n\n    References: [#7154](https://www.sqlalchemy.org/trac/ticket/7154)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where ORM loaded objects could not be pickled in cases where loader options making use of `\"*\"` were used in certain combinations, such as combining the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") loader strategy with `raiseload('*')` of sub-elements.\n\n    References: [#7134](https://www.sqlalchemy.org/trac/ticket/7134)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the use of a [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property \"sqlalchemy.ext.hybrid.hybrid_property\") attribute or a mapped [`composite()`](../orm/composites.html#sqlalchemy.orm.composite \"sqlalchemy.orm.composite\") attribute as a key passed to the [`Update.values()`](../core/dml.html#sqlalchemy.sql.expression.Update.values \"sqlalchemy.sql.expression.Update.values\") method for an ORM-enabled [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") statement, as well as when using it via the legacy [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update \"sqlalchemy.orm.Query.update\") method, would be processed for incoming ORM/hybrid/composite values within the compilation stage of the UPDATE statement, which meant that in those cases where caching occurred, subsequent invocations of the same statement would no longer receive the correct values. This would include not only hybrids that use the [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression \"sqlalchemy.ext.hybrid.hybrid_property.update_expression\") method, but any use of a plain hybrid attribute as well. For composites, the issue instead caused a non-repeatable cache key to be generated, which would break caching and could fill up the statement cache with repeated statements.\n\n    The [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") construct now handles the processing of key/value pairs passed to [`Update.values()`](../core/dml.html#sqlalchemy.sql.expression.Update.values \"sqlalchemy.sql.expression.Update.values\") and [`Update.ordered_values()`](../core/dml.html#sqlalchemy.sql.expression.Update.ordered_values \"sqlalchemy.sql.expression.Update.ordered_values\") up front when the construct is first generated, before the cache key has been generated so that the key/value pairs are processed each time, and so that the cache key is generated against the individual column/value pairs that will ultimately be used in the statement.\n\n    References: [#7209](https://www.sqlalchemy.org/trac/ticket/7209)\n\n*   **[orm]**\n\n    Passing a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") is not the intended use of this object, and will now raise a deprecation warning.\n\n    References: [#6284](https://www.sqlalchemy.org/trac/ticket/6284)\n\n### examples\n\n*   **[examples] [bug]**\n\n    Repaired the examples in examples/versioned_rows to use SQLAlchemy 1.4 APIs correctly; these examples had been missed when API changes like removing \u201cpassive\u201d from [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified \"sqlalchemy.orm.Session.is_modified\") were made as well as the [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute \"sqlalchemy.orm.SessionEvents.do_orm_execute\") event hook were added.\n\n    References: [#7169](https://www.sqlalchemy.org/trac/ticket/7169)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where the deprecation warning for the [`URL`](../core/engines.html#sqlalchemy.engine.URL \"sqlalchemy.engine.URL\") constructor which indicates that the [`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create \"sqlalchemy.engine.URL.create\") method should be used would not emit if a full positional argument list of seven arguments were passed; additionally, validation of URL arguments will now occur if the constructor is called in this way, which was being skipped previously.\n\n    References: [#7130](https://www.sqlalchemy.org/trac/ticket/7130)\n\n*   **[engine] [bug] [postgresql]**\n\n    The [`Inspector.reflect_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.reflect_table \"sqlalchemy.engine.reflection.Inspector.reflect_table\") method now supports reflecting tables that do not have user defined columns. This allows [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect \"sqlalchemy.schema.MetaData.reflect\") to properly complete reflection on databases that contain such tables. Currently, only PostgreSQL is known to support such a construct among the common database backends.\n\n    References: [#3247](https://www.sqlalchemy.org/trac/ticket/3247)\n\n*   **[engine] [bug]**\n\n    Implemented proper `__reduce__()` methods for all SQLAlchemy exception objects to ensure they all support clean round trips when pickling, as exception objects are often serialized for the purposes of various debugging tools.\n\n    References: [#7077](https://www.sqlalchemy.org/trac/ticket/7077)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where SQL queries using the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group \"sqlalchemy.sql.functions.FunctionElement.within_group\") construct could not be pickled, typically when using the `sqlalchemy.ext.serializer` extension but also for general generic pickling.\n\n    References: [#6520](https://www.sqlalchemy.org/trac/ticket/6520)\n\n*   **[sql] [bug]**\n\n    Repaired issue in new [`HasCTE.cte.nesting`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte.params.nesting \"sqlalchemy.sql.expression.HasCTE.cte\") parameter introduced with [#4123](https://www.sqlalchemy.org/trac/ticket/4123) where a recursive [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") using [`HasCTE.cte.recursive`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte.params.recursive \"sqlalchemy.sql.expression.HasCTE.cte\") in typical conjunction with UNION would not compile correctly. Additionally makes some adjustments so that the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct creates a correct cache key. Pull request courtesy Eric Masseran.\n\n    References: [#4123](https://www.sqlalchemy.org/trac/ticket/4123)\n\n*   **[sql] [bug]**\n\n    Account for the [`table.schema`](../core/selectable.html#sqlalchemy.sql.expression.table.params.schema \"sqlalchemy.sql.expression.table\") parameter passed to the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table \"sqlalchemy.sql.expression.table\") construct, such that it is taken into account when accessing the `TableClause.fullname` attribute.\n\n    References: [#7061](https://www.sqlalchemy.org/trac/ticket/7061)\n\n*   **[sql] [bug]**\n\n    Fixed an inconsistency in the [`ColumnOperators.any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.any_ \"sqlalchemy.sql.expression.ColumnOperators.any_\") / [`ColumnOperators.all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.all_ \"sqlalchemy.sql.expression.ColumnOperators.all_\") functions / methods where the special behavior these functions have of \u201cflipping\u201d the expression such that the \u201cANY\u201d / \u201cALL\u201d expression is always on the right side would not function if the comparison were against the None value, that is, \u201ccolumn.any_() == None\u201d should produce the same SQL expression as \u201cnull() == column.any_()\u201d. Added more docs to clarify this as well, plus mentions that any_() / all_() generally supersede the ARRAY version \u201cany()\u201d / \u201call()\u201d.\n\n    References: [#7140](https://www.sqlalchemy.org/trac/ticket/7140)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed issue where \u201cexpanding IN\u201d would fail to function correctly with datatypes that use the [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression \"sqlalchemy.types.TypeEngine.bind_expression\") method, where the method would need to be applied to each element of the IN expression rather than the overall IN expression itself.\n\n    References: [#7177](https://www.sqlalchemy.org/trac/ticket/7177)\n\n*   **[sql] [bug]**\n\n    Adjusted the \u201ccolumn disambiguation\u201d logic that\u2019s new in 1.4, where the same expression repeated gets an \u201cextra anonymous\u201d label, so that the logic more aggressively deduplicates those labels when the repeated element is the same Python expression object each time, as occurs in cases like when using \u201csingleton\u201d values like [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null \"sqlalchemy.sql.expression.null\"). This is based on the observation that at least some databases (e.g. MySQL, but not SQLite) will raise an error if the same label is repeated inside of a subquery.\n\n    References: [#7153](https://www.sqlalchemy.org/trac/ticket/7153)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue in mypy plugin to improve upon some issues detecting `Enum()` SQL types containing custom Python enumeration classes. Pull request courtesy Hiroshi Ogawa.\n\n    References: [#6435](https://www.sqlalchemy.org/trac/ticket/6435)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Added a \u201cdisconnect\u201d condition for the \u201cSSL SYSCALL error: Bad address\u201d error message as reported by psycopg2\\. Pull request courtesy Zeke Brechtel.\n\n    References: [#5387](https://www.sqlalchemy.org/trac/ticket/5387)\n\n*   **[postgresql] [bug] [regression]**\n\n    Fixed issue where IN expressions against a series of array elements, as can be done with PostgreSQL, would fail to function correctly due to multiple issues within the \u201cexpanding IN\u201d feature of SQLAlchemy Core that was standardized in version 1.4\\. The psycopg2 dialect now makes use of the [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression \"sqlalchemy.types.TypeEngine.bind_expression\") method with [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") to portably apply the correct casts to elements. The asyncpg dialect was not affected by this issue as it applies bind-level casts at the driver level rather than at the compiler level.\n\n    References: [#7177](https://www.sqlalchemy.org/trac/ticket/7177)\n\n### mysql\n\n*   **[mysql] [bug] [mariadb]**\n\n    Fixes to accommodate for the MariaDB 10.6 series, including backwards incompatible changes in both the mariadb-connector Python driver (supported on SQLAlchemy 1.4 only) as well as the native 10.6 client libraries that are used automatically by the mysqlclient DBAPI (applies to both 1.3 and 1.4). The \u201cutf8mb3\u201d encoding symbol is now reported by these client libraries when the encoding is stated as \u201cutf8\u201d, leading to lookup and encoding errors within the MySQL dialect that does not expect this symbol. Updates to both the MySQL base library to accommodate for this utf8mb3 symbol being reported as well as to the test suite. Thanks to Georg Richter for support.\n\n    This change is also **backported** to: 1.3.25\n\n    References: [#7115](https://www.sqlalchemy.org/trac/ticket/7115), [#7136](https://www.sqlalchemy.org/trac/ticket/7136)\n\n*   **[mysql] [bug]**\n\n    Fixed issue in MySQL [`match()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match \"sqlalchemy.dialects.mysql.match\") construct where passing a clause expression such as [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") or other SQL expression for the \u201cagainst\u201d parameter would fail. Pull request courtesy Anton Kovalevich.\n\n    References: [#7144](https://www.sqlalchemy.org/trac/ticket/7144)\n\n*   **[mysql] [bug]**\n\n    Fixed installation issue where the `sqlalchemy.dialects.mysql` module would not be importable if \u201cgreenlet\u201d were not installed.\n\n    References: [#7204](https://www.sqlalchemy.org/trac/ticket/7204)\n\n### mssql\n\n*   **[mssql] [usecase]**\n\n    Added reflection support for SQL Server foreign key options, including \u201cON UPDATE\u201d and \u201cON DELETE\u201d values of \u201cCASCADE\u201d and \u201cSET NULL\u201d.\n\n*   **[mssql] [bug]**\n\n    Fixed issue with [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys \"sqlalchemy.engine.reflection.Inspector.get_foreign_keys\") where foreign keys were omitted if they were established against a unique index instead of a unique constraint.\n\n    References: [#7160](https://www.sqlalchemy.org/trac/ticket/7160)\n\n*   **[mssql] [bug]**\n\n    Fixed issue with [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\") where it would return False if a local temp table with the same name from a different session happened to be returned first when querying tempdb. This is a continuation of [#6910](https://www.sqlalchemy.org/trac/ticket/6910) which accounted for the temp table existing only in the alternate session and not the current one.\n\n    References: [#7168](https://www.sqlalchemy.org/trac/ticket/7168)\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed bug in SQL Server [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET \"sqlalchemy.dialects.mssql.DATETIMEOFFSET\") datatype where the ODBC implementation would not generate the correct DDL, for cases where the type were converted using the `dialect.type_descriptor()` method, the usage of which is illustrated in some documented examples for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\"), though not necessary for most datatypes. Regression was introduced by [#6366](https://www.sqlalchemy.org/trac/ticket/6366). As part of this change, the full list of SQL Server date types have been amended to return a \u201cdialect impl\u201d that generates the same DDL name as the supertype.\n\n    References: [#7129](https://www.sqlalchemy.org/trac/ticket/7129)\n\n## 1.4.25\n\nReleased: September 22, 2021\n\n### platform\n\n*   **[platform] [bug] [regression]**\n\n    Fixed regression due to [#7024](https://www.sqlalchemy.org/trac/ticket/7024) where the reorganization of the \u201cplatform machine\u201d names used by the `greenlet` dependency mis-spelled \u201caarch64\u201d and additionally omitted uppercase \u201cAMD64\u201d as is needed for Windows machines. Pull request courtesy James Dow.\n\n    References: [#7024](https://www.sqlalchemy.org/trac/ticket/7024)\n\n## 1.4.24\n\nReleased: September 22, 2021\n\n### platform\n\n*   **[platform] [bug]**\n\n    Further adjusted the \u201cgreenlet\u201d package specifier in setup.cfg to use a long chain of \u201cor\u201d expressions, so that the comparison of `platform_machine` to a specific identifier matches only the complete string.\n\n    References: [#7024](https://www.sqlalchemy.org/trac/ticket/7024)\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added loader options to [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") and [`AsyncSession.merge()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.merge \"sqlalchemy.ext.asyncio.AsyncSession.merge\") via a new [`Session.merge.options`](../orm/session_api.html#sqlalchemy.orm.Session.merge.params.options \"sqlalchemy.orm.Session.merge\") parameter, which will apply the given loader options to the `get()` used internally by merge, allowing eager loading of relationships etc. to be applied when the merge process loads a new object. Pull request courtesy Daniel Stone.\n\n    References: [#6955](https://www.sqlalchemy.org/trac/ticket/6955)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed ORM issue where column expressions passed to `query()` or ORM-enabled `select()` would be deduplicated on the identity of the object, such as a phrase like `select(A.id, null(), null())` would produce only one \u201cNULL\u201d expression, which previously was not the case in 1.3\\. However, the change also allows for ORM expressions to render as given as well, such as `select(A.data, A.data)` will produce a result row with two columns.\n\n    References: [#6979](https://www.sqlalchemy.org/trac/ticket/6979)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed issue in recently repaired `Query.with_entities()` method where the flag that determines automatic uniquing for legacy ORM `Query` objects only would be set to `True` inappropriately in cases where the `with_entities()` call would be setting the `Query` to return column-only rows, which are not uniqued.\n\n    References: [#6924](https://www.sqlalchemy.org/trac/ticket/6924)\n\n### engine\n\n*   **[engine] [usecase] [asyncio]**\n\n    Improve the interface used by adapted drivers, like the asyncio ones, to access the actual connection object returned by the driver.\n\n    The [`_ConnectionFairy`](../core/pooling.html#sqlalchemy.pool._ConnectionFairy \"sqlalchemy.pool._ConnectionFairy\") object has two new attributes:\n\n    *   `_ConnectionFairy.dbapi_connection` always represents a DBAPI compatible object. For pep-249 drivers, this is the DBAPI connection as it always has been, previously accessed under the `.connection` attribute. For asyncio drivers that SQLAlchemy adapts into a pep-249 interface, the returned object will normally be a SQLAlchemy adaption object called [`AdaptedConnection`](../core/internals.html#sqlalchemy.engine.AdaptedConnection \"sqlalchemy.engine.AdaptedConnection\").\n\n    *   `_ConnectionFairy.driver_connection` always represents the actual connection object maintained by the third party pep-249 DBAPI or async driver in use. For standard pep-249 DBAPIs, this will always be the same object as that of the `dbapi_connection`. For an asyncio driver, it will be the underlying asyncio-only connection object.\n\n    The `.connection` attribute remains available and is now a legacy alias of `.dbapi_connection`.\n\n    See also\n\n    [How do I get at the raw DBAPI connection when using an Engine?](../faq/connections.html#faq-dbapi-connection)\n\n    References: [#6832](https://www.sqlalchemy.org/trac/ticket/6832)\n\n*   **[engine] [usecase] [orm]**\n\n    Added new methods [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars \"sqlalchemy.orm.Session.scalars\"), [`Connection.scalars()`](../core/connections.html#sqlalchemy.engine.Connection.scalars \"sqlalchemy.engine.Connection.scalars\"), [`AsyncSession.scalars()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.scalars \"sqlalchemy.ext.asyncio.AsyncSession.scalars\") and [`AsyncSession.stream_scalars()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream_scalars \"sqlalchemy.ext.asyncio.AsyncSession.stream_scalars\"), which provide a short cut to the use case of receiving a row-oriented [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object and converting it to a [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") object via the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars \"sqlalchemy.engine.Result.scalars\") method, to return a list of values rather than a list of rows. The new methods are analogous to the long existing [`Session.scalar()`](../orm/session_api.html#sqlalchemy.orm.Session.scalar \"sqlalchemy.orm.Session.scalar\") and [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar \"sqlalchemy.engine.Connection.scalar\") methods used to return a single value from the first row only. Pull request courtesy Miguel Grinberg.\n\n    References: [#6990](https://www.sqlalchemy.org/trac/ticket/6990)\n\n*   **[engine] [bug] [regression]**\n\n    Fixed issue where the ability of the [`ConnectionEvents.before_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.before_execute \"sqlalchemy.events.ConnectionEvents.before_execute\") method to alter the SQL statement object passed, returning the new object to be invoked, was inadvertently removed. This behavior has been restored.\n\n    References: [#6913](https://www.sqlalchemy.org/trac/ticket/6913)\n\n*   **[engine] [bug]**\n\n    Ensure that `str()` is called on the an [`URL.create.password`](../core/engines.html#sqlalchemy.engine.URL.create.params.password \"sqlalchemy.engine.URL.create\") argument, allowing usage of objects that implement the `__str__()` method as password attributes. Also clarified that one such object is not appropriate to dynamically change the password for each database connection; the approaches at [Generating dynamic authentication tokens](../core/engines.html#engines-dynamic-tokens) should be used instead.\n\n    References: [#6958](https://www.sqlalchemy.org/trac/ticket/6958)\n\n*   **[engine] [bug]**\n\n    Fixed issue in [`URL`](../core/engines.html#sqlalchemy.engine.URL \"sqlalchemy.engine.URL\") where validation of \u201cdrivername\u201d would not appropriately respond to the `None` value where a string were expected.\n\n    References: [#6983](https://www.sqlalchemy.org/trac/ticket/6983)\n\n*   **[engine] [bug] [postgresql]**\n\n    Fixed issue where an engine that had [`create_engine.implicit_returning`](../core/engines.html#sqlalchemy.create_engine.params.implicit_returning \"sqlalchemy.create_engine\") set to False would fail to function when PostgreSQL\u2019s \u201cfast insertmany\u201d feature were used in conjunction with a `Sequence`, as well as if any kind of \u201cexecutemany\u201d with \u201creturn_defaults()\u201d were used in conjunction with a `Sequence`. Note that PostgreSQL \u201cfast insertmany\u201d uses \u201cRETURNING\u201d by definition, when the SQL statement is passed to the driver; overall, the [`create_engine.implicit_returning`](../core/engines.html#sqlalchemy.create_engine.params.implicit_returning \"sqlalchemy.create_engine\") flag is legacy and has no real use in modern SQLAlchemy, and will be deprecated in a separate change.\n\n    References: [#6963](https://www.sqlalchemy.org/trac/ticket/6963)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Added new parameter [`HasCTE.cte.nesting`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte.params.nesting \"sqlalchemy.sql.expression.HasCTE.cte\") to the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") constructor and [`HasCTE.cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte \"sqlalchemy.sql.expression.HasCTE.cte\") method, which flags the CTE as one which should remain nested within an enclosing CTE, rather than being moved to the top level of the outermost SELECT. While in the vast majority of cases there is no difference in SQL functionality, users have identified various edge-cases where true nesting of CTE constructs is desirable. Much thanks to Eric Masseran for lots of work on this intricate feature.\n\n    References: [#4123](https://www.sqlalchemy.org/trac/ticket/4123)\n\n*   **[sql] [bug]**\n\n    Implemented missing methods in [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement \"sqlalchemy.sql.functions.FunctionElement\") which, while unused, would lead pylint to report them as unimplemented abstract methods.\n\n    References: [#7052](https://www.sqlalchemy.org/trac/ticket/7052)\n\n*   **[sql] [bug]**\n\n    Fixed a two issues where combinations of `select()` and `join()` when adapted to form a copy of the element would not completely copy the state of all column objects associated with subqueries. A key problem this caused is that usage of the [`ClauseElement.params()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.params \"sqlalchemy.sql.expression.ClauseElement.params\") method (which should probably be moved into a legacy category as it is inefficient and error prone) would leave copies of the old [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter \"sqlalchemy.sql.expression.BindParameter\") objects around, leading to issues in correctly setting the parameters at execution time.\n\n    References: [#7055](https://www.sqlalchemy.org/trac/ticket/7055)\n\n*   **[sql] [bug]**\n\n    Fixed issue related to new [`HasCTE.add_cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte \"sqlalchemy.sql.expression.HasCTE.add_cte\") feature where pairing two \u201cINSERT..FROM SELECT\u201d statements simultaneously would lose track of the two independent SELECT statements, leading to the wrong SQL.\n\n    References: [#7036](https://www.sqlalchemy.org/trac/ticket/7036)\n\n*   **[sql] [bug]**\n\n    Fixed issue where using ORM column expressions as keys in the list of dictionaries passed to [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values \"sqlalchemy.sql.expression.Insert.values\") for \u201cmulti-valued insert\u201d would not be processed correctly into the correct column expressions.\n\n    References: [#7060](https://www.sqlalchemy.org/trac/ticket/7060)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue where mypy plugin would crash when interpreting a `query_expression()` construct.\n\n    References: [#6950](https://www.sqlalchemy.org/trac/ticket/6950)\n\n*   **[mypy] [bug]**\n\n    Fixed issue in mypy plugin where columns on a mixin would not be correctly interpreted if the mapped class relied upon a `__tablename__` routine that came from a superclass.\n\n    References: [#6937](https://www.sqlalchemy.org/trac/ticket/6937)\n\n### asyncio\n\n*   **[asyncio] [feature] [mysql]**\n\n    Added initial support for the `asyncmy` asyncio database driver for MySQL and MariaDB. This driver is very new, however appears to be the only current alternative to the `aiomysql` driver which currently appears to be unmaintained and is not working with current Python versions. Much thanks to long2ice for the pull request for this dialect.\n\n    See also\n\n    [asyncmy](../dialects/mysql.html#asyncmy)\n\n    References: [#6993](https://www.sqlalchemy.org/trac/ticket/6993)\n\n*   **[asyncio] [usecase]**\n\n    The [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") now supports overriding which [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") it uses as the proxied instance. A custom `Session` class can be passed using the [`AsyncSession.sync_session_class`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.params.sync_session_class \"sqlalchemy.ext.asyncio.AsyncSession\") parameter or by subclassing the `AsyncSession` and specifying a custom [`AsyncSession.sync_session_class`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.sync_session_class \"sqlalchemy.ext.asyncio.AsyncSession.sync_session_class\").\n\n    References: [#6746](https://www.sqlalchemy.org/trac/ticket/6746)\n\n*   **[asyncio] [bug]**\n\n    Fixed a bug in [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute \"sqlalchemy.ext.asyncio.AsyncSession.execute\") and [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream \"sqlalchemy.ext.asyncio.AsyncSession.stream\") that required `execution_options` to be an instance of `immutabledict` when defined. It now correctly accepts any mapping.\n\n    References: [#6943](https://www.sqlalchemy.org/trac/ticket/6943)\n\n*   **[asyncio] [bug]**\n\n    Added missing `**kw` arguments to the [`AsyncSession.connection()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.connection \"sqlalchemy.ext.asyncio.AsyncSession.connection\") method.\n\n*   **[asyncio] [bug]**\n\n    Deprecate usage of [`scoped_session`](../orm/contextual.html#sqlalchemy.orm.scoped_session \"sqlalchemy.orm.scoped_session\") with asyncio drivers. When using Asyncio the [`async_scoped_session`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session \"sqlalchemy.ext.asyncio.async_scoped_session\") should be used instead.\n\n    References: [#6746](https://www.sqlalchemy.org/trac/ticket/6746)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Qualify `version()` call to avoid shadowing issues if a different search path is configured by the user.\n\n    References: [#6912](https://www.sqlalchemy.org/trac/ticket/6912)\n\n*   **[postgresql] [bug]**\n\n    The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM \"sqlalchemy.dialects.postgresql.ENUM\") datatype is PostgreSQL-native and therefore should not be used with the `native_enum=False` flag. This flag is now ignored if passed to the [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM \"sqlalchemy.dialects.postgresql.ENUM\") datatype and a warning is emitted; previously the flag would cause the type object to fail to function correctly.\n\n    References: [#6106](https://www.sqlalchemy.org/trac/ticket/6106)\n\n### sqlite\n\n*   **[sqlite] [bug]**\n\n    Fixed bug where the error message for SQLite invalid isolation level on the pysqlite driver would fail to indicate that \u201cAUTOCOMMIT\u201d is one of the valid isolation levels.\n\n### mssql\n\n*   **[mssql] [bug] [reflection]**\n\n    Fixed an issue where `sqlalchemy.engine.reflection.has_table()` returned `True` for local temporary tables that actually belonged to a different SQL Server session (connection). An extra check is now performed to ensure that the temp table detected is in fact owned by the current session.\n\n    References: [#6910](https://www.sqlalchemy.org/trac/ticket/6910)\n\n### oracle\n\n*   **[oracle] [performance] [bug]**\n\n    Added a CAST(VARCHAR2(128)) to the \u201ctable name\u201d, \u201cowner\u201d, and other DDL-name parameters as used in reflection queries against Oracle system views such as ALL_TABLES, ALL_TAB_CONSTRAINTS, etc to better enable indexing to take place against these columns, as they previously would be implicitly handled as NVARCHAR2 due to Python\u2019s use of Unicode for strings; these columns are documented in all Oracle versions as being VARCHAR2 with lengths varying from 30 to 128 characters depending on server version. Additionally, test support has been enabled for Unicode-named DDL structures against Oracle databases.\n\n    References: [#4486](https://www.sqlalchemy.org/trac/ticket/4486)\n\n## 1.4.23\n\nReleased: August 18, 2021\n\n### general\n\n*   **[general] [bug]**\n\n    The setup requirements have been modified such `greenlet` is a default requirement only for those platforms that are well known for `greenlet` to be installable and for which there is already a pre-built binary on pypi; the current list is `x86_64 aarch64 ppc64le amd64 win32`. For other platforms, greenlet will not install by default, which should enable installation and test suite running of SQLAlchemy 1.4 on platforms that don\u2019t support `greenlet`, excluding any asyncio features. In order to install with the `greenlet` dependency included on a machine architecture outside of the above list, the `[asyncio]` extra may be included by running `pip install sqlalchemy[asyncio]` which will then attempt to install `greenlet`.\n\n    Additionally, the test suite has been repaired so that tests can complete fully when greenlet is not installed, with appropriate skips for asyncio-related tests.\n\n    References: [#6136](https://www.sqlalchemy.org/trac/ticket/6136)\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added new attribute [`Select.columns_clause_froms`](../core/selectable.html#sqlalchemy.sql.expression.Select.columns_clause_froms \"sqlalchemy.sql.expression.Select.columns_clause_froms\") that will retrieve the FROM list implied by the columns clause of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") statement. This differs from the old [`Select.froms`](../core/selectable.html#sqlalchemy.sql.expression.Select.froms \"sqlalchemy.sql.expression.Select.froms\") collection in that it does not perform any ORM compilation steps, which necessarily deannotate the FROM elements and do things like compute joinedloads etc., which makes it not an appropriate candidate for the [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from \"sqlalchemy.sql.expression.Select.select_from\") method. Additionally adds a new parameter [`Select.with_only_columns.maintain_column_froms`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns.params.maintain_column_froms \"sqlalchemy.sql.expression.Select.with_only_columns\") that transfers this collection to [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from \"sqlalchemy.sql.expression.Select.select_from\") before replacing the columns collection.\n\n    In addition, the [`Select.froms`](../core/selectable.html#sqlalchemy.sql.expression.Select.froms \"sqlalchemy.sql.expression.Select.froms\") is renamed to [`Select.get_final_froms()`](../core/selectable.html#sqlalchemy.sql.expression.Select.get_final_froms \"sqlalchemy.sql.expression.Select.get_final_froms\"), to stress that this collection is not a simple accessor and is instead calculated given the full state of the object, which can be an expensive call when used in an ORM context.\n\n    Additionally fixes a regression involving the `with_only_columns()` function to support applying criteria to column elements that were replaced with either [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns \"sqlalchemy.sql.expression.Select.with_only_columns\") or [`Query.with_entities()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_entities \"sqlalchemy.orm.Query.with_entities\") , which had broken as part of [#6503](https://www.sqlalchemy.org/trac/ticket/6503) released in 1.4.19.\n\n    References: [#6808](https://www.sqlalchemy.org/trac/ticket/6808)\n\n*   **[orm] [bug] [sql]**\n\n    Fixed issue where a bound parameter object that was \u201ccloned\u201d would cause a name conflict in the compiler, if more than one clone of this parameter were used at the same time in a single statement. This could occur in particular with things like ORM single table inheritance queries that indicated the same \u201cdiscriminator\u201d value multiple times in one query.\n\n    References: [#6824](https://www.sqlalchemy.org/trac/ticket/6824)\n\n*   **[orm] [bug]**\n\n    Fixed issue in loader strategies where the use of the [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options \"sqlalchemy.orm.Load.options\") method, particularly when nesting multiple calls, would generate an overly long and more importantly non-deterministic cache key, leading to very large cache keys which were also not allowing efficient cache usage, both in terms of total memory used as well as number of entries used in the cache itself.\n\n    References: [#6869](https://www.sqlalchemy.org/trac/ticket/6869)\n\n*   **[orm] [bug]**\n\n    Revised the means by which the [`ORMExecuteState.user_defined_options`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.user_defined_options \"sqlalchemy.orm.ORMExecuteState.user_defined_options\") accessor receives `UserDefinedOption` and related option objects from the context, with particular emphasis on the \u201cselectinload\u201d on the loader strategy where this previously was not working; other strategies did not have this problem. The objects that are associated with the current query being executed, and not that of a query being cached, are now propagated unconditionally. This essentially separates them out from the \u201cloader strategy\u201d options which are explicitly associated with the compiled state of a query and need to be used in relation to the cached query.\n\n    The effect of this fix is that a user-defined option, such as those used by the dogpile.caching example as well as for other recipes such as defining a \u201cshard id\u201d for the horizontal sharing extension, will be correctly propagated to eager and lazy loaders regardless of whether a cached query was ultimately invoked.\n\n    References: [#6887](https://www.sqlalchemy.org/trac/ticket/6887)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the unit of work would internally use a 2.0-deprecated SQL expression form, emitting a deprecation warning when SQLALCHEMY_WARN_20 were enabled.\n\n    References: [#6812](https://www.sqlalchemy.org/trac/ticket/6812)\n\n*   **[orm] [bug]**\n\n    Fixed issue in [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") where use of the new [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") feature within options that were nested more than one level deep would fail to update bound parameter values that were in the nested criteria, as a side effect of SQL statement caching.\n\n    References: [#6881](https://www.sqlalchemy.org/trac/ticket/6881)\n\n*   **[orm] [bug]**\n\n    Adjusted ORM loader internals to no longer use the \u201clambda caching\u201d system that was added in 1.4, as well as repaired one location that was still using the previous \u201cbaked query\u201d system for a query. The lambda caching system remains an effective way to reduce the overhead of building up queries that have relatively fixed usage patterns. In the case of loader strategies, the queries used are responsible for moving through lots of arbitrary options and criteria, which is both generated and sometimes consumed by end-user code, that make the lambda cache concept not any more efficient than not using it, at the cost of more complexity. In particular the problems noted by [#6881](https://www.sqlalchemy.org/trac/ticket/6881) and [#6887](https://www.sqlalchemy.org/trac/ticket/6887) are made are made considerably less complicated by removing this feature internally.\n\n    References: [#6079](https://www.sqlalchemy.org/trac/ticket/6079), [#6889](https://www.sqlalchemy.org/trac/ticket/6889)\n\n*   **[orm] [bug]**\n\n    Fixed an issue where the [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle \"sqlalchemy.orm.Bundle\") construct would not create proper cache keys, leading to inefficient use of the query cache. This had some impact on the \u201cselectinload\u201d strategy and was identified as part of [#6889](https://www.sqlalchemy.org/trac/ticket/6889).\n\n    References: [#6889](https://www.sqlalchemy.org/trac/ticket/6889)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fix issue in [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") where new [`HasCTE.add_cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte \"sqlalchemy.sql.expression.HasCTE.add_cte\") method added in version 1.4.21 / [#6752](https://www.sqlalchemy.org/trac/ticket/6752) failed to function correctly for \u201ccompound select\u201d structures such as [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union \"sqlalchemy.sql.expression.union\"), [`union_all()`](../core/selectable.html#sqlalchemy.sql.expression.union_all \"sqlalchemy.sql.expression.union_all\"), `except()`, etc. Pull request courtesy Eric Masseran.\n\n    References: [#6752](https://www.sqlalchemy.org/trac/ticket/6752)\n\n*   **[sql] [bug]**\n\n    Fixed an issue in the `CacheKey.to_offline_string()` method used by the dogpile.caching example where attempting to create a proper cache key from the special \u201clambda\u201d query generated by the lazy loader would fail to include the parameter values, leading to an incorrect cache key.\n\n    References: [#6858](https://www.sqlalchemy.org/trac/ticket/6858)\n\n*   **[sql] [bug]**\n\n    Adjusted the \u201cfrom linter\u201d warning feature to accommodate for a chain of joins more than one level deep where the ON clauses don\u2019t explicitly match up the targets, such as an expression such as \u201cON TRUE\u201d. This mode of use is intended to cancel the cartesian product warning simply by the fact that there\u2019s a JOIN from \u201ca to b\u201d, which was not working for the case where the chain of joins had more than one element.\n\n    References: [#6886](https://www.sqlalchemy.org/trac/ticket/6886)\n\n*   **[sql] [bug]**\n\n    Fixed issue in lambda caching system where an element of a query that produces no cache key, like a custom option or clause element, would still populate the expression in the \u201clambda cache\u201d inappropriately.\n\n### schema\n\n*   **[schema] [enum]**\n\n    Unify behaviour `Enum` in native and non-native implementations regarding the accepted values for an enum with aliased elements. When `Enum.omit_aliases` is `False` all values, alias included, are accepted as valid values. When `Enum.omit_aliases` is `True` only non aliased values are accepted as valid values.\n\n    References: [#6146](https://www.sqlalchemy.org/trac/ticket/6146)\n\n### mypy\n\n*   **[mypy] [usecase]**\n\n    Added support for SQLAlchemy classes to be defined in user code using \u201cgeneric class\u201d syntax as defined by `sqlalchemy2-stubs`, e.g. `Column[String]`, without the need for qualifying these constructs within a `TYPE_CHECKING` block by implementing the Python special method `__class_getitem__()`, which allows this syntax to pass without error at runtime.\n\n    References: [#6759](https://www.sqlalchemy.org/trac/ticket/6759), [#6804](https://www.sqlalchemy.org/trac/ticket/6804)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Added the \u201cis_comparison\u201d flag to the PostgreSQL \u201coverlaps\u201d, \u201ccontained_by\u201d, \u201ccontains\u201d operators, so that they work in relevant ORM contexts as well as in conjunction with the \u201cfrom linter\u201d feature.\n\n    References: [#6886](https://www.sqlalchemy.org/trac/ticket/6886)\n\n### mssql\n\n*   **[mssql] [bug] [sql]**\n\n    Fixed issue where the `literal_binds` compiler flag, as used externally to render bound parameters inline, would fail to work when used with a certain class of parameters known as \u201cliteral_execute\u201d, which covers things like LIMIT and OFFSET values for dialects where the drivers don\u2019t allow a bound parameter, such as SQL Server\u2019s \u201cTOP\u201d clause. The issue locally seemed to affect only the MSSQL dialect.\n\n    References: [#6863](https://www.sqlalchemy.org/trac/ticket/6863)\n\n### misc\n\n*   **[bug] [ext]**\n\n    Fixed issue where the horizontal sharding extension would not correctly accommodate for a plain textual SQL statement passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\").\n\n    References: [#6816](https://www.sqlalchemy.org/trac/ticket/6816)\n\n## 1.4.22\n\nReleased: July 21, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in new [`Table.table_valued()`](../core/metadata.html#sqlalchemy.schema.Table.table_valued \"sqlalchemy.schema.Table.table_valued\") method where the resulting `TableValuedColumn` construct would not respond correctly to alias adaptation as is used throughout the ORM, such as for eager loading, polymorphic loading, etc.\n\n    References: [#6775](https://www.sqlalchemy.org/trac/ticket/6775)\n\n*   **[orm] [bug]**\n\n    Fixed issue where usage of the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\") method with an ORM result that included column expressions with unhashable types, such as `JSON` or `ARRAY` using non-tuples would silently fall back to using the `id()` function, rather than raising an error. This now raises an error when the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\") method is used in a 2.0 style ORM query. Additionally, hashability is assumed to be True for result values of unknown type, such as often happens when using SQL functions of unknown return type; if values are truly not hashable then the `hash()` itself will raise.\n\n    For legacy ORM queries, since the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object uniquifies in all cases, the old rules remain in place, which is to use `id()` for result values of unknown type as this legacy uniquing is mostly for the purpose of uniquing ORM entities and not column values.\n\n    References: [#6769](https://www.sqlalchemy.org/trac/ticket/6769)\n\n*   **[orm] [bug]**\n\n    Fixed an issue where clearing of mappers during things like test suite teardowns could cause a \u201cdictionary changed size\u201d warning during garbage collection, due to iteration of a weak-referencing dictionary. A `list()` has been applied to prevent concurrent GC from affecting this operation.\n\n    References: [#6771](https://www.sqlalchemy.org/trac/ticket/6771)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed critical caching issue where the ORM\u2019s persistence feature using INSERT..RETURNING would cache an incorrect query when mixing the \u201cbulk save\u201d and standard \u201cflush\u201d forms of INSERT.\n\n    References: [#6793](https://www.sqlalchemy.org/trac/ticket/6793)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Added some guards against `KeyError` in the event system to accommodate the case that the interpreter is shutting down at the same time [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose \"sqlalchemy.engine.Engine.dispose\") is being called, which would cause stack trace warnings.\n\n    References: [#6740](https://www.sqlalchemy.org/trac/ticket/6740)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where use of the [`case.whens`](../core/sqlelement.html#sqlalchemy.sql.expression.case.params.whens \"sqlalchemy.sql.expression.case\") parameter passing a dictionary positionally and not as a keyword argument would emit a 2.0 deprecation warning, referring to the deprecation of passing a list positionally. The dictionary format of \u201cwhens\u201d, passed positionally, is still supported and was accidentally marked as deprecated.\n\n    References: [#6786](https://www.sqlalchemy.org/trac/ticket/6786)\n\n*   **[sql] [bug]**\n\n    Fixed issue where type-specific bound parameter handlers would not be called upon in the case of using the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values \"sqlalchemy.sql.expression.Insert.values\") method with the Python `None` value; in particular, this would be noticed when using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON \"sqlalchemy.types.JSON\") datatype as well as related PostgreSQL specific types such as [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB \"sqlalchemy.dialects.postgresql.JSONB\") which would fail to encode the Python `None` value into JSON null, however the issue was generalized to any bound parameter handler in conjunction with this specific method of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\").\n\n    References: [#6770](https://www.sqlalchemy.org/trac/ticket/6770)\n\n## 1.4.21\n\nReleased: July 14, 2021\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Modified the approach used for history tracking of scalar object relationships that are not many-to-one, i.e. one-to-one relationships that would otherwise be one-to-many. When replacing a one-to-one value, the \u201cold\u201d value that would be replaced is no longer loaded immediately, and is instead handled during the flush process. This eliminates an historically troublesome lazy load that otherwise often occurs when assigning to a one-to-one attribute, and is particularly troublesome when using \u201clazy=\u2019raise\u2019\u201d as well as asyncio use cases.\n\n    This change does cause a behavioral change within the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set \"sqlalchemy.orm.AttributeEvents.set\") event, which is nonetheless currently documented, which is that the event applied to such a one-to-one attribute will no longer receive the \u201cold\u201d parameter if it is unloaded and the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history \"sqlalchemy.orm.relationship\") flag is not set. As is documented in [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set \"sqlalchemy.orm.AttributeEvents.set\"), if the event handler needs to receive the \u201cold\u201d value when the event fires off, the active_history flag must be established either with the event listener or with the relationship. This is already the behavior with other kinds of attributes such as many-to-one and column value references.\n\n    The change additionally will defer updating a backref on the \u201cold\u201d value in the less common case that the \u201cold\u201d value is locally present in the session, but isn\u2019t loaded on the relationship in question, until the next flush occurs. If this causes an issue, again the normal [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history \"sqlalchemy.orm.relationship\") flag can be set to `True` on the relationship.\n\n    References: [#6708](https://www.sqlalchemy.org/trac/ticket/6708)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused in 1.4.19 due to [#6503](https://www.sqlalchemy.org/trac/ticket/6503) and related involving [`Query.with_entities()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_entities \"sqlalchemy.orm.Query.with_entities\") where the new structure used would be inappropriately transferred to an enclosing [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") when making use of set operations such as [`Query.union()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union \"sqlalchemy.orm.Query.union\"), causing the JOIN instructions within to be applied to the outside query as well.\n\n    References: [#6698](https://www.sqlalchemy.org/trac/ticket/6698)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression which appeared in version 1.4.3 due to [#6060](https://www.sqlalchemy.org/trac/ticket/6060) where rules that limit ORM adaptation of derived selectables interfered with other ORM-adaptation based cases, in this case when applying adaptations for a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") against a mapping which uses a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property \"sqlalchemy.orm.column_property\") which in turn makes use of a scalar select that includes a [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") object of the mapped table.\n\n    References: [#6762](https://www.sqlalchemy.org/trac/ticket/6762)\n\n*   **[orm] [regression]**\n\n    Fixed ORM regression where ad-hoc label names generated for hybrid properties and potentially other similar types of ORM-enabled expressions would usually be propagated outwards through subqueries, allowing the name to be retained in the final keys of the result set even when selecting from subqueries. Additional state is now tracked in this case that isn\u2019t lost when a hybrid is selected out of a Core select / subquery.\n\n    References: [#6718](https://www.sqlalchemy.org/trac/ticket/6718)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Added new method [`HasCTE.add_cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte \"sqlalchemy.sql.expression.HasCTE.add_cte\") to each of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\"), [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert \"sqlalchemy.sql.expression.insert\"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update \"sqlalchemy.sql.expression.update\") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete \"sqlalchemy.sql.expression.delete\") constructs. This method will add the given [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") as an \u201cindependent\u201d CTE of the statement, meaning it renders in the WITH clause above the statement unconditionally even if it is not otherwise referenced in the primary statement. This is a popular use case on the PostgreSQL database where a CTE is used for a DML statement that runs against database rows independently of the primary statement.\n\n    References: [#6752](https://www.sqlalchemy.org/trac/ticket/6752)\n\n*   **[sql] [bug]**\n\n    Fixed issue in CTE constructs where a recursive CTE that referred to a SELECT that has duplicate column names, which are typically deduplicated using labeling logic in 1.4, would fail to refer to the deduplicated label name correctly within the WITH clause.\n\n    References: [#6710](https://www.sqlalchemy.org/trac/ticket/6710)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where the [`tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.tablesample \"sqlalchemy.sql.expression.tablesample\") construct would fail to be executable when constructed given a floating-point sampling value not embedded within a SQL function.\n\n    References: [#6735](https://www.sqlalchemy.org/trac/ticket/6735)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed issue in [`Insert.on_conflict_do_nothing()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing\") and [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") where the name of a unique constraint passed as the `constraint` parameter would not be properly truncated for length if it were based on a naming convention that generated a too-long name for the PostgreSQL max identifier length of 63 characters, in the same way which occurs within a CREATE TABLE statement.\n\n    References: [#6755](https://www.sqlalchemy.org/trac/ticket/6755)\n\n*   **[postgresql] [bug]**\n\n    Fixed issue where the PostgreSQL `ENUM` datatype as embedded in the `ARRAY` datatype would fail to emit correctly in create/drop when the `schema_translate_map` feature were also in use. Additionally repairs a related issue where the same `schema_translate_map` feature would not work for the `ENUM` datatype in combination with a `CAST`, that\u2019s also intrinsic to how the `ARRAY(ENUM)` combination works on the PostgreSQL dialect.\n\n    References: [#6739](https://www.sqlalchemy.org/trac/ticket/6739)\n\n*   **[postgresql] [bug]**\n\n    Fixed issue in [`Insert.on_conflict_do_nothing()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing\") and [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") where the name of a unique constraint passed as the `constraint` parameter would not be properly quoted if it contained characters which required quoting.\n\n    References: [#6696](https://www.sqlalchemy.org/trac/ticket/6696)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression where the special dotted-schema name handling for the SQL Server dialect would not function correctly if the dotted schema name were used within the `schema_translate_map` feature.\n\n    References: [#6697](https://www.sqlalchemy.org/trac/ticket/6697)\n\n## 1.4.20\n\nReleased: June 28, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in ORM regarding an internal reconstitution step for the [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") construct, when the user-facing object is garbage collected as the query is processed. The reconstitution was not ensuring the sub-entities for the \u201cpolymorphic\u201d case were handled, leading to an `AttributeError`.\n\n    References: [#6680](https://www.sqlalchemy.org/trac/ticket/6680)\n\n*   **[orm] [bug] [regression]**\n\n    Adjusted [`Query.union()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union \"sqlalchemy.orm.Query.union\") and similar set operations to be correctly compatible with the new capabilities just added in [#6661](https://www.sqlalchemy.org/trac/ticket/6661), with SQLAlchemy 1.4.19, such that the SELECT statements rendered as elements of the UNION or other set operation will include directly mapped columns that are mapped as deferred; this both fixes a regression involving unions with multiple levels of nesting that would produce a column mismatch, and also allows the [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer \"sqlalchemy.orm.undefer\") option to be used at the top level of such a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") without having to apply the option to each of the elements within the UNION.\n\n    References: [#6678](https://www.sqlalchemy.org/trac/ticket/6678)\n\n*   **[orm] [bug]**\n\n    Adjusted the check in the mapper for a callable object that is used as a `@validates` validator function or a `@reconstructor` reconstruction function, to check for \u201ccallable\u201d more liberally such as to accommodate objects based on fundamental attributes like `__func__` and `__call__`, rather than testing for `MethodType` / `FunctionType`, allowing things like cython functions to work properly. Pull request courtesy Mi\u0142osz Stypi\u0144ski.\n\n    References: [#6538](https://www.sqlalchemy.org/trac/ticket/6538)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed an issue in the C extension for the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") class which could lead to a memory leak in the unlikely case of a [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object which referred to an ORM object that then was mutated to refer back to the `Row` itself, creating a cycle. The Python C APIs for tracking GC cycles has been added to the native [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") implementation to accommodate for this case.\n\n    References: [#5348](https://www.sqlalchemy.org/trac/ticket/5348)\n\n*   **[engine] [bug]**\n\n    Fixed old issue where a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") made against the token \u201c*\u201d, which then yielded exactly one column, would fail to correctly organize the `cursor.description` column name into the keys of the result object.\n\n    References: [#6665](https://www.sqlalchemy.org/trac/ticket/6665)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Add a impl parameter to [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType \"sqlalchemy.types.PickleType\") constructor, allowing any arbitrary type to be used in place of the default implementation of [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary \"sqlalchemy.types.LargeBinary\"). Pull request courtesy jason3gb.\n\n    References: [#6646](https://www.sqlalchemy.org/trac/ticket/6646)\n\n*   **[sql] [bug] [orm]**\n\n    Fixed the class hierarchy for the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") and the more general [`DefaultGenerator`](../core/defaults.html#sqlalchemy.schema.DefaultGenerator \"sqlalchemy.schema.DefaultGenerator\") base, as these are \u201cexecutable\u201d as statements they need to include [`Executable`](../core/selectable.html#sqlalchemy.sql.expression.Executable \"sqlalchemy.sql.expression.Executable\") in their hierarchy, not just `StatementRole` as was applied arbitrarily to [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") previously. The fix allows [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") to work in all `.execute()` methods including with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") which was not working in the case that a [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute \"sqlalchemy.orm.SessionEvents.do_orm_execute\") handler was also established.\n\n    References: [#6668](https://www.sqlalchemy.org/trac/ticket/6668)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed issue where passing `None` for the value of [`Table.prefixes`](../core/metadata.html#sqlalchemy.schema.Table.params.prefixes \"sqlalchemy.schema.Table\") would not store an empty list, but rather the constant `None`, which may be unexpected by third party dialects. The issue is revealed by a usage in recent versions of Alembic that are passing `None` for this value. Pull request courtesy Kai Mueller.\n\n    References: [#6685](https://www.sqlalchemy.org/trac/ticket/6685)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Made a small adjustment in the table reflection feature of the MySQL dialect to accommodate for alternate MySQL-oriented databases such as TiDB which include their own \u201ccomment\u201d directives at the end of a constraint directive within \u201cCREATE TABLE\u201d where the format doesn\u2019t have the additional space character after the comment, in this case the TiDB \u201cclustered index\u201d feature. Pull request courtesy Dani\u00ebl van Eeden.\n\n    References: [#6659](https://www.sqlalchemy.org/trac/ticket/6659)\n\n### misc\n\n*   **[bug] [ext] [regression]**\n\n    Fixed regression in [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap \"sqlalchemy.ext.automap\") extension such that the use case of creating an explicit mapped class to a table that is also the [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary \"sqlalchemy.orm.relationship\") element of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") that automap will be generating would emit the \u201coverlaps\u201d warnings introduced in 1.4 and discussed at [relationship X will copy column Q to column P, which conflicts with relationship(s): \u2018Y\u2019](../errors.html#error-qzyx). While generating this case from automap is still subject to the same caveats mentioned in the \u2018overlaps\u2019 warning, since automap is primarily intended for more ad-hoc use cases, the condition triggering the warning is disabled when a many-to-many relationship with this specific pattern is generated.\n\n    References: [#6679](https://www.sqlalchemy.org/trac/ticket/6679)\n\n## 1.4.19\n\nReleased: June 22, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed further regressions in the same area as that of [#6052](https://www.sqlalchemy.org/trac/ticket/6052) where loader options as well as invocations of methods like [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") would fail if the left side of the statement for which the option/join depends upon were replaced by using the [`Query.with_entities()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_entities \"sqlalchemy.orm.Query.with_entities\") method, or when using 2.0 style queries when using the [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns \"sqlalchemy.sql.expression.Select.with_only_columns\") method. A new set of state has been added to the objects which tracks the \u201cleft\u201d entities that the options / join were made against which is memoized when the lead entities are changed.\n\n    References: [#6253](https://www.sqlalchemy.org/trac/ticket/6253), [#6503](https://www.sqlalchemy.org/trac/ticket/6503)\n\n*   **[orm] [bug]**\n\n    Refined the behavior of ORM subquery rendering with regards to deferred columns and column properties to be more compatible with that of 1.3 while also providing for 1.4\u2019s newer features. As a subquery in 1.4 does not make use of loader options, including [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer \"sqlalchemy.orm.undefer\"), a subquery that is against an ORM entity with deferred attributes will now render those deferred attributes that refer directly to mapped table columns, as these are needed in the outer SELECT if that outer SELECT makes use of these columns; however a deferred attribute that refers to a composed SQL expression as we normally do with [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property \"sqlalchemy.orm.column_property\") will not be part of the subquery, as these can be selected explicitly if needed in the subquery. If the entity is being SELECTed from this subquery, the column expression can still render on \u201cthe outside\u201d in terms of the derived subquery columns. This produces essentially the same behavior as when working with 1.3\\. However in this case the fix has to also make sure that the `.selected_columns` collection of an ORM-enabled [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") also follows these rules, which in particular allows recursive CTEs to render correctly in this scenario, which were previously failing to render correctly due to this issue.\n\n    References: [#6661](https://www.sqlalchemy.org/trac/ticket/6661)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue in CTE constructs mostly relevant to ORM use cases where a recursive CTE against \u201canonymous\u201d labels such as those seen in ORM `column_property()` mappings would render in the `WITH RECURSIVE xyz(...)` section as their raw internal label and not a cleanly anonymized name.\n\n    References: [#6663](https://www.sqlalchemy.org/trac/ticket/6663)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue in mypy plugin where class info for a custom declarative base would not be handled correctly on a cached mypy pass, leading to an AssertionError being raised.\n\n    References: [#6476](https://www.sqlalchemy.org/trac/ticket/6476)\n\n### asyncio\n\n*   **[asyncio] [usecase]**\n\n    Implemented [`async_scoped_session`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session \"sqlalchemy.ext.asyncio.async_scoped_session\") to address some asyncio-related incompatibilities between [`scoped_session`](../orm/contextual.html#sqlalchemy.orm.scoped_session \"sqlalchemy.orm.scoped_session\") and [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"), in which some methods (notably the [`async_scoped_session.remove()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session.remove \"sqlalchemy.ext.asyncio.async_scoped_session.remove\") method) should be used with the `await` keyword.\n\n    See also\n\n    [Using asyncio scoped session](../orm/extensions/asyncio.html#asyncio-scoped-session)\n\n    References: [#6583](https://www.sqlalchemy.org/trac/ticket/6583)\n\n*   **[asyncio] [bug] [postgresql]**\n\n    Fixed bug in asyncio implementation where the greenlet adaptation system failed to propagate `BaseException` subclasses, most notably including `asyncio.CancelledError`, to the exception handling logic used by the engine to invalidate and clean up the connection, thus preventing connections from being correctly disposed when a task was cancelled.\n\n    References: [#6652](https://www.sqlalchemy.org/trac/ticket/6652)\n\n### postgresql\n\n*   **[postgresql] [bug] [oracle]**\n\n    Fixed issue where the `INTERVAL` datatype on PostgreSQL and Oracle would produce an `AttributeError` when used in the context of a comparison operation against a `timedelta()` object. Pull request courtesy MajorDallas.\n\n    References: [#6649](https://www.sqlalchemy.org/trac/ticket/6649)\n\n*   **[postgresql] [bug]**\n\n    Fixed issue where the pool \u201cpre ping\u201d feature would implicitly start a transaction, which would then interfere with custom transactional flags such as PostgreSQL\u2019s \u201cread only\u201d mode when used with the psycopg2 driver.\n\n    References: [#6621](https://www.sqlalchemy.org/trac/ticket/6621)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Added new construct [`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match \"sqlalchemy.dialects.mysql.match\"), which provides for the full range of MySQL\u2019s MATCH operator including multiple column support and modifiers. Pull request courtesy Anton Kovalevich.\n\n    See also\n\n    [`match`](../dialects/mysql.html#sqlalchemy.dialects.mysql.match \"sqlalchemy.dialects.mysql.match\")\n\n    References: [#6132](https://www.sqlalchemy.org/trac/ticket/6132)\n\n### mssql\n\n*   **[mssql] [change]**\n\n    Made improvements to the server version regexp used by the pymssql dialect to prevent a regexp overflow in case of an invalid version string.\n\n    References: [#6253](https://www.sqlalchemy.org/trac/ticket/6253), [#6503](https://www.sqlalchemy.org/trac/ticket/6503)\n\n*   **[mssql] [bug]**\n\n    Fixed bug where the \u201cschema_translate_map\u201d feature would fail to function correctly in conjunction with an INSERT into a table that has an IDENTITY column, where the value of the IDENTITY column were specified in the values of the INSERT thus triggering SQLAlchemy\u2019s feature of setting IDENTITY INSERT to \u201con\u201d; it\u2019s in this directive where the schema translate map would fail to be honored.\n\n    References: [#6658](https://www.sqlalchemy.org/trac/ticket/6658)\n\n## 1.4.18\n\nReleased: June 10, 2021\n\n### orm\n\n*   **[orm] [performance] [bug] [regression]**\n\n    Fixed regression involving how the ORM would resolve a given mapped column to a result row, where under cases such as joined eager loading, a slightly more expensive \u201cfallback\u201d could take place to set up this resolution due to some logic that was removed since 1.3\\. The issue could also cause deprecation warnings involving column resolution to be emitted when using a 1.4 style query with joined eager loading.\n\n    References: [#6596](https://www.sqlalchemy.org/trac/ticket/6596)\n\n*   **[orm] [bug]**\n\n    Clarified the current purpose of the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries \"sqlalchemy.orm.relationship\") flag, which in 1.4 is to enable or disable \u201clambda caching\u201d of statements within the \u201clazyload\u201d and \u201cselectinload\u201d loader strategies; this is separate from the more foundational SQL query cache that is used for most statements. Additionally, the lazy loader no longer uses its own cache for many-to-one SQL queries, which was an implementation quirk that doesn\u2019t exist for any other loader scenario. Finally, the \u201clru cache\u201d warning that the lazyloader and selectinloader strategies could emit when handling a wide array of class/relationship combinations has been removed; based on analysis of some end-user cases, this warning doesn\u2019t suggest any significant issue. While setting `bake_queries=False` for such a relationship will remove this cache from being used, there\u2019s no particular performance gain in this case as using no caching vs. using a cache that needs to refresh often likely still wins out on the caching being used side.\n\n    References: [#6072](https://www.sqlalchemy.org/trac/ticket/6072), [#6487](https://www.sqlalchemy.org/trac/ticket/6487)\n\n*   **[orm] [bug] [regression]**\n\n    Adjusted the means by which classes such as [`scoped_session`](../orm/contextual.html#sqlalchemy.orm.scoped_session \"sqlalchemy.orm.scoped_session\") and [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") are generated from the base [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") class, such that custom [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") subclasses such as that used by Flask-SQLAlchemy don\u2019t need to implement positional arguments when they call into the superclass method, and can continue using the same argument styles as in previous releases.\n\n    References: [#6285](https://www.sqlalchemy.org/trac/ticket/6285)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed issue where query production for joinedload against a complex left hand side involving joined-table inheritance could fail to produce a correct query, due to a clause adaption issue.\n\n    References: [#6595](https://www.sqlalchemy.org/trac/ticket/6595)\n\n*   **[orm] [bug]**\n\n    Fixed issue in experimental \u201cselect ORM objects from INSERT/UPDATE\u201d use case where an error was raised if the statement were against a single-table-inheritance subclass.\n\n    References: [#6591](https://www.sqlalchemy.org/trac/ticket/6591)\n\n*   **[orm] [bug]**\n\n    The warning that\u2019s emitted for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") when multiple relationships would overlap with each other as far as foreign key attributes written towards, now includes the specific \u201coverlaps\u201d argument to use for each warning in order to silence the warning without changing the mapping.\n\n    References: [#6400](https://www.sqlalchemy.org/trac/ticket/6400)\n\n### asyncio\n\n*   **[asyncio] [usecase]**\n\n    Implemented a new registry architecture that allows the `Async` version of an object, like `AsyncSession`, `AsyncConnection`, etc., to be locatable given the proxied \u201csync\u201d object, i.e. `Session`, `Connection`. Previously, to the degree such lookup functions were used, an `Async` object would be re-created each time, which was less than ideal as the identity and state of the \u201casync\u201d object would not be preserved across calls.\n\n    From there, new helper functions [`async_object_session()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_object_session \"sqlalchemy.ext.asyncio.async_object_session\"), [`async_session()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_session \"sqlalchemy.ext.asyncio.async_session\") as well as a new [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState \"sqlalchemy.orm.InstanceState\") attribute [`InstanceState.async_session`](../orm/internals.html#sqlalchemy.orm.InstanceState.async_session \"sqlalchemy.orm.InstanceState.async_session\") have been added, which are used to retrieve the original [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") associated with an ORM mapped object, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") associated with an [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"), and an [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") associated with an [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState \"sqlalchemy.orm.InstanceState\"), respectively.\n\n    This patch also implements new methods [`AsyncSession.in_nested_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.in_nested_transaction \"sqlalchemy.ext.asyncio.AsyncSession.in_nested_transaction\"), [`AsyncSession.get_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get_transaction \"sqlalchemy.ext.asyncio.AsyncSession.get_transaction\"), [`AsyncSession.get_nested_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get_nested_transaction \"sqlalchemy.ext.asyncio.AsyncSession.get_nested_transaction\").\n\n    References: [#6319](https://www.sqlalchemy.org/trac/ticket/6319)\n\n*   **[asyncio] [bug]**\n\n    Fixed an issue that presented itself when using the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool \"sqlalchemy.pool.NullPool\") or the [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool \"sqlalchemy.pool.StaticPool\") with an async engine. This mostly affected the aiosqlite dialect.\n\n    References: [#6575](https://www.sqlalchemy.org/trac/ticket/6575)\n\n*   **[asyncio] [bug]**\n\n    Added `asyncio.exceptions.TimeoutError`, `asyncio.exceptions.CancelledError` as so-called \u201cexit exceptions\u201d, a class of exceptions that include things like `GreenletExit` and `KeyboardInterrupt`, which are considered to be events that warrant considering a DBAPI connection to be in an unusable state where it should be recycled.\n\n    References: [#6592](https://www.sqlalchemy.org/trac/ticket/6592)\n\n### postgresql\n\n*   **[postgresql] [bug] [regression]**\n\n    Fixed regression where using the PostgreSQL \u201cINSERT..ON CONFLICT\u201d structure would fail to work with the psycopg2 driver if it were used in an \u201cexecutemany\u201d context along with bound parameters in the \u201cSET\u201d clause, due to the implicit use of the psycopg2 fast execution helpers which are not appropriate for this style of INSERT statement; as these helpers are the default in 1.4 this is effectively a regression. Additional checks to exclude this kind of statement from that particular extension have been added.\n\n    References: [#6581](https://www.sqlalchemy.org/trac/ticket/6581)\n\n### sqlite\n\n*   **[sqlite] [bug]**\n\n    Add note regarding encryption-related pragmas for pysqlcipher passed in the url.\n\n    This change is also **backported** to: 1.3.25\n\n    References: [#6589](https://www.sqlalchemy.org/trac/ticket/6589)\n\n*   **[sqlite] [bug] [regression]**\n\n    The fix for pysqlcipher released in version 1.4.3 [#5848](https://www.sqlalchemy.org/trac/ticket/5848) was unfortunately non-working, in that the new `on_connect_url` hook was erroneously not receiving a `URL` object under normal usage of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine \"sqlalchemy.create_engine\") and instead received a string that was unhandled; the test suite failed to fully set up the actual conditions under which this hook is called. This has been fixed.\n\n    References: [#6586](https://www.sqlalchemy.org/trac/ticket/6586)\n\n## 1.4.17\n\nReleased: May 29, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by just-released performance fix mentioned in #6550 where a query.join() to a relationship could produce an AttributeError if the query were made against non-ORM structures only, a fairly unusual calling pattern.\n\n    References: [#6558](https://www.sqlalchemy.org/trac/ticket/6558)\n\n## 1.4.16\n\nReleased: May 28, 2021\n\n### general\n\n*   **[general] [bug]**\n\n    Resolved various deprecation warnings which were appearing as of Python version 3.10.0b1.\n\n    References: [#6540](https://www.sqlalchemy.org/trac/ticket/6540), [#6543](https://www.sqlalchemy.org/trac/ticket/6543)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue when using [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs \"sqlalchemy.orm.relationship\") parameter set to `False`, which per [cascade_backrefs behavior deprecated for removal in 2.0](migration_14.html#change-5150) is set to become the standard behavior in SQLAlchemy 2.0, where adding the item to a collection that uniquifies, such as `set` or `dict` would fail to fire a cascade event if the object were already associated in that collection via the backref. This fix represents a fundamental change in the collection mechanics by introducing a new event state which can fire off for a collection mutation even if there is no net change on the collection; the action is now suited using a new event hook [`AttributeEvents.append_wo_mutation()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append_wo_mutation \"sqlalchemy.orm.AttributeEvents.append_wo_mutation\").\n\n    References: [#6471](https://www.sqlalchemy.org/trac/ticket/6471)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression involving clause adaption of labeled ORM compound elements, such as single-table inheritance discriminator expressions with conditionals or CASE expressions, which could cause aliased expressions such as those used in ORM join / joinedload operations to not be adapted correctly, such as referring to the wrong table in the ON clause in a join.\n\n    This change also improves a performance bump that was located within the process of invoking [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") given an ORM attribute as a target.\n\n    References: [#6550](https://www.sqlalchemy.org/trac/ticket/6550)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the full combination of joined inheritance, global with_polymorphic, self-referential relationship and joined loading would fail to be able to produce a query with the scope of lazy loads and object refresh operations that also attempted to render the joined loader.\n\n    References: [#6495](https://www.sqlalchemy.org/trac/ticket/6495)\n\n*   **[orm] [bug]**\n\n    Enhanced the bind resolution rules for [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") so that when a non-ORM statement such as an [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert \"sqlalchemy.sql.expression.insert\") construct nonetheless is built against ORM objects, to the greatest degree possible the ORM entity will be used to resolve the bind, such as for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that has a bind map set up on a common superclass without specific mappers or tables named in the map.\n\n    References: [#6484](https://www.sqlalchemy.org/trac/ticket/6484)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where an `@` sign in the database portion of a URL would not be interpreted correctly if the URL also had a username:password section.\n\n    References: [#6482](https://www.sqlalchemy.org/trac/ticket/6482)\n\n*   **[engine] [bug]**\n\n    Fixed a long-standing issue with [`URL`](../core/engines.html#sqlalchemy.engine.URL \"sqlalchemy.engine.URL\") where query parameters following the question mark would not be parsed correctly if the URL did not contain a database portion with a backslash.\n\n    References: [#6329](https://www.sqlalchemy.org/trac/ticket/6329)\n\n### sql\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression in dynamic loader strategy and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") overall where the [`relationship.order_by`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.order_by \"sqlalchemy.orm.relationship\") parameter were stored as a mutable list, which could then be mutated when combined with additional \u201corder_by\u201d methods used against the dynamic query object, causing the ORDER BY criteria to continue to grow repetitively.\n\n    References: [#6549](https://www.sqlalchemy.org/trac/ticket/6549)\n\n### mssql\n\n*   **[mssql] [usecase]**\n\n    Implemented support for a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct to be used directly as the target of a [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete \"sqlalchemy.sql.expression.delete\") construct, i.e. \u201cWITH \u2026 AS cte DELETE FROM cte\u201d. This appears to be a useful feature of SQL Server.\n\n    References: [#6464](https://www.sqlalchemy.org/trac/ticket/6464)\n\n### misc\n\n*   **[bug] [ext]**\n\n    Fixed a deprecation warning that was emitted when using [`automap_base()`](../orm/extensions/automap.html#sqlalchemy.ext.automap.automap_base \"sqlalchemy.ext.automap.automap_base\") without passing an existing `Base`.\n\n    References: [#6529](https://www.sqlalchemy.org/trac/ticket/6529)\n\n*   **[bug] [pep484]**\n\n    Remove pep484 types from the code. Current effort is around the stub package, and having typing in two places makes thing worse, since the types in the SQLAlchemy source were usually outdated compared to the version in the stubs.\n\n    References: [#6461](https://www.sqlalchemy.org/trac/ticket/6461)\n\n*   **[bug] [ext] [regression]**\n\n    Fixed regression in the `sqlalchemy.ext.instrumentation` extension that prevented instrumentation disposal from working completely. This fix includes both a 1.4 regression fix as well as a fix for a related issue that existed in 1.3 also. As part of this change, the [`sqlalchemy.ext.instrumentation.InstrumentationManager`](../orm/extensions/instrumentation.html#sqlalchemy.ext.instrumentation.InstrumentationManager \"sqlalchemy.ext.instrumentation.InstrumentationManager\") class now has a new method `unregister()`, which replaces the previous method `dispose()`, which was not called as of version 1.4.\n\n    References: [#6390](https://www.sqlalchemy.org/trac/ticket/6390)\n\n## 1.4.15\n\nReleased: May 11, 2021\n\n### general\n\n*   **[general] [feature]**\n\n    A new approach has been applied to the warnings system in SQLAlchemy to accurately predict the appropriate stack level for each warning dynamically. This allows evaluating the source of SQLAlchemy-generated warnings and deprecation warnings to be more straightforward as the warning will indicate the source line within end-user code, rather than from an arbitrary level within SQLAlchemy\u2019s own source code.\n\n    References: [#6241](https://www.sqlalchemy.org/trac/ticket/6241)\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed additional regression caused by \u201ceager loaders run on unexpire\u201d feature [#1763](https://www.sqlalchemy.org/trac/ticket/1763) where the feature would run for a `contains_eager()` eagerload option in the case that the `contains_eager()` were chained to an additional eager loader option, which would then produce an incorrect query as the original query-bound join criteria were no longer present.\n\n    References: [#6449](https://www.sqlalchemy.org/trac/ticket/6449)\n\n*   **[orm] [bug]**\n\n    Fixed issue in subquery loader strategy which prevented caching from working correctly. This would have been seen in the logs as a \u201cgenerated\u201d message instead of \u201ccached\u201d for all subqueryload SQL emitted, which by saturating the cache with new keys would degrade overall performance; it also would produce \u201cLRU size alert\u201d warnings.\n\n    References: [#6459](https://www.sqlalchemy.org/trac/ticket/6459)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Adjusted the logic added as part of [#6397](https://www.sqlalchemy.org/trac/ticket/6397) in 1.4.12 so that internal mutation of the [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter \"sqlalchemy.sql.expression.BindParameter\") object occurs within the clause construction phase as it did before, rather than in the compilation phase. In the latter case, the mutation still produced side effects against the incoming construct and additionally could potentially interfere with other internal mutation routines.\n\n    References: [#6460](https://www.sqlalchemy.org/trac/ticket/6460)\n\n### mysql\n\n*   **[mysql] [bug] [documentation]**\n\n    Added support for the `ssl_check_hostname=` parameter in mysql connection URIs and updated the mysql dialect documentation regarding secure connections. Original pull request courtesy of Jerry Zhao.\n\n    References: [#5397](https://www.sqlalchemy.org/trac/ticket/5397)\n\n## 1.4.14\n\nReleased: May 6, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression involving `lazy='dynamic'` loader in conjunction with a detached object. The previous behavior was that the dynamic loader upon calling methods like `.all()` returns empty lists for detached objects without error, this has been restored; however a warning is now emitted as this is not the correct result. Other dynamic loader scenarios correctly raise `DetachedInstanceError`.\n\n    References: [#6426](https://www.sqlalchemy.org/trac/ticket/6426)\n\n### engine\n\n*   **[engine] [usecase] [orm]**\n\n    Applied consistent behavior to the use case of calling `.commit()` or `.rollback()` inside of an existing `.begin()` context manager, with the addition of potentially emitting SQL within the block subsequent to the commit or rollback. This change continues upon the change first added in [#6155](https://www.sqlalchemy.org/trac/ticket/6155) where the use case of calling \u201crollback\u201d inside of a `.begin()` contextmanager block was proposed:\n\n    *   calling `.commit()` or `.rollback()` will now be allowed without error or warning within all scopes, including that of legacy and future [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\"), ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\"), asyncio [`AsyncEngine`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine \"sqlalchemy.ext.asyncio.AsyncEngine\"). Previously, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") disallowed this.\n\n    *   The remaining scope of the context manager is then closed; when the block ends, a check is emitted to see if the transaction was already ended, and if so the block returns without action.\n\n    *   It will now raise **an error** if subsequent SQL of any kind is emitted within the block, **after** `.commit()` or `.rollback()` is called. The block should be closed as the state of the executable object would otherwise be undefined in this state.\n\n    References: [#6288](https://www.sqlalchemy.org/trac/ticket/6288)\n\n*   **[engine] [bug] [regression]**\n\n    Established a deprecation path for calling upon the `CursorResult.keys()` method for a statement that returns no rows to provide support for legacy patterns used by the \u201crecords\u201d package as well as any other non-migrated applications. Previously, this would raise `ResourceClosedException` unconditionally in the same way as it does when attempting to fetch rows. While this is the correct behavior going forward, the `LegacyCursorResult` object will now in this case return an empty list for `.keys()` as it did in 1.3, while also emitting a 2.0 deprecation warning. The `_cursor.CursorResult`, used when using a 2.0-style \u201cfuture\u201d engine, will continue to raise as it does now.\n\n    References: [#6427](https://www.sqlalchemy.org/trac/ticket/6427)\n\n### sql\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by the \u201cempty in\u201d change just made in [#6397](https://www.sqlalchemy.org/trac/ticket/6397) 1.4.12 where the expression needs to be parenthesized for the \u201cnot in\u201d use case, otherwise the condition will interfere with the other filtering criteria.\n\n    References: [#6428](https://www.sqlalchemy.org/trac/ticket/6428)\n\n*   **[sql] [bug] [regression]**\n\n    The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\") class will now emit a warning when used in SQL compilation with caching unless the `.cache_ok` flag is set to `True` or `False`. A new class-level attribute [`TypeDecorator.cache_ok`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.cache_ok \"sqlalchemy.types.TypeDecorator.cache_ok\") may be set which will be used as an indication that all the parameters passed to the object are safe to be used as a cache key if set to `True`, `False` means they are not.\n\n    References: [#6436](https://www.sqlalchemy.org/trac/ticket/6436)\n\n## 1.4.13\n\nReleased: May 3, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in `selectinload` loader strategy that would cause it to cache its internal state incorrectly when handling relationships that join across more than one column, such as when using a composite foreign key. The invalid caching would then cause other unrelated loader operations to fail.\n\n    References: [#6410](https://www.sqlalchemy.org/trac/ticket/6410)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") would not work if the lead entity were a SQL function or other expression derived from the primary entity in question, rather than a simple entity or column of that entity. Additionally, improved the behavior of [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by \"sqlalchemy.sql.expression.Select.filter_by\") overall to work with column expressions even in a non-ORM context.\n\n    References: [#6414](https://www.sqlalchemy.org/trac/ticket/6414)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where using [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") and [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload \"sqlalchemy.orm.subqueryload\") to load a two-level-deep path would lead to an attribute error.\n\n    References: [#6419](https://www.sqlalchemy.org/trac/ticket/6419)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where using the [`noload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.noload \"sqlalchemy.orm.noload\") loader strategy in conjunction with a \u201cdynamic\u201d relationship would lead to an attribute error as the noload strategy would attempt to apply itself to the dynamic loader.\n\n    References: [#6420](https://www.sqlalchemy.org/trac/ticket/6420)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Restored a legacy transactional behavior that was inadvertently removed from the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") as it was never tested as a known use case in previous versions, where calling upon the [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested \"sqlalchemy.engine.Connection.begin_nested\") method, when no transaction is present, does not create a SAVEPOINT at all and instead starts an outer transaction, returning a [`RootTransaction`](../core/connections.html#sqlalchemy.engine.RootTransaction \"sqlalchemy.engine.RootTransaction\") object instead of a [`NestedTransaction`](../core/connections.html#sqlalchemy.engine.NestedTransaction \"sqlalchemy.engine.NestedTransaction\") object. This [`RootTransaction`](../core/connections.html#sqlalchemy.engine.RootTransaction \"sqlalchemy.engine.RootTransaction\") then will emit a real COMMIT on the database connection when committed. Previously, the 2.0 style behavior was present in all cases that would autobegin a transaction but not commit it, which is a behavioral change.\n\n    When using a [2.0 style](../glossary.html#term-2.0-style) connection object, the behavior is unchanged from previous 1.4 versions; calling [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested \"sqlalchemy.engine.Connection.begin_nested\") will \u201cautobegin\u201d the outer transaction if not already present, and then as instructed emit a SAVEPOINT, returning the [`NestedTransaction`](../core/connections.html#sqlalchemy.engine.NestedTransaction \"sqlalchemy.engine.NestedTransaction\") object. The outer transaction is committed by calling upon [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit \"sqlalchemy.engine.Connection.commit\"), as is \u201ccommit-as-you-go\u201d style usage.\n\n    In non-\u201cfuture\u201d mode, while the old behavior is restored, it also emits a 2.0 deprecation warning as this is a legacy behavior.\n\n    References: [#6408](https://www.sqlalchemy.org/trac/ticket/6408)\n\n### asyncio\n\n*   **[asyncio] [bug] [regression]**\n\n    Fixed a regression introduced by [#6337](https://www.sqlalchemy.org/trac/ticket/6337) that would create an `asyncio.Lock` which could be attached to the wrong loop when instantiating the async engine before any asyncio loop was started, leading to an asyncio error message when attempting to use the engine under certain circumstances.\n\n    References: [#6409](https://www.sqlalchemy.org/trac/ticket/6409)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Add support for server side cursors in the pg8000 dialect for PostgreSQL. This allows use of the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") option.\n\n    References: [#6198](https://www.sqlalchemy.org/trac/ticket/6198)\n\n## 1.4.12\n\nReleased: April 29, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects \"sqlalchemy.orm.Session.bulk_save_objects\") when used with persistent objects which would fail to track the primary key of mappings where the column name of the primary key were different than the attribute name.\n\n    This change is also **backported** to: 1.3.25\n\n    References: [#6392](https://www.sqlalchemy.org/trac/ticket/6392)\n\n*   **[orm] [bug] [caching] [regression]**\n\n    Fixed critical regression where bound parameter tracking as used in the SQL caching system could fail to track all parameters for the case where the same SQL expression containing a parameter were used in an ORM-related query using a feature such as class inheritance, which was then embedded in an enclosing expression which would make use of that same expression multiple times, such as a UNION. The ORM would individually copy the individual SELECT statements as part of compilation with class inheritance, which then embedded in the enclosing statement would fail to accommodate for all parameters. The logic that tracks this condition has been adjusted to work for multiple copies of a parameter.\n\n    References: [#6391](https://www.sqlalchemy.org/trac/ticket/6391)\n\n*   **[orm] [bug]**\n\n    Fixed two distinct issues mostly affecting [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property \"sqlalchemy.ext.hybrid.hybrid_property\"), which would come into play under common mis-configuration scenarios that were silently ignored in 1.3, and now failed in 1.4, where the \u201cexpression\u201d implementation would return a non [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement \"sqlalchemy.sql.expression.ClauseElement\") such as a boolean value. For both issues, 1.3\u2019s behavior was to silently ignore the mis-configuration and ultimately attempt to interpret the value as a SQL expression, which would lead to an incorrect query.\n\n    *   Fixed issue regarding interaction of the attribute system with hybrid_property, where if the `__clause_element__()` method of the attribute returned a non-[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement \"sqlalchemy.sql.expression.ClauseElement\") object, an internal `AttributeError` would lead the attribute to return the `expression` function on the hybrid_property itself, as the attribute error was against the name `.expression` which would invoke the `__getattr__()` method as a fallback. This now raises explicitly. In 1.3 the non-[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement \"sqlalchemy.sql.expression.ClauseElement\") was returned directly.\n\n    *   Fixed issue in SQL argument coercions system where passing the wrong kind of object to methods that expect column expressions would fail if the object were altogether not a SQLAlchemy object, such as a Python function, in cases where the object were not just coerced into a bound value. Again 1.3 did not have a comprehensive argument coercion system so this case would also pass silently.\n\n    References: [#6350](https://www.sqlalchemy.org/trac/ticket/6350)\n\n*   **[orm] [bug]**\n\n    Fixed issue where using a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") as a subquery in an ORM context would modify the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") in place to disable eagerloads on that object, which would then cause that same [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") to not eagerload if it were then re-used in a top-level execution context.\n\n    References: [#6378](https://www.sqlalchemy.org/trac/ticket/6378)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed issue where the new [autobegin](../orm/session_basics.html#session-autobegin) behavior failed to \u201cautobegin\u201d in the case where an existing persistent object has an attribute change, which would then impact the behavior of [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback \"sqlalchemy.orm.Session.rollback\") in that no snapshot was created to be rolled back. The \u201cattribute modify\u201d mechanics have been updated to ensure \u201cautobegin\u201d, which does not perform any database work, does occur when persistent attributes change in the same manner as when [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add \"sqlalchemy.orm.Session.add\") is called. This is a regression as in 1.3, the rollback() method always had a transaction to roll back and would expire every time.\n\n    References: [#6359](https://www.sqlalchemy.org/trac/ticket/6359), [#6360](https://www.sqlalchemy.org/trac/ticket/6360)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in ORM where using hybrid property to indicate an expression from a different entity would confuse the column-labeling logic in the ORM and attempt to derive the name of the hybrid from that other class, leading to an attribute error. The owning class of the hybrid attribute is now tracked along with the name.\n\n    References: [#6386](https://www.sqlalchemy.org/trac/ticket/6386)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in hybrid_property where a hybrid against a SQL function would generate an `AttributeError` when attempting to generate an entry for the `.c` collection of a subquery in some cases; among other things this would impact its use in cases like that of `Query.count()`.\n\n    References: [#6401](https://www.sqlalchemy.org/trac/ticket/6401)\n\n*   **[orm] [bug] [dataclasses]**\n\n    Adjusted the declarative scan for dataclasses so that the inheritance behavior of [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") established on a mixin, when using the new form of having it inside of a `dataclasses.field()` construct and not actually a descriptor attribute on the class, correctly accommodates the case when the target class to be mapped is a subclass of an existing mapped class which has already mapped that [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\"), and therefore should not be re-applied to this class.\n\n    References: [#6346](https://www.sqlalchemy.org/trac/ticket/6346)\n\n*   **[orm] [bug]**\n\n    Fixed an issue with the (deprecated in 1.4) [`ForeignKeyConstraint.copy()`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.copy \"sqlalchemy.schema.ForeignKeyConstraint.copy\") method that caused an error when invoked with the `schema` argument.\n\n    References: [#6353](https://www.sqlalchemy.org/trac/ticket/6353)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where usage of an explicit [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") would produce inconsistent \u201cinline\u201d behavior for an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct that includes multiple values phrases; the first seq would be inline but subsequent ones would be \u201cpre-execute\u201d, leading to inconsistent sequence ordering. The sequence expressions are now fully inline.\n\n    References: [#6361](https://www.sqlalchemy.org/trac/ticket/6361)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Revised the \u201cEMPTY IN\u201d expression to no longer rely upon using a subquery, as this was causing some compatibility and performance problems. The new approach for selected databases takes advantage of using a NULL-returning IN expression combined with the usual \u201c1 != 1\u201d or \u201c1 = 1\u201d expression appended by AND or OR. The expression is now the default for all backends other than SQLite, which still had some compatibility issues regarding tuple \u201cIN\u201d for older SQLite versions.\n\n    Third party dialects can still override how the \u201cempty set\u201d expression renders by implementing a new compiler method `def visit_empty_set_op_expr(self, type_, expand_op)`, which takes precedence over the existing `def visit_empty_set_expr(self, element_types)` which remains in place.\n\n    References: [#6258](https://www.sqlalchemy.org/trac/ticket/6258), [#6397](https://www.sqlalchemy.org/trac/ticket/6397)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where usage of the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") construct inside the columns clause of a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") construct, which is better handled by using a [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column \"sqlalchemy.sql.expression.literal_column\") construct, would nonetheless prevent constructs like [`union()`](../core/selectable.html#sqlalchemy.sql.expression.union \"sqlalchemy.sql.expression.union\") from working correctly. Other use cases, such as constructing subuqeries, continue to work the same as in prior versions where the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") construct is silently omitted from the collection of exported columns. Also repairs similar use within the ORM.\n\n    References: [#6343](https://www.sqlalchemy.org/trac/ticket/6343)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression involving legacy methods such as `Select.append_column()` where internal assertions would fail.\n\n    References: [#6261](https://www.sqlalchemy.org/trac/ticket/6261)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by [#5395](https://www.sqlalchemy.org/trac/ticket/5395) where tuning back the check for sequences in [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") now caused failures when doing 2.0-style querying with a mapped class that also happens to have an `__iter__()` method. Tuned the check some more to accommodate this as well as some other interesting `__iter__()` scenarios.\n\n    References: [#6300](https://www.sqlalchemy.org/trac/ticket/6300)\n\n### schema\n\n*   **[schema] [bug] [mariadb] [mysql] [oracle] [postgresql]**\n\n    Ensure that the MySQL and MariaDB dialect ignore the `Identity` construct while rendering the `AUTO_INCREMENT` keyword in a create table.\n\n    The Oracle and PostgreSQL compiler was updated to not render `Identity` if the database version does not support it (Oracle < 12 and PostgreSQL < 10). Previously it was rendered regardless of the database version.\n\n    References: [#6338](https://www.sqlalchemy.org/trac/ticket/6338)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed very old issue where the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype would not inherit the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema \"sqlalchemy.schema.MetaData\") parameter of a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") object when that object were passed to the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") using [`Enum.metadata`](../core/type_basics.html#sqlalchemy.types.Enum.params.metadata \"sqlalchemy.types.Enum\").\n\n    References: [#6373](https://www.sqlalchemy.org/trac/ticket/6373)\n\n### sqlite\n\n*   **[sqlite] [usecase]**\n\n    Default to using `SingletonThreadPool` for in-memory SQLite databases created using URI filenames. Previously the default pool used was the `NullPool` that precented sharing the same database between multiple engines.\n\n    References: [#6379](https://www.sqlalchemy.org/trac/ticket/6379)\n\n### mssql\n\n*   **[mssql] [bug] [schema]**\n\n    Add [`TypeEngine.as_generic()`](../core/type_api.html#sqlalchemy.types.TypeEngine.as_generic \"sqlalchemy.types.TypeEngine.as_generic\") support for [`sqlalchemy.dialects.mysql.BIT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.BIT \"sqlalchemy.dialects.mysql.BIT\") columns, mapping them to `Boolean`.\n\n    References: [#6345](https://www.sqlalchemy.org/trac/ticket/6345)\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression caused by [#6306](https://www.sqlalchemy.org/trac/ticket/6306) which added support for `DateTime(timezone=True)`, where the previous behavior of the pyodbc driver of implicitly dropping the tzinfo from a timezone-aware date when INSERTing into a timezone-naive DATETIME column were lost, leading to a SQL Server error when inserting timezone-aware datetime objects into timezone-native database columns.\n\n    References: [#6366](https://www.sqlalchemy.org/trac/ticket/6366)\n\n## 1.4.11\n\nReleased: April 21, 2021\n\n### orm declarative\n\n*   **[orm] [declarative] [bug] [regression]**\n\n    Fixed regression where recent changes to support Python dataclasses had the inadvertent effect that an ORM mapped class could not successfully override the `__new__()` method.\n\n    References: [#6331](https://www.sqlalchemy.org/trac/ticket/6331)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Fixed critical regression caused by the change in [#5497](https://www.sqlalchemy.org/trac/ticket/5497) where the connection pool \u201cinit\u201d phase no longer occurred within mutexed isolation, allowing other threads to proceed with the dialect uninitialized, which could then impact the compilation of SQL statements.\n\n    References: [#6337](https://www.sqlalchemy.org/trac/ticket/6337)\n\n## 1.4.10\n\nReleased: April 20, 2021\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Altered some of the behavior repaired in [#6232](https://www.sqlalchemy.org/trac/ticket/6232) where the `immediateload` loader strategy no longer goes into recursive loops; the modification is that an eager load (joinedload, selectinload, or subqueryload) from A->bs->B which then states `immediateload` for a simple manytoone B->a->A that\u2019s in the identity map will populate the B->A, so that this attribute is back-populated when the collection of A/A.bs are loaded. This allows the objects to be functional when detached.\n\n*   **[orm] [bug]**\n\n    Fixed bug in new [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature where using a mixin class with [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") on an attribute that were accessed inside the custom lambda would emit a warning regarding using an unmapped declared attr, when the lambda callable were first initialized. This warning is now prevented using special instrumentation for this lambda initialization step.\n\n    References: [#6320](https://www.sqlalchemy.org/trac/ticket/6320)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed additional regression caused by the \u201ceagerloaders on refresh\u201d feature added in [#1763](https://www.sqlalchemy.org/trac/ticket/1763) where the refresh operation historically would set `populate_existing`, which given the new feature now overwrites pending changes on eagerly loaded objects when autoflush is false. The populate_existing flag has been turned off for this case and a more specific method used to ensure the correct attributes refreshed.\n\n    References: [#6326](https://www.sqlalchemy.org/trac/ticket/6326)\n\n*   **[orm] [bug] [result]**\n\n    Fixed an issue when using 2.0 style execution that prevented using [`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one \"sqlalchemy.engine.Result.scalar_one\") or [`Result.scalar_one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one_or_none \"sqlalchemy.engine.Result.scalar_one_or_none\") after calling [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\"), for the case where the ORM is returning a single-element row in any case.\n\n    References: [#6299](https://www.sqlalchemy.org/trac/ticket/6299)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue in SQL compiler where the bound parameters set up for a [`Values`](../core/selectable.html#sqlalchemy.sql.expression.Values \"sqlalchemy.sql.expression.Values\") construct wouldn\u2019t be positionally tracked correctly if inside of a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\"), affecting database drivers that support VALUES + ctes and use positional parameters such as SQL Server in particular as well as asyncpg. The fix also repairs support for compiler flags such as `literal_binds`.\n\n    References: [#6327](https://www.sqlalchemy.org/trac/ticket/6327)\n\n*   **[sql] [bug]**\n\n    Repaired and solidified issues regarding custom functions and other arbitrary expression constructs which within SQLAlchemy\u2019s column labeling mechanics would seek to use `str(obj)` to get a string representation to use as an anonymous column name in the `.c` collection of a subquery. This is a very legacy behavior that performs poorly and leads to lots of issues, so has been revised to no longer perform any compilation by establishing specific methods on [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement \"sqlalchemy.sql.functions.FunctionElement\") to handle this case, as SQL functions are the only use case that it came into play. An effect of this behavior is that an unlabeled column expression with no derivable name will be given an arbitrary label starting with the prefix `\"_no_label\"` in the `.c` collection of a subquery; these were previously being represented either as the generic stringification of that expression, or as an internal symbol.\n\n    References: [#6256](https://www.sqlalchemy.org/trac/ticket/6256)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed issue where [`next_value()`](../core/functions.html#sqlalchemy.sql.functions.next_value \"sqlalchemy.sql.functions.next_value\") was not deriving its type from the corresponding [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\"), instead hardcoded to [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer \"sqlalchemy.types.Integer\"). The specific numeric type is now used.\n\n    References: [#6287](https://www.sqlalchemy.org/trac/ticket/6287)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue where mypy plugin would not correctly interpret an explicit [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped \"sqlalchemy.orm.Mapped\") annotation in conjunction with a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") that refers to a class by string name; the correct annotation would be downgraded to a less specific one leading to typing errors.\n\n    References: [#6255](https://www.sqlalchemy.org/trac/ticket/6255)\n\n### mssql\n\n*   **[mssql] [usecase]**\n\n    The [`DateTime.timezone`](../core/type_basics.html#sqlalchemy.types.DateTime.params.timezone \"sqlalchemy.types.DateTime\") parameter when set to `True` will now make use of the `DATETIMEOFFSET` column type with SQL Server when used to emit DDL, rather than `DATETIME` where the flag was silently ignored.\n\n    References: [#6306](https://www.sqlalchemy.org/trac/ticket/6306)\n\n### misc\n\n*   **[bug] [declarative] [regression]**\n\n    Fixed `instrument_declarative()` that called a non existing registry method.\n\n    References: [#6291](https://www.sqlalchemy.org/trac/ticket/6291)\n\n## 1.4.9\n\nReleased: April 17, 2021\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Established support for `synoynm()` in conjunction with hybrid property, assocaitionproxy is set up completely, including that synonyms can be established linking to these constructs which work fully. This is a behavior that was semi-explicitly disallowed previously, however since it did not fail in every scenario, explicit support for assoc proxy and hybrids has been added.\n\n    References: [#6267](https://www.sqlalchemy.org/trac/ticket/6267)\n\n*   **[orm] [performance] [bug] [regression] [sql]**\n\n    Fixed a critical performance issue where the traversal of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct would traverse a repetitive product of the represented FROM clauses as they were each referenced by columns in the columns clause; for a series of nested subqueries with lots of columns this could cause a large delay and significant memory growth. This traversal is used by a wide variety of SQL and ORM functions, including by the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") when it\u2019s configured to have \u201ctable-per-bind\u201d, which while this is not a common use case, it seems to be what Flask-SQLAlchemy is hardcoded as using, so the issue impacts Flask-SQLAlchemy users. The traversal has been repaired to uniqify on FROM clauses which was effectively what would happen implicitly with the pre-1.4 architecture.\n\n    References: [#6304](https://www.sqlalchemy.org/trac/ticket/6304)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where an attribute that is mapped to a [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym \"sqlalchemy.orm.synonym\") could not be used in column loader options such as [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only \"sqlalchemy.orm.load_only\").\n\n    References: [#6272](https://www.sqlalchemy.org/trac/ticket/6272)\n\n### sql\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where an empty in statement on a tuple would result in an error when compiled with the option `literal_binds=True`.\n\n    References: [#6290](https://www.sqlalchemy.org/trac/ticket/6290)\n\n### postgresql\n\n*   **[postgresql] [bug] [regression] [sql]**\n\n    Fixed an argument error in the default and PostgreSQL compilers that would interfere with an UPDATE..FROM or DELETE..FROM..USING statement that was then SELECTed from as a CTE.\n\n    References: [#6303](https://www.sqlalchemy.org/trac/ticket/6303)\n\n## 1.4.8\n\nReleased: April 15, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed a cache leak involving the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression \"sqlalchemy.orm.with_expression\") loader option, where the given SQL expression would not be correctly considered as part of the cache key.\n\n    Additionally, fixed regression involving the corresponding [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") feature. While the bug technically exists in 1.3 as well, it was not exposed until 1.4\\. The \u201cdefault expr\u201d value of `null()` would be rendered when not needed, and additionally was also not adapted correctly when the ORM rewrites statements such as when using joined eager loading. The fix ensures \u201csingleton\u201d expressions like `NULL` and `true` aren\u2019t \u201cadapted\u201d to refer to columns in ORM statements, and additionally ensures that a [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") with no default expression doesn\u2019t render in the statement if a [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression \"sqlalchemy.orm.with_expression\") isn\u2019t used.\n\n    References: [#6259](https://www.sqlalchemy.org/trac/ticket/6259)\n\n*   **[orm] [bug]**\n\n    Fixed issue in the new feature of [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh \"sqlalchemy.orm.Session.refresh\") introduced by [#1763](https://www.sqlalchemy.org/trac/ticket/1763) where eagerly loaded relationships are also refreshed, where the `lazy=\"raise\"` and `lazy=\"raise_on_sql\"` loader strategies would interfere with the [`immediateload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.immediateload \"sqlalchemy.orm.immediateload\") loader strategy, thus breaking the feature for relationships that were loaded with [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload \"sqlalchemy.orm.subqueryload\") as well.\n\n    References: [#6252](https://www.sqlalchemy.org/trac/ticket/6252)\n\n### engine\n\n*   **[engine] [bug]**\n\n    The [`Dialect.has_table()`](../core/internals.html#sqlalchemy.engine.Dialect.has_table \"sqlalchemy.engine.Dialect.has_table\") method now raises an informative exception if a non-Connection is passed to it, as this incorrect behavior seems to be common. This method is not intended for external use outside of a dialect. Please use the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\") method or for cross-compatibility with older SQLAlchemy versions, the `Engine.has_table()` method.\n\n### sql\n\n*   **[sql] [feature]**\n\n    The tuple returned by [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key \"sqlalchemy.engine.CursorResult.inserted_primary_key\") is now a [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object with a named tuple interface on top of the existing tuple interface.\n\n    References: [#3314](https://www.sqlalchemy.org/trac/ticket/3314)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where the [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter \"sqlalchemy.sql.expression.BindParameter\") object would not properly render for an IN expression (i.e. using the \u201cpost compile\u201d feature in 1.4) if the object were copied from either an internal cloning operation, or from a pickle operation, and the parameter name contained spaces or other special characters.\n\n    References: [#6249](https://www.sqlalchemy.org/trac/ticket/6249)\n\n*   **[sql] [bug] [regression] [sqlite]**\n\n    Fixed regression where the introduction of the INSERT syntax \u201cINSERT\u2026 VALUES (DEFAULT)\u201d was not supported on some backends that do however support \u201cINSERT..DEFAULT VALUES\u201d, including SQLite. The two syntaxes are now each individually supported or non-supported for each dialect, for example MySQL supports \u201cVALUES (DEFAULT)\u201d but not \u201cDEFAULT VALUES\u201d. Support for Oracle has also been enabled.\n\n    References: [#6254](https://www.sqlalchemy.org/trac/ticket/6254)\n\n### mypy\n\n*   **[mypy] [change]**\n\n    Updated Mypy plugin to only use the public plugin interface of the semantic analyzer.\n\n*   **[mypy] [bug]**\n\n    Revised the fix for `OrderingList` from version 1.4.7 which was testing against the incorrect API.\n\n    References: [#6205](https://www.sqlalchemy.org/trac/ticket/6205)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Fix typo that prevented setting the `bind` attribute of an [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") to the correct value.\n\n    References: [#6220](https://www.sqlalchemy.org/trac/ticket/6220)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed an additional regression in the same area as that of [#6173](https://www.sqlalchemy.org/trac/ticket/6173), [#6184](https://www.sqlalchemy.org/trac/ticket/6184), where using a value of 0 for OFFSET in conjunction with LIMIT with SQL Server would create a statement using \u201cTOP\u201d, as was the behavior in 1.3, however due to caching would then fail to respond accordingly to other values of OFFSET. If the \u201c0\u201d wasn\u2019t first, then it would be fine. For the fix, the \u201cTOP\u201d syntax is now only emitted if the OFFSET value is omitted entirely, that is, [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset \"sqlalchemy.sql.expression.Select.offset\") is not used. Note that this change now requires that if the \u201cwith_ties\u201d or \u201cpercent\u201d modifiers are used, the statement can\u2019t specify an OFFSET of zero, it now needs to be omitted entirely.\n\n    References: [#6265](https://www.sqlalchemy.org/trac/ticket/6265)\n\n## 1.4.7\n\nReleased: April 9, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload \"sqlalchemy.orm.subqueryload\") loader strategy would fail to correctly accommodate sub-options, such as a [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer \"sqlalchemy.orm.defer\") option on a column, if the \u201cpath\u201d of the subqueryload were more than one level deep.\n\n    References: [#6221](https://www.sqlalchemy.org/trac/ticket/6221)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`merge_frozen_result()`](../orm/internals.html#sqlalchemy.orm.merge_frozen_result \"sqlalchemy.orm.merge_frozen_result\") function relied upon by the dogpile.caching example was not included in tests and began failing due to incorrect internal arguments.\n\n    References: [#6211](https://www.sqlalchemy.org/trac/ticket/6211)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed critical regression where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") could fail to \u201cautobegin\u201d a new transaction when a flush occurred without an existing transaction in place, implicitly placing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") into legacy autocommit mode which commit the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") now has a check that will prevent this condition from occurring, in addition to repairing the flush issue.\n\n    Additionally, scaled back part of the change made as part of [#5226](https://www.sqlalchemy.org/trac/ticket/5226) which can run autoflush during an unexpire operation, to not actually do this in the case of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") using legacy [`Session.autocommit`](../orm/session_api.html#sqlalchemy.orm.Session.params.autocommit \"sqlalchemy.orm.Session\") mode, as this incurs a commit within a refresh operation.\n\n    References: [#6233](https://www.sqlalchemy.org/trac/ticket/6233)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the ORM compilation scheme would assume the function name of a hybrid property would be the same as the attribute name in such a way that an `AttributeError` would be raised, when it would attempt to determine the correct name for each element in a result tuple. A similar issue exists in 1.3 but only impacts the names of tuple rows. The fix here adds a check that the hybrid\u2019s function name is actually present in the `__dict__` of the class or its superclasses before assigning this name; otherwise, the hybrid is considered to be \u201cunnamed\u201d and ORM result tuples will use the naming scheme of the underlying expression.\n\n    References: [#6215](https://www.sqlalchemy.org/trac/ticket/6215)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed critical regression caused by the new feature added as part of [#1763](https://www.sqlalchemy.org/trac/ticket/1763), eager loaders are invoked on unexpire operations. The new feature makes use of the \u201cimmediateload\u201d eager loader strategy as a substitute for a collection loading strategy, which unlike the other \u201cpost-load\u201d strategies was not accommodating for recursive invocations between mutually-dependent relationships, leading to recursion overflow errors.\n\n    References: [#6232](https://www.sqlalchemy.org/trac/ticket/6232)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Fixed up the behavior of the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object when dictionary access is used upon it, meaning converting to a dict via `dict(row)` or accessing members using strings or other objects i.e. `row[\"some_key\"]` works as it would with a dictionary, rather than raising `TypeError` as would be the case with a tuple, whether or not the C extensions are in place. This was originally supposed to emit a 2.0 deprecation warning for the \u201cnon-future\u201d case using `LegacyRow`, and was to raise `TypeError` for the \u201cfuture\u201d [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") class. However, the C version of [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") was failing to raise this `TypeError`, and to complicate matters, the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") method now returns [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") in all cases to maintain consistency with the ORM result case, so users who didn\u2019t have C extensions installed would see different behavior in this one case for existing pre-1.4 style code.\n\n    Therefore, in order to soften the overall upgrade scheme as most users have not been exposed to the more strict behavior of [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") up through 1.4.6, `LegacyRow` and [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") both provide for string-key access as well as support for `dict(row)`, in all cases emitting the 2.0 deprecation warning when `SQLALCHEMY_WARN_20` is enabled. The [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object still uses tuple-like behavior for `__contains__`, which is probably the only noticeable behavioral change compared to `LegacyRow`, other than the removal of dictionary-style methods `values()` and `items()`.\n\n    References: [#6218](https://www.sqlalchemy.org/trac/ticket/6218)\n\n### sql\n\n*   **[sql] [bug] [regression]**\n\n    Enhanced the \u201cexpanding\u201d feature used for [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_ \"sqlalchemy.sql.expression.ColumnOperators.in_\") operations to infer the type of expression from the right hand list of elements, if the left hand side does not have any explicit type set up. This allows the expression to support stringification among other things. In 1.3, \u201cexpanding\u201d was not automatically used for [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_ \"sqlalchemy.sql.expression.ColumnOperators.in_\") expressions, so in that sense this change fixes a behavioral regression.\n\n    References: [#6222](https://www.sqlalchemy.org/trac/ticket/6222)\n\n*   **[sql] [bug]**\n\n    Fixed the \u201cstringify\u201d compiler to support a basic stringification of a \u201cmultirow\u201d INSERT statement, i.e. one with multiple tuples following the VALUES keyword.\n\n### schema\n\n*   **[schema] [bug] [regression]**\n\n    Fixed regression where usage of a token in the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map \"sqlalchemy.engine.Connection.execution_options\") dictionary which contained special characters such as braces would fail to be substituted properly. Use of square bracket characters `[]` is now explicitly disallowed as these are used as a delimiter character in the current implementation.\n\n    References: [#6216](https://www.sqlalchemy.org/trac/ticket/6216)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue in Mypy plugin where the plugin wasn\u2019t inferring the correct type for columns of subclasses that don\u2019t directly descend from `TypeEngine`, in particular that of `TypeDecorator` and `UserDefinedType`.\n\n### tests\n\n*   **[tests] [change]**\n\n    Added a new flag to [`DefaultDialect`](../core/internals.html#sqlalchemy.engine.default.DefaultDialect \"sqlalchemy.engine.default.DefaultDialect\") called `supports_schemas`; third party dialects may set this flag to `False` to disable SQLAlchemy\u2019s schema-level tests when running the test suite for a third party dialect.\n\n## 1.4.6\n\nReleased: April 6, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where a deprecated form of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") were used, passing a series of entities to join from without any ON clause in a single [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") call, would fail to function correctly.\n\n    References: [#6203](https://www.sqlalchemy.org/trac/ticket/6203)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed critical regression where the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per \"sqlalchemy.orm.Query.yield_per\") method in the ORM would set up the internal [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") to yield chunks at a time, however made use of the new [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\") method which uniques across the entire result. This would lead to lost rows since the ORM is using `id(obj)` as the uniquing function, which leads to repeated identifiers for new objects as already-seen objects are garbage collected. 1.3\u2019s behavior here was to \u201cunique\u201d across each chunk, which does not actually produce \u201cuniqued\u201d results when results are yielded in chunks. As the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per \"sqlalchemy.orm.Query.yield_per\") method is already explicitly disallowed when joined eager loading is in place, which is the primary rationale for the \u201cuniquing\u201d feature, the \u201cuniquing\u201d feature is now turned off entirely when [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per \"sqlalchemy.orm.Query.yield_per\") is used.\n\n    This regression only applies to the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object; when using [2.0 style](../glossary.html#term-2.0-style) execution, \u201cuniquing\u201d is not automatically applied. To prevent the issue from arising from explicit use of [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\"), an error is now raised if rows are fetched from a \u201cuniqued\u201d ORM-level [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") if any [yield per](../orm/queryguide/api.html#orm-queryguide-yield-per) API is also in use, as the purpose of `yield_per` is to allow for arbitrarily large numbers of rows, which cannot be uniqued in memory without growing the number of entries to fit the complete result size.\n\n    References: [#6206](https://www.sqlalchemy.org/trac/ticket/6206)\n\n### sql\n\n*   **[sql] [bug] [mssql] [oracle] [regression]**\n\n    Fixed further regressions in the same area as that of [#6173](https://www.sqlalchemy.org/trac/ticket/6173) released in 1.4.5, where a \u201cpostcompile\u201d parameter, again most typically those used for LIMIT/OFFSET rendering in Oracle and SQL Server, would fail to be processed correctly if the same parameter rendered in multiple places in the statement.\n\n    References: [#6202](https://www.sqlalchemy.org/trac/ticket/6202)\n\n*   **[sql] [bug]**\n\n    Executing a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery \"sqlalchemy.sql.expression.Subquery\") using [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute \"sqlalchemy.engine.Connection.execute\") is deprecated and will emit a deprecation warning; this use case was an oversight that should have been removed from 1.4\\. The operation will now execute the underlying [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") object directly for backwards compatibility. Similarly, the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") class is also not appropriate for execution. In 1.3, attempting to execute a CTE would result in an invalid \u201cblank\u201d SQL statement being executed; since this use case was not working it now raises [`ObjectNotExecutableError`](../core/exceptions.html#sqlalchemy.exc.ObjectNotExecutableError \"sqlalchemy.exc.ObjectNotExecutableError\"). Previously, 1.4 was attempting to execute the CTE as a statement however it was working only erratically.\n\n    References: [#6204](https://www.sqlalchemy.org/trac/ticket/6204)\n\n### schema\n\n*   **[schema] [bug]**\n\n    The [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object now raises an informative error message if it is instantiated without passing at least the [`Table.name`](../core/metadata.html#sqlalchemy.schema.Table.params.name \"sqlalchemy.schema.Table\") and [`Table.metadata`](../core/metadata.html#sqlalchemy.schema.Table.params.metadata \"sqlalchemy.schema.Table\") arguments positionally. Previously, if these were passed as keyword arguments, the object would silently fail to initialize correctly.\n\n    This change is also **backported** to: 1.3.25\n\n    References: [#6135](https://www.sqlalchemy.org/trac/ticket/6135)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Applied a series of refactorings and fixes to accommodate for Mypy \u201cincremental\u201d mode across multiple files, which previously was not taken into account. In this mode the Mypy plugin has to accommodate Python datatypes expressed in other files coming in with less information than they have on a direct run.\n\n    Additionally, a new decorator [`declarative_mixin()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_mixin \"sqlalchemy.orm.declarative_mixin\") is added, which is necessary for the Mypy plugin to be able to definifitely identify a Declarative mixin class that is otherwise not used inside a particular Python file.\n\n    See also\n\n    [Using @declared_attr and Declarative Mixins](../orm/extensions/mypy.html#mypy-declarative-mixins)\n\n    References: [#6147](https://www.sqlalchemy.org/trac/ticket/6147)\n\n*   **[mypy] [bug]**\n\n    Fixed issue where the Mypy plugin would fail to interpret the \u201ccollection_class\u201d of a relationship if it were a callable and not a class. Also improved type matching and error reporting for collection-oriented relationships.\n\n    References: [#6205](https://www.sqlalchemy.org/trac/ticket/6205)\n\n### asyncio\n\n*   **[asyncio] [usecase] [postgresql]**\n\n    Added accessors `.sqlstate` and synonym `.pgcode` to the `.orig` attribute of the SQLAlchemy exception class raised by the asyncpg DBAPI adapter, that is, the intermediary exception object that wraps on top of that raised by the asyncpg library itself, but below the level of the SQLAlchemy dialect.\n\n    References: [#6199](https://www.sqlalchemy.org/trac/ticket/6199)\n\n## 1.4.5\n\nReleased: April 2, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") loader strategy would not successfully joinedload to a mapper that is mapper against a [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct.\n\n    References: [#6172](https://www.sqlalchemy.org/trac/ticket/6172)\n\n*   **[orm] [bug] [regression]**\n\n    Scaled back the warning message added in [#5171](https://www.sqlalchemy.org/trac/ticket/5171) to not warn for overlapping columns in an inheritance scenario where a particular relationship is local to a subclass and therefore does not represent an overlap.\n\n    References: [#6171](https://www.sqlalchemy.org/trac/ticket/6171)\n\n### sql\n\n*   **[sql] [bug] [postgresql]**\n\n    Fixed bug in new `FunctionElement.render_derived()` feature where column names rendered out explicitly in the alias SQL would not have proper quoting applied for case sensitive names and other non-alphanumeric names.\n\n    References: [#6183](https://www.sqlalchemy.org/trac/ticket/6183)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where use of the `Operators.in_()` method with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") object against a non-table-bound column would produce an `AttributeError`, or more generally using a [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect \"sqlalchemy.sql.expression.ScalarSelect\") that has no datatype in a binary expression would produce invalid state.\n\n    References: [#6181](https://www.sqlalchemy.org/trac/ticket/6181)\n\n*   **[sql] [bug]**\n\n    Added a new flag to the [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect \"sqlalchemy.engine.Dialect\") class called [`Dialect.supports_statement_cache`](../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache \"sqlalchemy.engine.Dialect.supports_statement_cache\"). This flag now needs to be present directly on a dialect class in order for SQLAlchemy\u2019s [query cache](../core/connections.html#sql-caching) to take effect for that dialect. The rationale is based on discovered issues such as [#6173](https://www.sqlalchemy.org/trac/ticket/6173) revealing that dialects which hardcode literal values from the compiled statement, often the numerical parameters used for LIMIT / OFFSET, will not be compatible with caching until these dialects are revised to use the parameters present in the statement only. For third party dialects where this flag is not applied, the SQL logging will show the message \u201cdialect does not support caching\u201d, indicating the dialect should seek to apply this flag once they have verified that no per-statement literal values are being rendered within the compilation phase.\n\n    See also\n\n    [Caching for Third Party Dialects](../core/connections.html#engine-thirdparty-caching)\n\n    References: [#6184](https://www.sqlalchemy.org/trac/ticket/6184)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Introduce a new parameter [`Enum.omit_aliases`](../core/type_basics.html#sqlalchemy.types.Enum.params.omit_aliases \"sqlalchemy.types.Enum\") in [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") type allow filtering aliases when using a pep435 Enum. Previous versions of SQLAlchemy kept aliases in all cases, creating database enum type with additional states, meaning that they were treated as different values in the db. For backward compatibility this flag defaults to `False` in the 1.4 series, but will be switched to `True` in a future version. A deprecation warning is raise if this flag is not specified and the passed enum contains aliases.\n\n    References: [#6146](https://www.sqlalchemy.org/trac/ticket/6146)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue in mypy plugin where newly added support for [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative \"sqlalchemy.orm.as_declarative\") needed to more fully add the `DeclarativeMeta` class to the mypy interpreter\u2019s state so that it does not result in a name not found error; additionally improves how global names are setup for the plugin including the `Mapped` name.\n\n    References: [#sqlalchemy/sqlalchemy2-stubs/#14](https://www.sqlalchemy.org/trac/ticket/sqlalchemy/sqlalchemy2-stubs/#14)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Fixed issue where the asyncio extension could not be loaded if running Python 3.6 with the backport library of `contextvars` installed.\n\n    References: [#6166](https://www.sqlalchemy.org/trac/ticket/6166)\n\n### postgresql\n\n*   **[postgresql] [bug] [regression]**\n\n    Fixed regression caused by [#6023](https://www.sqlalchemy.org/trac/ticket/6023) where the PostgreSQL cast operator applied to elements within an [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") when using psycopg2 would fail to use the correct type in the case that the datatype were also embedded within an instance of the [`Variant`](../core/type_api.html#sqlalchemy.types.Variant \"sqlalchemy.types.Variant\") adapter.\n\n    Additionally, repairs support for the correct CREATE TYPE to be emitted when using a `Variant(ARRAY(some_schema_type))`.\n\n    This change is also **backported** to: 1.3.25\n\n    References: [#6182](https://www.sqlalchemy.org/trac/ticket/6182)\n\n*   **[postgresql] [bug]**\n\n    Fixed typo in the fix for [#6099](https://www.sqlalchemy.org/trac/ticket/6099) released in 1.4.4 that completely prevented this change from working correctly, i.e. the error message did not match what was actually emitted by pg8000.\n\n    References: [#6099](https://www.sqlalchemy.org/trac/ticket/6099)\n\n*   **[postgresql] [bug]**\n\n    Fixed issue where the PostgreSQL [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector \"sqlalchemy.dialects.postgresql.base.PGInspector\"), when generated against an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\"), would fail for `.get_enums()`, `.get_view_names()`, `.get_foreign_table_names()` and `.get_table_oid()` when used against a \u201cfuture\u201d style engine and not the connection directly.\n\n    References: [#6170](https://www.sqlalchemy.org/trac/ticket/6170)\n\n### mysql\n\n*   **[mysql] [bug] [regression]**\n\n    Fixed regression in the MySQL dialect where the reflection query used to detect if a table exists would fail on very old MySQL 5.0 and 5.1 versions.\n\n    References: [#6163](https://www.sqlalchemy.org/trac/ticket/6163)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed a regression in MSSQL 2012+ that prevented the order by clause to be rendered when `offset=0` is used in a subquery.\n\n    References: [#6163](https://www.sqlalchemy.org/trac/ticket/6163)\n\n### oracle\n\n*   **[oracle] [bug] [regression]**\n\n    Fixed critical regression where the Oracle compiler would not maintain the correct parameter values in the LIMIT/OFFSET for a select due to a caching issue.\n\n    References: [#6173](https://www.sqlalchemy.org/trac/ticket/6173)\n\n## 1.4.4\n\nReleased: March 30, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed critical issue in the new [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") feature where loader strategies that emit secondary SELECT statements such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") and [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload \"sqlalchemy.orm.lazyload\") would fail to accommodate for bound parameters in the user-defined criteria in terms of the current statement being executed, as opposed to the cached statement, causing stale bound values to be used.\n\n    This also adds a warning for the case where an object that uses [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload \"sqlalchemy.orm.lazyload\") in conjunction with [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") is attempted to be serialized; the loader criteria cannot reliably be serialized and deserialized and eager loading should be used for this case.\n\n    References: [#6139](https://www.sqlalchemy.org/trac/ticket/6139)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed missing method [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get \"sqlalchemy.orm.Session.get\") from the `ScopedSession` interface.\n\n    References: [#6144](https://www.sqlalchemy.org/trac/ticket/6144)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Modified the context manager used by [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction \"sqlalchemy.engine.Transaction\") so that an \u201calready detached\u201d warning is not emitted by the ending of the context manager itself, if the transaction were already manually rolled back inside the block. This applies to regular transactions, savepoint transactions, and legacy \u201cmarker\u201d transactions. A warning is still emitted if the `.rollback()` method is called explicitly more than once.\n\n    References: [#6155](https://www.sqlalchemy.org/trac/ticket/6155)\n\n*   **[engine] [bug]**\n\n    Repair wrong arguments to exception handling method in CursorResult.\n\n    References: [#6138](https://www.sqlalchemy.org/trac/ticket/6138)\n\n### postgresql\n\n*   **[postgresql] [bug] [reflection]**\n\n    Fixed issue in PostgreSQL reflection where a column expressing \u201cNOT NULL\u201d will supersede the nullability of a corresponding domain.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#6161](https://www.sqlalchemy.org/trac/ticket/6161)\n\n*   **[postgresql] [bug]**\n\n    Modified the `is_disconnect()` handler for the pg8000 dialect, which now accommodates for a new `InterfaceError` emitted by pg8000 1.19.0\\. Pull request courtesy Hamdi Burak Usul.\n\n    References: [#6099](https://www.sqlalchemy.org/trac/ticket/6099)\n\n### misc\n\n*   **[misc] [bug]**\n\n    Adjusted the usage of the `importlib_metadata` library for loading setuptools entrypoints in order to accommodate for some deprecation changes.\n\n## 1.4.3\n\nReleased: March 25, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed a bug where python 2.7.5 (default on CentOS 7) wasn\u2019t able to import sqlalchemy, because on this version of Python `exec \"statement\"` and `exec(\"statement\")` do not behave the same way. The compatibility `exec_()` function was used instead.\n\n    References: [#6069](https://www.sqlalchemy.org/trac/ticket/6069)\n\n*   **[orm] [bug]**\n\n    Fixed bug where ORM queries using a correlated subquery in conjunction with [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property \"sqlalchemy.orm.column_property\") would fail to correlate correctly to an enclosing subquery or to a CTE when [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except \"sqlalchemy.sql.expression.Select.correlate_except\") were used in the property to control correlation, in cases where the subquery contained the same selectables as ones within the correlated subquery that were intended to not be correlated.\n\n    References: [#6060](https://www.sqlalchemy.org/trac/ticket/6060)\n\n*   **[orm] [bug]**\n\n    Fixed bug where combinations of the new \u201crelationship with criteria\u201d feature could fail in conjunction with features that make use of the new \u201clambda SQL\u201d feature, including loader strategies such as selectinload and lazyload, for more complicated scenarios such as polymorphic loading.\n\n    References: [#6131](https://www.sqlalchemy.org/trac/ticket/6131)\n\n*   **[orm] [bug]**\n\n    Repaired support so that the [`ClauseElement.params()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.params \"sqlalchemy.sql.expression.ClauseElement.params\") method can work correctly with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") object that includes joins across ORM relationship structures, which is a new feature in 1.4.\n\n    References: [#6124](https://www.sqlalchemy.org/trac/ticket/6124)\n\n*   **[orm] [bug]**\n\n    Fixed issue where a \u201cremoved in 2.0\u201d warning were generated internally by the relationship loader mechanics.\n\n    References: [#6115](https://www.sqlalchemy.org/trac/ticket/6115)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug] [regression]**\n\n    Fixed regression where the `.metadata` attribute on a per class level would not be honored, breaking the use case of per-class-hierarchy [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") for abstract declarative classes and mixins.\n\n    See also\n\n    [metadata](../orm/declarative_config.html#declarative-metadata)\n\n    References: [#6128](https://www.sqlalchemy.org/trac/ticket/6128)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Restored the `ResultProxy` name back to the `sqlalchemy.engine` namespace. This name refers to the `LegacyCursorResult` object.\n\n    References: [#6119](https://www.sqlalchemy.org/trac/ticket/6119)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Adjusted the logic that emits DROP statements for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") objects among the dropping of multiple tables, such that all [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") objects are dropped after all tables, even if the given [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") is related only to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object and not directly to the overall [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") object. The use case supports the same [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") being associated with more than one [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") at a time.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#6071](https://www.sqlalchemy.org/trac/ticket/6071)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Added support for the Mypy extension to correctly interpret a declarative base class that\u2019s generated using the [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative \"sqlalchemy.orm.as_declarative\") function as well as the [`registry.as_declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.as_declarative_base \"sqlalchemy.orm.registry.as_declarative_base\") method.\n\n*   **[mypy] [bug]**\n\n    Fixed bug in Mypy plugin where the Python type detection for the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean \"sqlalchemy.types.Boolean\") column type would produce an exception; additionally implemented support for [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\"), including detection of a string-based enum vs. use of Python `enum.Enum`.\n\n    References: [#6109](https://www.sqlalchemy.org/trac/ticket/6109)\n\n### postgresql\n\n*   **[postgresql] [bug] [types]**\n\n    Adjusted the psycopg2 dialect to emit an explicit PostgreSQL-style cast for bound parameters that contain ARRAY elements. This allows the full range of datatypes to function correctly within arrays. The asyncpg dialect already generated these internal casts in the final statement. This also includes support for array slice updates as well as the PostgreSQL-specific `ARRAY.contains()` method.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#6023](https://www.sqlalchemy.org/trac/ticket/6023)\n\n*   **[postgresql] [bug] [reflection]**\n\n    Fixed reflection of identity columns in tables with mixed case names in PostgreSQL.\n\n    References: [#6129](https://www.sqlalchemy.org/trac/ticket/6129)\n\n### sqlite\n\n*   **[sqlite] [feature] [asyncio]**\n\n    Added support for the aiosqlite database driver for use with the SQLAlchemy asyncio extension.\n\n    See also\n\n    [Aiosqlite](../dialects/sqlite.html#aiosqlite)\n\n    References: [#5920](https://www.sqlalchemy.org/trac/ticket/5920)\n\n*   **[sqlite] [bug] [regression]**\n\n    Repaired the `pysqlcipher` dialect to connect correctly which had regressed in 1.4, and added test + CI support to maintain the driver in working condition. The dialect now imports the `sqlcipher3` module for Python 3 by default before falling back to `pysqlcipher3` which is documented as now being unmaintained.\n\n    See also\n\n    [Pysqlcipher](../dialects/sqlite.html#pysqlcipher)\n\n    References: [#5848](https://www.sqlalchemy.org/trac/ticket/5848)\n\n## 1.4.2\n\nReleased: March 19, 2021\n\n### orm\n\n*   **[orm] [usecase] [dataclasses]**\n\n    Added support for the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") object to work in the context of dataclass fields.\n\n    See also\n\n    [Using Declarative Mixins with pre-existing dataclasses](../orm/dataclasses.html#orm-declarative-dataclasses-mixin)\n\n    References: [#6100](https://www.sqlalchemy.org/trac/ticket/6100)\n\n*   **[orm] [bug] [dataclasses]**\n\n    Fixed issue in new ORM dataclasses functionality where dataclass fields on an abstract base or mixin that contained column or other mapping constructs would not be mapped if they also included a \u201cdefault\u201d key within the dataclasses.field() object.\n\n    References: [#6093](https://www.sqlalchemy.org/trac/ticket/6093)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`Query.selectable`](../orm/queryguide/query.html#sqlalchemy.orm.Query.selectable \"sqlalchemy.orm.Query.selectable\") accessor, which is a synonym for `Query.__clause_element__()`, got removed, it\u2019s now restored.\n\n    References: [#6088](https://www.sqlalchemy.org/trac/ticket/6088)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where use of an unnamed SQL expression such as a SQL function would raise a column targeting error if the query itself were using joinedload for an entity and was also being wrapped in a subquery by the joinedload eager loading process.\n\n    References: [#6086](https://www.sqlalchemy.org/trac/ticket/6086)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") method would fail to locate the correct source entity if the [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") method had been used targeting an entity without any kind of ON clause.\n\n    References: [#6092](https://www.sqlalchemy.org/trac/ticket/6092)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the SQL compilation of a [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function \"sqlalchemy.sql.functions.Function\") would not work correctly if the object had been \u201cannotated\u201d, which is an internal memoization process used mostly by the ORM. In particular it could affect ORM lazy loads which make greater use of this feature in 1.4.\n\n    References: [#6095](https://www.sqlalchemy.org/trac/ticket/6095)\n\n*   **[orm] [bug]**\n\n    Fixed regression where the [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase \"sqlalchemy.ext.declarative.ConcreteBase\") would fail to map at all when a mapped column name overlapped with the discriminator column name, producing an assertion error. The use case here did not function correctly in 1.3 as the polymorphic union would produce a query that ignored the discriminator column entirely, while emitting duplicate column warnings. As 1.4\u2019s architecture cannot easily reproduce this essentially broken behavior of 1.3 at the `select()` level right now, the use case now raises an informative error message instructing the user to use the `.ConcreteBase._concrete_discriminator_name` attribute to resolve the conflict. To assist with this configuration, `.ConcreteBase._concrete_discriminator_name` may be placed on the base class only where it will be automatically used by subclasses; previously this was not the case.\n\n    References: [#6090](https://www.sqlalchemy.org/trac/ticket/6090)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Restored top level import for `sqlalchemy.engine.reflection`. This ensures that the base [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector \"sqlalchemy.engine.reflection.Inspector\") class is properly registered so that [`inspect()`](../core/inspection.html#sqlalchemy.inspect \"sqlalchemy.inspect\") works for third party dialects that don\u2019t otherwise import this package.\n\n### sql\n\n*   **[sql] [bug] [regression]**\n\n    Fixed issue where using a `func` that includes dotted packagenames would fail to be cacheable by the SQL caching system due to a Python list of names that needed to be a tuple.\n\n    References: [#6101](https://www.sqlalchemy.org/trac/ticket/6101)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression in the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case \"sqlalchemy.sql.expression.case\") construct, where the \u201cdictionary\u201d form of argument specification failed to work correctly if it were passed positionally, rather than as a \u201cwhens\u201d keyword argument.\n\n    References: [#6097](https://www.sqlalchemy.org/trac/ticket/6097)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed issue in MyPy extension which crashed on detecting the type of a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") if the type were given with a module prefix like `sa.Integer()`.\n\n    References: [#sqlalchemy/sqlalchemy2-stubs/2](https://www.sqlalchemy.org/trac/ticket/sqlalchemy/sqlalchemy2-stubs/2)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Rename the column name used by a reflection query that used a reserved word in some postgresql compatible databases.\n\n    References: [#6982](https://www.sqlalchemy.org/trac/ticket/6982)\n\n## 1.4.1\n\nReleased: March 17, 2021\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where producing a Core expression construct such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") using ORM entities would eagerly configure the mappers, in an effort to maintain compatibility with the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object which necessarily does this to support many backref-related legacy cases. However, core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") constructs are also used in mapper configurations and such, and to that degree this eager configuration is more of an inconvenience, so eager configure has been disabled for the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") and other Core constructs in the absence of ORM loading types of functions such as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load \"sqlalchemy.orm.Load\").\n\n    The change maintains the behavior of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") so that backwards compatibility is maintained. However, when using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") in conjunction with ORM entities, a \u201cbackref\u201d that isn\u2019t explicitly placed on one of the classes until mapper configure time won\u2019t be available unless [`configure_mappers()`](../orm/mapping_api.html#sqlalchemy.orm.configure_mappers \"sqlalchemy.orm.configure_mappers\") or the newer [`configure()`](../orm/mapping_api.html#sqlalchemy.orm.registry.configure \"sqlalchemy.orm.registry.configure\") has been called elsewhere. Prefer using [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates \"sqlalchemy.orm.relationship\") for more explicit relationship configuration which does not have the eager configure requirement.\n\n    References: [#6066](https://www.sqlalchemy.org/trac/ticket/6066)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed a critical regression in the relationship lazy loader where the SQL criteria used to fetch a related many-to-one object could go stale in relation to other memoized structures within the loader if the mapper had configuration changes, such as can occur when mappers are late configured or configured on demand, producing a comparison to None and returning no object. Huge thanks to Alan Hamlett for their help tracking this down late into the night.\n\n    References: [#6055](https://www.sqlalchemy.org/trac/ticket/6055)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the [`Query.exists()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.exists \"sqlalchemy.orm.Query.exists\") method would fail to create an expression if the entity list of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") were an arbitrary SQL column expression.\n\n    References: [#6076](https://www.sqlalchemy.org/trac/ticket/6076)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where calling upon [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count \"sqlalchemy.orm.Query.count\") in conjunction with a loader option such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") would fail to ignore the loader option. This is a behavior that has always been very specific to the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count \"sqlalchemy.orm.Query.count\") method; an error is normally raised if a given [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") has options that don\u2019t apply to what it is returning.\n\n    References: [#6052](https://www.sqlalchemy.org/trac/ticket/6052)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in [`Session.identity_key()`](../orm/session_api.html#sqlalchemy.orm.Session.identity_key \"sqlalchemy.orm.Session.identity_key\"), including that the method and related methods were not covered by any unit test as well as that the method contained a typo preventing it from functioning correctly.\n\n    References: [#6067](https://www.sqlalchemy.org/trac/ticket/6067)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug] [regression]**\n\n    Fixed bug where user-mapped classes that contained an attribute named \u201cregistry\u201d would cause conflicts with the new registry-based mapping system when using `DeclarativeMeta`. While the attribute remains something that can be set explicitly on a declarative base to be consumed by the metaclass, once located it is placed under a private class variable so it does not conflict with future subclasses that use the same name for other purposes.\n\n    References: [#6054](https://www.sqlalchemy.org/trac/ticket/6054)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    The Python `namedtuple()` has the behavior such that the names `count` and `index` will be served as tuple values if the named tuple includes those names; if they are absent, then their behavior as methods of `collections.abc.Sequence` is maintained. Therefore the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") and `LegacyRow` classes have been fixed so that they work in this same way, maintaining the expected behavior for database rows that have columns named \u201cindex\u201d or \u201ccount\u201d.\n\n    References: [#6074](https://www.sqlalchemy.org/trac/ticket/6074)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression where a new setinputsizes() API that\u2019s available for pyodbc was enabled, which is apparently incompatible with pyodbc\u2019s fast_executemany() mode in the absence of more accurate typing information, which as of yet is not fully implemented or tested. The pyodbc dialect and connector has been modified so that setinputsizes() is not used at all unless the parameter `use_setinputsizes` is passed to the dialect, e.g. via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine \"sqlalchemy.create_engine\"), at which point its behavior can be customized using the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes \"sqlalchemy.events.DialectEvents.do_setinputsizes\") hook.\n\n    See also\n\n    [Setinputsizes Support](../dialects/mssql.html#mssql-pyodbc-setinputsizes)\n\n    References: [#6058](https://www.sqlalchemy.org/trac/ticket/6058)\n\n### misc\n\n*   **[bug] [regression]**\n\n    Added back `items` and `values` to `ColumnCollection` class. The regression was introduced while adding support for duplicate columns in from clauses and selectable in ticket #4753.\n\n    References: [#6068](https://www.sqlalchemy.org/trac/ticket/6068)\n\n## 1.4.0\n\nReleased: March 15, 2021\n\n### orm\n\n*   **[orm] [bug]**\n\n    Removed very old warning that states that passive_deletes is not intended for many-to-one relationships. While it is likely that in many cases placing this parameter on a many-to-one relationship is not what was intended, there are use cases where delete cascade may want to be disallowed following from such a relationship.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#5983](https://www.sqlalchemy.org/trac/ticket/5983)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the process of joining two tables could fail if one of the tables had an unrelated, unresolvable foreign key constraint which would raise [`NoReferenceError`](../core/exceptions.html#sqlalchemy.exc.NoReferenceError \"sqlalchemy.exc.NoReferenceError\") within the join process, which nonetheless could be bypassed to allow the join to complete. The logic which tested the exception for significance within the process would make assumptions about the construct which would fail.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#5952](https://www.sqlalchemy.org/trac/ticket/5952)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the [`MutableComposite`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite \"sqlalchemy.ext.mutable.MutableComposite\") construct could be placed into an invalid state when the parent object was already loaded, and then covered by a subsequent query, due to the composite properties\u2019 refresh handler replacing the object with a new one not handled by the mutable extension.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#6001](https://www.sqlalchemy.org/trac/ticket/6001)\n\n*   **[orm] [bug]**\n\n    Fixed regression where the [`relationship.query_class`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.query_class \"sqlalchemy.orm.relationship\") parameter stopped being functional for \u201cdynamic\u201d relationships. The `AppenderQuery` remains dependent on the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") class; users are encouraged to migrate from the use of \u201cdynamic\u201d relationships to using [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent \"sqlalchemy.orm.with_parent\") instead.\n\n    References: [#5981](https://www.sqlalchemy.org/trac/ticket/5981)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") would produce no effect if the query itself as well as the join target were against a [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object, rather than a mapped class. This was part of a more systemic issue where the legacy ORM query compiler would not be correctly used from a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") if the statement produced had not ORM entities present within it.\n\n    References: [#6003](https://www.sqlalchemy.org/trac/ticket/6003)\n\n*   **[orm] [bug] [asyncio]**\n\n    The API for [`AsyncSession.delete()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.delete \"sqlalchemy.ext.asyncio.AsyncSession.delete\") is now an awaitable; this method cascades along relationships which must be loaded in a similar manner as the [`AsyncSession.merge()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.merge \"sqlalchemy.ext.asyncio.AsyncSession.merge\") method.\n\n    References: [#5998](https://www.sqlalchemy.org/trac/ticket/5998)\n\n*   **[orm] [bug]**\n\n    The unit of work process now turns off all \u201clazy=\u2019raise\u2019\u201d behavior altogether when a flush is proceeding. While there are areas where the UOW is sometimes loading things that aren\u2019t ultimately needed, the lazy=\u201draise\u201d strategy is not helpful here as the user often does not have much control or visibility into the flush process.\n\n    References: [#5984](https://www.sqlalchemy.org/trac/ticket/5984)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed bug where the \u201cschema_translate_map\u201d feature failed to be taken into account for the use case of direct execution of [`DefaultGenerator`](../core/defaults.html#sqlalchemy.schema.DefaultGenerator \"sqlalchemy.schema.DefaultGenerator\") objects such as sequences, which included the case where they were \u201cpre-executed\u201d in order to generate primary key values when implicit_returning was disabled.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#5929](https://www.sqlalchemy.org/trac/ticket/5929)\n\n*   **[engine] [bug]**\n\n    Improved engine logging to note ROLLBACK and COMMIT which is logged while the DBAPI driver is in AUTOCOMMIT mode. These ROLLBACK/COMMIT are library level and do not have any effect when AUTOCOMMIT is in effect, however it\u2019s still worthwhile to log as these indicate where SQLAlchemy sees the \u201ctransaction\u201d demarcation.\n\n    References: [#6002](https://www.sqlalchemy.org/trac/ticket/6002)\n\n*   **[engine] [bug] [regression]**\n\n    Fixed a regression where the \u201creset agent\u201d of the connection pool wasn\u2019t really being utilized by the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") when it were closed, and also leading to a double-rollback scenario that was somewhat wasteful. The newer architecture of the engine has been updated so that the connection pool \u201creset-on-return\u201d logic will be skipped when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") explicitly closes out the transaction before returning the pool to the connection.\n\n    References: [#6004](https://www.sqlalchemy.org/trac/ticket/6004)\n\n### sql\n\n*   **[sql] [change]**\n\n    Altered the compilation for the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct so that a string is returned representing the inner SELECT statement if the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") is stringified directly, outside of the context of an enclosing SELECT; This is the same behavior of [`FromClause.alias()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias \"sqlalchemy.sql.expression.FromClause.alias\") and [`Select.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.subquery \"sqlalchemy.sql.expression.Select.subquery\"). Previously, a blank string would be returned as the CTE is normally placed above a SELECT after that SELECT has been generated, which is generally misleading when debugging.\n\n*   **[sql] [bug]**\n\n    Fixed bug where the \u201cpercent escaping\u201d feature that occurs with dialects that use the \u201cformat\u201d or \u201cpyformat\u201d bound parameter styles was not enabled for the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op \"sqlalchemy.sql.expression.Operators.op\") and [`custom_op`](../core/sqlelement.html#sqlalchemy.sql.expression.custom_op \"sqlalchemy.sql.expression.custom_op\") constructs, for custom operators that use percent signs. The percent sign will now be automatically doubled based on the paramstyle as necessary.\n\n    References: [#6016](https://www.sqlalchemy.org/trac/ticket/6016)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where the \u201cunsupported compilation error\u201d for unknown datatypes would fail to raise correctly.\n\n    References: [#5979](https://www.sqlalchemy.org/trac/ticket/5979)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression where usage of the standalone [`distinct()`](../core/sqlelement.html#sqlalchemy.sql.expression.distinct \"sqlalchemy.sql.expression.distinct\") used in the form of being directly SELECTed would fail to be locatable in the result set by column identity, which is how the ORM locates columns. While standalone [`distinct()`](../core/sqlelement.html#sqlalchemy.sql.expression.distinct \"sqlalchemy.sql.expression.distinct\") is not oriented towards being directly SELECTed (use `select.distinct()` for a regular `SELECT DISTINCT..`) , it was usable to a limited extent in this way previously (but wouldn\u2019t work in subqueries, for example). The column targeting for unary expressions such as \u201cDISTINCT <col>\u201d has been improved so that this case works again, and an additional improvement has been made so that usage of this form in a subquery at least generates valid SQL which was not the case previously.\n\n    The change additionally enhances the ability to target elements in `row._mapping` based on SQL expression objects in ORM-enabled SELECT statements, including whether the statement was invoked by `connection.execute()` or `session.execute()`.\n\n    References: [#6008](https://www.sqlalchemy.org/trac/ticket/6008)\n\n### schema\n\n*   **[schema] [bug] [sqlite]**\n\n    Fixed issue where the CHECK constraint generated by [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean \"sqlalchemy.types.Boolean\") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") would fail to render the naming convention correctly after the first compilation, due to an unintended change of state within the name given to the constraint. This issue was first introduced in 0.9 in the fix for issue #3067, and the fix revises the approach taken at that time which appears to have been more involved than what was needed.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#6007](https://www.sqlalchemy.org/trac/ticket/6007)\n\n*   **[schema] [bug]**\n\n    Repaired / implemented support for primary key constraint naming conventions that use column names/keys/etc as part of the convention. In particular, this includes that the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint \"sqlalchemy.schema.PrimaryKeyConstraint\") object that\u2019s automatically associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") will update its name as new primary key [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") objects are added to the table and then to the constraint. Internal failure modes related to this constraint construction process including no columns present, no name present or blank name present are now accommodated.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#5919](https://www.sqlalchemy.org/trac/ticket/5919)\n\n*   **[schema] [bug]**\n\n    Deprecated all schema-level `.copy()` methods and renamed to `_copy()`. These are not standard Python \u201ccopy()\u201d methods as they typically rely upon being instantiated within particular contexts which are passed to the method as optional keyword arguments. The [`Table.tometadata()`](../core/metadata.html#sqlalchemy.schema.Table.tometadata \"sqlalchemy.schema.Table.tometadata\") method is the public API that provides copying for [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects.\n\n    References: [#5953](https://www.sqlalchemy.org/trac/ticket/5953)\n\n### mypy\n\n*   **[mypy] [feature]**\n\n    Rudimentary and experimental support for Mypy has been added in the form of a new plugin, which itself depends on new typing stubs for SQLAlchemy. The plugin allows declarative mappings in their standard form to both be compatible with Mypy as well as to provide typing support for mapped classes and instances.\n\n    See also\n\n    [Mypy / Pep-484 Support for ORM Mappings](../orm/extensions/mypy.html)\n\n    References: [#4609](https://www.sqlalchemy.org/trac/ticket/4609)\n\n### postgresql\n\n*   **[postgresql] [usecase] [asyncio] [mysql]**\n\n    Added an `asyncio.Lock()` within SQLAlchemy\u2019s emulated DBAPI cursor, local to the connection, for the asyncpg and aiomysql dialects for the scope of the `cursor.execute()` and `cursor.executemany()` methods. The rationale is to prevent failures and corruption for the case where the connection is used in multiple awaitables at once.\n\n    While this use case can also occur with threaded code and non-asyncio dialects, we anticipate this kind of use will be more common under asyncio, as the asyncio API is encouraging of such use. It\u2019s definitely better to use a distinct connection per concurrent awaitable however as concurrency will not be achieved otherwise.\n\n    For the asyncpg dialect, this is so that the space between the call to `prepare()` and `fetch()` is prevented from allowing concurrent executions on the connection from causing interface error exceptions, as well as preventing race conditions when starting a new transaction. Other PostgreSQL DBAPIs are threadsafe at the connection level so this intends to provide a similar behavior, outside the realm of server side cursors.\n\n    For the aiomysql dialect, the mutex will provide safety such that the statement execution and the result set fetch, which are two distinct steps at the connection level, won\u2019t get corrupted by concurrent executions on the same connection.\n\n    References: [#5967](https://www.sqlalchemy.org/trac/ticket/5967)\n\n*   **[postgresql] [bug]**\n\n    Fixed issue where using [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by \"sqlalchemy.dialects.postgresql.aggregate_order_by\") would return ARRAY(NullType) under certain conditions, interfering with the ability of the result object to return data correctly.\n\n    This change is also **backported** to: 1.3.24\n\n    References: [#5989](https://www.sqlalchemy.org/trac/ticket/5989)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fix a reflection error for MSSQL 2005 introduced by the reflection of filtered indexes.\n\n    References: [#5919](https://www.sqlalchemy.org/trac/ticket/5919)\n\n### misc\n\n*   **[usecase] [ext]**\n\n    Add new parameter [`AutomapBase.prepare.reflection_options`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflection_options \"sqlalchemy.ext.automap.AutomapBase.prepare\") to allow passing of [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect \"sqlalchemy.schema.MetaData.reflect\") options like `only` or dialect-specific reflection options like `oracle_resolve_synonyms`.\n\n    References: [#5942](https://www.sqlalchemy.org/trac/ticket/5942)\n\n*   **[bug] [ext]**\n\n    The `sqlalchemy.ext.mutable` extension now tracks the \u201cparents\u201d collection using the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState \"sqlalchemy.orm.InstanceState\") associated with objects, rather than the object itself. The latter approach required that the object be hashable so that it can be inside of a `WeakKeyDictionary`, which goes against the behavioral contract of the ORM overall which is that ORM mapped objects do not need to provide any particular kind of `__hash__()` method and that unhashable objects are supported.\n\n    References: [#6020](https://www.sqlalchemy.org/trac/ticket/6020)\n\n## 1.4.0b3\n\nReleased: February 15, 2021\n\n### orm\n\n*   **[orm] [feature]**\n\n    The ORM used in [2.0 style](../glossary.html#term-2.0-style) can now return ORM objects from the rows returned by an UPDATE..RETURNING or INSERT..RETURNING statement, by supplying the construct to [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement \"sqlalchemy.sql.expression.Select.from_statement\") in an ORM context.\n\n    See also\n\n    [Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM Objects](../orm/persistence_techniques.html#orm-dml-returning-objects)\n\n*   **[orm] [bug]**\n\n    Fixed issue in new 1.4/2.0 style ORM queries where a statement-level label style would not be preserved in the keys used by result rows; this has been applied to all combinations of Core/ORM columns / session vs. connection etc. so that the linkage from statement to result row is the same in all cases. As part of this change, the labeling of column expressions in rows has been improved to retain the original name of the ORM attribute even if used in a subquery.\n\n    References: [#5933](https://www.sqlalchemy.org/trac/ticket/5933)\n\n### engine\n\n*   **[engine] [bug] [postgresql]**\n\n    Continued with the improvement made as part of [#5653](https://www.sqlalchemy.org/trac/ticket/5653) to further support bound parameter names, including those generated against column names, for names that include colons, parenthesis, and question marks, as well as improved test support, so that bound parameter names even if they are auto-derived from column names should have no problem including for parenthesis in psycopg2\u2019s \u201cpyformat\u201d style.\n\n    As part of this change, the format used by the asyncpg DBAPI adapter (which is local to SQLAlchemy\u2019s asyncpg dialect) has been changed from using \u201cqmark\u201d paramstyle to \u201cformat\u201d, as there is a standard and internally supported SQL string escaping style for names that use percent signs with \u201cformat\u201d style (i.e. to double percent signs), as opposed to names that use question marks with \u201cqmark\u201d style (where an escaping system is not defined by pep-249 or Python).\n\n    See also\n\n    [psycopg2 dialect no longer has limitations regarding bound parameter names](migration_14.html#change-5941)\n\n    References: [#5941](https://www.sqlalchemy.org/trac/ticket/5941)\n\n### sql\n\n*   **[sql] [usecase] [postgresql] [sqlite]**\n\n    Enhance `set_` keyword of `OnConflictDoUpdate` to accept a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection \"sqlalchemy.sql.expression.ColumnCollection\"), such as the `.c.` collection from a `Selectable`, or the `.excluded` contextual object.\n\n    References: [#5939](https://www.sqlalchemy.org/trac/ticket/5939)\n\n*   **[sql] [bug]**\n\n    Fixed bug where the \u201ccartesian product\u201d assertion was not correctly accommodating for joins between tables that relied upon the use of LATERAL to connect from a subquery to another subquery in the enclosing context.\n\n    References: [#5924](https://www.sqlalchemy.org/trac/ticket/5924)\n\n*   **[sql] [bug]**\n\n    Fixed 1.4 regression where the `Function.in_()` method was not covered by tests and failed to function properly in all cases.\n\n    References: [#5934](https://www.sqlalchemy.org/trac/ticket/5934)\n\n*   **[sql] [bug]**\n\n    Fixed regression where use of an arbitrary iterable with the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") function was not working, outside of plain lists. The forwards/backwards compatibility logic here now checks for a wider range of incoming \u201citerable\u201d types including that a `.c` collection from a selectable can be passed directly. Pull request compliments of Oliver Rice.\n\n    References: [#5935](https://www.sqlalchemy.org/trac/ticket/5935)\n\n## 1.4.0b2\n\nReleased: February 3, 2021\n\n### general\n\n*   **[general] [bug]**\n\n    Fixed a SQLite source file that had non-ascii characters inside of its docstring without a source encoding, introduced within the \u201cINSERT..ON CONFLICT\u201d feature, which would cause failures under Python 2.\n\n### platform\n\n*   **[platform] [performance]**\n\n    Adjusted some elements related to internal class production at import time which added significant latency to the time spent to import the library vs. that of 1.3\\. The time is now about 20-30% slower than 1.3 instead of 200%.\n\n    References: [#5681](https://www.sqlalchemy.org/trac/ticket/5681)\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added [`ORMExecuteState.bind_mapper`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.bind_mapper \"sqlalchemy.orm.ORMExecuteState.bind_mapper\") and [`ORMExecuteState.all_mappers`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.all_mappers \"sqlalchemy.orm.ORMExecuteState.all_mappers\") accessors to [`ORMExecuteState`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState \"sqlalchemy.orm.ORMExecuteState\") event object, so that handlers can respond to the target mapper and/or mapped class or classes involved in an ORM statement execution.\n\n*   **[orm] [usecase] [asyncio]**\n\n    Added [`AsyncSession.scalar()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.scalar \"sqlalchemy.ext.asyncio.AsyncSession.scalar\"), [`AsyncSession.get()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get \"sqlalchemy.ext.asyncio.AsyncSession.get\") as well as support for [`sessionmaker.begin()`](../orm/session_api.html#sqlalchemy.orm.sessionmaker.begin \"sqlalchemy.orm.sessionmaker.begin\") to work as an async context manager with [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"). Also added [`AsyncSession.in_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.in_transaction \"sqlalchemy.ext.asyncio.AsyncSession.in_transaction\") accessor.\n\n    References: [#5796](https://www.sqlalchemy.org/trac/ticket/5796), [#5797](https://www.sqlalchemy.org/trac/ticket/5797), [#5802](https://www.sqlalchemy.org/trac/ticket/5802)\n\n*   **[orm] [changed]**\n\n    Mapper \u201cconfiguration\u201d, which occurs within the [`configure_mappers()`](../orm/mapping_api.html#sqlalchemy.orm.configure_mappers \"sqlalchemy.orm.configure_mappers\") function, is now organized to be on a per-registry basis. This allows for example the mappers within a certain declarative base to be configured, but not those of another base that is also present in memory. The goal is to provide a means of reducing application startup time by only running the \u201cconfigure\u201d process for sets of mappers that are needed. This also adds the [`registry.configure()`](../orm/mapping_api.html#sqlalchemy.orm.registry.configure \"sqlalchemy.orm.registry.configure\") method that will run configure for the mappers local in a particular registry only.\n\n    References: [#5897](https://www.sqlalchemy.org/trac/ticket/5897)\n\n*   **[orm] [bug]**\n\n    Added a comprehensive check and an informative error message for the case where a mapped class, or a string mapped class name, is passed to [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary \"sqlalchemy.orm.relationship\"). This is an extremely common error which warrants a clear message.\n\n    Additionally, added a new rule to the class registry resolution such that with regards to the [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary \"sqlalchemy.orm.relationship\") parameter, if a mapped class and its table are of the identical string name, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") will be favored when resolving this parameter. In all other cases, the class continues to be favored if a class and table share the identical name.\n\n    This change is also **backported** to: 1.3.21\n\n    References: [#5774](https://www.sqlalchemy.org/trac/ticket/5774)\n\n*   **[orm] [bug]**\n\n    Fixed bug involving the `restore_load_context` option of ORM events such as [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load \"sqlalchemy.orm.InstanceEvents.load\") such that the flag would not be carried along to subclasses which were mapped after the event handler were first established.\n\n    This change is also **backported** to: 1.3.21\n\n    References: [#5737](https://www.sqlalchemy.org/trac/ticket/5737)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed issue in new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") similar to that of the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") where the new \u201cautobegin\u201d logic could be tripped into a re-entrant (recursive) state if SQL were executed within the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create \"sqlalchemy.orm.SessionEvents.after_transaction_create\") event hook.\n\n    References: [#5845](https://www.sqlalchemy.org/trac/ticket/5845)\n\n*   **[orm] [bug] [unitofwork]**\n\n    Improved the unit of work topological sorting system such that the toplogical sort is now deterministic based on the sorting of the input set, which itself is now sorted at the level of mappers, so that the same inputs of affected mappers should produce the same output every time, among mappers / tables that don\u2019t have any dependency on each other. This further reduces the chance of deadlocks as can be observed in a flush that UPDATEs among multiple, unrelated tables such that row locks are generated.\n\n    References: [#5735](https://www.sqlalchemy.org/trac/ticket/5735)\n\n*   **[orm] [bug]**\n\n    Fixed regression where the [`Bundle.single_entity`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle.params.single_entity \"sqlalchemy.orm.Bundle\") flag would take effect for a [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle \"sqlalchemy.orm.Bundle\") even though it were not set. Additionally, this flag is legacy as it only makes sense for the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object and not 2.0 style execution. a deprecation warning is emitted when used with new-style execution.\n\n    References: [#5702](https://www.sqlalchemy.org/trac/ticket/5702)\n\n*   **[orm] [bug]**\n\n    Fixed regression where creating an [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct against a plain selectable and including a name would raise an assertionerror.\n\n    References: [#5750](https://www.sqlalchemy.org/trac/ticket/5750)\n\n*   **[orm] [bug]**\n\n    Related to the fixes for the lambda criteria system within Core, within the ORM implemented a variety of fixes for the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature as well as the [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute \"sqlalchemy.orm.SessionEvents.do_orm_execute\") event handler that is often used in conjunction [ticket:5760]:\n\n    *   fixed issue where [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") function would fail if the given entity or base included non-mapped mixins in its descending class hierarchy [ticket:5766]\n\n    *   The [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature is now unconditionally disabled for the case of ORM \u201crefresh\u201d operations, including loads of deferred or expired column attributes as well as for explicit operations like [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh \"sqlalchemy.orm.Session.refresh\"). These loads are necessarily based on primary key identity where additional WHERE criteria is never appropriate. [ticket:5762]\n\n    *   Added new attribute [`ORMExecuteState.is_column_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_column_load \"sqlalchemy.orm.ORMExecuteState.is_column_load\") to indicate that a [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute \"sqlalchemy.orm.SessionEvents.do_orm_execute\") handler that a particular operation is a primary-key-directed column attribute load, where additional criteria should not be added. The [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") function as above ignores these in any case now. [ticket:5761]\n\n    *   Fixed issue where the [`ORMExecuteState.is_relationship_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_relationship_load \"sqlalchemy.orm.ORMExecuteState.is_relationship_load\") attribute would not be set correctly for many lazy loads as well as all selectinloads. The flag is essential in order to test if options should be added to statements or if they would already have been propagated via relationship loads. [ticket:5764]\n\n    References: [#5760](https://www.sqlalchemy.org/trac/ticket/5760), [#5761](https://www.sqlalchemy.org/trac/ticket/5761), [#5762](https://www.sqlalchemy.org/trac/ticket/5762), [#5764](https://www.sqlalchemy.org/trac/ticket/5764), [#5766](https://www.sqlalchemy.org/trac/ticket/5766)\n\n*   **[orm] [bug]**\n\n    Fixed 1.4 regression where the use of [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having \"sqlalchemy.orm.Query.having\") in conjunction with queries with internally adapted SQL elements (common in inheritance scenarios) would fail due to an incorrect function call. Pull request courtesy esoh.\n\n    References: [#5781](https://www.sqlalchemy.org/trac/ticket/5781)\n\n*   **[orm] [bug]**\n\n    Fixed an issue where the API to create a custom executable SQL construct using the `sqlalchemy.ext.compiles` extension according to the documentation that\u2019s been up for many years would no longer function if only `Executable, ClauseElement` were used as the base classes, additional classes were needed if wanting to use [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\"). This has been resolved so that those extra classes aren\u2019t needed.\n\n*   **[orm] [bug] [regression]**\n\n    Fixed ORM unit of work regression where an errant \u201cassert primary_key\u201d statement interferes with primary key generation sequences that don\u2019t actually consider the columns in the table to use a real primary key constraint, instead using [`Mapper.primary_key`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key \"sqlalchemy.orm.Mapper\") to establish certain columns as \u201cprimary\u201d.\n\n    References: [#5867](https://www.sqlalchemy.org/trac/ticket/5867)\n\n### orm declarative\n\n*   **[orm] [declarative] [feature]**\n\n    Added an alternate resolution scheme to Declarative that will extract the SQLAlchemy column or mapped property from the \u201cmetadata\u201d dictionary of a dataclasses.Field object. This allows full declarative mappings to be combined with dataclass fields.\n\n    See also\n\n    [Mapping pre-existing dataclasses using Declarative-style fields](../orm/dataclasses.html#orm-declarative-dataclasses-declarative-table)\n\n    References: [#5745](https://www.sqlalchemy.org/trac/ticket/5745)\n\n### engine\n\n*   **[engine] [feature]**\n\n    Dialect-specific constructs such as [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") can now stringify in-place without the need to specify an explicit dialect object. The constructs, when called upon for `str()`, `print()`, etc. now have internal direction to call upon their appropriate dialect rather than the \u201cdefault\u201ddialect which doesn\u2019t know how to stringify these. The approach is also adapted to generic schema-level create/drop such as [`AddConstraint`](../core/ddl.html#sqlalchemy.schema.AddConstraint \"sqlalchemy.schema.AddConstraint\"), which will adapt its stringify dialect to one indicated by the element within it, such as the [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint \"sqlalchemy.dialects.postgresql.ExcludeConstraint\") object.\n\n*   **[engine] [feature]**\n\n    Added new execution option [`Connection.execution_options.logging_token`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.logging_token \"sqlalchemy.engine.Connection.execution_options\"). This option will add an additional per-message token to log messages generated by the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") as it executes statements. This token is not part of the logger name itself (that part can be affected using the existing [`create_engine.logging_name`](../core/engines.html#sqlalchemy.create_engine.params.logging_name \"sqlalchemy.create_engine\") parameter), so is appropriate for ad-hoc connection use without the side effect of creating many new loggers. The option can be set at the level of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") or [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\").\n\n    See also\n\n    [Setting Per-Connection / Sub-Engine Tokens](../core/engines.html#dbengine-logging-tokens)\n\n    References: [#5911](https://www.sqlalchemy.org/trac/ticket/5911)\n\n*   **[engine] [bug] [sqlite]**\n\n    Fixed bug in the 2.0 \u201cfuture\u201d version of [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") where emitting SQL during the `EngineEvents.begin()` event hook would cause a re-entrant (recursive) condition due to autobegin, affecting among other things the recipe documented for SQLite to allow for savepoints and serializable isolation support.\n\n    References: [#5845](https://www.sqlalchemy.org/trac/ticket/5845)\n\n*   **[engine] [bug] [oracle] [postgresql]**\n\n    Adjusted the \u201csetinputsizes\u201d logic relied upon by the cx_Oracle, asyncpg and pg8000 dialects to support a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\") that includes an override the [`TypeDecorator.get_dbapi_type()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.get_dbapi_type \"sqlalchemy.types.TypeDecorator.get_dbapi_type\") method.\n\n*   **[engine] [bug]**\n\n    Added the \u201cfuture\u201d keyword to the list of words that are known by the [`engine_from_config()`](../core/engines.html#sqlalchemy.engine_from_config \"sqlalchemy.engine_from_config\") function, so that the values \u201ctrue\u201d and \u201cfalse\u201d may be configured as \u201cboolean\u201d values when using a key such as `sqlalchemy.future = true` or `sqlalchemy.future = false`.\n\n### sql\n\n*   **[sql] [feature]**\n\n    Implemented support for \u201ctable valued functions\u201d along with additional syntaxes supported by PostgreSQL, one of the most commonly requested features. Table valued functions are SQL functions that return lists of values or rows, and are prevalent in PostgreSQL in the area of JSON functions, where the \u201ctable value\u201d is commonly referred to as the \u201crecord\u201d datatype. Table valued functions are also supported by Oracle and SQL Server.\n\n    Features added include:\n\n    *   the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued \"sqlalchemy.sql.functions.FunctionElement.table_valued\") modifier that creates a table-like selectable object from a SQL function\n\n    *   A [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias \"sqlalchemy.sql.expression.TableValuedAlias\") construct that renders a SQL function as a named table\n\n    *   Support for PostgreSQL\u2019s special \u201cderived column\u201d syntax that includes column names and sometimes datatypes, such as for the `json_to_recordset` function, using the [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") method.\n\n    *   Support for PostgreSQL\u2019s \u201cWITH ORDINALITY\u201d construct using the [`FunctionElement.table_valued.with_ordinality`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.with_ordinality \"sqlalchemy.sql.functions.FunctionElement.table_valued\") parameter\n\n    *   Support for selection FROM a SQL function as column-valued scalar, a syntax supported by PostgreSQL and Oracle, via the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") method\n\n    *   A way to SELECT a single column from a table-valued expression without using a FROM clause via the [`FunctionElement.scalar_table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.scalar_table_valued \"sqlalchemy.sql.functions.FunctionElement.scalar_table_valued\") method.\n\n    See also\n\n    [Table-Valued Functions](../tutorial/data_select.html#tutorial-functions-table-valued) - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)\n\n    References: [#3566](https://www.sqlalchemy.org/trac/ticket/3566)\n\n*   **[sql] [usecase]**\n\n    Multiple calls to \u201creturning\u201d, e.g. [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning \"sqlalchemy.sql.expression.Insert.returning\"), may now be chained to add new columns to the RETURNING clause.\n\n    References: [#5695](https://www.sqlalchemy.org/trac/ticket/5695)\n\n*   **[sql] [usecase]**\n\n    Added [`Select.outerjoin_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin_from \"sqlalchemy.sql.expression.Select.outerjoin_from\") method to complement [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from \"sqlalchemy.sql.expression.Select.join_from\").\n\n*   **[sql] [usecase]**\n\n    Adjusted the \u201cliteral_binds\u201d feature of `Compiler` to render NULL for a bound parameter that has `None` as the value, either explicitly passed or omitted. The previous error message \u201cbind parameter without a renderable value\u201d is removed, and a missing or `None` value will now render NULL in all cases. Previously, rendering of NULL was starting to happen for DML statements due to internal refactorings, but was not explicitly part of test coverage, which it now is.\n\n    While no error is raised, when the context is within that of a column comparison, and the operator is not \u201cIS\u201d/\u201dIS NOT\u201d, a warning is emitted that this is not generally useful from a SQL perspective.\n\n    References: [#5888](https://www.sqlalchemy.org/trac/ticket/5888)\n\n*   **[sql] [bug]**\n\n    Fixed issue in new [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") method where chaining from the current JOIN wasn\u2019t looking at the right state, causing an expression like \u201cFROM a JOIN b <onclause>, b JOIN c <onclause>\u201d rather than \u201cFROM a JOIN b <onclause> JOIN c <onclause>\u201d.\n\n    References: [#5858](https://www.sqlalchemy.org/trac/ticket/5858)\n\n*   **[sql] [bug]**\n\n    Deprecation warnings are emitted under \u201cSQLALCHEMY_WARN_20\u201d mode when passing a plain string to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\").\n\n    References: [#5754](https://www.sqlalchemy.org/trac/ticket/5754)\n\n*   **[sql] [bug] [orm]**\n\n    A wide variety of fixes to the \u201clambda SQL\u201d feature introduced at [Using Lambdas to add significant speed gains to statement production](../core/connections.html#engine-lambda-caching) have been implemented based on user feedback, with an emphasis on its use within the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature where it is most prominently used [ticket:5760]:\n\n    *   Fixed the issue where boolean True/False values, which were referred to in the closure variables of the lambda, would cause failures. [ticket:5763]\n\n    *   Repaired a non-working detection for Python functions embedded in the lambda that produce bound values; this case is likely not supportable so raises an informative error, where the function should be invoked outside the lambda itself. New documentation has been added to further detail this behavior. [ticket:5770]\n\n    *   The lambda system by default now rejects the use of non-SQL elements within the closure variables of the lambda entirely, where the error suggests the two options of either explicitly ignoring closure variables that are not SQL parameters, or specifying a specific set of values to be considered as part of the cache key based on hash value. This critically prevents the lambda system from assuming that arbitrary objects within the lambda\u2019s closure are appropriate for caching while also refusing to ignore them by default, preventing the case where their state might not be constant and have an impact on the SQL construct produced. The error message is comprehensive and new documentation has been added to further detail this behavior. [ticket:5765]\n\n    *   Fixed support for the edge case where an `in_()` expression against a list of SQL elements, such as [`literal()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal \"sqlalchemy.sql.expression.literal\") objects, would fail to be accommodated correctly. [ticket:5768]\n\n    References: [#5760](https://www.sqlalchemy.org/trac/ticket/5760), [#5763](https://www.sqlalchemy.org/trac/ticket/5763), [#5765](https://www.sqlalchemy.org/trac/ticket/5765), [#5768](https://www.sqlalchemy.org/trac/ticket/5768), [#5770](https://www.sqlalchemy.org/trac/ticket/5770)\n\n*   **[sql] [bug] [mysql] [postgresql] [sqlite]**\n\n    An informative error message is now raised for a selected set of DML methods (currently all part of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") constructs) if they are called a second time, which would implicitly cancel out the previous setting. The methods altered include: [`on_conflict_do_update`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update \"sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update\"), [`on_conflict_do_nothing`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing \"sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing\") (SQLite), [`on_conflict_do_update`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\"), [`on_conflict_do_nothing`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing\") (PostgreSQL), [`on_duplicate_key_update`](../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update \"sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update\") (MySQL)\n\n    References: [#5169](https://www.sqlalchemy.org/trac/ticket/5169)\n\n*   **[sql] [bug]**\n\n    Fixed issue in new [`Values`](../core/selectable.html#sqlalchemy.sql.expression.Values \"sqlalchemy.sql.expression.Values\") construct where passing tuples of objects would fall back to per-value type detection rather than making use of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") objects passed directly to [`Values`](../core/selectable.html#sqlalchemy.sql.expression.Values \"sqlalchemy.sql.expression.Values\") that tells SQLAlchemy what the expected type is. This would lead to issues for objects such as enumerations and numpy strings that are not actually necessary since the expected type is given.\n\n    References: [#5785](https://www.sqlalchemy.org/trac/ticket/5785)\n\n*   **[sql] [bug]**\n\n    Fixed issue where a `RemovedIn20Warning` would erroneously emit when the `.bind` attribute were accessed internally on objects, particularly when stringifying a SQL construct.\n\n    References: [#5717](https://www.sqlalchemy.org/trac/ticket/5717)\n\n*   **[sql] [bug]**\n\n    Properly render `cycle=False` and `order=False` as `NO CYCLE` and `NO ORDER` in `Sequence` and `Identity` objects.\n\n    References: [#5722](https://www.sqlalchemy.org/trac/ticket/5722)\n\n*   **[sql]**\n\n    Replace [`Query.with_labels()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_labels \"sqlalchemy.orm.Query.with_labels\") and `GenerativeSelect.apply_labels()` with explicit getters and setters [`GenerativeSelect.get_label_style()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.get_label_style \"sqlalchemy.sql.expression.GenerativeSelect.get_label_style\") and [`GenerativeSelect.set_label_style()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.set_label_style \"sqlalchemy.sql.expression.GenerativeSelect.set_label_style\") to accommodate the three supported label styles: `LABEL_STYLE_DISAMBIGUATE_ONLY`, `LABEL_STYLE_TABLENAME_PLUS_COL`, and `LABEL_STYLE_NONE`.\n\n    In addition, for Core and \u201cfuture style\u201d ORM queries, `LABEL_STYLE_DISAMBIGUATE_ONLY` is now the default label style. This style differs from the existing \u201cno labels\u201d style in that labeling is applied in the case of column name conflicts; with `LABEL_STYLE_NONE`, a duplicate column name is not accessible via name in any case.\n\n    For cases where labeling is significant, namely that the `.c` collection of a subquery is able to refer to all columns unambiguously, the behavior of `LABEL_STYLE_DISAMBIGUATE_ONLY` is now sufficient for all SQLAlchemy features across Core and ORM which involve this behavior. Result set rows since SQLAlchemy 1.0 are usually aligned with column constructs positionally.\n\n    For legacy ORM queries using [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\"), the table-plus-column names labeling style applied by `LABEL_STYLE_TABLENAME_PLUS_COL` continues to be used so that existing test suites and logging facilities see no change in behavior by default.\n\n    References: [#4757](https://www.sqlalchemy.org/trac/ticket/4757)\n\n### schema\n\n*   **[schema] [feature]**\n\n    Added [`TypeEngine.as_generic()`](../core/type_api.html#sqlalchemy.types.TypeEngine.as_generic \"sqlalchemy.types.TypeEngine.as_generic\") to map dialect-specific types, such as [`sqlalchemy.dialects.mysql.INTEGER`](../dialects/mysql.html#sqlalchemy.dialects.mysql.INTEGER \"sqlalchemy.dialects.mysql.INTEGER\"), with the \u201cbest match\u201d generic SQLAlchemy type, in this case [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer \"sqlalchemy.types.Integer\"). Pull request courtesy Andrew Hannigan.\n\n    See also\n\n    [Reflecting with Database-Agnostic Types](../core/reflection.html#metadata-reflection-dbagnostic-types) - example usage\n\n    References: [#5659](https://www.sqlalchemy.org/trac/ticket/5659)\n\n*   **[schema] [usecase]**\n\n    The [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect \"sqlalchemy.events.DDLEvents.column_reflect\") event may now be applied to a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") object where it will take effect for the [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects local to that collection.\n\n    See also\n\n    [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect \"sqlalchemy.events.DDLEvents.column_reflect\")\n\n    [Automating Column Naming Schemes from Reflected Tables](../orm/declarative_tables.html#mapper-automated-reflection-schemes) - in the ORM mapping documentation\n\n    [Intercepting Column Definitions](../orm/extensions/automap.html#automap-intercepting-columns) - in the [Automap](../orm/extensions/automap.html) documentation\n\n    References: [#5712](https://www.sqlalchemy.org/trac/ticket/5712)\n\n*   **[schema] [usecase]**\n\n    Added parameters [`CreateTable.if_not_exists`](../core/ddl.html#sqlalchemy.schema.CreateTable.params.if_not_exists \"sqlalchemy.schema.CreateTable\"), [`CreateIndex.if_not_exists`](../core/ddl.html#sqlalchemy.schema.CreateIndex.params.if_not_exists \"sqlalchemy.schema.CreateIndex\"), [`DropTable.if_exists`](../core/ddl.html#sqlalchemy.schema.DropTable.params.if_exists \"sqlalchemy.schema.DropTable\") and [`DropIndex.if_exists`](../core/ddl.html#sqlalchemy.schema.DropIndex.params.if_exists \"sqlalchemy.schema.DropIndex\") to the [`CreateTable`](../core/ddl.html#sqlalchemy.schema.CreateTable \"sqlalchemy.schema.CreateTable\"), [`DropTable`](../core/ddl.html#sqlalchemy.schema.DropTable \"sqlalchemy.schema.DropTable\"), [`CreateIndex`](../core/ddl.html#sqlalchemy.schema.CreateIndex \"sqlalchemy.schema.CreateIndex\") and [`DropIndex`](../core/ddl.html#sqlalchemy.schema.DropIndex \"sqlalchemy.schema.DropIndex\") constructs which result in \u201cIF NOT EXISTS\u201d / \u201cIF EXISTS\u201d DDL being added to the CREATE/DROP. These phrases are not accepted by all databases and the operation will fail on a database that does not support it as there is no similarly compatible fallback within the scope of a single DDL statement. Pull request courtesy Ramon Williams.\n\n    References: [#2843](https://www.sqlalchemy.org/trac/ticket/2843)\n\n*   **[schema] [changed]**\n\n    Altered the behavior of the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") construct such that when applied to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\"), it will automatically imply that the value of `Column.nullable` should default to `False`, in a similar manner as when the `Column.primary_key` parameter is set to `True`. This matches the default behavior of all supporting databases where `IDENTITY` implies `NOT NULL`. The PostgreSQL backend is the only one that supports adding `NULL` to an `IDENTITY` column, which is here supported by passing a `True` value for the `Column.nullable` parameter at the same time.\n\n    References: [#5775](https://www.sqlalchemy.org/trac/ticket/5775)\n\n### asyncio\n\n*   **[asyncio] [usecase]**\n\n    The [`AsyncEngine`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine \"sqlalchemy.ext.asyncio.AsyncEngine\"), [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection \"sqlalchemy.ext.asyncio.AsyncConnection\") and [`AsyncTransaction`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction \"sqlalchemy.ext.asyncio.AsyncTransaction\") objects may be compared using Python `==` or `!=`, which will compare the two given objects based on the \u201csync\u201d object they are proxying towards. This is useful as there are cases particularly for [`AsyncTransaction`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction \"sqlalchemy.ext.asyncio.AsyncTransaction\") where multiple instances of [`AsyncTransaction`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction \"sqlalchemy.ext.asyncio.AsyncTransaction\") can be proxying towards the same sync [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction \"sqlalchemy.engine.Transaction\"), and are actually equivalent. The [`AsyncConnection.get_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_transaction \"sqlalchemy.ext.asyncio.AsyncConnection.get_transaction\") method will currently return a new proxying [`AsyncTransaction`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction \"sqlalchemy.ext.asyncio.AsyncTransaction\") each time as the [`AsyncTransaction`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction \"sqlalchemy.ext.asyncio.AsyncTransaction\") is not otherwise statefully associated with its originating [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection \"sqlalchemy.ext.asyncio.AsyncConnection\").\n\n*   **[asyncio] [bug]**\n\n    Adjusted the greenlet integration, which provides support for Python asyncio in SQLAlchemy, to accommodate for the handling of Python `contextvars` (introduced in Python 3.7) for `greenlet` versions greater than 0.4.17. Greenlet version 0.4.17 added automatic handling of contextvars in a backwards-incompatible way; we\u2019ve coordinated with the greenlet authors to add a preferred API for this in versions subsequent to 0.4.17 which is now supported by SQLAlchemy\u2019s greenlet integration. For greenlet versions prior to 0.4.17 no behavioral change is needed, version 0.4.17 itself is blocked from the dependencies.\n\n    References: [#5615](https://www.sqlalchemy.org/trac/ticket/5615)\n\n*   **[asyncio] [bug]**\n\n    Implemented \u201cconnection-binding\u201d for [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"), the ability to pass an [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection \"sqlalchemy.ext.asyncio.AsyncConnection\") to create an [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"). Previously, this use case was not implemented and would use the associated engine when the connection were passed. This fixes the issue where the \u201cjoin a session to an external transaction\u201d use case would not work correctly for the [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\"). Additionally, added methods [`AsyncConnection.in_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.in_transaction \"sqlalchemy.ext.asyncio.AsyncConnection.in_transaction\"), [`AsyncConnection.in_nested_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.in_nested_transaction \"sqlalchemy.ext.asyncio.AsyncConnection.in_nested_transaction\"), [`AsyncConnection.get_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_transaction \"sqlalchemy.ext.asyncio.AsyncConnection.get_transaction\"), [`AsyncConnection.get_nested_transaction()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_nested_transaction \"sqlalchemy.ext.asyncio.AsyncConnection.get_nested_transaction\") and [`AsyncConnection.info`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.info \"sqlalchemy.ext.asyncio.AsyncConnection.info\") attribute.\n\n    References: [#5811](https://www.sqlalchemy.org/trac/ticket/5811)\n\n*   **[asyncio] [bug]**\n\n    Fixed bug in asyncio connection pool where `asyncio.TimeoutError` would be raised rather than [`TimeoutError`](../core/exceptions.html#sqlalchemy.exc.TimeoutError \"sqlalchemy.exc.TimeoutError\"). Also repaired the [`create_engine.pool_timeout`](../core/engines.html#sqlalchemy.create_engine.params.pool_timeout \"sqlalchemy.create_engine\") parameter set to zero when using the async engine, which previously would ignore the timeout and block rather than timing out immediately as is the behavior with regular [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool \"sqlalchemy.pool.QueuePool\").\n\n    References: [#5827](https://www.sqlalchemy.org/trac/ticket/5827)\n\n*   **[asyncio] [bug] [pool]**\n\n    When using an asyncio engine, the connection pool will now detach and discard a pooled connection that is was not explicitly closed/returned to the pool when its tracking object is garbage collected, emitting a warning that the connection was not properly closed. As this operation occurs during Python gc finalizers, it\u2019s not safe to run any IO operations upon the connection including transaction rollback or connection close as this will often be outside of the event loop.\n\n    The `AsyncAdaptedQueue` used by default on async dpapis should instantiate a queue only when it\u2019s first used to avoid binding it to a possibly wrong event loop.\n\n    References: [#5823](https://www.sqlalchemy.org/trac/ticket/5823)\n\n*   **[asyncio]**\n\n    The SQLAlchemy async mode now detects and raises an informative error when an non asyncio compatible [DBAPI](../glossary.html#term-DBAPI) is used. Using a standard `DBAPI` with async SQLAlchemy will cause it to block like any sync call, interrupting the executing asyncio loop.\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added new parameter [`ExcludeConstraint.ops`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops \"sqlalchemy.dialects.postgresql.ExcludeConstraint\") to the [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint \"sqlalchemy.dialects.postgresql.ExcludeConstraint\") object, to support operator class specification with this constraint. Pull request courtesy Alon Menczer.\n\n    This change is also **backported** to: 1.3.21\n\n    References: [#5604](https://www.sqlalchemy.org/trac/ticket/5604)\n\n*   **[postgresql] [usecase]**\n\n    Added a read/write `.autocommit` attribute to the DBAPI-adaptation layer for the asyncpg dialect. This so that when working with DBAPI-specific schemes that need to use \u201cautocommit\u201d directly with the DBAPI connection, the same `.autocommit` attribute which works with both psycopg2 as well as pg8000 is available.\n\n*   **[postgresql] [changed]**\n\n    Fixed issue where the psycopg2 dialect would silently pass the `use_native_unicode=False` flag without actually having any effect under Python 3, as the psycopg2 DBAPI uses Unicode unconditionally under Python 3\\. This usage now raises an [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError \"sqlalchemy.exc.ArgumentError\") when used under Python 3\\. Added test support for Python 2.\n\n*   **[postgresql] [performance]**\n\n    Enhanced the performance of the asyncpg dialect by caching the asyncpg PreparedStatement objects on a per-connection basis. For a test case that makes use of the same statement on a set of pooled connections this appears to grant a 10-20% speed improvement. The cache size is adjustable and may also be disabled.\n\n    See also\n\n    [Prepared Statement Cache](../dialects/postgresql.html#asyncpg-prepared-statement-cache)\n\n*   **[postgresql] [bug] [mysql]**\n\n    Fixed regression introduced in 1.3.2 for the PostgreSQL dialect, also copied out to the MySQL dialect\u2019s feature in 1.3.18, where usage of a non [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") construct such as [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") as the argument to [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of \"sqlalchemy.sql.expression.Select.with_for_update\") would fail to be accommodated correctly within the PostgreSQL or MySQL compilers.\n\n    This change is also **backported** to: 1.3.21\n\n    References: [#5729](https://www.sqlalchemy.org/trac/ticket/5729)\n\n*   **[postgresql] [bug]**\n\n    Fixed a small regression where the query for \u201cshow standard_conforming_strings\u201d upon initialization would be emitted even if the server version info were detected as less than version 8.2, previously it would only occur for server version 8.2 or greater. The query fails on Amazon Redshift which reports a PG server version older than this value.\n\n    References: [#5698](https://www.sqlalchemy.org/trac/ticket/5698)\n\n*   **[postgresql] [bug]**\n\n    Established support for [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") objects as well as ORM instrumented attributes as keys in the `set_` dictionary passed to the [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") and [`Insert.on_conflict_do_update()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update \"sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update\") methods, which match to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") objects in the `.c` collection of the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\"). Previously, only string column names were expected; a column expression would be assumed to be an out-of-table expression that would render fully along with a warning.\n\n    References: [#5722](https://www.sqlalchemy.org/trac/ticket/5722)\n\n*   **[postgresql] [bug] [asyncio]**\n\n    Fixed bug in asyncpg dialect where a failure during a \u201ccommit\u201d or less likely a \u201crollback\u201d should cancel the entire transaction; it\u2019s no longer possible to emit rollback. Previously the connection would continue to await a rollback that could not succeed as asyncpg would reject it.\n\n    References: [#5824](https://www.sqlalchemy.org/trac/ticket/5824)\n\n### mysql\n\n*   **[mysql] [feature]**\n\n    Added support for the aiomysql driver when using the asyncio SQLAlchemy extension.\n\n    See also\n\n    [aiomysql](../dialects/mysql.html#aiomysql)\n\n    References: [#5747](https://www.sqlalchemy.org/trac/ticket/5747)\n\n*   **[mysql] [bug] [reflection]**\n\n    Fixed issue where reflecting a server default on MariaDB only that contained a decimal point in the value would fail to be reflected correctly, leading towards a reflected table that lacked any server default.\n\n    This change is also **backported** to: 1.3.21\n\n    References: [#5744](https://www.sqlalchemy.org/trac/ticket/5744)\n\n### sqlite\n\n*   **[sqlite] [usecase]**\n\n    Implemented INSERT\u2026 ON CONFLICT clause for SQLite. Pull request courtesy Ramon Williams.\n\n    See also\n\n    [INSERT\u2026ON CONFLICT (Upsert)](../dialects/sqlite.html#sqlite-on-conflict-insert)\n\n    References: [#4010](https://www.sqlalchemy.org/trac/ticket/4010)\n\n*   **[sqlite] [bug]**\n\n    Use python `re.search()` instead of `re.match()` as the operation used by the `Column.regexp_match()` method when using sqlite. This matches the behavior of regular expressions on other databases as well as that of well-known SQLite plugins.\n\n    References: [#5699](https://www.sqlalchemy.org/trac/ticket/5699)\n\n### mssql\n\n*   **[mssql] [bug] [datatypes] [mysql]**\n\n    Decimal accuracy and behavior has been improved when extracting floating point and/or decimal values from JSON strings using the `Comparator.as_float()` method, when the numeric value inside of the JSON string has many significant digits; previously, MySQL backends would truncate values with many significant digits and SQL Server backends would raise an exception due to a DECIMAL cast with insufficient significant digits. Both backends now use a FLOAT-compatible approach that does not hardcode significant digits for floating point values. For precision numerics, a new method `Comparator.as_numeric()` has been added which accepts arguments for precision and scale, and will return values as Python `Decimal` objects with no floating point conversion assuming the DBAPI supports it (all but pysqlite).\n\n    References: [#5788](https://www.sqlalchemy.org/trac/ticket/5788)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed regression which occurred due to [#5755](https://www.sqlalchemy.org/trac/ticket/5755) which implemented isolation level support for Oracle. It has been reported that many Oracle accounts don\u2019t actually have permission to query the `v$transaction` view so this feature has been altered to gracefully fallback when it fails upon database connect, where the dialect will assume \u201cREAD COMMITTED\u201d is the default isolation level as was the case prior to SQLAlchemy 1.3.21. However, explicit use of the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level \"sqlalchemy.engine.Connection.get_isolation_level\") method must now necessarily raise an exception, as Oracle databases with this restriction explicitly disallow the user from reading the current isolation level.\n\n    This change is also **backported** to: 1.3.22\n\n    References: [#5784](https://www.sqlalchemy.org/trac/ticket/5784)\n\n*   **[oracle] [bug]**\n\n    Oracle two-phase transactions at a rudimentary level are now no longer deprecated. After receiving support from cx_Oracle devs we can provide for basic xid + begin/prepare support with some limitations, which will work more fully in an upcoming release of cx_Oracle. Two phase \u201crecovery\u201d is not currently supported.\n\n    References: [#5884](https://www.sqlalchemy.org/trac/ticket/5884)\n\n*   **[oracle] [bug]**\n\n    The Oracle dialect now uses `select sys_context( 'userenv', 'current_schema' ) from dual` to get the default schema name, rather than `SELECT USER FROM DUAL`, to accommodate for changes to the session-local schema name under Oracle.\n\n    References: [#5716](https://www.sqlalchemy.org/trac/ticket/5716)\n\n### tests\n\n*   **[tests] [usecase] [pool]**\n\n    Improve documentation and add test for sub-second pool timeouts. Pull request courtesy Jordan Pittier.\n\n    References: [#5582](https://www.sqlalchemy.org/trac/ticket/5582)\n\n### misc\n\n*   **[usecase] [pool]**\n\n    The internal mechanics of the engine connection routine has been altered such that it\u2019s now guaranteed that a user-defined event handler for the `PoolEvents.connect()` handler, when established using `insert=True`, will allow an event handler to run that is definitely invoked **before** any dialect-specific initialization starts up, most notably when it does things like detect default schema name. Previously, this would occur in most cases but not unconditionally. A new example is added to the schema documentation illustrating how to establish the \u201cdefault schema name\u201d within an on-connect event.\n\n    References: [#5497](https://www.sqlalchemy.org/trac/ticket/5497), [#5708](https://www.sqlalchemy.org/trac/ticket/5708)\n\n*   **[bug] [reflection]**\n\n    Fixed bug where the now-deprecated `autoload` parameter was being called internally within the reflection routines when a related table were reflected.\n\n    References: [#5684](https://www.sqlalchemy.org/trac/ticket/5684)\n\n*   **[bug] [pool]**\n\n    Fixed regression where a connection pool event specified with a keyword, most notably `insert=True`, would be lost when the event were set up. This would prevent startup events that need to fire before dialect-level events from working correctly.\n\n    References: [#5708](https://www.sqlalchemy.org/trac/ticket/5708)\n\n*   **[bug] [pool] [pypy]**\n\n    Fixed issue where connection pool would not return connections to the pool or otherwise be finalized upon garbage collection under pypy if the checked out connection fell out of scope without being closed. This is a long standing issue due to pypy\u2019s difference in GC behavior that does not call weakref finalizers if they are relative to another object that is also being garbage collected. A strong reference to the related record is now maintained so that the weakref has a strong-referenced \u201cbase\u201d to trigger off of.\n\n    References: [#5842](https://www.sqlalchemy.org/trac/ticket/5842)\n\n## 1.4.0b1\n\nReleased: November 2, 2020\n\n### general\n\n*   **[general] [change]**\n\n    \u201dpython setup.py test\u201d is no longer a test runner, as this is deprecated by Pypa. Please use \u201ctox\u201d with no arguments for a basic test run.\n\n    References: [#4789](https://www.sqlalchemy.org/trac/ticket/4789)\n\n*   **[general] [bug]**\n\n    Refactored the internal conventions used to cross-import modules that have mutual dependencies between them, such that the inspected arguments of functions and methods are no longer modified. This allows tools like pylint, Pycharm, other code linters, as well as hypothetical pep-484 implementations added in the future to function correctly as they no longer see missing arguments to function calls. The new approach is also simpler and more performant.\n\n    See also\n\n    [Repaired internal importing conventions such that code linters may work correctly](migration_14.html#change-4656)\n\n    References: [#4656](https://www.sqlalchemy.org/trac/ticket/4656), [#4689](https://www.sqlalchemy.org/trac/ticket/4689)\n\n### platform\n\n*   **[platform] [change]**\n\n    The `importlib_metadata` library is used to scan for setuptools entrypoints rather than pkg_resources. as importlib_metadata is a small library that is included as of Python 3.8, the compatibility library is installed as a dependency for Python versions older than 3.8.\n\n    References: [#5400](https://www.sqlalchemy.org/trac/ticket/5400)\n\n*   **[platform] [change]**\n\n    Installation has been modernized to use setup.cfg for most package metadata.\n\n    References: [#5404](https://www.sqlalchemy.org/trac/ticket/5404)\n\n*   **[platform] [removed]**\n\n    Dropped support for python 3.4 and 3.5 that has reached EOL. SQLAlchemy 1.4 series requires python 2.7 or 3.6+.\n\n    See also\n\n    [Python 3.6 is the minimum Python 3 version; Python 2.7 still supported](migration_14.html#change-5634)\n\n    References: [#5634](https://www.sqlalchemy.org/trac/ticket/5634)\n\n*   **[platform] [removed]**\n\n    Removed all dialect code related to support for Jython and zxJDBC. Jython has not been supported by SQLAlchemy for many years and it is not expected that the current zxJDBC code is at all functional; for the moment it just takes up space and adds confusion by showing up in documentation. At the moment, it appears that Jython has achieved Python 2.7 support in its releases but not Python 3\\. If Jython were to be supported again, the form it should take is against the Python 3 version of Jython, and the various zxJDBC stubs for various backends should be implemented as a third party dialect.\n\n    References: [#5094](https://www.sqlalchemy.org/trac/ticket/5094)\n\n### orm\n\n*   **[orm] [feature]**\n\n    The ORM can now generate queries previously only available when using [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") using the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct directly. A new system by which ORM \u201cplugins\u201d may establish themselves within a Core [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") allow the majority of query building logic previously inside of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") to now take place within a compilation-level extension for [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\"). Similar changes have been made for the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") constructs as well. The constructs when invoked using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") now do ORM-related work within the method. For [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\"), the [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object returned now contains ORM-level entities and results.\n\n    See also\n\n    [ORM Query is internally unified with select, update, delete; 2.0 style execution available](migration_14.html#change-5159)\n\n    References: [#5159](https://www.sqlalchemy.org/trac/ticket/5159)\n\n*   **[orm] [feature]**\n\n    Added the ability to add arbitrary criteria to the ON clause generated by a relationship attribute in a query, which applies to methods such as [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") as well as loader options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\"). Additionally, a \u201cglobal\u201d version of the option allows limiting criteria to be applied to particular entities in a query globally.\n\n    See also\n\n    [Adding Criteria to loader options](../orm/queryguide/relationships.html#loader-option-criteria)\n\n    [Adding global WHERE / ON criteria](../orm/session_events.html#do-orm-execute-global-criteria)\n\n    [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\")\n\n    References: [#4472](https://www.sqlalchemy.org/trac/ticket/4472)\n\n*   **[orm] [feature]**\n\n    The ORM Declarative system is now unified into the ORM itself, with new import spaces under `sqlalchemy.orm` and new kinds of mappings. Support for decorator-based mappings without using a base class, support for classical style-mapper() calls that have access to the declarative class registry for relationships, and full integration of Declarative with 3rd party class attribute systems like `dataclasses` and `attrs` is now supported.\n\n    See also\n\n    [Declarative is now integrated into the ORM with new features](migration_14.html#change-5508)\n\n    [Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)\n\n    References: [#5508](https://www.sqlalchemy.org/trac/ticket/5508)\n\n*   **[orm] [feature]**\n\n    Eager loaders, such as joined loading, SELECT IN loading, etc., when configured on a mapper or via query options will now be invoked during the refresh on an expired object; in the case of selectinload and subqueryload, since the additional load is for a single object only, the \u201cimmediateload\u201d scheme is used in these cases which resembles the single-parent query emitted by lazy loading.\n\n    See also\n\n    [Eager loaders emit during unexpire operations](migration_14.html#change-1763)\n\n    References: [#1763](https://www.sqlalchemy.org/trac/ticket/1763)\n\n*   **[orm] [feature]**\n\n    Added support for direct mapping of Python classes that are defined using the Python `dataclasses` decorator. Pull request courtesy V\u00e1clav Klus\u00e1k. The new feature integrates into new support at the Declarative level for systems such as `dataclasses` and `attrs`.\n\n    See also\n\n    [Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)\n\n    [Declarative is now integrated into the ORM with new features](migration_14.html#change-5508)\n\n    References: [#5027](https://www.sqlalchemy.org/trac/ticket/5027)\n\n*   **[orm] [feature]**\n\n    Added \u201craiseload\u201d feature for ORM mapped columns via [`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload \"sqlalchemy.orm.defer\") parameter on [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer \"sqlalchemy.orm.defer\") and [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred \"sqlalchemy.orm.deferred\"). This provides similar behavior for column-expression mapped attributes as the [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload \"sqlalchemy.orm.raiseload\") option does for relationship mapped attributes. The change also includes some behavioral changes to deferred columns regarding expiration; see the migration notes for details.\n\n    See also\n\n    [Raiseload for Columns](migration_14.html#change-4826)\n\n    References: [#4826](https://www.sqlalchemy.org/trac/ticket/4826)\n\n*   **[orm] [usecase]**\n\n    The evaluator that takes place within the ORM bulk update and delete for synchronize_session=\u201devaluate\u201d now supports the IN and NOT IN operators. Tuple IN is also supported.\n\n    References: [#1653](https://www.sqlalchemy.org/trac/ticket/1653)\n\n*   **[orm] [usecase]**\n\n    Enhanced logic that tracks if relationships will be conflicting with each other when they write to the same column to include simple cases of two relationships that should have a \u201cbackref\u201d between them. This means that if two relationships are not viewonly, are not linked with back_populates and are not otherwise in an inheriting sibling/overriding arrangement, and will populate the same foreign key column, a warning is emitted at mapper configuration time warning that a conflict may arise. A new parameter [`relationship.overlaps`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps \"sqlalchemy.orm.relationship\") is added to suit those very rare cases where such an overlapping persistence arrangement may be unavoidable.\n\n    References: [#5171](https://www.sqlalchemy.org/trac/ticket/5171)\n\n*   **[orm] [usecase]**\n\n    The ORM bulk update and delete operations, historically available via the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update \"sqlalchemy.orm.Query.update\") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete \"sqlalchemy.orm.Query.delete\") methods as well as via the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") constructs for [2.0 style](../glossary.html#term-2.0-style) execution, will now automatically accommodate for the additional WHERE criteria needed for a single-table inheritance discriminator in order to limit the statement to rows referring to the specific subtype requested. The new [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") construct is also supported for with bulk update/delete operations.\n\n    References: [#3903](https://www.sqlalchemy.org/trac/ticket/3903), [#5018](https://www.sqlalchemy.org/trac/ticket/5018)\n\n*   **[orm] [usecase]**\n\n    Update [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref \"sqlalchemy.orm.relationship\") flag in a relationship to make it implicitly `False` in `viewonly=True` relationships, preventing synchronization events.\n\n    See also\n\n    [Viewonly relationships don\u2019t synchronize backrefs](migration_14.html#change-5237-14)\n\n    References: [#5237](https://www.sqlalchemy.org/trac/ticket/5237)\n\n*   **[orm] [change]**\n\n    The condition where a pending object being flushed with an identity that already exists in the identity map has been adjusted to emit a warning, rather than throw a [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError \"sqlalchemy.orm.exc.FlushError\"). The rationale is so that the flush will proceed and raise a [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError \"sqlalchemy.exc.IntegrityError\") instead, in the same way as if the existing object were not present in the identity map already. This helps with schemes that are using the [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError \"sqlalchemy.exc.IntegrityError\") as a means of catching whether or not a row already exists in the table.\n\n    See also\n\n    [The \u201cNew instance conflicts with existing identity\u201d error is now a warning](migration_14.html#change-4662)\n\n    References: [#4662](https://www.sqlalchemy.org/trac/ticket/4662)\n\n*   **[orm] [change] [sql]**\n\n    A selection of Core and ORM query objects now perform much more of their Python computational tasks within the compile step, rather than at construction time. This is to support an upcoming caching model that will provide for caching of the compiled statement structure based on a cache key that is derived from the statement construct, which itself is expected to be newly constructed in Python code each time it is used. This means that the internal state of these objects may not be the same as it used to be, as well as that some but not all error raise scenarios for various kinds of argument validation will occur within the compilation / execution phase, rather than at statement construction time. See the migration notes linked below for complete details.\n\n    See also\n\n    [Many Core and ORM statement objects now perform much of their construction and validation in the compile phase](migration_14.html#change-deferred-construction)\n\n*   **[orm] [change]**\n\n    The automatic uniquing of rows on the client side is turned off for the new [2.0 style](../glossary.html#term-2.0-style) of ORM querying. This improves both clarity and performance. However, uniquing of rows on the client side is generally necessary when using joined eager loading for collections, as there will be duplicates of the primary entity for each element in the collection because a join was used. This uniquing must now be manually enabled and can be achieved using the new [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique \"sqlalchemy.engine.Result.unique\") modifier. To avoid silent failure, the ORM explicitly requires the method be called when the result of an ORM query in 2.0 style makes use of joined load collections. The newer [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") strategy is likely preferable for eager loading of collections in any case.\n\n    See also\n\n    [ORM Rows not uniquified by default](migration_20.html#joinedload-not-uniqued)\n\n    References: [#4395](https://www.sqlalchemy.org/trac/ticket/4395)\n\n*   **[orm] [change]**\n\n    The ORM will now warn when asked to coerce a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct into a subquery implicitly. This occurs within places such as the `Query.select_entity_from()` and [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from \"sqlalchemy.orm.Query.select_from\") methods as well as within the [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") function. When a [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase \"sqlalchemy.sql.expression.SelectBase\") (which is what\u2019s produced by [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\")) or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object is passed directly to these functions and others, the ORM is typically coercing them to be a subquery by calling the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias \"sqlalchemy.sql.expression.SelectBase.alias\") method automatically (which is now superseded by the [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery \"sqlalchemy.sql.expression.SelectBase.subquery\") method). See the migration notes linked below for further details.\n\n    See also\n\n    [A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[orm] [change]**\n\n    The \u201cKeyedTuple\u201d class returned by [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") is now replaced with the Core [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") class, which behaves in the same way as KeyedTuple. In SQLAlchemy 2.0, both Core and ORM will return result rows using the same [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object. In the interim, Core uses a backwards-compatibility class `LegacyRow` that maintains the former mapping/tuple hybrid behavior used by \u201cRowProxy\u201d.\n\n    See also\n\n    [The \u201cKeyedTuple\u201d object returned by Query is replaced by Row](migration_14.html#change-4710-orm)\n\n    References: [#4710](https://www.sqlalchemy.org/trac/ticket/4710)\n\n*   **[orm] [performance]**\n\n    The bulk update and delete methods [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update \"sqlalchemy.orm.Query.update\") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete \"sqlalchemy.orm.Query.delete\"), as well as their 2.0-style counterparts, now make use of RETURNING when the \u201cfetch\u201d strategy is used in order to fetch the list of affected primary key identites, rather than emitting a separate SELECT, when the backend in use supports RETURNING. Additionally, the \u201cfetch\u201d strategy will in ordinary cases not expire the attributes that have been updated, and will instead apply the updated values directly in the same way that the \u201cevaluate\u201d strategy does, to avoid having to refresh the object. The \u201cevaluate\u201d strategy will also fall back to expiring attributes that were updated to a SQL expression that was unevaluable in Python.\n\n    See also\n\n    [ORM Bulk Update and Delete use RETURNING for \u201cfetch\u201d strategy when available](migration_14.html#change-orm-update-returning-14)\n\n*   **[orm] [performance] [postgresql]**\n\n    Implemented support for the psycopg2 `execute_values()` extension within the ORM flush process via the enhancements to Core made in [#5401](https://www.sqlalchemy.org/trac/ticket/5401), so that this extension is used both as a strategy to batch INSERT statements together as well as that RETURNING may now be used among multiple parameter sets to retrieve primary key values back in batch. This allows nearly all INSERT statements emitted by the ORM on behalf of PostgreSQL to be submitted in batch and also via the `execute_values()` extension which benches at five times faster than plain executemany() for this particular backend.\n\n    See also\n\n    [ORM Batch inserts with psycopg2 now batch statements with RETURNING in most cases](migration_14.html#change-5263)\n\n    References: [#5263](https://www.sqlalchemy.org/trac/ticket/5263)\n\n*   **[orm] [bug]**\n\n    A query that is against a mapped inheritance subclass which also uses `Query.select_entity_from()` or a similar technique in order to provide an existing subquery to SELECT from, will now raise an error if the given subquery returns entities that do not correspond to the given subclass, that is, they are sibling or superclasses in the same hierarchy. Previously, these would be returned without error. Additionally, if the inheritance mapping is a single-inheritance mapping, the given subquery must apply the appropriate filtering against the polymorphic discriminator column in order to avoid this error; previously, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") would add this criteria to the outside query however this interferes with some kinds of query that return other kinds of entities as well.\n\n    See also\n\n    [Stricter behavior when querying inheritance mappings using custom queries](migration_14.html#change-5122)\n\n    References: [#5122](https://www.sqlalchemy.org/trac/ticket/5122)\n\n*   **[orm] [bug]**\n\n    The internal attribute symbols NO_VALUE and NEVER_SET have been unified, as there was no meaningful difference between these two symbols, other than a few codepaths where they were differentiated in subtle and undocumented ways, these have been fixed.\n\n    References: [#4696](https://www.sqlalchemy.org/trac/ticket/4696)\n\n*   **[orm] [bug]**\n\n    Fixed bug where a versioning column specified on a mapper against a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct where the version_id_col itself were against the underlying table would incur additional loads when accessed, even if the value were locally persisted by the flush. The actual fix is a result of the changes in [#4617](https://www.sqlalchemy.org/trac/ticket/4617), by fact that a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") object no longer has a `.c` attribute and therefore does not confuse the mapper into thinking there\u2019s an unknown column value present.\n\n    References: [#4194](https://www.sqlalchemy.org/trac/ticket/4194)\n\n*   **[orm] [bug]**\n\n    An `UnmappedInstanceError` is now raised for [`InstrumentedAttribute`](../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute \"sqlalchemy.orm.InstrumentedAttribute\") if an instance is an unmapped object. Prior to this an `AttributeError` was raised. Pull request courtesy Ramon Williams.\n\n    References: [#3858](https://www.sqlalchemy.org/trac/ticket/3858)\n\n*   **[orm] [bug]**\n\n    The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") object no longer initiates a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction \"sqlalchemy.orm.SessionTransaction\") object immediately upon construction or after the previous transaction is closed; instead, \u201cautobegin\u201d logic now initiates the new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction \"sqlalchemy.orm.SessionTransaction\") on demand when it is next needed. Rationale includes to remove reference cycles from a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that has been closed out, as well as to remove the overhead incurred by the creation of [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction \"sqlalchemy.orm.SessionTransaction\") objects that are often discarded immediately. This change affects the behavior of the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create \"sqlalchemy.orm.SessionEvents.after_transaction_create\") hook in that the event will be emitted when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") first requires a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction \"sqlalchemy.orm.SessionTransaction\") be present, rather than whenever the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") were created or the previous [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction \"sqlalchemy.orm.SessionTransaction\") were closed. Interactions with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") and the database itself remain unaffected.\n\n    See also\n\n    [Session features new \u201cautobegin\u201d behavior](migration_14.html#change-5074)\n\n    References: [#5074](https://www.sqlalchemy.org/trac/ticket/5074)\n\n*   **[orm] [bug]**\n\n    Added new entity-targeting capabilities to the ORM query context help with the case where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") is using a bind dictionary against mapped classes, rather than a single bind, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") is against a Core statement that was ultimately generated from a method such as [`Query.subquery()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.subquery \"sqlalchemy.orm.Query.subquery\"). First implemented using a deep search, the current approach leverages the unified [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct to keep track of the first mapper that is part of the construct.\n\n    References: [#4829](https://www.sqlalchemy.org/trac/ticket/4829)\n\n*   **[orm] [bug] [inheritance]**\n\n    An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError \"sqlalchemy.exc.ArgumentError\") is now raised if both the `selectable` and `flat` parameters are set to True in [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\"). The selectable name is already aliased and applying flat=True overrides the selectable name with an anonymous name that would\u2019ve previously caused the code to break. Pull request courtesy Ramon Williams.\n\n    References: [#4212](https://www.sqlalchemy.org/trac/ticket/4212)\n\n*   **[orm] [bug]**\n\n    Fixed issue in polymorphic loading internals which would fall back to a more expensive, soon-to-be-deprecated form of result column lookup within certain unexpiration scenarios in conjunction with the use of \u201cwith_polymorphic\u201d.\n\n    References: [#4718](https://www.sqlalchemy.org/trac/ticket/4718)\n\n*   **[orm] [bug]**\n\n    An error is raised if any persistence-related \u201ccascade\u201d settings are made on a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") that also sets up viewonly=True. The \u201ccascade\u201d settings now default to non-persistence related settings only when viewonly is also set. This is the continuation from [#4993](https://www.sqlalchemy.org/trac/ticket/4993) where this setting was changed to emit a warning in 1.3.\n\n    See also\n\n    [Persistence-related cascade operations disallowed with viewonly=True](migration_14.html#change-4994)\n\n    References: [#4994](https://www.sqlalchemy.org/trac/ticket/4994)\n\n*   **[orm] [bug]**\n\n    Improved declarative inheritance scanning to not get tripped up when the same base class appears multiple times in the base inheritance list.\n\n    References: [#4699](https://www.sqlalchemy.org/trac/ticket/4699)\n\n*   **[orm] [bug]**\n\n    Fixed bug in ORM versioning feature where assignment of an explicit version_id for a counter configured against a mapped selectable where version_id_col is against the underlying table would fail if the previous value were expired; this was due to the fact that the mapped attribute would not be configured with active_history=True.\n\n    References: [#4195](https://www.sqlalchemy.org/trac/ticket/4195)\n\n*   **[orm] [bug]**\n\n    An exception is now raised if the ORM loads a row for a polymorphic instance that has a primary key but the discriminator column is NULL, as discriminator columns should not be null.\n\n    References: [#4836](https://www.sqlalchemy.org/trac/ticket/4836)\n\n*   **[orm] [bug]**\n\n    Accessing a collection-oriented attribute on a newly created object no longer mutates `__dict__`, but still returns an empty collection as has always been the case. This allows collection-oriented attributes to work consistently in comparison to scalar attributes which return `None`, but also don\u2019t mutate `__dict__`. In order to accommodate for the collection being mutated, the same empty collection is returned each time once initially created, and when it is mutated (e.g. an item appended, added, etc.) it is then moved into `__dict__`. This removes the last of mutating side-effects on read-only attribute access within the ORM.\n\n    See also\n\n    [Accessing an uninitialized collection attribute on a transient object no longer mutates __dict__](migration_14.html#change-4519)\n\n    References: [#4519](https://www.sqlalchemy.org/trac/ticket/4519)\n\n*   **[orm] [bug]**\n\n    The refresh of an expired object will now trigger an autoflush if the list of expired attributes include one or more attributes that were explicitly expired or refreshed using the [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire \"sqlalchemy.orm.Session.expire\") or [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh \"sqlalchemy.orm.Session.refresh\") methods. This is an attempt to find a middle ground between the normal unexpiry of attributes that can happen in many cases where autoflush is not desirable, vs. the case where attributes are being explicitly expired or refreshed and it is possible that these attributes depend upon other pending state within the session that needs to be flushed. The two methods now also gain a new flag [`Session.expire.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.expire.params.autoflush \"sqlalchemy.orm.Session.expire\") and [`Session.refresh.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.autoflush \"sqlalchemy.orm.Session.refresh\"), defaulting to True; when set to False, this will disable the autoflush that occurs on unexpire for these attributes.\n\n    References: [#5226](https://www.sqlalchemy.org/trac/ticket/5226)\n\n*   **[orm] [bug]**\n\n    The behavior of the [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs \"sqlalchemy.orm.relationship\") flag will be reversed in 2.0 and set to `False` unconditionally, such that backrefs don\u2019t cascade save-update operations from a forwards-assignment to a backwards assignment. A 2.0 deprecation warning is emitted when the parameter is left at its default of `True` at the point at which such a cascade operation actually takes place. The new behavior can be established as always by setting the flag to `False` on a specific [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\"), or more generally can be set up across the board by setting the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future \"sqlalchemy.orm.Session\") flag to True.\n\n    See also\n\n    [cascade_backrefs behavior deprecated for removal in 2.0](migration_14.html#change-5150)\n\n    References: [#5150](https://www.sqlalchemy.org/trac/ticket/5150)\n\n*   **[orm] [deprecated]**\n\n    The \u201cslice index\u201d feature used by [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") as well as by the dynamic relationship loader will no longer accept negative indexes in SQLAlchemy 2.0\\. These operations do not work efficiently and load the entire collection in, which is both surprising and undesirable. These will warn in 1.4 unless the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future \"sqlalchemy.orm.Session\") flag is set in which case they will raise IndexError.\n\n    References: [#5606](https://www.sqlalchemy.org/trac/ticket/5606)\n\n*   **[orm] [deprecated]**\n\n    Calling the [`Query.instances()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.instances \"sqlalchemy.orm.Query.instances\") method without passing a [`QueryContext`](../orm/internals.html#sqlalchemy.orm.QueryContext \"sqlalchemy.orm.QueryContext\") is deprecated. The original use case for this was that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") could yield ORM objects when given only the entities to be selected as well as a DBAPI cursor object. However, for this to work correctly there is essential metadata that is passed from a SQLAlchemy `ResultProxy` that is derived from the mapped column expressions, which comes originally from the [`QueryContext`](../orm/internals.html#sqlalchemy.orm.QueryContext \"sqlalchemy.orm.QueryContext\"). To retrieve ORM results from arbitrary SELECT statements, the [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement \"sqlalchemy.orm.Query.from_statement\") method should be used.\n\n    References: [#4719](https://www.sqlalchemy.org/trac/ticket/4719)\n\n*   **[orm] [deprecated]**\n\n    Using strings to represent relationship names in ORM operations such as [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\"), as well as strings for all ORM attribute names in loader options like [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") is deprecated and will be removed in SQLAlchemy 2.0\\. The class-bound attribute should be passed instead. This provides much better specificity to the given method, allows for modifiers such as `of_type()`, and reduces internal complexity.\n\n    Additionally, the `aliased` and `from_joinpoint` parameters to [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join \"sqlalchemy.orm.Query.join\") are also deprecated. The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct now provides for a great deal of flexibility and capability and should be used directly.\n\n    See also\n\n    [ORM Query - Joining / loading on relationships uses attributes, not strings](migration_20.html#migration-20-orm-query-join-strings)\n\n    [ORM Query - join(\u2026, aliased=True), from_joinpoint removed](migration_20.html#migration-20-query-join-options)\n\n    References: [#4705](https://www.sqlalchemy.org/trac/ticket/4705), [#5202](https://www.sqlalchemy.org/trac/ticket/5202)\n\n*   **[orm] [deprecated]**\n\n    Deprecated logic in [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct \"sqlalchemy.orm.Query.distinct\") that automatically adds columns in the ORDER BY clause to the columns clause; this will be removed in 2.0.\n\n    See also\n\n    [Using DISTINCT with additional columns, but only select the entity](migration_20.html#migration-20-query-distinct)\n\n    References: [#5134](https://www.sqlalchemy.org/trac/ticket/5134)\n\n*   **[orm] [deprecated]**\n\n    Passing keyword arguments to methods such as [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") to be passed into the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind \"sqlalchemy.orm.Session.get_bind\") method is deprecated; the new [`Session.execute.bind_arguments`](../orm/session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments \"sqlalchemy.orm.Session.execute\") dictionary should be passed instead.\n\n    References: [#5573](https://www.sqlalchemy.org/trac/ticket/5573)\n\n*   **[orm] [deprecated]**\n\n    The `eagerload()` and `relation()` were old aliases and are now deprecated. Use [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") respectively.\n\n    References: [#5192](https://www.sqlalchemy.org/trac/ticket/5192)\n\n*   **[orm] [removed]**\n\n    All long-deprecated \u201cextension\u201d classes have been removed, including MapperExtension, SessionExtension, PoolListener, ConnectionProxy, AttributeExtension. These classes have been deprecated since version 0.7 long superseded by the event listener system.\n\n    References: [#4638](https://www.sqlalchemy.org/trac/ticket/4638)\n\n*   **[orm] [removed]**\n\n    Remove the deprecated loader options `joinedload_all`, `subqueryload_all`, `lazyload_all`, `selectinload_all`. The normal version with method chaining should be used in their place.\n\n    References: [#4642](https://www.sqlalchemy.org/trac/ticket/4642)\n\n*   **[orm] [removed]**\n\n    Remove deprecated function `comparable_property`. Please refer to the [`hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid \"sqlalchemy.ext.hybrid\") extension. This also removes the function `comparable_using` in the declarative extension.\n\n    Remove deprecated function `compile_mappers`. Please use [`configure_mappers()`](../orm/mapping_api.html#sqlalchemy.orm.configure_mappers \"sqlalchemy.orm.configure_mappers\")\n\n    Remove deprecated method `collection.linker`. Please refer to the [`AttributeEvents.init_collection()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_collection \"sqlalchemy.orm.AttributeEvents.init_collection\") and [`AttributeEvents.dispose_collection()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.dispose_collection \"sqlalchemy.orm.AttributeEvents.dispose_collection\") event handlers.\n\n    Remove deprecated method `Session.prune` and parameter `Session.weak_identity_map`. See the recipe at [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior) for an event-based approach to maintaining strong identity references. This change also removes the class `StrongInstanceDict`.\n\n    Remove deprecated parameter `mapper.order_by`. Use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by \"sqlalchemy.orm.Query.order_by\") to determine the ordering of a result set.\n\n    Remove deprecated parameter `Session._enable_transaction_accounting`.\n\n    Remove deprecated parameter `Session.is_modified.passive`.\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n### engine\n\n*   **[engine] [feature]**\n\n    Implemented an all-new [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object that replaces the previous `ResultProxy` object. As implemented in Core, the subclass [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult \"sqlalchemy.engine.CursorResult\") features a compatible calling interface with the previous `ResultProxy`, and additionally adds a great amount of new functionality that can be applied to Core result sets as well as ORM result sets, which are now integrated into the same model. [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") includes features such as column selection and rearrangement, improved fetchmany patterns, uniquing, as well as a variety of implementations that can be used to create database results from in-memory structures as well.\n\n    See also\n\n    [New Result object](migration_14.html#change-result-14-core)\n\n    References: [#4395](https://www.sqlalchemy.org/trac/ticket/4395), [#4959](https://www.sqlalchemy.org/trac/ticket/4959), [#5087](https://www.sqlalchemy.org/trac/ticket/5087)\n\n*   **[engine] [feature] [orm]**\n\n    SQLAlchemy now includes support for Python asyncio within both Core and ORM, using the included [asyncio extension](../orm/extensions/asyncio.html). The extension makes use of the [greenlet](https://greenlet.readthedocs.io/en/latest/) library in order to adapt SQLAlchemy\u2019s sync-oriented internals such that an asyncio interface that ultimately interacts with an asyncio database adapter is now feasible. The single driver supported at the moment is the [asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg) driver for PostgreSQL.\n\n    See also\n\n    [Asynchronous IO Support for Core and ORM](migration_14.html#change-3414)\n\n    References: [#3414](https://www.sqlalchemy.org/trac/ticket/3414)\n\n*   **[engine] [feature] [alchemy2]**\n\n    Implemented the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future \"sqlalchemy.create_engine\") parameter which enables forwards compatibility with SQLAlchemy 2\\. is used for forwards compatibility with SQLAlchemy 2\\. This engine features always-transactional behavior with autobegin.\n\n    See also\n\n    [SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)\n\n    References: [#4644](https://www.sqlalchemy.org/trac/ticket/4644)\n\n*   **[engine] [feature] [pyodbc]**\n\n    Reworked the \u201csetinputsizes()\u201d set of dialect hooks to be correctly extensible for any arbitrary DBAPI, by allowing dialects individual hooks that may invoke cursor.setinputsizes() in the appropriate style for that DBAPI. In particular this is intended to support pyodbc\u2019s style of usage which is fundamentally different from that of cx_Oracle. Added support for pyodbc.\n\n    References: [#5649](https://www.sqlalchemy.org/trac/ticket/5649)\n\n*   **[engine] [feature]**\n\n    Added new reflection method [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names \"sqlalchemy.engine.reflection.Inspector.get_sequence_names\") which returns all the sequences defined and [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence \"sqlalchemy.engine.reflection.Inspector.has_sequence\") to check if a particular sequence exits. Support for this method has been added to the backend that support [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\"): PostgreSQL, Oracle and MariaDB >= 10.3.\n\n    References: [#2056](https://www.sqlalchemy.org/trac/ticket/2056)\n\n*   **[engine] [feature]**\n\n    The [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with \"sqlalchemy.schema.Table\") parameter now accepts an [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector \"sqlalchemy.engine.reflection.Inspector\") object directly, as well as any [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") as was the case before.\n\n    References: [#4755](https://www.sqlalchemy.org/trac/ticket/4755)\n\n*   **[engine] [change]**\n\n    The `RowProxy` class is no longer a \u201cproxy\u201d object, and is instead directly populated with the post-processed contents of the DBAPI row tuple upon construction. Now named [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\"), the mechanics of how the Python-level value processors have been simplified, particularly as it impacts the format of the C code, so that a DBAPI row is processed into a result tuple up front. The object returned by the `ResultProxy` is now the `LegacyRow` subclass, which maintains mapping/tuple hybrid behavior, however the base [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") class now behaves more fully like a named tuple.\n\n    See also\n\n    [RowProxy is no longer a \u201cproxy\u201d; is now called Row and behaves like an enhanced named tuple](migration_14.html#change-4710-core)\n\n    References: [#4710](https://www.sqlalchemy.org/trac/ticket/4710)\n\n*   **[engine] [performance]**\n\n    The pool \u201cpre-ping\u201d feature has been refined to not invoke for a DBAPI connection that was just opened in the same checkout operation. pre ping only applies to a DBAPI connection that\u2019s been checked into the pool and is being checked out again.\n\n    References: [#4524](https://www.sqlalchemy.org/trac/ticket/4524)\n\n*   **[engine] [performance] [change] [py3k]**\n\n    Disabled the \u201cunicode returns\u201d check that runs on dialect startup when running under Python 3, which for many years has occurred in order to test the current DBAPI\u2019s behavior for whether or not it returns Python Unicode or Py2K strings for the VARCHAR and NVARCHAR datatypes. The check still occurs by default under Python 2, however the mechanism to test the behavior will be removed in SQLAlchemy 2.0 when Python 2 support is also removed.\n\n    This logic was very effective when it was needed, however now that Python 3 is standard, all DBAPIs are expected to return Python 3 strings for character datatypes. In the unlikely case that a third party DBAPI does not support this, the conversion logic within [`String`](../core/type_basics.html#sqlalchemy.types.String \"sqlalchemy.types.String\") is still available and the third party dialect may specify this in its upfront dialect flags by setting the dialect level flag `returns_unicode_strings` to one of `String.RETURNS_CONDITIONAL` or `String.RETURNS_BYTES`, both of which will enable Unicode conversion even under Python 3.\n\n    References: [#5315](https://www.sqlalchemy.org/trac/ticket/5315)\n\n*   **[engine] [bug]**\n\n    Revised the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map \"sqlalchemy.engine.Connection.execution_options\") feature such that the processing of the SQL statement to receive a specific schema name occurs within the execution phase of the statement, rather than at the compile phase. This is to support the statement being efficiently cached. Previously, the current schema being rendered into the statement for a particular run would be considered as part of the cache key itself, meaning that for a run against hundreds of schemas, there would be hundreds of cache keys, rendering the cache much less performant. The new behavior is that the rendering is done in a similar manner as the \u201cpost compile\u201d rendering added in 1.4 as part of [#4645](https://www.sqlalchemy.org/trac/ticket/4645), [#4808](https://www.sqlalchemy.org/trac/ticket/4808).\n\n    References: [#5004](https://www.sqlalchemy.org/trac/ticket/5004)\n\n*   **[engine] [bug]**\n\n    The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") object will now not clear a rolled-back transaction until the outermost transaction is explicitly rolled back. This is essentially the same behavior that the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") has had for a long time, where an explicit call to `.rollback()` on all enclosing transactions is required for the transaction to logically clear, even though the DBAPI-level transaction has already been rolled back. The new behavior helps with situations such as the \u201cORM rollback test suite\u201d pattern where the test suite rolls the transaction back within the ORM scope, but the test harness which seeks to control the scope of the transaction externally does not expect a new transaction to start implicitly.\n\n    See also\n\n    [Connection-level transactions can now be inactive based on subtransaction](migration_14.html#change-4712)\n\n    References: [#4712](https://www.sqlalchemy.org/trac/ticket/4712)\n\n*   **[engine] [bug]**\n\n    Adjusted the dialect initialization process such that the [`Dialect.on_connect()`](../core/internals.html#sqlalchemy.engine.Dialect.on_connect \"sqlalchemy.engine.Dialect.on_connect\") is not called a second time on the first connection. The hook is called first, then the [`Dialect.initialize()`](../core/internals.html#sqlalchemy.engine.Dialect.initialize \"sqlalchemy.engine.Dialect.initialize\") is called if that connection is the first for that dialect, then no more events are called. This eliminates the two calls to the \u201con_connect\u201d function which can produce very difficult debugging situations.\n\n    References: [#5497](https://www.sqlalchemy.org/trac/ticket/5497)\n\n*   **[engine] [deprecated]**\n\n    The [`URL`](../core/engines.html#sqlalchemy.engine.URL \"sqlalchemy.engine.URL\") object is now an immutable named tuple. To modify a URL object, use the [`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set \"sqlalchemy.engine.URL.set\") method to produce a new URL object.\n\n    See also\n\n    [The URL object is now immutable](migration_14.html#change-5526) - notes on migration\n\n    References: [#5526](https://www.sqlalchemy.org/trac/ticket/5526)\n\n*   **[engine] [deprecated]**\n\n    The [`MetaData.bind`](../core/metadata.html#sqlalchemy.schema.MetaData.params.bind \"sqlalchemy.schema.MetaData\") argument as well as the overall concept of \u201cbound metadata\u201d is deprecated in SQLAlchemy 1.4 and will be removed in SQLAlchemy 2.0\\. The parameter as well as related functions now emit a `RemovedIn20Warning` when [SQLAlchemy 2.0 Deprecations Mode](migration_14.html#deprecation-20-mode) is in use.\n\n    See also\n\n    [\u201cImplicit\u201d and \u201cConnectionless\u201d execution, \u201cbound metadata\u201d removed](migration_20.html#migration-20-implicit-execution)\n\n    References: [#4634](https://www.sqlalchemy.org/trac/ticket/4634)\n\n*   **[engine] [deprecated]**\n\n    The `server_side_cursors` engine-wide parameter is deprecated and will be removed in a future release. For unbuffered cursors, the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") execution option should be used on a per-execution basis.\n\n*   **[engine] [deprecated]**\n\n    The `Connection.connect()` method is deprecated as is the concept of \u201cconnection branching\u201d, which copies a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") into a new one that has a no-op \u201c.close()\u201d method. This pattern is oriented around the \u201cconnectionless execution\u201d concept which is also being removed in 2.0.\n\n    References: [#5131](https://www.sqlalchemy.org/trac/ticket/5131)\n\n*   **[engine] [deprecated]**\n\n    The `case_sensitive` flag on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine \"sqlalchemy.create_engine\") is deprecated; this flag was part of the transition of the result row object to allow case sensitive column matching as the default, while providing backwards compatibility for the former matching method. All string access for a row should be assumed to be case sensitive just like any other Python mapping.\n\n    References: [#4878](https://www.sqlalchemy.org/trac/ticket/4878)\n\n*   **[engine] [deprecated]**\n\n    \u201dImplicit autocommit\u201d, which is the COMMIT that occurs when a DML or DDL statement is emitted on a connection, is deprecated and won\u2019t be part of SQLAlchemy 2.0\\. A 2.0-style warning is emitted when autocommit takes effect, so that the calling code may be adjusted to use an explicit transaction.\n\n    As part of this change, DDL methods such as [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all \"sqlalchemy.schema.MetaData.create_all\") when used against an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") will run the operation in a BEGIN block if one is not started already.\n\n    See also\n\n    [SQLAlchemy 2.0 Deprecations Mode](migration_14.html#deprecation-20-mode)\n\n    References: [#4846](https://www.sqlalchemy.org/trac/ticket/4846)\n\n*   **[engine] [deprecated]**\n\n    Deprecated the behavior by which a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") can be used as the key in a result set row lookup, when that [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") is not part of the SQL selectable that is being selected; that is, it is only matched on name. A deprecation warning is now emitted for this case. Various ORM use cases, such as those involving [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") constructs, have been improved so that this fallback logic is avoided in most cases.\n\n    References: [#4877](https://www.sqlalchemy.org/trac/ticket/4877)\n\n*   **[engine] [deprecated]**\n\n    Deprecated remaining engine-level introspection and utility methods including `Engine.run_callable()`, `Engine.transaction()`, `Engine.table_names()`, `Engine.has_table()`. The utility methods are superseded by modern context-manager patterns, and the table introspection tasks are suited by the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector \"sqlalchemy.engine.reflection.Inspector\") object.\n\n    References: [#4755](https://www.sqlalchemy.org/trac/ticket/4755)\n\n*   **[engine] [removed]**\n\n    Remove deprecated method `get_primary_keys` in the [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect \"sqlalchemy.engine.Dialect\") and [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector \"sqlalchemy.engine.reflection.Inspector\") classes. Please refer to the [`Dialect.get_pk_constraint()`](../core/internals.html#sqlalchemy.engine.Dialect.get_pk_constraint \"sqlalchemy.engine.Dialect.get_pk_constraint\") and `Inspector.get_primary_keys()` methods.\n\n    Remove deprecated event `dbapi_error` and the method `ConnectionEvents.dbapi_error`. Please refer to the `ConnectionEvents.handle_error()` event. This change also removes the attributes `ExecutionContext.is_disconnect` and `ExecutionContext.exception`.\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n*   **[engine] [removed]**\n\n    The internal dialect method `Dialect.reflecttable` has been removed. A review of third party dialects has not found any making use of this method, as it was already documented as one that should not be used by external dialects. Additionally, the private `Engine._run_visitor` method is also removed.\n\n    References: [#4755](https://www.sqlalchemy.org/trac/ticket/4755)\n\n*   **[engine] [removed]**\n\n    The long-deprecated `Inspector.get_table_names.order_by` parameter has been removed.\n\n    References: [#4755](https://www.sqlalchemy.org/trac/ticket/4755)\n\n*   **[engine] [renamed]**\n\n    The `Inspector.reflecttable()` was renamed to [`Inspector.reflect_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.reflect_table \"sqlalchemy.engine.reflection.Inspector.reflect_table\").\n\n    References: [#5244](https://www.sqlalchemy.org/trac/ticket/5244)\n\n### sql\n\n*   **[sql] [feature]**\n\n    Added \u201cfrom linting\u201d as a built-in feature to the SQL compiler. This allows the compiler to maintain graph of all the FROM clauses in a particular SELECT statement, linked by criteria in either the WHERE or in JOIN clauses that link these FROM clauses together. If any two FROM clauses have no path between them, a warning is emitted that the query may be producing a cartesian product. As the Core expression language as well as the ORM are built on an \u201cimplicit FROMs\u201d model where a particular FROM clause is automatically added if any part of the query refers to it, it is easy for this to happen inadvertently and it is hoped that the new feature helps with this issue.\n\n    See also\n\n    [Built-in FROM linting will warn for any potential cartesian products in a SELECT statement](migration_14.html#change-4737)\n\n    References: [#4737](https://www.sqlalchemy.org/trac/ticket/4737)\n\n*   **[sql] [feature] [mssql] [oracle]**\n\n    Added new \u201cpost compile parameters\u201d feature. This feature allows a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") construct to have its value rendered into the SQL string before being passed to the DBAPI driver, but after the compilation step, using the \u201cliteral render\u201d feature of the compiler. The immediate rationale for this feature is to support LIMIT/OFFSET schemes that don\u2019t work or perform well as bound parameters handled by the database driver, while still allowing for SQLAlchemy SQL constructs to be cacheable in their compiled form. The immediate targets for the new feature are the \u201cTOP N\u201d clause used by SQL Server (and Sybase) which does not support a bound parameter, as well as the \u201cROWNUM\u201d and optional \u201cFIRST_ROWS()\u201d schemes used by the Oracle dialect, the former of which has been known to perform better without bound parameters and the latter of which does not support a bound parameter. The feature builds upon the mechanisms first developed to support \u201cexpanding\u201d parameters for IN expressions. As part of this feature, the Oracle `use_binds_for_limits` feature is turned on unconditionally and this flag is now deprecated.\n\n    See also\n\n    [New \u201cpost compile\u201d bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](migration_14.html#change-4808)\n\n    References: [#4808](https://www.sqlalchemy.org/trac/ticket/4808)\n\n*   **[sql] [feature]**\n\n    Add support for regular expression on supported backends. Two operations have been defined:\n\n    *   [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") implementing a regular expression match like function.\n\n    *   [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") implementing a regular expression string replace function.\n\n    Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.\n\n    See also\n\n    [Support for SQL Regular Expression operators](migration_14.html#change-1390)\n\n    References: [#1390](https://www.sqlalchemy.org/trac/ticket/1390)\n\n*   **[sql] [feature]**\n\n    The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct and related constructs now allow for duplication of column labels and columns themselves in the columns clause, mirroring exactly how column expressions were passed in. This allows the tuples returned by an executed result to match what was SELECTed for in the first place, which is how the ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") works, so this establishes better cross-compatibility between the two constructs. Additionally, it allows column-positioning-sensitive structures such as UNIONs (i.e. `_selectable.CompoundSelect`) to be more intuitively constructed in those cases where a particular column might appear in more than one place. To support this change, the [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection \"sqlalchemy.sql.expression.ColumnCollection\") has been revised to support duplicate columns as well as to allow integer index access.\n\n    See also\n\n    [SELECT objects and derived FROM clauses allow for duplicate columns and column labels](migration_14.html#change-4753)\n\n    References: [#4753](https://www.sqlalchemy.org/trac/ticket/4753)\n\n*   **[sql] [feature]**\n\n    Enhanced the disambiguating labels feature of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct such that when a select statement is used in a subquery, repeated column names from different tables are now automatically labeled with a unique label name, without the need to use the full \u201capply_labels()\u201d feature that combines tablename plus column name. The disambiguated labels are available as plain string keys in the .c collection of the subquery, and most importantly the feature allows an ORM [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") construct against the combination of an entity and an arbitrary subquery to work correctly, targeting the correct columns despite same-named columns in the source tables, without the need for an \u201capply labels\u201d warning.\n\n    See also\n\n    [Selecting from the query itself as a subquery, e.g. \u201cfrom_self()\u201d](migration_20.html#migration-20-query-from-self) - Illustrates the new disambiguation feature as part of a strategy to migrate away from the `Query.from_self()` method.\n\n    References: [#5221](https://www.sqlalchemy.org/trac/ticket/5221)\n\n*   **[sql] [feature]**\n\n    The \u201cexpanding IN\u201d feature, which generates IN expressions at query execution time which are based on the particular parameters associated with the statement execution, is now used for all IN expressions made against lists of literal values. This allows IN expressions to be fully cacheable independently of the list of values being passed, and also includes support for empty lists. For any scenario where the IN expression contains non-literal SQL expressions, the old behavior of pre-rendering for each position in the IN is maintained. The change also completes support for expanding IN with tuples, where previously type-specific bind processors weren\u2019t taking effect.\n\n    See also\n\n    [All IN expressions render parameters for each value in the list on the fly (e.g. expanding parameters)](migration_14.html#change-4645)\n\n    References: [#4645](https://www.sqlalchemy.org/trac/ticket/4645)\n\n*   **[sql] [feature]**\n\n    Along with the new transparent statement caching feature introduced as part of [#4369](https://www.sqlalchemy.org/trac/ticket/4369), a new feature intended to decrease the Python overhead of creating statements is added, allowing lambdas to be used when indicating arguments being passed to a statement object such as select(), Query(), update(), etc., as well as allowing the construction of full statements within lambdas in a similar manner as that of the \u201cbaked query\u201d system. The rationale of using lambdas is adapted from that of the \u201cbaked query\u201d approach which uses lambdas to encapsulate any amount of Python code into a callable that only needs to be called when the statement is first constructed into a string. The new feature however is more sophisticated in that Python literal values that would be passed as parameters are automatically extracted, so that there is no longer a need to use bindparam() objects with such queries. Use of the feature is optional and can be used to as small or as great a degree as is desired, while still allowing statements to be fully cacheable.\n\n    See also\n\n    [Using Lambdas to add significant speed gains to statement production](../core/connections.html#engine-lambda-caching)\n\n    References: [#5380](https://www.sqlalchemy.org/trac/ticket/5380)\n\n*   **[sql] [usecase]**\n\n    The [`Index.create()`](../core/constraints.html#sqlalchemy.schema.Index.create \"sqlalchemy.schema.Index.create\") and [`Index.drop()`](../core/constraints.html#sqlalchemy.schema.Index.drop \"sqlalchemy.schema.Index.drop\") methods now have a parameter [`Index.create.checkfirst`](../core/constraints.html#sqlalchemy.schema.Index.create.params.checkfirst \"sqlalchemy.schema.Index.create\"), in the same way as that of [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") and [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\"), which when enabled will cause the operation to detect if the index exists (or not) before performing a create or drop operation.\n\n    References: [#527](https://www.sqlalchemy.org/trac/ticket/527)\n\n*   **[sql] [usecase]**\n\n    The [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true \"sqlalchemy.sql.expression.true\") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false \"sqlalchemy.sql.expression.false\") operators may now be applied as the \u201conclause\u201d of a [`join()`](../core/selectable.html#sqlalchemy.sql.expression.join \"sqlalchemy.sql.expression.join\") on a backend that does not support \u201cnative boolean\u201d expressions, e.g. Oracle or SQL Server, and the expression will render as \u201c1=1\u201d for true and \u201c1=0\u201d false. This is the behavior that was introduced many years ago in [#2804](https://www.sqlalchemy.org/trac/ticket/2804) for and/or expressions.\n\n*   **[sql] [usecase]**\n\n    Change the method `__str` of `ColumnCollection` to avoid confusing it with a python list of string.\n\n    References: [#5191](https://www.sqlalchemy.org/trac/ticket/5191)\n\n*   **[sql] [usecase]**\n\n    Add support to `FETCH {FIRST | NEXT} [ count ] {ROW | ROWS} {ONLY | WITH TIES}` in the select for the supported backends, currently PostgreSQL, Oracle and MSSQL.\n\n    References: [#5576](https://www.sqlalchemy.org/trac/ticket/5576)\n\n*   **[sql] [usecase]**\n\n    Additional logic has been added such that certain SQL expressions which typically wrap a single database column will use the name of that column as their \u201canonymous label\u201d name within a SELECT statement, potentially making key-based lookups in result tuples more intuitive. The primary example of this is that of a CAST expression, e.g. `CAST(table.colname AS INTEGER)`, which will export its default name as \u201ccolname\u201d, rather than the usual \u201canon_1\u201d label, that is, `CAST(table.colname AS INTEGER) AS colname`. If the inner expression doesn\u2019t have a name, then the previous \u201canonymous label\u201d logic is used. When using SELECT statements that make use of `Select.apply_labels()`, such as those emitted by the ORM, the labeling logic will produce `<tablename>_<inner column name>` in the same was as if the column were named alone. The logic applies right now to the [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast \"sqlalchemy.sql.expression.cast\") and [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce \"sqlalchemy.sql.expression.type_coerce\") constructs as well as some single-element boolean expressions.\n\n    See also\n\n    [Improved column labeling for simple column expressions using CAST or similar](migration_14.html#change-4449)\n\n    References: [#4449](https://www.sqlalchemy.org/trac/ticket/4449)\n\n*   **[sql] [change]**\n\n    The \u201cclause coercion\u201d system, which is SQLAlchemy Core\u2019s system of receiving arguments and resolving them into [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement \"sqlalchemy.sql.expression.ClauseElement\") structures in order to build up SQL expression objects, has been rewritten from a series of ad-hoc functions to a fully consistent class-based system. This change is internal and should have no impact on end users other than more specific error messages when the wrong kind of argument is passed to an expression object, however the change is part of a larger set of changes involving the role and behavior of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") objects.\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[sql] [change]**\n\n    Added a core `Values` object that enables a VALUES construct to be used in the FROM clause of an SQL statement for databases that support it (mainly PostgreSQL and SQL Server).\n\n    References: [#4868](https://www.sqlalchemy.org/trac/ticket/4868)\n\n*   **[sql] [change]**\n\n    The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct is moving towards a new calling form that is `select(col1, col2, col3, ..)`, with all other keyword arguments removed, as these are all suited using generative methods. The single list of column or table arguments passed to `select()` is still accepted, however is no longer necessary if expressions are passed in a simple positional style. Other keyword arguments are disallowed when this form is used.\n\n    See also\n\n    [select(), case() now accept positional expressions](migration_14.html#change-5284)\n\n    References: [#5284](https://www.sqlalchemy.org/trac/ticket/5284)\n\n*   **[sql] [change]**\n\n    As part of the SQLAlchemy 2.0 migration project, a conceptual change has been made to the role of the [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase \"sqlalchemy.sql.expression.SelectBase\") class hierarchy, which is the root of all \u201cSELECT\u201d statement constructs, in that they no longer serve directly as FROM clauses, that is, they no longer subclass [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause \"sqlalchemy.sql.expression.FromClause\"). For end users, the change mostly means that any placement of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct in the FROM clause of another [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") requires first that it be wrapped in a subquery first, which historically is through the use of the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias \"sqlalchemy.sql.expression.SelectBase.alias\") method, and is now also available through the use of [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery \"sqlalchemy.sql.expression.SelectBase.subquery\"). This was usually a requirement in any case since several databases don\u2019t accept unnamed SELECT subqueries in their FROM clause in any case.\n\n    See also\n\n    [A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[sql] [change]**\n\n    Added a new Core class [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery \"sqlalchemy.sql.expression.Subquery\"), which takes the place of [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias \"sqlalchemy.sql.expression.Alias\") when creating named subqueries against a [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase \"sqlalchemy.sql.expression.SelectBase\") object. [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery \"sqlalchemy.sql.expression.Subquery\") acts in the same way as [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias \"sqlalchemy.sql.expression.Alias\") and is produced from the [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery \"sqlalchemy.sql.expression.SelectBase.subquery\") method; for ease of use and backwards compatibility, the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias \"sqlalchemy.sql.expression.SelectBase.alias\") method is synonymous with this new method.\n\n    See also\n\n    [A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[sql] [performance]**\n\n    An all-encompassing reorganization and refactoring of Core and ORM internals now allows all Core and ORM statements within the areas of DQL (e.g. SELECTs) and DML (e.g. INSERT, UPDATE, DELETE) to allow their SQL compilation as well as the construction of result-fetching metadata to be fully cached in most cases. This effectively provides a transparent and generalized version of what the \u201cBaked Query\u201d extension has offered for the ORM in past versions. The new feature can calculate the cache key for any given SQL construction based on the string that it would ultimately produce for a given dialect, allowing functions that compose the equivalent select(), Query(), insert(), update() or delete() object each time to have that statement cached after it\u2019s generated the first time.\n\n    The feature is enabled transparently but includes some new programming paradigms that may be employed to make the caching even more efficient.\n\n    See also\n\n    [Transparent SQL Compilation Caching added to All DQL, DML Statements in Core, ORM](migration_14.html#change-4639)\n\n    [SQL Compilation Caching](../core/connections.html#sql-caching)\n\n    References: [#4639](https://www.sqlalchemy.org/trac/ticket/4639)\n\n*   **[sql] [bug]**\n\n    Fixed issue where when constructing constraints from ORM-bound columns, primarily [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") objects but also [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint \"sqlalchemy.schema.UniqueConstraint\"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint \"sqlalchemy.schema.CheckConstraint\") and others, the ORM-level [`InstrumentedAttribute`](../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute \"sqlalchemy.orm.InstrumentedAttribute\") is discarded entirely, and all ORM-level annotations from the columns are removed; this is so that the constraints are still fully pickleable without the ORM-level entities being pulled in. These annotations are not necessary to be present at the schema/metadata level.\n\n    References: [#5001](https://www.sqlalchemy.org/trac/ticket/5001)\n\n*   **[sql] [bug]**\n\n    Registered function names based on [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction \"sqlalchemy.sql.functions.GenericFunction\") are now retrieved in a case-insensitive fashion in all cases, removing the deprecation logic from 1.3 which temporarily allowed multiple [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction \"sqlalchemy.sql.functions.GenericFunction\") objects to exist with differing cases. A [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction \"sqlalchemy.sql.functions.GenericFunction\") that replaces another on the same name whether or not it\u2019s case sensitive emits a warning before replacing the object.\n\n    References: [#4569](https://www.sqlalchemy.org/trac/ticket/4569), [#4649](https://www.sqlalchemy.org/trac/ticket/4649)\n\n*   **[sql] [bug]**\n\n    Creating an [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ \"sqlalchemy.sql.expression.and_\") or [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ \"sqlalchemy.sql.expression.or_\") construct with no arguments or empty `*args` will now emit a deprecation warning, as the SQL produced is a no-op (i.e. it renders as a blank string). This behavior is considered to be non-intuitive, so for empty or possibly empty [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ \"sqlalchemy.sql.expression.and_\") or [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ \"sqlalchemy.sql.expression.or_\") constructs, an appropriate default boolean should be included, such as `and_(True, *args)` or `or_(False, *args)`. As has been the case for many major versions of SQLAlchemy, these particular boolean values will not render if the `*args` portion is non-empty.\n\n    References: [#5054](https://www.sqlalchemy.org/trac/ticket/5054)\n\n*   **[sql] [bug]**\n\n    Improved the [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_ \"sqlalchemy.sql.expression.tuple_\") construct such that it behaves predictably when used in a columns-clause context. The SQL tuple is not supported as a \u201cSELECT\u201d columns clause element on most backends; on those that do (PostgreSQL, not surprisingly), the Python DBAPI does not have a \u201cnested type\u201d concept so there are still challenges in fetching rows for such an object. Use of [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_ \"sqlalchemy.sql.expression.tuple_\") in a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") will now raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError \"sqlalchemy.exc.CompileError\") at the point at which the [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_ \"sqlalchemy.sql.expression.tuple_\") object is seen as presenting itself for fetching rows (i.e., if the tuple is in the columns clause of a subquery, no error is raised). For ORM use,the [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle \"sqlalchemy.orm.Bundle\") object is an explicit directive that a series of columns should be returned as a sub-tuple per row and is suggested by the error message. Additionally ,the tuple will now render with parenthesis in all contexts. Previously, the parenthesization would not render in a columns context leading to non-defined behavior.\n\n    References: [#5127](https://www.sqlalchemy.org/trac/ticket/5127)\n\n*   **[sql] [bug] [postgresql]**\n\n    Improved support for column names that contain percent signs in the string, including repaired issues involving anonymous labels that also embedded a column name with a percent sign in it, as well as re-established support for bound parameter names with percent signs embedded on the psycopg2 dialect, using a late-escaping process similar to that used by the cx_Oracle dialect.\n\n    References: [#5653](https://www.sqlalchemy.org/trac/ticket/5653)\n\n*   **[sql] [bug]**\n\n    Custom functions that are created as subclasses of [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement \"sqlalchemy.sql.functions.FunctionElement\") will now generate an \u201canonymous label\u201d based on the \u201cname\u201d of the function just like any other [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function \"sqlalchemy.sql.functions.Function\") object, e.g. `\"SELECT myfunc() AS myfunc_1\"`. While SELECT statements no longer require labels in order for the result proxy object to function, the ORM still targets columns in rows by using objects as mapping keys, which works more reliably when the column expressions have distinct names. In any case, the behavior is now made consistent between functions generated by `func` and those generated as custom [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement \"sqlalchemy.sql.functions.FunctionElement\") objects.\n\n    References: [#4887](https://www.sqlalchemy.org/trac/ticket/4887)\n\n*   **[sql] [bug]**\n\n    Reworked the [`ClauseElement.compare()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compare \"sqlalchemy.sql.expression.ClauseElement.compare\") methods in terms of a new visitor-based approach, and additionally added test coverage ensuring that all [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement \"sqlalchemy.sql.expression.ClauseElement\") subclasses can be accurately compared against each other in terms of structure. Structural comparison capability is used to a small degree within the ORM currently, however it also may form the basis for new caching features.\n\n    References: [#4336](https://www.sqlalchemy.org/trac/ticket/4336)\n\n*   **[sql] [bug]**\n\n    Deprecate usage of `DISTINCT ON` in dialect other than PostgreSQL. Deprecate old usage of string distinct in MySQL dialect\n\n    References: [#4002](https://www.sqlalchemy.org/trac/ticket/4002)\n\n*   **[sql] [bug]**\n\n    The ORDER BY clause of a `_selectable.CompoundSelect`, e.g. UNION, EXCEPT, etc. will not render the table name associated with a given column when applying `CompoundSelect.order_by()` in terms of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") - bound column. Most databases require that the names in the ORDER BY clause be expressed as label names only which are matched to names in the first SELECT statement. The change is related to [#4617](https://www.sqlalchemy.org/trac/ticket/4617) in that a previous workaround was to refer to the `.c` attribute of the `_selectable.CompoundSelect` in order to get at a column that has no table name. As the subquery is now named, this change allows both the workaround to continue to work, as well as allows table-bound columns as well as the `CompoundSelect.selected_columns` collections to be usable in the `CompoundSelect.order_by()` method.\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[sql] [bug]**\n\n    The [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join \"sqlalchemy.sql.expression.Join\") construct no longer considers the \u201conclause\u201d as a source of additional FROM objects to be omitted from the FROM list of an enclosing [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") object as standalone FROM objects. This applies to an ON clause that includes a reference to another FROM object outside the JOIN; while this is usually not correct from a SQL perspective, it\u2019s also incorrect for it to be omitted, and the behavioral change makes the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") / [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join \"sqlalchemy.sql.expression.Join\") behave a bit more intuitively.\n\n    References: [#4621](https://www.sqlalchemy.org/trac/ticket/4621)\n\n*   **[sql] [deprecated]**\n\n    The `Join.alias()` method is deprecated and will be removed in SQLAlchemy 2.0\\. An explicit select + subquery, or aliasing of the inner tables, should be used instead.\n\n    References: [#5010](https://www.sqlalchemy.org/trac/ticket/5010)\n\n*   **[sql] [deprecated]**\n\n    The [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") class now raises a deprecation warning when columns with the same name are defined. To replace a column a new parameter [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing \"sqlalchemy.schema.Table.append_column\") was added to the [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column \"sqlalchemy.schema.Table.append_column\") method.\n\n    The [`ColumnCollection.contains_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection.contains_column \"sqlalchemy.sql.expression.ColumnCollection.contains_column\") will now raises an error when called with a string, suggesting the caller to use `in` instead.\n\n*   **[sql] [removed]**\n\n    The \u201cthreadlocal\u201d execution strategy, deprecated in 1.3, has been removed for 1.4, as well as the concept of \u201cengine strategies\u201d and the `Engine.contextual_connect` method. The \u201cstrategy=\u2019mock\u2019\u201d keyword argument is still accepted for now with a deprecation warning; use [`create_mock_engine()`](../core/engines.html#sqlalchemy.create_mock_engine \"sqlalchemy.create_mock_engine\") instead for this use case.\n\n    See also\n\n    [\u201cthreadlocal\u201d engine strategy deprecated](migration_13.html#change-4393-threadlocal) - from the 1.3 migration notes which discusses the rationale for deprecation.\n\n    References: [#4632](https://www.sqlalchemy.org/trac/ticket/4632)\n\n*   **[sql] [removed]**\n\n    Removed the `sqlalchemy.sql.visitors.iterate_depthfirst` and `sqlalchemy.sql.visitors.traverse_depthfirst` functions. These functions were unused by any part of SQLAlchemy. The [`iterate()`](../core/visitors.html#sqlalchemy.sql.visitors.iterate \"sqlalchemy.sql.visitors.iterate\") and [`traverse()`](../core/visitors.html#sqlalchemy.sql.visitors.traverse \"sqlalchemy.sql.visitors.traverse\") functions are commonly used for these functions. Also removed unused options from the remaining functions including \u201ccolumn_collections\u201d, \u201cschema_visitor\u201d.\n\n*   **[sql] [removed]**\n\n    Removed the concept of a bound engine from the `Compiler` object, and removed the `.execute()` and `.scalar()` methods from `Compiler`. These were essentially forgotten methods from over a decade ago and had no practical use, and it\u2019s not appropriate for the `Compiler` object itself to be maintaining a reference to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\").\n\n*   **[sql] [removed]**\n\n    Remove deprecated methods `Compiled.compile`, `ClauseElement.__and__` and `ClauseElement.__or__` and attribute `Over.func`.\n\n    Remove deprecated `FromClause.count` method. Please use the [`count`](../core/functions.html#sqlalchemy.sql.functions.count \"sqlalchemy.sql.functions.count\") function available from the `func` namespace.\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n*   **[sql] [removed]**\n\n    Remove deprecated parameters `text.bindparams` and `text.typemap`. Please refer to the [`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams \"sqlalchemy.sql.expression.TextClause.bindparams\") and [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns \"sqlalchemy.sql.expression.TextClause.columns\") methods.\n\n    Remove deprecated parameter `Table.useexisting`. Please use [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing \"sqlalchemy.schema.Table\").\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n*   **[sql] [renamed]**\n\n    [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") parameter `mustexist` has been renamed to [`Table.must_exist`](../core/metadata.html#sqlalchemy.schema.Table.params.must_exist \"sqlalchemy.schema.Table\") and will now warn when used.\n\n*   **[sql] [renamed]**\n\n    The [`SelectBase.as_scalar()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.as_scalar \"sqlalchemy.sql.expression.SelectBase.as_scalar\") and [`Query.as_scalar()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.as_scalar \"sqlalchemy.orm.Query.as_scalar\") methods have been renamed to [`SelectBase.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery \"sqlalchemy.sql.expression.SelectBase.scalar_subquery\") and [`Query.scalar_subquery()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.scalar_subquery \"sqlalchemy.orm.Query.scalar_subquery\"), respectively. The old names continue to exist within 1.4 series with a deprecation warning. In addition, the implicit coercion of [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase \"sqlalchemy.sql.expression.SelectBase\"), [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias \"sqlalchemy.sql.expression.Alias\"), and other SELECT oriented objects into scalar subqueries when evaluated in a column context is also deprecated, and emits a warning that the [`SelectBase.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery \"sqlalchemy.sql.expression.SelectBase.scalar_subquery\") method should be called explicitly. This warning will in a later major release become an error, however the message will always be clear when [`SelectBase.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery \"sqlalchemy.sql.expression.SelectBase.scalar_subquery\") needs to be invoked. The latter part of the change is for clarity and to reduce the implicit decisionmaking by the query coercion system. The [`Subquery.as_scalar()`](../core/selectable.html#sqlalchemy.sql.expression.Subquery.as_scalar \"sqlalchemy.sql.expression.Subquery.as_scalar\") method, which was previously `Alias.as_scalar`, is also deprecated; `.scalar_subquery()` should be invoked directly from ` [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") object or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object.\n\n    This change is part of the larger change to convert [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") objects to no longer be directly part of the \u201cfrom clause\u201d class hierarchy, which also includes an overhaul of the clause coercion system.\n\n    References: [#4617](https://www.sqlalchemy.org/trac/ticket/4617)\n\n*   **[sql] [renamed]**\n\n    Several operators are renamed to achieve more consistent naming across SQLAlchemy.\n\n    The operator changes are:\n\n    *   `isfalse` is now `is_false`\n\n    *   `isnot_distinct_from` is now `is_not_distinct_from`\n\n    *   `istrue` is now `is_true`\n\n    *   `notbetween` is now `not_between`\n\n    *   `notcontains` is now `not_contains`\n\n    *   `notendswith` is now `not_endswith`\n\n    *   `notilike` is now `not_ilike`\n\n    *   `notlike` is now `not_like`\n\n    *   `notmatch` is now `not_match`\n\n    *   `notstartswith` is now `not_startswith`\n\n    *   `nullsfirst` is now `nulls_first`\n\n    *   `nullslast` is now `nulls_last`\n\n    *   `isnot` is now `is_not`\n\n    *   `notin_` is now `not_in`\n\n    Because these are core operators, the internal migration strategy for this change is to support legacy terms for an extended period of time \u2013 if not indefinitely \u2013 but update all documentation, tutorials, and internal usage to the new terms. The new terms are used to define the functions, and the legacy terms have been deprecated into aliases of the new terms.\n\n    References: [#5429](https://www.sqlalchemy.org/trac/ticket/5429), [#5435](https://www.sqlalchemy.org/trac/ticket/5435)\n\n*   **[sql] [postgresql]**\n\n    Allow specifying the data type when creating a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") in PostgreSQL by using the parameter [`Sequence.data_type`](../core/defaults.html#sqlalchemy.schema.Sequence.params.data_type \"sqlalchemy.schema.Sequence\").\n\n    References: [#5498](https://www.sqlalchemy.org/trac/ticket/5498)\n\n*   **[sql] [reflection]**\n\n    The \u201cNO ACTION\u201d keyword for foreign key \u201cON UPDATE\u201d is now considered to be the default cascade for a foreign key on all supporting backends (SQlite, MySQL, PostgreSQL) and when detected is not included in the reflection dictionary; this is already the behavior for PostgreSQL and MySQL for all previous SQLAlchemy versions in any case. The \u201cRESTRICT\u201d keyword is positively stored when detected; PostgreSQL does report on this keyword, and MySQL as of version 8.0 does as well. On earlier MySQL versions, it is not reported by the database.\n\n    References: [#4741](https://www.sqlalchemy.org/trac/ticket/4741)\n\n*   **[sql] [reflection]**\n\n    Added support for reflecting \u201cidentity\u201d columns, which are now returned as part of the structure returned by [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns \"sqlalchemy.engine.reflection.Inspector.get_columns\"). When reflecting full [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects, identity columns will be represented using the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") construct. Currently the supported backends are PostgreSQL >= 10, Oracle >= 12 and MSSQL (with different syntax and a subset of functionalities).\n\n    References: [#5324](https://www.sqlalchemy.org/trac/ticket/5324), [#5527](https://www.sqlalchemy.org/trac/ticket/5527)\n\n### schema\n\n*   **[schema] [change]**\n\n    The [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint \"sqlalchemy.types.Enum\") and [`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint \"sqlalchemy.types.Boolean\") parameters now default to False, indicating when a so-called \u201cnon-native\u201d version of these two datatypes is created, a CHECK constraint will not be generated by default. These CHECK constraints present schema-management maintenance complexities that should be opted in to, rather than being turned on by default.\n\n    See also\n\n    [Enum and Boolean datatypes no longer default to \u201ccreate constraint\u201d](migration_14.html#change-5367)\n\n    References: [#5367](https://www.sqlalchemy.org/trac/ticket/5367)\n\n*   **[schema] [bug]**\n\n    Cleaned up the internal `str()` for datatypes so that all types produce a string representation without any dialect present, including that it works for third-party dialect types without that dialect being present. The string representation defaults to being the UPPERCASE name of that type with nothing else.\n\n    References: [#4262](https://www.sqlalchemy.org/trac/ticket/4262)\n\n*   **[schema] [removed]**\n\n    Remove deprecated class `Binary`. Please use [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary \"sqlalchemy.types.LargeBinary\").\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n*   **[schema] [renamed]**\n\n    Renamed the [`Table.tometadata()`](../core/metadata.html#sqlalchemy.schema.Table.tometadata \"sqlalchemy.schema.Table.tometadata\") method to [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata \"sqlalchemy.schema.Table.to_metadata\"). The previous name remains with a deprecation warning.\n\n    References: [#5413](https://www.sqlalchemy.org/trac/ticket/5413)\n\n*   **[schema] [sql]**\n\n    Added the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") construct that can be used to configure identity columns rendered with GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY. Currently the supported backends are PostgreSQL >= 10, Oracle >= 12 and MSSQL (with different syntax and a subset of functionalities).\n\n    References: [#5324](https://www.sqlalchemy.org/trac/ticket/5324), [#5360](https://www.sqlalchemy.org/trac/ticket/5360), [#5362](https://www.sqlalchemy.org/trac/ticket/5362)\n\n### extensions\n\n*   **[extensions] [usecase]**\n\n    Custom compiler constructs created using the `sqlalchemy.ext.compiled` extension will automatically add contextual information to the compiler when a custom construct is interpreted as an element in the columns clause of a SELECT statement, such that the custom element will be targetable as a key in result row mappings, which is the kind of targeting that the ORM uses in order to match column elements into result tuples.\n\n    References: [#4887](https://www.sqlalchemy.org/trac/ticket/4887)\n\n*   **[extensions] [change]**\n\n    Added new parameter [`AutomapBase.prepare.autoload_with`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with \"sqlalchemy.ext.automap.AutomapBase.prepare\") which supersedes [`AutomapBase.prepare.reflect`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect \"sqlalchemy.ext.automap.AutomapBase.prepare\") and [`AutomapBase.prepare.engine`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine \"sqlalchemy.ext.automap.AutomapBase.prepare\").\n\n    References: [#5142](https://www.sqlalchemy.org/trac/ticket/5142)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added support for PostgreSQL \u201creadonly\u201d and \u201cdeferrable\u201d flags for all of psycopg2, asyncpg and pg8000 dialects. This takes advantage of a newly generalized version of the \u201cisolation level\u201d API to support other kinds of session attributes set via execution options that are reliably reset when connections are returned to the connection pool.\n\n    See also\n\n    [Setting READ ONLY / DEFERRABLE](../dialects/postgresql.html#postgresql-readonly-deferrable)\n\n    References: [#5549](https://www.sqlalchemy.org/trac/ticket/5549)\n\n*   **[postgresql] [usecase]**\n\n    The maximum buffer size for the `BufferedRowResultProxy`, which is used by dialects such as PostgreSQL when `stream_results=True`, can now be set to a number greater than 1000 and the buffer will grow to that size. Previously, the buffer would not go beyond 1000 even if the value were set larger. The growth of the buffer is also now based on a simple multiplying factor currently set to 5\\. Pull request courtesy Soumaya Mauthoor.\n\n    References: [#4914](https://www.sqlalchemy.org/trac/ticket/4914)\n\n*   **[postgresql] [change]**\n\n    When using the psycopg2 dialect for PostgreSQL, psycopg2 minimum version is set at 2.7\\. The psycopg2 dialect relies upon many features of psycopg2 released in the past few years, so to simplify the dialect, version 2.7, released in March, 2017 is now the minimum version required.\n\n*   **[postgresql] [performance]**\n\n    The psycopg2 dialect now defaults to using the very performant `execute_values()` psycopg2 extension for compiled INSERT statements, and also implements RETURNING support when this extension is used. This allows INSERT statements that even include an autoincremented SERIAL or IDENTITY value to run very fast while still being able to return the newly generated primary key values. The ORM will then integrate this new feature in a separate change.\n\n    See also\n\n    [psycopg2 dialect features \u201cexecute_values\u201d with RETURNING for INSERT statements by default](migration_14.html#change-5401) - full list of changes regarding the `executemany_mode` parameter.\n\n    References: [#5401](https://www.sqlalchemy.org/trac/ticket/5401)\n\n*   **[postgresql] [bug]**\n\n    The pg8000 dialect has been revised and modernized for the most recent version of the pg8000 driver for PostgreSQL. Pull request courtesy Tony Locke. Note that this necessarily pins pg8000 at 1.16.6 or greater, which no longer has Python 2 support. Python 2 users who require pg8000 should ensure their requirements are pinned at `SQLAlchemy<1.4`.\n\n*   **[postgresql] [deprecated]**\n\n    The pygresql and py-postgresql dialects are deprecated.\n\n    References: [#5189](https://www.sqlalchemy.org/trac/ticket/5189)\n\n*   **[postgresql] [removed]**\n\n    Remove support for deprecated engine URLs of the form `postgres://`; this has emitted a warning for many years and projects should be using `postgresql://`.\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n### mysql\n\n*   **[mysql] [feature]**\n\n    Added support for MariaDB Connector/Python to the mysql dialect. Original pull request courtesy Georg Richter.\n\n    References: [#5459](https://www.sqlalchemy.org/trac/ticket/5459)\n\n*   **[mysql] [usecase]**\n\n    Added a new dialect token \u201cmariadb\u201d that may be used in place of \u201cmysql\u201d in the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine \"sqlalchemy.create_engine\") URL. This will deliver a MariaDB dialect subclass of the MySQLDialect in use that forces the \u201cis_mariadb\u201d flag to True. The dialect will raise an error if a server version string that does not indicate MariaDB in use is received. This is useful for MariaDB-specific testing scenarios as well as to support applications that are hardcoding to MariaDB-only concepts. As MariaDB and MySQL featuresets and usage patterns continue to diverge, this pattern may become more prominent.\n\n    References: [#5496](https://www.sqlalchemy.org/trac/ticket/5496)\n\n*   **[mysql] [usecase]**\n\n    Added support for use of the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") construct with MariaDB 10.3 and greater, as this is now supported by this database. The construct integrates with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object in the same way that it does for other databases like PostgreSQL and Oracle; if is present on the integer primary key \u201cautoincrement\u201d column, it is used to generate defaults. For backwards compatibility, to support a [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") that has a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") on it to support sequence only databases like Oracle, while still not having the sequence fire off for MariaDB, the optional=True flag should be set, which indicates the sequence should only be used to generate the primary key if the target database offers no other option.\n\n    See also\n\n    [Added Sequence support for MariaDB 10.3](migration_14.html#change-4976)\n\n    References: [#4976](https://www.sqlalchemy.org/trac/ticket/4976)\n\n*   **[mysql] [bug]**\n\n    The MySQL and MariaDB dialects now query from the information_schema.tables system view in order to determine if a particular table exists or not. Previously, the \u201cDESCRIBE\u201d command was used with an exception catch to detect non-existent, which would have the undesirable effect of emitting a ROLLBACK on the connection. There appeared to be legacy encoding issues which prevented the use of \u201cSHOW TABLES\u201d, for this, but as MySQL support is now at 5.0.2 or above due to [#4189](https://www.sqlalchemy.org/trac/ticket/4189), the information_schema tables are now available in all cases.\n\n*   **[mysql] [bug]**\n\n    The \u201cskip_locked\u201d keyword used with `with_for_update()` will render \u201cSKIP LOCKED\u201d on all MySQL backends, meaning it will fail for MySQL less than version 8 and on current MariaDB backends. This is because those backends do not support \u201cSKIP LOCKED\u201d or any equivalent, so this error should not be silently ignored. This is upgraded from a warning in the 1.3 series.\n\n    References: [#5568](https://www.sqlalchemy.org/trac/ticket/5568)\n\n*   **[mysql] [bug]**\n\n    MySQL dialect\u2019s server_version_info tuple is now all numeric. String tokens like \u201cMariaDB\u201d are no longer present so that numeric comparison works in all cases. The .is_mariadb flag on the dialect should be consulted for whether or not mariadb was detected. Additionally removed structures meant to support extremely old MySQL versions 3.x and 4.x; the minimum MySQL version supported is now version 5.0.2.\n\n    References: [#4189](https://www.sqlalchemy.org/trac/ticket/4189)\n\n*   **[mysql] [deprecated]**\n\n    The OurSQL dialect is deprecated.\n\n    References: [#5189](https://www.sqlalchemy.org/trac/ticket/5189)\n\n*   **[mysql] [removed]**\n\n    Remove deprecated dialect `mysql+gaerdbms` that has been deprecated since version 1.0\\. Use the MySQLdb dialect directly.\n\n    Remove deprecated parameter `quoting` from [`ENUM`](../dialects/mysql.html#sqlalchemy.dialects.mysql.ENUM \"sqlalchemy.dialects.mysql.ENUM\") and [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET \"sqlalchemy.dialects.mysql.SET\") in the `mysql` dialect. The values passed to the enum or the set are quoted by SQLAlchemy when needed automatically.\n\n    References: [#4643](https://www.sqlalchemy.org/trac/ticket/4643)\n\n### sqlite\n\n*   **[sqlite] [change]**\n\n    Dropped support for right-nested join rewriting to support old SQLite versions prior to 3.7.16, released in 2013\\. It is expected that all modern Python versions among those now supported should all include much newer versions of SQLite.\n\n    See also\n\n    [Removed \u201cjoin rewriting\u201d logic from SQLite dialect; updated imports](migration_14.html#change-4895)\n\n    References: [#4895](https://www.sqlalchemy.org/trac/ticket/4895)\n\n### mssql\n\n*   **[mssql] [feature] [sql]**\n\n    Added support for the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON \"sqlalchemy.types.JSON\") datatype on the SQL Server dialect using the [`JSON`](../dialects/mssql.html#sqlalchemy.dialects.mssql.JSON \"sqlalchemy.dialects.mssql.JSON\") implementation, which implements SQL Server\u2019s JSON functionality against the `NVARCHAR(max)` datatype as per SQL Server documentation. Implementation courtesy Gord Thompson.\n\n    References: [#4384](https://www.sqlalchemy.org/trac/ticket/4384)\n\n*   **[mssql] [feature]**\n\n    Added support for \u201cCREATE SEQUENCE\u201d and full [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") support for Microsoft SQL Server. This removes the deprecated feature of using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") objects to manipulate IDENTITY characteristics which should now be performed using `mssql_identity_start` and `mssql_identity_increment` as documented at [Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity). The change includes a new parameter [`Sequence.data_type`](../core/defaults.html#sqlalchemy.schema.Sequence.params.data_type \"sqlalchemy.schema.Sequence\") to accommodate SQL Server\u2019s choice of datatype, which for that backend includes INTEGER, BIGINT, and DECIMAL(n, 0). The default starting value for SQL Server\u2019s version of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") has been set at 1; this default is now emitted within the CREATE SEQUENCE DDL for all backends.\n\n    See also\n\n    [Added Sequence support distinct from IDENTITY to SQL Server](migration_14.html#change-4235)\n\n    References: [#4235](https://www.sqlalchemy.org/trac/ticket/4235), [#4633](https://www.sqlalchemy.org/trac/ticket/4633)\n\n*   **[mssql] [usecase] [postgresql] [reflection] [schema]**\n\n    Improved support for covering indexes (with INCLUDE columns). Added the ability for postgresql to render CREATE INDEX statements with an INCLUDE clause from Core. Index reflection also report INCLUDE columns separately for both mssql and postgresql (11+).\n\n    References: [#4458](https://www.sqlalchemy.org/trac/ticket/4458)\n\n*   **[mssql] [usecase] [postgresql]**\n\n    Added support for inspection / reflection of partial indexes / filtered indexes, i.e. those which use the `mssql_where` or `postgresql_where` parameters, with [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\"). The entry is both part of the dictionary returned by [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes \"sqlalchemy.engine.reflection.Inspector.get_indexes\") as well as part of a reflected [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\") construct that was reflected. Pull request courtesy Ramon Williams.\n\n    References: [#4966](https://www.sqlalchemy.org/trac/ticket/4966)\n\n*   **[mssql] [usecase] [reflection]**\n\n    Added support for reflection of temporary tables with the SQL Server dialect. Table names that are prefixed by a pound sign \u201c#\u201d are now introspected from the MSSQL \u201ctempdb\u201d system catalog.\n\n    References: [#5506](https://www.sqlalchemy.org/trac/ticket/5506)\n\n*   **[mssql] [change]**\n\n    SQL Server OFFSET and FETCH keywords are now used for limit/offset, rather than using a window function, for SQL Server versions 11 and higher. TOP is still used for a query that features only LIMIT. Pull request courtesy Elkin.\n\n    References: [#5084](https://www.sqlalchemy.org/trac/ticket/5084)\n\n*   **[mssql] [bug] [schema]**\n\n    Fixed an issue where `sqlalchemy.engine.reflection.has_table()` always returned `False` for temporary tables.\n\n    References: [#5597](https://www.sqlalchemy.org/trac/ticket/5597)\n\n*   **[mssql] [bug]**\n\n    Fixed the base class of the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET \"sqlalchemy.dialects.mssql.DATETIMEOFFSET\") datatype to be based on the [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime \"sqlalchemy.types.DateTime\") class hierarchy, as this is a datetime-holding datatype.\n\n    References: [#4980](https://www.sqlalchemy.org/trac/ticket/4980)\n\n*   **[mssql] [deprecated]**\n\n    The adodbapi and mxODBC dialects are deprecated.\n\n    References: [#5189](https://www.sqlalchemy.org/trac/ticket/5189)\n\n*   **[mssql]**\n\n    The mssql dialect will assume that at least MSSQL 2005 is used. There is no hard exception raised if a previous version is detected, but operations may fail for older versions.\n\n*   **[mssql] [reflection]**\n\n    As part of the support for reflecting [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") objects, the method [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns \"sqlalchemy.engine.reflection.Inspector.get_columns\") no longer returns `mssql_identity_start` and `mssql_identity_increment` as part of the `dialect_options`. Use the information in the `identity` key instead.\n\n    References: [#5527](https://www.sqlalchemy.org/trac/ticket/5527)\n\n*   **[mssql] [engine]**\n\n    Deprecated the `legacy_schema_aliasing` parameter to [`sqlalchemy.create_engine()`](../core/engines.html#sqlalchemy.create_engine \"sqlalchemy.create_engine\"). This is a long-outdated parameter that has defaulted to False since version 1.1.\n\n    References: [#4809](https://www.sqlalchemy.org/trac/ticket/4809)\n\n### oracle\n\n*   **[oracle] [usecase]**\n\n    The max_identifier_length for the Oracle dialect is now 128 characters by default, unless compatibility version less than 12.2 upon first connect, in which case the legacy length of 30 characters is used. This is a continuation of the issue as committed to the 1.3 series which adds max identifier length detection upon first connect as well as warns for the change in Oracle server.\n\n    See also\n\n    [Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths) - in the Oracle dialect documentation\n\n    References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)\n\n*   **[oracle] [change]**\n\n    The LIMIT / OFFSET scheme used in Oracle now makes use of named subqueries rather than unnamed subqueries when it transparently rewrites a SELECT statement to one that uses a subquery that includes ROWNUM. The change is part of a larger change where unnamed subqueries are no longer directly supported by Core, as well as to modernize the internal use of the select() construct within the Oracle dialect.\n\n*   **[oracle] [bug]**\n\n    Correctly render [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") and [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") column options `nominvalue` and `nomaxvalue` as `NOMAXVALUE` and ``NOMINVALUE` on oracle database.\n\n*   **[oracle] [bug]**\n\n    The [`INTERVAL`](../dialects/oracle.html#sqlalchemy.dialects.oracle.INTERVAL \"sqlalchemy.dialects.oracle.INTERVAL\") class of the Oracle dialect is now correctly a subclass of the abstract version of [`Interval`](../core/type_basics.html#sqlalchemy.types.Interval \"sqlalchemy.types.Interval\") as well as the correct \u201cemulated\u201d base class, which allows for correct behavior under both native and non-native modes; previously it was only based on [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine \"sqlalchemy.types.TypeEngine\").\n\n    References: [#4971](https://www.sqlalchemy.org/trac/ticket/4971)\n\n### misc\n\n*   **[deprecated] [firebird]**\n\n    The Firebird dialect is deprecated, as there is now a 3rd party dialect that supports this database.\n\n    References: [#5189](https://www.sqlalchemy.org/trac/ticket/5189)\n\n*   **[misc] [deprecated]**\n\n    The Sybase dialect is deprecated.\n\n    References: [#5189](https://www.sqlalchemy.org/trac/ticket/5189)\n\n## 1.4.53\n\nno release date\n\n## 1.4.52\n\nReleased: March 4, 2024\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed bug where ORM [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") would not apply itself to a [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") where the ON clause were given as a plain SQL comparison, rather than as a relationship target or similar.\n\n    This is a backport of the same issue fixed in version 2.0 for 2.0.22.\n\n    References: [#10365](https://www.sqlalchemy.org/trac/ticket/10365)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed bug where ORM [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") would not apply itself to a [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") where the ON clause were given as a plain SQL comparison, rather than as a relationship target or similar.\n\n    This is a backport of the same issue fixed in version 2.0 for 2.0.22.\n\n    References: [#10365](https://www.sqlalchemy.org/trac/ticket/10365)\n\n## 1.4.51\n\nReleased: January 2, 2024\n\n### orm\n\n*   **[orm] [bug]**\n\n    Improved a fix first implemented for [#3208](https://www.sqlalchemy.org/trac/ticket/3208) released in version 0.9.8, where the registry of classes used internally by declarative could be subject to a race condition in the case where individual mapped classes are being garbage collected at the same time while new mapped classes are being constructed, as can happen in some test suite configurations or dynamic class creation environments. In addition to the weakref check already added, the list of items being iterated is also copied first to avoid \u201clist changed while iterating\u201d errors. Pull request courtesy Yilei Yang.\n\n    References: [#10782](https://www.sqlalchemy.org/trac/ticket/10782)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Fixed critical issue in asyncio version of the connection pool where calling [`AsyncEngine.dispose()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.dispose \"sqlalchemy.ext.asyncio.AsyncEngine.dispose\") would produce a new connection pool that did not fully re-establish the use of asyncio-compatible mutexes, leading to the use of a plain `threading.Lock()` which would then cause deadlocks in an asyncio context when using concurrency features like `asyncio.gather()`.\n\n    References: [#10813](https://www.sqlalchemy.org/trac/ticket/10813)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Fixed regression introduced by the fix in ticket [#10492](https://www.sqlalchemy.org/trac/ticket/10492) when using pool pre-ping with PyMySQL version older than 1.0.\n\n    References: [#10650](https://www.sqlalchemy.org/trac/ticket/10650)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Improved a fix first implemented for [#3208](https://www.sqlalchemy.org/trac/ticket/3208) released in version 0.9.8, where the registry of classes used internally by declarative could be subject to a race condition in the case where individual mapped classes are being garbage collected at the same time while new mapped classes are being constructed, as can happen in some test suite configurations or dynamic class creation environments. In addition to the weakref check already added, the list of items being iterated is also copied first to avoid \u201clist changed while iterating\u201d errors. Pull request courtesy Yilei Yang.\n\n    References: [#10782](https://www.sqlalchemy.org/trac/ticket/10782)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Fixed critical issue in asyncio version of the connection pool where calling [`AsyncEngine.dispose()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.dispose \"sqlalchemy.ext.asyncio.AsyncEngine.dispose\") would produce a new connection pool that did not fully re-establish the use of asyncio-compatible mutexes, leading to the use of a plain `threading.Lock()` which would then cause deadlocks in an asyncio context when using concurrency features like `asyncio.gather()`.\n\n    References: [#10813](https://www.sqlalchemy.org/trac/ticket/10813)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Fixed regression introduced by the fix in ticket [#10492](https://www.sqlalchemy.org/trac/ticket/10492) when using pool pre-ping with PyMySQL version older than 1.0.\n\n    References: [#10650](https://www.sqlalchemy.org/trac/ticket/10650)\n\n## 1.4.50\n\nReleased: October 29, 2023\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed fundamental issue which prevented some forms of ORM \u201cannotations\u201d from taking place for subqueries which made use of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") against a relationship target. These annotations are used whenever a subquery is used in special situations such as within [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") and other ORM-specific scenarios.\n\n    References: [#10223](https://www.sqlalchemy.org/trac/ticket/10223)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where using the same bound parameter more than once with `literal_execute=True` in some combinations with other literal rendering parameters would cause the wrong values to render due to an iteration issue.\n\n    References: [#10142](https://www.sqlalchemy.org/trac/ticket/10142)\n\n*   **[sql] [bug]**\n\n    Fixed issue where unpickling of a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") or other [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement \"sqlalchemy.sql.expression.ColumnElement\") would fail to restore the correct \u201ccomparator\u201d object, which is used to generate SQL expressions specific to the type object.\n\n    References: [#10213](https://www.sqlalchemy.org/trac/ticket/10213)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Modified the rendering of the Oracle only [`Identity.order`](../core/defaults.html#sqlalchemy.schema.Identity.params.order \"sqlalchemy.schema.Identity\") parameter that\u2019s part of both [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") and [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") to only take place for the Oracle backend, and not other backends such as that of PostgreSQL. A future release will rename the [`Identity.order`](../core/defaults.html#sqlalchemy.schema.Identity.params.order \"sqlalchemy.schema.Identity\"), [`Sequence.order`](../core/defaults.html#sqlalchemy.schema.Sequence.params.order \"sqlalchemy.schema.Sequence\") and [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null \"sqlalchemy.schema.Identity\") parameters to Oracle-specific names, deprecating the old names, these parameters only apply to Oracle.\n\n    References: [#10207](https://www.sqlalchemy.org/trac/ticket/10207)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Updated aiomysql dialect since the dialect appears to be maintained again. Re-added to the ci testing using version 0.2.0.\n\n*   **[mysql] [bug]**\n\n    Repaired a new incompatibility in the MySQL \u201cpre-ping\u201d routine where the `False` argument passed to `connection.ping()`, which is intended to disable an unwanted \u201cautomatic reconnect\u201d feature, is being deprecated in MySQL drivers and backends, and is producing warnings for some versions of MySQL\u2019s native client drivers. It\u2019s removed for mysqlclient, whereas for PyMySQL and drivers based on PyMySQL, the parameter will be deprecated and removed at some point, so API introspection is used to future proof against these various stages of removal.\n\n    References: [#10492](https://www.sqlalchemy.org/trac/ticket/10492)\n\n### mssql\n\n*   **[mssql] [bug] [reflection]**\n\n    Fixed issue where identity column reflection would fail for a bigint column with a large identity start value (more than 18 digits).\n\n    References: [#10504](https://www.sqlalchemy.org/trac/ticket/10504)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed fundamental issue which prevented some forms of ORM \u201cannotations\u201d from taking place for subqueries which made use of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\") against a relationship target. These annotations are used whenever a subquery is used in special situations such as within [`PropComparator.and_()`](../orm/internals.html#sqlalchemy.orm.PropComparator.and_ \"sqlalchemy.orm.PropComparator.and_\") and other ORM-specific scenarios.\n\n    References: [#10223](https://www.sqlalchemy.org/trac/ticket/10223)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where using the same bound parameter more than once with `literal_execute=True` in some combinations with other literal rendering parameters would cause the wrong values to render due to an iteration issue.\n\n    References: [#10142](https://www.sqlalchemy.org/trac/ticket/10142)\n\n*   **[sql] [bug]**\n\n    Fixed issue where unpickling of a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") or other [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement \"sqlalchemy.sql.expression.ColumnElement\") would fail to restore the correct \u201ccomparator\u201d object, which is used to generate SQL expressions specific to the type object.\n\n    References: [#10213](https://www.sqlalchemy.org/trac/ticket/10213)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Modified the rendering of the Oracle only [`Identity.order`](../core/defaults.html#sqlalchemy.schema.Identity.params.order \"sqlalchemy.schema.Identity\") parameter that\u2019s part of both [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence \"sqlalchemy.schema.Sequence\") and [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity \"sqlalchemy.schema.Identity\") to only take place for the Oracle backend, and not other backends such as that of PostgreSQL. A future release will rename the [`Identity.order`](../core/defaults.html#sqlalchemy.schema.Identity.params.order \"sqlalchemy.schema.Identity\"), [`Sequence.order`](../core/defaults.html#sqlalchemy.schema.Sequence.params.order \"sqlalchemy.schema.Sequence\") and [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null \"sqlalchemy.schema.Identity\") parameters to Oracle-specific names, deprecating the old names, these parameters only apply to Oracle.\n\n    References: [#10207](https://www.sqlalchemy.org/trac/ticket/10207)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Updated aiomysql dialect since the dialect appears to be maintained again. Re-added to the ci testing using version 0.2.0.\n\n*   **[mysql] [bug]**\n\n    Repaired a new incompatibility in the MySQL \u201cpre-ping\u201d routine where the `False` argument passed to `connection.ping()`, which is intended to disable an unwanted \u201cautomatic reconnect\u201d feature, is being deprecated in MySQL drivers and backends, and is producing warnings for some versions of MySQL\u2019s native client drivers. It\u2019s removed for mysqlclient, whereas for PyMySQL and drivers based on PyMySQL, the parameter will be deprecated and removed at some point, so API introspection is used to future proof against these various stages of removal.\n\n    References: [#10492](https://www.sqlalchemy.org/trac/ticket/10492)\n\n### mssql\n\n*   **[mssql] [bug] [reflection]**\n\n    Fixed issue where identity column reflection would fail for a bigint column with a large identity start value (more than 18 digits).\n\n    References: [#10504](https://www.sqlalchemy.org/trac/ticket/10504)\n\n## 1.4.49\n\nReleased: July 5, 2023\n\n### platform\n\n*   **[platform] [usecase]**\n\n    Compatibility improvements to work fully with Python 3.12\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") when using \u201cflags\u201d would not produce a \u201cstable\u201d cache key, that is, the cache key would keep changing each time causing cache pollution. The same issue existed for [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") with both the flags and the actual replacement expression. The flags are now represented as fixed modifier strings rendered as safestrings rather than bound parameters, and the replacement expression is established within the primary portion of the \u201cbinary\u201d element so that it generates an appropriate cache key.\n\n    Note that as part of this change, the [`ColumnOperators.regexp_match.flags`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match.params.flags \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") and [`ColumnOperators.regexp_replace.flags`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace.params.flags \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") have been modified to render as literal strings only, whereas previously they were rendered as full SQL expressions, typically bound parameters. These parameters should always be passed as plain Python strings and not as SQL expression constructs; it\u2019s not expected that SQL expression constructs were used in practice for this parameter, so this is a backwards-incompatible change.\n\n    The change also modifies the internal structure of the expression generated, for [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") with or without flags, and for [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") with flags. Third party dialects which may have implemented regexp implementations of their own (no such dialects could be located in a search, so impact is expected to be low) would need to adjust the traversal of the structure to accommodate.\n\n    References: [#10042](https://www.sqlalchemy.org/trac/ticket/10042)\n\n*   **[sql] [bug]**\n\n    Fixed issue in mostly-internal [`CacheKey`](../core/foundation.html#sqlalchemy.sql.expression.CacheKey \"sqlalchemy.sql.expression.CacheKey\") construct where the `__ne__()` operator were not properly implemented, leading to nonsensical results when comparing [`CacheKey`](../core/foundation.html#sqlalchemy.sql.expression.CacheKey \"sqlalchemy.sql.expression.CacheKey\") instances to each other.\n\n### extensions\n\n*   **[extensions] [bug]**\n\n    Fixed issue in mypy plugin for use with mypy 1.4.\n\n### platform\n\n*   **[platform] [usecase]**\n\n    Compatibility improvements to work fully with Python 3.12\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") when using \u201cflags\u201d would not produce a \u201cstable\u201d cache key, that is, the cache key would keep changing each time causing cache pollution. The same issue existed for [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") with both the flags and the actual replacement expression. The flags are now represented as fixed modifier strings rendered as safestrings rather than bound parameters, and the replacement expression is established within the primary portion of the \u201cbinary\u201d element so that it generates an appropriate cache key.\n\n    Note that as part of this change, the [`ColumnOperators.regexp_match.flags`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match.params.flags \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") and [`ColumnOperators.regexp_replace.flags`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace.params.flags \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") have been modified to render as literal strings only, whereas previously they were rendered as full SQL expressions, typically bound parameters. These parameters should always be passed as plain Python strings and not as SQL expression constructs; it\u2019s not expected that SQL expression constructs were used in practice for this parameter, so this is a backwards-incompatible change.\n\n    The change also modifies the internal structure of the expression generated, for [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace \"sqlalchemy.sql.expression.ColumnOperators.regexp_replace\") with or without flags, and for [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match \"sqlalchemy.sql.expression.ColumnOperators.regexp_match\") with flags. Third party dialects which may have implemented regexp implementations of their own (no such dialects could be located in a search, so impact is expected to be low) would need to adjust the traversal of the structure to accommodate.\n\n    References: [#10042](https://www.sqlalchemy.org/trac/ticket/10042)\n\n*   **[sql] [bug]**\n\n    Fixed issue in mostly-internal [`CacheKey`](../core/foundation.html#sqlalchemy.sql.expression.CacheKey \"sqlalchemy.sql.expression.CacheKey\") construct where the `__ne__()` operator were not properly implemented, leading to nonsensical results when comparing [`CacheKey`](../core/foundation.html#sqlalchemy.sql.expression.CacheKey \"sqlalchemy.sql.expression.CacheKey\") instances to each other.\n\n### extensions\n\n*   **[extensions] [bug]**\n\n    Fixed issue in mypy plugin for use with mypy 1.4.\n\n## 1.4.48\n\nReleased: April 30, 2023\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed critical caching issue where the combination of [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") and [`hybrid_property()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property \"sqlalchemy.ext.hybrid.hybrid_property\") expression compositions would cause a cache key mismatch, leading to cache keys that held onto the actual [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") object while also not matching that of equivalent constructs, filling up the cache.\n\n    References: [#9728](https://www.sqlalchemy.org/trac/ticket/9728)\n\n*   **[orm] [bug]**\n\n    Fixed bug where various ORM-specific getters such as [`ORMExecuteState.is_column_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_column_load \"sqlalchemy.orm.ORMExecuteState.is_column_load\"), [`ORMExecuteState.is_relationship_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_relationship_load \"sqlalchemy.orm.ORMExecuteState.is_relationship_load\"), [`ORMExecuteState.loader_strategy_path`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.loader_strategy_path \"sqlalchemy.orm.ORMExecuteState.loader_strategy_path\") etc. would throw an `AttributeError` if the SQL statement itself were a \u201ccompound select\u201d such as a UNION.\n\n    References: [#9634](https://www.sqlalchemy.org/trac/ticket/9634)\n\n*   **[orm] [bug]**\n\n    Fixed endless loop which could occur when using \u201crelationship to aliased class\u201d feature and also indicating a recursive eager loader such as `lazy=\"selectinload\"` in the loader, in combination with another eager loader on the opposite side. The check for cycles has been fixed to include aliased class relationships.\n\n    References: [#9590](https://www.sqlalchemy.org/trac/ticket/9590)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed critical caching issue where the combination of [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") and [`hybrid_property()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property \"sqlalchemy.ext.hybrid.hybrid_property\") expression compositions would cause a cache key mismatch, leading to cache keys that held onto the actual [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") object while also not matching that of equivalent constructs, filling up the cache.\n\n    References: [#9728](https://www.sqlalchemy.org/trac/ticket/9728)\n\n*   **[orm] [bug]**\n\n    Fixed bug where various ORM-specific getters such as [`ORMExecuteState.is_column_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_column_load \"sqlalchemy.orm.ORMExecuteState.is_column_load\"), [`ORMExecuteState.is_relationship_load`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_relationship_load \"sqlalchemy.orm.ORMExecuteState.is_relationship_load\"), [`ORMExecuteState.loader_strategy_path`](../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.loader_strategy_path \"sqlalchemy.orm.ORMExecuteState.loader_strategy_path\") etc. would throw an `AttributeError` if the SQL statement itself were a \u201ccompound select\u201d such as a UNION.\n\n    References: [#9634](https://www.sqlalchemy.org/trac/ticket/9634)\n\n*   **[orm] [bug]**\n\n    Fixed endless loop which could occur when using \u201crelationship to aliased class\u201d feature and also indicating a recursive eager loader such as `lazy=\"selectinload\"` in the loader, in combination with another eager loader on the opposite side. The check for cycles has been fixed to include aliased class relationships.\n\n    References: [#9590](https://www.sqlalchemy.org/trac/ticket/9590)\n\n## 1.4.47\n\nReleased: March 18, 2023\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed bug / regression where using [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") with the same name as a column in the [`Update.values()`](../core/dml.html#sqlalchemy.sql.expression.Update.values \"sqlalchemy.sql.expression.Update.values\") method of [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"), as well as the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values \"sqlalchemy.sql.expression.Insert.values\") method of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") in 2.0 only, would in some cases silently fail to honor the SQL expression in which the parameter were presented, replacing the expression with a new parameter of the same name and discarding any other elements of the SQL expression, such as SQL functions, etc. The specific case would be statements that were constructed against ORM entities rather than plain [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") instances, but would occur if the statement were invoked with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") or a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\").\n\n    [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") part of the issue was present in both 2.0 and 1.4 and is backported to 1.4.\n\n    References: [#9075](https://www.sqlalchemy.org/trac/ticket/9075)\n\n*   **[sql] [bug]**\n\n    Fixed stringify for a the [`CreateSchema`](../core/ddl.html#sqlalchemy.schema.CreateSchema \"sqlalchemy.schema.CreateSchema\") and [`DropSchema`](../core/ddl.html#sqlalchemy.schema.DropSchema \"sqlalchemy.schema.DropSchema\") DDL constructs, which would fail with an `AttributeError` when stringified without a dialect.\n\n    References: [#7664](https://www.sqlalchemy.org/trac/ticket/7664)\n\n*   **[sql] [bug]**\n\n    Fixed critical SQL caching issue where use of the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op \"sqlalchemy.sql.expression.Operators.op\") custom operator function would not produce an appropriate cache key, leading to reduce the effectiveness of the SQL cache.\n\n    References: [#9506](https://www.sqlalchemy.org/trac/ticket/9506)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Adjustments made to the mypy plugin to accommodate for some potential changes being made for issue #236 sqlalchemy2-stubs when using SQLAlchemy 1.4\\. These changes are being kept in sync within SQLAlchemy 2.0. The changes are also backwards compatible with older versions of sqlalchemy2-stubs.\n\n*   **[mypy] [bug]**\n\n    Fixed crash in mypy plugin which could occur on both 1.4 and 2.0 versions if a decorator for the [`mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped \"sqlalchemy.orm.registry.mapped\") decorator were used that was referenced in an expression with more than two components (e.g. `@Backend.mapper_registry.mapped`). This scenario is now ignored; when using the plugin, the decorator expression needs to be two components (i.e. `@reg.mapped`).\n\n    References: [#9102](https://www.sqlalchemy.org/trac/ticket/9102)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Added support to the asyncpg dialect to return the `cursor.rowcount` value for SELECT statements when available. While this is not a typical use for `cursor.rowcount`, the other PostgreSQL dialects generally provide this value. Pull request courtesy Michael Gorven.\n\n    References: [#9048](https://www.sqlalchemy.org/trac/ticket/9048)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Added support to MySQL index reflection to correctly reflect the `mysql_length` dictionary, which previously was being ignored.\n\n    References: [#9047](https://www.sqlalchemy.org/trac/ticket/9047)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed bug where a schema name given with brackets, but no dots inside the name, for parameters such as [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema \"sqlalchemy.schema.Table\") would not be interpreted within the context of the SQL Server dialect\u2019s documented behavior of interpreting explicit brackets as token delimiters, first added in 1.2 for #2626, when referring to the schema name in reflection operations. The original assumption for #2626\u2019s behavior was that the special interpretation of brackets was only significant if dots were present, however in practice, the brackets are not included as part of the identifier name for all SQL rendering operations since these are not valid characters within regular or delimited identifiers. Pull request courtesy Shan.\n\n    References: [#9133](https://www.sqlalchemy.org/trac/ticket/9133)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Added [`ROWID`](../dialects/oracle.html#sqlalchemy.dialects.oracle.ROWID \"sqlalchemy.dialects.oracle.ROWID\") to reflected types as this type may be used in a \u201cCREATE TABLE\u201d statement.\n\n    References: [#5047](https://www.sqlalchemy.org/trac/ticket/5047)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed bug / regression where using [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") with the same name as a column in the [`Update.values()`](../core/dml.html#sqlalchemy.sql.expression.Update.values \"sqlalchemy.sql.expression.Update.values\") method of [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"), as well as the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values \"sqlalchemy.sql.expression.Insert.values\") method of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") in 2.0 only, would in some cases silently fail to honor the SQL expression in which the parameter were presented, replacing the expression with a new parameter of the same name and discarding any other elements of the SQL expression, such as SQL functions, etc. The specific case would be statements that were constructed against ORM entities rather than plain [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") instances, but would occur if the statement were invoked with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") or a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\").\n\n    [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") part of the issue was present in both 2.0 and 1.4 and is backported to 1.4.\n\n    References: [#9075](https://www.sqlalchemy.org/trac/ticket/9075)\n\n*   **[sql] [bug]**\n\n    Fixed stringify for a the [`CreateSchema`](../core/ddl.html#sqlalchemy.schema.CreateSchema \"sqlalchemy.schema.CreateSchema\") and [`DropSchema`](../core/ddl.html#sqlalchemy.schema.DropSchema \"sqlalchemy.schema.DropSchema\") DDL constructs, which would fail with an `AttributeError` when stringified without a dialect.\n\n    References: [#7664](https://www.sqlalchemy.org/trac/ticket/7664)\n\n*   **[sql] [bug]**\n\n    Fixed critical SQL caching issue where use of the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op \"sqlalchemy.sql.expression.Operators.op\") custom operator function would not produce an appropriate cache key, leading to reduce the effectiveness of the SQL cache.\n\n    References: [#9506](https://www.sqlalchemy.org/trac/ticket/9506)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Adjustments made to the mypy plugin to accommodate for some potential changes being made for issue #236 sqlalchemy2-stubs when using SQLAlchemy 1.4\\. These changes are being kept in sync within SQLAlchemy 2.0. The changes are also backwards compatible with older versions of sqlalchemy2-stubs.\n\n*   **[mypy] [bug]**\n\n    Fixed crash in mypy plugin which could occur on both 1.4 and 2.0 versions if a decorator for the [`mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped \"sqlalchemy.orm.registry.mapped\") decorator were used that was referenced in an expression with more than two components (e.g. `@Backend.mapper_registry.mapped`). This scenario is now ignored; when using the plugin, the decorator expression needs to be two components (i.e. `@reg.mapped`).\n\n    References: [#9102](https://www.sqlalchemy.org/trac/ticket/9102)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Added support to the asyncpg dialect to return the `cursor.rowcount` value for SELECT statements when available. While this is not a typical use for `cursor.rowcount`, the other PostgreSQL dialects generally provide this value. Pull request courtesy Michael Gorven.\n\n    References: [#9048](https://www.sqlalchemy.org/trac/ticket/9048)\n\n### mysql\n\n*   **[mysql] [usecase]**\n\n    Added support to MySQL index reflection to correctly reflect the `mysql_length` dictionary, which previously was being ignored.\n\n    References: [#9047](https://www.sqlalchemy.org/trac/ticket/9047)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed bug where a schema name given with brackets, but no dots inside the name, for parameters such as [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema \"sqlalchemy.schema.Table\") would not be interpreted within the context of the SQL Server dialect\u2019s documented behavior of interpreting explicit brackets as token delimiters, first added in 1.2 for #2626, when referring to the schema name in reflection operations. The original assumption for #2626\u2019s behavior was that the special interpretation of brackets was only significant if dots were present, however in practice, the brackets are not included as part of the identifier name for all SQL rendering operations since these are not valid characters within regular or delimited identifiers. Pull request courtesy Shan.\n\n    References: [#9133](https://www.sqlalchemy.org/trac/ticket/9133)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Added [`ROWID`](../dialects/oracle.html#sqlalchemy.dialects.oracle.ROWID \"sqlalchemy.dialects.oracle.ROWID\") to reflected types as this type may be used in a \u201cCREATE TABLE\u201d statement.\n\n    References: [#5047](https://www.sqlalchemy.org/trac/ticket/5047)\n\n## 1.4.46\n\nReleased: January 3, 2023\n\n### general\n\n*   **[general] [change]**\n\n    A new deprecation \u201cuber warning\u201d is now emitted at runtime the first time any SQLAlchemy 2.0 deprecation warning would normally be emitted, but the `SQLALCHEMY_WARN_20` environment variable is not set. The warning emits only once at most, before setting a boolean to prevent it from emitting a second time.\n\n    This deprecation warning intends to notify users who may not have set an appropriate constraint in their requirements files to block against a surprise SQLAlchemy 2.0 upgrade and also alert that the SQLAlchemy 2.0 upgrade process is available, as the first full 2.0 release is expected very soon. The deprecation warning can be silenced by setting the environment variable `SQLALCHEMY_SILENCE_UBER_WARNING` to `\"1\"`.\n\n    See also\n\n    [SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)\n\n    References: [#8983](https://www.sqlalchemy.org/trac/ticket/8983)\n\n*   **[general] [bug]**\n\n    Fixed regression where the base compat module was calling upon `platform.architecture()` in order to detect some system properties, which results in an over-broad system call against the system-level `file` call that is unavailable under some circumstances, including within some secure environment configurations.\n\n    References: [#8995](https://www.sqlalchemy.org/trac/ticket/8995)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in the internal SQL traversal for DML statements like [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") which would cause among other potential issues, a specific issue using lambda statements with the ORM update/delete feature.\n\n    References: [#9033](https://www.sqlalchemy.org/trac/ticket/9033)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed a long-standing race condition in the connection pool which could occur under eventlet/gevent monkeypatching schemes in conjunction with the use of eventlet/gevent `Timeout` conditions, where a connection pool checkout that\u2019s interrupted due to the timeout would fail to clean up the failed state, causing the underlying connection record and sometimes the database connection itself to \u201cleak\u201d, leaving the pool in an invalid state with unreachable entries. This issue was first identified and fixed in SQLAlchemy 1.2 for [#4225](https://www.sqlalchemy.org/trac/ticket/4225), however the failure modes detected in that fix failed to accommodate for `BaseException`, rather than `Exception`, which prevented eventlet/gevent `Timeout` from being caught. In addition, a block within initial pool connect has also been identified and hardened with a `BaseException` -> \u201cclean failed connect\u201d block to accommodate for the same condition in this location. Big thanks to Github user @niklaus for their tenacious efforts in identifying and describing this intricate issue.\n\n    References: [#8974](https://www.sqlalchemy.org/trac/ticket/8974)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Added parameter [`FunctionElement.column_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.column_valued\"), which is useful in preventing the \u201ccartesian product\u201d warning when making use of table-valued or column-valued functions. This parameter was already introduced for [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued \"sqlalchemy.sql.functions.FunctionElement.table_valued\") in [#7845](https://www.sqlalchemy.org/trac/ticket/7845), however it failed to be added for [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") as well.\n\n    References: [#9009](https://www.sqlalchemy.org/trac/ticket/9009)\n\n*   **[sql] [bug]**\n\n    Fixed bug where SQL compilation would fail (assertion fail in 2.0, NoneType error in 1.4) when using an expression whose type included [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression \"sqlalchemy.types.TypeEngine.bind_expression\"), in the context of an \u201cexpanding\u201d (i.e. \u201cIN\u201d) parameter in conjunction with the `literal_binds` compiler parameter.\n\n    References: [#8989](https://www.sqlalchemy.org/trac/ticket/8989)\n\n*   **[sql] [bug]**\n\n    Fixed issue in lambda SQL feature where the calculated type of a literal value would not take into account the type coercion rules of the \u201ccompared to type\u201d, leading to a lack of typing information for SQL expressions, such as comparisons to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON \"sqlalchemy.types.JSON\") elements and similar.\n\n    References: [#9029](https://www.sqlalchemy.org/trac/ticket/9029)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added the PostgreSQL type `MACADDR8`. Pull request courtesy of Asim Farooq.\n\n    References: [#8393](https://www.sqlalchemy.org/trac/ticket/8393)\n\n*   **[postgresql] [bug]**\n\n    Fixed bug where the PostgreSQL [`Insert.on_conflict_do_update.constraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") parameter would accept an [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\") object, however would not expand this index out into its individual index expressions, instead rendering its name in an ON CONFLICT ON CONSTRAINT clause, which is not accepted by PostgreSQL; the \u201cconstraint name\u201d form only accepts unique or exclude constraint names. The parameter continues to accept the index but now expands it out into its component expressions for the render.\n\n    References: [#9023](https://www.sqlalchemy.org/trac/ticket/9023)\n\n### sqlite\n\n*   **[sqlite] [bug]**\n\n    Fixed regression caused by new support for reflection of partial indexes on SQLite added in 1.4.45 for [#8804](https://www.sqlalchemy.org/trac/ticket/8804), where the `index_list` pragma command in very old versions of SQLite (possibly prior to 3.8.9) does not return the current expected number of columns, leading to exceptions raised when reflecting tables and indexes.\n\n    References: [#8969](https://www.sqlalchemy.org/trac/ticket/8969)\n\n### tests\n\n*   **[tests] [bug]**\n\n    Fixed issue in tox.ini file where changes in the tox 4.0 series to the format of \u201cpassenv\u201d caused tox to not function correctly, in particular raising an error as of tox 4.0.6.\n\n*   **[tests] [bug]**\n\n    Added new exclusion rule for third party dialects called `unusual_column_name_characters`, which can be \u201cclosed\u201d for third party dialects that don\u2019t support column names with unusual characters such as dots, slashes, or percent signs in them, even if the name is properly quoted.\n\n    References: [#9002](https://www.sqlalchemy.org/trac/ticket/9002)\n\n### general\n\n*   **[general] [change]**\n\n    A new deprecation \u201cuber warning\u201d is now emitted at runtime the first time any SQLAlchemy 2.0 deprecation warning would normally be emitted, but the `SQLALCHEMY_WARN_20` environment variable is not set. The warning emits only once at most, before setting a boolean to prevent it from emitting a second time.\n\n    This deprecation warning intends to notify users who may not have set an appropriate constraint in their requirements files to block against a surprise SQLAlchemy 2.0 upgrade and also alert that the SQLAlchemy 2.0 upgrade process is available, as the first full 2.0 release is expected very soon. The deprecation warning can be silenced by setting the environment variable `SQLALCHEMY_SILENCE_UBER_WARNING` to `\"1\"`.\n\n    See also\n\n    [SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)\n\n    References: [#8983](https://www.sqlalchemy.org/trac/ticket/8983)\n\n*   **[general] [bug]**\n\n    Fixed regression where the base compat module was calling upon `platform.architecture()` in order to detect some system properties, which results in an over-broad system call against the system-level `file` call that is unavailable under some circumstances, including within some secure environment configurations.\n\n    References: [#8995](https://www.sqlalchemy.org/trac/ticket/8995)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in the internal SQL traversal for DML statements like [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") which would cause among other potential issues, a specific issue using lambda statements with the ORM update/delete feature.\n\n    References: [#9033](https://www.sqlalchemy.org/trac/ticket/9033)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed a long-standing race condition in the connection pool which could occur under eventlet/gevent monkeypatching schemes in conjunction with the use of eventlet/gevent `Timeout` conditions, where a connection pool checkout that\u2019s interrupted due to the timeout would fail to clean up the failed state, causing the underlying connection record and sometimes the database connection itself to \u201cleak\u201d, leaving the pool in an invalid state with unreachable entries. This issue was first identified and fixed in SQLAlchemy 1.2 for [#4225](https://www.sqlalchemy.org/trac/ticket/4225), however the failure modes detected in that fix failed to accommodate for `BaseException`, rather than `Exception`, which prevented eventlet/gevent `Timeout` from being caught. In addition, a block within initial pool connect has also been identified and hardened with a `BaseException` -> \u201cclean failed connect\u201d block to accommodate for the same condition in this location. Big thanks to Github user @niklaus for their tenacious efforts in identifying and describing this intricate issue.\n\n    References: [#8974](https://www.sqlalchemy.org/trac/ticket/8974)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Added parameter [`FunctionElement.column_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.column_valued\"), which is useful in preventing the \u201ccartesian product\u201d warning when making use of table-valued or column-valued functions. This parameter was already introduced for [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued \"sqlalchemy.sql.functions.FunctionElement.table_valued\") in [#7845](https://www.sqlalchemy.org/trac/ticket/7845), however it failed to be added for [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") as well.\n\n    References: [#9009](https://www.sqlalchemy.org/trac/ticket/9009)\n\n*   **[sql] [bug]**\n\n    Fixed bug where SQL compilation would fail (assertion fail in 2.0, NoneType error in 1.4) when using an expression whose type included [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression \"sqlalchemy.types.TypeEngine.bind_expression\"), in the context of an \u201cexpanding\u201d (i.e. \u201cIN\u201d) parameter in conjunction with the `literal_binds` compiler parameter.\n\n    References: [#8989](https://www.sqlalchemy.org/trac/ticket/8989)\n\n*   **[sql] [bug]**\n\n    Fixed issue in lambda SQL feature where the calculated type of a literal value would not take into account the type coercion rules of the \u201ccompared to type\u201d, leading to a lack of typing information for SQL expressions, such as comparisons to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON \"sqlalchemy.types.JSON\") elements and similar.\n\n    References: [#9029](https://www.sqlalchemy.org/trac/ticket/9029)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added the PostgreSQL type `MACADDR8`. Pull request courtesy of Asim Farooq.\n\n    References: [#8393](https://www.sqlalchemy.org/trac/ticket/8393)\n\n*   **[postgresql] [bug]**\n\n    Fixed bug where the PostgreSQL [`Insert.on_conflict_do_update.constraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") parameter would accept an [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\") object, however would not expand this index out into its individual index expressions, instead rendering its name in an ON CONFLICT ON CONSTRAINT clause, which is not accepted by PostgreSQL; the \u201cconstraint name\u201d form only accepts unique or exclude constraint names. The parameter continues to accept the index but now expands it out into its component expressions for the render.\n\n    References: [#9023](https://www.sqlalchemy.org/trac/ticket/9023)\n\n### sqlite\n\n*   **[sqlite] [bug]**\n\n    Fixed regression caused by new support for reflection of partial indexes on SQLite added in 1.4.45 for [#8804](https://www.sqlalchemy.org/trac/ticket/8804), where the `index_list` pragma command in very old versions of SQLite (possibly prior to 3.8.9) does not return the current expected number of columns, leading to exceptions raised when reflecting tables and indexes.\n\n    References: [#8969](https://www.sqlalchemy.org/trac/ticket/8969)\n\n### tests\n\n*   **[tests] [bug]**\n\n    Fixed issue in tox.ini file where changes in the tox 4.0 series to the format of \u201cpassenv\u201d caused tox to not function correctly, in particular raising an error as of tox 4.0.6.\n\n*   **[tests] [bug]**\n\n    Added new exclusion rule for third party dialects called `unusual_column_name_characters`, which can be \u201cclosed\u201d for third party dialects that don\u2019t support column names with unusual characters such as dots, slashes, or percent signs in them, even if the name is properly quoted.\n\n    References: [#9002](https://www.sqlalchemy.org/trac/ticket/9002)\n\n## 1.4.45\n\nReleased: December 10, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed bug where [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") would fail to preserve the current loaded contents of relationship attributes that were indicated with the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly \"sqlalchemy.orm.relationship\") parameter, thus defeating strategies that use [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") to pull fully loaded objects from caches and other similar techniques. In a related change, fixed issue where an object that contains a loaded relationship that was nonetheless configured as `lazy='raise'` on the mapping would fail when passed to [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\"); checks for \u201craise\u201d are now suspended within the merge process assuming the [`Session.merge.load`](../orm/session_api.html#sqlalchemy.orm.Session.merge.params.load \"sqlalchemy.orm.Session.merge\") parameter remains at its default of `True`.\n\n    Overall, this is a behavioral adjustment to a change introduced in the 1.4 series as of [#4994](https://www.sqlalchemy.org/trac/ticket/4994), which took \u201cmerge\u201d out of the set of cascades applied by default to \u201cviewonly\u201d relationships. As \u201cviewonly\u201d relationships aren\u2019t persisted under any circumstances, allowing their contents to transfer during \u201cmerge\u201d does not impact the persistence behavior of the target object. This allows [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") to correctly suit one of its use cases, that of adding objects to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that were loaded elsewhere, often for the purposes of restoring from a cache.\n\n    References: [#8862](https://www.sqlalchemy.org/trac/ticket/8862)\n\n*   **[orm] [bug]**\n\n    Fixed issues in [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression \"sqlalchemy.orm.with_expression\") where expressions that were composed of columns that were referenced from the enclosing SELECT would not render correct SQL in some contexts, in the case where the expression had a label name that matched the attribute which used [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\"), even when [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") had no default expression. For the moment, if the [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") does have a default expression, that label name is still used for that default, and an additional label with the same name will continue to be ignored. Overall, this case is pretty thorny so further adjustments might be warranted.\n\n    References: [#8881](https://www.sqlalchemy.org/trac/ticket/8881)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where [`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze \"sqlalchemy.engine.Result.freeze\") method would not work for textual SQL using either [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") or [`Connection.exec_driver_sql()`](../core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql \"sqlalchemy.engine.Connection.exec_driver_sql\").\n\n    References: [#8963](https://www.sqlalchemy.org/trac/ticket/8963)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    An informative re-raise is now thrown in the case where any \u201cliteral bindparam\u201d render operation fails, indicating the value itself and the datatype in use, to assist in debugging when literal params are being rendered in a statement.\n\n    References: [#8800](https://www.sqlalchemy.org/trac/ticket/8800)\n\n*   **[sql] [bug]**\n\n    Fixed a series of issues regarding the position and sometimes the identity of rendered bound parameters, such as those used for SQLite, asyncpg, MySQL, Oracle and others. Some compiled forms would not maintain the order of parameters correctly, such as the PostgreSQL `regexp_replace()` function, the \u201cnesting\u201d feature of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct first introduced in [#4123](https://www.sqlalchemy.org/trac/ticket/4123), and selectable tables formed by using the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") method with Oracle.\n\n    References: [#8827](https://www.sqlalchemy.org/trac/ticket/8827)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Removed non-functional `merge()` method from [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\"). This method has never worked and was included with [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\") in error.\n\n    References: [#8952](https://www.sqlalchemy.org/trac/ticket/8952)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Made an adjustment to how the PostgreSQL dialect considers column types when it reflects columns from a table, to accommodate for alternative backends which may return NULL from the PG `format_type()` function.\n\n    References: [#8748](https://www.sqlalchemy.org/trac/ticket/8748)\n\n### sqlite\n\n*   **[sqlite] [usecase]**\n\n    Added support for the SQLite backend to reflect the \u201cDEFERRABLE\u201d and \u201cINITIALLY\u201d keywords which may be present on a foreign key construct. Pull request courtesy Michael Gorven.\n\n    References: [#8903](https://www.sqlalchemy.org/trac/ticket/8903)\n\n*   **[sqlite] [usecase]**\n\n    Added support for reflection of expression-oriented WHERE criteria included in indexes on the SQLite dialect, in a manner similar to that of the PostgreSQL dialect. Pull request courtesy Tobias Pfeiffer.\n\n    References: [#8804](https://www.sqlalchemy.org/trac/ticket/8804)\n\n*   **[sqlite] [bug]**\n\n    Backported a fix for SQLite reflection of unique constraints in attached schemas, released in 2.0 as a small part of [#4379](https://www.sqlalchemy.org/trac/ticket/4379). Previously, unique constraints in attached schemas would be ignored by SQLite reflection. Pull request courtesy Michael Gorven.\n\n    References: [#8866](https://www.sqlalchemy.org/trac/ticket/8866)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Continued fixes for Oracle fix [#8708](https://www.sqlalchemy.org/trac/ticket/8708) released in 1.4.43 where bound parameter names that start with underscores, which are disallowed by Oracle, were still not being properly escaped in all circumstances.\n\n    References: [#8708](https://www.sqlalchemy.org/trac/ticket/8708)\n\n*   **[oracle] [bug]**\n\n    Fixed issue in Oracle compiler where the syntax for [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") was incorrect, rendering the name `COLUMN_VALUE` without qualifying the source table correctly.\n\n    References: [#8945](https://www.sqlalchemy.org/trac/ticket/8945)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed bug where [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") would fail to preserve the current loaded contents of relationship attributes that were indicated with the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly \"sqlalchemy.orm.relationship\") parameter, thus defeating strategies that use [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") to pull fully loaded objects from caches and other similar techniques. In a related change, fixed issue where an object that contains a loaded relationship that was nonetheless configured as `lazy='raise'` on the mapping would fail when passed to [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\"); checks for \u201craise\u201d are now suspended within the merge process assuming the [`Session.merge.load`](../orm/session_api.html#sqlalchemy.orm.Session.merge.params.load \"sqlalchemy.orm.Session.merge\") parameter remains at its default of `True`.\n\n    Overall, this is a behavioral adjustment to a change introduced in the 1.4 series as of [#4994](https://www.sqlalchemy.org/trac/ticket/4994), which took \u201cmerge\u201d out of the set of cascades applied by default to \u201cviewonly\u201d relationships. As \u201cviewonly\u201d relationships aren\u2019t persisted under any circumstances, allowing their contents to transfer during \u201cmerge\u201d does not impact the persistence behavior of the target object. This allows [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") to correctly suit one of its use cases, that of adding objects to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that were loaded elsewhere, often for the purposes of restoring from a cache.\n\n    References: [#8862](https://www.sqlalchemy.org/trac/ticket/8862)\n\n*   **[orm] [bug]**\n\n    Fixed issues in [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression \"sqlalchemy.orm.with_expression\") where expressions that were composed of columns that were referenced from the enclosing SELECT would not render correct SQL in some contexts, in the case where the expression had a label name that matched the attribute which used [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\"), even when [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") had no default expression. For the moment, if the [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression \"sqlalchemy.orm.query_expression\") does have a default expression, that label name is still used for that default, and an additional label with the same name will continue to be ignored. Overall, this case is pretty thorny so further adjustments might be warranted.\n\n    References: [#8881](https://www.sqlalchemy.org/trac/ticket/8881)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where [`Result.freeze()`](../core/connections.html#sqlalchemy.engine.Result.freeze \"sqlalchemy.engine.Result.freeze\") method would not work for textual SQL using either [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\") or [`Connection.exec_driver_sql()`](../core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql \"sqlalchemy.engine.Connection.exec_driver_sql\").\n\n    References: [#8963](https://www.sqlalchemy.org/trac/ticket/8963)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    An informative re-raise is now thrown in the case where any \u201cliteral bindparam\u201d render operation fails, indicating the value itself and the datatype in use, to assist in debugging when literal params are being rendered in a statement.\n\n    References: [#8800](https://www.sqlalchemy.org/trac/ticket/8800)\n\n*   **[sql] [bug]**\n\n    Fixed a series of issues regarding the position and sometimes the identity of rendered bound parameters, such as those used for SQLite, asyncpg, MySQL, Oracle and others. Some compiled forms would not maintain the order of parameters correctly, such as the PostgreSQL `regexp_replace()` function, the \u201cnesting\u201d feature of the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE \"sqlalchemy.sql.expression.CTE\") construct first introduced in [#4123](https://www.sqlalchemy.org/trac/ticket/4123), and selectable tables formed by using the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") method with Oracle.\n\n    References: [#8827](https://www.sqlalchemy.org/trac/ticket/8827)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Removed non-functional `merge()` method from [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\"). This method has never worked and was included with [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\") in error.\n\n    References: [#8952](https://www.sqlalchemy.org/trac/ticket/8952)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Made an adjustment to how the PostgreSQL dialect considers column types when it reflects columns from a table, to accommodate for alternative backends which may return NULL from the PG `format_type()` function.\n\n    References: [#8748](https://www.sqlalchemy.org/trac/ticket/8748)\n\n### sqlite\n\n*   **[sqlite] [usecase]**\n\n    Added support for the SQLite backend to reflect the \u201cDEFERRABLE\u201d and \u201cINITIALLY\u201d keywords which may be present on a foreign key construct. Pull request courtesy Michael Gorven.\n\n    References: [#8903](https://www.sqlalchemy.org/trac/ticket/8903)\n\n*   **[sqlite] [usecase]**\n\n    Added support for reflection of expression-oriented WHERE criteria included in indexes on the SQLite dialect, in a manner similar to that of the PostgreSQL dialect. Pull request courtesy Tobias Pfeiffer.\n\n    References: [#8804](https://www.sqlalchemy.org/trac/ticket/8804)\n\n*   **[sqlite] [bug]**\n\n    Backported a fix for SQLite reflection of unique constraints in attached schemas, released in 2.0 as a small part of [#4379](https://www.sqlalchemy.org/trac/ticket/4379). Previously, unique constraints in attached schemas would be ignored by SQLite reflection. Pull request courtesy Michael Gorven.\n\n    References: [#8866](https://www.sqlalchemy.org/trac/ticket/8866)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Continued fixes for Oracle fix [#8708](https://www.sqlalchemy.org/trac/ticket/8708) released in 1.4.43 where bound parameter names that start with underscores, which are disallowed by Oracle, were still not being properly escaped in all circumstances.\n\n    References: [#8708](https://www.sqlalchemy.org/trac/ticket/8708)\n\n*   **[oracle] [bug]**\n\n    Fixed issue in Oracle compiler where the syntax for [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued \"sqlalchemy.sql.functions.FunctionElement.column_valued\") was incorrect, rendering the name `COLUMN_VALUE` without qualifying the source table correctly.\n\n    References: [#8945](https://www.sqlalchemy.org/trac/ticket/8945)\n\n## 1.4.44\n\nReleased: November 12, 2022\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed critical memory issue identified in cache key generation, where for very large and complex ORM statements that make use of lots of ORM aliases with subqueries, cache key generation could produce excessively large keys that were orders of magnitude bigger than the statement itself. Much thanks to Rollo Konig Brock for their very patient, long term help in finally identifying this issue.\n\n    References: [#8790](https://www.sqlalchemy.org/trac/ticket/8790)\n\n### postgresql\n\n*   **[postgresql] [bug] [mssql]**\n\n    For the PostgreSQL and SQL Server dialects only, adjusted the compiler so that when rendering column expressions in the RETURNING clause, the \u201cnon anon\u201d label that\u2019s used in SELECT statements is suggested for SQL expression elements that generate a label; the primary example is a SQL function that may be emitting as part of the column\u2019s type, where the label name should match the column\u2019s name by default. This restores a not-well defined behavior that had changed in version 1.4.21 due to [#6718](https://www.sqlalchemy.org/trac/ticket/6718), [#6710](https://www.sqlalchemy.org/trac/ticket/6710). The Oracle dialect has a different RETURNING implementation and was not affected by this issue. Version 2.0 features an across the board change for its widely expanded support of RETURNING on other backends.\n\n    References: [#8770](https://www.sqlalchemy.org/trac/ticket/8770)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed issue in the Oracle dialect where an INSERT statement that used `insert(some_table).values(...).returning(some_table)` against a full [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object at once would fail to execute, raising an exception.\n\n### tests\n\n*   **[tests] [bug]**\n\n    Fixed issue where the `--disable-asyncio` parameter to the test suite would fail to not actually run greenlet tests and would also not prevent the suite from using a \u201cwrapping\u201d greenlet for the whole suite. This parameter now ensures that no greenlet or asyncio use will occur within the entire run when set.\n\n    References: [#8793](https://www.sqlalchemy.org/trac/ticket/8793)\n\n*   **[tests] [bug]**\n\n    Adjusted the test suite which tests the Mypy plugin to accommodate for changes in Mypy 0.990 regarding how it handles message output, which affect how sys.path is interpreted when determining if notes and errors should be printed for particular files. The change broke the test suite as the files within the test directory itself no longer produced messaging when run under the mypy API.\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed critical memory issue identified in cache key generation, where for very large and complex ORM statements that make use of lots of ORM aliases with subqueries, cache key generation could produce excessively large keys that were orders of magnitude bigger than the statement itself. Much thanks to Rollo Konig Brock for their very patient, long term help in finally identifying this issue.\n\n    References: [#8790](https://www.sqlalchemy.org/trac/ticket/8790)\n\n### postgresql\n\n*   **[postgresql] [bug] [mssql]**\n\n    For the PostgreSQL and SQL Server dialects only, adjusted the compiler so that when rendering column expressions in the RETURNING clause, the \u201cnon anon\u201d label that\u2019s used in SELECT statements is suggested for SQL expression elements that generate a label; the primary example is a SQL function that may be emitting as part of the column\u2019s type, where the label name should match the column\u2019s name by default. This restores a not-well defined behavior that had changed in version 1.4.21 due to [#6718](https://www.sqlalchemy.org/trac/ticket/6718), [#6710](https://www.sqlalchemy.org/trac/ticket/6710). The Oracle dialect has a different RETURNING implementation and was not affected by this issue. Version 2.0 features an across the board change for its widely expanded support of RETURNING on other backends.\n\n    References: [#8770](https://www.sqlalchemy.org/trac/ticket/8770)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed issue in the Oracle dialect where an INSERT statement that used `insert(some_table).values(...).returning(some_table)` against a full [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") object at once would fail to execute, raising an exception.\n\n### tests\n\n*   **[tests] [bug]**\n\n    Fixed issue where the `--disable-asyncio` parameter to the test suite would fail to not actually run greenlet tests and would also not prevent the suite from using a \u201cwrapping\u201d greenlet for the whole suite. This parameter now ensures that no greenlet or asyncio use will occur within the entire run when set.\n\n    References: [#8793](https://www.sqlalchemy.org/trac/ticket/8793)\n\n*   **[tests] [bug]**\n\n    Adjusted the test suite which tests the Mypy plugin to accommodate for changes in Mypy 0.990 regarding how it handles message output, which affect how sys.path is interpreted when determining if notes and errors should be printed for particular files. The change broke the test suite as the files within the test directory itself no longer produced messaging when run under the mypy API.\n\n## 1.4.43\n\nReleased: November 4, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in joined eager loading where an assertion fail would occur with a particular combination of outer/inner joined eager loads, when eager loading across three mappers where the middle mapper was an inherited subclass mapper.\n\n    References: [#8738](https://www.sqlalchemy.org/trac/ticket/8738)\n\n*   **[orm] [bug]**\n\n    Fixed bug involving [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") constructs, where combinations of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from \"sqlalchemy.sql.expression.Select.select_from\") with [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\"), as well as when using [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from \"sqlalchemy.sql.expression.Select.join_from\"), would cause the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature as well as the IN criteria needed for single-table inheritance queries to not render, in cases where the columns clause of the query did not explicitly include the left-hand side entity of the JOIN. The correct entity is now transferred to the [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join \"sqlalchemy.sql.expression.Join\") object that\u2019s generated internally, so that the criteria against the left side entity is correctly added.\n\n    References: [#8721](https://www.sqlalchemy.org/trac/ticket/8721)\n\n*   **[orm] [bug]**\n\n    An informative exception is now raised when the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") option is used as a loader option added to a specific \u201cloader path\u201d, such as when using it within [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options \"sqlalchemy.orm.Load.options\"). This use is not supported as [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") is only intended to be used as a top level loader option. Previously, an internal error would be generated.\n\n    References: [#8711](https://www.sqlalchemy.org/trac/ticket/8711)\n\n*   **[orm] [bug]**\n\n    Improved \u201cdictionary mode\u201d for [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get \"sqlalchemy.orm.Session.get\") so that synonym names which refer to primary key attribute names may be indicated in the named dictionary.\n\n    References: [#8753](https://www.sqlalchemy.org/trac/ticket/8753)\n\n*   **[orm] [bug]**\n\n    Fixed issue where \u201cselectin_polymorphic\u201d loading for inheritance mappers would not function correctly if the [`Mapper.polymorphic_on`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on \"sqlalchemy.orm.Mapper\") parameter referred to a SQL expression that was not directly mapped on the class.\n\n    References: [#8704](https://www.sqlalchemy.org/trac/ticket/8704)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the underlying DBAPI cursor would not be closed when using the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object as an iterator, if a user-defined exception case were raised within the iteration process, thereby causing the iterator to be closed by the Python interpreter. When using [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per \"sqlalchemy.orm.Query.yield_per\") to create server-side cursors, this would lead to the usual MySQL-related issues with server side cursors out of sync, and without direct access to the [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object, end-user code could not access the cursor in order to close it.\n\n    To resolve, a catch for `GeneratorExit` is applied within the iterator method, which will close the result object in those cases when the iterator were interrupted, and by definition will be closed by the Python interpreter.\n\n    As part of this change as implemented for the 1.4 series, ensured that `.close()` methods are available on all [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") implementations including [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\"), [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\"). The 2.0 version of this change also includes new context manager patterns for use with [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") classes.\n\n    References: [#8710](https://www.sqlalchemy.org/trac/ticket/8710)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Fixed issue where the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset \"sqlalchemy.events.PoolEvents.reset\") event hook would not be be called in all cases when a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") were closed and was in the process of returning its DBAPI connection to the connection pool.\n\n    The scenario was when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") had already emitted `.rollback()` on its DBAPI connection within the process of returning the connection to the pool, where it would then instruct the connection pool to forego doing its own \u201creset\u201d to save on the additional method call. However, this prevented custom pool reset schemes from being used within this hook, as such hooks by definition are doing more than just calling `.rollback()`, and need to be invoked under all circumstances. This was a regression that appeared in version 1.4.\n\n    For version 1.4, the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin \"sqlalchemy.events.PoolEvents.checkin\") remains viable as an alternate event hook to use for custom \u201creset\u201d implementations. Version 2.0 will feature an improved version of [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset \"sqlalchemy.events.PoolEvents.reset\") which is called for additional scenarios such as termination of asyncio connections, and is also passed contextual information about the reset, to allow for \u201ccustom connection reset\u201d schemes which can respond to different reset scenarios in different ways.\n\n    References: [#8717](https://www.sqlalchemy.org/trac/ticket/8717)\n\n*   **[engine] [bug]**\n\n    Ensured all [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") objects include a [`Result.close()`](../core/connections.html#sqlalchemy.engine.Result.close \"sqlalchemy.engine.Result.close\") method as well as a [`Result.closed`](../core/connections.html#sqlalchemy.engine.Result.closed \"sqlalchemy.engine.Result.closed\") attribute, including on [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") and [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\").\n\n    References: [#8710](https://www.sqlalchemy.org/trac/ticket/8710)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue which prevented the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column \"sqlalchemy.sql.expression.literal_column\") construct from working properly within the context of a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") construct as well as other potential places where \u201canonymized labels\u201d might be generated, if the literal expression contained characters which could interfere with format strings, such as open parenthesis, due to an implementation detail of the \u201canonymous label\u201d structure.\n\n    References: [#8724](https://www.sqlalchemy.org/trac/ticket/8724)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed issue with [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\"), which when used against a temporary table with the SQL Server dialect would fail on some Azure variants, due to an unnecessary information schema query that is not supported on those server versions. Pull request courtesy Mike Barry.\n\n    References: [#8714](https://www.sqlalchemy.org/trac/ticket/8714)\n\n*   **[mssql] [bug] [reflection]**\n\n    Fixed issue with [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\"), which when used against a view with the SQL Server dialect would erroneously return `False`, due to a regression in the 1.4 series which removed support for this on SQL Server. The issue is not present in the 2.0 series which uses a different reflection architecture. Test support is added to ensure `has_table()` remains working per spec re: views.\n\n    References: [#8700](https://www.sqlalchemy.org/trac/ticket/8700)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed issue where bound parameter names, including those automatically derived from similarly-named database columns, which contained characters that normally require quoting with Oracle would not be escaped when using \u201cexpanding parameters\u201d with the Oracle dialect, causing execution errors. The usual \u201cquoting\u201d for bound parameters used by the Oracle dialect is not used with the \u201cexpanding parameters\u201d architecture, so escaping for a large range of characters is used instead, now using a list of characters/escapes that are specific to Oracle.\n\n    References: [#8708](https://www.sqlalchemy.org/trac/ticket/8708)\n\n*   **[oracle] [bug]**\n\n    Fixed issue where the `nls_session_parameters` view queried on first connect in order to get the default decimal point character may not be available depending on Oracle connection modes, and would therefore raise an error. The approach to detecting decimal char has been simplified to test a decimal value directly, instead of reading system views, which works on any backend / driver.\n\n    References: [#8744](https://www.sqlalchemy.org/trac/ticket/8744)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue in joined eager loading where an assertion fail would occur with a particular combination of outer/inner joined eager loads, when eager loading across three mappers where the middle mapper was an inherited subclass mapper.\n\n    References: [#8738](https://www.sqlalchemy.org/trac/ticket/8738)\n\n*   **[orm] [bug]**\n\n    Fixed bug involving [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") constructs, where combinations of [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from \"sqlalchemy.sql.expression.Select.select_from\") with [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join \"sqlalchemy.sql.expression.Select.join\"), as well as when using [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from \"sqlalchemy.sql.expression.Select.join_from\"), would cause the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") feature as well as the IN criteria needed for single-table inheritance queries to not render, in cases where the columns clause of the query did not explicitly include the left-hand side entity of the JOIN. The correct entity is now transferred to the [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join \"sqlalchemy.sql.expression.Join\") object that\u2019s generated internally, so that the criteria against the left side entity is correctly added.\n\n    References: [#8721](https://www.sqlalchemy.org/trac/ticket/8721)\n\n*   **[orm] [bug]**\n\n    An informative exception is now raised when the [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") option is used as a loader option added to a specific \u201cloader path\u201d, such as when using it within [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options \"sqlalchemy.orm.Load.options\"). This use is not supported as [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") is only intended to be used as a top level loader option. Previously, an internal error would be generated.\n\n    References: [#8711](https://www.sqlalchemy.org/trac/ticket/8711)\n\n*   **[orm] [bug]**\n\n    Improved \u201cdictionary mode\u201d for [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get \"sqlalchemy.orm.Session.get\") so that synonym names which refer to primary key attribute names may be indicated in the named dictionary.\n\n    References: [#8753](https://www.sqlalchemy.org/trac/ticket/8753)\n\n*   **[orm] [bug]**\n\n    Fixed issue where \u201cselectin_polymorphic\u201d loading for inheritance mappers would not function correctly if the [`Mapper.polymorphic_on`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on \"sqlalchemy.orm.Mapper\") parameter referred to a SQL expression that was not directly mapped on the class.\n\n    References: [#8704](https://www.sqlalchemy.org/trac/ticket/8704)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the underlying DBAPI cursor would not be closed when using the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query \"sqlalchemy.orm.Query\") object as an iterator, if a user-defined exception case were raised within the iteration process, thereby causing the iterator to be closed by the Python interpreter. When using [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per \"sqlalchemy.orm.Query.yield_per\") to create server-side cursors, this would lead to the usual MySQL-related issues with server side cursors out of sync, and without direct access to the [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object, end-user code could not access the cursor in order to close it.\n\n    To resolve, a catch for `GeneratorExit` is applied within the iterator method, which will close the result object in those cases when the iterator were interrupted, and by definition will be closed by the Python interpreter.\n\n    As part of this change as implemented for the 1.4 series, ensured that `.close()` methods are available on all [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") implementations including [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\"), [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\"). The 2.0 version of this change also includes new context manager patterns for use with [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") classes.\n\n    References: [#8710](https://www.sqlalchemy.org/trac/ticket/8710)\n\n### engine\n\n*   **[engine] [bug] [regression]**\n\n    Fixed issue where the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset \"sqlalchemy.events.PoolEvents.reset\") event hook would not be be called in all cases when a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") were closed and was in the process of returning its DBAPI connection to the connection pool.\n\n    The scenario was when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") had already emitted `.rollback()` on its DBAPI connection within the process of returning the connection to the pool, where it would then instruct the connection pool to forego doing its own \u201creset\u201d to save on the additional method call. However, this prevented custom pool reset schemes from being used within this hook, as such hooks by definition are doing more than just calling `.rollback()`, and need to be invoked under all circumstances. This was a regression that appeared in version 1.4.\n\n    For version 1.4, the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin \"sqlalchemy.events.PoolEvents.checkin\") remains viable as an alternate event hook to use for custom \u201creset\u201d implementations. Version 2.0 will feature an improved version of [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset \"sqlalchemy.events.PoolEvents.reset\") which is called for additional scenarios such as termination of asyncio connections, and is also passed contextual information about the reset, to allow for \u201ccustom connection reset\u201d schemes which can respond to different reset scenarios in different ways.\n\n    References: [#8717](https://www.sqlalchemy.org/trac/ticket/8717)\n\n*   **[engine] [bug]**\n\n    Ensured all [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") objects include a [`Result.close()`](../core/connections.html#sqlalchemy.engine.Result.close \"sqlalchemy.engine.Result.close\") method as well as a [`Result.closed`](../core/connections.html#sqlalchemy.engine.Result.closed \"sqlalchemy.engine.Result.closed\") attribute, including on [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") and [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\").\n\n    References: [#8710](https://www.sqlalchemy.org/trac/ticket/8710)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue which prevented the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column \"sqlalchemy.sql.expression.literal_column\") construct from working properly within the context of a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") construct as well as other potential places where \u201canonymized labels\u201d might be generated, if the literal expression contained characters which could interfere with format strings, such as open parenthesis, due to an implementation detail of the \u201canonymous label\u201d structure.\n\n    References: [#8724](https://www.sqlalchemy.org/trac/ticket/8724)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed issue with [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\"), which when used against a temporary table with the SQL Server dialect would fail on some Azure variants, due to an unnecessary information schema query that is not supported on those server versions. Pull request courtesy Mike Barry.\n\n    References: [#8714](https://www.sqlalchemy.org/trac/ticket/8714)\n\n*   **[mssql] [bug] [reflection]**\n\n    Fixed issue with [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table \"sqlalchemy.engine.reflection.Inspector.has_table\"), which when used against a view with the SQL Server dialect would erroneously return `False`, due to a regression in the 1.4 series which removed support for this on SQL Server. The issue is not present in the 2.0 series which uses a different reflection architecture. Test support is added to ensure `has_table()` remains working per spec re: views.\n\n    References: [#8700](https://www.sqlalchemy.org/trac/ticket/8700)\n\n### oracle\n\n*   **[oracle] [bug]**\n\n    Fixed issue where bound parameter names, including those automatically derived from similarly-named database columns, which contained characters that normally require quoting with Oracle would not be escaped when using \u201cexpanding parameters\u201d with the Oracle dialect, causing execution errors. The usual \u201cquoting\u201d for bound parameters used by the Oracle dialect is not used with the \u201cexpanding parameters\u201d architecture, so escaping for a large range of characters is used instead, now using a list of characters/escapes that are specific to Oracle.\n\n    References: [#8708](https://www.sqlalchemy.org/trac/ticket/8708)\n\n*   **[oracle] [bug]**\n\n    Fixed issue where the `nls_session_parameters` view queried on first connect in order to get the default decimal point character may not be available depending on Oracle connection modes, and would therefore raise an error. The approach to detecting decimal char has been simplified to test a decimal value directly, instead of reading system views, which works on any backend / driver.\n\n    References: [#8744](https://www.sqlalchemy.org/trac/ticket/8744)\n\n## 1.4.42\n\nReleased: October 16, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    The [`Session.execute.bind_arguments`](../orm/session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments \"sqlalchemy.orm.Session.execute\") dictionary is no longer mutated when passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") and similar; instead, it\u2019s copied to an internal dictionary for state changes. Among other things, this fixes and issue where the \u201cclause\u201d passed to the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind \"sqlalchemy.orm.Session.get_bind\") method would be incorrectly referring to the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") construct used for the \u201cfetch\u201d synchronization strategy, when the actual query being emitted was a [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"). This would interfere with recipes for \u201crouting sessions\u201d.\n\n    References: [#8614](https://www.sqlalchemy.org/trac/ticket/8614)\n\n*   **[orm] [bug]**\n\n    A warning is emitted in ORM configurations when an explicit [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote \"sqlalchemy.orm.remote\") annotation is applied to columns that are local to the immediate mapped class, when the referenced class does not include any of the same table columns. Ideally this would raise an error at some point as it\u2019s not correct from a mapping point of view.\n\n    References: [#7094](https://www.sqlalchemy.org/trac/ticket/7094)\n\n*   **[orm] [bug]**\n\n    A warning is emitted when attempting to configure a mapped class within an inheritance hierarchy where the mapper is not given any polymorphic identity, however there is a polymorphic discriminator column assigned. Such classes should be abstract if they never intend to load directly.\n\n    References: [#7545](https://www.sqlalchemy.org/trac/ticket/7545)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression for 1.4 in [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") where the \u201cwrap in subquery\u201d logic of [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") would be inadvertently triggered for use of the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") function with similar statements (e.g. those that use `distinct()`, `limit()` or `offset()`), which would then lead to secondary issues with queries that used some combinations of SQL label names and aliasing. This \u201cwrapping\u201d is not appropriate for [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") which has always had the contract that the user-defined SQL statement is unmodified with the exception of adding the appropriate columns to be fetched.\n\n    References: [#8569](https://www.sqlalchemy.org/trac/ticket/8569)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where using ORM update() with synchronize_session=\u2019fetch\u2019 would fail due to the use of evaluators that are now used to determine the in-Python value for expressions in the SET clause when refreshing objects; if the evaluators make use of math operators against non-numeric values such as PostgreSQL JSONB, the non-evaluable condition would fail to be detected correctly. The evaluator now limits the use of math mutation operators to numeric types only, with the exception of \u201c+\u201d that continues to work for strings as well. SQLAlchemy 2.0 may alter this further by fetching the SET values completely rather than using evaluation.\n\n    References: [#8507](https://www.sqlalchemy.org/trac/ticket/8507)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where mixing \u201c*\u201d with additional explicitly-named column expressions within the columns clause of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct would cause result-column targeting to sometimes consider the label name or other non-repeated names to be an ambiguous target.\n\n    References: [#8536](https://www.sqlalchemy.org/trac/ticket/8536)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Improved implementation of `asyncio.shield()` used in context managers as added in [#8145](https://www.sqlalchemy.org/trac/ticket/8145), such that the \u201cclose\u201d operation is enclosed within an `asyncio.Task` which is then strongly referenced as the operation proceeds. This is per Python documentation indicating that the task is otherwise not strongly referenced.\n\n    References: [#8516](https://www.sqlalchemy.org/trac/ticket/8516)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by \"sqlalchemy.dialects.postgresql.aggregate_order_by\") now supports cache generation.\n\n    References: [#8574](https://www.sqlalchemy.org/trac/ticket/8574)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Adjusted the regular expression used to match \u201cCREATE VIEW\u201d when testing for views to work more flexibly, no longer requiring the special keyword \u201cALGORITHM\u201d in the middle, which was intended to be optional but was not working correctly. The change allows view reflection to work more completely on MySQL-compatible variants such as StarRocks. Pull request courtesy John Bodley.\n\n    References: [#8588](https://www.sqlalchemy.org/trac/ticket/8588)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed yet another regression in SQL Server isolation level fetch (see [#8231](https://www.sqlalchemy.org/trac/ticket/8231), [#8475](https://www.sqlalchemy.org/trac/ticket/8475)), this time with \u201cMicrosoft Dynamics CRM Database via Azure Active Directory\u201d, which apparently lacks the `system_views` view entirely. Error catching has been extended that under no circumstances will this method ever fail, provided database connectivity is present.\n\n    References: [#8525](https://www.sqlalchemy.org/trac/ticket/8525)\n\n### orm\n\n*   **[orm] [bug]**\n\n    The [`Session.execute.bind_arguments`](../orm/session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments \"sqlalchemy.orm.Session.execute\") dictionary is no longer mutated when passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") and similar; instead, it\u2019s copied to an internal dictionary for state changes. Among other things, this fixes and issue where the \u201cclause\u201d passed to the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind \"sqlalchemy.orm.Session.get_bind\") method would be incorrectly referring to the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select \"sqlalchemy.sql.expression.Select\") construct used for the \u201cfetch\u201d synchronization strategy, when the actual query being emitted was a [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"). This would interfere with recipes for \u201crouting sessions\u201d.\n\n    References: [#8614](https://www.sqlalchemy.org/trac/ticket/8614)\n\n*   **[orm] [bug]**\n\n    A warning is emitted in ORM configurations when an explicit [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote \"sqlalchemy.orm.remote\") annotation is applied to columns that are local to the immediate mapped class, when the referenced class does not include any of the same table columns. Ideally this would raise an error at some point as it\u2019s not correct from a mapping point of view.\n\n    References: [#7094](https://www.sqlalchemy.org/trac/ticket/7094)\n\n*   **[orm] [bug]**\n\n    A warning is emitted when attempting to configure a mapped class within an inheritance hierarchy where the mapper is not given any polymorphic identity, however there is a polymorphic discriminator column assigned. Such classes should be abstract if they never intend to load directly.\n\n    References: [#7545](https://www.sqlalchemy.org/trac/ticket/7545)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression for 1.4 in [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") where the \u201cwrap in subquery\u201d logic of [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload \"sqlalchemy.orm.joinedload\") would be inadvertently triggered for use of the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") function with similar statements (e.g. those that use `distinct()`, `limit()` or `offset()`), which would then lead to secondary issues with queries that used some combinations of SQL label names and aliasing. This \u201cwrapping\u201d is not appropriate for [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager \"sqlalchemy.orm.contains_eager\") which has always had the contract that the user-defined SQL statement is unmodified with the exception of adding the appropriate columns to be fetched.\n\n    References: [#8569](https://www.sqlalchemy.org/trac/ticket/8569)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where using ORM update() with synchronize_session=\u2019fetch\u2019 would fail due to the use of evaluators that are now used to determine the in-Python value for expressions in the SET clause when refreshing objects; if the evaluators make use of math operators against non-numeric values such as PostgreSQL JSONB, the non-evaluable condition would fail to be detected correctly. The evaluator now limits the use of math mutation operators to numeric types only, with the exception of \u201c+\u201d that continues to work for strings as well. SQLAlchemy 2.0 may alter this further by fetching the SET values completely rather than using evaluation.\n\n    References: [#8507](https://www.sqlalchemy.org/trac/ticket/8507)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed issue where mixing \u201c*\u201d with additional explicitly-named column expressions within the columns clause of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct would cause result-column targeting to sometimes consider the label name or other non-repeated names to be an ambiguous target.\n\n    References: [#8536](https://www.sqlalchemy.org/trac/ticket/8536)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Improved implementation of `asyncio.shield()` used in context managers as added in [#8145](https://www.sqlalchemy.org/trac/ticket/8145), such that the \u201cclose\u201d operation is enclosed within an `asyncio.Task` which is then strongly referenced as the operation proceeds. This is per Python documentation indicating that the task is otherwise not strongly referenced.\n\n    References: [#8516](https://www.sqlalchemy.org/trac/ticket/8516)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by \"sqlalchemy.dialects.postgresql.aggregate_order_by\") now supports cache generation.\n\n    References: [#8574](https://www.sqlalchemy.org/trac/ticket/8574)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Adjusted the regular expression used to match \u201cCREATE VIEW\u201d when testing for views to work more flexibly, no longer requiring the special keyword \u201cALGORITHM\u201d in the middle, which was intended to be optional but was not working correctly. The change allows view reflection to work more completely on MySQL-compatible variants such as StarRocks. Pull request courtesy John Bodley.\n\n    References: [#8588](https://www.sqlalchemy.org/trac/ticket/8588)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed yet another regression in SQL Server isolation level fetch (see [#8231](https://www.sqlalchemy.org/trac/ticket/8231), [#8475](https://www.sqlalchemy.org/trac/ticket/8475)), this time with \u201cMicrosoft Dynamics CRM Database via Azure Active Directory\u201d, which apparently lacks the `system_views` view entirely. Error catching has been extended that under no circumstances will this method ever fail, provided database connectivity is present.\n\n    References: [#8525](https://www.sqlalchemy.org/trac/ticket/8525)\n\n## 1.4.41\n\nReleased: September 6, 2022\n\n### orm\n\n*   **[orm] [bug] [events]**\n\n    Fixed event listening issue where event listeners added to a superclass would be lost if a subclass were created which then had its own listeners associated. The practical example is that of the [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker \"sqlalchemy.orm.sessionmaker\") class created after events have been associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") class.\n\n    References: [#8467](https://www.sqlalchemy.org/trac/ticket/8467)\n\n*   **[orm] [bug]**\n\n    Hardened the cache key strategy for the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") constructs. While no issue involving actual statements being cached can easily be demonstrated (if at all), these two constructs were not including enough of what makes them unique in their cache keys for caching on the aliased construct alone to be accurate.\n\n    References: [#8401](https://www.sqlalchemy.org/trac/ticket/8401)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression appearing in the 1.4 series where a joined-inheritance query placed as a subquery within an enclosing query for that same entity would fail to render the JOIN correctly for the inner query. The issue manifested in two different ways prior and subsequent to version 1.4.18 (related issue [#6595](https://www.sqlalchemy.org/trac/ticket/6595)), in one case rendering JOIN twice, in the other losing the JOIN entirely. To resolve, the conditions under which \u201cpolymorphic loading\u201d are applied have been scaled back to not be invoked for simple joined inheritance queries.\n\n    References: [#8456](https://www.sqlalchemy.org/trac/ticket/8456)\n\n*   **[orm] [bug]**\n\n    Fixed issue in [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable \"sqlalchemy.ext.mutable\") extension where collection links to the parent object would be lost if the object were merged with [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") while also passing [`Session.merge.load`](../orm/session_api.html#sqlalchemy.orm.Session.merge.params.load \"sqlalchemy.orm.Session.merge\") as False.\n\n    References: [#8446](https://www.sqlalchemy.org/trac/ticket/8446)\n\n*   **[orm] [bug]**\n\n    Fixed issue involving [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") where a closure variable used as bound parameter value within the lambda would not carry forward correctly into additional relationship loaders such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") and [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload \"sqlalchemy.orm.lazyload\") after the statement were cached, using the stale originally-cached value instead.\n\n    References: [#8399](https://www.sqlalchemy.org/trac/ticket/8399)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where use of the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table \"sqlalchemy.sql.expression.table\") construct, passing a string for the [`table.schema`](../core/selectable.html#sqlalchemy.sql.expression.table.params.schema \"sqlalchemy.sql.expression.table\") parameter, would fail to take the \u201cschema\u201d string into account when producing a cache key, thus leading to caching collisions if multiple, same-named [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table \"sqlalchemy.sql.expression.table\") constructs with different schemas were used.\n\n    References: [#8441](https://www.sqlalchemy.org/trac/ticket/8441)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Integrated support for asyncpg\u2019s `terminate()` method call for cases where the connection pool is recycling a possibly timed-out connection, where a connection is being garbage collected that wasn\u2019t gracefully closed, as well as when the connection has been invalidated. This allows asyncpg to abandon the connection without waiting for a response that may incur long timeouts.\n\n    References: [#8419](https://www.sqlalchemy.org/trac/ticket/8419)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression caused by the fix for [#8231](https://www.sqlalchemy.org/trac/ticket/8231) released in 1.4.40 where connection would fail if the user did not have permission to query the `dm_exec_sessions` or `dm_pdw_nodes_exec_sessions` system views when trying to determine the current transaction isolation level.\n\n    References: [#8475](https://www.sqlalchemy.org/trac/ticket/8475)\n\n### orm\n\n*   **[orm] [bug] [events]**\n\n    Fixed event listening issue where event listeners added to a superclass would be lost if a subclass were created which then had its own listeners associated. The practical example is that of the [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker \"sqlalchemy.orm.sessionmaker\") class created after events have been associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") class.\n\n    References: [#8467](https://www.sqlalchemy.org/trac/ticket/8467)\n\n*   **[orm] [bug]**\n\n    Hardened the cache key strategy for the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased \"sqlalchemy.orm.aliased\") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") constructs. While no issue involving actual statements being cached can easily be demonstrated (if at all), these two constructs were not including enough of what makes them unique in their cache keys for caching on the aliased construct alone to be accurate.\n\n    References: [#8401](https://www.sqlalchemy.org/trac/ticket/8401)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression appearing in the 1.4 series where a joined-inheritance query placed as a subquery within an enclosing query for that same entity would fail to render the JOIN correctly for the inner query. The issue manifested in two different ways prior and subsequent to version 1.4.18 (related issue [#6595](https://www.sqlalchemy.org/trac/ticket/6595)), in one case rendering JOIN twice, in the other losing the JOIN entirely. To resolve, the conditions under which \u201cpolymorphic loading\u201d are applied have been scaled back to not be invoked for simple joined inheritance queries.\n\n    References: [#8456](https://www.sqlalchemy.org/trac/ticket/8456)\n\n*   **[orm] [bug]**\n\n    Fixed issue in [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable \"sqlalchemy.ext.mutable\") extension where collection links to the parent object would be lost if the object were merged with [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge \"sqlalchemy.orm.Session.merge\") while also passing [`Session.merge.load`](../orm/session_api.html#sqlalchemy.orm.Session.merge.params.load \"sqlalchemy.orm.Session.merge\") as False.\n\n    References: [#8446](https://www.sqlalchemy.org/trac/ticket/8446)\n\n*   **[orm] [bug]**\n\n    Fixed issue involving [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") where a closure variable used as bound parameter value within the lambda would not carry forward correctly into additional relationship loaders such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload \"sqlalchemy.orm.selectinload\") and [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload \"sqlalchemy.orm.lazyload\") after the statement were cached, using the stale originally-cached value instead.\n\n    References: [#8399](https://www.sqlalchemy.org/trac/ticket/8399)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed issue where use of the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table \"sqlalchemy.sql.expression.table\") construct, passing a string for the [`table.schema`](../core/selectable.html#sqlalchemy.sql.expression.table.params.schema \"sqlalchemy.sql.expression.table\") parameter, would fail to take the \u201cschema\u201d string into account when producing a cache key, thus leading to caching collisions if multiple, same-named [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table \"sqlalchemy.sql.expression.table\") constructs with different schemas were used.\n\n    References: [#8441](https://www.sqlalchemy.org/trac/ticket/8441)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Integrated support for asyncpg\u2019s `terminate()` method call for cases where the connection pool is recycling a possibly timed-out connection, where a connection is being garbage collected that wasn\u2019t gracefully closed, as well as when the connection has been invalidated. This allows asyncpg to abandon the connection without waiting for a response that may incur long timeouts.\n\n    References: [#8419](https://www.sqlalchemy.org/trac/ticket/8419)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression caused by the fix for [#8231](https://www.sqlalchemy.org/trac/ticket/8231) released in 1.4.40 where connection would fail if the user did not have permission to query the `dm_exec_sessions` or `dm_pdw_nodes_exec_sessions` system views when trying to determine the current transaction isolation level.\n\n    References: [#8475](https://www.sqlalchemy.org/trac/ticket/8475)\n\n## 1.4.40\n\nReleased: August 8, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue where referencing a CTE multiple times in conjunction with a polymorphic SELECT could result in multiple \u201cclones\u201d of the same CTE being constructed, which would then trigger these two CTEs as duplicates. To resolve, the two CTEs are deep-compared when this occurs to ensure that they are equivalent, then are treated as equivalent.\n\n    References: [#8357](https://www.sqlalchemy.org/trac/ticket/8357)\n\n*   **[orm] [bug]**\n\n    A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct that is passed a sole \u2018*\u2019 argument for `SELECT *`, either via string, [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\"), or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column \"sqlalchemy.sql.expression.literal_column\"), will be interpreted as a Core-level SQL statement rather than as an ORM level statement. This is so that the `*`, when expanded to match any number of columns, will result in all columns returned in the result. the ORM- level interpretation of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") needs to know the names and types of all ORM columns up front which can\u2019t be achieved when `'*'` is used.\n\n    If `'*` is used amongst other expressions simultaneously with an ORM statement, an error is raised as this can\u2019t be interpreted correctly by the ORM.\n\n    References: [#8235](https://www.sqlalchemy.org/trac/ticket/8235)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug]**\n\n    Fixed issue where a hierarchy of classes set up as an abstract or mixin declarative classes could not declare standalone columns on a superclass that would then be copied correctly to a [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") callable that wanted to make use of them on a descendant class.\n\n    References: [#8190](https://www.sqlalchemy.org/trac/ticket/8190)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Implemented new [`Connection.execution_options.yield_per`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.yield_per \"sqlalchemy.engine.Connection.execution_options\") execution option for [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") in Core, to mirror that of the same [yield_per](../orm/queryguide/api.html#orm-queryguide-yield-per) option available in the ORM. The option sets both the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") option at the same time as invoking [`Result.yield_per()`](../core/connections.html#sqlalchemy.engine.Result.yield_per \"sqlalchemy.engine.Result.yield_per\"), to provide the most common streaming result configuration which also mirrors that of the ORM use case in its usage pattern.\n\n    See also\n\n    [Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results) - revised documentation\n\n*   **[engine] [bug]**\n\n    Fixed bug in [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") where the usage of a buffered result strategy would not be used if the dialect in use did not support an explicit \u201cserver side cursor\u201d setting, when using [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\"). This is in error as DBAPIs such as that of SQLite and Oracle already use a non-buffered result fetching scheme, which still benefits from usage of partial result fetching. The \u201cbuffered\u201d strategy is now used in all cases where [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") is set.\n\n*   **[engine] [bug]**\n\n    Added [`FilterResult.yield_per()`](../core/connections.html#sqlalchemy.engine.FilterResult.yield_per \"sqlalchemy.engine.FilterResult.yield_per\") so that result implementations such as [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\"), [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") and [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\") have access to this method.\n\n    References: [#8199](https://www.sqlalchemy.org/trac/ticket/8199)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Adjusted the SQL compilation for string containment functions `.contains()`, `.startswith()`, `.endswith()` to force the use of the string concatenation operator, rather than relying upon the overload of the addition operator, so that non-standard use of these operators with for example bytestrings still produces string concatenation operators.\n\n    References: [#8253](https://www.sqlalchemy.org/trac/ticket/8253)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed a crash of the mypy plugin when using a lambda as a Column default. Pull request courtesy of tchapi.\n\n    References: [#8196](https://www.sqlalchemy.org/trac/ticket/8196)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Added `asyncio.shield()` to the connection and session release process specifically within the `__aexit__()` context manager exit, when using [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection \"sqlalchemy.ext.asyncio.AsyncConnection\") or [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") as a context manager that releases the object when the context manager is complete. This appears to help with task cancellation when using alternate concurrency libraries such as `anyio`, `uvloop` that otherwise don\u2019t provide an async context for the connection pool to release the connection properly during task cancellation.\n\n    References: [#8145](https://www.sqlalchemy.org/trac/ticket/8145)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed issue in psycopg2 dialect where the \u201cmultiple hosts\u201d feature implemented for [#4392](https://www.sqlalchemy.org/trac/ticket/4392), where multiple `host:port` pairs could be passed in the query string as `?host=host1:port1&host=host2:port2&host=host3:port3` was not implemented correctly, as it did not propagate the \u201cport\u201d parameter appropriately. Connections that didn\u2019t use a different \u201cport\u201d likely worked without issue, and connections that had \u201cport\u201d for some of the entries may have incorrectly passed on that hostname. The format is now corrected to pass hosts/ports appropriately.\n\n    As part of this change, maintained support for another multihost style that worked unintentionally, which is comma-separated `?host=h1,h2,h3&port=p1,p2,p3`. This format is more consistent with libpq\u2019s query-string format, whereas the previous format is inspired by a different aspect of libpq\u2019s URI format but is not quite the same thing.\n\n    If the two styles are mixed together, an error is raised as this is ambiguous.\n\n    References: [#4392](https://www.sqlalchemy.org/trac/ticket/4392)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed issues that prevented the new usage patterns for using DML with ORM objects presented at [Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM Objects](../orm/persistence_techniques.html#orm-dml-returning-objects) from working correctly with the SQL Server pyodbc dialect.\n\n    References: [#8210](https://www.sqlalchemy.org/trac/ticket/8210)\n\n*   **[mssql] [bug]**\n\n    Fixed issue where the SQL Server dialect\u2019s query for the current isolation level would fail on Azure Synapse Analytics, due to the way in which this database handles transaction rollbacks after an error has occurred. The initial query has been modified to no longer rely upon catching an error when attempting to detect the appropriate system view. Additionally, to better support this database\u2019s very specific \u201crollback\u201d behavior, implemented new parameter `ignore_no_transaction_on_rollback` indicating that a rollback should ignore Azure Synapse error \u2018No corresponding transaction found. (111214)\u2019, which is raised if no transaction is present in conflict with the Python DBAPI.\n\n    Initial patch and valuable debugging assistance courtesy of @ww2406.\n\n    See also\n\n    [Avoiding transaction-related exceptions on Azure Synapse Analytics](../dialects/mssql.html#azure-synapse-ignore-no-transaction-on-rollback)\n\n    References: [#8231](https://www.sqlalchemy.org/trac/ticket/8231)\n\n### misc\n\n*   **[bug] [types]**\n\n    Fixed issue where [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\") would not correctly proxy the `__getitem__()` operator when decorating the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") datatype, without explicit workarounds.\n\n    References: [#7249](https://www.sqlalchemy.org/trac/ticket/7249)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue where referencing a CTE multiple times in conjunction with a polymorphic SELECT could result in multiple \u201cclones\u201d of the same CTE being constructed, which would then trigger these two CTEs as duplicates. To resolve, the two CTEs are deep-compared when this occurs to ensure that they are equivalent, then are treated as equivalent.\n\n    References: [#8357](https://www.sqlalchemy.org/trac/ticket/8357)\n\n*   **[orm] [bug]**\n\n    A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") construct that is passed a sole \u2018*\u2019 argument for `SELECT *`, either via string, [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text \"sqlalchemy.sql.expression.text\"), or [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column \"sqlalchemy.sql.expression.literal_column\"), will be interpreted as a Core-level SQL statement rather than as an ORM level statement. This is so that the `*`, when expanded to match any number of columns, will result in all columns returned in the result. the ORM- level interpretation of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select \"sqlalchemy.sql.expression.select\") needs to know the names and types of all ORM columns up front which can\u2019t be achieved when `'*'` is used.\n\n    If `'*` is used amongst other expressions simultaneously with an ORM statement, an error is raised as this can\u2019t be interpreted correctly by the ORM.\n\n    References: [#8235](https://www.sqlalchemy.org/trac/ticket/8235)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug]**\n\n    Fixed issue where a hierarchy of classes set up as an abstract or mixin declarative classes could not declare standalone columns on a superclass that would then be copied correctly to a [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr \"sqlalchemy.orm.declared_attr\") callable that wanted to make use of them on a descendant class.\n\n    References: [#8190](https://www.sqlalchemy.org/trac/ticket/8190)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Implemented new [`Connection.execution_options.yield_per`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.yield_per \"sqlalchemy.engine.Connection.execution_options\") execution option for [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") in Core, to mirror that of the same [yield_per](../orm/queryguide/api.html#orm-queryguide-yield-per) option available in the ORM. The option sets both the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") option at the same time as invoking [`Result.yield_per()`](../core/connections.html#sqlalchemy.engine.Result.yield_per \"sqlalchemy.engine.Result.yield_per\"), to provide the most common streaming result configuration which also mirrors that of the ORM use case in its usage pattern.\n\n    See also\n\n    [Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results) - revised documentation\n\n*   **[engine] [bug]**\n\n    Fixed bug in [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") where the usage of a buffered result strategy would not be used if the dialect in use did not support an explicit \u201cserver side cursor\u201d setting, when using [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\"). This is in error as DBAPIs such as that of SQLite and Oracle already use a non-buffered result fetching scheme, which still benefits from usage of partial result fetching. The \u201cbuffered\u201d strategy is now used in all cases where [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") is set.\n\n*   **[engine] [bug]**\n\n    Added [`FilterResult.yield_per()`](../core/connections.html#sqlalchemy.engine.FilterResult.yield_per \"sqlalchemy.engine.FilterResult.yield_per\") so that result implementations such as [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult \"sqlalchemy.engine.MappingResult\"), [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") and [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult \"sqlalchemy.ext.asyncio.AsyncResult\") have access to this method.\n\n    References: [#8199](https://www.sqlalchemy.org/trac/ticket/8199)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Adjusted the SQL compilation for string containment functions `.contains()`, `.startswith()`, `.endswith()` to force the use of the string concatenation operator, rather than relying upon the overload of the addition operator, so that non-standard use of these operators with for example bytestrings still produces string concatenation operators.\n\n    References: [#8253](https://www.sqlalchemy.org/trac/ticket/8253)\n\n### mypy\n\n*   **[mypy] [bug]**\n\n    Fixed a crash of the mypy plugin when using a lambda as a Column default. Pull request courtesy of tchapi.\n\n    References: [#8196](https://www.sqlalchemy.org/trac/ticket/8196)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Added `asyncio.shield()` to the connection and session release process specifically within the `__aexit__()` context manager exit, when using [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection \"sqlalchemy.ext.asyncio.AsyncConnection\") or [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession \"sqlalchemy.ext.asyncio.AsyncSession\") as a context manager that releases the object when the context manager is complete. This appears to help with task cancellation when using alternate concurrency libraries such as `anyio`, `uvloop` that otherwise don\u2019t provide an async context for the connection pool to release the connection properly during task cancellation.\n\n    References: [#8145](https://www.sqlalchemy.org/trac/ticket/8145)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed issue in psycopg2 dialect where the \u201cmultiple hosts\u201d feature implemented for [#4392](https://www.sqlalchemy.org/trac/ticket/4392), where multiple `host:port` pairs could be passed in the query string as `?host=host1:port1&host=host2:port2&host=host3:port3` was not implemented correctly, as it did not propagate the \u201cport\u201d parameter appropriately. Connections that didn\u2019t use a different \u201cport\u201d likely worked without issue, and connections that had \u201cport\u201d for some of the entries may have incorrectly passed on that hostname. The format is now corrected to pass hosts/ports appropriately.\n\n    As part of this change, maintained support for another multihost style that worked unintentionally, which is comma-separated `?host=h1,h2,h3&port=p1,p2,p3`. This format is more consistent with libpq\u2019s query-string format, whereas the previous format is inspired by a different aspect of libpq\u2019s URI format but is not quite the same thing.\n\n    If the two styles are mixed together, an error is raised as this is ambiguous.\n\n    References: [#4392](https://www.sqlalchemy.org/trac/ticket/4392)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fixed issues that prevented the new usage patterns for using DML with ORM objects presented at [Using INSERT, UPDATE and ON CONFLICT (i.e. upsert) to return ORM Objects](../orm/persistence_techniques.html#orm-dml-returning-objects) from working correctly with the SQL Server pyodbc dialect.\n\n    References: [#8210](https://www.sqlalchemy.org/trac/ticket/8210)\n\n*   **[mssql] [bug]**\n\n    Fixed issue where the SQL Server dialect\u2019s query for the current isolation level would fail on Azure Synapse Analytics, due to the way in which this database handles transaction rollbacks after an error has occurred. The initial query has been modified to no longer rely upon catching an error when attempting to detect the appropriate system view. Additionally, to better support this database\u2019s very specific \u201crollback\u201d behavior, implemented new parameter `ignore_no_transaction_on_rollback` indicating that a rollback should ignore Azure Synapse error \u2018No corresponding transaction found. (111214)\u2019, which is raised if no transaction is present in conflict with the Python DBAPI.\n\n    Initial patch and valuable debugging assistance courtesy of @ww2406.\n\n    See also\n\n    [Avoiding transaction-related exceptions on Azure Synapse Analytics](../dialects/mssql.html#azure-synapse-ignore-no-transaction-on-rollback)\n\n    References: [#8231](https://www.sqlalchemy.org/trac/ticket/8231)\n\n### misc\n\n*   **[bug] [types]**\n\n    Fixed issue where [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator \"sqlalchemy.types.TypeDecorator\") would not correctly proxy the `__getitem__()` operator when decorating the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") datatype, without explicit workarounds.\n\n    References: [#7249](https://www.sqlalchemy.org/trac/ticket/7249)\n\n## 1.4.39\n\nReleased: June 24, 2022\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#8133](https://www.sqlalchemy.org/trac/ticket/8133) where the pickle format for mutable attributes was changed, without a fallback to recognize the old format, causing in-place upgrades of SQLAlchemy to no longer be able to read pickled data from previous versions. A check plus a fallback for the old format is now in place.\n\n    References: [#8133](https://www.sqlalchemy.org/trac/ticket/8133)\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#8133](https://www.sqlalchemy.org/trac/ticket/8133) where the pickle format for mutable attributes was changed, without a fallback to recognize the old format, causing in-place upgrades of SQLAlchemy to no longer be able to read pickled data from previous versions. A check plus a fallback for the old format is now in place.\n\n    References: [#8133](https://www.sqlalchemy.org/trac/ticket/8133)\n\n## 1.4.38\n\nReleased: June 23, 2022\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#8064](https://www.sqlalchemy.org/trac/ticket/8064) where a particular check for column correspondence was made too liberal, resulting in incorrect rendering for some ORM subqueries such as those using [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has \"sqlalchemy.orm.PropComparator.has\") or [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any \"sqlalchemy.orm.PropComparator.any\") in conjunction with joined-inheritance queries that also use legacy aliasing features.\n\n    References: [#8162](https://www.sqlalchemy.org/trac/ticket/8162)\n\n*   **[orm] [bug] [sql]**\n\n    Fixed an issue where [`GenerativeSelect.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.fetch \"sqlalchemy.sql.expression.GenerativeSelect.fetch\") would not be applied when executing a statement using the ORM.\n\n    References: [#8091](https://www.sqlalchemy.org/trac/ticket/8091)\n\n*   **[orm] [bug]**\n\n    Fixed issue where a [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") option could not be pickled, as is necessary when it is carried along for propagation to lazy loaders in conjunction with a caching scheme. Currently, the only form that is supported as picklable is to pass the \u201cwhere criteria\u201d as a fixed module-level callable function that produces a SQL expression. An ad-hoc \u201clambda\u201d can\u2019t be pickled, and a SQL expression object is usually not fully picklable directly.\n\n    References: [#8109](https://www.sqlalchemy.org/trac/ticket/8109)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Repaired a deprecation warning class decorator that was preventing key objects such as [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") from having a proper `__weakref__` attribute, causing operations like Python standard library `inspect.getmembers()` to fail.\n\n    References: [#8115](https://www.sqlalchemy.org/trac/ticket/8115)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed multiple observed race conditions related to [`lambda_stmt()`](../core/sqlelement.html#sqlalchemy.sql.expression.lambda_stmt \"sqlalchemy.sql.expression.lambda_stmt\"), including an initial \u201cdogpile\u201d issue when a new Python code object is initially analyzed among multiple simultaneous threads which created both a performance issue as well as some internal corruption of state. Additionally repaired observed race condition which could occur when \u201ccloning\u201d an expression construct that is also in the process of being compiled or otherwise accessed in a different thread due to memoized attributes altering the `__dict__` while iterated, for Python versions prior to 3.10; in particular the lambda SQL construct is sensitive to this as it holds onto a single statement object persistently. The iteration has been refined to use `dict.copy()` with or without an additional iteration instead.\n\n    References: [#8098](https://www.sqlalchemy.org/trac/ticket/8098)\n\n*   **[sql] [bug]**\n\n    Enhanced the mechanism of [`Cast`](../core/sqlelement.html#sqlalchemy.sql.expression.Cast \"sqlalchemy.sql.expression.Cast\") and other \u201cwrapping\u201d column constructs to more fully preserve a wrapped [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label \"sqlalchemy.sql.expression.Label\") construct, including that the label name will be preserved in the `.c` collection of a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery \"sqlalchemy.sql.expression.Subquery\"). The label was already able to render in the SQL correctly on the outside of the construct which it was wrapped inside.\n\n    References: [#8084](https://www.sqlalchemy.org/trac/ticket/8084)\n\n*   **[sql] [bug]**\n\n    Adjusted the fix made for [#8056](https://www.sqlalchemy.org/trac/ticket/8056) which adjusted the escaping of bound parameter names with special characters such that the escaped names were translated after the SQL compilation step, which broke a published recipe on the FAQ illustrating how to merge parameter names into the string output of a compiled SQL string. The change restores the escaped names that come from `compiled.params` and adds a conditional parameter to [`SQLCompiler.construct_params()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.construct_params \"sqlalchemy.sql.compiler.SQLCompiler.construct_params\") named `escape_names` that defaults to `True`, restoring the old behavior by default.\n\n    References: [#8113](https://www.sqlalchemy.org/trac/ticket/8113)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed bugs involving the [`Table.include_columns`](../core/metadata.html#sqlalchemy.schema.Table.params.include_columns \"sqlalchemy.schema.Table\") and the [`Table.resolve_fks`](../core/metadata.html#sqlalchemy.schema.Table.params.resolve_fks \"sqlalchemy.schema.Table\") parameters on [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\"); these little-used parameters were apparently not working for columns that refer to foreign key constraints.\n\n    In the first case, not-included columns that refer to foreign keys would still attempt to create a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object, producing errors when attempting to resolve the columns for the foreign key constraint within reflection; foreign key constraints that refer to skipped columns are now omitted from the table reflection process in the same way as occurs for [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\") and [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint \"sqlalchemy.schema.UniqueConstraint\") objects with the same conditions. No warning is produced however, as we likely want to remove the include_columns warnings for all constraints in 2.0.\n\n    In the latter case, the production of table aliases or subqueries would fail on an FK related table not found despite the presence of `resolve_fks=False`; the logic has been repaired so that if a related table is not found, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object is still proxied to the aliased table or subquery (these [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") objects are normally used in the production of join conditions), but it is sent with a flag that it\u2019s not resolvable. The aliased table / subquery will then work normally, with the exception that it cannot be used to generate a join condition automatically, as the foreign key information is missing. This was already the behavior for such foreign key constraints produced using non-reflection methods, such as joining [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects from different [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") collections.\n\n    References: [#8100](https://www.sqlalchemy.org/trac/ticket/8100), [#8101](https://www.sqlalchemy.org/trac/ticket/8101)\n\n*   **[schema] [bug] [mssql]**\n\n    Fixed issue where [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects that made use of IDENTITY columns with a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric \"sqlalchemy.types.Numeric\") datatype would produce errors when attempting to reconcile the \u201cautoincrement\u201d column, preventing construction of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") from using the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement \"sqlalchemy.schema.Column\") parameter as well as emitting errors when attempting to invoke an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct.\n\n    References: [#8111](https://www.sqlalchemy.org/trac/ticket/8111)\n\n### extensions\n\n*   **[extensions] [bug]**\n\n    Fixed bug in [`Mutable`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.Mutable \"sqlalchemy.ext.mutable.Mutable\") where pickling and unpickling of an ORM mapped instance would not correctly restore state for mappings that contained multiple [`Mutable`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.Mutable \"sqlalchemy.ext.mutable.Mutable\")-enabled attributes.\n\n    References: [#8133](https://www.sqlalchemy.org/trac/ticket/8133)\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#8064](https://www.sqlalchemy.org/trac/ticket/8064) where a particular check for column correspondence was made too liberal, resulting in incorrect rendering for some ORM subqueries such as those using [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has \"sqlalchemy.orm.PropComparator.has\") or [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any \"sqlalchemy.orm.PropComparator.any\") in conjunction with joined-inheritance queries that also use legacy aliasing features.\n\n    References: [#8162](https://www.sqlalchemy.org/trac/ticket/8162)\n\n*   **[orm] [bug] [sql]**\n\n    Fixed an issue where [`GenerativeSelect.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.fetch \"sqlalchemy.sql.expression.GenerativeSelect.fetch\") would not be applied when executing a statement using the ORM.\n\n    References: [#8091](https://www.sqlalchemy.org/trac/ticket/8091)\n\n*   **[orm] [bug]**\n\n    Fixed issue where a [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") option could not be pickled, as is necessary when it is carried along for propagation to lazy loaders in conjunction with a caching scheme. Currently, the only form that is supported as picklable is to pass the \u201cwhere criteria\u201d as a fixed module-level callable function that produces a SQL expression. An ad-hoc \u201clambda\u201d can\u2019t be pickled, and a SQL expression object is usually not fully picklable directly.\n\n    References: [#8109](https://www.sqlalchemy.org/trac/ticket/8109)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Repaired a deprecation warning class decorator that was preventing key objects such as [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") from having a proper `__weakref__` attribute, causing operations like Python standard library `inspect.getmembers()` to fail.\n\n    References: [#8115](https://www.sqlalchemy.org/trac/ticket/8115)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed multiple observed race conditions related to [`lambda_stmt()`](../core/sqlelement.html#sqlalchemy.sql.expression.lambda_stmt \"sqlalchemy.sql.expression.lambda_stmt\"), including an initial \u201cdogpile\u201d issue when a new Python code object is initially analyzed among multiple simultaneous threads which created both a performance issue as well as some internal corruption of state. Additionally repaired observed race condition which could occur when \u201ccloning\u201d an expression construct that is also in the process of being compiled or otherwise accessed in a different thread due to memoized attributes altering the `__dict__` while iterated, for Python versions prior to 3.10; in particular the lambda SQL construct is sensitive to this as it holds onto a single statement object persistently. The iteration has been refined to use `dict.copy()` with or without an additional iteration instead.\n\n    References: [#8098](https://www.sqlalchemy.org/trac/ticket/8098)\n\n*   **[sql] [bug]**\n\n    Enhanced the mechanism of [`Cast`](../core/sqlelement.html#sqlalchemy.sql.expression.Cast \"sqlalchemy.sql.expression.Cast\") and other \u201cwrapping\u201d column constructs to more fully preserve a wrapped [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label \"sqlalchemy.sql.expression.Label\") construct, including that the label name will be preserved in the `.c` collection of a [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery \"sqlalchemy.sql.expression.Subquery\"). The label was already able to render in the SQL correctly on the outside of the construct which it was wrapped inside.\n\n    References: [#8084](https://www.sqlalchemy.org/trac/ticket/8084)\n\n*   **[sql] [bug]**\n\n    Adjusted the fix made for [#8056](https://www.sqlalchemy.org/trac/ticket/8056) which adjusted the escaping of bound parameter names with special characters such that the escaped names were translated after the SQL compilation step, which broke a published recipe on the FAQ illustrating how to merge parameter names into the string output of a compiled SQL string. The change restores the escaped names that come from `compiled.params` and adds a conditional parameter to [`SQLCompiler.construct_params()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.construct_params \"sqlalchemy.sql.compiler.SQLCompiler.construct_params\") named `escape_names` that defaults to `True`, restoring the old behavior by default.\n\n    References: [#8113](https://www.sqlalchemy.org/trac/ticket/8113)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed bugs involving the [`Table.include_columns`](../core/metadata.html#sqlalchemy.schema.Table.params.include_columns \"sqlalchemy.schema.Table\") and the [`Table.resolve_fks`](../core/metadata.html#sqlalchemy.schema.Table.params.resolve_fks \"sqlalchemy.schema.Table\") parameters on [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\"); these little-used parameters were apparently not working for columns that refer to foreign key constraints.\n\n    In the first case, not-included columns that refer to foreign keys would still attempt to create a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object, producing errors when attempting to resolve the columns for the foreign key constraint within reflection; foreign key constraints that refer to skipped columns are now omitted from the table reflection process in the same way as occurs for [`Index`](../core/constraints.html#sqlalchemy.schema.Index \"sqlalchemy.schema.Index\") and [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint \"sqlalchemy.schema.UniqueConstraint\") objects with the same conditions. No warning is produced however, as we likely want to remove the include_columns warnings for all constraints in 2.0.\n\n    In the latter case, the production of table aliases or subqueries would fail on an FK related table not found despite the presence of `resolve_fks=False`; the logic has been repaired so that if a related table is not found, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object is still proxied to the aliased table or subquery (these [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") objects are normally used in the production of join conditions), but it is sent with a flag that it\u2019s not resolvable. The aliased table / subquery will then work normally, with the exception that it cannot be used to generate a join condition automatically, as the foreign key information is missing. This was already the behavior for such foreign key constraints produced using non-reflection methods, such as joining [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects from different [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData \"sqlalchemy.schema.MetaData\") collections.\n\n    References: [#8100](https://www.sqlalchemy.org/trac/ticket/8100), [#8101](https://www.sqlalchemy.org/trac/ticket/8101)\n\n*   **[schema] [bug] [mssql]**\n\n    Fixed issue where [`Table`](../core/metadata.html#sqlalchemy.schema.Table \"sqlalchemy.schema.Table\") objects that made use of IDENTITY columns with a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric \"sqlalchemy.types.Numeric\") datatype would produce errors when attempting to reconcile the \u201cautoincrement\u201d column, preventing construction of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") from using the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement \"sqlalchemy.schema.Column\") parameter as well as emitting errors when attempting to invoke an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct.\n\n    References: [#8111](https://www.sqlalchemy.org/trac/ticket/8111)\n\n### extensions\n\n*   **[extensions] [bug]**\n\n    Fixed bug in [`Mutable`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.Mutable \"sqlalchemy.ext.mutable.Mutable\") where pickling and unpickling of an ORM mapped instance would not correctly restore state for mappings that contained multiple [`Mutable`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.Mutable \"sqlalchemy.ext.mutable.Mutable\")-enabled attributes.\n\n    References: [#8133](https://www.sqlalchemy.org/trac/ticket/8133)\n\n## 1.4.37\n\nReleased: May 31, 2022\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue where using a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property \"sqlalchemy.orm.column_property\") construct containing a subquery against an already-mapped column attribute would not correctly apply ORM-compilation behaviors to the subquery, including that the \u201cIN\u201d expression added for a single-table inherits expression would fail to be included.\n\n    References: [#8064](https://www.sqlalchemy.org/trac/ticket/8064)\n\n*   **[orm] [bug]**\n\n    Fixed issue where ORM results would apply incorrect key names to the returned [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") objects in the case where the set of columns to be selected were changed, such as when using [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns \"sqlalchemy.sql.expression.Select.with_only_columns\").\n\n    References: [#8001](https://www.sqlalchemy.org/trac/ticket/8001)\n\n*   **[orm] [bug] [oracle] [postgresql]**\n\n    Fixed bug, likely a regression from 1.3, where usage of column names that require bound parameter escaping, more concretely when using Oracle with column names that require quoting such as those that start with an underscore, or in less common cases with some PostgreSQL drivers when using column names that contain percent signs, would cause the ORM versioning feature to not work correctly if the versioning column itself had such a name, as the ORM assumes certain bound parameter naming conventions that were being interfered with via the quotes. This issue is related to [#8053](https://www.sqlalchemy.org/trac/ticket/8053) and essentially revises the approach towards fixing this, revising the original issue [#5653](https://www.sqlalchemy.org/trac/ticket/5653) that created the initial implementation for generalized bound-parameter name quoting.\n\n    References: [#8056](https://www.sqlalchemy.org/trac/ticket/8056)\n\n### engine\n\n*   **[engine] [bug] [tests]**\n\n    Fixed issue where support for logging \u201cstacklevel\u201d implemented in [#7612](https://www.sqlalchemy.org/trac/ticket/7612) required adjustment to work with recently released Python 3.11.0b1, also repairs the unit tests which tested this feature.\n\n    References: [#8019](https://www.sqlalchemy.org/trac/ticket/8019)\n\n### sql\n\n*   **[sql] [bug] [postgresql] [sqlite]**\n\n    Fixed bug where the PostgreSQL [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") method and the SQLite [`Insert.on_conflict_do_update()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update \"sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update\") method would both fail to correctly accommodate a column with a separate \u201c.key\u201d when specifying the column using its key name in the dictionary passed to [`Insert.on_conflict_do_update.set_`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_ \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\"), as well as if the [`Insert.excluded`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.excluded \"sqlalchemy.dialects.postgresql.Insert.excluded\") collection were used as the dictionary directly.\n\n    References: [#8014](https://www.sqlalchemy.org/trac/ticket/8014)\n\n*   **[sql] [bug]**\n\n    An informative error is raised for the use case where [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select \"sqlalchemy.sql.expression.Insert.from_select\") is being passed a \u201ccompound select\u201d object such as a UNION, yet the INSERT statement needs to append additional columns to support Python-side or explicit SQL defaults from the table metadata. In this case a subquery of the compound object should be passed.\n\n    References: [#8073](https://www.sqlalchemy.org/trac/ticket/8073)\n\n*   **[sql] [bug]**\n\n    Fixed an issue where using [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") with no explicit data or type given could be coerced into the incorrect type when used in expressions such as when using [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any \"sqlalchemy.types.ARRAY.Comparator.any\") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all \"sqlalchemy.types.ARRAY.Comparator.all\").\n\n    References: [#7979](https://www.sqlalchemy.org/trac/ticket/7979)\n\n*   **[sql] [bug]**\n\n    An informative error is raised if two individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter \"sqlalchemy.sql.expression.BindParameter\") objects share the same name, yet one is used within an \u201cexpanding\u201d context (typically an IN expression) and the other is not; mixing the same name in these two different styles of usage is not supported and typically the `expanding=True` parameter should be set on the parameters that are to receive list values outside of IN expressions (where `expanding` is set by default).\n\n    References: [#8018](https://www.sqlalchemy.org/trac/ticket/8018)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Further adjustments to the MySQL PyODBC dialect to allow for complete connectivity, which was previously still not working despite fixes in [#7871](https://www.sqlalchemy.org/trac/ticket/7871).\n\n    References: [#7966](https://www.sqlalchemy.org/trac/ticket/7966)\n\n*   **[mysql] [bug]**\n\n    Added disconnect code for MySQL error 4031, introduced in MySQL >= 8.0.24, indicating connection idle timeout exceeded. In particular this repairs an issue where pre-ping could not reconnect on a timed-out connection. Pull request courtesy valievkarim.\n\n    References: [#8036](https://www.sqlalchemy.org/trac/ticket/8036)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fix issue where a password with a leading \u201c{\u201d would result in login failure.\n\n    References: [#8062](https://www.sqlalchemy.org/trac/ticket/8062)\n\n*   **[mssql] [bug] [reflection]**\n\n    Explicitly specify the collation when reflecting table columns using MSSQL to prevent \u201ccollation conflict\u201d errors.\n\n    References: [#8035](https://www.sqlalchemy.org/trac/ticket/8035)\n\n### oracle\n\n*   **[oracle] [usecase]**\n\n    Added two new error codes for Oracle disconnect handling to support early testing of the new \u201cpython-oracledb\u201d driver released by Oracle.\n\n    References: [#8066](https://www.sqlalchemy.org/trac/ticket/8066)\n\n*   **[oracle] [bug]**\n\n    Fixed SQL compiler issue where the \u201cbind processing\u201d function for a bound parameter would not be correctly applied to a bound value if the bound parameter\u2019s name were \u201cescaped\u201d. Concretely, this applies, among other cases, to Oracle when a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") has a name that itself requires quoting, such that the quoting-required name is then used for the bound parameters generated within DML statements, and the datatype in use requires bind processing, such as the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype.\n\n    References: [#8053](https://www.sqlalchemy.org/trac/ticket/8053)\n\n### orm\n\n*   **[orm] [bug]**\n\n    Fixed issue where using a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property \"sqlalchemy.orm.column_property\") construct containing a subquery against an already-mapped column attribute would not correctly apply ORM-compilation behaviors to the subquery, including that the \u201cIN\u201d expression added for a single-table inherits expression would fail to be included.\n\n    References: [#8064](https://www.sqlalchemy.org/trac/ticket/8064)\n\n*   **[orm] [bug]**\n\n    Fixed issue where ORM results would apply incorrect key names to the returned [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") objects in the case where the set of columns to be selected were changed, such as when using [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns \"sqlalchemy.sql.expression.Select.with_only_columns\").\n\n    References: [#8001](https://www.sqlalchemy.org/trac/ticket/8001)\n\n*   **[orm] [bug] [oracle] [postgresql]**\n\n    Fixed bug, likely a regression from 1.3, where usage of column names that require bound parameter escaping, more concretely when using Oracle with column names that require quoting such as those that start with an underscore, or in less common cases with some PostgreSQL drivers when using column names that contain percent signs, would cause the ORM versioning feature to not work correctly if the versioning column itself had such a name, as the ORM assumes certain bound parameter naming conventions that were being interfered with via the quotes. This issue is related to [#8053](https://www.sqlalchemy.org/trac/ticket/8053) and essentially revises the approach towards fixing this, revising the original issue [#5653](https://www.sqlalchemy.org/trac/ticket/5653) that created the initial implementation for generalized bound-parameter name quoting.\n\n    References: [#8056](https://www.sqlalchemy.org/trac/ticket/8056)\n\n### engine\n\n*   **[engine] [bug] [tests]**\n\n    Fixed issue where support for logging \u201cstacklevel\u201d implemented in [#7612](https://www.sqlalchemy.org/trac/ticket/7612) required adjustment to work with recently released Python 3.11.0b1, also repairs the unit tests which tested this feature.\n\n    References: [#8019](https://www.sqlalchemy.org/trac/ticket/8019)\n\n### sql\n\n*   **[sql] [bug] [postgresql] [sqlite]**\n\n    Fixed bug where the PostgreSQL [`Insert.on_conflict_do_update()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\") method and the SQLite [`Insert.on_conflict_do_update()`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update \"sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update\") method would both fail to correctly accommodate a column with a separate \u201c.key\u201d when specifying the column using its key name in the dictionary passed to [`Insert.on_conflict_do_update.set_`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_ \"sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update\"), as well as if the [`Insert.excluded`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.excluded \"sqlalchemy.dialects.postgresql.Insert.excluded\") collection were used as the dictionary directly.\n\n    References: [#8014](https://www.sqlalchemy.org/trac/ticket/8014)\n\n*   **[sql] [bug]**\n\n    An informative error is raised for the use case where [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select \"sqlalchemy.sql.expression.Insert.from_select\") is being passed a \u201ccompound select\u201d object such as a UNION, yet the INSERT statement needs to append additional columns to support Python-side or explicit SQL defaults from the table metadata. In this case a subquery of the compound object should be passed.\n\n    References: [#8073](https://www.sqlalchemy.org/trac/ticket/8073)\n\n*   **[sql] [bug]**\n\n    Fixed an issue where using [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\") with no explicit data or type given could be coerced into the incorrect type when used in expressions such as when using [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any \"sqlalchemy.types.ARRAY.Comparator.any\") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all \"sqlalchemy.types.ARRAY.Comparator.all\").\n\n    References: [#7979](https://www.sqlalchemy.org/trac/ticket/7979)\n\n*   **[sql] [bug]**\n\n    An informative error is raised if two individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter \"sqlalchemy.sql.expression.BindParameter\") objects share the same name, yet one is used within an \u201cexpanding\u201d context (typically an IN expression) and the other is not; mixing the same name in these two different styles of usage is not supported and typically the `expanding=True` parameter should be set on the parameters that are to receive list values outside of IN expressions (where `expanding` is set by default).\n\n    References: [#8018](https://www.sqlalchemy.org/trac/ticket/8018)\n\n### mysql\n\n*   **[mysql] [bug]**\n\n    Further adjustments to the MySQL PyODBC dialect to allow for complete connectivity, which was previously still not working despite fixes in [#7871](https://www.sqlalchemy.org/trac/ticket/7871).\n\n    References: [#7966](https://www.sqlalchemy.org/trac/ticket/7966)\n\n*   **[mysql] [bug]**\n\n    Added disconnect code for MySQL error 4031, introduced in MySQL >= 8.0.24, indicating connection idle timeout exceeded. In particular this repairs an issue where pre-ping could not reconnect on a timed-out connection. Pull request courtesy valievkarim.\n\n    References: [#8036](https://www.sqlalchemy.org/trac/ticket/8036)\n\n### mssql\n\n*   **[mssql] [bug]**\n\n    Fix issue where a password with a leading \u201c{\u201d would result in login failure.\n\n    References: [#8062](https://www.sqlalchemy.org/trac/ticket/8062)\n\n*   **[mssql] [bug] [reflection]**\n\n    Explicitly specify the collation when reflecting table columns using MSSQL to prevent \u201ccollation conflict\u201d errors.\n\n    References: [#8035](https://www.sqlalchemy.org/trac/ticket/8035)\n\n### oracle\n\n*   **[oracle] [usecase]**\n\n    Added two new error codes for Oracle disconnect handling to support early testing of the new \u201cpython-oracledb\u201d driver released by Oracle.\n\n    References: [#8066](https://www.sqlalchemy.org/trac/ticket/8066)\n\n*   **[oracle] [bug]**\n\n    Fixed SQL compiler issue where the \u201cbind processing\u201d function for a bound parameter would not be correctly applied to a bound value if the bound parameter\u2019s name were \u201cescaped\u201d. Concretely, this applies, among other cases, to Oracle when a [`Column`](../core/metadata.html#sqlalchemy.schema.Column \"sqlalchemy.schema.Column\") has a name that itself requires quoting, such that the quoting-required name is then used for the bound parameters generated within DML statements, and the datatype in use requires bind processing, such as the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype.\n\n    References: [#8053](https://www.sqlalchemy.org/trac/ticket/8053)\n\n## 1.4.36\n\nReleased: April 26, 2022\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the change made for [#7861](https://www.sqlalchemy.org/trac/ticket/7861), released in version 1.4.33, that brought the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct to be partially recognized as an ORM-enabled statement did not properly transfer the correct mapper / mapped table state to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\"), causing the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind \"sqlalchemy.orm.Session.get_bind\") method to fail for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that was bound to engines and/or connections using the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds \"sqlalchemy.orm.Session\") parameter.\n\n    References: [#7936](https://www.sqlalchemy.org/trac/ticket/7936)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug]**\n\n    Modified the `DeclarativeMeta` metaclass to pass `cls.__dict__` into the declarative scanning process to look for attributes, rather than the separate dictionary passed to the type\u2019s `__init__()` method. This allows user-defined base classes that add attributes within an `__init_subclass__()` to work as expected, as `__init_subclass__()` can only affect the `cls.__dict__` itself and not the other dictionary. This is technically a regression from 1.3 where `__dict__` was being used.\n\n    References: [#7900](https://www.sqlalchemy.org/trac/ticket/7900)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed a memory leak in the C extensions which could occur when calling upon named members of [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") when the member does not exist under Python 3; in particular this could occur during NumPy transformations when it attempts to call members such as `.__array__`, but the issue was surrounding any `AttributeError` thrown by the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object. This issue does not apply to version 2.0 which has already transitioned to Cython. Thanks much to Sebastian Berg for identifying the problem.\n\n    References: [#7875](https://www.sqlalchemy.org/trac/ticket/7875)\n\n*   **[engine] [bug]**\n\n    Added a warning regarding a bug which exists in the [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns \"sqlalchemy.engine.Result.columns\") method when passing 0 for the index in conjunction with a [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") that will return a single ORM entity, which indicates that the current behavior of [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns \"sqlalchemy.engine.Result.columns\") is broken in this case as the [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object will yield scalar values and not [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") objects. The issue will be fixed in 2.0, which would be a backwards-incompatible change for code that relies on the current broken behavior. Code which wants to receive a collection of scalar values should use the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars \"sqlalchemy.engine.Result.scalars\") method, which will return a new [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") object that yields non-row scalar objects.\n\n    References: [#7953](https://www.sqlalchemy.org/trac/ticket/7953)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed bug where [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") naming conventions using the `referred_column_0` naming convention key would not work if the foreign key constraint were set up as a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object rather than an explicit [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") object. As this change makes use of a backport of some fixes from version 2.0, an additional little-known feature that has likely been broken for many years is also fixed which is that a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object may refer to a referred table by name of the table alone without using a column name, if the name of the referent column is the same as that of the referred column.\n\n    The `referred_column_0` naming convention key was previously not tested with the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object, only [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\"), and this bug reveals that the feature has never worked correctly unless [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") is used for all FK constraints. This bug traces back to the original introduction of the feature introduced for [#3989](https://www.sqlalchemy.org/trac/ticket/3989).\n\n    References: [#7958](https://www.sqlalchemy.org/trac/ticket/7958)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Repaired handling of `contextvar.ContextVar` objects inside of async adapted event handlers. Previously, values applied to a `ContextVar` would not be propagated in the specific case of calling upon awaitables inside of non-awaitable code.\n\n    References: [#7937](https://www.sqlalchemy.org/trac/ticket/7937)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed bug in [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") datatype in combination with [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") on PostgreSQL where using the `.any()` or `.all()` methods to render SQL ANY() or ALL(), given members of the Python enumeration as arguments, would produce a type adaptation failure on all drivers.\n\n    References: [#6515](https://www.sqlalchemy.org/trac/ticket/6515)\n\n*   **[postgresql] [bug]**\n\n    Implemented `UUID.python_type` attribute for the PostgreSQL `UUID` type object. The attribute will return either `str` or `uuid.UUID` based on the `UUID.as_uuid` parameter setting. Previously, this attribute was unimplemented. Pull request courtesy Alex Gr\u00f6nholm.\n\n    References: [#7943](https://www.sqlalchemy.org/trac/ticket/7943)\n\n*   **[postgresql] [bug]**\n\n    Fixed an issue in the psycopg2 dialect when using the [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping \"sqlalchemy.create_engine\") parameter which would cause user-configured `AUTOCOMMIT` isolation level to be inadvertently reset by the \u201cping\u201d handler.\n\n    References: [#7930](https://www.sqlalchemy.org/trac/ticket/7930)\n\n### mysql\n\n*   **[mysql] [bug] [regression]**\n\n    Fixed a regression in the untested MySQL PyODBC dialect caused by the fix for [#7518](https://www.sqlalchemy.org/trac/ticket/7518) in version 1.4.32 where an argument was being propagated incorrectly upon first connect, leading to a `TypeError`.\n\n    References: [#7871](https://www.sqlalchemy.org/trac/ticket/7871)\n\n### tests\n\n*   **[tests] [bug]**\n\n    For third party dialects, repaired a missing requirement for the `SimpleUpdateDeleteTest` suite test which was not checking for a working \u201crowcount\u201d function on the target dialect.\n\n    References: [#7919](https://www.sqlalchemy.org/trac/ticket/7919)\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the change made for [#7861](https://www.sqlalchemy.org/trac/ticket/7861), released in version 1.4.33, that brought the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct to be partially recognized as an ORM-enabled statement did not properly transfer the correct mapper / mapped table state to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\"), causing the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind \"sqlalchemy.orm.Session.get_bind\") method to fail for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session \"sqlalchemy.orm.Session\") that was bound to engines and/or connections using the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds \"sqlalchemy.orm.Session\") parameter.\n\n    References: [#7936](https://www.sqlalchemy.org/trac/ticket/7936)\n\n### orm declarative\n\n*   **[orm] [declarative] [bug]**\n\n    Modified the `DeclarativeMeta` metaclass to pass `cls.__dict__` into the declarative scanning process to look for attributes, rather than the separate dictionary passed to the type\u2019s `__init__()` method. This allows user-defined base classes that add attributes within an `__init_subclass__()` to work as expected, as `__init_subclass__()` can only affect the `cls.__dict__` itself and not the other dictionary. This is technically a regression from 1.3 where `__dict__` was being used.\n\n    References: [#7900](https://www.sqlalchemy.org/trac/ticket/7900)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Fixed a memory leak in the C extensions which could occur when calling upon named members of [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") when the member does not exist under Python 3; in particular this could occur during NumPy transformations when it attempts to call members such as `.__array__`, but the issue was surrounding any `AttributeError` thrown by the [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") object. This issue does not apply to version 2.0 which has already transitioned to Cython. Thanks much to Sebastian Berg for identifying the problem.\n\n    References: [#7875](https://www.sqlalchemy.org/trac/ticket/7875)\n\n*   **[engine] [bug]**\n\n    Added a warning regarding a bug which exists in the [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns \"sqlalchemy.engine.Result.columns\") method when passing 0 for the index in conjunction with a [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") that will return a single ORM entity, which indicates that the current behavior of [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns \"sqlalchemy.engine.Result.columns\") is broken in this case as the [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object will yield scalar values and not [`Row`](../core/connections.html#sqlalchemy.engine.Row \"sqlalchemy.engine.Row\") objects. The issue will be fixed in 2.0, which would be a backwards-incompatible change for code that relies on the current broken behavior. Code which wants to receive a collection of scalar values should use the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars \"sqlalchemy.engine.Result.scalars\") method, which will return a new [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult \"sqlalchemy.engine.ScalarResult\") object that yields non-row scalar objects.\n\n    References: [#7953](https://www.sqlalchemy.org/trac/ticket/7953)\n\n### schema\n\n*   **[schema] [bug]**\n\n    Fixed bug where [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") naming conventions using the `referred_column_0` naming convention key would not work if the foreign key constraint were set up as a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object rather than an explicit [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") object. As this change makes use of a backport of some fixes from version 2.0, an additional little-known feature that has likely been broken for many years is also fixed which is that a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object may refer to a referred table by name of the table alone without using a column name, if the name of the referent column is the same as that of the referred column.\n\n    The `referred_column_0` naming convention key was previously not tested with the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") object, only [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\"), and this bug reveals that the feature has never worked correctly unless [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") is used for all FK constraints. This bug traces back to the original introduction of the feature introduced for [#3989](https://www.sqlalchemy.org/trac/ticket/3989).\n\n    References: [#7958](https://www.sqlalchemy.org/trac/ticket/7958)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Repaired handling of `contextvar.ContextVar` objects inside of async adapted event handlers. Previously, values applied to a `ContextVar` would not be propagated in the specific case of calling upon awaitables inside of non-awaitable code.\n\n    References: [#7937](https://www.sqlalchemy.org/trac/ticket/7937)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Fixed bug in [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY \"sqlalchemy.types.ARRAY\") datatype in combination with [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") on PostgreSQL where using the `.any()` or `.all()` methods to render SQL ANY() or ALL(), given members of the Python enumeration as arguments, would produce a type adaptation failure on all drivers.\n\n    References: [#6515](https://www.sqlalchemy.org/trac/ticket/6515)\n\n*   **[postgresql] [bug]**\n\n    Implemented `UUID.python_type` attribute for the PostgreSQL `UUID` type object. The attribute will return either `str` or `uuid.UUID` based on the `UUID.as_uuid` parameter setting. Previously, this attribute was unimplemented. Pull request courtesy Alex Gr\u00f6nholm.\n\n    References: [#7943](https://www.sqlalchemy.org/trac/ticket/7943)\n\n*   **[postgresql] [bug]**\n\n    Fixed an issue in the psycopg2 dialect when using the [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping \"sqlalchemy.create_engine\") parameter which would cause user-configured `AUTOCOMMIT` isolation level to be inadvertently reset by the \u201cping\u201d handler.\n\n    References: [#7930](https://www.sqlalchemy.org/trac/ticket/7930)\n\n### mysql\n\n*   **[mysql] [bug] [regression]**\n\n    Fixed a regression in the untested MySQL PyODBC dialect caused by the fix for [#7518](https://www.sqlalchemy.org/trac/ticket/7518) in version 1.4.32 where an argument was being propagated incorrectly upon first connect, leading to a `TypeError`.\n\n    References: [#7871](https://www.sqlalchemy.org/trac/ticket/7871)\n\n### tests\n\n*   **[tests] [bug]**\n\n    For third party dialects, repaired a missing requirement for the `SimpleUpdateDeleteTest` suite test which was not checking for a working \u201crowcount\u201d function on the target dialect.\n\n    References: [#7919](https://www.sqlalchemy.org/trac/ticket/7919)\n\n## 1.4.35\n\nReleased: April 6, 2022\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed bug in newly implemented [`FunctionElement.table_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.table_valued\") feature where the parameter would not automatically propagate from the original [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias \"sqlalchemy.sql.expression.TableValuedAlias\") object to the secondary object produced when calling upon [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") or [`TableValuedAlias.alias()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.alias \"sqlalchemy.sql.expression.TableValuedAlias.alias\").\n\n    Additionally repaired these issues in [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias \"sqlalchemy.sql.expression.TableValuedAlias\"):\n\n    *   repaired a potential memory issue which could occur when repeatedly calling [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") against successive copies of the same object (for .alias(), we currently have to still continue chaining from the previous element. not sure if this can be improved but this is standard behavior for .alias() elsewhere)\n\n    *   repaired issue where the individual element types would be lost when calling upon [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") or [`TableValuedAlias.alias()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.alias \"sqlalchemy.sql.expression.TableValuedAlias.alias\").\n\n    References: [#7890](https://www.sqlalchemy.org/trac/ticket/7890)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by [#7823](https://www.sqlalchemy.org/trac/ticket/7823) which impacted the caching system, such that bound parameters that had been \u201ccloned\u201d within ORM operations, such as polymorphic loading, would in some cases not acquire their correct execution-time value leading to incorrect bind values being rendered.\n\n    References: [#7903](https://www.sqlalchemy.org/trac/ticket/7903)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed bug in newly implemented [`FunctionElement.table_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.table_valued\") feature where the parameter would not automatically propagate from the original [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias \"sqlalchemy.sql.expression.TableValuedAlias\") object to the secondary object produced when calling upon [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") or [`TableValuedAlias.alias()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.alias \"sqlalchemy.sql.expression.TableValuedAlias.alias\").\n\n    Additionally repaired these issues in [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias \"sqlalchemy.sql.expression.TableValuedAlias\"):\n\n    *   repaired a potential memory issue which could occur when repeatedly calling [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") against successive copies of the same object (for .alias(), we currently have to still continue chaining from the previous element. not sure if this can be improved but this is standard behavior for .alias() elsewhere)\n\n    *   repaired issue where the individual element types would be lost when calling upon [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived \"sqlalchemy.sql.expression.TableValuedAlias.render_derived\") or [`TableValuedAlias.alias()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.alias \"sqlalchemy.sql.expression.TableValuedAlias.alias\").\n\n    References: [#7890](https://www.sqlalchemy.org/trac/ticket/7890)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by [#7823](https://www.sqlalchemy.org/trac/ticket/7823) which impacted the caching system, such that bound parameters that had been \u201ccloned\u201d within ORM operations, such as polymorphic loading, would in some cases not acquire their correct execution-time value leading to incorrect bind values being rendered.\n\n    References: [#7903](https://www.sqlalchemy.org/trac/ticket/7903)\n\n## 1.4.34\n\nReleased: March 31, 2022\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#7861](https://www.sqlalchemy.org/trac/ticket/7861) where invoking an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct which contained ORM entities directly via [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") would fail.\n\n    References: [#7878](https://www.sqlalchemy.org/trac/ticket/7878)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Scaled back a fix made for [#6581](https://www.sqlalchemy.org/trac/ticket/6581) where \u201cexecutemany values\u201d mode for psycopg2 were disabled for all \u201cON CONFLICT\u201d styles of INSERT, to not apply to the \u201cON CONFLICT DO NOTHING\u201d clause, which does not include any parameters and is safe for \u201cexecutemany values\u201d mode. \u201cON CONFLICT DO UPDATE\u201d is still blocked from \u201cexecutemany values\u201d as there may be additional parameters in the DO UPDATE clause that cannot be batched (which is the original issue fixed by [#6581](https://www.sqlalchemy.org/trac/ticket/6581)).\n\n    References: [#7880](https://www.sqlalchemy.org/trac/ticket/7880)\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression caused by [#7861](https://www.sqlalchemy.org/trac/ticket/7861) where invoking an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\") construct which contained ORM entities directly via [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute \"sqlalchemy.orm.Session.execute\") would fail.\n\n    References: [#7878](https://www.sqlalchemy.org/trac/ticket/7878)\n\n### postgresql\n\n*   **[postgresql] [bug]**\n\n    Scaled back a fix made for [#6581](https://www.sqlalchemy.org/trac/ticket/6581) where \u201cexecutemany values\u201d mode for psycopg2 were disabled for all \u201cON CONFLICT\u201d styles of INSERT, to not apply to the \u201cON CONFLICT DO NOTHING\u201d clause, which does not include any parameters and is safe for \u201cexecutemany values\u201d mode. \u201cON CONFLICT DO UPDATE\u201d is still blocked from \u201cexecutemany values\u201d as there may be additional parameters in the DO UPDATE clause that cannot be batched (which is the original issue fixed by [#6581](https://www.sqlalchemy.org/trac/ticket/6581)).\n\n    References: [#7880](https://www.sqlalchemy.org/trac/ticket/7880)\n\n## 1.4.33\n\nReleased: March 31, 2022\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added [`with_polymorphic.adapt_on_names`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic.params.adapt_on_names \"sqlalchemy.orm.with_polymorphic\") to the [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") function, which allows a polymorphic load (typically with concrete mapping) to be stated against an alternative selectable that will adapt to the original mapped selectable on column names alone.\n\n    References: [#7805](https://www.sqlalchemy.org/trac/ticket/7805)\n\n*   **[orm] [usecase]**\n\n    Added new attributes [`UpdateBase.returning_column_descriptions`](../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning_column_descriptions \"sqlalchemy.sql.expression.UpdateBase.returning_column_descriptions\") and [`UpdateBase.entity_description`](../core/dml.html#sqlalchemy.sql.expression.UpdateBase.entity_description \"sqlalchemy.sql.expression.UpdateBase.entity_description\") to allow for inspection of ORM attributes and entities that are installed as part of an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\"), [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"), or [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") construct. The [`Select.column_descriptions`](../core/selectable.html#sqlalchemy.sql.expression.Select.column_descriptions \"sqlalchemy.sql.expression.Select.column_descriptions\") accessor is also now implemented for Core-only selectables.\n\n    References: [#7861](https://www.sqlalchemy.org/trac/ticket/7861)\n\n*   **[orm] [performance] [bug]**\n\n    Improvements in memory usage by the ORM, removing a significant set of intermediary expression objects that are typically stored when a copy of an expression object is created. These clones have been greatly reduced, reducing the number of total expression objects stored in memory by ORM mappings by about 30%.\n\n    References: [#7823](https://www.sqlalchemy.org/trac/ticket/7823)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in \u201cdynamic\u201d loader strategy where the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") method would not be given an appropriate entity to filter from, in the case where a \u201csecondary\u201d table were present in the relationship being queried and the mapping were against something complex such as a \u201cwith polymorphic\u201d.\n\n    References: [#7868](https://www.sqlalchemy.org/trac/ticket/7868)\n\n*   **[orm] [bug]**\n\n    Fixed bug where [`composite()`](../orm/composites.html#sqlalchemy.orm.composite \"sqlalchemy.orm.composite\") attributes would not work in conjunction with the [`selectin_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.selectin_polymorphic \"sqlalchemy.orm.selectin_polymorphic\") loader strategy for joined table inheritance.\n\n    References: [#7801](https://www.sqlalchemy.org/trac/ticket/7801)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the [`selectin_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.selectin_polymorphic \"sqlalchemy.orm.selectin_polymorphic\") loader option would not work with joined inheritance mappers that don\u2019t have a fixed \u201cpolymorphic_on\u201d column. Additionally added test support for a wider variety of usage patterns with this construct.\n\n    References: [#7799](https://www.sqlalchemy.org/trac/ticket/7799)\n\n*   **[orm] [bug]**\n\n    Fixed bug in [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") function where loader criteria would not be applied to a joined eager load that were invoked within the scope of a refresh operation for the parent object.\n\n    References: [#7862](https://www.sqlalchemy.org/trac/ticket/7862)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper \"sqlalchemy.orm.Mapper\") would reduce a user-defined [`Mapper.primary_key`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key \"sqlalchemy.orm.Mapper\") argument too aggressively, in the case of mapping to a `UNION` where for some of the SELECT entries, two columns are essentially equivalent, but in another, they are not, such as in a recursive CTE. The logic here has been changed to accept a given user-defined PK as given, where columns will be related to the mapped selectable but no longer \u201creduced\u201d as this heuristic can\u2019t accommodate for all situations.\n\n    References: [#7842](https://www.sqlalchemy.org/trac/ticket/7842)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Added new parameter [`Engine.dispose.close`](../core/connections.html#sqlalchemy.engine.Engine.dispose.params.close \"sqlalchemy.engine.Engine.dispose\"), defaulting to True. When False, the engine disposal does not touch the connections in the old pool at all, simply dropping the pool and replacing it. This use case is so that when the original pool is transferred from a parent process, the parent process may continue to use those connections.\n\n    See also\n\n    [Using Connection Pools with Multiprocessing or os.fork()](../core/pooling.html#pooling-multiprocessing) - revised documentation\n\n    References: [#7815](https://www.sqlalchemy.org/trac/ticket/7815), [#7877](https://www.sqlalchemy.org/trac/ticket/7877)\n\n*   **[engine] [bug]**\n\n    Further clarified connection-level logging to indicate the BEGIN, ROLLBACK and COMMIT log messages do not actually indicate a real transaction when the AUTOCOMMIT isolation level is in use; messaging has been extended to include the BEGIN message itself, and the messaging has also been fixed to accommodate when the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") level [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level \"sqlalchemy.create_engine\") parameter was used directly.\n\n    References: [#7853](https://www.sqlalchemy.org/trac/ticket/7853)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Added new parameter [`FunctionElement.table_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.table_valued\"), for the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued \"sqlalchemy.sql.functions.FunctionElement.table_valued\") construct. This parameter indicates that the table-valued function provided will automatically perform an implicit join with the referenced table. This effectively disables the \u2018from linting\u2019 feature, such as the \u2018cartesian product\u2019 warning, from triggering due to the presence of this parameter. May be used for functions such as `func.json_each()`.\n\n    References: [#7845](https://www.sqlalchemy.org/trac/ticket/7845)\n\n*   **[sql] [bug]**\n\n    The [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute \"sqlalchemy.sql.expression.bindparam\") parameter now takes part of the cache generation of a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\"), since it changes the sql string generated by the compiler. Previously the correct bind values were used, but the `literal_execute` would be ignored on subsequent executions of the same query.\n\n    References: [#7876](https://www.sqlalchemy.org/trac/ticket/7876)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by [#7760](https://www.sqlalchemy.org/trac/ticket/7760) where the new capabilities of [`TextualSelect`](../core/selectable.html#sqlalchemy.sql.expression.TextualSelect \"sqlalchemy.sql.expression.TextualSelect\") were not fully implemented within the compiler properly, leading to issues with composed INSERT constructs such as \u201cINSERT FROM SELECT\u201d and \u201cINSERT\u2026ON CONFLICT\u201d when combined with CTE and textual statements.\n\n    References: [#7798](https://www.sqlalchemy.org/trac/ticket/7798)\n\n### schema\n\n*   **[schema] [usecase]**\n\n    Added support so that the [`Table.to_metadata.referred_schema_fn`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata.params.referred_schema_fn \"sqlalchemy.schema.Table.to_metadata\") callable passed to [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata \"sqlalchemy.schema.Table.to_metadata\") may return the value [`BLANK_SCHEMA`](../core/metadata.html#sqlalchemy.schema.SchemaConst.BLANK_SCHEMA \"sqlalchemy.schema.SchemaConst.BLANK_SCHEMA\") to indicate that the referenced foreign key should be reset to None. The [`RETAIN_SCHEMA`](../core/metadata.html#sqlalchemy.schema.SchemaConst.RETAIN_SCHEMA \"sqlalchemy.schema.SchemaConst.RETAIN_SCHEMA\") symbol may also be returned from this function to indicate \u201cno change\u201d, which will behave the same as `None` currently does which also indicates no change.\n\n    References: [#7860](https://www.sqlalchemy.org/trac/ticket/7860)\n\n### sqlite\n\n*   **[sqlite] [bug] [reflection]**\n\n    Fixed bug where the name of CHECK constraints under SQLite would not be reflected if the name were created using quotes, as is the case when the name uses mixed case or special characters.\n\n    References: [#5463](https://www.sqlalchemy.org/trac/ticket/5463)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression caused by [#7160](https://www.sqlalchemy.org/trac/ticket/7160) where FK reflection in conjunction with a low compatibility level setting (compatibility level 80: SQL Server 2000) causes an \u201cAmbiguous column name\u201d error. Patch courtesy @Lin-Your.\n\n    References: [#7812](https://www.sqlalchemy.org/trac/ticket/7812)\n\n### misc\n\n*   **[bug] [ext]**\n\n    Improved the error message that\u2019s raised for the case where the [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy \"sqlalchemy.ext.associationproxy.association_proxy\") construct attempts to access a target attribute at the class level, and this access fails. The particular use case here is when proxying to a hybrid attribute that does not include a working class-level implementation.\n\n    References: [#7827](https://www.sqlalchemy.org/trac/ticket/7827)\n\n### orm\n\n*   **[orm] [usecase]**\n\n    Added [`with_polymorphic.adapt_on_names`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic.params.adapt_on_names \"sqlalchemy.orm.with_polymorphic\") to the [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic \"sqlalchemy.orm.with_polymorphic\") function, which allows a polymorphic load (typically with concrete mapping) to be stated against an alternative selectable that will adapt to the original mapped selectable on column names alone.\n\n    References: [#7805](https://www.sqlalchemy.org/trac/ticket/7805)\n\n*   **[orm] [usecase]**\n\n    Added new attributes [`UpdateBase.returning_column_descriptions`](../core/dml.html#sqlalchemy.sql.expression.UpdateBase.returning_column_descriptions \"sqlalchemy.sql.expression.UpdateBase.returning_column_descriptions\") and [`UpdateBase.entity_description`](../core/dml.html#sqlalchemy.sql.expression.UpdateBase.entity_description \"sqlalchemy.sql.expression.UpdateBase.entity_description\") to allow for inspection of ORM attributes and entities that are installed as part of an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert \"sqlalchemy.sql.expression.Insert\"), [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update \"sqlalchemy.sql.expression.Update\"), or [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete \"sqlalchemy.sql.expression.Delete\") construct. The [`Select.column_descriptions`](../core/selectable.html#sqlalchemy.sql.expression.Select.column_descriptions \"sqlalchemy.sql.expression.Select.column_descriptions\") accessor is also now implemented for Core-only selectables.\n\n    References: [#7861](https://www.sqlalchemy.org/trac/ticket/7861)\n\n*   **[orm] [performance] [bug]**\n\n    Improvements in memory usage by the ORM, removing a significant set of intermediary expression objects that are typically stored when a copy of an expression object is created. These clones have been greatly reduced, reducing the number of total expression objects stored in memory by ORM mappings by about 30%.\n\n    References: [#7823](https://www.sqlalchemy.org/trac/ticket/7823)\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression in \u201cdynamic\u201d loader strategy where the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by \"sqlalchemy.orm.Query.filter_by\") method would not be given an appropriate entity to filter from, in the case where a \u201csecondary\u201d table were present in the relationship being queried and the mapping were against something complex such as a \u201cwith polymorphic\u201d.\n\n    References: [#7868](https://www.sqlalchemy.org/trac/ticket/7868)\n\n*   **[orm] [bug]**\n\n    Fixed bug where [`composite()`](../orm/composites.html#sqlalchemy.orm.composite \"sqlalchemy.orm.composite\") attributes would not work in conjunction with the [`selectin_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.selectin_polymorphic \"sqlalchemy.orm.selectin_polymorphic\") loader strategy for joined table inheritance.\n\n    References: [#7801](https://www.sqlalchemy.org/trac/ticket/7801)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the [`selectin_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.selectin_polymorphic \"sqlalchemy.orm.selectin_polymorphic\") loader option would not work with joined inheritance mappers that don\u2019t have a fixed \u201cpolymorphic_on\u201d column. Additionally added test support for a wider variety of usage patterns with this construct.\n\n    References: [#7799](https://www.sqlalchemy.org/trac/ticket/7799)\n\n*   **[orm] [bug]**\n\n    Fixed bug in [`with_loader_criteria()`](../orm/queryguide/api.html#sqlalchemy.orm.with_loader_criteria \"sqlalchemy.orm.with_loader_criteria\") function where loader criteria would not be applied to a joined eager load that were invoked within the scope of a refresh operation for the parent object.\n\n    References: [#7862](https://www.sqlalchemy.org/trac/ticket/7862)\n\n*   **[orm] [bug]**\n\n    Fixed issue where the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper \"sqlalchemy.orm.Mapper\") would reduce a user-defined [`Mapper.primary_key`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key \"sqlalchemy.orm.Mapper\") argument too aggressively, in the case of mapping to a `UNION` where for some of the SELECT entries, two columns are essentially equivalent, but in another, they are not, such as in a recursive CTE. The logic here has been changed to accept a given user-defined PK as given, where columns will be related to the mapped selectable but no longer \u201creduced\u201d as this heuristic can\u2019t accommodate for all situations.\n\n    References: [#7842](https://www.sqlalchemy.org/trac/ticket/7842)\n\n### engine\n\n*   **[engine] [usecase]**\n\n    Added new parameter [`Engine.dispose.close`](../core/connections.html#sqlalchemy.engine.Engine.dispose.params.close \"sqlalchemy.engine.Engine.dispose\"), defaulting to True. When False, the engine disposal does not touch the connections in the old pool at all, simply dropping the pool and replacing it. This use case is so that when the original pool is transferred from a parent process, the parent process may continue to use those connections.\n\n    See also\n\n    [Using Connection Pools with Multiprocessing or os.fork()](../core/pooling.html#pooling-multiprocessing) - revised documentation\n\n    References: [#7815](https://www.sqlalchemy.org/trac/ticket/7815), [#7877](https://www.sqlalchemy.org/trac/ticket/7877)\n\n*   **[engine] [bug]**\n\n    Further clarified connection-level logging to indicate the BEGIN, ROLLBACK and COMMIT log messages do not actually indicate a real transaction when the AUTOCOMMIT isolation level is in use; messaging has been extended to include the BEGIN message itself, and the messaging has also been fixed to accommodate when the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\") level [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level \"sqlalchemy.create_engine\") parameter was used directly.\n\n    References: [#7853](https://www.sqlalchemy.org/trac/ticket/7853)\n\n### sql\n\n*   **[sql] [usecase]**\n\n    Added new parameter [`FunctionElement.table_valued.joins_implicitly`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.joins_implicitly \"sqlalchemy.sql.functions.FunctionElement.table_valued\"), for the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued \"sqlalchemy.sql.functions.FunctionElement.table_valued\") construct. This parameter indicates that the table-valued function provided will automatically perform an implicit join with the referenced table. This effectively disables the \u2018from linting\u2019 feature, such as the \u2018cartesian product\u2019 warning, from triggering due to the presence of this parameter. May be used for functions such as `func.json_each()`.\n\n    References: [#7845](https://www.sqlalchemy.org/trac/ticket/7845)\n\n*   **[sql] [bug]**\n\n    The [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute \"sqlalchemy.sql.expression.bindparam\") parameter now takes part of the cache generation of a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam \"sqlalchemy.sql.expression.bindparam\"), since it changes the sql string generated by the compiler. Previously the correct bind values were used, but the `literal_execute` would be ignored on subsequent executions of the same query.\n\n    References: [#7876](https://www.sqlalchemy.org/trac/ticket/7876)\n\n*   **[sql] [bug] [regression]**\n\n    Fixed regression caused by [#7760](https://www.sqlalchemy.org/trac/ticket/7760) where the new capabilities of [`TextualSelect`](../core/selectable.html#sqlalchemy.sql.expression.TextualSelect \"sqlalchemy.sql.expression.TextualSelect\") were not fully implemented within the compiler properly, leading to issues with composed INSERT constructs such as \u201cINSERT FROM SELECT\u201d and \u201cINSERT\u2026ON CONFLICT\u201d when combined with CTE and textual statements.\n\n    References: [#7798](https://www.sqlalchemy.org/trac/ticket/7798)\n\n### schema\n\n*   **[schema] [usecase]**\n\n    Added support so that the [`Table.to_metadata.referred_schema_fn`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata.params.referred_schema_fn \"sqlalchemy.schema.Table.to_metadata\") callable passed to [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata \"sqlalchemy.schema.Table.to_metadata\") may return the value [`BLANK_SCHEMA`](../core/metadata.html#sqlalchemy.schema.SchemaConst.BLANK_SCHEMA \"sqlalchemy.schema.SchemaConst.BLANK_SCHEMA\") to indicate that the referenced foreign key should be reset to None. The [`RETAIN_SCHEMA`](../core/metadata.html#sqlalchemy.schema.SchemaConst.RETAIN_SCHEMA \"sqlalchemy.schema.SchemaConst.RETAIN_SCHEMA\") symbol may also be returned from this function to indicate \u201cno change\u201d, which will behave the same as `None` currently does which also indicates no change.\n\n    References: [#7860](https://www.sqlalchemy.org/trac/ticket/7860)\n\n### sqlite\n\n*   **[sqlite] [bug] [reflection]**\n\n    Fixed bug where the name of CHECK constraints under SQLite would not be reflected if the name were created using quotes, as is the case when the name uses mixed case or special characters.\n\n    References: [#5463](https://www.sqlalchemy.org/trac/ticket/5463)\n\n### mssql\n\n*   **[mssql] [bug] [regression]**\n\n    Fixed regression caused by [#7160](https://www.sqlalchemy.org/trac/ticket/7160) where FK reflection in conjunction with a low compatibility level setting (compatibility level 80: SQL Server 2000) causes an \u201cAmbiguous column name\u201d error. Patch courtesy @Lin-Your.\n\n    References: [#7812](https://www.sqlalchemy.org/trac/ticket/7812)\n\n### misc\n\n*   **[bug] [ext]**\n\n    Improved the error message that\u2019s raised for the case where the [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy \"sqlalchemy.ext.associationproxy.association_proxy\") construct attempts to access a target attribute at the class level, and this access fails. The particular use case here is when proxying to a hybrid attribute that does not include a working class-level implementation.\n\n    References: [#7827](https://www.sqlalchemy.org/trac/ticket/7827)\n\n## 1.4.32\n\nReleased: March 6, 2022\n\n### orm\n\n*   **[orm] [bug] [regression]**\n\n    Fixed regression where the ORM exception that is to be raised when an INSERT silently fails to actually insert a row (such as from a trigger) would not be reached, due to a runtime exception raised ahead of time due to the missing primary key value, thus raising an uninformative exception rather than the correct one. For 1.4 and above, a new [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError \"sqlalchemy.orm.exc.FlushError\") is added for this case that\u2019s raised earlier than the previous \u201cnull identity\u201d exception was for 1.3, as a situation where the number of rows actually INSERTed does not match what was expected is a more critical situation in 1.4 as it prevents batching of multiple objects from working correctly. This is separate from the case where a newly fetched primary key is fetched as NULL, which continues to raise the existing \u201cnull identity\u201d exception.\n\n    References: [#7594](https://www.sqlalchemy.org/trac/ticket/7594)\n\n*   **[orm] [bug]**\n\n    Fixed issue where using a fully qualified path for the classname in [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship \"sqlalchemy.orm.relationship\") that nonetheless contained an incorrect name for path tokens that were not the first token, would fail to raise an informative error and would instead fail randomly at a later step.\n\n    References: [#7697](https://www.sqlalchemy.org/trac/ticket/7697)\n\n### engine\n\n*   **[engine] [bug]**\n\n    Adjusted the logging for key SQLAlchemy components including [`Engine`](../core/connections.html#sqlalchemy.engine.Engine \"sqlalchemy.engine.Engine\"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection \"sqlalchemy.engine.Connection\") to establish an appropriate stack level parameter, so that the Python logging tokens `funcName` and `lineno` when used in custom logging formatters will report the correct information, which can be useful when filtering log output; supported on Python 3.8 and above. Pull request courtesy Markus Gerstel.\n\n    References: [#7612](https://www.sqlalchemy.org/trac/ticket/7612)\n\n### sql\n\n*   **[sql] [bug]**\n\n    Fixed type-related error messages that would fail for values that were tuples, due to string formatting syntax, including compile of unsupported literal values and invalid boolean values.\n\n    References: [#7721](https://www.sqlalchemy.org/trac/ticket/7721)\n\n*   **[sql] [bug] [mysql]**\n\n    Fixed issues in MySQL [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET \"sqlalchemy.dialects.mysql.SET\") datatype as well as the generic [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype where the `__repr__()` method would not render all optional parameters in the string output, impacting the use of these types in Alembic autogenerate. Pull request for MySQL courtesy Yuki Nishimine.\n\n    References: [#7598](https://www.sqlalchemy.org/trac/ticket/7598), [#7720](https://www.sqlalchemy.org/trac/ticket/7720), [#7789](https://www.sqlalchemy.org/trac/ticket/7789)\n\n*   **[sql] [bug]**\n\n    The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype now emits a warning if the [`Enum.length`](../core/type_basics.html#sqlalchemy.types.Enum.params.length \"sqlalchemy.types.Enum\") argument is specified without also specifying [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum \"sqlalchemy.types.Enum\") as False, as the parameter is otherwise silently ignored in this case, despite the fact that the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum \"sqlalchemy.types.Enum\") datatype will still render VARCHAR DDL on backends that don\u2019t have a native ENUM datatype such as SQLite. This behavior may change in a future release so that \u201clength\u201d is honored for all non-native \u201cenum\u201d types regardless of the \u201cnative_enum\u201d setting.\n\n*   **[sql] [bug]**\n\n    Fixed issue where the [`HasCTE.add_cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte \"sqlalchemy.sql.expression.HasCTE.add_cte\") method as called upon a [`TextualSelect`](../core/selectable.html#sqlalchemy.sql.expression.TextualSelect \"sqlalchemy.sql.expression.TextualSelect\") instance was not being accommodated by the SQL compiler. The fix additionally adds more \u201cSELECT\u201d-like compiler behavior to [`TextualSelect`](../core/selectable.html#sqlalchemy.sql.expression.TextualSelect \"sqlalchemy.sql.expression.TextualSelect\") including that DML CTEs such as UPDATE and INSERT may be accommodated.\n\n    References: [#7760](https://www.sqlalchemy.org/trac/ticket/7760)\n\n### asyncio\n\n*   **[asyncio] [bug]**\n\n    Fixed issues where a descriptive error message was not raised for some classes of event listening with an async engine, which should instead be a sync engine instance.\n\n*   **[asyncio] [bug]**\n\n    Fixed issue where the [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute \"sqlalchemy.ext.asyncio.AsyncSession.execute\") method failed to raise an informative exception if the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") execution option were used, which is incompatible with a sync-style [`Result`](../core/connections.html#sqlalchemy.engine.Result \"sqlalchemy.engine.Result\") object when using an asyncio calling style, as the operation to fetch more rows would need to be awaited. An exception is now raised in this scenario in the same way one was already raised when the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results \"sqlalchemy.engine.Connection.execution_options\") option would be used with the [`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute \"sqlalchemy.ext.asyncio.AsyncConnection.execute\") method.\n\n    Additionally, for improved stability with state-sensitive database drivers such as asyncmy, the cursor is now closed when this error condition is raised; previously with the asyncmy dialect, the connection would go into an invalid state with unconsumed server side results remaining.\n\n    References: [#7667](https://www.sqlalchemy.org/trac/ticket/7667)\n\n### postgresql\n\n*   **[postgresql] [usecase]**\n\n    Added compiler support for the PostgreSQL `NOT VALID` phrase when rendering DDL for the [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint \"sqlalchemy.schema.CheckConstraint\"), [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint \"sqlalchemy.schema.ForeignKeyConstraint\") and [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey \"sqlalchemy.schema.ForeignKey\") schema constructs. Pull request courtesy Gilbert Gilb\u2019s.\n\n    See also\n\n    [PostgreSQL Constraint Options](../dialects/postgresql.html#postgresql-constraint-options)\n\n    References: [#7600](https://www.sqlalchemy.org/trac/ticket/7600)\n\n### mysql\n\n*   **[mysql] [bug] [regression]**\n\n    Fixed regression caused by [#7518](https://www.sqlalchemy.org/trac/ticket/7518) where changing the syntax \u201cSHOW VARIABLES\u201d to \u201cSELECT @@\u201d broke compatibility with MySQL versions older than 5.6, including early 5.0 releases. While these are very old MySQL versions, a change in compatibility was not planned, so version-specific logic has been restored to fall back to \u201cSHOW VARIABLES\u201d for MySQL server versions < 5.6.\n\n    References: [#7518](https://www.sqlalchemy.org/trac/ticket/7518)\n\n### mariadb\n\n*   **[mariadb] [bug] [regression]**\n\n    Fixed regression in mariadbconnector dialect as of mariadb connector 1.0.10 where the DBAPI no longer pre-buffers cursor.lastrowid, leading to errors when inserting objects with the ORM as well as causing non-availability of the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key \"sqlalchemy.engine.CursorResult.inserted_primary_key\") attribute. The dialect now fetches this value proactively for situations where it applies.\n\n    References: [#7738](https://www.sqlalchemy.org/trac/ticket/7738)\n\n### sqlite\n\n*   **[sqlite] [usecase]**\n\n    Added support for reflecting SQLite inline unique constraints where the column names are formatted with SQLite \u201cescape quotes\u201d `[]` or ```"]