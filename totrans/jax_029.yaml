- en: Type promotion semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/type_promotion.html`](https://jax.readthedocs.io/en/latest/type_promotion.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This document describes JAX’s type promotion rules–i.e., the result of `jax.numpy.promote_types()`
    for each pair of types. For some background on the considerations that went into
    the design of what is described below, see [Design of Type Promotion Semantics
    for JAX](https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX’s type promotion behavior is determined via the following type promotion
    lattice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/type_lattice.svg](img/5bcb61d2d26437cb91bbfc4057949d61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b1` means `np.bool_`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2` means `np.int16`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u4` means `np.uint32`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bf` means `np.bfloat16`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f2` means `np.float16`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c8` means `np.complex64`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i*` means Python `int` or weakly-typed `int`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f*` means Python `float` or weakly-typed `float`, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c*` means Python `complex` or weakly-typed `complex`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (for more about weak types, see Weakly-typed values in JAX below).
  prefs: []
  type: TYPE_NORMAL
- en: 'Promotion between any two types is given by their [join](https://en.wikipedia.org/wiki/Join_and_meet)
    on this lattice, which generates the following binary promotion table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b1 | u1 | u2 | u4 | u8 | i1 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8 |
    c16 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| b1 | b1 | u1 | u2 | u4 | u8 | i1 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u1 | u1 | u1 | u2 | u4 | u8 | i2 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | u1 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u2 | u2 | u2 | u2 | u4 | u8 | i4 | i4 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | u2 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u4 | u4 | u4 | u4 | u4 | u8 | i8 | i8 | i8 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | u4 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | u8 | u8 | u8 | u8 | u8 | f* | f* | f* | f* | bf | f2 | f4 | f8 | c8
    | c16 | u8 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i1 | i1 | i2 | i4 | i8 | f* | i1 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i1 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i2 | i2 | i2 | i4 | i8 | f* | i2 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i2 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i4 | i4 | i4 | i4 | i8 | f* | i4 | i4 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i4 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | i8 | i8 | i8 | i8 | f* | i8 | i8 | i8 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i8 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| bf | bf | bf | bf | bf | bf | bf | bf | bf | bf | bf | f4 | f4 | f8 | c8
    | c16 | bf | bf | c8 |'
  prefs: []
  type: TYPE_TB
- en: '| f2 | f2 | f2 | f2 | f2 | f2 | f2 | f2 | f2 | f2 | f4 | f2 | f4 | f8 | c8
    | c16 | f2 | f2 | c8 |'
  prefs: []
  type: TYPE_TB
- en: '| f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f4 | f8 | c8
    | c16 | f4 | f4 | c8 |'
  prefs: []
  type: TYPE_TB
- en: '| f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | f8 | c16
    | c16 | f8 | f8 | c16 |'
  prefs: []
  type: TYPE_TB
- en: '| c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c8 | c16 | c8
    | c16 | c8 | c8 | c8 |'
  prefs: []
  type: TYPE_TB
- en: '| c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16 | c16
    | c16 | c16 | c16 | c16 | c16 | c16 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | i* | u1 | u2 | u4 | u8 | i1 | i2 | i4 | i8 | bf | f2 | f4 | f8 | c8
    | c16 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| f* | f* | f* | f* | f* | f* | f* | f* | f* | f* | bf | f2 | f4 | f8 | c8
    | c16 | f* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| c* | c* | c* | c* | c* | c* | c* | c* | c* | c* | c8 | c8 | c8 | c16 | c8
    | c16 | c* | c* | c* |'
  prefs: []
  type: TYPE_TB
- en: 'Jax’s type promotion rules differ from those of NumPy, as given by [`numpy.promote_types()`](https://numpy.org/doc/stable/reference/generated/numpy.promote_types.html#numpy.promote_types
    "(in NumPy v2.0)"), in those cells highlighted with a green background in the
    table above. There are three key classes of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: When promoting a weakly typed value against a typed JAX value of the same category,
    JAX always prefers the precision of the JAX value. For example, `jnp.int16(1)
    + 1` will return `int16` rather than promoting to `int64` as in NumPy. Note that
    this applies only to Python scalar values; if the constant is a NumPy array then
    the above lattice is used for type promotion. For example, `jnp.int16(1) + np.array(1)`
    will return `int64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When promoting an integer or boolean type against a floating-point or complex
    type, JAX always prefers the type of the floating-point or complex type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX supports the [bfloat16](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format)
    non-standard 16-bit floating point type (`jax.numpy.bfloat16`), which is useful
    for neural network training. The only notable promotion behavior is with respect
    to IEEE-754 `float16`, with which `bfloat16` promotes to a `float32`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between NumPy and JAX are motivated by the fact that accelerator
    devices, such as GPUs and TPUs, either pay a significant performance penalty to
    use 64-bit floating point types (GPUs) or do not support 64-bit floating point
    types at all (TPUs). Classic NumPy’s promotion rules are too willing to overpromote
    to 64-bit types, which is problematic for a system designed to run on accelerators.
  prefs: []
  type: TYPE_NORMAL
- en: JAX uses floating point promotion rules that are more suited to modern accelerator
    devices and are less aggressive about promoting floating point types. The promotion
    rules used by JAX for floating-point types are similar to those used by PyTorch.
  prefs: []
  type: TYPE_NORMAL
- en: Effects of Python operator dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that Python operators like + will dispatch based on the Python
    type of the two values being added. This means that, for example, `np.int16(1)
    + 1` will promote using NumPy rules, whereas `jnp.int16(1) + 1` will promote using
    JAX rules. This can lead to potentially confusing non-associative promotion semantics
    when the two types of promotion are combined; for example with `np.int16(1) +
    1 + jnp.int16(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '## Weakly-typed values in JAX'
  prefs: []
  type: TYPE_NORMAL
- en: '*Weakly-typed* values in JAX can in most cases be thought of as having promotion
    behavior equivalent to that of Python scalars, such as the integer scalar `2`
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'JAX’s weak type framework is designed to prevent unwanted type promotion within
    binary operations between JAX values and values with no explicitly user-specified
    type, such as Python scalar literals. For example, if `2` were not treated as
    weakly-typed, the expression above would lead to an implicit type promotion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in JAX, Python scalars are sometimes promoted to `DeviceArray` objects,
    for example during JIT compilation. To maintain the desired promotion semantics
    in this case, `DeviceArray` objects carry a `weak_type` flag that can be seen
    in an array’s string representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `dtype` is specified explicitly, it will instead result in a standard
    strongly-typed array value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]  ## Strict dtype promotion'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some contexts it can be useful to disable implicit type promotion behavior,
    and instead require all promotions to be explicit. This can be done in JAX by
    setting the `jax_numpy_dtype_promtion` flag to `''strict''`. Locally, it can be
    done with acontext manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, strict promotion mode will still allow safe weakly-typed promotions,
    so you can still write code code that mixes JAX arrays and Python scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would prefer to set the configuration globally, you can do so using
    the standard configuration update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore the default standard type promotion, set this configuration to `''standard''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
