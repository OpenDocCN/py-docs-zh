- en: Mypy / Pep-484 Support for ORM Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/extensions/mypy.html](https://docs.sqlalchemy.org/en/20/orm/extensions/mypy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Support for [**PEP 484**](https://peps.python.org/pep-0484/) typing annotations
    as well as the [MyPy](https://mypy.readthedocs.io/) type checking tool when using
    SQLAlchemy [declarative](../declarative_config.html) mappings that refer to the
    [`Column`](../../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object directly, rather than the [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct introduced in SQLAlchemy 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0: **The SQLAlchemy Mypy Plugin is DEPRECATED, and
    will be removed possibly as early as the SQLAlchemy 2.1 release. We would urge
    users to please migrate away from it ASAP.**'
  prefs: []
  type: TYPE_NORMAL
- en: This plugin cannot be maintained across constantly changing releases of mypy
    and its stability going forward CANNOT be guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Modern SQLAlchemy now offers [fully pep-484 compliant mapping syntaxes](../../changelog/whatsnew_20.html#whatsnew-20-orm-declarative-typing);
    see the linked section for migration details.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For **SQLAlchemy 2.0 only**: No stubs should be installed and packages like
    [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) and [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    should be fully uninstalled.'
  prefs: []
  type: TYPE_NORMAL
- en: The [Mypy](https://mypy.readthedocs.io/) package itself is a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mypy may be installed using the “mypy” extras hook using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin itself is configured as described in [Configuring mypy to use Plugins](https://mypy.readthedocs.io/en/latest/extending_mypy.html#configuring-mypy-to-use-plugins),
    using the `sqlalchemy.ext.mypy.plugin` module name, such as within `setup.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What the Plugin Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary purpose of the Mypy plugin is to intercept and alter the static
    definition of SQLAlchemy [declarative mappings](../declarative_config.html) so
    that they match up to how they are structured after they have been [instrumented](../../glossary.html#term-instrumented)
    by their [`Mapper`](../mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    objects. This allows both the class structure itself as well as code that uses
    the class to make sense to the Mypy tool, which otherwise would not be the case
    based on how declarative mappings currently function. The plugin is not unlike
    similar plugins that are required for libraries like [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which alter classes dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cover the major areas where this occurs, consider the following ORM mapping,
    using the typical example of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the steps that the Mypy extension can take include:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of the `Base` dynamic class generated by [`declarative_base()`](../mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base"), so that classes which inherit from it are
    known to be mapped. It also can accommodate the class decorator approach described
    at [Declarative Mapping using a Decorator (no declarative base)](../declarative_styles.html#orm-declarative-decorator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference for ORM mapped attributes that are defined in declarative “inline”
    style, in the above example the `id` and `name` attributes of the `User` class.
    This includes that an instance of `User` will use `int` for `id` and `str` for
    `name`. It also includes that when the `User.id` and `User.name` class-level attributes
    are accessed, as they are above in the `select()` statement, they are compatible
    with SQL expression behavior, which is derived from the [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") attribute descriptor class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application of an `__init__()` method to mapped classes that do not already
    include an explicit constructor, which accepts keyword arguments of specific types
    for all mapped attributes detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the Mypy plugin processes the above file, the resulting static class definition
    and Python code passed to the Mypy tool is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The key steps which have been taken above include:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Base` class is now defined in terms of the `DeclarativeMeta` class explicitly,
    rather than being a dynamic class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id` and `name` attributes are defined in terms of the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class, which represents a Python descriptor that exhibits
    different behaviors at the class vs. instance levels. The [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class is now the base class for the [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") class that is used for all ORM mapped
    attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    is defined as a generic class against arbitrary Python types, meaning specific
    occurrences of [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    are associated with a specific Python type, such as `Mapped[Optional[int]]` and
    `Mapped[Optional[str]]` above.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The right-hand side of the declarative mapped attribute assignments are **removed**,
    as this resembles the operation that the [`Mapper`](../mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") class would normally be doing, which is that it would
    be replacing these attributes with specific instances of [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute"). The original expression is moved into
    a function call that will allow it to still be type-checked without conflicting
    with the left-hand side of the expression. For Mypy purposes, the left-hand typing
    annotation is sufficient for the attribute’s behavior to be understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type stub for the `User.__init__()` method is added which includes the correct
    keywords and datatypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following subsections will address individual uses cases that have so far
    been considered for pep-484 compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection of Columns based on TypeEngine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For mapped columns that include an explicit datatype, when they are mapped
    as inline attributes, the mapped type will be introspected automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the ultimate class-level datatypes of `id`, `name` and `other_name`
    will be introspected as `Mapped[Optional[int]]`, `Mapped[Optional[str]]` and `Mapped[Optional[str]]`.
    The types are by default **always** considered to be `Optional`, even for the
    primary key and non-nullable column. The reason is because while the database
    columns “id” and “name” can’t be NULL, the Python attributes `id` and `name` most
    certainly can be `None` without an explicit constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of the above columns can be stated **explicitly**, providing the
    two advantages of clearer self-documentation as well as being able to control
    which types are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mypy plugin will accept the above `int`, `str` and `Optional[str]` and
    convert them to include the `Mapped[]` type surrounding them. The `Mapped[]` construct
    may also be used explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the type is non-optional, it simply means that the attribute as accessed
    from an instance of `MyClass` will be considered to be non-None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For optional attributes, Mypy considers that the type must include None or
    otherwise be `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the mapped attribute is typed as `Optional`, the generation of
    the `__init__()` method will **still consider all keywords to be optional**. This
    is again matching what the SQLAlchemy ORM actually does when it creates the constructor,
    and should not be confused with the behavior of a validating system such as Python
    `dataclasses` which will generate a constructor that matches the annotations in
    terms of optional vs. required attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Columns that Don’t have an Explicit Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Columns that include a [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") modifier do not need to specify a datatype in
    a SQLAlchemy declarative mapping. For this type of attribute, the Mypy plugin
    will inform the user that it needs an explicit type to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin will deliver the message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve, apply an explicit type annotation to the `Address.user_id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Columns with Imperative Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [imperative table style](../declarative_tables.html#orm-imperative-table-configuration),
    the [`Column`](../../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    definitions are given inside of a [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct which is separate from the mapped attributes
    themselves. The Mypy plugin does not consider this [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), but instead supports that the attributes can be explicitly
    stated with a complete annotation that **must** use the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class to identify them as mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The above [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotations are considered as mapped columns and will be included in the default
    constructor, as well as provide the correct typing profile for `MyClass` both
    at the class level and the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plugin has limited support for using type inference to detect the types
    for relationships. For all those cases where it can’t detect the type, it will
    emit an informative error message, and in all cases the appropriate type may be
    provided explicitly, either with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class or optionally omitting it for an inline declaration.
    The plugin also needs to determine whether or not the relationship refers to a
    collection or a scalar, and for that it relies upon the explicit value of the
    [`relationship.uselist`](../relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") and/or [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameters. An explicit type is needed if neither
    of these parameters are present, as well as if the target type of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is a string or callable, and not a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The error can be resolved either by using `relationship(User, uselist=False)`
    or by providing the type, in this case the scalar `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For collections, a similar pattern applies, where in the absence of `uselist=True`
    or a [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship"), a collection annotation such as `List` may be
    used. It is also fully appropriate to use the string name of the class in the
    annotation as supported by pep-484, ensuring the class is imported with in the
    [TYPE_CHECKING block](https://www.python.org/dev/peps/pep-0484/#runtime-or-type-checking)
    as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with columns, the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class may also be applied explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '### Using @declared_attr and Declarative Mixins'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    class allows Declarative mapped attributes to be declared in class level functions,
    and is particularly useful when using [declarative mixins](../declarative_mixins.html).
    For these functions, the return type of the function should be annotated using
    either the `Mapped[]` construct or by indicating the exact kind of object returned
    by the function. Additionally, “mixin” classes that are not otherwise mapped (i.e.
    don’t extend from a [`declarative_base()`](../mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") class nor are they mapped with a method such
    as [`registry.mapped()`](../mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped"))
    should be decorated with the [`declarative_mixin()`](../mapping_api.html#sqlalchemy.orm.declarative_mixin
    "sqlalchemy.orm.declarative_mixin") decorator, which provides a hint to the Mypy
    plugin that a particular class intends to serve as a declarative mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the mismatch between the actual return type of a method like `HasCompany.company`
    vs. what is annotated. The Mypy plugin converts all `@declared_attr` functions
    into simple annotated attributes to avoid this complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Combining with Dataclasses or Other Type-Sensitive Attribute Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples of Python dataclasses integration at [Applying ORM Mappings to
    an existing dataclass (legacy dataclass use)](../dataclasses.html#orm-declarative-dataclasses)
    presents a problem; Python dataclasses expect an explicit type that it will use
    to build the class, and the value given in each assignment statement is significant.
    That is, a class as follows has to be stated exactly as it is in order to be accepted
    by dataclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can’t apply our `Mapped[]` types to the attributes `id`, `name`, etc. because
    they will be rejected by the `@dataclass` decorator. Additionally, Mypy has another
    plugin for dataclasses explicitly which can also get in the way of what we’re
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above class will actually pass Mypy’s type checking without issue; the
    only thing we are missing is the ability for attributes on `User` to be used in
    SQL expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide a workaround for this, the Mypy plugin has an additional feature
    whereby we can specify an extra attribute `_mypy_mapped_attrs`, that is a list
    that encloses the class-level objects or their string names. This attribute can
    be conditional within the `TYPE_CHECKING` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the above recipe, the attributes listed in `_mypy_mapped_attrs` will be
    applied with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    typing information so that the `User` class will behave as a SQLAlchemy mapped
    class when used in a class-bound context.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For **SQLAlchemy 2.0 only**: No stubs should be installed and packages like
    [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) and [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    should be fully uninstalled.'
  prefs: []
  type: TYPE_NORMAL
- en: The [Mypy](https://mypy.readthedocs.io/) package itself is a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mypy may be installed using the “mypy” extras hook using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin itself is configured as described in [Configuring mypy to use Plugins](https://mypy.readthedocs.io/en/latest/extending_mypy.html#configuring-mypy-to-use-plugins),
    using the `sqlalchemy.ext.mypy.plugin` module name, such as within `setup.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What the Plugin Does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary purpose of the Mypy plugin is to intercept and alter the static
    definition of SQLAlchemy [declarative mappings](../declarative_config.html) so
    that they match up to how they are structured after they have been [instrumented](../../glossary.html#term-instrumented)
    by their [`Mapper`](../mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    objects. This allows both the class structure itself as well as code that uses
    the class to make sense to the Mypy tool, which otherwise would not be the case
    based on how declarative mappings currently function. The plugin is not unlike
    similar plugins that are required for libraries like [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which alter classes dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cover the major areas where this occurs, consider the following ORM mapping,
    using the typical example of the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the steps that the Mypy extension can take include:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of the `Base` dynamic class generated by [`declarative_base()`](../mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base"), so that classes which inherit from it are
    known to be mapped. It also can accommodate the class decorator approach described
    at [Declarative Mapping using a Decorator (no declarative base)](../declarative_styles.html#orm-declarative-decorator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference for ORM mapped attributes that are defined in declarative “inline”
    style, in the above example the `id` and `name` attributes of the `User` class.
    This includes that an instance of `User` will use `int` for `id` and `str` for
    `name`. It also includes that when the `User.id` and `User.name` class-level attributes
    are accessed, as they are above in the `select()` statement, they are compatible
    with SQL expression behavior, which is derived from the [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") attribute descriptor class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application of an `__init__()` method to mapped classes that do not already
    include an explicit constructor, which accepts keyword arguments of specific types
    for all mapped attributes detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the Mypy plugin processes the above file, the resulting static class definition
    and Python code passed to the Mypy tool is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The key steps which have been taken above include:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Base` class is now defined in terms of the `DeclarativeMeta` class explicitly,
    rather than being a dynamic class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id` and `name` attributes are defined in terms of the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class, which represents a Python descriptor that exhibits
    different behaviors at the class vs. instance levels. The [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class is now the base class for the [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") class that is used for all ORM mapped
    attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    is defined as a generic class against arbitrary Python types, meaning specific
    occurrences of [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    are associated with a specific Python type, such as `Mapped[Optional[int]]` and
    `Mapped[Optional[str]]` above.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The right-hand side of the declarative mapped attribute assignments are **removed**,
    as this resembles the operation that the [`Mapper`](../mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") class would normally be doing, which is that it would
    be replacing these attributes with specific instances of [`InstrumentedAttribute`](../internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute"). The original expression is moved into
    a function call that will allow it to still be type-checked without conflicting
    with the left-hand side of the expression. For Mypy purposes, the left-hand typing
    annotation is sufficient for the attribute’s behavior to be understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type stub for the `User.__init__()` method is added which includes the correct
    keywords and datatypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following subsections will address individual uses cases that have so far
    been considered for pep-484 compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection of Columns based on TypeEngine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For mapped columns that include an explicit datatype, when they are mapped
    as inline attributes, the mapped type will be introspected automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the ultimate class-level datatypes of `id`, `name` and `other_name`
    will be introspected as `Mapped[Optional[int]]`, `Mapped[Optional[str]]` and `Mapped[Optional[str]]`.
    The types are by default **always** considered to be `Optional`, even for the
    primary key and non-nullable column. The reason is because while the database
    columns “id” and “name” can’t be NULL, the Python attributes `id` and `name` most
    certainly can be `None` without an explicit constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of the above columns can be stated **explicitly**, providing the
    two advantages of clearer self-documentation as well as being able to control
    which types are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mypy plugin will accept the above `int`, `str` and `Optional[str]` and
    convert them to include the `Mapped[]` type surrounding them. The `Mapped[]` construct
    may also be used explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the type is non-optional, it simply means that the attribute as accessed
    from an instance of `MyClass` will be considered to be non-None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For optional attributes, Mypy considers that the type must include None or
    otherwise be `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the mapped attribute is typed as `Optional`, the generation of
    the `__init__()` method will **still consider all keywords to be optional**. This
    is again matching what the SQLAlchemy ORM actually does when it creates the constructor,
    and should not be confused with the behavior of a validating system such as Python
    `dataclasses` which will generate a constructor that matches the annotations in
    terms of optional vs. required attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Columns that Don’t have an Explicit Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Columns that include a [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") modifier do not need to specify a datatype in
    a SQLAlchemy declarative mapping. For this type of attribute, the Mypy plugin
    will inform the user that it needs an explicit type to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin will deliver the message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve, apply an explicit type annotation to the `Address.user_id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Columns with Imperative Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [imperative table style](../declarative_tables.html#orm-imperative-table-configuration),
    the [`Column`](../../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    definitions are given inside of a [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct which is separate from the mapped attributes
    themselves. The Mypy plugin does not consider this [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), but instead supports that the attributes can be explicitly
    stated with a complete annotation that **must** use the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class to identify them as mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The above [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotations are considered as mapped columns and will be included in the default
    constructor, as well as provide the correct typing profile for `MyClass` both
    at the class level and the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plugin has limited support for using type inference to detect the types
    for relationships. For all those cases where it can’t detect the type, it will
    emit an informative error message, and in all cases the appropriate type may be
    provided explicitly, either with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class or optionally omitting it for an inline declaration.
    The plugin also needs to determine whether or not the relationship refers to a
    collection or a scalar, and for that it relies upon the explicit value of the
    [`relationship.uselist`](../relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") and/or [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameters. An explicit type is needed if neither
    of these parameters are present, as well as if the target type of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is a string or callable, and not a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The error can be resolved either by using `relationship(User, uselist=False)`
    or by providing the type, in this case the scalar `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For collections, a similar pattern applies, where in the absence of `uselist=True`
    or a [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship"), a collection annotation such as `List` may be
    used. It is also fully appropriate to use the string name of the class in the
    annotation as supported by pep-484, ensuring the class is imported with in the
    [TYPE_CHECKING block](https://www.python.org/dev/peps/pep-0484/#runtime-or-type-checking)
    as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with columns, the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class may also be applied explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '### Using @declared_attr and Declarative Mixins'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    class allows Declarative mapped attributes to be declared in class level functions,
    and is particularly useful when using [declarative mixins](../declarative_mixins.html).
    For these functions, the return type of the function should be annotated using
    either the `Mapped[]` construct or by indicating the exact kind of object returned
    by the function. Additionally, “mixin” classes that are not otherwise mapped (i.e.
    don’t extend from a [`declarative_base()`](../mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") class nor are they mapped with a method such
    as [`registry.mapped()`](../mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped"))
    should be decorated with the [`declarative_mixin()`](../mapping_api.html#sqlalchemy.orm.declarative_mixin
    "sqlalchemy.orm.declarative_mixin") decorator, which provides a hint to the Mypy
    plugin that a particular class intends to serve as a declarative mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the mismatch between the actual return type of a method like `HasCompany.company`
    vs. what is annotated. The Mypy plugin converts all `@declared_attr` functions
    into simple annotated attributes to avoid this complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Combining with Dataclasses or Other Type-Sensitive Attribute Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples of Python dataclasses integration at [Applying ORM Mappings to
    an existing dataclass (legacy dataclass use)](../dataclasses.html#orm-declarative-dataclasses)
    presents a problem; Python dataclasses expect an explicit type that it will use
    to build the class, and the value given in each assignment statement is significant.
    That is, a class as follows has to be stated exactly as it is in order to be accepted
    by dataclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can’t apply our `Mapped[]` types to the attributes `id`, `name`, etc. because
    they will be rejected by the `@dataclass` decorator. Additionally, Mypy has another
    plugin for dataclasses explicitly which can also get in the way of what we’re
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above class will actually pass Mypy’s type checking without issue; the
    only thing we are missing is the ability for attributes on `User` to be used in
    SQL expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide a workaround for this, the Mypy plugin has an additional feature
    whereby we can specify an extra attribute `_mypy_mapped_attrs`, that is a list
    that encloses the class-level objects or their string names. This attribute can
    be conditional within the `TYPE_CHECKING` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With the above recipe, the attributes listed in `_mypy_mapped_attrs` will be
    applied with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    typing information so that the `User` class will behave as a SQLAlchemy mapped
    class when used in a class-bound context.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection of Columns based on TypeEngine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For mapped columns that include an explicit datatype, when they are mapped
    as inline attributes, the mapped type will be introspected automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the ultimate class-level datatypes of `id`, `name` and `other_name`
    will be introspected as `Mapped[Optional[int]]`, `Mapped[Optional[str]]` and `Mapped[Optional[str]]`.
    The types are by default **always** considered to be `Optional`, even for the
    primary key and non-nullable column. The reason is because while the database
    columns “id” and “name” can’t be NULL, the Python attributes `id` and `name` most
    certainly can be `None` without an explicit constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of the above columns can be stated **explicitly**, providing the
    two advantages of clearer self-documentation as well as being able to control
    which types are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mypy plugin will accept the above `int`, `str` and `Optional[str]` and
    convert them to include the `Mapped[]` type surrounding them. The `Mapped[]` construct
    may also be used explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When the type is non-optional, it simply means that the attribute as accessed
    from an instance of `MyClass` will be considered to be non-None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For optional attributes, Mypy considers that the type must include None or
    otherwise be `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the mapped attribute is typed as `Optional`, the generation of
    the `__init__()` method will **still consider all keywords to be optional**. This
    is again matching what the SQLAlchemy ORM actually does when it creates the constructor,
    and should not be confused with the behavior of a validating system such as Python
    `dataclasses` which will generate a constructor that matches the annotations in
    terms of optional vs. required attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Columns that Don’t have an Explicit Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Columns that include a [`ForeignKey`](../../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") modifier do not need to specify a datatype in
    a SQLAlchemy declarative mapping. For this type of attribute, the Mypy plugin
    will inform the user that it needs an explicit type to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin will deliver the message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve, apply an explicit type annotation to the `Address.user_id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Columns with Imperative Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [imperative table style](../declarative_tables.html#orm-imperative-table-configuration),
    the [`Column`](../../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    definitions are given inside of a [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct which is separate from the mapped attributes
    themselves. The Mypy plugin does not consider this [`Table`](../../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), but instead supports that the attributes can be explicitly
    stated with a complete annotation that **must** use the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class to identify them as mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The above [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotations are considered as mapped columns and will be included in the default
    constructor, as well as provide the correct typing profile for `MyClass` both
    at the class level and the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plugin has limited support for using type inference to detect the types
    for relationships. For all those cases where it can’t detect the type, it will
    emit an informative error message, and in all cases the appropriate type may be
    provided explicitly, either with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class or optionally omitting it for an inline declaration.
    The plugin also needs to determine whether or not the relationship refers to a
    collection or a scalar, and for that it relies upon the explicit value of the
    [`relationship.uselist`](../relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") and/or [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameters. An explicit type is needed if neither
    of these parameters are present, as well as if the target type of the [`relationship()`](../relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is a string or callable, and not a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The error can be resolved either by using `relationship(User, uselist=False)`
    or by providing the type, in this case the scalar `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For collections, a similar pattern applies, where in the absence of `uselist=True`
    or a [`relationship.collection_class`](../relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship"), a collection annotation such as `List` may be
    used. It is also fully appropriate to use the string name of the class in the
    annotation as supported by pep-484, ensuring the class is imported with in the
    [TYPE_CHECKING block](https://www.python.org/dev/peps/pep-0484/#runtime-or-type-checking)
    as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with columns, the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") class may also be applied explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '### Using @declared_attr and Declarative Mixins'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    class allows Declarative mapped attributes to be declared in class level functions,
    and is particularly useful when using [declarative mixins](../declarative_mixins.html).
    For these functions, the return type of the function should be annotated using
    either the `Mapped[]` construct or by indicating the exact kind of object returned
    by the function. Additionally, “mixin” classes that are not otherwise mapped (i.e.
    don’t extend from a [`declarative_base()`](../mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") class nor are they mapped with a method such
    as [`registry.mapped()`](../mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped"))
    should be decorated with the [`declarative_mixin()`](../mapping_api.html#sqlalchemy.orm.declarative_mixin
    "sqlalchemy.orm.declarative_mixin") decorator, which provides a hint to the Mypy
    plugin that a particular class intends to serve as a declarative mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the mismatch between the actual return type of a method like `HasCompany.company`
    vs. what is annotated. The Mypy plugin converts all `@declared_attr` functions
    into simple annotated attributes to avoid this complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Combining with Dataclasses or Other Type-Sensitive Attribute Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples of Python dataclasses integration at [Applying ORM Mappings to
    an existing dataclass (legacy dataclass use)](../dataclasses.html#orm-declarative-dataclasses)
    presents a problem; Python dataclasses expect an explicit type that it will use
    to build the class, and the value given in each assignment statement is significant.
    That is, a class as follows has to be stated exactly as it is in order to be accepted
    by dataclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We can’t apply our `Mapped[]` types to the attributes `id`, `name`, etc. because
    they will be rejected by the `@dataclass` decorator. Additionally, Mypy has another
    plugin for dataclasses explicitly which can also get in the way of what we’re
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above class will actually pass Mypy’s type checking without issue; the
    only thing we are missing is the ability for attributes on `User` to be used in
    SQL expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide a workaround for this, the Mypy plugin has an additional feature
    whereby we can specify an extra attribute `_mypy_mapped_attrs`, that is a list
    that encloses the class-level objects or their string names. This attribute can
    be conditional within the `TYPE_CHECKING` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With the above recipe, the attributes listed in `_mypy_mapped_attrs` will be
    applied with the [`Mapped`](../internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    typing information so that the `User` class will behave as a SQLAlchemy mapped
    class when used in a class-bound context.
  prefs: []
  type: TYPE_NORMAL
