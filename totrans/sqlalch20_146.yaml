- en: What’s New in SQLAlchemy 0.9?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_09.html](https://docs.sqlalchemy.org/en/20/changelog/migration_09.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 0.8, undergoing maintenance
    releases as of May, 2013, and SQLAlchemy version 0.9, which had its first production
    release on December 30, 2013.
  prefs: []
  type: TYPE_NORMAL
- en: 'Document last updated: June 10, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 0.9, and also documents
    changes which affect users migrating their applications from the 0.8 series of
    SQLAlchemy to 0.9.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review [Behavioral Changes - ORM](#behavioral-changes-orm-09)
    and [Behavioral Changes - Core](#behavioral-changes-core-09) for potentially backwards-incompatible
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Platform Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  prefs: []
  type: TYPE_NORMAL
- en: C Extensions Supported on Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Behavioral Changes - ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '### Composite attributes are now returned as their object form when queried
    on a per-attribute basis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Bundles for ORM queries](#change-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example against the usual `User` mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement predictably renders SQL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` on
    `relationship()` prevents history from taking effect'
  prefs: []
  type: TYPE_NORMAL
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### Association Proxy
    SQL Expression Improvements and Fixes'
  prefs: []
  type: TYPE_NORMAL
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Up through 0.8, a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, it now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  prefs: []
  type: TYPE_NORMAL
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### Association Proxy
    Missing Scalar returns None'
  prefs: []
  type: TYPE_NORMAL
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()
    will query from the DB by default if value not present'
  prefs: []
  type: TYPE_NORMAL
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a small change demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ## Behavioral Changes
    - Core'
  prefs: []
  type: TYPE_NORMAL
- en: Type objects no longer accept ignored keyword arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  prefs: []
  type: TYPE_NORMAL
- en: '`None` can no longer be used as a “partial AND” constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct code for both 0.8 and 0.9 should read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  prefs: []
  type: TYPE_NORMAL
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### The precedence rules
    for COLLATE have been changed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.8, this produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM now applies quoting to values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Event Removal API'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  prefs: []
  type: TYPE_NORMAL
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### New Query Options
    API; `load_only()` option'
  prefs: []
  type: TYPE_NORMAL
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  prefs: []
  type: TYPE_NORMAL
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The Load Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Load Only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Class-specific Wildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### New `text()` Capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### INSERT from SELECT'
  prefs: []
  type: TYPE_NORMAL
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### New FOR UPDATE support
    on `select()`, `Query()`'
  prefs: []
  type: TYPE_NORMAL
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'On Posgtresql the above statement might render like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.  ### Floating Point String-Conversion
    Precision Configurable for Native Floating Point Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### Column Bundles for
    ORM queries'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  prefs: []
  type: TYPE_NORMAL
- en: Server Side Version Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `include_backrefs=False` option for `@validates`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL JSON Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automap Extension'
  prefs: []
  type: TYPE_NORMAL
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](../orm/extensions/automap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improvements that should produce no compatibility issues except in exceedingly
    rare and unusual hypothetical cases, but are good to be aware of in case there
    are unexpected issues.
  prefs: []
  type: TYPE_NORMAL
- en: '### Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped in
    (SELECT * FROM ..) AS ANON_1'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  prefs: []
  type: TYPE_NORMAL
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Generates (everywhere except SQLite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    Right-nested inner joins available in joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a joined eager load chain like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This feature is new in 0.9.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  prefs: []
  type: TYPE_NORMAL
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  prefs: []
  type: TYPE_NORMAL
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  prefs: []
  type: TYPE_NORMAL
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### Backref handlers
    can now propagate more than one level deep'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  prefs: []
  type: TYPE_NORMAL
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### The typing system
    now handles the task of rendering “literal bind” values'
  prefs: []
  type: TYPE_NORMAL
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### Schema identifiers
    now carry along their own quoting information'
  prefs: []
  type: TYPE_NORMAL
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  prefs: []
  type: TYPE_NORMAL
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### Improved rendering
    of Boolean constants, NULL constants, conjunctions'
  prefs: []
  type: TYPE_NORMAL
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a table such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### Label constructs
    can now render as their name alone in an ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. an example like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to 0.9 would render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  prefs: []
  type: TYPE_NORMAL
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy` now has
    tuple-sorting behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### A bindparam() construct
    with no type gets upgraded via copy when a type is available'
  prefs: []
  type: TYPE_NORMAL
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  prefs: []
  type: TYPE_NORMAL
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### Columns can reliably
    get their type from a column referred to via ForeignKey'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  prefs: []
  type: TYPE_NORMAL
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenarios which now work correctly include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firebird `fdb` is now the default Firebird dialect.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  prefs: []
  type: TYPE_NORMAL
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.fdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 0.9, and also documents
    changes which affect users migrating their applications from the 0.8 series of
    SQLAlchemy to 0.9.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review [Behavioral Changes - ORM](#behavioral-changes-orm-09)
    and [Behavioral Changes - Core](#behavioral-changes-core-09) for potentially backwards-incompatible
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Platform Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  prefs: []
  type: TYPE_NORMAL
- en: C Extensions Supported on Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  prefs: []
  type: TYPE_NORMAL
- en: Targeting Python 2.6 and Up Now, Python 3 without 2to3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first achievement of the 0.9 release is to remove the dependency on the
    2to3 tool for Python 3 compatibility. To make this more straightforward, the lowest
    Python release targeted now is 2.6, which features a wide degree of cross-compatibility
    with Python 3\. All SQLAlchemy modules and unit tests are now interpreted equally
    well with any Python interpreter from 2.6 forward, including the 3.1 and 3.2 interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2671](https://www.sqlalchemy.org/trac/ticket/2671)'
  prefs: []
  type: TYPE_NORMAL
- en: C Extensions Supported on Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C extensions have been ported to support Python 3 and now build in both
    Python 2 and Python 3 environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2161](https://www.sqlalchemy.org/trac/ticket/2161)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Behavioral Changes - ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '### Composite attributes are now returned as their object form when queried
    on a per-attribute basis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Bundles for ORM queries](#change-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)  ### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example against the usual `User` mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement predictably renders SQL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)  ### `viewonly=True` on
    `relationship()` prevents history from taking effect'
  prefs: []
  type: TYPE_NORMAL
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)  ### Association Proxy
    SQL Expression Improvements and Fixes'
  prefs: []
  type: TYPE_NORMAL
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Up through 0.8, a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, it now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  prefs: []
  type: TYPE_NORMAL
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)  ### Association Proxy
    Missing Scalar returns None'
  prefs: []
  type: TYPE_NORMAL
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)  ### attributes.get_history()
    will query from the DB by default if value not present'
  prefs: []
  type: TYPE_NORMAL
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a small change demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)  ### Composite attributes
    are now returned as their object form when queried on a per-attribute basis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    in conjunction with a composite attribute now returns the object type maintained
    by that composite, rather than being broken out into individual columns. Using
    the mapping setup at [Composite Column Types](../orm/composites.html#mapper-composite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This change is backwards-incompatible with code that expects the individual
    attribute to be expanded into individual columns. To get that behavior, use the
    `.clauses` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Bundles for ORM queries](#change-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '### [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") no longer applies the clause to corresponding
    entities'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method has been popularized in recent versions
    as a means of controlling the first thing that a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object “selects from”, typically for the purposes of controlling
    how a JOIN will render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example against the usual `User` mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement predictably renders SQL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to reverse the order of the left and right elements of the JOIN,
    the documentation would lead us to believe we could use [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in version 0.8 and earlier, the above use of [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") would apply the `select_stmt` to **replace**
    the `User` entity, as it selects from the `user` table which is compatible with
    `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The above statement is a mess, the ON clause refers `anon_1.id = anon_1.id`,
    our WHERE clause has been replaced with `anon_1` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is quite intentional, but has a different use case from that
    which has become popular for [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from"). The above behavior is now available by a
    new method known as `Query.select_entity_from()`. This is a lesser used behavior
    that in modern SQLAlchemy is roughly equivalent to selecting from a customized
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'So with SQLAlchemy 0.9, our query that selects from `select_stmt` produces
    the SQL we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The `Query.select_entity_from()` method will be available in SQLAlchemy **0.8.2**,
    so applications which rely on the old behavior can transition to this method first,
    ensure all tests continue to function, then upgrade to 0.9 without issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2736](https://www.sqlalchemy.org/trac/ticket/2736)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `viewonly=True` on `relationship()` prevents history from taking effect'
  prefs: []
  type: TYPE_NORMAL
- en: The `viewonly` flag on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is applied to prevent changes to the target attribute
    from having any effect within the flush process. This is achieved by eliminating
    the attribute from being considered during the flush. However, up until now, changes
    to the attribute would still register the parent object as “dirty” and trigger
    a potential flush. The change is that the `viewonly` flag now prevents history
    from being set for the target attribute as well. Attribute events like backrefs
    and user-defined events still continue to function normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[#2833](https://www.sqlalchemy.org/trac/ticket/2833)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Association Proxy SQL Expression Improvements and Fixes'
  prefs: []
  type: TYPE_NORMAL
- en: The `==` and `!=` operators as implemented by an association proxy that refers
    to a scalar value on a scalar relationship now produces a more complete SQL expression,
    intended to take into account the “association” row being present or not when
    the comparison is against `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Up through 0.8, a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, it now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The difference being, it not only checks `b.value`, it also checks if `a` refers
    to no `b` row at all. This will return different results versus prior versions,
    for a system that uses this type of comparison where some parent rows have no
    association row.
  prefs: []
  type: TYPE_NORMAL
- en: 'More critically, a correct expression is emitted for `A.b_value != None`. In
    0.8, this would return `True` for `A` rows that had no `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in 0.9, the check has been reworked so that it ensures the A.b_id row is
    present, in addition to `B.value` being non-NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `has()` operator is enhanced such that you can call it against
    a scalar column value with no criterion only, and it will produce criteria that
    checks for the association row being present or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to `A.b.has()`, but allows one to query against `b_value`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2751](https://www.sqlalchemy.org/trac/ticket/2751)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Association Proxy Missing Scalar returns None'
  prefs: []
  type: TYPE_NORMAL
- en: 'An association proxy from a scalar attribute to a scalar will now return `None`
    if the proxied object isn’t present. This is consistent with the fact that missing
    many-to-ones return None in SQLAlchemy, so should the proxied value. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[#2810](https://www.sqlalchemy.org/trac/ticket/2810)'
  prefs: []
  type: TYPE_NORMAL
- en: '### attributes.get_history() will query from the DB by default if value not
    present'
  prefs: []
  type: TYPE_NORMAL
- en: A bugfix regarding [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") allows a column-based attribute to query
    out to the database for an unloaded value, assuming the `passive` flag is left
    at its default of `PASSIVE_OFF`. Previously, this flag would not be honored. Additionally,
    a new method [`AttributeState.load_history()`](../orm/internals.html#sqlalchemy.orm.AttributeState.load_history
    "sqlalchemy.orm.AttributeState.load_history") is added to complement the [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") attribute, which will emit loader callables
    for an unloaded attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a small change demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[#2787](https://www.sqlalchemy.org/trac/ticket/2787)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Behavioral Changes - Core'
  prefs: []
  type: TYPE_NORMAL
- en: Type objects no longer accept ignored keyword arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  prefs: []
  type: TYPE_NORMAL
- en: '`None` can no longer be used as a “partial AND” constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct code for both 0.8 and 0.9 should read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  prefs: []
  type: TYPE_NORMAL
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)  ### The precedence rules
    for COLLATE have been changed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.8, this produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)  ### PostgreSQL CREATE
    TYPE <x> AS ENUM now applies quoting to values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  prefs: []
  type: TYPE_NORMAL
- en: Type objects no longer accept ignored keyword arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up through the 0.8 series, most type objects accepted arbitrary keyword arguments
    which were silently ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a very old bug for which a deprecation warning was added to the 0.8
    series, but because nobody ever runs Python with the “-W” flag, it was mostly
    never seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: As of the 0.9 series the “catch all” constructor is removed from [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), and these meaningless arguments are no longer
    accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to make use of dialect-specific arguments such as `storage_format`
    and `display_width` is to use the appropriate dialect-specific types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the case where we want the dialect-agnostic type also? We use the
    [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") isn’t new, it was added in SQLAlchemy
    0.7.2\. So code that is running on the 0.8 series can be corrected to use this
    approach and tested before upgrading to 0.9.'
  prefs: []
  type: TYPE_NORMAL
- en: '`None` can no longer be used as a “partial AND” constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`None` can no longer be used as the “backstop” to form an AND condition piecemeal.
    This pattern was not a documented pattern even though some SQLAlchemy internals
    made use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The above sequence, when `conditions` is non-empty, will on 0.9 produce `SELECT
    .. WHERE <condition> AND NULL`. The `None` is no longer implicitly ignored, and
    is instead consistent with when `None` is interpreted in other contexts besides
    that of a conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct code for both 0.8 and 0.9 should read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variant that works on all backends on 0.9, but on 0.8 only works on
    backends that support boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: On 0.8, this will produce a SELECT statement that always has `AND true` in the
    WHERE clause, which is not accepted by backends that don’t support boolean constants
    (MySQL, MSSQL). On 0.9, the `true` constant will be dropped within an `and_()`
    conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved rendering of Boolean constants, NULL constants, conjunctions](#migration-2804)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The “password” portion of a `create_engine()` no longer considers the `+`
    sign as an encoded space'
  prefs: []
  type: TYPE_NORMAL
- en: 'For whatever reason, the Python function `unquote_plus()` was applied to the
    “password” field of a URL, which is an incorrect application of the encoding rules
    described in [RFC 1738](https://www.ietf.org/rfc/rfc1738.txt) in that it escaped
    spaces as plus signs. The stringification of a URL now only encodes “:”, “@”,
    or “/” and nothing else, and is now applied to both the `username` and `password`
    fields (previously it only applied to the password). On parsing, encoded characters
    are converted, but plus signs and spaces are passed through as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[#2873](https://www.sqlalchemy.org/trac/ticket/2873)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The precedence rules for COLLATE have been changed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'would produce an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is misunderstood by MSSQL and is generally not the syntax suggested
    for any database. The expression will now produce the syntax illustrated by that
    of most database documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The potentially backwards incompatible change arises if the [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator is being applied
    to the right-hand column, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.8, this produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'However in 0.9, will now produce the more accurate, but probably not what you
    want, form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") operator now works more appropriately
    within an `ORDER BY` expression as well, as a specific precedence has been given
    to the `ASC` and `DESC` operators which will again ensure no parentheses are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[#2879](https://www.sqlalchemy.org/trac/ticket/2879)'
  prefs: []
  type: TYPE_NORMAL
- en: '### PostgreSQL CREATE TYPE <x> AS ENUM now applies quoting to values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type will now apply escaping to single
    quote signs within the enumerated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Existing workarounds which already escape single quote signs will need to be
    modified, else they will now double-escape.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2878](https://www.sqlalchemy.org/trac/ticket/2878)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Event Removal API'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  prefs: []
  type: TYPE_NORMAL
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)  ### New Query Options
    API; `load_only()` option'
  prefs: []
  type: TYPE_NORMAL
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  prefs: []
  type: TYPE_NORMAL
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The Load Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Load Only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Class-specific Wildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)  ### New `text()` Capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)  ### INSERT from SELECT'
  prefs: []
  type: TYPE_NORMAL
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)  ### New FOR UPDATE support
    on `select()`, `Query()`'
  prefs: []
  type: TYPE_NORMAL
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'On Posgtresql the above statement might render like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.  ### Floating Point String-Conversion
    Precision Configurable for Native Floating Point Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)  ### Column Bundles for
    ORM queries'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  prefs: []
  type: TYPE_NORMAL
- en: Server Side Version Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `include_backrefs=False` option for `@validates`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL JSON Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automap Extension'
  prefs: []
  type: TYPE_NORMAL
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](../orm/extensions/automap.html)  ### Event Removal API'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events established using [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") or [`listens_for()`](../core/event.html#sqlalchemy.event.listens_for
    "sqlalchemy.event.listens_for") can now be removed using the new [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove") function. The `target`, `identifier` and `fn` arguments
    sent to [`remove()`](../core/event.html#sqlalchemy.event.remove "sqlalchemy.event.remove")
    need to match exactly those which were sent for listening, and the event will
    be removed from all locations in which it had been established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, the `propagate=True` flag is set. This means `my_before_insert()`
    is established as a listener for `MyClass` as well as all subclasses of `MyClass`.
    The system tracks everywhere that the `my_before_insert()` listener function had
    been placed as a result of this call and removes it as a result of calling [`remove()`](../core/event.html#sqlalchemy.event.remove
    "sqlalchemy.event.remove").
  prefs: []
  type: TYPE_NORMAL
- en: The removal system uses a registry to associate arguments passed to [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") with collections of event listeners, which are in many
    cases wrapped versions of the original user-supplied function. This registry makes
    heavy use of weak references in order to allow all the contained contents, such
    as listener targets, to be garbage collected when they go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2268](https://www.sqlalchemy.org/trac/ticket/2268)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New Query Options API; `load_only()` option'
  prefs: []
  type: TYPE_NORMAL
- en: The system of loader options such as [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload"), [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), etc. all build upon a new system known as [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load"). [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") provides a “method chained” (a.k.a. [generative](../glossary.html#term-generative))
    approach to loader options, so that instead of joining together long paths using
    dots or multiple attribute names, an explicit loader style is given for each path.
  prefs: []
  type: TYPE_NORMAL
- en: While the new way is slightly more verbose, it is simpler to understand in that
    there is no ambiguity in what options are being applied to which paths; it simplifies
    the method signatures of the options and provides greater flexibility particularly
    for column-based options. The old systems are to remain functional indefinitely
    as well and all styles can be mixed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a certain style of loading along every link in a multi-element path,
    the `_all()` option has to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader options are now chainable, so the same `joinedload(x)` method is applied
    equally to each link, without the need to keep straight between [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and `joinedload_all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an option on path that is based on a subclass requires that all links
    in the path be spelled out as class bound attributes, since the [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method needs to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only those elements in the path that actually need [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") need to be set as a class-bound attribute,
    string-based names can be resumed afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the loader option on the last link in a long path uses a syntax that
    looks a lot like it should be setting the option for all links in the path, causing
    confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A path can now be spelled out using [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") for entries in the path where the existing loader
    style should be unchanged. More verbose but the intent is clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'The dotted style can still be taken advantage of, particularly in the case
    of skipping over several path elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '**Old Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option on a path needed to be spelled out with the full path for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '**New Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") object that arrives at the target path can have [`Load.defer()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.defer
    "sqlalchemy.orm.Load.defer") called upon it repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The Load Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Load Only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Class-specific Wildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
  prefs: []
  type: TYPE_NORMAL
- en: The Load Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    class can be used directly to provide a “bound” target, especially when multiple
    parent entities are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Load Only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new option [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") achieves a “defer everything but” style of load, loading
    only the given columns and deferring the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Class-specific Wildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load"),
    a wildcard may be used to set the loading for all relationships (or perhaps columns)
    on a given entity, without affecting any others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[#1418](https://www.sqlalchemy.org/trac/ticket/1418)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New `text()` Capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct gains new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`TextClause.bindparams()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams
    "sqlalchemy.sql.expression.TextClause.bindparams") allows bound parameter types
    and values to be set flexibly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") supersedes the `typemap` option
    of [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"),
    returning a new construct `TextAsFrom`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#2877](https://www.sqlalchemy.org/trac/ticket/2877)'
  prefs: []
  type: TYPE_NORMAL
- en: '### INSERT from SELECT'
  prefs: []
  type: TYPE_NORMAL
- en: 'After literally years of pointless procrastination this relatively minor syntactical
    feature has been added, and is also backported to 0.8.3, so technically isn’t
    “new” in 0.9\. A [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct or other compatible construct can
    be passed to the new method [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") where it will be used to render
    an `INSERT .. SELECT` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The construct is smart enough to also accommodate ORM objects such as classes
    and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[#722](https://www.sqlalchemy.org/trac/ticket/722)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New FOR UPDATE support on `select()`, `Query()`'
  prefs: []
  type: TYPE_NORMAL
- en: An attempt is made to simplify the specification of the `FOR UPDATE` clause
    on `SELECT` statements made within Core and ORM, and support is added for the
    `FOR UPDATE OF` SQL supported by PostgreSQL and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the core [`GenerativeSelect.with_for_update()`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update"), options like `FOR
    SHARE` and `NOWAIT` can be specified individually, rather than linking to arbitrary
    string codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'On Posgtresql the above statement might render like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object gains a similar method [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") which behaves in the same way. This method
    supersedes the existing `Query.with_lockmode()` method, which translated `FOR
    UPDATE` clauses using a different system. At the moment, the “lockmode” string
    argument is still accepted by the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method.
  prefs: []
  type: TYPE_NORMAL
- en: '### Floating Point String-Conversion Precision Configurable for Native Floating
    Point Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion which SQLAlchemy does whenever a DBAPI returns a Python floating
    point type which is to be converted into a Python `Decimal()` necessarily involves
    an intermediary step which converts the floating point value to a string. The
    scale used for this string conversion was previously hardcoded to 10, and is now
    configurable. The setting is available on both the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") as well as the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type, as well as all SQL- and dialect-specific descendant
    types, using the parameter `decimal_return_scale`. If the type supports a `.scale`
    parameter, as is the case with [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") and some float types such as `DOUBLE`, the value of
    `.scale` is used as the default for `.decimal_return_scale` if it is not otherwise
    specified. If both `.scale` and `.decimal_return_scale` are absent, then the default
    of 10 takes place. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[#2867](https://www.sqlalchemy.org/trac/ticket/2867)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Column Bundles for ORM queries'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    allows for querying of sets of columns, which are then grouped into one name under
    the tuple returned by the query. The initial purposes of [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle
    "sqlalchemy.orm.Bundle") are 1\. to allow “composite” ORM columns to be returned
    as a single value in a column-based result set, rather than expanding them out
    into individual columns and 2\. to allow the creation of custom result-set constructs
    within the ORM, using ad-hoc columns and return types, without involving the more
    heavyweight mechanics of mapped classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composite attributes are now returned as their object form when queried on
    a per-attribute basis](#migration-2824)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2824](https://www.sqlalchemy.org/trac/ticket/2824)'
  prefs: []
  type: TYPE_NORMAL
- en: Server Side Version Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The versioning feature of the ORM (now also documented at [Configuring a Version
    Counter](../orm/versioning.html#mapper-version-counter)) can now make use of server-side
    version counting schemes, such as those produced by triggers or database system
    columns, as well as conditional programmatic schemes outside of the version_id_counter
    function itself. By providing the value `False` to the `version_id_generator`
    parameter, the ORM will use the already-set version identifier, or alternatively
    fetch the version identifier from each row at the same time the INSERT or UPDATE
    is emitted. When using a server-generated version identifier, it is strongly recommended
    that this feature be used only on a backend with strong RETURNING support (PostgreSQL,
    SQL Server; Oracle also supports RETURNING but the cx_oracle driver has only limited
    support), else the additional SELECT statements will add significant performance
    overhead. The example provided at [Server Side Version Counters](../orm/versioning.html#server-side-version-counter)
    illustrates the usage of the PostgreSQL `xmin` system column in order to integrate
    it with the ORM’s versioning feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Server Side Version Counters](../orm/versioning.html#server-side-version-counter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2793](https://www.sqlalchemy.org/trac/ticket/2793)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `include_backrefs=False` option for `@validates`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") function now accepts an option `include_backrefs=True`,
    which will bypass firing the validator for the case where the event initiated
    from a backref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[#1535](https://www.sqlalchemy.org/trac/ticket/1535)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL JSON Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now features a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") type to complement the [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2581](https://www.sqlalchemy.org/trac/ticket/2581)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automap Extension'
  prefs: []
  type: TYPE_NORMAL
- en: A new extension is added in **0.9.1** known as [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap"). This is an **experimental** extension which expands
    upon the functionality of Declarative as well as the [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") class. Essentially, the extension
    provides a base class [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") which automatically generates mapped classes
    and relationships between them based on given table metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    in use normally might be produced via reflection, but there is no requirement
    that reflection is used. The most basic usage illustrates how [`sqlalchemy.ext.automap`](../orm/extensions/automap.html#module-sqlalchemy.ext.automap
    "sqlalchemy.ext.automap") is able to deliver mapped classes, including relationships,
    based on a reflected schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Beyond that, the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") class is a declarative base, and supports
    all the features that declarative does. The “automapping” feature can be used
    with an existing, explicitly declared schema to generate relationships and missing
    classes only. Naming schemes and relationship-production routines can be dropped
    in using callable functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is hoped that the [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") system provides a quick and modernized solution
    to the problem that the very famous [SQLSoup](https://sqlsoup.readthedocs.io/en/latest/)
    also tries to solve, that of generating a quick and rudimentary object model from
    an existing database on the fly. By addressing the issue strictly at the mapper
    configuration level, and integrating fully with existing Declarative class techniques,
    [`AutomapBase`](../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase
    "sqlalchemy.ext.automap.AutomapBase") seeks to provide a well-integrated approach
    to the issue of expediently auto-generating ad-hoc mappings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](../orm/extensions/automap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improvements that should produce no compatibility issues except in exceedingly
    rare and unusual hypothetical cases, but are good to be aware of in case there
    are unexpected issues.
  prefs: []
  type: TYPE_NORMAL
- en: '### Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped in
    (SELECT * FROM ..) AS ANON_1'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  prefs: []
  type: TYPE_NORMAL
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Generates (everywhere except SQLite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)  ###
    Right-nested inner joins available in joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a joined eager load chain like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: This feature is new in 0.9.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  prefs: []
  type: TYPE_NORMAL
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  prefs: []
  type: TYPE_NORMAL
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  prefs: []
  type: TYPE_NORMAL
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)  ### Backref handlers
    can now propagate more than one level deep'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  prefs: []
  type: TYPE_NORMAL
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)  ### The typing system
    now handles the task of rendering “literal bind” values'
  prefs: []
  type: TYPE_NORMAL
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)  ### Schema identifiers
    now carry along their own quoting information'
  prefs: []
  type: TYPE_NORMAL
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  prefs: []
  type: TYPE_NORMAL
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)  ### Improved rendering
    of Boolean constants, NULL constants, conjunctions'
  prefs: []
  type: TYPE_NORMAL
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a table such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)  ### Label constructs
    can now render as their name alone in an ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. an example like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to 0.9 would render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'And now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  prefs: []
  type: TYPE_NORMAL
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)  ### `RowProxy` now has
    tuple-sorting behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)  ### A bindparam() construct
    with no type gets upgraded via copy when a type is available'
  prefs: []
  type: TYPE_NORMAL
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  prefs: []
  type: TYPE_NORMAL
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)  ### Columns can reliably
    get their type from a column referred to via ForeignKey'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  prefs: []
  type: TYPE_NORMAL
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenarios which now work correctly include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)  ### Many JOIN and LEFT
    OUTER JOIN expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many years, the SQLAlchemy ORM has been held back from being able to nest
    a JOIN inside the right side of an existing JOIN (typically a LEFT OUTER JOIN,
    as INNER JOINs could always be flattened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'This was due to the fact that SQLite up until version **3.7.16** cannot parse
    a statement of the above format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-outer-joins are of course another way to work around right-side parenthesization;
    this would be significantly complicated and visually unpleasant to implement,
    but fortunately SQLite doesn’t support RIGHT OUTER JOIN either :):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in 2005, it wasn’t clear if other databases had trouble with this form,
    but today it seems clear every database tested except SQLite now supports it (Oracle
    8, a very old database, doesn’t support the JOIN keyword at all, but SQLAlchemy
    has always had a simple rewriting scheme in place for Oracle’s syntax). To make
    matters worse, SQLAlchemy’s usual workaround of applying a SELECT often degrades
    performance on platforms like PostgreSQL and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: A JOIN like the above form is commonplace when working with joined-table inheritance
    structures; any time [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is used to join from some parent to a joined-table
    subclass, or when [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") is used similarly, SQLAlchemy’s ORM would always
    make sure a nested JOIN was never rendered, lest the query wouldn’t be able to
    run on SQLite. Even though the Core has always supported a JOIN of the more compact
    form, the ORM had to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional issue would arise when producing joins across many-to-many relationships
    where special criteria is present in the ON clause. Consider an eager load join
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming a many-to-many from `Order` to `Item` which actually refers to a subclass
    like `Subitem`, the SQL for the above would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: What’s wrong with the above query? Basically, that it will load many `order`
    / `order_item` rows where the criteria of `item.type == 'subitem'` is not true.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 0.9, an entirely new approach has been taken. The ORM no longer
    worries about nesting JOINs in the right side of an enclosing JOIN, and it now
    will render these as often as possible while still returning the correct results.
    When the SQL statement is passed to be compiled, the **dialect compiler** will
    **rewrite the join** to suit the target backend, if that backend is known to not
    support a right-nested JOIN (which currently is only SQLite - if other backends
    have this issue please let us know!).
  prefs: []
  type: TYPE_NORMAL
- en: 'So a regular `query(Parent).join(Subclass)` will now usually produce a simpler
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'Joined eager loads like `query(Parent).options(joinedload(Parent.subclasses))`
    will alias the individual tables instead of wrapping in an `ANON_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Many-to-many joins and eagerloads will right nest the “secondary” and “right”
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these joins, when rendered with a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement that specifically specifies `use_labels=True`,
    which is true for all the queries the ORM emits, are candidates for “join rewriting”,
    which is the process of rewriting all those right-nested joins into nested SELECT
    statements, while maintaining the identical labeling used by the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"). So SQLite, the one database that won’t support
    this very common SQL syntax even in 2013, shoulders the extra complexity itself,
    with the above queries rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLAlchemy 1.1, the workarounds present in this feature for SQLite will
    automatically disable themselves when SQLite version **3.7.16** or greater is
    detected, as SQLite has repaired support for right-nested joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Join.alias()`, [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") and [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") functions now support a new argument, `flat=True`,
    which is used to construct aliases of joined-table entities without embedding
    into a SELECT. This flag is not on by default, to help with backwards compatibility
    - but now a “polymorphic” selectable can be joined as a target without any subqueries
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Generates (everywhere except SQLite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[#2369](https://www.sqlalchemy.org/trac/ticket/2369) [#2587](https://www.sqlalchemy.org/trac/ticket/2587)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Right-nested inner joins available in joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 0.9.4, the above mentioned right-nested joining can be enabled
    in the case of a joined eager load where an “outer” join is linked to an “inner”
    on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a joined eager load chain like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Would not produce an inner join; because of the LEFT OUTER JOIN from user->order,
    joined eager loading could not use an INNER join from order->items without changing
    the user rows that are returned, and would instead ignore the “chained” `innerjoin=True`
    directive. How 0.9.0 should have delivered this would be that instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'the new “right-nested joins are OK” logic would kick in, and we’d get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we missed the boat on that, to avoid further regressions we’ve added
    the above functionality by specifying the string `"nested"` to [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: This feature is new in 0.9.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2976](https://www.sqlalchemy.org/trac/ticket/2976)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM can efficiently fetch just-generated INSERT/UPDATE defaults using RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    has long supported an undocumented flag known as `eager_defaults=True`. The effect
    of this flag is that when an INSERT or UPDATE proceeds, and the row is known to
    have server-generated default values, a SELECT would immediately follow it in
    order to “eagerly” load those new values. Normally, the server-generated columns
    are marked as “expired” on the object, so that no overhead is incurred unless
    the application actually accesses these columns soon after the flush. The `eager_defaults`
    flag was therefore not of much use as it could only decrease performance, and
    was present only to support exotic event schemes where users needed default values
    to be available immediately within the flush process.
  prefs: []
  type: TYPE_NORMAL
- en: In 0.9, as a result of the version id enhancements, `eager_defaults` can now
    emit a RETURNING clause for these values, so on a backend with strong RETURNING
    support in particular PostgreSQL, the ORM can fetch newly generated default and
    SQL expression values inline with the INSERT or UPDATE. `eager_defaults`, when
    enabled, makes use of RETURNING automatically when the target backend and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") supports “implicit returning”.
  prefs: []
  type: TYPE_NORMAL
- en: '### Subquery Eager Loading will apply DISTINCT to the innermost SELECT for
    some queries'
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to reduce the number of duplicate rows that can be generated by
    subquery eager loading when a many-to-one relationship is involved, a DISTINCT
    keyword will be applied to the innermost SELECT when the join is targeting columns
    that do not comprise the primary key, as in when loading along a many to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, when subquery loading on a many-to-one from A->B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Since `a.b_id` is a non-distinct foreign key, DISTINCT is applied so that redundant
    `a.b_id` are eliminated. The behavior can be turned on or off unconditionally
    for a particular [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the flag `distinct_target_key`, setting the
    value to `True` for unconditionally on, `False` for unconditionally off, and `None`
    for the feature to take effect when the target SELECT is against columns that
    do not comprise a full primary key. In 0.9, `None` is the default.
  prefs: []
  type: TYPE_NORMAL
- en: The option is also backported to 0.8 where the `distinct_target_key` option
    defaults to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: While the feature here is designed to help performance by eliminating duplicate
    rows, the `DISTINCT` keyword in SQL itself can have a negative performance impact.
    If columns in the SELECT are not indexed, `DISTINCT` will likely perform an `ORDER
    BY` on the rowset which can be expensive. By keeping the feature limited just
    to foreign keys which are hopefully indexed in any case, it’s expected that the
    new defaults are reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: The feature also does not eliminate every possible dupe-row scenario; if a many-to-one
    is present elsewhere in the chain of joins, dupe rows may still be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2836](https://www.sqlalchemy.org/trac/ticket/2836)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Backref handlers can now propagate more than one level deep'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism by which attribute events pass along their “initiator”, that is
    the object associated with the start of the event, has been changed; instead of
    a `AttributeImpl` being passed, a new object `Event` is passed instead; this object
    refers to the `AttributeImpl` as well as to an “operation token”, representing
    if the operation is an append, remove, or replace operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attribute event system no longer looks at this “initiator” object in order
    to halt a recursive series of attribute events. Instead, the system of preventing
    endless recursion due to mutually-dependent backref handlers has been moved to
    the ORM backref event handlers specifically, which now take over the role of ensuring
    that a chain of mutually-dependent events (such as append to collection A.bs,
    set many-to-one attribute B.a in response) doesn’t go into an endless recursion
    stream. The rationale here is that the backref system, given more detail and control
    over event propagation, can finally allow operations more than one level deep
    to occur; the typical scenario is when a collection append results in a many-to-one
    replacement operation, which in turn should cause the item to be removed from
    a previous collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to this change, the `c1` object would still have been present in
    `p1.children`, even though it is also present in `p2.children` at the same time;
    the backref handlers would have stopped at replacing `c1.parent` with `p2` instead
    of `p1`. In 0.9, using the more detailed `Event` object as well as letting the
    backref handlers make more detailed decisions about these objects, the propagation
    can continue onto removing `c1` from `p1.children` while maintaining a check against
    the propagation from going into an endless recursive loop.
  prefs: []
  type: TYPE_NORMAL
- en: End-user code which a. makes use of the [`AttributeEvents.set()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.set
    "sqlalchemy.orm.AttributeEvents.set"), [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append"), or [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events, and b. initiates further attribute
    modification operations as a result of these events may need to be modified to
    prevent recursive loops, as the attribute system no longer stops a chain of events
    from propagating endlessly in the absence of the backref event handlers. Additionally,
    code which depends upon the value of the `initiator` will need to be adjusted
    to the new API, and furthermore must be ready for the value of `initiator` to
    change from its original value within a string of backref-initiated events, as
    the backref handlers may now swap in a new `initiator` value for some operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2789](https://www.sqlalchemy.org/trac/ticket/2789)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The typing system now handles the task of rendering “literal bind” values'
  prefs: []
  type: TYPE_NORMAL
- en: A new method is added to [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") as well as [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") which take on the task of rendering so-called
    “inline literal parameters” - parameters that normally render as “bound” values,
    but are instead being rendered inline into the SQL statement due to the compiler
    configuration. This feature is used when generating DDL for constructs such as
    [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), as well as by Alembic when using constructs
    such as `op.inline_literal()`. Previously, a simple “isinstance” check checked
    for a few basic types, and the “bind processor” was used unconditionally, leading
    to such issues as strings being encoded into utf-8 prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types written with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should continue to work in “inline literal”
    scenarios, as the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") falls back to [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") by default, as these methods
    usually handle a data manipulation, not as much how the data is presented to the
    database. [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") can be specified to specifically
    produce a string representing how a value should be rendered into an inline DDL
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2838](https://www.sqlalchemy.org/trac/ticket/2838)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Schema identifiers now carry along their own quoting information'
  prefs: []
  type: TYPE_NORMAL
- en: This change simplifies the Core’s usage of so-called “quote” flags, such as
    the `quote` flag passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The flag is now internalized within the string name
    itself, which is now represented as an instance of [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name"), a string subclass. The [`IdentifierPreparer`](../core/internals.html#sqlalchemy.sql.compiler.IdentifierPreparer
    "sqlalchemy.sql.compiler.IdentifierPreparer") now relies solely on the quoting
    preferences reported by the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object rather than checking for any explicit
    `quote` flags in most cases. The issue resolved here includes that various case-sensitive
    methods such as `Engine.has_table()` as well as similar methods within dialects
    now function with explicitly quoted names, without the need to complicate or introduce
    backwards-incompatible changes to those APIs (many of which are 3rd party) with
    the details of quoting flags - in particular, a wider range of identifiers now
    function correctly with the so-called “uppercase” backends like Oracle, Firebird,
    and DB2 (backends that store and report upon table and column names using all
    uppercase for case insensitive names).
  prefs: []
  type: TYPE_NORMAL
- en: The [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") object is used internally as needed;
    however if other keywords require fixed quoting preferences, the class is available
    publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2812](https://www.sqlalchemy.org/trac/ticket/2812)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improved rendering of Boolean constants, NULL constants, conjunctions'
  prefs: []
  type: TYPE_NORMAL
- en: New capabilities have been added to the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constants, in particular in conjunction with
    [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions as well as the behavior of the WHERE/HAVING clauses in conjunction with
    these types, boolean types overall, and the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a table such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'A select construct will now render the boolean column as a binary expression
    on backends that don’t feature `true`/`false` constant behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](../core/sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    constructs will now exhibit quasi “short circuit” behavior, that is truncating
    a rendered expression, when a [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") or [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") constant is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    can be used as the base to build up an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'The boolean constants [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") themselves render as `0 = 1` and `1 = 1` for
    a backend with no boolean constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Interpretation of `None`, while not particularly valid SQL, is at least now
    consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[#2804](https://www.sqlalchemy.org/trac/ticket/2804)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Label constructs can now render as their name alone in an ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: For the case where a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is used in both the columns clause as well
    as the ORDER BY clause of a SELECT, the label will render as just its name in
    the ORDER BY clause, assuming the underlying dialect reports support of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. an example like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to 0.9 would render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'And now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The ORDER BY only renders the label if the label isn’t further embedded into
    an expression within the ORDER BY, other than a simple `ASC` or `DESC`.
  prefs: []
  type: TYPE_NORMAL
- en: The above format works on all databases tested, but might have compatibility
    issues with older database versions (MySQL 4? Oracle 8? etc.). Based on user reports
    we can add rules that will disable the feature based on database version detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1068](https://www.sqlalchemy.org/trac/ticket/1068)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `RowProxy` now has tuple-sorting behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object acts much like a tuple, but up until now would not sort
    as a tuple if a list of them were sorted using `sorted()`. The `__eq__()` method
    now compares both sides as a tuple and also an `__lt__()` method has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[#2848](https://www.sqlalchemy.org/trac/ticket/2848)'
  prefs: []
  type: TYPE_NORMAL
- en: '### A bindparam() construct with no type gets upgraded via copy when a type
    is available'
  prefs: []
  type: TYPE_NORMAL
- en: The logic which “upgrades” a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct to take on the type of the enclosing
    expression has been improved in two ways. First, the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") object is **copied** before the new type
    is assigned, so that the given [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not mutated in place. Secondly, this
    same operation occurs when an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct is compiled, regarding the “values”
    that were set in the statement via the [`ValuesBase.values()`](../core/dml.html#sqlalchemy.sql.expression.ValuesBase.values
    "sqlalchemy.sql.expression.ValuesBase.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If given an untyped [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: The type for `bp` remains as `NullType`, however if `mytable.c.col` is of type
    `String`, then `expr.right`, that is the right side of the binary expression,
    will take on the `String` type. Previously, `bp` itself would have been changed
    in place to have `String` as its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, this operation occurs in an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `bp` remains unchanged, but the `String` type will be used when the
    statement is executed, which we can see by examining the `binds` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The feature allows custom types to take their expected effect within INSERT/UPDATE
    statements without needing to explicitly specify those types within every [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") expression.
  prefs: []
  type: TYPE_NORMAL
- en: The potentially backwards-compatible changes involve two unlikely scenarios.
    Since the bound parameter is **cloned**, users should not be relying upon making
    in-place changes to a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct once created. Additionally, code
    which uses [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") within an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") or [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") statement which is relying on the fact that
    the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") is not typed according to the column being
    assigned towards will no longer function in that way.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2850](https://www.sqlalchemy.org/trac/ticket/2850)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Columns can reliably get their type from a column referred to via ForeignKey'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a long standing behavior which says that a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") can be declared without a type, as long as that [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is referred to by a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), and the type from the referenced column
    will be copied into this one. The problem has been that this feature never worked
    very well and wasn’t maintained. The core issue was that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") object doesn’t know what target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it refers to until it is asked, typically the first
    time the foreign key is used to construct a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"). So until that time, the parent [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would not have a type, or more specifically, it would
    have a default type of [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType").
  prefs: []
  type: TYPE_NORMAL
- en: While it’s taken a long time, the work to reorganize the initialization of [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects has been completed such that this feature
    can finally work acceptably. At the core of the change is that the [`ForeignKey.column`](../core/constraints.html#sqlalchemy.schema.ForeignKey.column
    "sqlalchemy.schema.ForeignKey.column") attribute no longer lazily initializes
    the location of the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); the issue with this system was that the owning [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") would be stuck with [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") as its type until the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") happened to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the new version, the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") coordinates with the eventual [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") it will refer to using internal attachment events,
    so that the moment the referencing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"), all [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects that refer to it will be sent a message
    that they need to initialize their parent column. This system is more complicated
    but works more solidly; as a bonus, there are now tests in place for a wide variety
    of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    / [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    configuration scenarios and error messages have been improved to be very specific
    to no less than seven different error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenarios which now work correctly include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type on a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is immediately present as soon as the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") becomes associated with the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"); this works no matter which side is configured first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The system now works with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It even works for “multiple hops” - that is, a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") that refers to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that refers to another [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#1765](https://www.sqlalchemy.org/trac/ticket/1765)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firebird `fdb` is now the default Firebird dialect.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  prefs: []
  type: TYPE_NORMAL
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.fdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  prefs: []
  type: TYPE_NORMAL
- en: Firebird `fdb` is now the default Firebird dialect.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `fdb` dialect is now used if an engine is created without a dialect specifier,
    i.e. `firebird://`. `fdb` is a `kinterbasdb` compatible DBAPI which per the Firebird
    project is now their official Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2504](https://www.sqlalchemy.org/trac/ticket/2504)'
  prefs: []
  type: TYPE_NORMAL
- en: Firebird `fdb` and `kinterbasdb` set `retaining=False` by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the `fdb` and `kinterbasdb` DBAPIs support a flag `retaining=True` which
    can be passed to the `commit()` and `rollback()` methods of its connection. The
    documented rationale for this flag is so that the DBAPI can re-use internal transaction
    state for subsequent transactions, for the purposes of improving performance.
    However, newer documentation refers to analyses of Firebird’s “garbage collection”
    which expresses that this flag can have a negative effect on the database’s ability
    to process cleanup tasks, and has been reported as *lowering* performance as a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not clear how this flag is actually usable given this information, and
    as it appears to be only a performance enhancing feature, it now defaults to `False`.
    The value can be controlled by passing the flag `retaining=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") call. This is a new flag which is added as of 0.8.2,
    so applications on 0.8.2 can begin setting this to `True` or `False` as desired.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.fdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlalchemy.dialects.firebird.kinterbasdb`'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions](https://pythonhosted.org/fdb/usage-guide.html#retaining-transactions)
    - information on the “retaining” flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2763](https://www.sqlalchemy.org/trac/ticket/2763)'
  prefs: []
  type: TYPE_NORMAL
