- en: Configuring a Version Counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/versioning.html](https://docs.sqlalchemy.org/en/20/orm/versioning.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    supports management of a [version id column](../glossary.html#term-version-id-column),
    which is a single table column that increments or otherwise updates its value
    each time an `UPDATE` to the mapped table occurs. This value is checked each time
    the ORM emits an `UPDATE` or `DELETE` against the row to ensure that the value
    held in memory matches the database value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Because the versioning feature relies upon comparison of the **in memory** record
    of an object, the feature only applies to the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") process, where the ORM flushes individual in-memory
    rows to the database. It does **not** take effect when performing a multirow UPDATE
    or DELETE using [`Query.update()`](queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods, as these methods only emit an UPDATE or
    DELETE statement but otherwise do not have direct access to the contents of those
    rows being affected.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this feature is to detect when two concurrent transactions are
    modifying the same row at roughly the same time, or alternatively to provide a
    guard against the usage of a “stale” row in a system that might be re-using data
    from a previous transaction without refreshing (e.g. if one sets `expire_on_commit=False`
    with a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it is possible to re-use the data from a previous transaction).
  prefs: []
  type: TYPE_NORMAL
- en: Simple Version Counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward way to track versions is to add an integer column
    to the mapped table, then establish it as the `version_id_col` within the mapper
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is **strongly recommended** that the `version_id` column be made NOT NULL.
    The versioning feature **does not support** a NULL value in the versioning column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above, the `User` mapping tracks integer versions using the column `version_id`.
    When an object of type `User` is first flushed, the `version_id` column will be
    given a value of “1”. Then, an UPDATE of the table later on will always be emitted
    in a manner similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above UPDATE statement is updating the row that not only matches `user.id
    = 1`, it also is requiring that `user.version_id = 1`, where “1” is the last version
    identifier we’ve been known to use on this object. If a transaction elsewhere
    has modified the row independently, this version id will no longer match, and
    the UPDATE statement will report that no rows matched; this is the condition that
    SQLAlchemy tests, that exactly one row matched our UPDATE (or DELETE) statement.
    If zero rows match, that indicates our version of the data is stale, and a [`StaleDataError`](exceptions.html#sqlalchemy.orm.exc.StaleDataError
    "sqlalchemy.orm.exc.StaleDataError") is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '## Custom Version Counters / Types'
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of values or counters can be used for versioning. Common types include
    dates and GUIDs. When using an alternate type or counter scheme, SQLAlchemy provides
    a hook for this scheme using the `version_id_generator` argument, which accepts
    a version generation callable. This callable is passed the value of the current
    known version, and is expected to return the subsequent version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to track the versioning of our `User` class using
    a randomly generated GUID, we could do this (note that some backends support a
    native GUID type, but we illustrate here using a simple string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The persistence engine will call upon `uuid.uuid4()` each time a `User` object
    is subject to an INSERT or an UPDATE. In this case, our version generation function
    can disregard the incoming value of `version`, as the `uuid4()` function generates
    identifiers without any prerequisite value. If we were using a sequential versioning
    scheme such as numeric or a special character system, we could make use of the
    given `version` in order to help determine the subsequent value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Backend-agnostic GUID Type](../core/custom_types.html#custom-guid-type)  ##
    Server Side Version Counters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `version_id_generator` can also be configured to rely upon a value that
    is generated by the database. In this case, the database would need some means
    of generating new identifiers when a row is subject to an INSERT as well as with
    an UPDATE. For the UPDATE case, typically an update trigger is needed, unless
    the database in question supports some other native version identifier. The PostgreSQL
    database in particular supports a system column called [xmin](https://www.postgresql.org/docs/current/static/ddl-system-columns.html)
    which provides UPDATE versioning. We can make use of the PostgreSQL `xmin` column
    to version our `User` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the above mapping, the ORM will rely upon the `xmin` column for automatically
    providing the new value of the version id counter.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM typically does not actively fetch the values of database-generated values
    when it emits an INSERT or UPDATE, instead leaving these columns as “expired”
    and to be fetched when they are next accessed, unless the `eager_defaults` [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") flag is set. However, when a server side version column
    is used, the ORM needs to actively fetch the newly generated value. This is so
    that the version counter is set up *before* any concurrent transaction may update
    it again. This fetching is also best done simultaneously within the INSERT or
    UPDATE statement using [RETURNING](../glossary.html#term-RETURNING), otherwise
    if emitting a SELECT statement afterwards, there is still a potential race condition
    where the version counter may change before it can be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the target database supports RETURNING, an INSERT statement for our `User`
    class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the ORM can acquire any newly generated primary key values along
    with server-generated version identifiers in one statement. When the backend does
    not support RETURNING, an additional SELECT must be emitted for **every** INSERT
    and UPDATE, which is much less efficient, and also introduces the possibility
    of missed version counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is *strongly recommended* that server side version counters only be used
    when absolutely necessary and only on backends that support [RETURNING](../glossary.html#term-RETURNING),
    currently PostgreSQL, Oracle, MariaDB 10.5, SQLite 3.35, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic or Conditional Version Counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When `version_id_generator` is set to False, we can also programmatically (and
    conditionally) set the version identifier on our object in the same way we assign
    any other mapped attribute. Such as if we used our UUID example, but set `version_id_generator`
    to `False`, we can set the version identifier at our choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update our `User` object without incrementing the version counter as
    well; the value of the counter will remain unchanged, and the UPDATE statement
    will still check against the previous value. This may be useful for schemes where
    only certain classes of UPDATE are sensitive to concurrency issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Simple Version Counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward way to track versions is to add an integer column
    to the mapped table, then establish it as the `version_id_col` within the mapper
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is **strongly recommended** that the `version_id` column be made NOT NULL.
    The versioning feature **does not support** a NULL value in the versioning column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above, the `User` mapping tracks integer versions using the column `version_id`.
    When an object of type `User` is first flushed, the `version_id` column will be
    given a value of “1”. Then, an UPDATE of the table later on will always be emitted
    in a manner similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The above UPDATE statement is updating the row that not only matches `user.id
    = 1`, it also is requiring that `user.version_id = 1`, where “1” is the last version
    identifier we’ve been known to use on this object. If a transaction elsewhere
    has modified the row independently, this version id will no longer match, and
    the UPDATE statement will report that no rows matched; this is the condition that
    SQLAlchemy tests, that exactly one row matched our UPDATE (or DELETE) statement.
    If zero rows match, that indicates our version of the data is stale, and a [`StaleDataError`](exceptions.html#sqlalchemy.orm.exc.StaleDataError
    "sqlalchemy.orm.exc.StaleDataError") is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '## Custom Version Counters / Types'
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of values or counters can be used for versioning. Common types include
    dates and GUIDs. When using an alternate type or counter scheme, SQLAlchemy provides
    a hook for this scheme using the `version_id_generator` argument, which accepts
    a version generation callable. This callable is passed the value of the current
    known version, and is expected to return the subsequent version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to track the versioning of our `User` class using
    a randomly generated GUID, we could do this (note that some backends support a
    native GUID type, but we illustrate here using a simple string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The persistence engine will call upon `uuid.uuid4()` each time a `User` object
    is subject to an INSERT or an UPDATE. In this case, our version generation function
    can disregard the incoming value of `version`, as the `uuid4()` function generates
    identifiers without any prerequisite value. If we were using a sequential versioning
    scheme such as numeric or a special character system, we could make use of the
    given `version` in order to help determine the subsequent value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Backend-agnostic GUID Type](../core/custom_types.html#custom-guid-type)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Server Side Version Counters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `version_id_generator` can also be configured to rely upon a value that
    is generated by the database. In this case, the database would need some means
    of generating new identifiers when a row is subject to an INSERT as well as with
    an UPDATE. For the UPDATE case, typically an update trigger is needed, unless
    the database in question supports some other native version identifier. The PostgreSQL
    database in particular supports a system column called [xmin](https://www.postgresql.org/docs/current/static/ddl-system-columns.html)
    which provides UPDATE versioning. We can make use of the PostgreSQL `xmin` column
    to version our `User` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the above mapping, the ORM will rely upon the `xmin` column for automatically
    providing the new value of the version id counter.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM typically does not actively fetch the values of database-generated values
    when it emits an INSERT or UPDATE, instead leaving these columns as “expired”
    and to be fetched when they are next accessed, unless the `eager_defaults` [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") flag is set. However, when a server side version column
    is used, the ORM needs to actively fetch the newly generated value. This is so
    that the version counter is set up *before* any concurrent transaction may update
    it again. This fetching is also best done simultaneously within the INSERT or
    UPDATE statement using [RETURNING](../glossary.html#term-RETURNING), otherwise
    if emitting a SELECT statement afterwards, there is still a potential race condition
    where the version counter may change before it can be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the target database supports RETURNING, an INSERT statement for our `User`
    class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the ORM can acquire any newly generated primary key values along
    with server-generated version identifiers in one statement. When the backend does
    not support RETURNING, an additional SELECT must be emitted for **every** INSERT
    and UPDATE, which is much less efficient, and also introduces the possibility
    of missed version counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is *strongly recommended* that server side version counters only be used
    when absolutely necessary and only on backends that support [RETURNING](../glossary.html#term-RETURNING),
    currently PostgreSQL, Oracle, MariaDB 10.5, SQLite 3.35, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic or Conditional Version Counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When `version_id_generator` is set to False, we can also programmatically (and
    conditionally) set the version identifier on our object in the same way we assign
    any other mapped attribute. Such as if we used our UUID example, but set `version_id_generator`
    to `False`, we can set the version identifier at our choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update our `User` object without incrementing the version counter as
    well; the value of the counter will remain unchanged, and the UPDATE statement
    will still check against the previous value. This may be useful for schemes where
    only certain classes of UPDATE are sensitive to concurrency issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
