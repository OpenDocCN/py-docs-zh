["```py\nclass sqlalchemy.types.TypeEngine\n```", "```py\nclass Comparator\n```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nmethod adapt(cls: Type[TypeEngine | TypeEngineMixin], **kw: Any) \u2192 TypeEngine\n```", "```py\nmethod as_generic(allow_nulltype: bool = False) \u2192 TypeEngine\n```", "```py\n>>> from sqlalchemy.dialects.mysql import INTEGER\n>>> INTEGER(display_width=4).as_generic()\nInteger()\n```", "```py\n>>> from sqlalchemy.dialects.mysql import NVARCHAR\n>>> NVARCHAR(length=100).as_generic()\nUnicode(length=100)\n```", "```py\nmethod bind_expression(bindvalue: BindParameter[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nmethod bind_processor(dialect: Dialect) \u2192 _BindProcessorType[_T] | None\n```", "```py\nmethod coerce_compared_value(op: OperatorType | None, value: Any) \u2192 TypeEngine[Any]\n```", "```py\nmethod column_expression(colexpr: ColumnElement[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nattribute comparator_factory\n```", "```py\nmethod compare_values(x: Any, y: Any) \u2192 bool\n```", "```py\nmethod compile(dialect: Dialect | None = None) \u2192 str\n```", "```py\nmethod dialect_impl(dialect: Dialect) \u2192 TypeEngine[_T]\n```", "```py\nmethod evaluates_none() \u2192 Self\n```", "```py\nTable(\n    'some_table', metadata,\n    Column(\n        String(50).evaluates_none(),\n        nullable=True,\n        server_default='no value')\n)\n```", "```py\nmethod get_dbapi_type(dbapi: module) \u2192 Any | None\n```", "```py\nattribute hashable = True\n```", "```py\nmethod literal_processor(dialect: Dialect) \u2192 _LiteralProcessorType[_T] | None\n```", "```py\nattribute python_type\n```", "```py\nattribute render_bind_cast = False\n```", "```py\nattribute render_literal_cast = False\n```", "```py\nmethod result_processor(dialect: Dialect, coltype: object) \u2192 _ResultProcessorType[_T] | None\n```", "```py\nattribute should_evaluate_none: bool = False\n```", "```py\nattribute sort_key_function: Callable[[Any], Any] | None = None\n```", "```py\nmethod with_variant(type_: _TypeEngineArgument[Any], *dialect_names: str) \u2192 Self\n```", "```py\nfrom sqlalchemy.types import String\nfrom sqlalchemy.dialects import mysql\n\nstring_type = String()\n\nstring_type = string_type.with_variant(\n    mysql.VARCHAR(collation='foo'), 'mysql', 'mariadb'\n)\n```", "```py\nclass sqlalchemy.types.Concatenable\n```", "```py\nclass Comparator\n```", "```py\nattribute comparator_factory\n```", "```py\nclass sqlalchemy.types.Indexable\n```", "```py\nclass Comparator\n```", "```py\nattribute comparator_factory\n```", "```py\nclass sqlalchemy.types.NullType\n```", "```py\nclass sqlalchemy.types.ExternalType\n```", "```py\nattribute cache_ok: bool | None = None\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nclass sqlalchemy.types.Variant\n```", "```py\nmethod with_variant(type_: _TypeEngineArgument[Any], *dialect_names: str) \u2192 Self\n```", "```py\nfrom sqlalchemy.types import String\nfrom sqlalchemy.dialects import mysql\n\nstring_type = String()\n\nstring_type = string_type.with_variant(\n    mysql.VARCHAR(collation='foo'), 'mysql', 'mariadb'\n)\n```"]