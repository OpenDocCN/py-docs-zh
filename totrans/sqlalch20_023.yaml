- en: SQL Expressions as Mapped Attributes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 表达式作为映射属性
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/mapped_sql_expr.html](https://docs.sqlalchemy.org/en/20/orm/mapped_sql_expr.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/mapped_sql_expr.html](https://docs.sqlalchemy.org/en/20/orm/mapped_sql_expr.html)
- en: Attributes on a mapped class can be linked to SQL expressions, which can be
    used in queries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类上的属性可以链接到 SQL 表达式，这些表达式可以在查询中使用。
- en: Using a Hybrid
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用混合
- en: 'The easiest and most flexible way to link relatively simple SQL expressions
    to a class is to use a so-called “hybrid attribute”, described in the section
    [Hybrid Attributes](extensions/hybrid.html). The hybrid provides for an expression
    that works at both the Python level as well as at the SQL expression level. For
    example, below we map a class `User`, containing attributes `firstname` and `lastname`,
    and include a hybrid that will provide for us the `fullname`, which is the string
    concatenation of the two:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将相对简单的 SQL 表达式链接到类的最简单和最灵活的方法是使用所谓的“混合属性”，在 [混合属性](extensions/hybrid.html) 部分中描述。混合提供了一个同时在
    Python 级别和 SQL 表达式级别工作的表达式。例如，我们将一个类 `User`，其中包含属性 `firstname` 和 `lastname`，映射到下面一个混合，该混合将为我们提供
    `fullname`，即这两者的字符串连接：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Above, the `fullname` attribute is interpreted at both the instance and class
    level, so that it is available from an instance:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`fullname` 属性在实例和类级别都被解释，因此可以从一个实例中使用：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'as well as usable within queries:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以及可在查询中使用：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The string concatenation example is a simple one, where the Python expression
    can be dual purposed at the instance and class level. Often, the SQL expression
    must be distinguished from the Python expression, which can be achieved using
    [`hybrid_property.expression()`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression"). Below we illustrate the case
    where a conditional needs to be present inside the hybrid, using the `if` statement
    in Python and the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") construct for SQL expressions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接示例是一个简单的示例，其中 Python 表达式可以在实例和类级别上兼用。通常，必须区分 SQL 表达式和 Python 表达式，可以使用[`hybrid_property.expression()`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression")来实现。下面我们展示了在混合内部需要存在条件的情况，使用
    Python 中的`if`语句和 SQL 表达式的[`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case")构造：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '## Using column_property'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用 column_property'
- en: The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    function can be used to map a SQL expression in a manner similar to a regularly
    mapped [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column").
    With this technique, the attribute is loaded along with all other column-mapped
    attributes at load time. This is in some cases an advantage over the usage of
    hybrids, as the value can be loaded up front at the same time as the parent row
    of the object, particularly if the expression is one which links to other tables
    (typically as a correlated subquery) to access data that wouldn’t normally be
    available on an already loaded object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    函数可用于将 SQL 表达式映射到与常规映射的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 类似的方式。使用这种技术，属性在加载时与所有其他列映射的属性一起加载。这在某些情况下优于使用混合的用法，因为该值可以在对象的父行加载时一次性加载，特别是如果表达式是链接到其他表（通常作为相关子查询）以访问通常不会在已加载对象上可用的数据的情况。'
- en: Disadvantages to using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") for SQL expressions include that the expression
    must be compatible with the SELECT statement emitted for the class as a whole,
    and there are also some configurational quirks which can occur when using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") from declarative mixins.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")来表示
    SQL 表达式的缺点包括表达式必须与整个类所发出的 SELECT 语句兼容，以及在使用来自声明性混合的[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")时可能会出现一些配置怪癖。
- en: 'Our “fullname” example can be expressed using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“fullname”示例可以使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")表示如下：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Correlated subqueries may be used as well. Below we use the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect"), representing a column-oriented SELECT
    statement, that links together the count of `Address` objects available for a
    particular `User`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相关子查询。 下面我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造创建一个[`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect")，表示一个面向列的SELECT语句，将特定`User`的可用`Address`对象的计数链接在一起：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the above example, we define a [`ScalarSelect()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们定义了一个类似以下的[`ScalarSelect()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect")构造：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Above, we first use [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, which we then convert into a [scalar
    subquery](../glossary.html#term-scalar-subquery) using the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method, indicating our intent
    to use this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement in a column expression context.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")创建一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造，然后使用[`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery")方法将其转换为[标量子查询](../glossary.html#term-scalar-subquery)，表示我们打算在列表达式上下文中使用此[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句。
- en: Within the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") itself, we select the count of `Address.id`
    rows where the `Address.user_id` column is equated to `id`, which in the context
    of the `User` class is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") named `id` (note that `id` is also the name of a Python
    built in function, which is not what we want to use here - if we were outside
    of the `User` class definition, we’d use `User.id`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")本身中，我们选择计数`Address.id`行，其中`Address.user_id`列等于`id`，在`User`类的上下文中，`id`是名为`id`的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")（请注意，`id`也是Python内置函数的名称，这不是我们想在这里使用的 - 如果我们在`User`类定义之外，我们将使用`User.id`）。
- en: The [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") method indicates that each
    element in the FROM clause of this [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") may be omitted from the FROM list (that is,
    correlated to the enclosing SELECT statement against `User`) except for the one
    corresponding to `Address`. This isn’t strictly necessary, but prevents `Address`
    from being inadvertently omitted from the FROM list in the case of a long string
    of joins between `User` and `Address` tables where SELECT statements against `Address`
    are nested.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")方法指示此[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")中FROM子句的每个元素都可以从FROM列表中省略（即与针对`User`的封闭SELECT语句相关联），除了与`Address`对应的元素。
    这并不是绝对必要的，但是在`User`和`Address`表之间进行一长串连接的情况下，防止`Address`意外地从FROM列表中省略。'
- en: 'For a [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") that refers to columns linked from a many-to-many
    relationship, use [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") to join the fields of the association table
    to both tables in a relationship:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用从多对多关系链接的列的[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")，使用[`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_")将关联表的字段与关系中的两个表连接起来：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding column_property() to an existing Declarative mapped class
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将column_property()添加到现有的声明映射类
- en: 'If import issues prevent the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") from being defined inline with the class, it
    can be assigned to the class after both are configured. When using mappings that
    make use of a Declarative base class (i.e. produced by the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass or legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")), this attribute assignment has the effect
    of calling [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") to add an additional property after the
    fact:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入问题阻止在类中定义[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")，则可以在两者配置后将其分配给类。当使用使用声明性基类（即由[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")超类或遗留函数（例如[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")）生成的映射时，此属性分配的效果是在事后调用[`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property")以添加额外的属性：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When using mapping styles that don’t use Declarative base classes such as the
    [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, the [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") method may be invoked explicitly on the
    underlying [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, which can be obtained using [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect"):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不使用声明性基类的映射样式，如[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器时，可以在底层[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象上显式调用[`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property")方法，该对象可以使用[`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")获取：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Appending additional columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[将附加列添加到现有的声明式映射类](declarative_tables.html#orm-declarative-table-adding-columns)'
- en: '### Composing from Column Properties at Mapping Time'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在映射时从列属性组合'
- en: 'It is possible to create mappings that combine multiple [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") objects together. The [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") will be interpreted as a SQL expression when
    used in a Core expression context, provided that it is targeted by an existing
    expression object; this works by the Core detecting that the object has a `__clause_element__()`
    method which returns a SQL expression. However, if the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") is used as a lead object in an expression where
    there is no other Core SQL expression object to target it, the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute will return the underlying
    SQL expression so that it can be used to build SQL expressions consistently. Below,
    the `File` class contains an attribute `File.path` that concatenates a string
    token to the `File.filename` attribute, which is itself a [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建将多个[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")对象组合在一起的映射。当在核心表达式上下文中使用[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")时，它将被解释为SQL表达式，前提是它被现有的表达式对象所指向；这是通过核心检测到对象具有`__clause_element__()`方法并返回SQL表达式来实现的。然而，如果[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")作为表达式中的主对象使用，而没有其他核心SQL表达式对象来指向它，那么[`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression")属性将返回底层SQL表达式，以便可以一致地用于构建SQL表达式。下面，`File`类包含一个属性`File.path`，它将一个字符串令牌连接到`File.filename`属性上，该属性本身是一个[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the `File` class is used in expressions normally, the attributes assigned
    to `filename` and `path` are usable directly. The use of the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute is only necessary when using
    the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    directly within the mapping definition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当`File`类通常在表达式中使用时，分配给`filename`和`path`的属性可以直接使用。仅当直接在映射定义中使用[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")时，才需要使用[`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression")属性：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using Column Deferral with `column_property()`
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Column Deferral与`column_property()`
- en: 'The column deferral feature introduced in the [ORM Querying Guide](queryguide/index.html)
    at [Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    may be applied at mapping time to a SQL expression mapped by [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") by using the [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function in place of [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[ORM查询指南](queryguide/index.html)中引入的列延迟特性可在映射时应用于由[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")映射的SQL表达式，方法是在[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")的位置使用[`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")函数而不是[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Using deferred() for imperative mappers, mapped SQL expressions](queryguide/columns.html#orm-queryguide-deferred-imperative)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用deferred()用于命令式映射器，映射的SQL表达式](queryguide/columns.html#orm-queryguide-deferred-imperative)'
- en: Using a plain descriptor
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单描述符
- en: 'In cases where a SQL query more elaborate than what [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`hybrid_property`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") can provide must be emitted, a regular
    Python function accessed as an attribute can be used, assuming the expression
    only needs to be available on an already-loaded instance. The function is decorated
    with Python’s own `@property` decorator to mark it as a read-only attribute. Within
    the function, [`object_session()`](session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") is used to locate the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") corresponding to the current object, which is then used
    to emit a query:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要发出比[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")或[`hybrid_property`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")提供的SQL查询更复杂的情况下，可以使用作为属性访问的常规Python函数，假设表达式仅需要在已加载的实例上可用。该函数使用Python自己的`@property`装饰器装饰，将其标记为只读属性。在函数内部，使用[`object_session()`](session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session")定位到与当前对象对应的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，然后用于发出查询：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The plain descriptor approach is useful as a last resort, but is less performant
    in the usual case than both the hybrid and column property approaches, in that
    it needs to emit a SQL query upon each access.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单描述符方法在紧急情况下很有用，但在通常情况下比混合和列属性方法性能更低，因为它需要在每次访问时发出SQL查询。
- en: '## Query-time SQL expressions as mapped attributes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '## 映射属性中的查询时SQL表达式'
- en: In addition to being able to configure fixed SQL expressions on mapped classes,
    the SQLAlchemy ORM also includes a feature wherein objects may be loaded with
    the results of arbitrary SQL expressions which are set up at query time as part
    of their state. This behavior is available by configuring an ORM mapped attribute
    using [`query_expression()`](queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") and then using the [`with_expression()`](queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option at query time. See the section
    [Loading Arbitrary SQL Expressions onto Objects](queryguide/columns.html#orm-queryguide-with-expression)
    for an example mapping and usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在映射类上配置固定的 SQL 表达式之外，SQLAlchemy ORM 还包括一个功能，可以在查询时将对象加载为任意 SQL 表达式的结果，并将其设置为其状态的一部分。通过使用
    [`query_expression()`](queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") 配置 ORM 映射属性，然后在查询时使用 [`with_expression()`](queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载器选项来实现此行为。查看 [将任意 SQL 表达式加载到对象上](queryguide/columns.html#orm-queryguide-with-expression)
    中的示例映射和用法。
- en: Using a Hybrid
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用混合
- en: 'The easiest and most flexible way to link relatively simple SQL expressions
    to a class is to use a so-called “hybrid attribute”, described in the section
    [Hybrid Attributes](extensions/hybrid.html). The hybrid provides for an expression
    that works at both the Python level as well as at the SQL expression level. For
    example, below we map a class `User`, containing attributes `firstname` and `lastname`,
    and include a hybrid that will provide for us the `fullname`, which is the string
    concatenation of the two:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将相对简单的 SQL 表达式链接到类的最简单和最灵活的方法是使用所谓的“混合属性”，在 [混合属性](extensions/hybrid.html) 部分中描述。混合提供了一个在
    Python 级别和 SQL 表达式级别都起作用的表达式。例如，下面我们映射一个类 `User`，包含属性 `firstname` 和 `lastname`，并包含一个混合，将为我们提供
    `fullname`，即两者的字符串连接：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Above, the `fullname` attribute is interpreted at both the instance and class
    level, so that it is available from an instance:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`fullname` 属性在实例和类级别都被解释，因此可以从实例中使用：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'as well as usable within queries:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以及可在查询中使用：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The string concatenation example is a simple one, where the Python expression
    can be dual purposed at the instance and class level. Often, the SQL expression
    must be distinguished from the Python expression, which can be achieved using
    [`hybrid_property.expression()`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression"). Below we illustrate the case
    where a conditional needs to be present inside the hybrid, using the `if` statement
    in Python and the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") construct for SQL expressions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串拼接示例是一个简单的示例，其中 Python 表达式可以在实例和类级别上都起到双重作用。通常，必须区分 SQL 表达式和 Python 表达式，可以使用
    [`hybrid_property.expression()`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") 来实现。下面我们举例说明一个需要在混合中存在条件的情况，使用
    Python 中的 `if` 语句和 SQL 表达式的 [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") 结构：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '## Using column_property'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用 column_property'
- en: The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    function can be used to map a SQL expression in a manner similar to a regularly
    mapped [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column").
    With this technique, the attribute is loaded along with all other column-mapped
    attributes at load time. This is in some cases an advantage over the usage of
    hybrids, as the value can be loaded up front at the same time as the parent row
    of the object, particularly if the expression is one which links to other tables
    (typically as a correlated subquery) to access data that wouldn’t normally be
    available on an already loaded object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    函数可用于以与常规映射的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    类似的方式映射 SQL 表达式。通过此技术，属性在加载时与所有其他列映射的属性一起加载。在某些情况下，这比使用混合的优势更大，因为值可以在与对象的父行同时加载的同时前置加载，特别是如果表达式是链接到其他表的（通常作为关联子查询）以访问在已加载对象上通常不可用的数据。'
- en: Disadvantages to using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") for SQL expressions include that the expression
    must be compatible with the SELECT statement emitted for the class as a whole,
    and there are also some configurational quirks which can occur when using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") from declarative mixins.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")进行SQL表达式的缺点包括表达式必须与整个类的SELECT语句兼容，并且在使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")时可能会出现一些配置怪癖。
- en: 'Our “fullname” example can be expressed using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“fullname”示例可以使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")表示如下：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Correlated subqueries may be used as well. Below we use the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect"), representing a column-oriented SELECT
    statement, that links together the count of `Address` objects available for a
    particular `User`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相关子查询。下面我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造创建一个[`ScalarSelect`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect")，表示一个面向列的SELECT语句，它链接了特定`User`的可用`Address`对象的计数：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the above example, we define a [`ScalarSelect()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect") construct like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们定义一个如下所示的[`ScalarSelect()`](../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect
    "sqlalchemy.sql.expression.ScalarSelect")构造：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Above, we first use [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, which we then convert into a [scalar
    subquery](../glossary.html#term-scalar-subquery) using the [`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery") method, indicating our intent
    to use this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement in a column expression context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")创建一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造，然后使用[`Select.scalar_subquery()`](../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery
    "sqlalchemy.sql.expression.Select.scalar_subquery")方法将其转换为标量子查询，表明我们打算在列表达式上下文中使用这个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句。
- en: Within the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") itself, we select the count of `Address.id`
    rows where the `Address.user_id` column is equated to `id`, which in the context
    of the `User` class is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") named `id` (note that `id` is also the name of a Python
    built in function, which is not what we want to use here - if we were outside
    of the `User` class definition, we’d use `User.id`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")本身中，我们选择`Address.id`行的计数，其中`Address.user_id`列等于`id`，在`User`类的上下文中，`id`是名为`id`的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")（请注意，`id`也是Python内置函数的名称，这不是我们想要在此处使用的 - 如果我们在`User`类定义之外，我们将使用`User.id`）。
- en: The [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") method indicates that each
    element in the FROM clause of this [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") may be omitted from the FROM list (that is,
    correlated to the enclosing SELECT statement against `User`) except for the one
    corresponding to `Address`. This isn’t strictly necessary, but prevents `Address`
    from being inadvertently omitted from the FROM list in the case of a long string
    of joins between `User` and `Address` tables where SELECT statements against `Address`
    are nested.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") 方法指示此 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 的 FROM 子句中的每个元素都可以从 FROM 列表中省略（即与针对 `User`
    的封闭 SELECT 语句相关联），除了与 `Address` 对应的元素。这并非绝对必要，但在 `User` 和 `Address` 表之间的一长串联接中，防止了
    `Address` 在 SELECT 语句嵌套中无意中被省略出 FROM 列表。'
- en: 'For a [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") that refers to columns linked from a many-to-many
    relationship, use [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") to join the fields of the association table
    to both tables in a relationship:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用来自多对多关系的列的 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")，使用 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 来将关联表的字段连接到关系中的两个表：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding column_property() to an existing Declarative mapped class
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '向现有的声明式映射类添加 `column_property()` '
- en: 'If import issues prevent the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") from being defined inline with the class, it
    can be assigned to the class after both are configured. When using mappings that
    make use of a Declarative base class (i.e. produced by the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass or legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")), this attribute assignment has the effect
    of calling [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") to add an additional property after the
    fact:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入问题阻止内联定义 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 与类一起定义，则在两者配置后可以将其分配给类。当使用使用声明式基类（即由 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 超类或遗留函数如 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 生成的映射）时，此属性分配具有调用 [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") 的效果，以在事后添加附加属性。
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When using mapping styles that don’t use Declarative base classes such as the
    [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, the [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") method may be invoked explicitly on the
    underlying [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, which can be obtained using [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect"):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不使用声明式基类的映射样式时，例如 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器时，可以在底层的 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 对象上显式调用 [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") 方法，可以使用 [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 获取该对象：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Appending additional columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[向现有的声明式映射类添加额外的列](declarative_tables.html#orm-declarative-table-adding-columns)'
- en: '### Composing from Column Properties at Mapping Time'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在映射时从列属性组成'
- en: 'It is possible to create mappings that combine multiple [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") objects together. The [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") will be interpreted as a SQL expression when
    used in a Core expression context, provided that it is targeted by an existing
    expression object; this works by the Core detecting that the object has a `__clause_element__()`
    method which returns a SQL expression. However, if the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") is used as a lead object in an expression where
    there is no other Core SQL expression object to target it, the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute will return the underlying
    SQL expression so that it can be used to build SQL expressions consistently. Below,
    the `File` class contains an attribute `File.path` that concatenates a string
    token to the `File.filename` attribute, which is itself a [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建结合多个 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    对象的映射。当在核心表达式上下文中使用时，[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") 将被解释为 SQL 表达式，前提是它被现有表达式对象所定位；这通过核心检测对象是否具有返回
    SQL 表达式的 `__clause_element__()` 方法来完成。然而，如果在表达式中将 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") 用作领导对象，而没有其他核心 SQL 表达式对象来定位它，那么 [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") 属性将返回底层 SQL 表达式，以便可以一致地构建 SQL 表达式。下面，`File`
    类包含一个属性 `File.path`，它将一个字符串标记连接到 `File.filename` 属性，后者本身就是一个 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the `File` class is used in expressions normally, the attributes assigned
    to `filename` and `path` are usable directly. The use of the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute is only necessary when using
    the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    directly within the mapping definition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `File` 类在表达式中正常使用时，分配给 `filename` 和 `path` 的属性可以直接使用。只有在映射定义中直接使用 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") 时才需要使用 [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") 属性：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using Column Deferral with `column_property()`
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `column_property()` 进行列延迟
- en: 'The column deferral feature introduced in the [ORM Querying Guide](queryguide/index.html)
    at [Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    may be applied at mapping time to a SQL expression mapped by [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") by using the [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function in place of [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南](queryguide/index.html)中介绍的列延迟功能可在映射时应用到由 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 映射的 SQL 表达式上，方法是使用 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 函数代替 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")：'
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using deferred() for imperative mappers, mapped SQL expressions](queryguide/columns.html#orm-queryguide-deferred-imperative)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 imperative mappers、映射的 SQL 表达式进行延迟加载](queryguide/columns.html#orm-queryguide-deferred-imperative)'
- en: Adding column_property() to an existing Declarative mapped class
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向现有的 Declarative 映射类添加 `column_property()`
- en: 'If import issues prevent the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") from being defined inline with the class, it
    can be assigned to the class after both are configured. When using mappings that
    make use of a Declarative base class (i.e. produced by the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass or legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")), this attribute assignment has the effect
    of calling [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") to add an additional property after the
    fact:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入问题阻止 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 在类中内联定义，可以在两者配置后将其分配给类。在使用使用声明基类（即由 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 超类或遗留函数如 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 生成的）的映射时，此属性分配将调用 [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") 来添加一个额外的属性：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When using mapping styles that don’t use Declarative base classes such as the
    [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, the [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") method may be invoked explicitly on the
    underlying [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, which can be obtained using [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect"):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用不使用声明基类的映射样式，例如 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器时，可以显式调用底层的 [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property") 方法，这可以通过 [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 获取底层的 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 对象来实现：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 详见
- en: '[Appending additional columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[向现有的声明映射类添加额外列](declarative_tables.html#orm-declarative-table-adding-columns)'
- en: '### Composing from Column Properties at Mapping Time'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在映射时从列属性组成'
- en: 'It is possible to create mappings that combine multiple [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") objects together. The [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") will be interpreted as a SQL expression when
    used in a Core expression context, provided that it is targeted by an existing
    expression object; this works by the Core detecting that the object has a `__clause_element__()`
    method which returns a SQL expression. However, if the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") is used as a lead object in an expression where
    there is no other Core SQL expression object to target it, the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute will return the underlying
    SQL expression so that it can be used to build SQL expressions consistently. Below,
    the `File` class contains an attribute `File.path` that concatenates a string
    token to the `File.filename` attribute, which is itself a [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建将多个 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    对象组合在一起的映射。当在核心表达式上下文中使用时，如果 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") 被现有表达式对象所定位，则它将被解释为 SQL 表达式；这是通过核心检测到对象具有返回 SQL
    表达式的 `__clause_element__()` 方法来完成的。但是，如果在表达式中使用 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") 作为主要对象，而没有其他核心 SQL 表达式对象来定位它，则 [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") 属性将返回底层的 SQL 表达式，以便可以一致地构建 SQL 表达式。在下面的示例中，`File`
    类包含一个属性 `File.path`，它将一个字符串令牌连接到 `File.filename` 属性上，后者本身是一个 [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the `File` class is used in expressions normally, the attributes assigned
    to `filename` and `path` are usable directly. The use of the [`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute is only necessary when using
    the [`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    directly within the mapping definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当`File`类在表达式中正常使用时，分配给`filename`和`path`的属性可以直接使用。仅在映射定义中直接使用[`ColumnProperty`](internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")时才需要使用[`ColumnProperty.expression`](internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression")属性：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using Column Deferral with `column_property()`
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`column_property()`进行列延迟
- en: 'The column deferral feature introduced in the [ORM Querying Guide](queryguide/index.html)
    at [Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    may be applied at mapping time to a SQL expression mapped by [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") by using the [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function in place of [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[ORM 查询指南](queryguide/index.html)中引入的列延迟功能可以在映射时应用于由[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")映射的 SQL 表达式，方法是在映射定义中使用 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 函数代替[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using deferred() for imperative mappers, mapped SQL expressions](queryguide/columns.html#orm-queryguide-deferred-imperative)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于命令式映射器，映射 SQL 表达式使用 deferred()](queryguide/columns.html#orm-queryguide-deferred-imperative)'
- en: Using a plain descriptor
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单描述符
- en: 'In cases where a SQL query more elaborate than what [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`hybrid_property`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") can provide must be emitted, a regular
    Python function accessed as an attribute can be used, assuming the expression
    only needs to be available on an already-loaded instance. The function is decorated
    with Python’s own `@property` decorator to mark it as a read-only attribute. Within
    the function, [`object_session()`](session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") is used to locate the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") corresponding to the current object, which is then used
    to emit a query:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要发出比[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")或[`hybrid_property`](extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")提供的更复杂的 SQL 查询的情况下，可以使用作为属性访问的常规 Python
    函数，假设表达式仅需要在已加载的实例上可用。该函数使用 Python 自己的 `@property` 装饰器来将其标记为只读属性。在函数内部，使用[`object_session()`](session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session")来定位与当前对象对应的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，然后用于发出查询：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The plain descriptor approach is useful as a last resort, but is less performant
    in the usual case than both the hybrid and column property approaches, in that
    it needs to emit a SQL query upon each access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单描述符方法通常作为最后一手之计，但在通常情况下，它的性能不如混合和列属性方法，因为每次访问都需要发出一条 SQL 查询。
- en: '## Query-time SQL expressions as mapped attributes'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '## 查询时 SQL 表达式作为映射属性'
- en: In addition to being able to configure fixed SQL expressions on mapped classes,
    the SQLAlchemy ORM also includes a feature wherein objects may be loaded with
    the results of arbitrary SQL expressions which are set up at query time as part
    of their state. This behavior is available by configuring an ORM mapped attribute
    using [`query_expression()`](queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") and then using the [`with_expression()`](queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option at query time. See the section
    [Loading Arbitrary SQL Expressions onto Objects](queryguide/columns.html#orm-queryguide-with-expression)
    for an example mapping and usage.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在映射类上配置固定的 SQL 表达式之外，SQLAlchemy ORM 还包括一个功能，即对象可以使用在查询时设置为其状态的任意 SQL 表达式的结果进行加载。通过使用
    [`query_expression()`](queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") 配置 ORM 映射属性，然后在查询时使用 [`with_expression()`](queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载选项来实现这种行为。有关示例映射和用法，请参阅 [将任意 SQL 表达式加载到对象上](queryguide/columns.html#orm-queryguide-with-expression)。
