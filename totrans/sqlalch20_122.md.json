["```py\n    engine = create_engine(\"mysql+mysqldb://u:p@host/db\", pool_size=10, max_overflow=20)\n    ```", "```py\n>>> from sqlalchemy import column\n>>> print(column(\"x\") == 5)\nx  =  :x_1 \n```", "```py\n>>> from sqlalchemy.dialects.postgresql import insert\n>>> from sqlalchemy import table, column\n>>> my_table = table(\"my_table\", column(\"x\"), column(\"y\"))\n>>> insert_stmt = insert(my_table).values(x=\"foo\")\n>>> insert_stmt = insert_stmt.on_conflict_do_nothing(index_elements=[\"y\"])\n>>> print(insert_stmt)\nTraceback (most recent call last):\n\n...\n\nsqlalchemy.exc.UnsupportedCompilationError:\nCompiler <sqlalchemy.sql.compiler.StrSQLCompiler object at 0x7f04fc17e320>\ncan't render element of type\n<class 'sqlalchemy.dialects.postgresql.dml.OnConflictDoNothing'>\n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> print(insert_stmt.compile(dialect=postgresql.dialect()))\nINSERT  INTO  my_table  (x)  VALUES  (%(x)s)  ON  CONFLICT  (y)  DO  NOTHING \n```", "```py\nstatement = query.statement\nprint(statement.compile(dialect=postgresql.dialect()))\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop > 5),)\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop.expression > 5),)\n```", "```py\nstmt = select(table.c.column).where(table.c.id == bindparam(\"my_param\"))\n\nresult = conn.execute(stmt)\n```", "```py\nresult = conn.execute(stmt, {\"my_param\": 12})\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\n\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError)\nA value is required for bind parameter 'b', in parameter group 1\n[SQL: u'INSERT INTO t (a, b, c) VALUES (?, ?, ?)']\n[parameters: [{'a': 1, 'c': 3, 'b': 2}, {'a': 2, 'c': 4}, {'a': 3, 'c': 5, 'b': 4}]]\n```", "```py\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"b\": None, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\nstmt = select(t)\n```", "```py\nnew_stmt_1 = select(stmt)\n```", "```py\nnew_stmt_2 = select(some_table).select_from(some_table.join(stmt))\n```", "```py\nsubq = stmt.subquery()\n\nnew_stmt_1 = select(subq)\n\nnew_stmt_2 = select(some_table).select_from(some_table.join(subq))\n```", "```py\na1 = Address.__table__\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\na1 = Address.__table__.alias()\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(a1.c.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\n# normal join to relationship entity\nq = s.query(User).join(User.addresses).filter(Address.email_address == \"ed@foo.com\")\n\n# name Address target explicitly, not necessary but legal\nq = (\n    s.query(User)\n    .join(Address, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\na1 = aliased(Address)\n\n# of_type() form; recommended\nq = (\n    s.query(User)\n    .join(User.addresses.of_type(a1))\n    .filter(a1.email_address == \"ed@foo.com\")\n)\n\n# target, onclause form\nq = s.query(User).join(a1, User.addresses).filter(a1.email_address == \"ed@foo.com\")\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    manager_id = Column(ForeignKey(\"manager.id\"))\n    name = Column(String(50))\n    type = Column(String(50))\n\n    reports_to = relationship(\"Manager\", foreign_keys=manager_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Manager(Employee):\n    __tablename__ = \"manager\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"manager\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\n>>> stmt = select(Employee, Manager).join(Employee.reports_to)\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> from sqlalchemy.orm import aliased\n>>> manager_alias = aliased(Manager, flat=True)\n>>> stmt = select(Employee, manager_alias).join(Employee.reports_to.of_type(manager_alias))\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> stmt = (\n...     select(Employee)\n...     .join(Employee.reports_to.of_type(manager_alias))\n...     .options(contains_eager(Employee.reports_to.of_type(manager_alias)))\n... )\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    # this will emit the error message when the mapper\n    # configuration step occurs\n    a = relationship(\"A\", back_populates=\"bs\", cascade=\"all, delete-orphan\")\n\nconfigure_mappers()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\", cascade=\"all, delete-orphan\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", back_populates=\"bs\")\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        back_populates=\"bs\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\n>>> a1.bs = [b1, b2]\n>>> session.add_all([a1, b1, b2])\n>>> session.commit()\nINSERT  INTO  a  DEFAULT  VALUES\n()\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,) \n```", "```py\n>>> session.delete(b1)\n>>> session.commit()\nUPDATE  b  SET  a_id=?  WHERE  b.id  =  ?\n(None,  2)\nDELETE  FROM  b  WHERE  b.id  =  ?\n(1,)\nDELETE  FROM  a  WHERE  a.id  =  ?\n(1,)\nCOMMIT \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\")\n```", "```py\nSAWarning: relationship 'Child.parent' will copy column parent.id to column child.parent_id,\nwhich conflicts with relationship(s): 'Parent.children' (copies parent.id to child.parent_id).\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", back_populates=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\", back_populates=\"children\")\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    c1 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 0)\",\n        backref=\"parent\",\n        overlaps=\"c2, parent\",\n    )\n    c2 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 1)\",\n        overlaps=\"c1, parent\",\n    )\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\n    flag = Column(Integer)\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    result = sess.execute(select(User).where(User.id == 7))\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# iterating the result object can't associate the object with the\n# Session, raises this error.\nuser = result.first()\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    # result internally pre-fetches all objects\n    result = sess.execute(\n        select(User).where(User.id == 7), execution_options={\"prebuffer_rows\": True}\n    )\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# pre-buffered objects are returned\nuser = result.first()\n\n# however they are detached from the session, which has been closed\nassert inspect(user).detached\nassert inspect(user).session is None\n```", "```py\nfrom __future__ import annotations\n\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import MappedAsDataclass\n\nclass Mixin:\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n\nclass Base(DeclarativeBase, MappedAsDataclass):\n    pass\n\nclass User(Base, Mixin):\n    __tablename__ = \"sys_user\"\n\n    uid: Mapped[str] = mapped_column(\n        String(50), init=False, default_factory=uuid4, primary_key=True\n    )\n    username: Mapped[str] = mapped_column()\n    email: Mapped[str] = mapped_column()\n```", "```py\nSADeprecationWarning: When transforming <class '__main__.User'> to a\ndataclass, attribute(s) \"create_user\", \"update_user\" originates from\nsuperclass <class\n'__main__.Mixin'>, which is not a dataclass. This usage is deprecated and\nwill raise an error in SQLAlchemy 2.1\\. When declaring SQLAlchemy\nDeclarative Dataclasses, ensure that all mixin classes and other\nsuperclasses which include attributes are also a subclass of\nMappedAsDataclass.\n```", "```py\nclass Mixin(MappedAsDataclass):\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n```", "```py\nfrom dataclasses import dataclass\nfrom dataclasses import field\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nclass Mixin:\n    create_user: int\n    update_user: Optional[int] = field(default=None)\n\n@dataclass\nclass User(Mixin):\n    uid: str = field(init=False, default_factory=lambda: str(uuid4()))\n    username: str\n    password: str\n    email: str\n```", "```py\n>>> session.execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...         {\"id\": 5, \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n```", "```py\n>>> session.connection().execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\nasync def async_main():\n    async with engine.connect() as conn:\n        tables = await conn.run_sync(\n            lambda sync_conn: inspect(sync_conn).get_table_names()\n        )\n```", "```py\n# this is the way to do it going forward\nstmt = select(table1.c.myid).where(table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], whereclause=table1.c.myid == table2.c.otherid)\n```", "```py\n# this is also how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it's been documented since around version 1.0 or so\nstmt = select([table1.c.myid]).where(table1.c.myid == table2.c.otherid)\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker()\nmetadata_obj = MetaData(bind=engine)\nBase = declarative_base(metadata=metadata_obj)\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker(engine)\nBase = declarative_base()\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nmetadata_obj = MetaData()\ntable = Table(\"t\", metadata_obj, Column(\"q\", Integer))\n\nstmt = select(table)\nresult = stmt.execute()  # <--- raises\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pass@host/db\")\nmetadata_obj = MetaData(bind=engine)\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n```", "```py\nresult = session.execute(stmt)\n```", "```py\nengine = create_engine(...)\n\nconnection = engine.connect()\ntransaction1 = connection.begin()\n\n# this is a \"sub\" or \"marker\" transaction, a logical nesting\n# structure based on \"real\" transaction transaction1\ntransaction2 = connection.begin()\ntransaction2.rollback()\n\n# transaction1 is still present and needs explicit rollback,\n# so this will raise\nconnection.execute(text(\"select 1\"))\n```", "```py\ntransaction1.rollback()\n```", "```py\n    engine = create_engine(\"mysql+mysqldb://u:p@host/db\", pool_size=10, max_overflow=20)\n    ```", "```py\n    engine = create_engine(\"mysql+mysqldb://u:p@host/db\", pool_size=10, max_overflow=20)\n    ```", "```py\n>>> from sqlalchemy import column\n>>> print(column(\"x\") == 5)\nx  =  :x_1 \n```", "```py\n>>> from sqlalchemy.dialects.postgresql import insert\n>>> from sqlalchemy import table, column\n>>> my_table = table(\"my_table\", column(\"x\"), column(\"y\"))\n>>> insert_stmt = insert(my_table).values(x=\"foo\")\n>>> insert_stmt = insert_stmt.on_conflict_do_nothing(index_elements=[\"y\"])\n>>> print(insert_stmt)\nTraceback (most recent call last):\n\n...\n\nsqlalchemy.exc.UnsupportedCompilationError:\nCompiler <sqlalchemy.sql.compiler.StrSQLCompiler object at 0x7f04fc17e320>\ncan't render element of type\n<class 'sqlalchemy.dialects.postgresql.dml.OnConflictDoNothing'>\n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> print(insert_stmt.compile(dialect=postgresql.dialect()))\nINSERT  INTO  my_table  (x)  VALUES  (%(x)s)  ON  CONFLICT  (y)  DO  NOTHING \n```", "```py\nstatement = query.statement\nprint(statement.compile(dialect=postgresql.dialect()))\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop > 5),)\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop.expression > 5),)\n```", "```py\nstmt = select(table.c.column).where(table.c.id == bindparam(\"my_param\"))\n\nresult = conn.execute(stmt)\n```", "```py\nresult = conn.execute(stmt, {\"my_param\": 12})\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\n\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError)\nA value is required for bind parameter 'b', in parameter group 1\n[SQL: u'INSERT INTO t (a, b, c) VALUES (?, ?, ?)']\n[parameters: [{'a': 1, 'c': 3, 'b': 2}, {'a': 2, 'c': 4}, {'a': 3, 'c': 5, 'b': 4}]]\n```", "```py\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"b\": None, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\nstmt = select(t)\n```", "```py\nnew_stmt_1 = select(stmt)\n```", "```py\nnew_stmt_2 = select(some_table).select_from(some_table.join(stmt))\n```", "```py\nsubq = stmt.subquery()\n\nnew_stmt_1 = select(subq)\n\nnew_stmt_2 = select(some_table).select_from(some_table.join(subq))\n```", "```py\na1 = Address.__table__\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\na1 = Address.__table__.alias()\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(a1.c.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\n# normal join to relationship entity\nq = s.query(User).join(User.addresses).filter(Address.email_address == \"ed@foo.com\")\n\n# name Address target explicitly, not necessary but legal\nq = (\n    s.query(User)\n    .join(Address, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\na1 = aliased(Address)\n\n# of_type() form; recommended\nq = (\n    s.query(User)\n    .join(User.addresses.of_type(a1))\n    .filter(a1.email_address == \"ed@foo.com\")\n)\n\n# target, onclause form\nq = s.query(User).join(a1, User.addresses).filter(a1.email_address == \"ed@foo.com\")\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    manager_id = Column(ForeignKey(\"manager.id\"))\n    name = Column(String(50))\n    type = Column(String(50))\n\n    reports_to = relationship(\"Manager\", foreign_keys=manager_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Manager(Employee):\n    __tablename__ = \"manager\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"manager\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\n>>> stmt = select(Employee, Manager).join(Employee.reports_to)\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> from sqlalchemy.orm import aliased\n>>> manager_alias = aliased(Manager, flat=True)\n>>> stmt = select(Employee, manager_alias).join(Employee.reports_to.of_type(manager_alias))\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> stmt = (\n...     select(Employee)\n...     .join(Employee.reports_to.of_type(manager_alias))\n...     .options(contains_eager(Employee.reports_to.of_type(manager_alias)))\n... )\n```", "```py\n>>> from sqlalchemy import column\n>>> print(column(\"x\") == 5)\nx  =  :x_1 \n```", "```py\n>>> from sqlalchemy.dialects.postgresql import insert\n>>> from sqlalchemy import table, column\n>>> my_table = table(\"my_table\", column(\"x\"), column(\"y\"))\n>>> insert_stmt = insert(my_table).values(x=\"foo\")\n>>> insert_stmt = insert_stmt.on_conflict_do_nothing(index_elements=[\"y\"])\n>>> print(insert_stmt)\nTraceback (most recent call last):\n\n...\n\nsqlalchemy.exc.UnsupportedCompilationError:\nCompiler <sqlalchemy.sql.compiler.StrSQLCompiler object at 0x7f04fc17e320>\ncan't render element of type\n<class 'sqlalchemy.dialects.postgresql.dml.OnConflictDoNothing'>\n```", "```py\n>>> from sqlalchemy.dialects import postgresql\n>>> print(insert_stmt.compile(dialect=postgresql.dialect()))\nINSERT  INTO  my_table  (x)  VALUES  (%(x)s)  ON  CONFLICT  (y)  DO  NOTHING \n```", "```py\nstatement = query.statement\nprint(statement.compile(dialect=postgresql.dialect()))\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop > 5),)\n```", "```py\nclass Bar(Base):\n    __tablename__ = \"bar\"\n\n    id = Column(Integer, primary_key=True)\n    cprop = deferred(Column(Integer))\n\n    __table_args__ = (CheckConstraint(cprop.expression > 5),)\n```", "```py\nstmt = select(table.c.column).where(table.c.id == bindparam(\"my_param\"))\n\nresult = conn.execute(stmt)\n```", "```py\nresult = conn.execute(stmt, {\"my_param\": 12})\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\n\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nsqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError)\nA value is required for bind parameter 'b', in parameter group 1\n[SQL: u'INSERT INTO t (a, b, c) VALUES (?, ?, ?)']\n[parameters: [{'a': 1, 'c': 3, 'b': 2}, {'a': 2, 'c': 4}, {'a': 3, 'c': 5, 'b': 4}]]\n```", "```py\ne.execute(\n    t.insert(),\n    [\n        {\"a\": 1, \"b\": 2, \"c\": 3},\n        {\"a\": 2, \"b\": None, \"c\": 4},\n        {\"a\": 3, \"b\": 4, \"c\": 5},\n    ],\n)\n```", "```py\nm = MetaData()\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer), Column(\"c\", Integer))\nstmt = select(t)\n```", "```py\nnew_stmt_1 = select(stmt)\n```", "```py\nnew_stmt_2 = select(some_table).select_from(some_table.join(stmt))\n```", "```py\nsubq = stmt.subquery()\n\nnew_stmt_1 = select(subq)\n\nnew_stmt_2 = select(some_table).select_from(some_table.join(subq))\n```", "```py\na1 = Address.__table__\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\na1 = Address.__table__.alias()\n\nq = (\n    s.query(User)\n    .join(a1, User.addresses)\n    .filter(a1.c.email_address == \"ed@foo.com\")\n    .all()\n)\n```", "```py\n# normal join to relationship entity\nq = s.query(User).join(User.addresses).filter(Address.email_address == \"ed@foo.com\")\n\n# name Address target explicitly, not necessary but legal\nq = (\n    s.query(User)\n    .join(Address, User.addresses)\n    .filter(Address.email_address == \"ed@foo.com\")\n)\n```", "```py\nfrom sqlalchemy.orm import aliased\n\na1 = aliased(Address)\n\n# of_type() form; recommended\nq = (\n    s.query(User)\n    .join(User.addresses.of_type(a1))\n    .filter(a1.email_address == \"ed@foo.com\")\n)\n\n# target, onclause form\nq = s.query(User).join(a1, User.addresses).filter(a1.email_address == \"ed@foo.com\")\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    manager_id = Column(ForeignKey(\"manager.id\"))\n    name = Column(String(50))\n    type = Column(String(50))\n\n    reports_to = relationship(\"Manager\", foreign_keys=manager_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Manager(Employee):\n    __tablename__ = \"manager\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"manager\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\n>>> stmt = select(Employee, Manager).join(Employee.reports_to)\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> from sqlalchemy.orm import aliased\n>>> manager_alias = aliased(Manager, flat=True)\n>>> stmt = select(Employee, manager_alias).join(Employee.reports_to.of_type(manager_alias))\n>>> print(stmt)\nSELECT  employee.id,  employee.manager_id,  employee.name,\nemployee.type,  manager_1.id  AS  id_1,  employee_1.id  AS  id_2,\nemployee_1.manager_id  AS  manager_id_1,  employee_1.name  AS  name_1,\nemployee_1.type  AS  type_1\nFROM  employee  JOIN\n(employee  AS  employee_1  JOIN  manager  AS  manager_1  ON  manager_1.id  =  employee_1.id)\nON  manager_1.id  =  employee.manager_id \n```", "```py\n>>> stmt = (\n...     select(Employee)\n...     .join(Employee.reports_to.of_type(manager_alias))\n...     .options(contains_eager(Employee.reports_to.of_type(manager_alias)))\n... )\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    # this will emit the error message when the mapper\n    # configuration step occurs\n    a = relationship(\"A\", back_populates=\"bs\", cascade=\"all, delete-orphan\")\n\nconfigure_mappers()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\", cascade=\"all, delete-orphan\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", back_populates=\"bs\")\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        back_populates=\"bs\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\n>>> a1.bs = [b1, b2]\n>>> session.add_all([a1, b1, b2])\n>>> session.commit()\nINSERT  INTO  a  DEFAULT  VALUES\n()\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,) \n```", "```py\n>>> session.delete(b1)\n>>> session.commit()\nUPDATE  b  SET  a_id=?  WHERE  b.id  =  ?\n(None,  2)\nDELETE  FROM  b  WHERE  b.id  =  ?\n(1,)\nDELETE  FROM  a  WHERE  a.id  =  ?\n(1,)\nCOMMIT \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\")\n```", "```py\nSAWarning: relationship 'Child.parent' will copy column parent.id to column child.parent_id,\nwhich conflicts with relationship(s): 'Parent.children' (copies parent.id to child.parent_id).\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", back_populates=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\", back_populates=\"children\")\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    c1 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 0)\",\n        backref=\"parent\",\n        overlaps=\"c2, parent\",\n    )\n    c2 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 1)\",\n        overlaps=\"c1, parent\",\n    )\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\n    flag = Column(Integer)\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    result = sess.execute(select(User).where(User.id == 7))\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# iterating the result object can't associate the object with the\n# Session, raises this error.\nuser = result.first()\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    # result internally pre-fetches all objects\n    result = sess.execute(\n        select(User).where(User.id == 7), execution_options={\"prebuffer_rows\": True}\n    )\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# pre-buffered objects are returned\nuser = result.first()\n\n# however they are detached from the session, which has been closed\nassert inspect(user).detached\nassert inspect(user).session is None\n```", "```py\nfrom __future__ import annotations\n\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import MappedAsDataclass\n\nclass Mixin:\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n\nclass Base(DeclarativeBase, MappedAsDataclass):\n    pass\n\nclass User(Base, Mixin):\n    __tablename__ = \"sys_user\"\n\n    uid: Mapped[str] = mapped_column(\n        String(50), init=False, default_factory=uuid4, primary_key=True\n    )\n    username: Mapped[str] = mapped_column()\n    email: Mapped[str] = mapped_column()\n```", "```py\nSADeprecationWarning: When transforming <class '__main__.User'> to a\ndataclass, attribute(s) \"create_user\", \"update_user\" originates from\nsuperclass <class\n'__main__.Mixin'>, which is not a dataclass. This usage is deprecated and\nwill raise an error in SQLAlchemy 2.1\\. When declaring SQLAlchemy\nDeclarative Dataclasses, ensure that all mixin classes and other\nsuperclasses which include attributes are also a subclass of\nMappedAsDataclass.\n```", "```py\nclass Mixin(MappedAsDataclass):\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n```", "```py\nfrom dataclasses import dataclass\nfrom dataclasses import field\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nclass Mixin:\n    create_user: int\n    update_user: Optional[int] = field(default=None)\n\n@dataclass\nclass User(Mixin):\n    uid: str = field(init=False, default_factory=lambda: str(uuid4()))\n    username: str\n    password: str\n    email: str\n```", "```py\n>>> session.execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...         {\"id\": 5, \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n```", "```py\n>>> session.connection().execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    # this will emit the error message when the mapper\n    # configuration step occurs\n    a = relationship(\"A\", back_populates=\"bs\", cascade=\"all, delete-orphan\")\n\nconfigure_mappers()\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\", cascade=\"all, delete-orphan\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", back_populates=\"bs\")\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\n    bs = relationship(\"B\", back_populates=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        back_populates=\"bs\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\n>>> a1.bs = [b1, b2]\n>>> session.add_all([a1, b1, b2])\n>>> session.commit()\nINSERT  INTO  a  DEFAULT  VALUES\n()\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,) \n```", "```py\n>>> session.delete(b1)\n>>> session.commit()\nUPDATE  b  SET  a_id=?  WHERE  b.id  =  ?\n(None,  2)\nDELETE  FROM  b  WHERE  b.id  =  ?\n(1,)\nDELETE  FROM  a  WHERE  a.id  =  ?\n(1,)\nCOMMIT \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\n    a = relationship(\n        \"A\",\n        single_parent=True,\n        cascade=\"all, delete-orphan\",\n    )\n```", "```py\n>>> b1 = B()\n>>> b2 = B()\n>>> a1 = A()\n>>> b1.a = a1\n>>> b2.a = a1\nsqlalchemy.exc.InvalidRequestError: Instance <A at 0x7eff44359350> is\nalready associated with an instance of <class '__main__.B'> via its\nB.a attribute, and is only allowed a single parent.\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\")\n```", "```py\nSAWarning: relationship 'Child.parent' will copy column parent.id to column child.parent_id,\nwhich conflicts with relationship(s): 'Parent.children' (copies parent.id to child.parent_id).\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    children = relationship(\"Child\", back_populates=\"parent\")\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n    parent = relationship(\"Parent\", back_populates=\"children\")\n```", "```py\nclass Parent(Base):\n    __tablename__ = \"parent\"\n    id = Column(Integer, primary_key=True)\n    c1 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 0)\",\n        backref=\"parent\",\n        overlaps=\"c2, parent\",\n    )\n    c2 = relationship(\n        \"Child\",\n        primaryjoin=\"and_(Parent.id == Child.parent_id, Child.flag == 1)\",\n        overlaps=\"c1, parent\",\n    )\n\nclass Child(Base):\n    __tablename__ = \"child\"\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(ForeignKey(\"parent.id\"))\n\n    flag = Column(Integer)\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    result = sess.execute(select(User).where(User.id == 7))\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# iterating the result object can't associate the object with the\n# Session, raises this error.\nuser = result.first()\n```", "```py\n# context manager creates new Session\nwith Session(engine) as session_obj:\n    # result internally pre-fetches all objects\n    result = sess.execute(\n        select(User).where(User.id == 7), execution_options={\"prebuffer_rows\": True}\n    )\n\n# context manager is closed, so session_obj above is closed, identity\n# map is replaced\n\n# pre-buffered objects are returned\nuser = result.first()\n\n# however they are detached from the session, which has been closed\nassert inspect(user).detached\nassert inspect(user).session is None\n```", "```py\nfrom __future__ import annotations\n\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import MappedAsDataclass\n\nclass Mixin:\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n\nclass Base(DeclarativeBase, MappedAsDataclass):\n    pass\n\nclass User(Base, Mixin):\n    __tablename__ = \"sys_user\"\n\n    uid: Mapped[str] = mapped_column(\n        String(50), init=False, default_factory=uuid4, primary_key=True\n    )\n    username: Mapped[str] = mapped_column()\n    email: Mapped[str] = mapped_column()\n```", "```py\nSADeprecationWarning: When transforming <class '__main__.User'> to a\ndataclass, attribute(s) \"create_user\", \"update_user\" originates from\nsuperclass <class\n'__main__.Mixin'>, which is not a dataclass. This usage is deprecated and\nwill raise an error in SQLAlchemy 2.1\\. When declaring SQLAlchemy\nDeclarative Dataclasses, ensure that all mixin classes and other\nsuperclasses which include attributes are also a subclass of\nMappedAsDataclass.\n```", "```py\nclass Mixin(MappedAsDataclass):\n    create_user: Mapped[int] = mapped_column()\n    update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)\n```", "```py\nfrom dataclasses import dataclass\nfrom dataclasses import field\nimport inspect\nfrom typing import Optional\nfrom uuid import uuid4\n\nclass Mixin:\n    create_user: int\n    update_user: Optional[int] = field(default=None)\n\n@dataclass\nclass User(Mixin):\n    uid: str = field(init=False, default_factory=lambda: str(uuid4()))\n    username: str\n    password: str\n    email: str\n```", "```py\n>>> session.execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...         {\"id\": 5, \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n```", "```py\n>>> session.connection().execute(\n...     update(User).where(User.name == bindparam(\"u_name\")),\n...     [\n...         {\"u_name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"u_name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\nasync def async_main():\n    async with engine.connect() as conn:\n        tables = await conn.run_sync(\n            lambda sync_conn: inspect(sync_conn).get_table_names()\n        )\n```", "```py\nasync def async_main():\n    async with engine.connect() as conn:\n        tables = await conn.run_sync(\n            lambda sync_conn: inspect(sync_conn).get_table_names()\n        )\n```", "```py\n# this is the way to do it going forward\nstmt = select(table1.c.myid).where(table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], whereclause=table1.c.myid == table2.c.otherid)\n```", "```py\n# this is also how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it's been documented since around version 1.0 or so\nstmt = select([table1.c.myid]).where(table1.c.myid == table2.c.otherid)\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker()\nmetadata_obj = MetaData(bind=engine)\nBase = declarative_base(metadata=metadata_obj)\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker(engine)\nBase = declarative_base()\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nmetadata_obj = MetaData()\ntable = Table(\"t\", metadata_obj, Column(\"q\", Integer))\n\nstmt = select(table)\nresult = stmt.execute()  # <--- raises\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pass@host/db\")\nmetadata_obj = MetaData(bind=engine)\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n```", "```py\nresult = session.execute(stmt)\n```", "```py\nengine = create_engine(...)\n\nconnection = engine.connect()\ntransaction1 = connection.begin()\n\n# this is a \"sub\" or \"marker\" transaction, a logical nesting\n# structure based on \"real\" transaction transaction1\ntransaction2 = connection.begin()\ntransaction2.rollback()\n\n# transaction1 is still present and needs explicit rollback,\n# so this will raise\nconnection.execute(text(\"select 1\"))\n```", "```py\ntransaction1.rollback()\n```", "```py\n# this is the way to do it going forward\nstmt = select(table1.c.myid).where(table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], whereclause=table1.c.myid == table2.c.otherid)\n```", "```py\n# this is also how it was documented in original SQLAlchemy versions\n# many years ago\nstmt = select([table1.c.myid], table1.c.myid == table2.c.otherid)\n```", "```py\n# this is how it's been documented since around version 1.0 or so\nstmt = select([table1.c.myid]).where(table1.c.myid == table2.c.otherid)\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker()\nmetadata_obj = MetaData(bind=engine)\nBase = declarative_base(metadata=metadata_obj)\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nengine = create_engine(\"sqlite://\")\nSession = sessionmaker(engine)\nBase = declarative_base()\n\nclass MyClass(Base): ...\n\nsession = Session()\nsession.add(MyClass())\nsession.commit()\n```", "```py\nmetadata_obj = MetaData()\ntable = Table(\"t\", metadata_obj, Column(\"q\", Integer))\n\nstmt = select(table)\nresult = stmt.execute()  # <--- raises\n```", "```py\nengine = create_engine(\"mysql+pymysql://user:pass@host/db\")\nmetadata_obj = MetaData(bind=engine)\n```", "```py\nwith engine.connect() as conn:\n    result = conn.execute(stmt)\n```", "```py\nresult = session.execute(stmt)\n```", "```py\nengine = create_engine(...)\n\nconnection = engine.connect()\ntransaction1 = connection.begin()\n\n# this is a \"sub\" or \"marker\" transaction, a logical nesting\n# structure based on \"real\" transaction transaction1\ntransaction2 = connection.begin()\ntransaction2.rollback()\n\n# transaction1 is still present and needs explicit rollback,\n# so this will raise\nconnection.execute(text(\"select 1\"))\n```", "```py\ntransaction1.rollback()\n```"]