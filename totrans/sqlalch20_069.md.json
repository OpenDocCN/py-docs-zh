["```py\nfrom sqlalchemy.types import TypeDecorator, VARCHAR\nimport json\n\nclass JSONEncodedDict(TypeDecorator):\n    \"Represents an immutable structure as a json-encoded string.\"\n\n    impl = VARCHAR\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nfrom sqlalchemy.ext.mutable import Mutable\n\nclass MutableDict(Mutable, dict):\n    @classmethod\n    def coerce(cls, key, value):\n        \"Convert plain dictionaries to MutableDict.\"\n\n        if not isinstance(value, MutableDict):\n            if isinstance(value, dict):\n                return MutableDict(value)\n\n            # this call will raise ValueError\n            return Mutable.coerce(key, value)\n        else:\n            return value\n\n    def __setitem__(self, key, value):\n        \"Detect dictionary set events and emit change events.\"\n\n        dict.__setitem__(self, key, value)\n        self.changed()\n\n    def __delitem__(self, key):\n        \"Detect dictionary del events and emit change events.\"\n\n        dict.__delitem__(self, key)\n        self.changed()\n```", "```py\nfrom sqlalchemy import Table, Column, Integer\n\nmy_data = Table('my_data', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', MutableDict.as_mutable(JSONEncodedDict))\n)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(MutableDict.as_mutable(JSONEncodedDict))\n```", "```py\n>>> from sqlalchemy.orm import Session\n\n>>> sess = Session(some_engine)\n>>> m1 = MyDataClass(data={'value1':'foo'})\n>>> sess.add(m1)\n>>> sess.commit()\n\n>>> m1.data['value1'] = 'bar'\n>>> assert m1 in sess.dirty\nTrue\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nMutableDict.associate_with(JSONEncodedDict)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(JSONEncodedDict)\n```", "```py\nclass MyMutableType(Mutable):\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        d.pop('_parents', None)\n        return d\n```", "```py\nclass MutableDict(Mutable, dict):\n    # ....\n\n    def __getstate__(self):\n        return dict(self)\n\n    def __setstate__(self, state):\n        self.update(state)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance, initiator):\n    print(\"json value modified:\", instance.data)\n```", "```py\nimport dataclasses\nfrom sqlalchemy.ext.mutable import MutableComposite\n\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    x: int\n    y: int\n\n    def __setattr__(self, key, value):\n        \"Intercept set events\"\n\n        # set the attribute\n        object.__setattr__(self, key, value)\n\n        # alert all parents to the change\n        self.changed()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase, Mapped\nfrom sqlalchemy.orm import composite, mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    start: Mapped[Point] = composite(mapped_column(\"x1\"), mapped_column(\"y1\"))\n    end: Mapped[Point] = composite(mapped_column(\"x2\"), mapped_column(\"y2\"))\n\n    def __repr__(self):\n        return f\"Vertex(start={self.start}, end={self.end})\"\n```", "```py\n>>> from sqlalchemy.orm import Session\n>>> sess = Session(engine)\n>>> v1 = Vertex(start=Point(3, 4), end=Point(12, 15))\n>>> sess.add(v1)\n[sql](#)>>> sess.flush()\nBEGIN  (implicit)\nINSERT  INTO  vertices  (x1,  y1,  x2,  y2)  VALUES  (?,  ?,  ?,  ?)\n[...]  (3,  4,  12,  15)\n>>> v1.end.x = 8\n>>> assert v1 in sess.dirty\nTrue\n[sql](#)>>> sess.commit()\nUPDATE  vertices  SET  x2=?  WHERE  vertices.id  =  ?\n[...]  (8,  1)\nCOMMIT \n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # other Point methods\n    # ...\n\n    def coerce(cls, key, value):\n        if isinstance(value, tuple):\n            value = Point(*value)\n        elif not isinstance(value, Point):\n            raise ValueError(\"tuple or Point expected\")\n        return value\n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # ...\n\n    def __getstate__(self):\n        return self.x, self.y\n\n    def __setstate__(self, state):\n        self.x, self.y = state\n```", "```py\nclass sqlalchemy.ext.mutable.MutableBase\n```", "```py\nattribute _parents\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 Any | None\n```", "```py\nclass sqlalchemy.ext.mutable.Mutable\n```", "```py\nclassmethod _get_listen_keys(attribute: QueryableAttribute[Any]) \u2192 Set[str]\n```", "```py\nclassmethod _listen_on_attribute(attribute: QueryableAttribute[Any], coerce: bool, parent_cls: _ExternalEntityType[Any]) \u2192 None\n```", "```py\nattribute _parents\n```", "```py\nclassmethod as_mutable(sqltype: TypeEngine) \u2192 TypeEngine\n```", "```py\nTable('mytable', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', MyMutableType.as_mutable(PickleType))\n)\n```", "```py\nclassmethod associate_with(sqltype: type) \u2192 None\n```", "```py\nclassmethod associate_with_attribute(attribute: InstrumentedAttribute[_O]) \u2192 None\n```", "```py\nmethod changed() \u2192 None\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 Any | None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableComposite\n```", "```py\nmethod changed() \u2192 None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableDict\n```", "```py\nmethod clear() \u2192 None.\u00a0 Remove all items from D.\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 MutableDict[_KT, _VT] | None\n```", "```py\nmethod pop(k[, d]) \u2192 v, remove specified key and return the corresponding value.\n```", "```py\nmethod popitem() \u2192 Tuple[_KT, _VT]\n```", "```py\nmethod setdefault(*arg)\n```", "```py\nmethod update([E, ]**F) \u2192 None.\u00a0 Update D from dict/iterable E and F.\n```", "```py\nclass sqlalchemy.ext.mutable.MutableList\n```", "```py\nmethod append(x: _T) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nclassmethod coerce(key: str, value: MutableList[_T] | _T) \u2192 MutableList[_T] | None\n```", "```py\nmethod extend(x: Iterable[_T]) \u2192 None\n```", "```py\nmethod insert(i: SupportsIndex, x: _T) \u2192 None\n```", "```py\nmethod is_iterable(value: _T | Iterable[_T]) \u2192 TypeGuard[Iterable[_T]]\n```", "```py\nmethod is_scalar(value: _T | Iterable[_T]) \u2192 TypeGuard[_T]\n```", "```py\nmethod pop(*arg: SupportsIndex) \u2192 _T\n```", "```py\nmethod remove(i: _T) \u2192 None\n```", "```py\nmethod reverse() \u2192 None\n```", "```py\nmethod sort(**kw: Any) \u2192 None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableSet\n```", "```py\nmethod add(elem: _T) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nclassmethod coerce(index: str, value: Any) \u2192 MutableSet[_T] | None\n```", "```py\nmethod difference_update(*arg: Iterable[Any]) \u2192 None\n```", "```py\nmethod discard(elem: _T) \u2192 None\n```", "```py\nmethod intersection_update(*arg: Iterable[Any]) \u2192 None\n```", "```py\nmethod pop(*arg: Any) \u2192 _T\n```", "```py\nmethod remove(elem: _T) \u2192 None\n```", "```py\nmethod symmetric_difference_update(*arg: Iterable[_T]) \u2192 None\n```", "```py\nmethod update(*arg: Iterable[_T]) \u2192 None\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, VARCHAR\nimport json\n\nclass JSONEncodedDict(TypeDecorator):\n    \"Represents an immutable structure as a json-encoded string.\"\n\n    impl = VARCHAR\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nfrom sqlalchemy.ext.mutable import Mutable\n\nclass MutableDict(Mutable, dict):\n    @classmethod\n    def coerce(cls, key, value):\n        \"Convert plain dictionaries to MutableDict.\"\n\n        if not isinstance(value, MutableDict):\n            if isinstance(value, dict):\n                return MutableDict(value)\n\n            # this call will raise ValueError\n            return Mutable.coerce(key, value)\n        else:\n            return value\n\n    def __setitem__(self, key, value):\n        \"Detect dictionary set events and emit change events.\"\n\n        dict.__setitem__(self, key, value)\n        self.changed()\n\n    def __delitem__(self, key):\n        \"Detect dictionary del events and emit change events.\"\n\n        dict.__delitem__(self, key)\n        self.changed()\n```", "```py\nfrom sqlalchemy import Table, Column, Integer\n\nmy_data = Table('my_data', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', MutableDict.as_mutable(JSONEncodedDict))\n)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(MutableDict.as_mutable(JSONEncodedDict))\n```", "```py\n>>> from sqlalchemy.orm import Session\n\n>>> sess = Session(some_engine)\n>>> m1 = MyDataClass(data={'value1':'foo'})\n>>> sess.add(m1)\n>>> sess.commit()\n\n>>> m1.data['value1'] = 'bar'\n>>> assert m1 in sess.dirty\nTrue\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nMutableDict.associate_with(JSONEncodedDict)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(JSONEncodedDict)\n```", "```py\nclass MyMutableType(Mutable):\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        d.pop('_parents', None)\n        return d\n```", "```py\nclass MutableDict(Mutable, dict):\n    # ....\n\n    def __getstate__(self):\n        return dict(self)\n\n    def __setstate__(self, state):\n        self.update(state)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance, initiator):\n    print(\"json value modified:\", instance.data)\n```", "```py\nclass MyMutableType(Mutable):\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        d.pop('_parents', None)\n        return d\n```", "```py\nclass MutableDict(Mutable, dict):\n    # ....\n\n    def __getstate__(self):\n        return dict(self)\n\n    def __setstate__(self, state):\n        self.update(state)\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy import event\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyDataClass(Base):\n    __tablename__ = 'my_data'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[dict[str, str]] = mapped_column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance, initiator):\n    print(\"json value modified:\", instance.data)\n```", "```py\nimport dataclasses\nfrom sqlalchemy.ext.mutable import MutableComposite\n\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    x: int\n    y: int\n\n    def __setattr__(self, key, value):\n        \"Intercept set events\"\n\n        # set the attribute\n        object.__setattr__(self, key, value)\n\n        # alert all parents to the change\n        self.changed()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase, Mapped\nfrom sqlalchemy.orm import composite, mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Vertex(Base):\n    __tablename__ = \"vertices\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\n    start: Mapped[Point] = composite(mapped_column(\"x1\"), mapped_column(\"y1\"))\n    end: Mapped[Point] = composite(mapped_column(\"x2\"), mapped_column(\"y2\"))\n\n    def __repr__(self):\n        return f\"Vertex(start={self.start}, end={self.end})\"\n```", "```py\n>>> from sqlalchemy.orm import Session\n>>> sess = Session(engine)\n>>> v1 = Vertex(start=Point(3, 4), end=Point(12, 15))\n>>> sess.add(v1)\n[sql](#)>>> sess.flush()\nBEGIN  (implicit)\nINSERT  INTO  vertices  (x1,  y1,  x2,  y2)  VALUES  (?,  ?,  ?,  ?)\n[...]  (3,  4,  12,  15)\n>>> v1.end.x = 8\n>>> assert v1 in sess.dirty\nTrue\n[sql](#)>>> sess.commit()\nUPDATE  vertices  SET  x2=?  WHERE  vertices.id  =  ?\n[...]  (8,  1)\nCOMMIT \n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # other Point methods\n    # ...\n\n    def coerce(cls, key, value):\n        if isinstance(value, tuple):\n            value = Point(*value)\n        elif not isinstance(value, Point):\n            raise ValueError(\"tuple or Point expected\")\n        return value\n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # ...\n\n    def __getstate__(self):\n        return self.x, self.y\n\n    def __setstate__(self, state):\n        self.x, self.y = state\n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # other Point methods\n    # ...\n\n    def coerce(cls, key, value):\n        if isinstance(value, tuple):\n            value = Point(*value)\n        elif not isinstance(value, Point):\n            raise ValueError(\"tuple or Point expected\")\n        return value\n```", "```py\n@dataclasses.dataclass\nclass Point(MutableComposite):\n    # ...\n\n    def __getstate__(self):\n        return self.x, self.y\n\n    def __setstate__(self, state):\n        self.x, self.y = state\n```", "```py\nclass sqlalchemy.ext.mutable.MutableBase\n```", "```py\nattribute _parents\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 Any | None\n```", "```py\nclass sqlalchemy.ext.mutable.Mutable\n```", "```py\nclassmethod _get_listen_keys(attribute: QueryableAttribute[Any]) \u2192 Set[str]\n```", "```py\nclassmethod _listen_on_attribute(attribute: QueryableAttribute[Any], coerce: bool, parent_cls: _ExternalEntityType[Any]) \u2192 None\n```", "```py\nattribute _parents\n```", "```py\nclassmethod as_mutable(sqltype: TypeEngine) \u2192 TypeEngine\n```", "```py\nTable('mytable', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', MyMutableType.as_mutable(PickleType))\n)\n```", "```py\nclassmethod associate_with(sqltype: type) \u2192 None\n```", "```py\nclassmethod associate_with_attribute(attribute: InstrumentedAttribute[_O]) \u2192 None\n```", "```py\nmethod changed() \u2192 None\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 Any | None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableComposite\n```", "```py\nmethod changed() \u2192 None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableDict\n```", "```py\nmethod clear() \u2192 None.\u00a0 Remove all items from D.\n```", "```py\nclassmethod coerce(key: str, value: Any) \u2192 MutableDict[_KT, _VT] | None\n```", "```py\nmethod pop(k[, d]) \u2192 v, remove specified key and return the corresponding value.\n```", "```py\nmethod popitem() \u2192 Tuple[_KT, _VT]\n```", "```py\nmethod setdefault(*arg)\n```", "```py\nmethod update([E, ]**F) \u2192 None.\u00a0 Update D from dict/iterable E and F.\n```", "```py\nclass sqlalchemy.ext.mutable.MutableList\n```", "```py\nmethod append(x: _T) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nclassmethod coerce(key: str, value: MutableList[_T] | _T) \u2192 MutableList[_T] | None\n```", "```py\nmethod extend(x: Iterable[_T]) \u2192 None\n```", "```py\nmethod insert(i: SupportsIndex, x: _T) \u2192 None\n```", "```py\nmethod is_iterable(value: _T | Iterable[_T]) \u2192 TypeGuard[Iterable[_T]]\n```", "```py\nmethod is_scalar(value: _T | Iterable[_T]) \u2192 TypeGuard[_T]\n```", "```py\nmethod pop(*arg: SupportsIndex) \u2192 _T\n```", "```py\nmethod remove(i: _T) \u2192 None\n```", "```py\nmethod reverse() \u2192 None\n```", "```py\nmethod sort(**kw: Any) \u2192 None\n```", "```py\nclass sqlalchemy.ext.mutable.MutableSet\n```", "```py\nmethod add(elem: _T) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nclassmethod coerce(index: str, value: Any) \u2192 MutableSet[_T] | None\n```", "```py\nmethod difference_update(*arg: Iterable[Any]) \u2192 None\n```", "```py\nmethod discard(elem: _T) \u2192 None\n```", "```py\nmethod intersection_update(*arg: Iterable[Any]) \u2192 None\n```", "```py\nmethod pop(*arg: Any) \u2192 _T\n```", "```py\nmethod remove(elem: _T) \u2192 None\n```", "```py\nmethod symmetric_difference_update(*arg: Iterable[_T]) \u2192 None\n```", "```py\nmethod update(*arg: Iterable[_T]) \u2192 None\n```"]