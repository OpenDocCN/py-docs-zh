- en: Reflecting Database Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/reflection.html](https://docs.sqlalchemy.org/en/20/core/reflection.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object can be instructed to load information about itself from the corresponding
    database schema object already existing within the database. This process is called
    *reflection*. In the most simple case you need only specify the table name, a
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object, and the `autoload_with` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above operation will use the given engine to query the database for information
    about the `messages` table, and will then generate [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`ForeignKey`](constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), and other objects corresponding to this information
    as though the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object were hand-constructed in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'When tables are reflected, if a given table references another one via foreign
    key, a second [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is created within the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object representing the connection. Below, assume
    the table `shopping_cart_items` references a table named `shopping_carts`. Reflecting
    the `shopping_cart_items` table has the effect such that the `shopping_carts`
    table will also be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    has an interesting “singleton-like” behavior such that if you requested both tables
    individually, [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    will ensure that exactly one [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is created for each distinct table name. The [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor actually returns to you the already-existing
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    if one already exists with the given name. Such as below, we can access the already
    generated `shopping_carts` table just by naming it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it’s a good idea to use `autoload_with=engine` with the above table
    regardless. This is so that the table’s attributes will be loaded if they have
    not been already. The autoload operation only occurs for the table if it hasn’t
    already been loaded; once loaded, new calls to [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with the same name will not re-issue any reflection
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: '## Overriding Reflected Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual columns can be overridden with explicit values when reflecting tables;
    this is handy for specifying custom datatypes, constraints such as primary keys
    that may not be configured within the database, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Custom Types and Reflection](custom_types.html#custom-and-decorated-types-reflection)
    - illustrates how the above column override technique applies to the use of custom
    datatypes with table reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reflection system can also reflect views. Basic usage is the same as that
    of a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Above, `my_view` is a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object with [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects representing the names and types of each column within the view “some_view”.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it’s desired to have at least a primary key constraint when reflecting
    a view, if not foreign keys as well. View reflection doesn’t extrapolate these
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the “override” technique for this, specifying explicitly those columns
    which are part of the primary key or have foreign key constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reflecting All Tables at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object can also get a listing of tables and reflect the full set. This is achieved
    by using the [`reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect "sqlalchemy.schema.MetaData.reflect")
    method. After calling it, all located tables are present within the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object’s dictionary of tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`metadata.reflect()` also provides a handy way to clear or delete all the rows
    in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '## Reflecting Tables from Other Schemas'
  prefs: []
  type: TYPE_NORMAL
- en: The section [Specifying the Schema Name](metadata.html#schema-table-schema-name)
    introduces the concept of table schemas, which are namespaces within a database
    that contain tables and other objects, and which can be specified explicitly.
    The “schema” for a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, as well as for other objects like views, indexes and sequences, can be
    set up using the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter, and also as the default schema for a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object using the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of this schema parameter directly affects where the table reflection
    feature will look when it is asked to reflect objects. For example, given a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object configured with a default schema name “project”
    via its [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") will then utilize that configured `.schema`
    for reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is that [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects from the “project” schema will be reflected, and they will be populated
    as schema-qualified with that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, an individual [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object that includes the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter will also be reflected from that database
    schema, overriding any default schema that may have been configured on the owning
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method itself also allows a [`MetaData.reflect.schema`](metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect") parameter to be passed, so we could also
    load tables from the “project” schema for a default configured [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") any number of times with different [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") arguments (or none at all) to continue populating
    the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object with more objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '### Interaction of Schema-qualified Reflection with the Default Schema'
  prefs: []
  type: TYPE_NORMAL
- en: Section Best Practices Summarized
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss SQLAlchemy’s reflection behavior regarding tables
    that are visible in the “default schema” of a database session, and how these
    interact with SQLAlchemy directives that include the schema explicitly. As a best
    practice, ensure the “default” schema for a database is just a single name, and
    not a list of names; for tables that are part of this “default” schema and can
    be named without schema qualification in DDL and SQL, leave corresponding [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") and similar schema parameters set to their default
    of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: As described at [Specifying a Default Schema Name with MetaData](metadata.html#schema-metadata-schema-name),
    databases that have the concept of schemas usually also include the concept of
    a “default” schema. The reason for this is naturally that when one refers to table
    objects without a schema as is common, a schema-capable database will still consider
    that table to be in a “schema” somewhere. Some databases such as PostgreSQL take
    this concept further into the notion of a [schema search path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    where *multiple* schema names can be considered in a particular database session
    to be “implicit”; referring to a table name that it’s any of those schemas will
    not require that the schema name be present (while at the same time it’s also
    perfectly fine if the schema name *is* present).
  prefs: []
  type: TYPE_NORMAL
- en: Since most relational databases therefore have the concept of a particular table
    object which can be referenced both in a schema-qualified way, as well as an “implicit”
    way where no schema is present, this presents a complexity for SQLAlchemy’s reflection
    feature. Reflecting a table in a schema-qualified manner will always populate
    its [`Table.schema`](metadata.html#sqlalchemy.schema.Table.schema "sqlalchemy.schema.Table.schema")
    attribute and additionally affect how this [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is organized into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection, that is, in a schema qualified
    manner. Conversely, reflecting the **same** table in a non-schema qualified manner
    will organize it into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection **without** being schema qualified.
    The end result is that there would be two separate [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in the single [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection representing the same table in the actual
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the ramifications of this issue, consider tables from the “project”
    schema in the previous example, and suppose also that the “project” schema is
    the default schema of our database connection, or if using a database such as
    PostgreSQL suppose the “project” schema is set up in the PostgreSQL `search_path`.
    This would mean that the database accepts the following two SQL statements as
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a problem as the table can be found in both ways. However in SQLAlchemy,
    it’s the **identity** of the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object that determines its semantic role within a SQL statement. Based on the
    current decisions within SQLAlchemy, this means that if we reflect the same “messages”
    table in both a schema-qualified as well as a non-schema qualified manner, we
    get **two** [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that will **not** be treated as semantically equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The above issue becomes more complicated when the tables being reflected contain
    foreign key references to other tables. Suppose “messages” has a “project_id”
    column which refers to rows in another schema-local table “projects”, meaning
    there is a [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that is part of the definition
    of the “messages” table.
  prefs: []
  type: TYPE_NORMAL
- en: We can find ourselves in a situation where one [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection may contain as many as four [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects representing these two database tables, where
    one or two of the additional tables were generated by the reflection process;
    this is because when the reflection process encounters a foreign key constraint
    on a table being reflected, it branches out to reflect that referenced table as
    well. The decision making it uses to assign the schema to this referenced table
    is that SQLAlchemy will **omit a default schema** from the reflected [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object if the owning [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") also omits its schema name and also that these two
    objects are in the same schema, but will **include** it if it were not omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common scenario is when the reflection of a table in a schema qualified
    fashion then loads a related table that will also be performed in a schema qualified
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `messages_table_1` will refer to `projects` also in a schema qualified
    fashion. This “projects” table will be reflected automatically by the fact that
    “messages” refers to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'if some other part of the code reflects “projects” in a non-schema qualified
    fashion, there are now two projects tables that are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The above confusion can cause problems within applications that use table reflection
    to load up application-level [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, as well as within migration scenarios, in particular such as when using
    Alembic Migrations to detect new tables and foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above behavior can be remedied by sticking to one simple practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t include the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter for any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that expects to be located in the **default** schema
    of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For PostgreSQL and other databases that support a “search” path for schemas,
    add the following additional practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the “search path” narrowed down to **one schema only, which is the default
    schema**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Remote-Schema Table Introspection and PostgreSQL search_path](../dialects/postgresql.html#postgresql-schema-reflection)
    - additional details of this behavior as regards the PostgreSQL database.  ##
    Fine Grained Reflection with Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'A low level interface which provides a backend-agnostic system of loading lists
    of schema, table, column, and constraint descriptions from a given database is
    also available. This is known as the “Inspector”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Inspector](#sqlalchemy.engine.reflection.Inspector) | Performs database
    schema inspection. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedCheckConstraint](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint)
    | Dictionary representing the reflected elements corresponding to [`CheckConstraint`](constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedColumn](#sqlalchemy.engine.interfaces.ReflectedColumn) | Dictionary
    representing the reflected elements corresponding to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedComputed](#sqlalchemy.engine.interfaces.ReflectedComputed) | Represent
    the reflected elements of a computed column, corresponding to the [`Computed`](defaults.html#sqlalchemy.schema.Computed
    "sqlalchemy.schema.Computed") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedForeignKeyConstraint](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint)
    | Dictionary representing the reflected elements corresponding to [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedIdentity](#sqlalchemy.engine.interfaces.ReflectedIdentity) | represent
    the reflected IDENTITY structure of a column, corresponding to the [`Identity`](defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedIndex](#sqlalchemy.engine.interfaces.ReflectedIndex) | Dictionary
    representing the reflected elements corresponding to [`Index`](constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedPrimaryKeyConstraint](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint)
    | Dictionary representing the reflected elements corresponding to [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedTableComment](#sqlalchemy.engine.interfaces.ReflectedTableComment)
    | Dictionary representing the reflected comment corresponding to the `Table.comment`
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedUniqueConstraint](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint)
    | Dictionary representing the reflected elements corresponding to [`UniqueConstraint`](constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Performs database schema inspection.
  prefs: []
  type: TYPE_NORMAL
- en: The Inspector acts as a proxy to the reflection methods of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect"), providing a consistent interface as well
    as caching support for previously fetched metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector")
    object is usually created via the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function, which may be passed an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or a [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    associated with the engine may opt to return an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") subclass that provides additional methods
    specific to the dialect’s target database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.reflection.Inspector.__init__), [bind](#sqlalchemy.engine.reflection.Inspector.bind),
    [clear_cache()](#sqlalchemy.engine.reflection.Inspector.clear_cache), [default_schema_name](#sqlalchemy.engine.reflection.Inspector.default_schema_name),
    [dialect](#sqlalchemy.engine.reflection.Inspector.dialect), [engine](#sqlalchemy.engine.reflection.Inspector.engine),
    [from_engine()](#sqlalchemy.engine.reflection.Inspector.from_engine), [get_check_constraints()](#sqlalchemy.engine.reflection.Inspector.get_check_constraints),
    [get_columns()](#sqlalchemy.engine.reflection.Inspector.get_columns), [get_foreign_keys()](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys),
    [get_indexes()](#sqlalchemy.engine.reflection.Inspector.get_indexes), [get_materialized_view_names()](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names),
    [get_multi_check_constraints()](#sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints),
    [get_multi_columns()](#sqlalchemy.engine.reflection.Inspector.get_multi_columns),
    [get_multi_foreign_keys()](#sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys),
    [get_multi_indexes()](#sqlalchemy.engine.reflection.Inspector.get_multi_indexes),
    [get_multi_pk_constraint()](#sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint),
    [get_multi_table_comment()](#sqlalchemy.engine.reflection.Inspector.get_multi_table_comment),
    [get_multi_table_options()](#sqlalchemy.engine.reflection.Inspector.get_multi_table_options),
    [get_multi_unique_constraints()](#sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints),
    [get_pk_constraint()](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint),
    [get_schema_names()](#sqlalchemy.engine.reflection.Inspector.get_schema_names),
    [get_sequence_names()](#sqlalchemy.engine.reflection.Inspector.get_sequence_names),
    [get_sorted_table_and_fkc_names()](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names),
    [get_table_comment()](#sqlalchemy.engine.reflection.Inspector.get_table_comment),
    [get_table_names()](#sqlalchemy.engine.reflection.Inspector.get_table_names),
    [get_table_options()](#sqlalchemy.engine.reflection.Inspector.get_table_options),
    [get_temp_table_names()](#sqlalchemy.engine.reflection.Inspector.get_temp_table_names),
    [get_temp_view_names()](#sqlalchemy.engine.reflection.Inspector.get_temp_view_names),
    [get_unique_constraints()](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints),
    [get_view_definition()](#sqlalchemy.engine.reflection.Inspector.get_view_definition),
    [get_view_names()](#sqlalchemy.engine.reflection.Inspector.get_view_names), [has_index()](#sqlalchemy.engine.reflection.Inspector.has_index),
    [has_schema()](#sqlalchemy.engine.reflection.Inspector.has_schema), [has_sequence()](#sqlalchemy.engine.reflection.Inspector.has_sequence),
    [has_table()](#sqlalchemy.engine.reflection.Inspector.has_table), [info_cache](#sqlalchemy.engine.reflection.Inspector.info_cache),
    [reflect_table()](#sqlalchemy.engine.reflection.Inspector.reflect_table), [sort_tables_on_foreign_key_dependency()](#sqlalchemy.engine.reflection.Inspector.sort_tables_on_foreign_key_dependency)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.reflection.Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") (`sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initialize a new [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The __init__() method on [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") is deprecated and will be removed in
    a future release. Please use the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") in order to acquire an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bind** – a [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    which is typically an instance of [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").'
  prefs: []
  type: TYPE_NORMAL
- en: For a dialect-specific instance of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), see [`Inspector.from_engine()`](#sqlalchemy.engine.reflection.Inspector.from_engine
    "sqlalchemy.engine.reflection.Inspector.from_engine")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: reset the cache for this [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: Inspection methods that have data cached will emit SQL queries when next called
    to get new data.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Return the default schema name presented by the dialect for the current engine’s
    database user.
  prefs: []
  type: TYPE_NORMAL
- en: E.g. this is typically `public` for PostgreSQL and `dbo` for SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new dialect-specific Inspector object from the given engine or connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The from_engine() method on [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") is deprecated and will be removed in
    a future release. Please use the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") in order to acquire an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bind** – a [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs: []
  type: TYPE_NORMAL
- en: This method differs from direct a direct constructor call of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") in that the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect") is given a chance to provide a dialect-specific
    [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector")
    instance, which may provide additional methods.
  prefs: []
  type: TYPE_NORMAL
- en: See the example at [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Return information about check constraints in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return check constraint
    information as a list of [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of a check constraints.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Return information about columns in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string `schema`, return column information
    as a list of [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list of dictionaries, each representing the definition of a database column.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_columns()`](#sqlalchemy.engine.reflection.Inspector.get_multi_columns
    "sqlalchemy.engine.reflection.Inspector.get_multi_columns").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Return information about foreign_keys in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name`, and an optional string schema, return foreign key
    information as a list of [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the a foreign key definition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Return information about indexes in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return index information
    as a list of [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex "sqlalchemy.engine.interfaces.ReflectedIndex").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of an index.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_multi_indexes
    "sqlalchemy.engine.reflection.Inspector.get_multi_indexes")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return all materialized view names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Return information about check constraints in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if constraints of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of a check constraints.
    The schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Return information about columns in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if columns of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of a database column. The
    schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Return information about foreign_keys in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if foreign keys of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing a foreign key definition. The schema is
    `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Return information about indexes in in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex
    "sqlalchemy.engine.interfaces.ReflectedIndex").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if indexes of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of an index. The schema
    is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Return information about primary key constraints in all tables in the given
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if primary keys of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries, each representing the definition of a primary key constraint. The
    schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_pk_constraint")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Return information about the table comment in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment").
  prefs: []
  type: TYPE_NORMAL
- en: Raises `NotImplementedError` for a dialect that does not support comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if comments of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries, representing the table comments. The schema is `None` if no schema
    is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary of options specified when the tables in the given schema
    were created.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: This currently includes some options that apply to MySQL and Oracle tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if options of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries with the table options. The returned keys in each dict depend on
    the dialect in use. Each one is prefixed with the dialect name. The schema is
    `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_options()`](#sqlalchemy.engine.reflection.Inspector.get_table_options
    "sqlalchemy.engine.reflection.Inspector.get_table_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Return information about unique constraints in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if constraints of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of an unique constraint.
    The schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Return information about primary key constraint in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name`, and an optional string schema, return primary key
    information as a [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary representing the definition of a primary key constraint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Return all schema names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Return all sequence names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Return dependency-sorted table and foreign key constraint names in referred
    to within a particular schema.
  prefs: []
  type: TYPE_NORMAL
- en: This will yield 2-tuples of `(tablename, [(tname, fkname), (tname, fkname),
    ...])` consisting of table names in CREATE order grouped with the foreign key
    constraint names that are not detected as belonging to a cycle. The final element
    will be `(None, [(tname, fkname), (tname, fkname), ..])` which will consist of
    remaining foreign key constraint names that would require a separate CREATE step
    after-the-fact, based on dependencies between tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_names()`](#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sort_tables_and_constraints()`](ddl.html#sqlalchemy.schema.sort_tables_and_constraints
    "sqlalchemy.schema.sort_tables_and_constraints") - similar method which works
    with an already-given [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return information about the table comment for `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string `schema`, return table comment
    information as a [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment").
  prefs: []
  type: TYPE_NORMAL
- en: Raises `NotImplementedError` for a dialect that does not support comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary, with the table comment.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_multi_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_multi_table_comment")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Return all table names within a particular schema.
  prefs: []
  type: TYPE_NORMAL
- en: The names are expected to be real tables only, not views. Views are instead
    returned using the [`Inspector.get_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and/or [`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Schema name. If `schema` is left at `None`, the database’s default
    schema is used, else the named schema is searched. If the database does not support
    named schemas, behavior is undefined if `schema` is not passed as `None`. For
    special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_sorted_table_and_fkc_names()`](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names
    "sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.sorted_tables`](metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary of options specified when the table of the given name was
    created.
  prefs: []
  type: TYPE_NORMAL
- en: This currently includes some options that apply to MySQL and Oracle tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dict with the table options. The returned keys depend on the dialect in use.
    Each one is prefixed with the dialect name.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_table_options()`](#sqlalchemy.engine.reflection.Inspector.get_multi_table_options
    "sqlalchemy.engine.reflection.Inspector.get_multi_table_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of temporary table names for the current bind.
  prefs: []
  type: TYPE_NORMAL
- en: This method is unsupported by most dialects; currently only Oracle, PostgreSQL
    and SQLite implements it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of temporary view names for the current bind.
  prefs: []
  type: TYPE_NORMAL
- en: This method is unsupported by most dialects; currently only PostgreSQL and SQLite
    implements it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Return information about unique constraints in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return unique constraint
    information as a list of [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of an unique constraint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Return definition for the plain or materialized view called `view_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`view_name` – Name of the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Return all non-materialized view names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: For those dialects that previously included the names
    of materialized views in this list (currently PostgreSQL), this method no longer
    returns the names of materialized views. the [`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") method should
    be used instead.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Check the existence of a particular index name in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – the name of the table the index belongs to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_name` – the name of the index to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a schema with the given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema_name` – name of the schema to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a sequence with the given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_name` – name of the sequence to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a table, view, or temporary table of the given
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – name of the table to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New in version 1.4: - the [`Inspector.has_table()`](#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table") method replaces the `Engine.has_table()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0::: [`Inspector.has_table()`](#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table") now formally supports checking
    for additional table-like objects:'
  prefs: []
  type: TYPE_NORMAL
- en: any type of views (plain or materialized)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: temporary tables of any kind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, these two checks were not formally specified and different dialects
    would vary in their behavior. The dialect testing suite now includes tests for
    all of these object types and should be supported by all SQLAlchemy-included dialects.
    Support among third party dialects may be lagging, however.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Given a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, load its internal constructs based on introspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the underlying method used by most dialects to produce table reflection.
    Direct usage is like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Renamed from `reflecttable` to `reflect_table`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table` – a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_columns` – a list of string column names to include in the reflection
    process. If `None`, all columns are reflected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Return dependency-sorted table and foreign key constraint names referred to
    within multiple schemas.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be compared to [`Inspector.get_sorted_table_and_fkc_names()`](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names
    "sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names"), which
    works on one schema at a time; here, the method is a generalization that will
    consider multiple schemas at once including that it will resolve for cross-schema
    foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn "sqlalchemy.engine.interfaces.ReflectedColumn")
    structure is returned by the `get_columns` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[autoincrement](#sqlalchemy.engine.interfaces.ReflectedColumn.autoincrement),
    [comment](#sqlalchemy.engine.interfaces.ReflectedColumn.comment), [computed](#sqlalchemy.engine.interfaces.ReflectedColumn.computed),
    [default](#sqlalchemy.engine.interfaces.ReflectedColumn.default), [dialect_options](#sqlalchemy.engine.interfaces.ReflectedColumn.dialect_options),
    [identity](#sqlalchemy.engine.interfaces.ReflectedColumn.identity), [name](#sqlalchemy.engine.interfaces.ReflectedColumn.name),
    [nullable](#sqlalchemy.engine.interfaces.ReflectedColumn.nullable), [type](#sqlalchemy.engine.interfaces.ReflectedColumn.type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: database-dependent autoincrement flag.
  prefs: []
  type: TYPE_NORMAL
- en: This flag indicates if the column has a database-side “autoincrement” flag of
    some kind. Within SQLAlchemy, other kinds of columns may also act as an “autoincrement”
    column without necessarily having such a flag on them.
  prefs: []
  type: TYPE_NORMAL
- en: See [`Column.autoincrement`](metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") for more background on “autoincrement”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: comment for the column, if present. Only some dialects return this key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: indicates that this column is computed by the database. Only some dialects return
    this key.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.16: - added support for computed reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: column default expression as a SQL string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this reflected object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: indicates this column is an IDENTITY column. Only some dialects return this
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: - added support for identity column reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: column name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: boolean flag if the column is NULL or NOT NULL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: column type represented as a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Represent the reflected elements of a computed column, corresponding to the
    [`Computed`](defaults.html#sqlalchemy.schema.Computed "sqlalchemy.schema.Computed")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedComputed`](#sqlalchemy.engine.interfaces.ReflectedComputed "sqlalchemy.engine.interfaces.ReflectedComputed")
    structure is part of the [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") structure, which is returned by
    the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[persisted](#sqlalchemy.engine.interfaces.ReflectedComputed.persisted), [sqltext](#sqlalchemy.engine.interfaces.ReflectedComputed.sqltext)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedComputed`](#sqlalchemy.engine.interfaces.ReflectedComputed
    "sqlalchemy.engine.interfaces.ReflectedComputed") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: indicates if the value is stored in the table or computed on demand
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: the expression used to generate this column returned as a string SQL expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`CheckConstraint`](constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint") structure is returned
    by the [`Inspector.get_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[dialect_options](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint.dialect_options),
    [sqltext](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint.sqltext)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this check constraint
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.8.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: the check constraint’s SQL expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint") structure is returned
    by the [`Inspector.get_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[constrained_columns](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.constrained_columns),
    [options](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.options),
    [referred_columns](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_columns),
    [referred_schema](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_schema),
    [referred_table](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_table)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: local column names which comprise the foreign key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Additional options detected for this foreign key constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: referred column names that correspond to `constrained_columns`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: schema name of the table being referred
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: name of the table being referred
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: represent the reflected IDENTITY structure of a column, corresponding to the
    [`Identity`](defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedIdentity`](#sqlalchemy.engine.interfaces.ReflectedIdentity "sqlalchemy.engine.interfaces.ReflectedIdentity")
    structure is part of the [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") structure, which is returned by
    the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[always](#sqlalchemy.engine.interfaces.ReflectedIdentity.always), [cache](#sqlalchemy.engine.interfaces.ReflectedIdentity.cache),
    [cycle](#sqlalchemy.engine.interfaces.ReflectedIdentity.cycle), [increment](#sqlalchemy.engine.interfaces.ReflectedIdentity.increment),
    [maxvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.maxvalue), [minvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.minvalue),
    [nomaxvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.nomaxvalue), [nominvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.nominvalue),
    [on_null](#sqlalchemy.engine.interfaces.ReflectedIdentity.on_null), [order](#sqlalchemy.engine.interfaces.ReflectedIdentity.order),
    [start](#sqlalchemy.engine.interfaces.ReflectedIdentity.start)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedIdentity`](#sqlalchemy.engine.interfaces.ReflectedIdentity
    "sqlalchemy.engine.interfaces.ReflectedIdentity") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: type of identity column
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: number of future values in the sequence which are calculated in advance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: allows the sequence to wrap around when the maxvalue or minvalue has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: increment value of the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: the maximum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: the minimum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: no maximum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: no minimum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: indicates ON NULL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: if true, renders the ORDER keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: starting index of the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`Index`](constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex "sqlalchemy.engine.interfaces.ReflectedIndex")
    structure is returned by the [`Inspector.get_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[column_names](#sqlalchemy.engine.interfaces.ReflectedIndex.column_names),
    [column_sorting](#sqlalchemy.engine.interfaces.ReflectedIndex.column_sorting),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedIndex.dialect_options),
    [duplicates_constraint](#sqlalchemy.engine.interfaces.ReflectedIndex.duplicates_constraint),
    [expressions](#sqlalchemy.engine.interfaces.ReflectedIndex.expressions), [include_columns](#sqlalchemy.engine.interfaces.ReflectedIndex.include_columns),
    [name](#sqlalchemy.engine.interfaces.ReflectedIndex.name), [unique](#sqlalchemy.engine.interfaces.ReflectedIndex.unique)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex
    "sqlalchemy.engine.interfaces.ReflectedIndex") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: column names which the index references. An element of this list is `None` if
    it’s an expression and is returned in the `expressions` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: optional dict mapping column names or expressions to tuple of sort keywords,
    which may include `asc`, `desc`, `nulls_first`, `nulls_last`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this index
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this index mirrors a constraint with this name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Expressions that compose the index. This list, when present, contains both plain
    column names (that are also in `column_names`) and expressions (that are `None`
    in `column_names`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: columns to include in the INCLUDE clause for supporting databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0: Legacy value, will be replaced with `index_dict["dialect_options"]["<dialect
    name>_include"]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: index name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: whether or not the index has a unique flag
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint") structure is returned
    by the [`Inspector.get_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_pk_constraint") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[constrained_columns](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint.constrained_columns),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint.dialect_options)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: column names which comprise the primary key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this primary key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`UniqueConstraint`](constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint") structure is returned
    by the [`Inspector.get_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[column_names](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.column_names),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.dialect_options),
    [duplicates_index](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.duplicates_index)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: column names which comprise the unique constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this unique constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this unique constraint duplicates an index with this name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected comment corresponding to the `Table.comment`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment") structure is returned by
    the [`Inspector.get_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[text](#sqlalchemy.engine.interfaces.ReflectedTableComment.text)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'text of the comment  ## Reflecting with Database-Agnostic Types'
  prefs: []
  type: TYPE_NORMAL
- en: When the columns of a table are reflected, using either the [`Table.autoload_with`](metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter of [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), the datatypes will be as specific as
    possible to the target database. This means that if an “integer” datatype is reflected
    from a MySQL database, the type will be represented by the [`sqlalchemy.dialects.mysql.INTEGER`](../dialects/mysql.html#sqlalchemy.dialects.mysql.INTEGER
    "sqlalchemy.dialects.mysql.INTEGER") class, which includes MySQL-specific attributes
    such as “display_width”. Or on PostgreSQL, a PostgreSQL-specific datatype such
    as [`sqlalchemy.dialects.postgresql.INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") or [`sqlalchemy.dialects.postgresql.ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") may be returned.
  prefs: []
  type: TYPE_NORMAL
- en: There is a use case for reflection which is that a given [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is to be transferred to a different vendor database.
    To suit this use case, there is a technique by which these vendor-specific datatypes
    can be converted on the fly to be instance of SQLAlchemy backend-agnostic datatypes,
    for the examples above types such as [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`Interval`](type_basics.html#sqlalchemy.types.Interval
    "sqlalchemy.types.Interval") and [`Enum`](type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"). This may be achieved by intercepting the column reflection
    using the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event in conjunction with the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a table in MySQL (chosen because MySQL has a lot of vendor-specific datatypes
    and options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table includes MySQL-only integer types `MEDIUMINT` and `TINYINT`
    as well as a `VARCHAR` that includes the MySQL-only `CHARACTER SET` option. If
    we reflect this table normally, it produces a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that will contain those MySQL-specific datatypes
    and options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example reflects the above table schema into a new [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. We can then, for demonstration purposes, print
    out the MySQL-specific “CREATE TABLE” statement using the [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable
    "sqlalchemy.schema.CreateTable") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the MySQL-specific datatypes and options were maintained. If we wanted
    a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") that
    we could instead transfer cleanly to another database vendor, replacing the special
    datatypes [`sqlalchemy.dialects.mysql.MEDIUMINT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.MEDIUMINT
    "sqlalchemy.dialects.mysql.MEDIUMINT") and [`sqlalchemy.dialects.mysql.TINYINT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TINYINT
    "sqlalchemy.dialects.mysql.TINYINT") with [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), we can choose instead to “genericize” the datatypes
    on this table, or otherwise change them in any way we’d like, by establishing
    a handler using the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event. The custom handler will make
    use of the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method to convert the above MySQL-specific
    type objects into generic ones, by replacing the `"type"` entry within the column
    dictionary entry that is passed to the event handler. The format of this dictionary
    is described at [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get a new [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that is generic and uses [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") for those datatypes. We can now emit a “CREATE TABLE”
    statement for example on a PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Noting above also that SQLAlchemy will usually make a decent guess for other
    behaviors, such as that the MySQL `AUTO_INCREMENT` directive is represented in
    PostgreSQL most closely using the `SERIAL` auto-incrementing datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method and additionally improved the
    use of the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event such that it may be applied
    to a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to note that the reflection process recreates [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata using only information which is represented
    in the relational database. This process by definition cannot restore aspects
    of a schema that aren’t actually stored in the database. State which is not available
    from reflection includes but is not limited to:'
  prefs: []
  type: TYPE_NORMAL
- en: Client side defaults, either Python functions or SQL expressions defined using
    the `default` keyword of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    (note this is separate from `server_default`, which specifically is what’s available
    via reflection).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column information, e.g. data that might have been placed into the [`Column.info`](metadata.html#sqlalchemy.schema.Column.info
    "sqlalchemy.schema.Column.info") dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the `.quote` setting for [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The association of a particular [`Sequence`](defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") with a given [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relational database also in many cases reports on table metadata in a different
    format than what was specified in SQLAlchemy. The [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects returned from reflection cannot be always relied
    upon to produce the identical DDL as the original Python-defined [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. Areas where this occurs includes server defaults,
    column-associated sequences and various idiosyncrasies regarding constraints and
    datatypes. Server side defaults may be returned with cast directives (typically
    PostgreSQL will include a `::<type>` cast) or different quoting patterns than
    originally specified.
  prefs: []
  type: TYPE_NORMAL
- en: Another category of limitation includes schema structures for which reflection
    is only partially or not yet defined. Recent improvements to reflection allow
    things like views, indexes and foreign key options to be reflected. As of this
    writing, structures like CHECK constraints, table comments, and triggers are not
    reflected.
  prefs: []
  type: TYPE_NORMAL
- en: '## Overriding Reflected Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual columns can be overridden with explicit values when reflecting tables;
    this is handy for specifying custom datatypes, constraints such as primary keys
    that may not be configured within the database, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Custom Types and Reflection](custom_types.html#custom-and-decorated-types-reflection)
    - illustrates how the above column override technique applies to the use of custom
    datatypes with table reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reflection system can also reflect views. Basic usage is the same as that
    of a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Above, `my_view` is a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object with [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects representing the names and types of each column within the view “some_view”.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it’s desired to have at least a primary key constraint when reflecting
    a view, if not foreign keys as well. View reflection doesn’t extrapolate these
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the “override” technique for this, specifying explicitly those columns
    which are part of the primary key or have foreign key constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Reflecting All Tables at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object can also get a listing of tables and reflect the full set. This is achieved
    by using the [`reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect "sqlalchemy.schema.MetaData.reflect")
    method. After calling it, all located tables are present within the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object’s dictionary of tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '`metadata.reflect()` also provides a handy way to clear or delete all the rows
    in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '## Reflecting Tables from Other Schemas'
  prefs: []
  type: TYPE_NORMAL
- en: The section [Specifying the Schema Name](metadata.html#schema-table-schema-name)
    introduces the concept of table schemas, which are namespaces within a database
    that contain tables and other objects, and which can be specified explicitly.
    The “schema” for a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, as well as for other objects like views, indexes and sequences, can be
    set up using the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter, and also as the default schema for a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object using the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of this schema parameter directly affects where the table reflection
    feature will look when it is asked to reflect objects. For example, given a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object configured with a default schema name “project”
    via its [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") will then utilize that configured `.schema`
    for reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is that [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects from the “project” schema will be reflected, and they will be populated
    as schema-qualified with that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, an individual [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object that includes the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter will also be reflected from that database
    schema, overriding any default schema that may have been configured on the owning
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method itself also allows a [`MetaData.reflect.schema`](metadata.html#sqlalchemy.schema.MetaData.reflect.params.schema
    "sqlalchemy.schema.MetaData.reflect") parameter to be passed, so we could also
    load tables from the “project” schema for a default configured [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call [`MetaData.reflect()`](metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") any number of times with different [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") arguments (or none at all) to continue populating
    the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object with more objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '### Interaction of Schema-qualified Reflection with the Default Schema'
  prefs: []
  type: TYPE_NORMAL
- en: Section Best Practices Summarized
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss SQLAlchemy’s reflection behavior regarding tables
    that are visible in the “default schema” of a database session, and how these
    interact with SQLAlchemy directives that include the schema explicitly. As a best
    practice, ensure the “default” schema for a database is just a single name, and
    not a list of names; for tables that are part of this “default” schema and can
    be named without schema qualification in DDL and SQL, leave corresponding [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") and similar schema parameters set to their default
    of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: As described at [Specifying a Default Schema Name with MetaData](metadata.html#schema-metadata-schema-name),
    databases that have the concept of schemas usually also include the concept of
    a “default” schema. The reason for this is naturally that when one refers to table
    objects without a schema as is common, a schema-capable database will still consider
    that table to be in a “schema” somewhere. Some databases such as PostgreSQL take
    this concept further into the notion of a [schema search path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    where *multiple* schema names can be considered in a particular database session
    to be “implicit”; referring to a table name that it’s any of those schemas will
    not require that the schema name be present (while at the same time it’s also
    perfectly fine if the schema name *is* present).
  prefs: []
  type: TYPE_NORMAL
- en: Since most relational databases therefore have the concept of a particular table
    object which can be referenced both in a schema-qualified way, as well as an “implicit”
    way where no schema is present, this presents a complexity for SQLAlchemy’s reflection
    feature. Reflecting a table in a schema-qualified manner will always populate
    its [`Table.schema`](metadata.html#sqlalchemy.schema.Table.schema "sqlalchemy.schema.Table.schema")
    attribute and additionally affect how this [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is organized into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection, that is, in a schema qualified
    manner. Conversely, reflecting the **same** table in a non-schema qualified manner
    will organize it into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection **without** being schema qualified.
    The end result is that there would be two separate [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in the single [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection representing the same table in the actual
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the ramifications of this issue, consider tables from the “project”
    schema in the previous example, and suppose also that the “project” schema is
    the default schema of our database connection, or if using a database such as
    PostgreSQL suppose the “project” schema is set up in the PostgreSQL `search_path`.
    This would mean that the database accepts the following two SQL statements as
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a problem as the table can be found in both ways. However in SQLAlchemy,
    it’s the **identity** of the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object that determines its semantic role within a SQL statement. Based on the
    current decisions within SQLAlchemy, this means that if we reflect the same “messages”
    table in both a schema-qualified as well as a non-schema qualified manner, we
    get **two** [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that will **not** be treated as semantically equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The above issue becomes more complicated when the tables being reflected contain
    foreign key references to other tables. Suppose “messages” has a “project_id”
    column which refers to rows in another schema-local table “projects”, meaning
    there is a [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that is part of the definition
    of the “messages” table.
  prefs: []
  type: TYPE_NORMAL
- en: We can find ourselves in a situation where one [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection may contain as many as four [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects representing these two database tables, where
    one or two of the additional tables were generated by the reflection process;
    this is because when the reflection process encounters a foreign key constraint
    on a table being reflected, it branches out to reflect that referenced table as
    well. The decision making it uses to assign the schema to this referenced table
    is that SQLAlchemy will **omit a default schema** from the reflected [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object if the owning [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") also omits its schema name and also that these two
    objects are in the same schema, but will **include** it if it were not omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common scenario is when the reflection of a table in a schema qualified
    fashion then loads a related table that will also be performed in a schema qualified
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `messages_table_1` will refer to `projects` also in a schema qualified
    fashion. This “projects” table will be reflected automatically by the fact that
    “messages” refers to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'if some other part of the code reflects “projects” in a non-schema qualified
    fashion, there are now two projects tables that are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The above confusion can cause problems within applications that use table reflection
    to load up application-level [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, as well as within migration scenarios, in particular such as when using
    Alembic Migrations to detect new tables and foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above behavior can be remedied by sticking to one simple practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t include the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter for any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that expects to be located in the **default** schema
    of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For PostgreSQL and other databases that support a “search” path for schemas,
    add the following additional practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the “search path” narrowed down to **one schema only, which is the default
    schema**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Remote-Schema Table Introspection and PostgreSQL search_path](../dialects/postgresql.html#postgresql-schema-reflection)
    - additional details of this behavior as regards the PostgreSQL database.  ###
    Interaction of Schema-qualified Reflection with the Default Schema'
  prefs: []
  type: TYPE_NORMAL
- en: Section Best Practices Summarized
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss SQLAlchemy’s reflection behavior regarding tables
    that are visible in the “default schema” of a database session, and how these
    interact with SQLAlchemy directives that include the schema explicitly. As a best
    practice, ensure the “default” schema for a database is just a single name, and
    not a list of names; for tables that are part of this “default” schema and can
    be named without schema qualification in DDL and SQL, leave corresponding [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") and similar schema parameters set to their default
    of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: As described at [Specifying a Default Schema Name with MetaData](metadata.html#schema-metadata-schema-name),
    databases that have the concept of schemas usually also include the concept of
    a “default” schema. The reason for this is naturally that when one refers to table
    objects without a schema as is common, a schema-capable database will still consider
    that table to be in a “schema” somewhere. Some databases such as PostgreSQL take
    this concept further into the notion of a [schema search path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    where *multiple* schema names can be considered in a particular database session
    to be “implicit”; referring to a table name that it’s any of those schemas will
    not require that the schema name be present (while at the same time it’s also
    perfectly fine if the schema name *is* present).
  prefs: []
  type: TYPE_NORMAL
- en: Since most relational databases therefore have the concept of a particular table
    object which can be referenced both in a schema-qualified way, as well as an “implicit”
    way where no schema is present, this presents a complexity for SQLAlchemy’s reflection
    feature. Reflecting a table in a schema-qualified manner will always populate
    its [`Table.schema`](metadata.html#sqlalchemy.schema.Table.schema "sqlalchemy.schema.Table.schema")
    attribute and additionally affect how this [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is organized into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection, that is, in a schema qualified
    manner. Conversely, reflecting the **same** table in a non-schema qualified manner
    will organize it into the [`MetaData.tables`](metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection **without** being schema qualified.
    The end result is that there would be two separate [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in the single [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection representing the same table in the actual
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the ramifications of this issue, consider tables from the “project”
    schema in the previous example, and suppose also that the “project” schema is
    the default schema of our database connection, or if using a database such as
    PostgreSQL suppose the “project” schema is set up in the PostgreSQL `search_path`.
    This would mean that the database accepts the following two SQL statements as
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a problem as the table can be found in both ways. However in SQLAlchemy,
    it’s the **identity** of the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object that determines its semantic role within a SQL statement. Based on the
    current decisions within SQLAlchemy, this means that if we reflect the same “messages”
    table in both a schema-qualified as well as a non-schema qualified manner, we
    get **two** [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that will **not** be treated as semantically equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The above issue becomes more complicated when the tables being reflected contain
    foreign key references to other tables. Suppose “messages” has a “project_id”
    column which refers to rows in another schema-local table “projects”, meaning
    there is a [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object that is part of the definition
    of the “messages” table.
  prefs: []
  type: TYPE_NORMAL
- en: We can find ourselves in a situation where one [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection may contain as many as four [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects representing these two database tables, where
    one or two of the additional tables were generated by the reflection process;
    this is because when the reflection process encounters a foreign key constraint
    on a table being reflected, it branches out to reflect that referenced table as
    well. The decision making it uses to assign the schema to this referenced table
    is that SQLAlchemy will **omit a default schema** from the reflected [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object if the owning [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") also omits its schema name and also that these two
    objects are in the same schema, but will **include** it if it were not omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common scenario is when the reflection of a table in a schema qualified
    fashion then loads a related table that will also be performed in a schema qualified
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `messages_table_1` will refer to `projects` also in a schema qualified
    fashion. This “projects” table will be reflected automatically by the fact that
    “messages” refers to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'if some other part of the code reflects “projects” in a non-schema qualified
    fashion, there are now two projects tables that are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The above confusion can cause problems within applications that use table reflection
    to load up application-level [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, as well as within migration scenarios, in particular such as when using
    Alembic Migrations to detect new tables and foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above behavior can be remedied by sticking to one simple practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t include the [`Table.schema`](metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") parameter for any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that expects to be located in the **default** schema
    of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For PostgreSQL and other databases that support a “search” path for schemas,
    add the following additional practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the “search path” narrowed down to **one schema only, which is the default
    schema**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Remote-Schema Table Introspection and PostgreSQL search_path](../dialects/postgresql.html#postgresql-schema-reflection)
    - additional details of this behavior as regards the PostgreSQL database.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Fine Grained Reflection with Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'A low level interface which provides a backend-agnostic system of loading lists
    of schema, table, column, and constraint descriptions from a given database is
    also available. This is known as the “Inspector”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Inspector](#sqlalchemy.engine.reflection.Inspector) | Performs database
    schema inspection. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedCheckConstraint](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint)
    | Dictionary representing the reflected elements corresponding to [`CheckConstraint`](constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedColumn](#sqlalchemy.engine.interfaces.ReflectedColumn) | Dictionary
    representing the reflected elements corresponding to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedComputed](#sqlalchemy.engine.interfaces.ReflectedComputed) | Represent
    the reflected elements of a computed column, corresponding to the [`Computed`](defaults.html#sqlalchemy.schema.Computed
    "sqlalchemy.schema.Computed") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedForeignKeyConstraint](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint)
    | Dictionary representing the reflected elements corresponding to [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedIdentity](#sqlalchemy.engine.interfaces.ReflectedIdentity) | represent
    the reflected IDENTITY structure of a column, corresponding to the [`Identity`](defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedIndex](#sqlalchemy.engine.interfaces.ReflectedIndex) | Dictionary
    representing the reflected elements corresponding to [`Index`](constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedPrimaryKeyConstraint](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint)
    | Dictionary representing the reflected elements corresponding to [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedTableComment](#sqlalchemy.engine.interfaces.ReflectedTableComment)
    | Dictionary representing the reflected comment corresponding to the `Table.comment`
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [ReflectedUniqueConstraint](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint)
    | Dictionary representing the reflected elements corresponding to [`UniqueConstraint`](constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Performs database schema inspection.
  prefs: []
  type: TYPE_NORMAL
- en: The Inspector acts as a proxy to the reflection methods of the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect"), providing a consistent interface as well
    as caching support for previously fetched metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector")
    object is usually created via the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function, which may be passed an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or a [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.interfaces.Dialect")
    associated with the engine may opt to return an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") subclass that provides additional methods
    specific to the dialect’s target database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.engine.reflection.Inspector.__init__), [bind](#sqlalchemy.engine.reflection.Inspector.bind),
    [clear_cache()](#sqlalchemy.engine.reflection.Inspector.clear_cache), [default_schema_name](#sqlalchemy.engine.reflection.Inspector.default_schema_name),
    [dialect](#sqlalchemy.engine.reflection.Inspector.dialect), [engine](#sqlalchemy.engine.reflection.Inspector.engine),
    [from_engine()](#sqlalchemy.engine.reflection.Inspector.from_engine), [get_check_constraints()](#sqlalchemy.engine.reflection.Inspector.get_check_constraints),
    [get_columns()](#sqlalchemy.engine.reflection.Inspector.get_columns), [get_foreign_keys()](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys),
    [get_indexes()](#sqlalchemy.engine.reflection.Inspector.get_indexes), [get_materialized_view_names()](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names),
    [get_multi_check_constraints()](#sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints),
    [get_multi_columns()](#sqlalchemy.engine.reflection.Inspector.get_multi_columns),
    [get_multi_foreign_keys()](#sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys),
    [get_multi_indexes()](#sqlalchemy.engine.reflection.Inspector.get_multi_indexes),
    [get_multi_pk_constraint()](#sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint),
    [get_multi_table_comment()](#sqlalchemy.engine.reflection.Inspector.get_multi_table_comment),
    [get_multi_table_options()](#sqlalchemy.engine.reflection.Inspector.get_multi_table_options),
    [get_multi_unique_constraints()](#sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints),
    [get_pk_constraint()](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint),
    [get_schema_names()](#sqlalchemy.engine.reflection.Inspector.get_schema_names),
    [get_sequence_names()](#sqlalchemy.engine.reflection.Inspector.get_sequence_names),
    [get_sorted_table_and_fkc_names()](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names),
    [get_table_comment()](#sqlalchemy.engine.reflection.Inspector.get_table_comment),
    [get_table_names()](#sqlalchemy.engine.reflection.Inspector.get_table_names),
    [get_table_options()](#sqlalchemy.engine.reflection.Inspector.get_table_options),
    [get_temp_table_names()](#sqlalchemy.engine.reflection.Inspector.get_temp_table_names),
    [get_temp_view_names()](#sqlalchemy.engine.reflection.Inspector.get_temp_view_names),
    [get_unique_constraints()](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints),
    [get_view_definition()](#sqlalchemy.engine.reflection.Inspector.get_view_definition),
    [get_view_names()](#sqlalchemy.engine.reflection.Inspector.get_view_names), [has_index()](#sqlalchemy.engine.reflection.Inspector.has_index),
    [has_schema()](#sqlalchemy.engine.reflection.Inspector.has_schema), [has_sequence()](#sqlalchemy.engine.reflection.Inspector.has_sequence),
    [has_table()](#sqlalchemy.engine.reflection.Inspector.has_table), [info_cache](#sqlalchemy.engine.reflection.Inspector.info_cache),
    [reflect_table()](#sqlalchemy.engine.reflection.Inspector.reflect_table), [sort_tables_on_foreign_key_dependency()](#sqlalchemy.engine.reflection.Inspector.sort_tables_on_foreign_key_dependency)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.reflection.Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") (`sqlalchemy.inspection.Inspectable`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Initialize a new [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The __init__() method on [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") is deprecated and will be removed in
    a future release. Please use the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") in order to acquire an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bind** – a [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    which is typically an instance of [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").'
  prefs: []
  type: TYPE_NORMAL
- en: For a dialect-specific instance of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), see [`Inspector.from_engine()`](#sqlalchemy.engine.reflection.Inspector.from_engine
    "sqlalchemy.engine.reflection.Inspector.from_engine")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: reset the cache for this [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: Inspection methods that have data cached will emit SQL queries when next called
    to get new data.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Return the default schema name presented by the dialect for the current engine’s
    database user.
  prefs: []
  type: TYPE_NORMAL
- en: E.g. this is typically `public` for PostgreSQL and `dbo` for SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new dialect-specific Inspector object from the given engine or connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The from_engine() method on [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") is deprecated and will be removed in
    a future release. Please use the [`inspect()`](inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on an [`Engine`](connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") in order to acquire an [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bind** – a [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").'
  prefs: []
  type: TYPE_NORMAL
- en: This method differs from direct a direct constructor call of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") in that the [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.interfaces.Dialect") is given a chance to provide a dialect-specific
    [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector")
    instance, which may provide additional methods.
  prefs: []
  type: TYPE_NORMAL
- en: See the example at [`Inspector`](#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Return information about check constraints in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return check constraint
    information as a list of [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of a check constraints.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_multi_check_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Return information about columns in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string `schema`, return column information
    as a list of [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list of dictionaries, each representing the definition of a database column.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_columns()`](#sqlalchemy.engine.reflection.Inspector.get_multi_columns
    "sqlalchemy.engine.reflection.Inspector.get_multi_columns").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Return information about foreign_keys in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name`, and an optional string schema, return foreign key
    information as a list of [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the a foreign key definition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_multi_foreign_keys")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Return information about indexes in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return index information
    as a list of [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex "sqlalchemy.engine.interfaces.ReflectedIndex").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of an index.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_multi_indexes
    "sqlalchemy.engine.reflection.Inspector.get_multi_indexes")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Return all materialized view names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Return information about check constraints in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if constraints of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of a check constraints.
    The schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Return information about columns in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if columns of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of a database column. The
    schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Return information about foreign_keys in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if foreign keys of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing a foreign key definition. The schema is
    `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Return information about indexes in in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex
    "sqlalchemy.engine.interfaces.ReflectedIndex").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if indexes of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of an index. The schema
    is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Return information about primary key constraints in all tables in the given
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if primary keys of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries, each representing the definition of a primary key constraint. The
    schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_pk_constraint")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Return information about the table comment in all objects in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The objects can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment").
  prefs: []
  type: TYPE_NORMAL
- en: Raises `NotImplementedError` for a dialect that does not support comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if comments of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries, representing the table comments. The schema is `None` if no schema
    is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary of options specified when the tables in the given schema
    were created.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: This currently includes some options that apply to MySQL and Oracle tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if options of default, temporary or
    any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    dictionaries with the table options. The returned keys in each dict depend on
    the dialect in use. Each one is prefixed with the dialect name. The schema is
    `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_options()`](#sqlalchemy.engine.reflection.Inspector.get_table_options
    "sqlalchemy.engine.reflection.Inspector.get_table_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Return information about unique constraints in all tables in the given schema.
  prefs: []
  type: TYPE_NORMAL
- en: The tables can be filtered by passing the names to use to `filter_names`.
  prefs: []
  type: TYPE_NORMAL
- en: For each table the value is a list of [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_names` – optionally return information only for the objects listed
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` – a `ObjectKind` that specifies the type of objects to reflect. Defaults
    to `ObjectKind.TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope` – a `ObjectScope` that specifies if constraints of default, temporary
    or any tables should be reflected. Defaults to `ObjectScope.DEFAULT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary where the keys are two-tuple schema,table-name and the values are
    list of dictionaries, each representing the definition of an unique constraint.
    The schema is `None` if no schema is provided.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Return information about primary key constraint in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name`, and an optional string schema, return primary key
    information as a [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary representing the definition of a primary key constraint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_multi_pk_constraint")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Return all schema names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Return all sequence names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Return dependency-sorted table and foreign key constraint names in referred
    to within a particular schema.
  prefs: []
  type: TYPE_NORMAL
- en: This will yield 2-tuples of `(tablename, [(tname, fkname), (tname, fkname),
    ...])` consisting of table names in CREATE order grouped with the foreign key
    constraint names that are not detected as belonging to a cycle. The final element
    will be `(None, [(tname, fkname), (tname, fkname), ..])` which will consist of
    remaining foreign key constraint names that would require a separate CREATE step
    after-the-fact, based on dependencies between tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_names()`](#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sort_tables_and_constraints()`](ddl.html#sqlalchemy.schema.sort_tables_and_constraints
    "sqlalchemy.schema.sort_tables_and_constraints") - similar method which works
    with an already-given [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Return information about the table comment for `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string `schema`, return table comment
    information as a [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment").
  prefs: []
  type: TYPE_NORMAL
- en: Raises `NotImplementedError` for a dialect that does not support comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dictionary, with the table comment.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_multi_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_multi_table_comment")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Return all table names within a particular schema.
  prefs: []
  type: TYPE_NORMAL
- en: The names are expected to be real tables only, not views. Views are instead
    returned using the [`Inspector.get_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and/or [`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Schema name. If `schema` is left at `None`, the database’s default
    schema is used, else the named schema is searched. If the database does not support
    named schemas, behavior is undefined if `schema` is not passed as `None`. For
    special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_sorted_table_and_fkc_names()`](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names
    "sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.sorted_tables`](metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary of options specified when the table of the given name was
    created.
  prefs: []
  type: TYPE_NORMAL
- en: This currently includes some options that apply to MySQL and Oracle tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a dict with the table options. The returned keys depend on the dialect in use.
    Each one is prefixed with the dialect name.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_table_options()`](#sqlalchemy.engine.reflection.Inspector.get_multi_table_options
    "sqlalchemy.engine.reflection.Inspector.get_multi_table_options")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of temporary table names for the current bind.
  prefs: []
  type: TYPE_NORMAL
- en: This method is unsupported by most dialects; currently only Oracle, PostgreSQL
    and SQLite implements it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of temporary view names for the current bind.
  prefs: []
  type: TYPE_NORMAL
- en: This method is unsupported by most dialects; currently only PostgreSQL and SQLite
    implements it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Return information about unique constraints in `table_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a string `table_name` and an optional string schema, return unique constraint
    information as a list of [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of dictionaries, each representing the definition of an unique constraint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_multi_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_multi_unique_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Return definition for the plain or materialized view called `view_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`view_name` – Name of the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Return all non-materialized view names in schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema` – Optional, retrieve names from a non-default schema. For special
    quoting, use [`quoted_name`](sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: For those dialects that previously included the names
    of materialized views in this list (currently PostgreSQL), this method no longer
    returns the names of materialized views. the [`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") method should
    be used instead.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Inspector.get_materialized_view_names()`](#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Check the existence of a particular index name in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – the name of the table the index belongs to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_name` – the name of the index to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a schema with the given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schema_name` – name of the schema to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a sequence with the given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_name` – name of the sequence to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the backend has a table, view, or temporary table of the given
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – name of the table to check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name to query, if not the default schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kw` – Additional keyword argument to pass to the dialect specific implementation.
    See the documentation of the dialect in use for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New in version 1.4: - the [`Inspector.has_table()`](#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table") method replaces the `Engine.has_table()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0::: [`Inspector.has_table()`](#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table") now formally supports checking
    for additional table-like objects:'
  prefs: []
  type: TYPE_NORMAL
- en: any type of views (plain or materialized)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: temporary tables of any kind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, these two checks were not formally specified and different dialects
    would vary in their behavior. The dialect testing suite now includes tests for
    all of these object types and should be supported by all SQLAlchemy-included dialects.
    Support among third party dialects may be lagging, however.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Given a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object, load its internal constructs based on introspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the underlying method used by most dialects to produce table reflection.
    Direct usage is like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Renamed from `reflecttable` to `reflect_table`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table` – a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_columns` – a list of string column names to include in the reflection
    process. If `None`, all columns are reflected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Return dependency-sorted table and foreign key constraint names referred to
    within multiple schemas.
  prefs: []
  type: TYPE_NORMAL
- en: This method may be compared to [`Inspector.get_sorted_table_and_fkc_names()`](#sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names
    "sqlalchemy.engine.reflection.Inspector.get_sorted_table_and_fkc_names"), which
    works on one schema at a time; here, the method is a generalization that will
    consider multiple schemas at once including that it will resolve for cross-schema
    foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn "sqlalchemy.engine.interfaces.ReflectedColumn")
    structure is returned by the `get_columns` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[autoincrement](#sqlalchemy.engine.interfaces.ReflectedColumn.autoincrement),
    [comment](#sqlalchemy.engine.interfaces.ReflectedColumn.comment), [computed](#sqlalchemy.engine.interfaces.ReflectedColumn.computed),
    [default](#sqlalchemy.engine.interfaces.ReflectedColumn.default), [dialect_options](#sqlalchemy.engine.interfaces.ReflectedColumn.dialect_options),
    [identity](#sqlalchemy.engine.interfaces.ReflectedColumn.identity), [name](#sqlalchemy.engine.interfaces.ReflectedColumn.name),
    [nullable](#sqlalchemy.engine.interfaces.ReflectedColumn.nullable), [type](#sqlalchemy.engine.interfaces.ReflectedColumn.type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: database-dependent autoincrement flag.
  prefs: []
  type: TYPE_NORMAL
- en: This flag indicates if the column has a database-side “autoincrement” flag of
    some kind. Within SQLAlchemy, other kinds of columns may also act as an “autoincrement”
    column without necessarily having such a flag on them.
  prefs: []
  type: TYPE_NORMAL
- en: See [`Column.autoincrement`](metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") for more background on “autoincrement”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: comment for the column, if present. Only some dialects return this key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: indicates that this column is computed by the database. Only some dialects return
    this key.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.16: - added support for computed reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: column default expression as a SQL string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this reflected object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: indicates this column is an IDENTITY column. Only some dialects return this
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: - added support for identity column reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: column name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: boolean flag if the column is NULL or NOT NULL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: column type represented as a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Represent the reflected elements of a computed column, corresponding to the
    [`Computed`](defaults.html#sqlalchemy.schema.Computed "sqlalchemy.schema.Computed")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedComputed`](#sqlalchemy.engine.interfaces.ReflectedComputed "sqlalchemy.engine.interfaces.ReflectedComputed")
    structure is part of the [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") structure, which is returned by
    the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[persisted](#sqlalchemy.engine.interfaces.ReflectedComputed.persisted), [sqltext](#sqlalchemy.engine.interfaces.ReflectedComputed.sqltext)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedComputed`](#sqlalchemy.engine.interfaces.ReflectedComputed
    "sqlalchemy.engine.interfaces.ReflectedComputed") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: indicates if the value is stored in the table or computed on demand
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: the expression used to generate this column returned as a string SQL expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`CheckConstraint`](constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint") structure is returned
    by the [`Inspector.get_check_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[dialect_options](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint.dialect_options),
    [sqltext](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint.sqltext)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedCheckConstraint`](#sqlalchemy.engine.interfaces.ReflectedCheckConstraint
    "sqlalchemy.engine.interfaces.ReflectedCheckConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this check constraint
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.8.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: the check constraint’s SQL expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`ForeignKeyConstraint`](constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint") structure is returned
    by the [`Inspector.get_foreign_keys()`](#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[constrained_columns](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.constrained_columns),
    [options](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.options),
    [referred_columns](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_columns),
    [referred_schema](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_schema),
    [referred_table](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint.referred_table)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: local column names which comprise the foreign key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Additional options detected for this foreign key constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: referred column names that correspond to `constrained_columns`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: schema name of the table being referred
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: name of the table being referred
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: represent the reflected IDENTITY structure of a column, corresponding to the
    [`Identity`](defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedIdentity`](#sqlalchemy.engine.interfaces.ReflectedIdentity "sqlalchemy.engine.interfaces.ReflectedIdentity")
    structure is part of the [`ReflectedColumn`](#sqlalchemy.engine.interfaces.ReflectedColumn
    "sqlalchemy.engine.interfaces.ReflectedColumn") structure, which is returned by
    the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[always](#sqlalchemy.engine.interfaces.ReflectedIdentity.always), [cache](#sqlalchemy.engine.interfaces.ReflectedIdentity.cache),
    [cycle](#sqlalchemy.engine.interfaces.ReflectedIdentity.cycle), [increment](#sqlalchemy.engine.interfaces.ReflectedIdentity.increment),
    [maxvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.maxvalue), [minvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.minvalue),
    [nomaxvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.nomaxvalue), [nominvalue](#sqlalchemy.engine.interfaces.ReflectedIdentity.nominvalue),
    [on_null](#sqlalchemy.engine.interfaces.ReflectedIdentity.on_null), [order](#sqlalchemy.engine.interfaces.ReflectedIdentity.order),
    [start](#sqlalchemy.engine.interfaces.ReflectedIdentity.start)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedIdentity`](#sqlalchemy.engine.interfaces.ReflectedIdentity
    "sqlalchemy.engine.interfaces.ReflectedIdentity") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: type of identity column
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: number of future values in the sequence which are calculated in advance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: allows the sequence to wrap around when the maxvalue or minvalue has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: increment value of the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: the maximum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: the minimum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: no maximum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: no minimum value of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: indicates ON NULL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: if true, renders the ORDER keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: starting index of the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`Index`](constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex "sqlalchemy.engine.interfaces.ReflectedIndex")
    structure is returned by the [`Inspector.get_indexes()`](#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[column_names](#sqlalchemy.engine.interfaces.ReflectedIndex.column_names),
    [column_sorting](#sqlalchemy.engine.interfaces.ReflectedIndex.column_sorting),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedIndex.dialect_options),
    [duplicates_constraint](#sqlalchemy.engine.interfaces.ReflectedIndex.duplicates_constraint),
    [expressions](#sqlalchemy.engine.interfaces.ReflectedIndex.expressions), [include_columns](#sqlalchemy.engine.interfaces.ReflectedIndex.include_columns),
    [name](#sqlalchemy.engine.interfaces.ReflectedIndex.name), [unique](#sqlalchemy.engine.interfaces.ReflectedIndex.unique)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedIndex`](#sqlalchemy.engine.interfaces.ReflectedIndex
    "sqlalchemy.engine.interfaces.ReflectedIndex") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: column names which the index references. An element of this list is `None` if
    it’s an expression and is returned in the `expressions` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: optional dict mapping column names or expressions to tuple of sort keywords,
    which may include `asc`, `desc`, `nulls_first`, `nulls_last`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this index
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this index mirrors a constraint with this name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Expressions that compose the index. This list, when present, contains both plain
    column names (that are also in `column_names`) and expressions (that are `None`
    in `column_names`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: columns to include in the INCLUDE clause for supporting databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0: Legacy value, will be replaced with `index_dict["dialect_options"]["<dialect
    name>_include"]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: index name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: whether or not the index has a unique flag
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`PrimaryKeyConstraint`](constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint") structure is returned
    by the [`Inspector.get_pk_constraint()`](#sqlalchemy.engine.reflection.Inspector.get_pk_constraint
    "sqlalchemy.engine.reflection.Inspector.get_pk_constraint") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[constrained_columns](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint.constrained_columns),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint.dialect_options)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint`](#sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint
    "sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: column names which comprise the primary key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this primary key
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected elements corresponding to [`UniqueConstraint`](constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint") structure is returned
    by the [`Inspector.get_unique_constraints()`](#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[column_names](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.column_names),
    [dialect_options](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.dialect_options),
    [duplicates_index](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint.duplicates_index)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedUniqueConstraint`](#sqlalchemy.engine.interfaces.ReflectedUniqueConstraint
    "sqlalchemy.engine.interfaces.ReflectedUniqueConstraint") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: column names which comprise the unique constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Additional dialect-specific options detected for this unique constraint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Indicates if this unique constraint duplicates an index with this name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary representing the reflected comment corresponding to the `Table.comment`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment") structure is returned by
    the [`Inspector.get_table_comment()`](#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[text](#sqlalchemy.engine.interfaces.ReflectedTableComment.text)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.engine.interfaces.ReflectedTableComment`](#sqlalchemy.engine.interfaces.ReflectedTableComment
    "sqlalchemy.engine.interfaces.ReflectedTableComment") (`builtins.dict`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: text of the comment
  prefs: []
  type: TYPE_NORMAL
- en: '## Reflecting with Database-Agnostic Types'
  prefs: []
  type: TYPE_NORMAL
- en: When the columns of a table are reflected, using either the [`Table.autoload_with`](metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter of [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or the [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") method of [`Inspector`](#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), the datatypes will be as specific as
    possible to the target database. This means that if an “integer” datatype is reflected
    from a MySQL database, the type will be represented by the [`sqlalchemy.dialects.mysql.INTEGER`](../dialects/mysql.html#sqlalchemy.dialects.mysql.INTEGER
    "sqlalchemy.dialects.mysql.INTEGER") class, which includes MySQL-specific attributes
    such as “display_width”. Or on PostgreSQL, a PostgreSQL-specific datatype such
    as [`sqlalchemy.dialects.postgresql.INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") or [`sqlalchemy.dialects.postgresql.ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") may be returned.
  prefs: []
  type: TYPE_NORMAL
- en: There is a use case for reflection which is that a given [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is to be transferred to a different vendor database.
    To suit this use case, there is a technique by which these vendor-specific datatypes
    can be converted on the fly to be instance of SQLAlchemy backend-agnostic datatypes,
    for the examples above types such as [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`Interval`](type_basics.html#sqlalchemy.types.Interval
    "sqlalchemy.types.Interval") and [`Enum`](type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"). This may be achieved by intercepting the column reflection
    using the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event in conjunction with the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a table in MySQL (chosen because MySQL has a lot of vendor-specific datatypes
    and options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table includes MySQL-only integer types `MEDIUMINT` and `TINYINT`
    as well as a `VARCHAR` that includes the MySQL-only `CHARACTER SET` option. If
    we reflect this table normally, it produces a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that will contain those MySQL-specific datatypes
    and options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example reflects the above table schema into a new [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. We can then, for demonstration purposes, print
    out the MySQL-specific “CREATE TABLE” statement using the [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable
    "sqlalchemy.schema.CreateTable") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the MySQL-specific datatypes and options were maintained. If we wanted
    a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") that
    we could instead transfer cleanly to another database vendor, replacing the special
    datatypes [`sqlalchemy.dialects.mysql.MEDIUMINT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.MEDIUMINT
    "sqlalchemy.dialects.mysql.MEDIUMINT") and [`sqlalchemy.dialects.mysql.TINYINT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TINYINT
    "sqlalchemy.dialects.mysql.TINYINT") with [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), we can choose instead to “genericize” the datatypes
    on this table, or otherwise change them in any way we’d like, by establishing
    a handler using the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event. The custom handler will make
    use of the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method to convert the above MySQL-specific
    type objects into generic ones, by replacing the `"type"` entry within the column
    dictionary entry that is passed to the event handler. The format of this dictionary
    is described at [`Inspector.get_columns()`](#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get a new [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that is generic and uses [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") for those datatypes. We can now emit a “CREATE TABLE”
    statement for example on a PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Noting above also that SQLAlchemy will usually make a decent guess for other
    behaviors, such as that the MySQL `AUTO_INCREMENT` directive is represented in
    PostgreSQL most closely using the `SERIAL` auto-incrementing datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added the [`TypeEngine.as_generic()`](type_api.html#sqlalchemy.types.TypeEngine.as_generic
    "sqlalchemy.types.TypeEngine.as_generic") method and additionally improved the
    use of the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event such that it may be applied
    to a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    object for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to note that the reflection process recreates [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata using only information which is represented
    in the relational database. This process by definition cannot restore aspects
    of a schema that aren’t actually stored in the database. State which is not available
    from reflection includes but is not limited to:'
  prefs: []
  type: TYPE_NORMAL
- en: Client side defaults, either Python functions or SQL expressions defined using
    the `default` keyword of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    (note this is separate from `server_default`, which specifically is what’s available
    via reflection).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column information, e.g. data that might have been placed into the [`Column.info`](metadata.html#sqlalchemy.schema.Column.info
    "sqlalchemy.schema.Column.info") dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the `.quote` setting for [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The association of a particular [`Sequence`](defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") with a given [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relational database also in many cases reports on table metadata in a different
    format than what was specified in SQLAlchemy. The [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects returned from reflection cannot be always relied
    upon to produce the identical DDL as the original Python-defined [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. Areas where this occurs includes server defaults,
    column-associated sequences and various idiosyncrasies regarding constraints and
    datatypes. Server side defaults may be returned with cast directives (typically
    PostgreSQL will include a `::<type>` cast) or different quoting patterns than
    originally specified.
  prefs: []
  type: TYPE_NORMAL
- en: Another category of limitation includes schema structures for which reflection
    is only partially or not yet defined. Recent improvements to reflection allow
    things like views, indexes and foreign key options to be reflected. As of this
    writing, structures like CHECK constraints, table comments, and triggers are not
    reflected.
  prefs: []
  type: TYPE_NORMAL
