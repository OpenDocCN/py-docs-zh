- en: Oracle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oracle
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/oracle.html](https://docs.sqlalchemy.org/en/20/dialects/oracle.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://docs.sqlalchemy.org/en/20/dialects/oracle.html](https://docs.sqlalchemy.org/en/20/dialects/oracle.html)'
- en: Support for the Oracle database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Oracle 数据库。
- en: The following table summarizes current support levels for database release versions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了数据库发布版本的当前支持级别。
- en: '**Supported Oracle versions**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的 Oracle 版本**'
- en: '| Support type | Versions |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 支持类型 | 版本 |'
- en: '| --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 18c |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [CI 完全测试通过](index.html#term-Fully-tested-in-CI) | 18c |'
- en: '| [Normal support](index.html#term-Normal-support) | 11+ |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [正常支持](index.html#term-Normal-support) | 11+ |'
- en: '| [Best effort](index.html#term-Best-effort) | 9+ |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [尽力而为](index.html#term-Best-effort) | 9+ |'
- en: DBAPI Support
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBAPI 支持
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下列方言/DBAPI 选项可用。请参考各个 DBAPI 部分获取连接信息。
- en: '[cx-Oracle](#module-sqlalchemy.dialects.oracle.cx_oracle)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[cx-Oracle](#module-sqlalchemy.dialects.oracle.cx_oracle)'
- en: '[python-oracledb](#module-sqlalchemy.dialects.oracle.oracledb)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[python-oracledb](#module-sqlalchemy.dialects.oracle.oracledb)'
- en: Auto Increment Behavior
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自增行为
- en: SQLAlchemy Table objects which include integer primary keys are usually assumed
    to have “autoincrementing” behavior, meaning they can generate their own primary
    key values upon INSERT. For use within Oracle, two options are available, which
    are the use of IDENTITY columns (Oracle 12 and above only) or the association
    of a SEQUENCE with the column.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 包含整数主键的 SQLAlchemy Table 对象通常被假定具有“自动递增”行为，这意味着它们可以在插入时生成自己的主键值。在 Oracle 中，有两种可用的选项，即使用
    IDENTITY 列（仅限 Oracle 12 及以上版本）或将 SEQUENCE 与列关联。
- en: Specifying GENERATED AS IDENTITY (Oracle 12 and above)
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定 GENERATED AS IDENTITY（Oracle 12 及以上）
- en: 'Starting from version 12 Oracle can make use of identity columns using the
    `Identity` to specify the autoincrementing behavior:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 12 开始，Oracle 可以使用 `Identity` 来指定自增行为：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的 CREATE TABLE 如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object support many options to control the “autoincrementing” behavior of the
    column, like the starting value, the incrementing value, etc. In addition to the
    standard options, Oracle supports setting [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") to `None` to use the default generated mode, rendering
    GENERATED AS IDENTITY in the DDL. It also supports setting [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") to `True` to specify ON NULL in conjunction with
    a ‘BY DEFAULT’ identity column.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    对象支持许多选项来控制列的“自动递增”行为，例如起始值、递增值等。除了标准选项外，Oracle 还支持将 [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") 设置为 `None` 以使用默认生成模式，在 DDL 中呈现 GENERATED AS IDENTITY。它还支持将
    [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") 设置为 `True`，以指定在与“BY DEFAULT”标识列一起使用时的 ON NULL。'
- en: Using a SEQUENCE (all Oracle versions)
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SEQUENCE（所有 Oracle 版本）
- en: 'Older version of Oracle had no “autoincrement” feature, SQLAlchemy relies upon
    sequences to produce these values. With the older Oracle versions, *a sequence
    must always be explicitly specified to enable autoincrement*. This is divergent
    with the majority of documentation examples which assume the usage of an autoincrement-capable
    database. To specify sequences, use the sqlalchemy.schema.Sequence object which
    is passed to a Column construct:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版 Oracle 没有“自动递增”功能，SQLAlchemy 依赖序列来生成这些值。对于旧版 Oracle，*必须始终明确指定序列以启用自动递增*。这与大多数文档示例不一致，后者假定使用支持自动递增的数据库。要指定序列，请使用传递给
    Column 构造函数的 sqlalchemy.schema.Sequence 对象：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This step is also required when using table reflection, i.e. autoload_with=engine:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表反射时也需要此步骤，即 autoload_with=engine：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.4 起更改：在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    中添加了 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    构造，用于指定自增列的选项。
- en: '## Transaction Isolation Level / Autocommit'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '## 事务隔离级别 / 自动提交'
- en: The Oracle database supports “READ COMMITTED” and “SERIALIZABLE” modes of isolation.
    The AUTOCOMMIT isolation level is also supported by the cx_Oracle dialect.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 数据库支持“READ COMMITTED”和“SERIALIZABLE”隔离模式。cx_Oracle 方言还支持 AUTOCOMMIT 隔离级别。
- en: 'To set using per-connection execution options:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用每个连接的执行选项进行设置：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For `READ COMMITTED` and `SERIALIZABLE`, the Oracle dialect sets the level at
    the session level using `ALTER SESSION`, which is reverted back to its default
    setting when the connection is returned to the connection pool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `READ COMMITTED` 和 `SERIALIZABLE`，Oracle 方言使用 `ALTER SESSION` 在会话级别设置级别，在连接返回到连接池时会恢复到默认设置。
- en: 'Valid values for `isolation_level` include:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`isolation_level` 的有效值包括：'
- en: '`READ COMMITTED`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ COMMITTED`'
- en: '`AUTOCOMMIT`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTOCOMMIT`'
- en: '`SERIALIZABLE`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIALIZABLE`'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation for the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method as implemented by the
    Oracle dialect necessarily forces the start of a transaction using the Oracle
    LOCAL_TRANSACTION_ID function; otherwise no level is normally readable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 方言实现的 [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法必要地使用 Oracle LOCAL_TRANSACTION_ID
    函数启动事务；否则通常无法读取任何级别。
- en: Additionally, the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method will raise an exception
    if the `v$transaction` view is not available due to permissions or other reasons,
    which is a common occurrence in Oracle installations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果由于权限或其他原因导致 `v$transaction` 视图不可用，[`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法将引发异常，这在 Oracle 安装中是常见的。
- en: The cx_Oracle dialect attempts to call the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method when the dialect makes
    its first connection to the database in order to acquire the “default”isolation
    level. This default level is necessary so that the level can be reset on a connection
    after it has been temporarily modified using [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method. In the common event
    that the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method raises an exception
    due to `v$transaction` not being readable as well as any other database-related
    failure, the level is assumed to be “READ COMMITTED”. No warning is emitted for
    this initial first-connect condition as it is expected to be a common restriction
    on Oracle databases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当方言首次连接到数据库时，cx_Oracle 方言尝试调用 [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法以获取“默认”隔离级别。这个默认级别是必要的，以便在使用
    [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") 方法临时修改连接后，可以将级别重置为连接。在常见事件中，[`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法由于 `v$transaction` 不可读以及任何其他与数据库相关的故障而引发异常时，级别被假定为“READ
    COMMITTED”。对于这种初始首次连接条件，不会发出警告，因为预计这是 Oracle 数据库的常见限制。
- en: 'New in version 1.3.16: added support for AUTOCOMMIT to the cx_oracle dialect
    as well as the notion of a default isolation level'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.16 中新增了对 cx_oracle 方言的 AUTOCOMMIT 支持，以及默认隔离级别的概念
- en: 'New in version 1.3.21: Added support for SERIALIZABLE as well as live reading
    of the isolation level.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.21 中新增了对 SERIALIZABLE 的支持，以及隔离级别的实时读取。
- en: 'Changed in version 1.3.22: In the event that the default isolation level cannot
    be read due to permissions on the v$transaction view as is common in Oracle installations,
    the default isolation level is hardcoded to “READ COMMITTED” which was the behavior
    prior to 1.3.21.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.22 中的更改：在默认隔离级别由于 v$transaction 视图的权限而无法读取的情况下（这在 Oracle 安装中很常见），默认隔离级别被硬编码为“READ
    COMMITTED”，这是 1.3.21 之前的行为。
- en: See also
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括 DBAPI 自动提交](../core/connections.html#dbapi-autocommit)'
- en: Identifier Casing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符大小写
- en: In Oracle, the data dictionary represents all case insensitive identifier names
    using UPPERCASE text. SQLAlchemy on the other hand considers an all-lower case
    identifier name to be case insensitive. The Oracle dialect converts all case insensitive
    identifiers to and from those two formats during schema level communication, such
    as reflection of tables and indexes. Using an UPPERCASE name on the SQLAlchemy
    side indicates a case sensitive identifier, and SQLAlchemy will quote the name
    - this will cause mismatches against data dictionary data received from Oracle,
    so unless identifier names have been truly created as case sensitive (i.e. using
    quoted names), all lowercase names should be used on the SQLAlchemy side.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 中，数据字典使用大写文本表示所有不区分大小写的标识符名称。另一方面，SQLAlchemy 将所有小写标识符名称视为不区分大小写。Oracle
    方言在模式级通信（如表和索引的反射）期间将所有不区分大小写的标识符转换为这两种格式之一。在 SQLAlchemy 方面使用大写名称表示区分大小写的标识符，SQLAlchemy
    将引用该名称 - 这将导致与从 Oracle 收到的数据字典数据不匹配，因此除非标识符名称真正被创建为区分大小写（即使用带引号的名称），否则在 SQLAlchemy
    方面应使用所有小写名称。
- en: '## Max Identifier Lengths'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '## 最大标识符长度'
- en: Oracle has changed the default max identifier length as of Oracle Server version
    12.2\. Prior to this version, the length was 30, and for 12.2 and greater it is
    now 128\. This change impacts SQLAlchemy in the area of generated SQL label names
    as well as the generation of constraint names, particularly in the case where
    the constraint naming convention feature described at [Configuring Constraint
    Naming Conventions](../core/constraints.html#constraint-naming-conventions) is
    being used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Oracle Server 版本 12.2，Oracle 已更改了默认的最大标识符长度。在此版本之前，长度为 30，在 12.2 及更高版本中，现在为
    128。这一变化影响了 SQLAlchemy 在生成的 SQL 标签名称以及约束名称的区域，特别是在使用描述在 [配置约束命名约定](../core/constraints.html#constraint-naming-conventions)
    中的约束命名约定特性时。
- en: To assist with this change and others, Oracle includes the concept of a “compatibility”
    version, which is a version number that is independent of the actual server version
    in order to assist with migration of Oracle databases, and may be configured within
    the Oracle server itself. This compatibility version is retrieved using the query
    `SELECT value FROM v$parameter WHERE name = 'compatible';`. The SQLAlchemy Oracle
    dialect, when tasked with determining the default max identifier length, will
    attempt to use this query upon first connect in order to determine the effective
    compatibility version of the server, which determines what the maximum allowed
    identifier length is for the server. If the table is not available, the server
    version information is used instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了辅助这一变化和其他变化，Oracle 包括了“兼容性”版本的概念，这是一个与实际服务器版本无关的版本号，用于帮助迁移 Oracle 数据库，并可以在
    Oracle 服务器内部配置。这个兼容性版本是使用查询 `SELECT value FROM v$parameter WHERE name = 'compatible';`
    检索的。当 SQLAlchemy Oracle 方言被要求确定默认的最大标识符长度时，它将在第一次连接时尝试使用此查询，以确定服务器的有效兼容性版本，该版本确定了服务器允许的最大标识符长度。如果表不可用，则使用服务器版本信息。
- en: 'As of SQLAlchemy 1.4, the default max identifier length for the Oracle dialect
    is 128 characters. Upon first connect, the compatibility version is detected and
    if it is less than Oracle version 12.2, the max identifier length is changed to
    be 30 characters. In all cases, setting the [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") parameter will bypass this change and the value given
    will be used as is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 1.4 开始，Oracle 方言的默认最大标识符长度为 128 个字符。在第一次连接时，检测到兼容性版本，如果小于 Oracle
    版本 12.2，则将最大标识符长度更改为 30 个字符。在所有情况下，设置 [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") 参数将绕过此更改，并且将使用给定的值：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The maximum identifier length comes into play both when generating anonymized
    SQL labels in SELECT statements, but more crucially when generating constraint
    names from a naming convention. It is this area that has created the need for
    SQLAlchemy to change this default conservatively. For example, the following naming
    convention produces two very different constraint names based on the identifier
    length:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最大标识符长度在生成 SELECT 语句中的匿名化 SQL 标签时起作用，但更重要的是在根据命名约定生成约束名称时起作用。正是这一领域促使 SQLAlchemy
    谨慎地更改了这个默认值。例如，以下命名约定根据标识符长度产生了两个非常不同的约束名称：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With an identifier length of 30, the above CREATE INDEX looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标识符长度为 30 时，上述 CREATE INDEX 看起来像：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However with length=128, it becomes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当长度为 128 时，它变成：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Applications which have run versions of SQLAlchemy prior to 1.4 on an Oracle
    server version 12.2 or greater are therefore subject to the scenario of a database
    migration that wishes to “DROP CONSTRAINT” on a name that was previously generated
    with the shorter length. This migration will fail when the identifier length is
    changed without the name of the index or constraint first being adjusted. Such
    applications are strongly advised to make use of [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") in order to maintain control of the generation of
    truncated names, and to fully review and test all database migrations in a staging
    environment when changing this value to ensure that the impact of this change
    has been mitigated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 服务器版本 12.2 或更高版本上运行 SQLAlchemy 之前版本的应用程序因此可能受到以下情景的影响：希望对以较短长度生成的名称进行“DROP
    CONSTRAINT”的数据库迁移。当更改标识符长度而不首先调整索引或约束的名称时，此迁移将失败。因此，强烈建议这些应用程序使用 [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") 来控制生成截断名称，并在更改此值时完全审查和测试所有数据库迁移，以确保已减轻此更改的影响。
- en: 'Changed in version 1.4: the default max_identifier_length for Oracle is 128
    characters, which is adjusted down to 30 upon first connect if an older version
    of Oracle server (compatibility version < 12.2) is detected.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.4 开始：Oracle 的默认 max_identifier_length 是 128 个字符，如果检测到旧版 Oracle 服务器（兼容性版本
    < 12.2），则在首次连接时调整为 30。
- en: LIMIT/OFFSET/FETCH Support
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIMIT/OFFSET/FETCH 支持
- en: Methods like [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") make use of `FETCH FIRST N ROW / OFFSET
    N ROWS` syntax assuming Oracle 12c or above, and assuming the SELECT statement
    is not embedded within a compound statement like UNION. This syntax is also available
    directly by using the [`Select.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.Select.fetch
    "sqlalchemy.sql.expression.Select.fetch") method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 这样的方法使用 `FETCH FIRST N ROW / OFFSET
    N ROWS` 语法，假设 Oracle 12c 或以上版本，并假设 SELECT 语句不嵌套在 UNION 这样的复合语句中。使用 [`Select.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.Select.fetch
    "sqlalchemy.sql.expression.Select.fetch") 方法也可以直接使用此语法。
- en: 'Changed in version 2.0: the Oracle dialect now uses `FETCH FIRST N ROW / OFFSET
    N ROWS` for all [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") usage including within the ORM and
    legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query").
    To force the legacy behavior using window functions, specify the `enable_offset_fetch=False`
    dialect parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始：Oracle 方言现在对所有 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 的用法，包括 ORM 和旧版 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")，都使用 `FETCH FIRST N ROW / OFFSET N ROWS`。要强制使用窗口函数来保留旧版行为，请将
    `enable_offset_fetch=False` 方言参数传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")。
- en: The use of `FETCH FIRST / OFFSET` may be disabled on any Oracle version by passing
    `enable_offset_fetch=False` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will force the use of “legacy” mode that makes
    use of window functions. This mode is also selected automatically when using a
    version of Oracle prior to 12c.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任何 Oracle 版本上传递 `enable_offset_fetch=False` 给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，可以禁用 `FETCH FIRST / OFFSET` 的使用，这将强制使用使用窗口函数的“传统”模式。在使用
    Oracle 12c 之前的版本时，也会自动选择此模式。
- en: When using legacy mode, or when a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement with limit/offset is embedded in
    a compound statement, an emulated approach for LIMIT / OFFSET based on window
    functions is used, which involves creation of a subquery using `ROW_NUMBER` that
    is prone to performance issues as well as SQL construction issues for complex
    statements. However, this approach is supported by all Oracle versions. See notes
    below.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用传统模式或将带有限制/偏移的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 语句嵌入到复合语句中时，将使用基于窗口函数的 LIMIT / OFFSET 的模拟方法，涉及使用
    `ROW_NUMBER` 创建子查询，这种方法容易出现性能问题以及对于复杂语句的 SQL 构建问题。但是，所有 Oracle 版本都支持此方法。请参阅下面的说明。
- en: Notes on LIMIT / OFFSET emulation (when fetch() method cannot be used)
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 LIMIT / OFFSET 模拟（当无法使用 fetch() 方法时）
- en: 'If using [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset"), or with the ORM the [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit") and [`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset") methods on an Oracle version prior to 12c, the
    following notes apply:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Oracle 12c 之前的版本中使用 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset")，或使用 ORM 中的 [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit") 和 [`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset") 方法，以下注意事项适用：
- en: SQLAlchemy currently makes use of ROWNUM to achieve LIMIT/OFFSET; the exact
    methodology is taken from [https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)
    .
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy 目前使用 ROWNUM 来实现 LIMIT/OFFSET；确切的方法取自 [https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)。
- en: the “FIRST_ROWS()” optimization keyword is not used by default. To enable the
    usage of this optimization directive, specify `optimize_limits=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下不使用“FIRST_ROWS()”优化关键字。要启用此优化指令的使用，请在 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 中指定 `optimize_limits=True`。
- en: 'Changed in version 1.4: The Oracle dialect renders limit/offset integer values
    using a “post compile” scheme which renders the integer directly before passing
    the statement to the cursor for execution. The `use_binds_for_limits` flag no
    longer has an effect.'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1.4 版更改：Oracle 方言使用“编译后”方案呈现限制/偏移整数值，直接在传递语句给游标执行之前呈现整数。`use_binds_for_limits`
    标志不再起作用。
- en: See also
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](../changelog/migration_14.html#change-4808).'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Oracle 中用于 LIMIT/OFFSET 的新“编译后”绑定参数，以及 SQL Server](../changelog/migration_14.html#change-4808)。'
- en: '## RETURNING Support'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '## RETURNING 支持'
- en: The Oracle database supports RETURNING fully for INSERT, UPDATE and DELETE statements
    that are invoked with a single collection of bound parameters (that is, a `cursor.execute()`
    style statement; SQLAlchemy does not generally support RETURNING with [executemany](../glossary.html#term-executemany)
    statements). Multiple rows may be returned as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 数据库完全支持对使用单个绑定参数集合调用的 INSERT、UPDATE 和 DELETE 语句进行 RETURNING（即`cursor.execute()`风格语句；SQLAlchemy
    通常不支持在 [executemany](../glossary.html#term-executemany) 语句中使用 RETURNING）。也可以返回多行。
- en: 'Changed in version 2.0: the Oracle backend has full support for RETURNING on
    parity with other backends.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版更改：Oracle 后端具有与其他后端相同的 RETURNING 完全支持。
- en: ON UPDATE CASCADE
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ON UPDATE CASCADE
- en: Oracle doesn’t have native ON UPDATE CASCADE functionality. A trigger based
    solution is available at [https://asktom.oracle.com/tkyte/update_cascade/index.html](https://asktom.oracle.com/tkyte/update_cascade/index.html)
    .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 没有本地的 ON UPDATE CASCADE 功能。可以在 [https://asktom.oracle.com/tkyte/update_cascade/index.html](https://asktom.oracle.com/tkyte/update_cascade/index.html)
    上找到基于触发器的解决方案。
- en: When using the SQLAlchemy ORM, the ORM has limited ability to manually issue
    cascading updates - specify ForeignKey objects using the “deferrable=True, initially=’deferred’”
    keyword arguments, and specify “passive_updates=False” on each relationship().
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 SQLAlchemy ORM 时，ORM 有限的能力可以手动发出级联更新 - 使用“deferrable=True, initially=’deferred’”关键字参数指定
    ForeignKey 对象，并在每个 relationship() 上指定 “passive_updates=False”。
- en: Oracle 8 Compatibility
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 8 兼容性
- en: Warning
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The status of Oracle 8 compatibility is not known for SQLAlchemy 2.0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的 Oracle 8 兼容性状态未知。
- en: 'When Oracle 8 is detected, the dialect internally configures itself to the
    following behaviors:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到 Oracle 8 时，方言会自动配置为以下行为：
- en: the use_ansi flag is set to False. This has the effect of converting all JOIN
    phrases into the WHERE clause, and in the case of LEFT OUTER JOIN makes use of
    Oracle’s (+) operator.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `use_ansi` 标志设置为 False。这会将所有 JOIN 词组转换为 WHERE 子句，并且在左外连接的情况下使用 Oracle 的 (+)
    运算符。
- en: the NVARCHAR2 and NCLOB datatypes are no longer generated as DDL when the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") is used - VARCHAR2 and CLOB are issued instead. This
    because these types don’t seem to work correctly on Oracle 8 even though they
    are available. The [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    types will always generate NVARCHAR2 and NCLOB.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    时，NVARCHAR2 和 NCLOB 数据类型不再生成 DDL - 而是生成 VARCHAR2 和 CLOB。这是因为即使这些类型可用，它们在 Oracle
    8 上似乎无法正常工作。[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR")
    和 [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    类型将始终生成 NVARCHAR2 和 NCLOB。
- en: Synonym/DBLINK Reflection
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同义词/DBLINK 反射
- en: 'When using reflection with Table objects, the dialect can optionally search
    for tables indicated by synonyms, either in local or remote schemas or accessed
    over DBLINK, by passing the flag `oracle_resolve_synonyms=True` as a keyword argument
    to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反射与表对象时，方言可以选择性地搜索由同义词指示的表，可以是在本地或远程模式或通过 DBLINK 访问，通过将标志 `oracle_resolve_synonyms=True`
    作为关键字参数传递给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    构造函数：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When this flag is set, the given name (such as `some_table` above) will be searched
    not just in the `ALL_TABLES` view, but also within the `ALL_SYNONYMS` view to
    see if this name is actually a synonym to another name. If the synonym is located
    and refers to a DBLINK, the oracle dialect knows how to locate the table’s information
    using DBLINK syntax(e.g. `@dblink`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置此标志时，给定的名称（例如上面的 `some_table`）将不仅在 `ALL_TABLES` 视图中搜索，还将在 `ALL_SYNONYMS`
    视图中搜索，以查看此名称是否实际上是另一个名称的同义词。如果找到了同义词并且引用了 DBLINK，则 Oracle 方言知道如何使用 DBLINK 语法定位表的信息（例如
    `@dblink`）。
- en: '`oracle_resolve_synonyms` is accepted wherever reflection arguments are accepted,
    including methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") and [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns").'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`oracle_resolve_synonyms` 在接受反射参数的任何地方都被接受，包括诸如 [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 和 [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") 之类的方法。'
- en: If synonyms are not in use, this flag should be left disabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用同义词，则应禁用此标志。
- en: '## Constraint Reflection'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '## 约束反射'
- en: The Oracle dialect can return information about foreign key, unique, and CHECK
    constraints, as well as indexes on tables.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 方言可以返回有关表上的外键、唯一约束和 CHECK 约束以及索引的信息。
- en: Raw information regarding these constraints can be acquired using [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys"), [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints"), [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"), and [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")、[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")、[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") 和[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")获取关于这些约束的原始信息。
- en: 'Changed in version 1.2: The Oracle dialect can now reflect UNIQUE and CHECK
    constraints.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.2 更改：Oracle 方言现在可以反映唯一约束和检查约束。
- en: When using reflection at the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") level, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also include these constraints.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")级别使用反射时，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")也将包括这些约束。
- en: 'Note the following caveats:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下注意事项：
- en: 'When using the [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") method, Oracle
    builds a special “IS NOT NULL” constraint for columns that specify “NOT NULL”.
    This constraint is **not** returned by default; to include the “IS NOT NULL” constraints,
    pass the flag `include_all=True`:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")方法时，Oracle 为指定“NOT
    NULL”的列构建一个特殊的“IS NOT NULL”约束。 默认情况下，此约束**不**会被返回；要包括“IS NOT NULL”约束，传递标志`include_all=True`：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: in most cases, when reflecting a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), a UNIQUE constraint will **not** be available as a
    [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") object, as Oracle mirrors unique constraints
    with a UNIQUE index in most cases (the exception seems to be when two or more
    unique constraints represent the same columns); the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will instead represent these using [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` flag set.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，当反映一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")时，唯一约束将**不**作为[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")对象可用，因为在大多数情况下，Oracle 使用唯一索引来镜像唯一约束（例外情况似乎是当两个或更多个唯一约束表示相同的列时）；[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")将使用设置了`unique=True`标志的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")来代替这些。
- en: Oracle creates an implicit index for the primary key of a table; this index
    is **excluded** from all index results.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle 为表的主键创建一个隐式索引；此索引被**排除**在所有索引结果之外。
- en: the list of columns reflected for an index will not include column names that
    start with SYS_NC.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于索引反映的列列表，不会包括以 SYS_NC 开头的列名。
- en: Table names with SYSTEM/SYSAUX tablespaces
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有 SYSTEM/SYSAUX 表空间的表名称
- en: 'The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") methods each return
    a list of table names for the current engine. These methods are also part of the
    reflection which occurs within an operation such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). By default, these operations exclude the
    `SYSTEM` and `SYSAUX` tablespaces from the operation. In order to change this,
    the default list of tablespaces excluded can be changed at the engine level using
    the `exclude_tablespaces` parameter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 和 [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") 方法分别返回当前引擎的表名列表。这些方法也是在操作中进行反射的一部分，例如[`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")。默认情况下，这些操作将从操作中排除`SYSTEM`和`SYSAUX`表空间。为了更改此设置，可以在引擎级别使用`exclude_tablespaces`参数更改默认的排除表空间列表：'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: DateTime Compatibility
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期时间兼容性
- en: Oracle has no datatype known as `DATETIME`, it instead has only `DATE`, which
    can actually store a date and time value. For this reason, the Oracle dialect
    provides a type [`DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")
    which is a subclass of [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"). This type has no special behavior, and is only present
    as a “marker” for this type; additionally, when a database column is reflected
    and the type is reported as `DATE`, the time-supporting [`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE") type is used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 没有名为`DATETIME`的数据类型，它只有`DATE`，实际上可以存储日期和时间值。因此，Oracle 方言提供了一个[`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE")类型，它是[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")的子类。此类型没有特殊行为，仅作为此类型的“标记”存在；此外，当反映数据库列并且类型报告为`DATE`时，将使用支持时间的[`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE")类型。
- en: '## Oracle Table Options'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '## Oracle 表选项'
- en: 'The CREATE TABLE phrase supports the following options with Oracle in conjunction
    with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在与[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")结构一起使用
    Oracle 时，CREATE TABLE 语句支持以下选项：
- en: '`ON COMMIT`:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON COMMIT`：'
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`COMPRESS`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESS`：'
- en: '[PRE13]  ## Oracle Specific Index Options'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE13]  ## Oracle 特定索引选项'
- en: Bitmap Indexes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图索引
- en: 'You can specify the `oracle_bitmap` parameter to create a bitmap index instead
    of a B-tree index:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定`oracle_bitmap`参数来创建位图索引，而不是B树索引：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
    check for such limitations, only the database will.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 位图索引不能是唯一的，也不能被压缩。SQLAlchemy 不会检查这些限制，只有数据库会。
- en: Index compression
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引压缩
- en: 'Oracle has a more efficient storage mode for indexes containing lots of repeated
    values. Use the `oracle_compress` parameter to turn on key compression:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle对包含大量重复值的索引有更有效的存储模式。使用`oracle_compress`参数来打开键压缩：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `oracle_compress` parameter accepts either an integer specifying the number
    of prefix columns to compress, or `True` to use the default (all columns for non-unique
    indexes, all but the last column for unique indexes).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`oracle_compress`参数可以接受一个整数，指定要压缩的前缀列数，或者`True`以使用默认值（非唯一索引的所有列，唯一索引除最后一列外的所有列）。'
- en: Oracle Data Types
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 数据类型
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with Oracle are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 SQLAlchemy 方言一样，所有已知与 Oracle 有效的大写类型都可以从顶层方言导入，无论它们来自[`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types
    "sqlalchemy.types")还是来自本地方言：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'New in version 1.2.19: Added [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") to the list of datatypes exported by the Oracle dialect.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.19 版中新增：将[`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")添加到由
    Oracle 方言导出的数据类型列表中。
- en: 'Types which are specific to Oracle, or have Oracle-specific construction arguments,
    are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于Oracle的类型，或具有特定于Oracle的构造参数的类型如下：
- en: '| Object Name | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [BFILE](#sqlalchemy.dialects.oracle.BFILE) |  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| [BFILE](#sqlalchemy.dialects.oracle.BFILE) |  |'
- en: '| [BINARY_DOUBLE](#sqlalchemy.dialects.oracle.BINARY_DOUBLE) |  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| [BINARY_DOUBLE](#sqlalchemy.dialects.oracle.BINARY_DOUBLE) |  |'
- en: '| [BINARY_FLOAT](#sqlalchemy.dialects.oracle.BINARY_FLOAT) |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| [BINARY_FLOAT](#sqlalchemy.dialects.oracle.BINARY_FLOAT) |  |'
- en: '| [DATE](#sqlalchemy.dialects.oracle.DATE) | Provide the oracle DATE type.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| [DATE](#sqlalchemy.dialects.oracle.DATE) | 提供oracle DATE类型。 |'
- en: '| [FLOAT](#sqlalchemy.dialects.oracle.FLOAT) | Oracle FLOAT. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| [FLOAT](#sqlalchemy.dialects.oracle.FLOAT) | Oracle FLOAT。 |'
- en: '| [INTERVAL](#sqlalchemy.dialects.oracle.INTERVAL) |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| [INTERVAL](#sqlalchemy.dialects.oracle.INTERVAL) |  |'
- en: '| [LONG](#sqlalchemy.dialects.oracle.LONG) |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| [LONG](#sqlalchemy.dialects.oracle.LONG) |  |'
- en: '| [NCLOB](#sqlalchemy.dialects.oracle.NCLOB) |  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| [NCLOB](#sqlalchemy.dialects.oracle.NCLOB) |  |'
- en: '| [NUMBER](#sqlalchemy.dialects.oracle.NUMBER) |  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| [NUMBER](#sqlalchemy.dialects.oracle.NUMBER) |  |'
- en: '| [NVARCHAR2](#sqlalchemy.dialects.oracle.NVARCHAR2) | alias of [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.sql.sqltypes.NVARCHAR") |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| [NVARCHAR2](#sqlalchemy.dialects.oracle.NVARCHAR2) | [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.sql.sqltypes.NVARCHAR") 的别名 |'
- en: '| [RAW](#sqlalchemy.dialects.oracle.RAW) |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| [RAW](#sqlalchemy.dialects.oracle.RAW) |  |'
- en: '| [ROWID](#sqlalchemy.dialects.oracle.ROWID) | Oracle ROWID type. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| [ROWID](#sqlalchemy.dialects.oracle.ROWID) | Oracle ROWID 类型。 |'
- en: '| [TIMESTAMP](#sqlalchemy.dialects.oracle.TIMESTAMP) | Oracle implementation
    of `TIMESTAMP`, which supports additional Oracle-specific modes |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| [TIMESTAMP](#sqlalchemy.dialects.oracle.TIMESTAMP) | Oracle实现的`TIMESTAMP`，支持额外的Oracle特定模式
    |'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Members**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BFILE.__init__)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BFILE.__init__)'
- en: '**Class signature**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BFILE`](#sqlalchemy.dialects.oracle.BFILE
    "sqlalchemy.dialects.oracle.BFILE") ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.BFILE`](#sqlalchemy.dialects.oracle.BFILE "sqlalchemy.dialects.oracle.BFILE")
    ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    的 `sqlalchemy.types.LargeBinary.__init__` *方法继承*'
- en: Construct a LargeBinary type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 LargeBinary 类型。
- en: 'Parameters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**length** – 可选，用于DDL语句中的列长度，适用于接受长度的二进制类型，例如MySQL的BLOB类型。'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Members**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_DOUBLE.__init__)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_DOUBLE.__init__)'
- en: '**Class signature**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BINARY_DOUBLE`](#sqlalchemy.dialects.oracle.BINARY_DOUBLE
    "sqlalchemy.dialects.oracle.BINARY_DOUBLE") ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.BINARY_DOUBLE`](#sqlalchemy.dialects.oracle.BINARY_DOUBLE
    "sqlalchemy.dialects.oracle.BINARY_DOUBLE") ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    的 `sqlalchemy.types.Float.__init__` *方法继承*'
- en: Construct a Float.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 Float。
- en: 'Parameters:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`precision` –'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision` –'
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于DDL `CREATE TABLE` 中的数值精度。后端**应该**尝试确保此精度指示通用[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")数据类型的数字位数。
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT "sqlalchemy.dialects.oracle.FLOAT")
    datatype and specify the [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Oracle 后端，在渲染 DDL 时，不接受 [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") 参数，因为 Oracle 不支持将浮点精度指定为小数位数。相反，请使用 Oracle 特定的 [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") 数据类型，并指定 [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") 参数。这是 SQLAlchemy 版本 2.0 中的新功能。
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个与数据库无关的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")，并为
    Oracle 单独指定二进制精度，请使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 与 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 相同的标志，但默认为 `False`。请注意，将此标志设置为 `True` 会导致浮点数转换。'
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 在将浮点数转换为 Python 十进制数时使用的默认精度。由于十进制不准确性，浮点值通常会更长，而大多数浮点数据库类型没有“精度”概念，因此默认情况下，浮点类型在转换时会查找前十位小数点。指定此值将覆盖该长度。请注意，MySQL
    浮点类型包括“精度”，如果未另行指定，则将使用“精度”作为 decimal_return_scale 的默认值。'
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Members**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_FLOAT.__init__)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_FLOAT.__init__)'
- en: '**Class signature**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BINARY_FLOAT`](#sqlalchemy.dialects.oracle.BINARY_FLOAT
    "sqlalchemy.dialects.oracle.BINARY_FLOAT") ([`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.oracle.BINARY_FLOAT`](#sqlalchemy.dialects.oracle.BINARY_FLOAT
    "sqlalchemy.dialects.oracle.BINARY_FLOAT") ([`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"))
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    *的* `sqlalchemy.types.Float.__init__` *方法*'
- en: Construct a Float.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 Float。
- en: 'Parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`precision` –'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision` –'
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于在 DDL `CREATE TABLE` 中使用的数字精度。后端**应该**尽量确保此精度表示通用 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 数据类型的数字位数。
- en: Note
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT "sqlalchemy.dialects.oracle.FLOAT")
    datatype and specify the [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Oracle 后端，在渲染 DDL 时，不接受[`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float")参数，因为 Oracle 不支持将浮点精度指定为小数位数。相反，使用特定于 Oracle 的[`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT")数据类型，并指定[`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT")参数。这是 SQLAlchemy 版本 2.0 中的新功能。
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个与数据库无关的[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")，分别为
    Oracle 指定二进制精度，可以使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")，如下所示：
- en: '[PRE24]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 与[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")相同的标志，但默认值为`False`。请注意，将此标志设置为`True`会导致浮点转换。'
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 在将浮点数转换为 Python 十进制数时使用的默认精度。由于十进制的不准确性，浮点值通常会更长，并且大多数浮点数据库类型都没有“精度”的概念，因此，默认情况下，浮点类型在转换时会寻找前十位小数点。指定此值将覆盖该长度。请注意，如果未另行指定，包括“精度”的
    MySQL 浮点类型将使用“精度”作为 decimal_return_scale 的默认值。'
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Provide the oracle DATE type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 提供 Oracle DATE 类型。
- en: This type has no special Python behavior, except that it subclasses [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"); this is to suit the fact that the Oracle `DATE`
    type supports a time value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型没有特殊的 Python 行为，除了它是[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")的子类；这是为了适应 Oracle `DATE` 类型支持时间值的事实。
- en: '**Members**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.DATE.__init__)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.DATE.__init__)'
- en: '**Class signature**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")
    (`sqlalchemy.dialects.oracle.types._OracleDateLiteralRender`, [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")（`sqlalchemy.dialects.oracle.types._OracleDateLiteralRender`，[`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")）
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")*的*
    `sqlalchemy.types.DateTime.__init__` *方法*'
- en: Construct a new [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")。
- en: 'Parameters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype directly when using this flag, as some
    databases include separate generic date/time-holding types distinct from the timezone-capable
    TIMESTAMP datatype, such as Oracle.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**时区** – 布尔值。表示日期时间类型是否应在**仅基本日期/时间保存类型**上启用时区支持（如果可用）。建议在使用此标志时直接使用[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型，因为一些数据库包括与时区可用的TIMESTAMP数据类型不同的独立通用日期/时间保存类型，例如Oracle。'
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Oracle FLOAT.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle FLOAT。
- en: This is the same as [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT") except that an Oracle-specific [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter is accepted, and the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT")相同，不同之处在于接受特定于Oracle的[`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT")参数，并且不接受[`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float")参数。
- en: Oracle FLOAT types indicate precision in terms of “binary precision”, which
    defaults to 126\. For a REAL type, the value is 63\. This parameter does not cleanly
    map to a specific number of decimal places but is roughly equivalent to the desired
    number of decimal places divided by 0.3103.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle FLOAT类型以“二进制精度”表示精度，默认为126。对于REAL类型，该值为63。此参数不清晰地映射到特定数量的小数位数，但大致相当于所需小数位数除以0.3103。
- en: New in version 2.0.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版中的新功能。
- en: '**Members**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.FLOAT.__init__)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.FLOAT.__init__)'
- en: '**Class signature**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") ([`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT"))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") ([`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT"))
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Construct a FLOAT
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个FLOAT
- en: 'Parameters:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`binary_precision` – Oracle binary precision value to be rendered in DDL. This
    may be approximated to the number of decimal characters using the formula “decimal
    precision = 0.30103 * binary precision”. The default value used by Oracle for
    FLOAT / DOUBLE PRECISION is 126.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binary_precision` – 要在DDL中呈现的Oracle二进制精度值。这可以使用公式“十进制精度= 0.30103 * 二进制精度”来近似到十进制字符的数量。Oracle用于FLOAT
    / DOUBLE PRECISION的默认值为126。'
- en: '`asdecimal` – See [`Float.asdecimal`](../core/type_basics.html#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float")'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 参见[`Float.asdecimal`](../core/type_basics.html#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float")'
- en: '`decimal_return_scale` – See [`Float.decimal_return_scale`](../core/type_basics.html#sqlalchemy.types.Float.params.decimal_return_scale
    "sqlalchemy.types.Float")'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 参见[`Float.decimal_return_scale`](../core/type_basics.html#sqlalchemy.types.Float.params.decimal_return_scale
    "sqlalchemy.types.Float")'
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Members**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.INTERVAL.__init__)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.INTERVAL.__init__)'
- en: '**Class signature**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.INTERVAL`](#sqlalchemy.dialects.oracle.INTERVAL
    "sqlalchemy.dialects.oracle.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.INTERVAL`](#sqlalchemy.dialects.oracle.INTERVAL
    "sqlalchemy.dialects.oracle.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Construct an INTERVAL.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个INTERVAL。
- en: Note that only DAY TO SECOND intervals are currently supported. This is due
    to a lack of support for YEAR TO MONTH intervals within available DBAPIs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当前仅支持DAY TO SECOND间隔。这是由于可用DBAPI中缺少对YEAR TO MONTH间隔的支持。
- en: 'Parameters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`day_precision` – the day precision value. this is the number of digits to
    store for the day field. Defaults to “2”'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day_precision` – 日期精度值。这是要存储的日字段的位数。默认为“2”。'
- en: '`second_precision` – the second precision value. this is the number of digits
    to store for the fractional seconds field. Defaults to “6”.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second_precision` – 秒精度值。这是要存储的分数秒字段的位数。默认为“6”。'
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Members**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.NCLOB.__init__)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.NCLOB.__init__)'
- en: '**Class signature**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.NCLOB`](#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text"))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.oracle.NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")类（[`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text")）'
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    *的* `sqlalchemy.types.String.__init__` *方法*'
- en: Create a string-holding type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个持有字符串的类型。
- en: 'Parameters:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` – 可选的，在DDL和CAST表达式中使用的列的长度。如果不会发出`CREATE TABLE`，可以安全地省略。某些数据库可能需要在DDL中使用长度，并且如果包含了没有长度的`VARCHAR`，则在发出`CREATE
    TABLE` DDL时将引发异常。该值被解释为字节还是字符取决于数据库。'
- en: '`collation` –'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collation` –'
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选的，在DDL和CAST表达式中使用的列级排序。使用SQLite、MySQL和PostgreSQL支持的COLLATE关键字呈现。例如：
- en: '[PRE33]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，应使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")或[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")数据类型来存储非ASCII数据的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。这些数据类型将确保在数据库上使用正确的类型。
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: alias of [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.sql.sqltypes.NVARCHAR")
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.sql.sqltypes.NVARCHAR")的别名'
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Class signature**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") ([`sqlalchemy.types.Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.oracle.NUMBER`](#sqlalchemy.dialects.oracle.NUMBER "sqlalchemy.dialects.oracle.NUMBER")类（[`sqlalchemy.types.Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")，[`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")）'
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Members**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.LONG.__init__)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.LONG.__init__)'
- en: '**Class signature**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.LONG`](#sqlalchemy.dialects.oracle.LONG "sqlalchemy.dialects.oracle.LONG")
    ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.oracle.LONG`](#sqlalchemy.dialects.oracle.LONG "sqlalchemy.dialects.oracle.LONG")类（[`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text")）'
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    *的* `sqlalchemy.types.String.__init__` *方法*'
- en: Create a string-holding type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个持有字符串的类型。
- en: 'Parameters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` – 可选的，在DDL和CAST表达式中使用的列的长度。如果不会发出`CREATE TABLE`，可以安全地省略。某些数据库可能需要在DDL中使用长度，并且如果包含了没有长度的`VARCHAR`，则在发出`CREATE
    TABLE` DDL时将引发异常。该值被解释为字节还是字符取决于数据库。'
- en: '`collation` –'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collation` –'
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选的，在DDL和CAST表达式中使用的列级排序。使用SQLite、MySQL和PostgreSQL支持的COLLATE关键字呈现。例如：
- en: '[PRE38]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，应该使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")或[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")数据类型来表示预期存储非 ASCII 数据的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。这些数据类型将确保在数据库上使用正确的类型。
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Class signature**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.RAW`](#sqlalchemy.dialects.oracle.RAW "sqlalchemy.dialects.oracle.RAW")
    (`sqlalchemy.types._Binary`)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.RAW`](#sqlalchemy.dialects.oracle.RAW "sqlalchemy.dialects.oracle.RAW")
    (`sqlalchemy.types._Binary`)
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Oracle ROWID type.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle ROWID 类型。
- en: When used in a cast() or similar, generates ROWID.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cast() 或类似情况下使用时，生成 ROWID。
- en: '**Class signature**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.ROWID`](#sqlalchemy.dialects.oracle.ROWID
    "sqlalchemy.dialects.oracle.ROWID") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.ROWID`](#sqlalchemy.dialects.oracle.ROWID "sqlalchemy.dialects.oracle.ROWID")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Oracle implementation of `TIMESTAMP`, which supports additional Oracle-specific
    modes
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 实现的 `TIMESTAMP`，支持额外的 Oracle 特定模式
- en: New in version 2.0.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本中的新功能。
- en: '**Members**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.TIMESTAMP.__init__)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.TIMESTAMP.__init__)'
- en: '**Class signature**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP
    "sqlalchemy.dialects.oracle.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP
    "sqlalchemy.dialects.oracle.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Construct a new [`TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP "sqlalchemy.dialects.oracle.TIMESTAMP").
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的[`TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP "sqlalchemy.dialects.oracle.TIMESTAMP")。
- en: 'Parameters:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`timezone` – boolean. Indicates that the TIMESTAMP type should use Oracle’s
    `TIMESTAMP WITH TIME ZONE` datatype.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timezone` – 布尔值。表示 TIMESTAMP 类型应该使用 Oracle 的 `TIMESTAMP WITH TIME ZONE` 数据类型。'
- en: '`local_timezone` – boolean. Indicates that the TIMESTAMP type should use Oracle’s
    `TIMESTAMP WITH LOCAL TIME ZONE` datatype.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_timezone` – 布尔值。表示 TIMESTAMP 类型应该使用 Oracle 的 `TIMESTAMP WITH LOCAL TIME
    ZONE` 数据类型。'
- en: '## cx_Oracle'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '## cx_Oracle'
- en: Support for the Oracle database via the cx-Oracle driver.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 cx-Oracle 驱动程序支持 Oracle 数据库。
- en: DBAPI
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for cx-Oracle is available
    at: [https://oracle.github.io/python-cx_Oracle/](https://oracle.github.io/python-cx_Oracle/)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: cx-Oracle 的文档和下载信息（如果适用）可在此处获得：[https://oracle.github.io/python-cx_Oracle/](https://oracle.github.io/python-cx_Oracle/)
- en: Connecting
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: DSN vs. Hostname connections
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DSN vs. 主机名连接
- en: cx_Oracle provides several methods of indicating the target database. The dialect
    translates from a series of different URL forms.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 提供了几种指示目标数据库的方法。方言从一系列不同的 URL 形式转换而来。
- en: Hostname Connections with Easy Connect Syntax
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Easy Connect 语法的主机名连接
- en: 'Given a hostname, port and service name of the target Oracle Database, for
    example from Oracle’s [Easy Connect syntax](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings),
    then connect in SQLAlchemy using the `service_name` query string parameter:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 给定目标 Oracle 数据库的主机名、端口和服务名称，例如来自 Oracle 的 [Easy Connect 语法](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings)，然后在
    SQLAlchemy 中使用 `service_name` 查询字符串参数进行连接：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The [full Easy Connect syntax](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)
    is not supported. Instead, use a `tnsnames.ora` file and connect using a DSN.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持[完整的 Easy Connect 语法](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)。而是使用
    `tnsnames.ora` 文件，并使用 DSN 进行连接。
- en: Connections with tnsnames.ora or Oracle Cloud
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有 tnsnames.ora 或 Oracle Cloud 的连接
- en: 'Alternatively, if no port, database name, or `service_name` is provided, the
    dialect will use an Oracle DSN “connection string”. This takes the “hostname”
    portion of the URL as the data source name. For example, if the `tnsnames.ora`
    file contains a [Net Service Name](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)
    of `myalias` as below:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果没有提供端口、数据库名称或 `service_name`，方言将使用 Oracle DSN “连接字符串”。这将 URL 的“主机名”部分视为数据源名称。例如，如果
    `tnsnames.ora` 文件包含如下的[网络服务名称](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)
    `myalias`：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The cx_Oracle dialect connects to this database service when `myalias` is the
    hostname portion of the URL, without specifying a port, database name or `service_name`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `myalias` 是 URL 的主机名部分，而没有指定端口、数据库名称或 `service_name` 时，cx_Oracle 方言将连接到此数据库服务：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Users of Oracle Cloud should use this syntax and also configure the cloud wallet
    as shown in cx_Oracle documentation [Connecting to Autononmous Databases](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Cloud 的用户应该使用这种语法，并按照 cx_Oracle 文档 [连接到 Autonomous 数据库](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases)
    中所示配置云钱包。
- en: SID Connections
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SID 连接
- en: 'To use Oracle’s obsolete SID connection syntax, the SID can be passed in a
    “database name” portion of the URL as below:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Oracle 的过时 SID 连接语法，SID 可以像下面这样通过 URL 的“数据库名称”部分传递：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Above, the DSN passed to cx_Oracle is created by `cx_Oracle.makedsn()` as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，传递给 cx_Oracle 的 DSN 是由 `cx_Oracle.makedsn()` 创建的，如下所示：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Passing cx_Oracle connect arguments
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递 cx_Oracle 连接参数
- en: 'Additional connection arguments can usually be passed via the URL query string;
    particular symbols like `cx_Oracle.SYSDBA` are intercepted and converted to the
    correct symbol:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过 URL 查询字符串传递其他连接参数；特定符号如 `cx_Oracle.SYSDBA` 将被拦截并转换为正确的符号：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Changed in version 1.3: the cx_oracle dialect now accepts all argument names
    within the URL string itself, to be passed to the cx_Oracle DBAPI. As was the
    case earlier but not correctly documented, the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter also accepts all cx_Oracle DBAPI connect
    arguments.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1.3 中更改：cx_oracle 方言现在接受 URL 字符串本身中的所有参数名称，以传递给 cx_Oracle DBAPI。与之前的情况一样，但没有正确记录，[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 参数也接受所有 cx_Oracle DBAPI 连接参数。
- en: 'To pass arguments directly to `.connect()` without using the query string,
    use the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary. Any cx_Oracle parameter value and/or constant
    may be passed, such as:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接传递参数到 `.connect()` 而不使用查询字符串，可以使用 [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典。可以传递任何 cx_Oracle 参数值和/或常量，例如：
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the default value for `encoding` and `nencoding` was changed to “UTF-8”
    in cx_Oracle 8.0 so these parameters can be omitted when using that version, or
    later.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 cx_Oracle 8.0 中，`encoding` 和 `nencoding` 的默认值已更改为 “UTF-8”，因此在使用该版本或更高版本时可以省略这些参数。
- en: Options consumed by the SQLAlchemy cx_Oracle dialect outside of the driver
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在驱动程序之外由 SQLAlchemy cx_Oracle 方言使用的选项
- en: 'There are also options that are consumed by the SQLAlchemy cx_oracle dialect
    itself. These options are always passed directly to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , such as:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些选项是由 SQLAlchemy cx_oracle 方言自身使用的。这些选项始终直接传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") ，例如：
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The parameters accepted by the cx_oracle dialect are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: cx_oracle 方言接受的参数如下：
- en: '`arraysize` - set the cx_oracle.arraysize value on cursors; defaults to `None`,
    indicating that the driver default should be used (typically the value is 100).
    This setting controls how many rows are buffered when fetching rows, and can have
    a significant effect on performance when modified. The setting is used for both
    `cx_Oracle` as well as `oracledb`.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arraysize` - 在游标上设置 cx_oracle.arraysize 的值；默认为 `None`，表示应该使用驱动程序的默认值（通常值为
    100）。此设置控制在获取行时缓冲多少行，并且在修改时可以对性能产生重大影响。该设置用于 `cx_Oracle` 以及 `oracledb`。'
- en: 'Changed in version 2.0.26: - changed the default value from 50 to None, to
    use the default value of the driver itself.'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在版本 2.0.26 中更改：- 将默认值从 50 更改为 None，以使用驱动程序本身的默认值。
- en: '`auto_convert_lobs` - defaults to True; See [LOB Datatypes](#cx-oracle-lob).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto_convert_lobs` - 默认为True；详见[LOB数据类型](#cx-oracle-lob)。'
- en: '`coerce_to_decimal` - see [Precision Numerics](#cx-oracle-numeric) for detail.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal` - 详见[精度数值](#cx-oracle-numeric)。'
- en: '`encoding_errors` - see [Encoding Errors](#cx-oracle-unicode-encoding-errors)
    for detail.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding_errors` - 详见[编码错误](#cx-oracle-unicode-encoding-errors)。'
- en: '### Using cx_Oracle SessionPool'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用cx_Oracle会话池'
- en: 'The cx_Oracle library provides its own connection pool implementation that
    may be used in place of SQLAlchemy’s pooling functionality. This can be achieved
    by using the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter to provide a function that returns a new
    connection, along with setting [`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine") to `NullPool` to disable SQLAlchemy’s pooling:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle库提供了自己的连接池实现，可以替代SQLAlchemy的池功能。可以通过使用[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")参数提供一个返回新连接的函数，并将[`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine")设置为`NullPool`来禁用SQLAlchemy的池化功能来实现：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The above engine may then be used normally where cx_Oracle’s pool handles connection
    pooling:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎可以像平常一样使用，其中cx_Oracle的池处理连接池：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As well as providing a scalable solution for multi-user applications, the cx_Oracle
    session pool supports some Oracle features such as DRCP and [Application Continuity](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为多用户应用程序提供可扩展的解决方案之外，cx_Oracle会话池还支持一些Oracle功能，如DRCP和[应用程序连续性](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac)。
- en: Using Oracle Database Resident Connection Pooling (DRCP)
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Oracle数据库Resident连接池（DRCP）
- en: When using Oracle’s [DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086),
    the best practice is to pass a connection class and “purity” when acquiring a
    connection from the SessionPool. Refer to the [cx_Oracle DRCP documentation](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Oracle的[DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086)时，最佳实践是在从SessionPool获取连接时传递连接类和“purity”。请参阅[cx_Oracle
    DRCP文档](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp)。
- en: 'This can be achieved by wrapping `pool.acquire()`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过包装`pool.acquire()`来实现：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The above engine may then be used normally where cx_Oracle handles session
    pooling and Oracle Database additionally uses DRCP:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎可以像平常一样使用，其中cx_Oracle处理会话池，Oracle数据库另外使用DRCP：
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '### Unicode'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '### Unicode'
- en: As is the case for all DBAPIs under Python 3, all strings are inherently Unicode
    strings. In all cases however, the driver requires an explicit encoding configuration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3下的所有DBAPI，所有字符串都是本质上的Unicode字符串。然而，在所有情况下，驱动程序都需要显式的编码配置。
- en: Ensuring the Correct Client Encoding
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确保正确的客户端编码
- en: The long accepted standard for establishing client encoding for nearly all Oracle
    related software is via the [NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)
    environment variable. cx_Oracle like most other Oracle drivers will use this environment
    variable as the source of its encoding configuration. The format of this variable
    is idiosyncratic; a typical value would be `AMERICAN_AMERICA.AL32UTF8`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有与Oracle相关的软件建立客户端编码的长期接受标准是通过[NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)环境变量。cx_Oracle像大多数其他Oracle驱动程序一样将使用此环境变量作为其编码配置的来源。此变量的格式是特殊的；典型的值可能是`AMERICAN_AMERICA.AL32UTF8`。
- en: 'The cx_Oracle driver also supports a programmatic alternative which is to pass
    the `encoding` and `nencoding` parameters directly to its `.connect()` function.
    These can be present in the URL as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle驱动程序还支持一种编程方式，即直接将`encoding`和`nencoding`参数传递给其`.connect()`函数。这些可以在URL中如下所示：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For the meaning of the `encoding` and `nencoding` parameters, please consult
    [Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`encoding`和`nencoding`参数的含义，请参考[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)。
- en: See also
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - in the cx_Oracle documentation.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - 在 cx_Oracle 文档中。'
- en: Unicode-specific Column datatypes
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unicode 特定的列数据类型
- en: The Core expression language handles unicode data by use of the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes. These types correspond to the VARCHAR2
    and CLOB Oracle datatypes by default. When using these datatypes with Unicode
    data, it is expected that the Oracle database is configured with a Unicode-aware
    character set, as well as that the `NLS_LANG` environment variable is set appropriately,
    so that the VARCHAR2 and CLOB datatypes can accommodate the data.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达式语言通过使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型处理 Unicode 数据。这些类型默认对应于 VARCHAR2 和 CLOB Oracle 数据类型。在使用这些数据类型处理 Unicode 数据时，预期
    Oracle 数据库配置为具有 Unicode 意识的字符集，并且`NLS_LANG`环境变量设置正确，以便 VARCHAR2 和 CLOB 数据类型可以容纳数据。
- en: In the case that the Oracle database is not configured with a Unicode character
    set, the two options are to use the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    datatypes explicitly, or to pass the flag `use_nchar_for_unicode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will cause the SQLAlchemy dialect to use NCHAR/NCLOB
    for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes instead of VARCHAR/CLOB.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Oracle 数据库未配置为 Unicode 字符集，则有两种选择：显式使用[`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR")和[`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")数据类型，或者在调用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")时传递标志`use_nchar_for_unicode=True`，这将导致 SQLAlchemy 方言使用
    NCHAR/NCLOB 代替 VARCHAR/CLOB 用于[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 数据类型。
- en: 'Changed in version 1.3: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now correspond to the `VARCHAR2` and
    `CLOB` Oracle datatypes unless the `use_nchar_for_unicode=True` is passed to the
    dialect when [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is called.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3 开始更改：[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在对应于 `VARCHAR2` 和 `CLOB` Oracle 数据类型，除非在调用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")时传递了`use_nchar_for_unicode=True`。
- en: '#### Encoding Errors'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 编码错误'
- en: For the unusual case that data in the Oracle database is present with a broken
    encoding, the dialect accepts a parameter `encoding_errors` which will be passed
    to Unicode decoding functions in order to affect how decoding errors are handled.
    The value is ultimately consumed by the Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    function, and is passed both via cx_Oracle’s `encodingErrors` parameter consumed
    by `Cursor.var()`, as well as SQLAlchemy’s own decoding function, as the cx_Oracle
    dialect makes use of both under different circumstances.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Oracle 数据库中存在编码错误的情况，方言接受一个`encoding_errors`参数，该参数将传递给 Unicode 解码函数，以影响如何处理解码错误。该值最终由
    Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    函数消耗，并通过 cx_Oracle 的`encodingErrors`参数（由`Cursor.var()`消耗）以及 SQLAlchemy 自己的解码函数传递，因为
    cx_Oracle 方言在不同情况下都使用这两者。
- en: 'New in version 1.3.11.  ### Fine grained control over cx_Oracle data binding
    performance with setinputsizes'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3.11 中引入。### 使用 setinputsizes 对 cx_Oracle 数据绑定性能进行精细控制
- en: The cx_Oracle DBAPI has a deep and fundamental reliance upon the usage of the
    DBAPI `setinputsizes()` call. The purpose of this call is to establish the datatypes
    that are bound to a SQL statement for Python values being passed as parameters.
    While virtually no other DBAPI assigns any use to the `setinputsizes()` call,
    the cx_Oracle DBAPI relies upon it heavily in its interactions with the Oracle
    client interface, and in some scenarios it is not possible for SQLAlchemy to know
    exactly how data should be bound, as some settings can cause profoundly different
    performance characteristics, while altering the type coercion behavior at the
    same time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle DBAPI 深度且根本上依赖于使用 DBAPI 的 `setinputsizes()` 调用。此调用的目的是为了为作为参数传递的 Python
    值绑定到 SQL 语句的数据类型。虽然几乎没有其他 DBAPI 分配任何用途给 `setinputsizes()` 调用，但 cx_Oracle DBAPI
    在与 Oracle 客户端接口的交互中大量依赖它，在某些情况下，SQLAlchemy 无法准确知道数据应该如何绑定，因为一些设置可能会导致截然不同的性能特征，同时也会改变类型强制转换行为。
- en: Users of the cx_Oracle dialect are **strongly encouraged** to read through cx_Oracle’s
    list of built-in datatype symbols at [https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types).
    Note that in some cases, significant performance degradation can occur when using
    these types vs. not, in particular when specifying `cx_Oracle.CLOB`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 方言的用户**强烈建议**阅读 cx_Oracle 的内置数据类型符号列表，网址为 [https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types)。请注意，在某些情况下，使用这些类型与不使用这些类型相比，可能会导致显著的性能下降，特别是在指定
    `cx_Oracle.CLOB` 时。
- en: On the SQLAlchemy side, the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") event can be used both for
    runtime visibility (e.g. logging) of the setinputsizes step as well as to fully
    control how `setinputsizes()` is used on a per-statement basis.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 方面，[`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") 事件可用于运行时可见性（例如日志记录）设置 setinputsizes
    步骤以及在每个语句基础上完全控制 `setinputsizes()` 的使用。
- en: 'New in version 1.2.9: Added `DialectEvents.setinputsizes()`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.2.9 中的新功能：添加了 `DialectEvents.setinputsizes()`
- en: Example 1 - logging all setinputsizes calls
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1 - 记录所有 setinputsizes 调用
- en: 'The following example illustrates how to log the intermediary values from a
    SQLAlchemy perspective before they are converted to the raw `setinputsizes()`
    parameter dictionary. The keys of the dictionary are [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects which have a `.key` and a `.type`
    attribute:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在将其转换为原始 `setinputsizes()` 参数字典之前从 SQLAlchemy 视角记录中间值。字典的键是具有 `.key`
    和 `.type` 属性的 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 对象：
- en: '[PRE57]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Example 2 - remove all bindings to CLOB
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2 - 删除所有到 CLOB 的绑定
- en: 'The `CLOB` datatype in cx_Oracle incurs a significant performance overhead,
    however is set by default for the `Text` type within the SQLAlchemy 1.2 series.
    This setting can be modified as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 中的 `CLOB` 数据类型会产生显著的性能开销，但在 SQLAlchemy 1.2 系列中默认设置为 `Text` 类型。可以通过以下方式修改此设置：
- en: '[PRE58]  ### RETURNING Support'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE58]  ### RETURNING 支持'
- en: 'The cx_Oracle dialect implements RETURNING using OUT parameters. The dialect
    supports RETURNING fully.  ### LOB Datatypes'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'cx_Oracle 方言使用 OUT 参数实现 RETURNING。该方言完全支持 RETURNING。  ### LOB 数据类型'
- en: LOB datatypes refer to the “large object” datatypes such as CLOB, NCLOB and
    BLOB. Modern versions of cx_Oracle and oracledb are optimized for these datatypes
    to be delivered as a single buffer. As such, SQLAlchemy makes use of these newer
    type handlers by default.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: LOB 数据类型是指诸如 CLOB、NCLOB 和 BLOB 之类的“大对象”数据类型。cx_Oracle 和 oracledb 的现代版本经过优化，可以将这些数据类型作为单个缓冲区传递。因此，SQLAlchemy
    默认使用这些新型处理程序。
- en: To disable the use of newer type handlers and deliver LOB objects as classic
    buffered objects with a `read()` method, the parameter `auto_convert_lobs=False`
    may be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which takes place only engine-wide.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用新型类型处理程序的使用，并将 LOB 对象作为具有 `read()` 方法的经典缓冲对象传递，可以向 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 传递参数 `auto_convert_lobs=False`，这仅在引擎范围内生效。
- en: Two Phase Transactions Not Supported
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持两阶段事务
- en: Two phase transactions are **not supported** under cx_Oracle due to poor driver
    support. As of cx_Oracle 6.0b1, the interface for two phase transactions has been
    changed to be more of a direct pass-through to the underlying OCI layer with less
    automation. The additional logic to support this system is not implemented in
    SQLAlchemy.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于驱动程序支持不佳，cx_Oracle 不支持两阶段事务。从 cx_Oracle 6.0b1 开始，两阶段事务的接口已更改为更直接地通过到底层 OCI
    层的传递，自动化程度较低。支持此系统的附加逻辑未在 SQLAlchemy 中实现。
- en: '### Precision Numerics'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '### 精确数字'
- en: SQLAlchemy’s numeric types can handle receiving and returning values as Python
    `Decimal` objects or float objects. When a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") object, or a subclass such as [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), `DOUBLE_PRECISION` etc. is in use, the [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") flag determines if values should be coerced to `Decimal`
    upon return, or returned as float objects. To make matters more complicated under
    Oracle, Oracle’s `NUMBER` type can also represent integer values if the “scale”
    is zero, so the Oracle-specific [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") type takes this into account as well.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的数字类型可以处理接收和返回 Python `Decimal` 对象或浮点对象的值。当使用 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 对象或其子类如 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")，`DOUBLE_PRECISION` 等时，[`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") 标志确定返回时值是否应强制转换为 `Decimal`，或返回为浮点对象。在 Oracle 下更加复杂，Oracle
    的 `NUMBER` 类型如果“scale”为零，也可以表示整数值，因此 Oracle 特定的 [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") 类型也考虑到了这一点。
- en: The cx_Oracle dialect makes extensive use of connection- and cursor-level “outputtypehandler”
    callables in order to coerce numeric values as requested. These callables are
    specific to the specific flavor of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") in use, as well as if no SQLAlchemy typing objects
    are present. There are observed scenarios where Oracle may sends incomplete or
    ambiguous information about the numeric types being returned, such as a query
    where the numeric types are buried under multiple levels of subquery. The type
    handlers do their best to make the right decision in all cases, deferring to the
    underlying cx_Oracle DBAPI for all those cases where the driver can make the best
    decision.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 方言广泛使用连接和游标级别的“outputtypehandler”可调用对象，以根据请求强制转换数值。这些可调用对象特定于使用的 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 的具体类型，以及如果不存在 SQLAlchemy 类型对象。观察到的情况是，Oracle 可能发送关于返回的数字类型的不完整或模糊信息，例如查询中数字类型被埋在多层子查询中。类型处理程序在所有情况下都尽力做出正确决定，对于所有那些驱动程序可以做出最佳决定的情况，都会推迟到底层的
    cx_Oracle DBAPI。
- en: 'When no typing objects are present, as when executing plain SQL strings, a
    default “outputtypehandler” is present which will generally return numeric values
    which specify precision and scale as Python `Decimal` objects. To disable this
    coercion to decimal for performance reasons, pass the flag `coerce_to_decimal=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '当不存在类型对象时，例如执行普通 SQL 字符串时，存在默认的“outputtypehandler”，通常会返回指定精度和标度的数值，作为 Python
    `Decimal` 对象。为了出于性能原因禁用此强制转换为十进制数的操作，请将标志 `coerce_to_decimal=False` 传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `coerce_to_decimal` flag only impacts the results of plain string SQL statements
    that are not otherwise associated with a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy type (or a subclass of such).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal` 标志仅影响与 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy 类型（或其子类）无关的普通字符串 SQL 语句的结果。'
- en: 'Changed in version 1.2: The numeric handling system for cx_Oracle has been
    reworked to take advantage of newer cx_Oracle features as well as better integration
    of outputtypehandlers.  ## python-oracledb'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '从版本 1.2 开始更改：cx_Oracle 的数字处理系统已经重新设计，以利用更新的 cx_Oracle 功能以及更好地集成 outputtypehandlers。  ##
    python-oracledb'
- en: Support for the Oracle database via the python-oracledb driver.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 python-oracledb 驱动程序支持 Oracle 数据库。
- en: DBAPI
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for python-oracledb
    is available at: [https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: python-oracledb 的文档和下载信息（如果适用）可在此处获取：[https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)
- en: Connecting
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: python-oracledb is released by Oracle to supersede the cx_Oracle driver. It
    is fully compatible with cx_Oracle and features both a “thin” client mode that
    requires no dependencies, as well as a “thick” mode that uses the Oracle Client
    Interface in the same way as cx_Oracle.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: python-oracledb 是由 Oracle 发布的用于取代 cx_Oracle 驱动程序的驱动程序。它与 cx_Oracle 完全兼容，并且具有“thin”客户端模式（不需要依赖项）和“thick”模式（与
    cx_Oracle 一样使用 Oracle 客户端接口）。
- en: See also
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cx_Oracle](#cx-oracle) - all of cx_Oracle’s notes apply to the oracledb driver
    as well.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[cx_Oracle](#cx-oracle) - cx_Oracle 的所有说明也适用于 oracledb 驱动程序。'
- en: 'The SQLAlchemy `oracledb` dialect provides both a sync and an async implementation
    under the same dialect name. The proper version is selected depending on how the
    engine is created:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy `oracledb` 方言在同一方言名称下提供了同步和异步实现。根据引擎的创建方式选择适当的版本：
- en: 'calling [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    with `oracle+oracledb://...` will automatically select the sync version, e.g.:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `oracle+oracledb://...` 调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 将自动选择同步版本，例如：
- en: '[PRE61]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'calling [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") with `oracle+oracledb://...` will
    automatically select the async version, e.g.:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `oracle+oracledb://...` 调用 [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") 将自动选择异步版本，例如：
- en: '[PRE62]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The asyncio version of the dialect may also be specified explicitly using the
    `oracledb_async` suffix, as:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以明确指定方言的 asyncio 版本，使用 `oracledb_async` 后缀，如：
- en: '[PRE63]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'New in version 2.0.25: added support for the async version of oracledb.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.25 版本中的新功能：增加了对 oracledb 的异步版本的支持。
- en: Thick mode support
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Thick 模式支持
- en: By default the `python-oracledb` is started in thin mode, that does not require
    oracle client libraries to be installed in the system. The `python-oracledb` driver
    also support a “thick” mode, that behaves similarly to `cx_oracle` and requires
    that Oracle Client Interface (OCI) is installed.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`python-oracledb` 以 thin 模式启动，不需要在系统中安装 Oracle 客户端库。`python-oracledb`
    驱动程序还支持“thick”模式，行为类似于 `cx_oracle`，需要安装 Oracle 客户端接口（OCI）。
- en: 'To enable this mode, the user may call `oracledb.init_oracle_client` manually,
    or by passing the parameter `thick_mode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). To pass custom arguments to `init_oracle_client`,
    like the `lib_dir` path, a dict may be passed to this parameter, as in:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此模式，用户可以手动调用 `oracledb.init_oracle_client`，或通过将参数 `thick_mode=True` 传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 来启用。要向 `init_oracle_client` 传递自定义参数，如 `lib_dir` 路径，可以将字典传递给此参数，如下所示：
- en: '[PRE64]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: See also
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
- en: 'New in version 2.0.0: added support for oracledb driver.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.0 版本中的新功能：增加了对 oracledb 驱动程序的支持。
- en: Support for the Oracle database.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Oracle 数据库的支持。
- en: The following table summarizes current support levels for database release versions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了当前数据库发布版本的支持级别。
- en: '**Supported Oracle versions**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的 Oracle 版本**'
- en: '| Support type | Versions |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 支持类型 | 版本 |'
- en: '| --- | --- |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 18c |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| [在 CI 中进行完整测试](index.html#term-Fully-tested-in-CI) | 18c |'
- en: '| [Normal support](index.html#term-Normal-support) | 11+ |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| [普通支持](index.html#term-Normal-support) | 11+ |'
- en: '| [Best effort](index.html#term-Best-effort) | 9+ |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| [尽力而为](index.html#term-Best-effort) | 9+ |'
- en: DBAPI Support
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBAPI 支持
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 提供以下方言/DBAPI 选项。请参阅各自的 DBAPI 部分获取连接信息。
- en: '[cx-Oracle](#module-sqlalchemy.dialects.oracle.cx_oracle)'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[cx-Oracle](#module-sqlalchemy.dialects.oracle.cx_oracle)'
- en: '[python-oracledb](#module-sqlalchemy.dialects.oracle.oracledb)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[python-oracledb](#module-sqlalchemy.dialects.oracle.oracledb)'
- en: Auto Increment Behavior
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动增量行为
- en: SQLAlchemy Table objects which include integer primary keys are usually assumed
    to have “autoincrementing” behavior, meaning they can generate their own primary
    key values upon INSERT. For use within Oracle, two options are available, which
    are the use of IDENTITY columns (Oracle 12 and above only) or the association
    of a SEQUENCE with the column.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 包括整数主键的 SQLAlchemy Table 对象通常被假定具有“自动增量”行为，意味着它们可以在插入时生成自己的主键值。在 Oracle 中，有两个可用选项，即使用
    IDENTITY 列（仅限 Oracle 12 及以上版本）或将序列与列相关联。
- en: Specifying GENERATED AS IDENTITY (Oracle 12 and above)
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定 GENERATED AS IDENTITY（Oracle 12 及以上）
- en: 'Starting from version 12 Oracle can make use of identity columns using the
    `Identity` to specify the autoincrementing behavior:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 12 开始，Oracle 可以使用 `Identity` 指定自动增量行为：
- en: '[PRE65]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的 CREATE TABLE 如下：
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object support many options to control the “autoincrementing” behavior of the
    column, like the starting value, the incrementing value, etc. In addition to the
    standard options, Oracle supports setting [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") to `None` to use the default generated mode, rendering
    GENERATED AS IDENTITY in the DDL. It also supports setting [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") to `True` to specify ON NULL in conjunction with
    a ‘BY DEFAULT’ identity column.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    对象支持许多选项来控制列的“自动增量”行为，如起始值、增量值等。除了标准选项外，Oracle 还支持将 [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") 设置为 `None`，以使用默认生成模式，在 DDL 中呈现 GENERATED AS IDENTITY。它还支持将
    [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") 设置为 `True`，以指定在“BY DEFAULT”身份列上与“ON NULL”一起使用。'
- en: Using a SEQUENCE (all Oracle versions)
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SEQUENCE（所有 Oracle 版本）
- en: 'Older version of Oracle had no “autoincrement” feature, SQLAlchemy relies upon
    sequences to produce these values. With the older Oracle versions, *a sequence
    must always be explicitly specified to enable autoincrement*. This is divergent
    with the majority of documentation examples which assume the usage of an autoincrement-capable
    database. To specify sequences, use the sqlalchemy.schema.Sequence object which
    is passed to a Column construct:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 Oracle 没有“autoincrement”功能，SQLAlchemy 依赖序列来生成这些值。对于旧版的 Oracle，*必须始终明确指定序列以启用自动增量*。这与大多数文档示例不同，后者假设使用的是具有自动增量功能的数据库。要指定序列，请使用传递给列构造函数的
    sqlalchemy.schema.Sequence 对象：
- en: '[PRE67]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This step is also required when using table reflection, i.e. autoload_with=engine:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用表反射时，即 autoload_with=engine，也需要执行此步骤：
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4 中的更改：在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    中添加了 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    构造函数，用于指定自动增量列的选项。
- en: Specifying GENERATED AS IDENTITY (Oracle 12 and above)
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定 GENERATED AS IDENTITY（Oracle 12 及以上）
- en: 'Starting from version 12 Oracle can make use of identity columns using the
    `Identity` to specify the autoincrementing behavior:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 12 开始，Oracle 可以使用 `Identity` 指定自动增量行为：
- en: '[PRE69]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的 CREATE TABLE 如下：
- en: '[PRE70]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object support many options to control the “autoincrementing” behavior of the
    column, like the starting value, the incrementing value, etc. In addition to the
    standard options, Oracle supports setting [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") to `None` to use the default generated mode, rendering
    GENERATED AS IDENTITY in the DDL. It also supports setting [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") to `True` to specify ON NULL in conjunction with
    a ‘BY DEFAULT’ identity column.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    对象支持许多选项来控制列的“自动增量”行为，例如起始值、增量值等。除了标准选项外，Oracle 还支持将 [`Identity.always`](../core/defaults.html#sqlalchemy.schema.Identity.params.always
    "sqlalchemy.schema.Identity") 设置为 `None`，以使用默认生成模式，将 GENERATED AS IDENTITY 渲染到
    DDL 中。它还支持将 [`Identity.on_null`](../core/defaults.html#sqlalchemy.schema.Identity.params.on_null
    "sqlalchemy.schema.Identity") 设置为 `True`，以指定与 “BY DEFAULT” 身份列一起使用 ON NULL。'
- en: Using a SEQUENCE (all Oracle versions)
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SEQUENCE（所有 Oracle 版本）
- en: 'Older version of Oracle had no “autoincrement” feature, SQLAlchemy relies upon
    sequences to produce these values. With the older Oracle versions, *a sequence
    must always be explicitly specified to enable autoincrement*. This is divergent
    with the majority of documentation examples which assume the usage of an autoincrement-capable
    database. To specify sequences, use the sqlalchemy.schema.Sequence object which
    is passed to a Column construct:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 Oracle 没有“自动增量”功能，SQLAlchemy 依赖序列来生成这些值。在旧的 Oracle 版本中，*必须始终明确指定序列以启用自动增量*。这与大多数文档示例不同，后者假定使用支持自动增量的数据库。要指定序列，请使用传递给
    Column 结构的 sqlalchemy.schema.Sequence 对象：
- en: '[PRE71]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This step is also required when using table reflection, i.e. autoload_with=engine:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用表反射时也需要执行此步骤，即 autoload_with=engine：
- en: '[PRE72]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.4 版本开始更改：在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    中添加 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    结构以指定自动增量列的选项。
- en: '## Transaction Isolation Level / Autocommit'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '## 事务隔离级别 / 自动提交'
- en: The Oracle database supports “READ COMMITTED” and “SERIALIZABLE” modes of isolation.
    The AUTOCOMMIT isolation level is also supported by the cx_Oracle dialect.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 数据库支持“READ COMMITTED”和“SERIALIZABLE”隔离模式。 cx_Oracle 方言也支持 AUTOCOMMIT
    隔离级别。
- en: 'To set using per-connection execution options:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 设置使用每个连接的执行选项：
- en: '[PRE73]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For `READ COMMITTED` and `SERIALIZABLE`, the Oracle dialect sets the level at
    the session level using `ALTER SESSION`, which is reverted back to its default
    setting when the connection is returned to the connection pool.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `READ COMMITTED` 和 `SERIALIZABLE`，Oracle 方言使用 `ALTER SESSION` 在会话级别设置级别，当连接返回到连接池时，它将恢复为其默认设置。
- en: 'Valid values for `isolation_level` include:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`isolation_level` 的有效值包括：'
- en: '`READ COMMITTED`'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ COMMITTED`'
- en: '`AUTOCOMMIT`'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTOCOMMIT`'
- en: '`SERIALIZABLE`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIALIZABLE`'
- en: Note
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation for the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method as implemented by the
    Oracle dialect necessarily forces the start of a transaction using the Oracle
    LOCAL_TRANSACTION_ID function; otherwise no level is normally readable.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Oracle 方言实现的 [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法的实现必然使用 Oracle LOCAL_TRANSACTION_ID
    函数启动事务；否则，通常不可读取级别。
- en: Additionally, the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method will raise an exception
    if the `v$transaction` view is not available due to permissions or other reasons,
    which is a common occurrence in Oracle installations.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果由于权限或其他原因导致 `v$transaction` 视图不可用，[`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") 方法将引发异常，在 Oracle 安装中这是常见的情况。
- en: The cx_Oracle dialect attempts to call the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method when the dialect makes
    its first connection to the database in order to acquire the “default”isolation
    level. This default level is necessary so that the level can be reset on a connection
    after it has been temporarily modified using [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") method. In the common event
    that the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method raises an exception
    due to `v$transaction` not being readable as well as any other database-related
    failure, the level is assumed to be “READ COMMITTED”. No warning is emitted for
    this initial first-connect condition as it is expected to be a common restriction
    on Oracle databases.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当 cx_Oracle 方言在其首次连接到数据库时，会尝试调用[`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level")方法，以获取“默认”隔离级别。这个默认级别是必需的，以便在使用[`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options")方法临时修改连接后，可以重置级别。在常见情况下，如果[`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level")方法由于`v$transaction`不可读以及任何其他与数据库相关的故障而引发异常，则假定级别为“READ
    COMMITTED”。对于这种初始第一次连接条件，不会发出警告，因为预计这是 Oracle 数据库上的常见限制。
- en: 'New in version 1.3.16: added support for AUTOCOMMIT to the cx_oracle dialect
    as well as the notion of a default isolation level'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3.16 新增：为 cx_oracle 方言添加了对 AUTOCOMMIT 的支持以及默认隔离级别的概念
- en: 'New in version 1.3.21: Added support for SERIALIZABLE as well as live reading
    of the isolation level.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3.21 新增：增加了对 SERIALIZABLE 的支持以及隔离级别的实时读取。
- en: 'Changed in version 1.3.22: In the event that the default isolation level cannot
    be read due to permissions on the v$transaction view as is common in Oracle installations,
    the default isolation level is hardcoded to “READ COMMITTED” which was the behavior
    prior to 1.3.21.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3.22 起更改：如果由于在 Oracle 安装中常见的 v$transaction 视图上的权限问题而无法读取默认隔离级别，则默认隔离级别硬编码为“READ
    COMMITTED”，这是 1.3.21 之前的行为。
- en: See also
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括 DBAPI 自动提交](../core/connections.html#dbapi-autocommit)'
- en: Identifier Casing
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符大小写
- en: In Oracle, the data dictionary represents all case insensitive identifier names
    using UPPERCASE text. SQLAlchemy on the other hand considers an all-lower case
    identifier name to be case insensitive. The Oracle dialect converts all case insensitive
    identifiers to and from those two formats during schema level communication, such
    as reflection of tables and indexes. Using an UPPERCASE name on the SQLAlchemy
    side indicates a case sensitive identifier, and SQLAlchemy will quote the name
    - this will cause mismatches against data dictionary data received from Oracle,
    so unless identifier names have been truly created as case sensitive (i.e. using
    quoted names), all lowercase names should be used on the SQLAlchemy side.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 中，数据字典使用大写文本表示所有不区分大小写的标识符名称。另一方面，SQLAlchemy 认为所有小写标识符名称都是不区分大小写的。Oracle
    方言在模式级别通信期间（例如反射表和索引）将所有不区分大小写的标识符转换为这两种格式。在 SQLAlchemy 一侧使用大写名称表示区分大小写的标识符，并且
    SQLAlchemy 会对名称加引号 - 这将导致与从 Oracle 接收到的数据字典数据不匹配，因此除非标识符名称真的已创建为区分大小写的（即使用带引号的名称），否则在
    SQLAlchemy 一侧应使用所有小写名称。
- en: '## Max Identifier Lengths'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '## 最大标识符长度'
- en: Oracle has changed the default max identifier length as of Oracle Server version
    12.2\. Prior to this version, the length was 30, and for 12.2 and greater it is
    now 128\. This change impacts SQLAlchemy in the area of generated SQL label names
    as well as the generation of constraint names, particularly in the case where
    the constraint naming convention feature described at [Configuring Constraint
    Naming Conventions](../core/constraints.html#constraint-naming-conventions) is
    being used.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 在 Oracle Server 版本 12.2 之后更改了默认的最大标识符长度。在此版本之前，长度为 30，在 12.2 及更高版本中，现在为
    128。此更改影响 SQLAlchemy 在生成的 SQL 标签名称以及生成约束名称方面的操作，特别是在使用[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)中描述的约束命名约定功能的情况下。
- en: To assist with this change and others, Oracle includes the concept of a “compatibility”
    version, which is a version number that is independent of the actual server version
    in order to assist with migration of Oracle databases, and may be configured within
    the Oracle server itself. This compatibility version is retrieved using the query
    `SELECT value FROM v$parameter WHERE name = 'compatible';`. The SQLAlchemy Oracle
    dialect, when tasked with determining the default max identifier length, will
    attempt to use this query upon first connect in order to determine the effective
    compatibility version of the server, which determines what the maximum allowed
    identifier length is for the server. If the table is not available, the server
    version information is used instead.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助进行此更改和其他更改，Oracle包括“兼容性”版本的概念，这是一个与实际服务器版本无关的版本号，以帮助迁移Oracle数据库，并且可以在Oracle服务器内部配置。此兼容性版本通过查询`SELECT
    value FROM v$parameter WHERE name = 'compatible';`检索。当SQLAlchemy Oracle方言被要求确定默认最大标识符长度时，将尝试在首次连接时使用此查询以确定服务器的有效兼容性版本，该版本确定服务器的最大允许标识符长度。如果表不可用，则使用服务器版本信息。
- en: 'As of SQLAlchemy 1.4, the default max identifier length for the Oracle dialect
    is 128 characters. Upon first connect, the compatibility version is detected and
    if it is less than Oracle version 12.2, the max identifier length is changed to
    be 30 characters. In all cases, setting the [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") parameter will bypass this change and the value given
    will be used as is:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLAlchemy 1.4开始，Oracle方言的默认最大标识符长度为128个字符。首次连接时，检测兼容性版本，如果低于Oracle版本12.2，则将最大标识符长度更改为30个字符。在所有情况下，设置[`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine")参数将绕过此更改，并且给定的值将如实使用：
- en: '[PRE74]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The maximum identifier length comes into play both when generating anonymized
    SQL labels in SELECT statements, but more crucially when generating constraint
    names from a naming convention. It is this area that has created the need for
    SQLAlchemy to change this default conservatively. For example, the following naming
    convention produces two very different constraint names based on the identifier
    length:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 最大标识符长度在生成SELECT语句中的匿名化SQL标签时起作用，但更重要的是在根据命名约定生成约束名称时起作用。正是这个领域促使SQLAlchemy保守地更改此默认值。例如，以下命名约定基于标识符长度产生两个非常不同的约束名称：
- en: '[PRE75]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With an identifier length of 30, the above CREATE INDEX looks like:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 使用30个标识符长度，上述CREATE INDEX如下所示：
- en: '[PRE76]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However with length=128, it becomes:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，长度为128时，变为：
- en: '[PRE77]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Applications which have run versions of SQLAlchemy prior to 1.4 on an Oracle
    server version 12.2 or greater are therefore subject to the scenario of a database
    migration that wishes to “DROP CONSTRAINT” on a name that was previously generated
    with the shorter length. This migration will fail when the identifier length is
    changed without the name of the index or constraint first being adjusted. Such
    applications are strongly advised to make use of [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") in order to maintain control of the generation of
    truncated names, and to fully review and test all database migrations in a staging
    environment when changing this value to ensure that the impact of this change
    has been mitigated.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracle服务器版本12.2或更高版本上运行SQLAlchemy 1.4之前的版本的应用程序因此受到数据库迁移的影响，希望在较短长度生成的名称上“DROP
    CONSTRAINT”。当更改标识符长度而未先调整索引或约束的名称时，此迁移将失败。强烈建议这些应用程序使用[`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine")以控制生成截断名称，并在更改此值时在分段环境中全面审查和测试所有数据库迁移，以确保已减轻此更改的影响。
- en: 'Changed in version 1.4: the default max_identifier_length for Oracle is 128
    characters, which is adjusted down to 30 upon first connect if an older version
    of Oracle server (compatibility version < 12.2) is detected.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.4起更改：Oracle的默认max_identifier_length为128个字符，如果检测到旧版本的Oracle服务器（兼容性版本<12.2），则在首次连接时调整为30个字符。
- en: LIMIT/OFFSET/FETCH Support
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIMIT/OFFSET/FETCH 支持
- en: Methods like [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") make use of `FETCH FIRST N ROW / OFFSET
    N ROWS` syntax assuming Oracle 12c or above, and assuming the SELECT statement
    is not embedded within a compound statement like UNION. This syntax is also available
    directly by using the [`Select.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.Select.fetch
    "sqlalchemy.sql.expression.Select.fetch") method.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 像 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 这样的方法使用 `FETCH FIRST N ROW / OFFSET
    N ROWS` 语法，假设是 Oracle 12c 或更高版本，并且假设 SELECT 语句没有嵌入在像 UNION 这样的复合语句中。通过使用 [`Select.fetch()`](../core/selectable.html#sqlalchemy.sql.expression.Select.fetch
    "sqlalchemy.sql.expression.Select.fetch") 方法也可以直接使用此语法。
- en: 'Changed in version 2.0: the Oracle dialect now uses `FETCH FIRST N ROW / OFFSET
    N ROWS` for all [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") usage including within the ORM and
    legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query").
    To force the legacy behavior using window functions, specify the `enable_offset_fetch=False`
    dialect parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.0 版本开始更改：Oracle 方言现在对所有包括 ORM 和传统 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 内部在内的 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 使用中都使用 `FETCH FIRST N ROW / OFFSET
    N ROWS`。要强制使用基于窗口函数的传统行为，请在 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 中指定 `enable_offset_fetch=False` 方言参数。
- en: The use of `FETCH FIRST / OFFSET` may be disabled on any Oracle version by passing
    `enable_offset_fetch=False` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will force the use of “legacy” mode that makes
    use of window functions. This mode is also selected automatically when using a
    version of Oracle prior to 12c.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    传递 `enable_offset_fetch=False`，可以在任何 Oracle 版本上禁用 `FETCH FIRST / OFFSET` 的使用，这将强制使用“传统”模式，即使用窗口函数。当使用
    Oracle 版本 12c 之前的版本时，也会自动选择此模式。
- en: When using legacy mode, or when a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement with limit/offset is embedded in
    a compound statement, an emulated approach for LIMIT / OFFSET based on window
    functions is used, which involves creation of a subquery using `ROW_NUMBER` that
    is prone to performance issues as well as SQL construction issues for complex
    statements. However, this approach is supported by all Oracle versions. See notes
    below.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用传统模式或者将带有 limit/offset 的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 语句嵌入到复合语句中时，会使用基于窗口函数的 LIMIT / OFFSET 的模拟方法，这涉及使用
    `ROW_NUMBER` 创建子查询，容易出现性能问题以及对复杂语句的 SQL 构造问题。然而，这种方法受到所有 Oracle 版本的支持。请参阅下面的注意事项。
- en: Notes on LIMIT / OFFSET emulation (when fetch() method cannot be used)
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT / OFFSET 模拟的注意事项（当无法使用 fetch() 方法时）
- en: 'If using [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset"), or with the ORM the [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit") and [`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset") methods on an Oracle version prior to 12c, the
    following notes apply:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Oracle 版本 12c 之前使用 [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 方法，或者在 ORM 中使用 [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit") 和 [`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset") 方法，则需要注意以下内容：
- en: SQLAlchemy currently makes use of ROWNUM to achieve LIMIT/OFFSET; the exact
    methodology is taken from [https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)
    .
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy目前使用ROWNUM来实现LIMIT/OFFSET；确切的方法取自[https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)。
- en: the “FIRST_ROWS()” optimization keyword is not used by default. To enable the
    usage of this optimization directive, specify `optimize_limits=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “FIRST_ROWS()”优化关键字默认情况下不使用。要启用此优化指令的使用，请在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中指定`optimize_limits=True`。
- en: 'Changed in version 1.4: The Oracle dialect renders limit/offset integer values
    using a “post compile” scheme which renders the integer directly before passing
    the statement to the cursor for execution. The `use_binds_for_limits` flag no
    longer has an effect.'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自版本1.4起：Oracle方言使用“编译后”方案呈现限制/偏移整数值，直接在将语句传递给游标执行之前呈现整数。`use_binds_for_limits`标志不再起作用。
- en: See also
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](../changelog/migration_14.html#change-4808).'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Oracle、SQL Server中用于LIMIT/OFFSET的新“编译后”绑定参数](../changelog/migration_14.html#change-4808)。'
- en: Notes on LIMIT / OFFSET emulation (when fetch() method cannot be used)
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT / OFFSET仿真注意事项（当无法使用fetch()方法时）
- en: 'If using [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset"), or with the ORM the [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit") and [`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset") methods on an Oracle version prior to 12c, the
    following notes apply:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Oracle 12c之前的版本中使用[`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit")和[`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset")，或者在ORM中使用[`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit")和[`Query.offset()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.offset
    "sqlalchemy.orm.Query.offset")方法，则适用以下注意事项：
- en: SQLAlchemy currently makes use of ROWNUM to achieve LIMIT/OFFSET; the exact
    methodology is taken from [https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)
    .
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy目前使用ROWNUM来实现LIMIT/OFFSET；确切的方法取自[https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results](https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results)。
- en: the “FIRST_ROWS()” optimization keyword is not used by default. To enable the
    usage of this optimization directive, specify `optimize_limits=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “FIRST_ROWS()”优化关键字默认情况下不使用。要启用此优化指令的使用，请在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中指定`optimize_limits=True`。
- en: 'Changed in version 1.4: The Oracle dialect renders limit/offset integer values
    using a “post compile” scheme which renders the integer directly before passing
    the statement to the cursor for execution. The `use_binds_for_limits` flag no
    longer has an effect.'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自版本1.4起：Oracle方言使用“编译后”方案呈现限制/偏移整数值，直接在将语句传递给游标执行之前呈现整数。`use_binds_for_limits`标志不再起作用。
- en: See also
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](../changelog/migration_14.html#change-4808).'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Oracle、SQL Server中用于LIMIT/OFFSET的新“编译后”绑定参数](../changelog/migration_14.html#change-4808)。'
- en: '## RETURNING Support'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '## RETURNING支持'
- en: The Oracle database supports RETURNING fully for INSERT, UPDATE and DELETE statements
    that are invoked with a single collection of bound parameters (that is, a `cursor.execute()`
    style statement; SQLAlchemy does not generally support RETURNING with [executemany](../glossary.html#term-executemany)
    statements). Multiple rows may be returned as well.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle数据库完全支持对使用单个绑定参数集合（即`cursor.execute()`风格语句；SQLAlchemy通常不支持[executemany](../glossary.html#term-executemany)语句）调用的INSERT、UPDATE和DELETE语句的RETURNING。也可以返回多行。
- en: 'Changed in version 2.0: the Oracle backend has full support for RETURNING on
    parity with other backends.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本2.0起：Oracle后端完全支持与其他后端相同的RETURNING功能。
- en: ON UPDATE CASCADE
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ON UPDATE CASCADE
- en: Oracle doesn’t have native ON UPDATE CASCADE functionality. A trigger based
    solution is available at [https://asktom.oracle.com/tkyte/update_cascade/index.html](https://asktom.oracle.com/tkyte/update_cascade/index.html)
    .
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 没有本机的 ON UPDATE CASCADE 功能。一个基于触发器的解决方案可在 [https://asktom.oracle.com/tkyte/update_cascade/index.html](https://asktom.oracle.com/tkyte/update_cascade/index.html)
    找到。
- en: When using the SQLAlchemy ORM, the ORM has limited ability to manually issue
    cascading updates - specify ForeignKey objects using the “deferrable=True, initially=’deferred’”
    keyword arguments, and specify “passive_updates=False” on each relationship().
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 SQLAlchemy ORM 时，ORM 有限的手动发出级联更新的能力 - 使用“deferrable=True, initially='deferred'”关键字参数指定
    ForeignKey 对象，并在每个 relationship() 中指定“passive_updates=False”。
- en: Oracle 8 Compatibility
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 8 兼容性
- en: Warning
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The status of Oracle 8 compatibility is not known for SQLAlchemy 2.0.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLAlchemy 2.0，Oracle 8 兼容性的状态尚不清楚。
- en: 'When Oracle 8 is detected, the dialect internally configures itself to the
    following behaviors:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到 Oracle 8 时，方言内部会配置为以下行为：
- en: the use_ansi flag is set to False. This has the effect of converting all JOIN
    phrases into the WHERE clause, and in the case of LEFT OUTER JOIN makes use of
    Oracle’s (+) operator.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_ansi` 标志设置为 False。这会将所有 JOIN 短语转换为 WHERE 子句，并且在 LEFT OUTER JOIN 的情况下使用
    Oracle 的 (+) 运算符。'
- en: the NVARCHAR2 and NCLOB datatypes are no longer generated as DDL when the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") is used - VARCHAR2 and CLOB are issued instead. This
    because these types don’t seem to work correctly on Oracle 8 even though they
    are available. The [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    types will always generate NVARCHAR2 and NCLOB.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    时，不再生成 NVARCHAR2 和 NCLOB 数据类型的 DDL - 而是生成 VARCHAR2 和 CLOB。这是因为即使这些类型在 Oracle 8
    上是可用的，但在 Oracle 8 上似乎无法正确工作。[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") 和 [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    类型将始终生成 NVARCHAR2 和 NCLOB。
- en: Synonym/DBLINK Reflection
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同义词/DBLINK 反射
- en: 'When using reflection with Table objects, the dialect can optionally search
    for tables indicated by synonyms, either in local or remote schemas or accessed
    over DBLINK, by passing the flag `oracle_resolve_synonyms=True` as a keyword argument
    to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Table 对象进行反射时，方言可以选择搜索由同义词指示的表，无论是在本地还是远程模式，还是通过 DBLINK 访问，只需将标志 `oracle_resolve_synonyms=True`
    作为关键字参数传递给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    构造函数：
- en: '[PRE78]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When this flag is set, the given name (such as `some_table` above) will be searched
    not just in the `ALL_TABLES` view, but also within the `ALL_SYNONYMS` view to
    see if this name is actually a synonym to another name. If the synonym is located
    and refers to a DBLINK, the oracle dialect knows how to locate the table’s information
    using DBLINK syntax(e.g. `@dblink`).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置了此标志时，将会在 `ALL_TABLES` 视图中搜索给定的名称（例如上面的 `some_table`），而且还会在 `ALL_SYNONYMS`
    视图中搜索，以查看该名称是否实际上是另一个名称的同义词。如果找到同义词并且它指向一个 DBLINK，Oracle 方言会使用 DBLINK 语法来定位表的信息（例如
    `@dblink`）。
- en: '`oracle_resolve_synonyms` is accepted wherever reflection arguments are accepted,
    including methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") and [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns").'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`oracle_resolve_synonyms` 被接受在任何接受反射参数的地方，包括 [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 和 [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") 等方法。'
- en: If synonyms are not in use, this flag should be left disabled.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用同义词，应将此标志保持禁用。
- en: '## Constraint Reflection'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '## 约束反射'
- en: The Oracle dialect can return information about foreign key, unique, and CHECK
    constraints, as well as indexes on tables.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 方言可以返回有关表的外键、唯一约束、CHECK 约束以及索引的信息。
- en: Raw information regarding these constraints can be acquired using [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys"), [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints"), [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"), and [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes").
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys")、[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")、[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")和[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")获取关于这些约束的原始信息。
- en: 'Changed in version 1.2: The Oracle dialect can now reflect UNIQUE and CHECK
    constraints.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.2版本中更改：Oracle方言现在可以反映唯一约束和检查约束。
- en: When using reflection at the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") level, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also include these constraints.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")级别使用反射时，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")还将包括这些约束条件。
- en: 'Note the following caveats:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下注意事项：
- en: 'When using the [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") method, Oracle
    builds a special “IS NOT NULL” constraint for columns that specify “NOT NULL”.
    This constraint is **not** returned by default; to include the “IS NOT NULL” constraints,
    pass the flag `include_all=True`:'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints")方法时，Oracle为指定“NOT
    NULL”的列构建一个特殊的“IS NOT NULL”约束条件。默认情况下，此约束条件**不会**被返回；要包括“IS NOT NULL”约束条件，请传递标志`include_all=True`：
- en: '[PRE79]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: in most cases, when reflecting a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), a UNIQUE constraint will **not** be available as a
    [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") object, as Oracle mirrors unique constraints
    with a UNIQUE index in most cases (the exception seems to be when two or more
    unique constraints represent the same columns); the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will instead represent these using [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` flag set.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，当反映[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")时，唯一约束将**不可用**作为[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")对象，因为Oracle在大多数情况下使用唯一索引来反映唯一约束（例外情况似乎是当两个或多个唯一约束表示相同列时）；相反，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")将使用带有`unique=True`标志的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")来表示这些约束。
- en: Oracle creates an implicit index for the primary key of a table; this index
    is **excluded** from all index results.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle为表的主键创建一个隐式索引；此索引**不包含**在所有索引结果中。
- en: the list of columns reflected for an index will not include column names that
    start with SYS_NC.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反映索引的列列表不会包括以SYS_NC开头的列名。
- en: Table names with SYSTEM/SYSAUX tablespaces
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有SYSTEM/SYSAUX表空间的表名称
- en: 'The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") methods each return
    a list of table names for the current engine. These methods are also part of the
    reflection which occurs within an operation such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"). By default, these operations exclude the
    `SYSTEM` and `SYSAUX` tablespaces from the operation. In order to change this,
    the default list of tablespaces excluded can be changed at the engine level using
    the `exclude_tablespaces` parameter:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names")方法分别返回当前引擎的表名列表。这些方法也是在操作中发生的反射的一部分，比如[`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")。默认情况下，这些操作会排除`SYSTEM`和`SYSAUX`表空间。要更改这一点，可以在引擎级别使用`exclude_tablespaces`参数更改默认排除的表空间列表：'
- en: '[PRE80]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: DateTime Compatibility
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期时间兼容性
- en: Oracle has no datatype known as `DATETIME`, it instead has only `DATE`, which
    can actually store a date and time value. For this reason, the Oracle dialect
    provides a type [`DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")
    which is a subclass of [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"). This type has no special behavior, and is only present
    as a “marker” for this type; additionally, when a database column is reflected
    and the type is reported as `DATE`, the time-supporting [`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE") type is used.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle没有名为`DATETIME`的数据类型，它只有`DATE`，实际上可以存储日期和时间值。因此，Oracle方言提供了一个类型[`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE")，它是[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")的子类。这种类型没有特殊行为，只是作为这种类型的“标记”存在；此外，当反射数据库列并且类型报告为`DATE`时，将使用支持时间的[`DATE`](#sqlalchemy.dialects.oracle.DATE
    "sqlalchemy.dialects.oracle.DATE")类型。
- en: '## Oracle Table Options'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '## Oracle 表选项'
- en: 'The CREATE TABLE phrase supports the following options with Oracle in conjunction
    with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE短语与Oracle一起支持以下选项，与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造一起使用：
- en: '`ON COMMIT`:'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON COMMIT`：'
- en: '[PRE81]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`COMPRESS`:'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESS`：'
- en: '[PRE82]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '## Oracle Specific Index Options'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '## Oracle 特定索引选项'
- en: Bitmap Indexes
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图索引
- en: 'You can specify the `oracle_bitmap` parameter to create a bitmap index instead
    of a B-tree index:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定`oracle_bitmap`参数来创建位图索引，而不是B树索引：
- en: '[PRE83]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
    check for such limitations, only the database will.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 位图索引不能是唯一的，也不能被压缩。SQLAlchemy不会检查这些限制，只有数据库会检查。
- en: Index compression
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引压缩
- en: 'Oracle has a more efficient storage mode for indexes containing lots of repeated
    values. Use the `oracle_compress` parameter to turn on key compression:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle有一种更高效的存储模式，适用于包含大量重复值的索引。使用`oracle_compress`参数来启用键压缩：
- en: '[PRE84]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `oracle_compress` parameter accepts either an integer specifying the number
    of prefix columns to compress, or `True` to use the default (all columns for non-unique
    indexes, all but the last column for unique indexes).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`oracle_compress`参数接受一个整数，指定要压缩的前缀列数，或者`True`来使用默认值（对于非唯一索引，使用所有列，对于唯一索引，使用除最后一列之外的所有列）。'
- en: Bitmap Indexes
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图索引
- en: 'You can specify the `oracle_bitmap` parameter to create a bitmap index instead
    of a B-tree index:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定`oracle_bitmap`参数来创建位图索引，而不是B树索引：
- en: '[PRE85]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
    check for such limitations, only the database will.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 位图索引不能是唯一的，也不能被压缩。SQLAlchemy不会检查这些限制，只有数据库会检查。
- en: Index compression
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引压缩
- en: 'Oracle has a more efficient storage mode for indexes containing lots of repeated
    values. Use the `oracle_compress` parameter to turn on key compression:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle有一种更高效的存储模式，适用于包含大量重复值的索引。使用`oracle_compress`参数来启用键压缩：
- en: '[PRE86]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `oracle_compress` parameter accepts either an integer specifying the number
    of prefix columns to compress, or `True` to use the default (all columns for non-unique
    indexes, all but the last column for unique indexes).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`oracle_compress` 参数接受一个整数，指定要压缩的前缀列数，或者接受 `True` 来使用默认值（对于非唯一索引是所有列，对于唯一索引是除最后一列外的所有列）。'
- en: Oracle Data Types
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 数据类型
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with Oracle are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 SQLAlchemy 方言一样，所有已知在 Oracle 中有效的大写类型都可以从顶级方言导入，无论它们是从 [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types
    "sqlalchemy.types") 还是从本地方言派生的：
- en: '[PRE87]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'New in version 1.2.19: Added [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") to the list of datatypes exported by the Oracle dialect.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2.19 版新增：将 [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    添加到 Oracle 方言导出的数据类型列表中。
- en: 'Types which are specific to Oracle, or have Oracle-specific construction arguments,
    are as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是特定于 Oracle 或具有 Oracle 特定构造参数的类型：
- en: '| Object Name | Description |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [BFILE](#sqlalchemy.dialects.oracle.BFILE) |  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| [BFILE](#sqlalchemy.dialects.oracle.BFILE) |  |'
- en: '| [BINARY_DOUBLE](#sqlalchemy.dialects.oracle.BINARY_DOUBLE) |  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| [BINARY_DOUBLE](#sqlalchemy.dialects.oracle.BINARY_DOUBLE) |  |'
- en: '| [BINARY_FLOAT](#sqlalchemy.dialects.oracle.BINARY_FLOAT) |  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| [BINARY_FLOAT](#sqlalchemy.dialects.oracle.BINARY_FLOAT) |  |'
- en: '| [DATE](#sqlalchemy.dialects.oracle.DATE) | Provide the oracle DATE type.
    |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| [DATE](#sqlalchemy.dialects.oracle.DATE) | 提供 Oracle DATE 类型。 |'
- en: '| [FLOAT](#sqlalchemy.dialects.oracle.FLOAT) | Oracle FLOAT. |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| [FLOAT](#sqlalchemy.dialects.oracle.FLOAT) | Oracle FLOAT 类型。 |'
- en: '| [INTERVAL](#sqlalchemy.dialects.oracle.INTERVAL) |  |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| [INTERVAL](#sqlalchemy.dialects.oracle.INTERVAL) |  |'
- en: '| [LONG](#sqlalchemy.dialects.oracle.LONG) |  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| [LONG](#sqlalchemy.dialects.oracle.LONG) |  |'
- en: '| [NCLOB](#sqlalchemy.dialects.oracle.NCLOB) |  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| [NCLOB](#sqlalchemy.dialects.oracle.NCLOB) |  |'
- en: '| [NUMBER](#sqlalchemy.dialects.oracle.NUMBER) |  |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| [NUMBER](#sqlalchemy.dialects.oracle.NUMBER) |  |'
- en: '| [NVARCHAR2](#sqlalchemy.dialects.oracle.NVARCHAR2) | alias of [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.sql.sqltypes.NVARCHAR") |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| [NVARCHAR2](#sqlalchemy.dialects.oracle.NVARCHAR2) | [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.sql.sqltypes.NVARCHAR") 的别名 |'
- en: '| [RAW](#sqlalchemy.dialects.oracle.RAW) |  |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| [RAW](#sqlalchemy.dialects.oracle.RAW) |  |'
- en: '| [ROWID](#sqlalchemy.dialects.oracle.ROWID) | Oracle ROWID type. |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| [ROWID](#sqlalchemy.dialects.oracle.ROWID) | Oracle ROWID 类型。 |'
- en: '| [TIMESTAMP](#sqlalchemy.dialects.oracle.TIMESTAMP) | Oracle implementation
    of `TIMESTAMP`, which supports additional Oracle-specific modes |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| [TIMESTAMP](#sqlalchemy.dialects.oracle.TIMESTAMP) | `TIMESTAMP` 的 Oracle
    实现，支持额外的 Oracle 特定模式。 |'
- en: '[PRE88]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Members**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BFILE.__init__)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BFILE.__init__)'
- en: '**Class signature**'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BFILE`](#sqlalchemy.dialects.oracle.BFILE
    "sqlalchemy.dialects.oracle.BFILE") ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.BFILE`](#sqlalchemy.dialects.oracle.BFILE
    "sqlalchemy.dialects.oracle.BFILE") ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
- en: '[PRE89]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") *的* `sqlalchemy.types.LargeBinary.__init__` *方法*'
- en: Construct a LargeBinary type.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 LargeBinary 类型。
- en: 'Parameters:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**length** – 可选，用于DDL语句中的列长度，适用于接受长度的二进制类型，如MySQL的 BLOB 类型。'
- en: '[PRE90]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Members**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_DOUBLE.__init__)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_DOUBLE.__init__)'
- en: '**Class signature**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BINARY_DOUBLE`](#sqlalchemy.dialects.oracle.BINARY_DOUBLE
    "sqlalchemy.dialects.oracle.BINARY_DOUBLE") ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.BINARY_DOUBLE`](#sqlalchemy.dialects.oracle.BINARY_DOUBLE
    "sqlalchemy.dialects.oracle.BINARY_DOUBLE") ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
- en: '[PRE91]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    *的* `sqlalchemy.types.Float.__init__` *方法*'
- en: Construct a Float.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 Float。
- en: 'Parameters:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`precision` –'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision` –'
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于DDL `CREATE TABLE`中的数值精度。后端**应该**尽量确保此精度指示了通用[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")数据类型的数字位数。
- en: Note
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT "sqlalchemy.dialects.oracle.FLOAT")
    datatype and specify the [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Oracle后端，在渲染DDL时不接受[`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float")参数，因为Oracle不支持将浮点精度指定为小数位数。而是使用Oracle特定的[`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT")数据类型，并指定[`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT")参数。这是SQLAlchemy的2.0版本中的新功能。
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个数据库通用的[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")，并分别为Oracle指定二进制精度，请使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")如下：
- en: '[PRE92]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 与[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")相同的标志，但默认值为`False`。请注意，将此标志设置为`True`会导致浮点转换。'
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 将浮点数转换为Python十进制时使用的默认标度。由于十进制不准确，浮点值通常会更长，并且大多数浮点数据库类型都没有“标度”的概念，因此默认情况下，浮点类型在转换时会查找前十位小数点。指定此值将覆盖该长度。请注意，MySQL浮点类型（包括“标度”）将使用“标度”作为decimal_return_scale的默认值，如果未另行指定。'
- en: '[PRE93]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '**Members**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_FLOAT.__init__)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.BINARY_FLOAT.__init__)'
- en: '**Class signature**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.BINARY_FLOAT`](#sqlalchemy.dialects.oracle.BINARY_FLOAT
    "sqlalchemy.dialects.oracle.BINARY_FLOAT") ([`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"))
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.BINARY_FLOAT`](#sqlalchemy.dialects.oracle.BINARY_FLOAT
    "sqlalchemy.dialects.oracle.BINARY_FLOAT")（[`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")）
- en: '[PRE94]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    *的* `sqlalchemy.types.Float.__init__` *方法继承而来*'
- en: Construct a Float.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个Float。
- en: 'Parameters:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`precision` –'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision` –'
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于DDL `CREATE TABLE`中的数值精度。后端**应该**尽量确保此精度指示了通用[`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")数据类型的数字位数。
- en: Note
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT "sqlalchemy.dialects.oracle.FLOAT")
    datatype and specify the [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Oracle 后端，在渲染 DDL 时不接受 [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") *参数，因为 Oracle 不支持指定浮点精度为小数位数。* *相反，使用特定于 Oracle 的 [`FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") 数据类型，并指定 [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") *参数。* *这是 SQLAlchemy 的 2.0 新功能。*
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个数据库通用的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")，为
    Oracle 分别指定二进制精度，请使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") *如下所示*：
- en: '[PRE95]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 与 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") *相同的标志，但默认为* `False`。请注意，将此标志设置为 `True` 将导致浮点数转换。'
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 在从浮点数转换为 Python 十进制数时要使用的默认比例。由于十进制不精确，浮点数值通常会更长，并且大多数浮点数数据库类型没有“比例”的概念，因此默认情况下，浮点类型在转换时会寻找前十位小数位数。指定此值将覆盖该长度。请注意，如果没有另行指定，具有“比例”的
    MySQL 浮点类型将使用“比例”作为 `decimal_return_scale` 的默认值。'
- en: '[PRE96]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Provide the oracle DATE type.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 提供 Oracle DATE 类型。
- en: This type has no special Python behavior, except that it subclasses [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"); this is to suit the fact that the Oracle `DATE`
    type supports a time value.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型在 Python 中没有特殊的行为，除了它是 [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") *的子类*；*这是为了适应 Oracle `DATE` 类型支持时间值的事实。*
- en: '**Members**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.DATE.__init__)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.DATE.__init__)'
- en: '**Class signature**'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")
    (`sqlalchemy.dialects.oracle.types._OracleDateLiteralRender`, [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.DATE`](#sqlalchemy.dialects.oracle.DATE "sqlalchemy.dialects.oracle.DATE")
    (`sqlalchemy.dialects.oracle.types._OracleDateLiteralRender`, [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
- en: '[PRE97]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    *方法的* `sqlalchemy.types.DateTime.__init__` *方法*'
- en: Construct a new [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime").
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的 [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")。
- en: 'Parameters:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype directly when using this flag, as some
    databases include separate generic date/time-holding types distinct from the timezone-capable
    TIMESTAMP datatype, such as Oracle.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**时区** – 布尔值。指示日期时间类型应在仅在基本日期/时间保持类型上可用时启用时区支持。建议在使用此标志时直接使用[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型，因为某些数据库包括与时区支持 TIMESTAMP 数据类型不同的通用日期/时间保持类型，如
    Oracle。'
- en: '[PRE98]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Oracle FLOAT.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle FLOAT。
- en: This is the same as [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT") except that an Oracle-specific [`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter is accepted, and the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT")相同，不同之处在于接受一个
    Oracle 特定的[`FLOAT.binary_precision`](#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT")参数，并且不接受[`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float")参数。
- en: Oracle FLOAT types indicate precision in terms of “binary precision”, which
    defaults to 126\. For a REAL type, the value is 63\. This parameter does not cleanly
    map to a specific number of decimal places but is roughly equivalent to the desired
    number of decimal places divided by 0.3103.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle FLOAT 类型以“二进制精度”表示精度，默认为 126。对于 REAL 类型，该值为 63。该参数不清晰地映射到特定数量的小数位，但大致相当于所需小数位数除以
    0.3103。
- en: New in version 2.0.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本2.0中新增。
- en: '**Members**'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.FLOAT.__init__)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.FLOAT.__init__)'
- en: '**Class signature**'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.FLOAT`](#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") ([`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT"))
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.FLOAT`](#sqlalchemy.dialects.oracle.FLOAT "sqlalchemy.dialects.oracle.FLOAT")
    ([`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"))
- en: '[PRE99]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Construct a FLOAT
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个浮点数
- en: 'Parameters:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`binary_precision` – Oracle binary precision value to be rendered in DDL. This
    may be approximated to the number of decimal characters using the formula “decimal
    precision = 0.30103 * binary precision”. The default value used by Oracle for
    FLOAT / DOUBLE PRECISION is 126.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binary_precision` – 要在 DDL 中呈现的 Oracle 二进制精度值。这可以使用公式“十进制精度 = 0.30103 * 二进制精度”来近似为十进制字符的数量。Oracle
    用于 FLOAT / DOUBLE PRECISION 的默认值为 126。'
- en: '`asdecimal` – See [`Float.asdecimal`](../core/type_basics.html#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float")'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asdecimal` – 参见[`Float.asdecimal`](../core/type_basics.html#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float")'
- en: '`decimal_return_scale` – See [`Float.decimal_return_scale`](../core/type_basics.html#sqlalchemy.types.Float.params.decimal_return_scale
    "sqlalchemy.types.Float")'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal_return_scale` – 参见[`Float.decimal_return_scale`](../core/type_basics.html#sqlalchemy.types.Float.params.decimal_return_scale
    "sqlalchemy.types.Float")'
- en: '[PRE100]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '**Members**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.INTERVAL.__init__)'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.INTERVAL.__init__)'
- en: '**Class signature**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.INTERVAL`](#sqlalchemy.dialects.oracle.INTERVAL
    "sqlalchemy.dialects.oracle.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.oracle.INTERVAL`](#sqlalchemy.dialects.oracle.INTERVAL
    "sqlalchemy.dialects.oracle.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
- en: '[PRE101]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Construct an INTERVAL.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个间隔。
- en: Note that only DAY TO SECOND intervals are currently supported. This is due
    to a lack of support for YEAR TO MONTH intervals within available DBAPIs.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前仅支持“DAY TO SECOND”间隔。这是由于可用的 DBAPI 不支持“YEAR TO MONTH”间隔。
- en: 'Parameters:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`day_precision` – the day precision value. this is the number of digits to
    store for the day field. Defaults to “2”'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day_precision` – 天精度值。这是用于存储天字段的数字位数。默认为“2”'
- en: '`second_precision` – the second precision value. this is the number of digits
    to store for the fractional seconds field. Defaults to “6”.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second_precision` – 秒精度值。这是用于存储小数秒字段的数字位数。默认为“6”。'
- en: '[PRE102]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Members**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.NCLOB.__init__)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.NCLOB.__init__)'
- en: '**Class signature**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.NCLOB`](#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text"))
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.NCLOB`](#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text"))
- en: '[PRE103]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    的 `sqlalchemy.types.String.__init__` *方法*'
- en: Create a string-holding type.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个持有字符串的类型。
- en: 'Parameters:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` – 可选，用于DDL和CAST表达式中的列长度。如果不会发出`CREATE TABLE`，则可以安全地省略。某些数据库可能需要在DDL中使用`length`，如果包含没有长度的`VARCHAR`，则在发出`CREATE
    TABLE` DDL时会引发异常。值是以字节还是字符解释是特定于数据库的。'
- en: '`collation` –'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collation` –'
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选，用于DDL和CAST表达式中的列级排序。使用SQLite、MySQL和PostgreSQL支持的COLLATE关键字进行呈现。例如：
- en: '[PRE104]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    预计存储非ASCII数据的列应使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")数据类型。这些数据类型将确保在数据库上使用正确的类型。
- en: '[PRE105]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: alias of [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.sql.sqltypes.NVARCHAR")
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为 [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.sql.sqltypes.NVARCHAR")
- en: '[PRE106]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '**Class signature**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") ([`sqlalchemy.types.Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"))
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") ([`sqlalchemy.types.Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"))
- en: '[PRE107]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '**Members**'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.LONG.__init__)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.LONG.__init__)'
- en: '**Class signature**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.LONG`](#sqlalchemy.dialects.oracle.LONG "sqlalchemy.dialects.oracle.LONG")
    ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.oracle.LONG`](#sqlalchemy.dialects.oracle.LONG "sqlalchemy.dialects.oracle.LONG")
    ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text"))
- en: '[PRE108]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    的 `sqlalchemy.types.String.__init__` *方法*'
- en: Create a string-holding type.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个持有字符串的类型。
- en: 'Parameters:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` – 可选，用于DDL和CAST表达式中的列长度。如果不会发出`CREATE TABLE`，则可以安全地省略。某些数据库可能需要在DDL中���用`length`，如果包含没有长度的`VARCHAR`，则在发出`CREATE
    TABLE` DDL时会引发异常。值是以字节还是字符解释是特定于数据库的。'
- en: '`collation` –'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collation` –'
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选，用于DDL和CAST表达式中的列级排序。使用SQLite、MySQL和PostgreSQL支持的COLLATE关键字进行呈现。例如：
- en: '[PRE109]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，应该使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    或 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型来存储非 ASCII 数据的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")。这些数据类型将确保在数据库上使用正确的类型。
- en: '[PRE110]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '**Class signature**'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.RAW`](#sqlalchemy.dialects.oracle.RAW "sqlalchemy.dialects.oracle.RAW")
    (`sqlalchemy.types._Binary`)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.oracle.RAW`](#sqlalchemy.dialects.oracle.RAW "sqlalchemy.dialects.oracle.RAW")
    （`sqlalchemy.types._Binary`）
- en: '[PRE111]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Oracle ROWID type.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle ROWID 类型。
- en: When used in a cast() or similar, generates ROWID.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 cast() 或类似情况下使用时，生成 ROWID。
- en: '**Class signature**'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.ROWID`](#sqlalchemy.dialects.oracle.ROWID
    "sqlalchemy.dialects.oracle.ROWID") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.oracle.ROWID`](#sqlalchemy.dialects.oracle.ROWID "sqlalchemy.dialects.oracle.ROWID")
    （[`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")）
- en: '[PRE112]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Oracle implementation of `TIMESTAMP`, which supports additional Oracle-specific
    modes
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 实现的 `TIMESTAMP`，支持附加的 Oracle 特定模式
- en: New in version 2.0.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本中的新增功能。
- en: '**Members**'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.oracle.TIMESTAMP.__init__)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.oracle.TIMESTAMP.__init__)'
- en: '**Class signature**'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.oracle.TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP
    "sqlalchemy.dialects.oracle.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.oracle.TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP
    "sqlalchemy.dialects.oracle.TIMESTAMP") （[`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")）
- en: '[PRE113]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Construct a new [`TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP "sqlalchemy.dialects.oracle.TIMESTAMP").
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的 [`TIMESTAMP`](#sqlalchemy.dialects.oracle.TIMESTAMP "sqlalchemy.dialects.oracle.TIMESTAMP")。
- en: 'Parameters:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`timezone` – boolean. Indicates that the TIMESTAMP type should use Oracle’s
    `TIMESTAMP WITH TIME ZONE` datatype.'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timezone` – 布尔值。指示 TIMESTAMP 类型应该使用 Oracle 的 `TIMESTAMP WITH TIME ZONE` 数据类型。'
- en: '`local_timezone` – boolean. Indicates that the TIMESTAMP type should use Oracle’s
    `TIMESTAMP WITH LOCAL TIME ZONE` datatype.'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_timezone` – 布尔值。指示 TIMESTAMP 类型应该使用 Oracle 的 `TIMESTAMP WITH LOCAL TIME
    ZONE` 数据类型。'
- en: '## cx_Oracle'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '## cx_Oracle'
- en: Support for the Oracle database via the cx-Oracle driver.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 cx-Oracle 驱动程序支持 Oracle 数据库。
- en: DBAPI
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for cx-Oracle is available
    at: [https://oracle.github.io/python-cx_Oracle/](https://oracle.github.io/python-cx_Oracle/)'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: cx-Oracle 的文档和下载信息（如果适用）可在此处找到：[https://oracle.github.io/python-cx_Oracle/](https://oracle.github.io/python-cx_Oracle/)
- en: Connecting
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE114]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: DSN vs. Hostname connections
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DSN vs. 主机名连接
- en: cx_Oracle provides several methods of indicating the target database. The dialect
    translates from a series of different URL forms.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 提供了几种指示目标数据库的方法。方言从一系列不同的 URL 形式转换而来。
- en: Hostname Connections with Easy Connect Syntax
  id: totrans-705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Easy Connect 语法的主机名连接
- en: 'Given a hostname, port and service name of the target Oracle Database, for
    example from Oracle’s [Easy Connect syntax](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings),
    then connect in SQLAlchemy using the `service_name` query string parameter:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 给定目标 Oracle 数据库的主机名、端口和服务名称，例如来自 Oracle 的 [Easy Connect 语法](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings)，然后使用
    SQLAlchemy 中的 `service_name` 查询字符串参数进行连接：
- en: '[PRE115]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The [full Easy Connect syntax](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)
    is not supported. Instead, use a `tnsnames.ora` file and connect using a DSN.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Easy Connect 语法不受支持。请使用 `tnsnames.ora` 文件，并使用 DSN 进行连接。
- en: Connections with tnsnames.ora or Oracle Cloud
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 tnsnames.ora 或 Oracle Cloud 的连接
- en: 'Alternatively, if no port, database name, or `service_name` is provided, the
    dialect will use an Oracle DSN “connection string”. This takes the “hostname”
    portion of the URL as the data source name. For example, if the `tnsnames.ora`
    file contains a [Net Service Name](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)
    of `myalias` as below:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果未提供端口、数据库名称或 `service_name`，则方言将使用 Oracle DSN “连接字符串”。这将“主机名”部分的 URL 作为数据源名称。例如，如果
    `tnsnames.ora` 文件包含以下内容的 [Net Service Name](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)：
- en: '[PRE116]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The cx_Oracle dialect connects to this database service when `myalias` is the
    hostname portion of the URL, without specifying a port, database name or `service_name`:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `myalias` 是 URL 的主机名部分时，cx_Oracle 方言将连接到此数据库服务，而不指定端口、数据库名称或 `service_name`：
- en: '[PRE117]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Users of Oracle Cloud should use this syntax and also configure the cloud wallet
    as shown in cx_Oracle documentation [Connecting to Autononmous Databases](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Cloud 的用户应该使用此语法，并按照 cx_Oracle 文档中所示配置云钱包 [连接到自主数据库](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases)。
- en: SID Connections
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SID 连接
- en: 'To use Oracle’s obsolete SID connection syntax, the SID can be passed in a
    “database name” portion of the URL as below:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Oracle 的过时 SID 连接语法，SID 可以在 URL 的“数据库名称”部分中传递，如下所示：
- en: '[PRE118]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Above, the DSN passed to cx_Oracle is created by `cx_Oracle.makedsn()` as follows:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，传递给 cx_Oracle 的 DSN 是由 `cx_Oracle.makedsn()` 创建的，如下所示：
- en: '[PRE119]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Passing cx_Oracle connect arguments
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递 cx_Oracle 连接参数
- en: 'Additional connection arguments can usually be passed via the URL query string;
    particular symbols like `cx_Oracle.SYSDBA` are intercepted and converted to the
    correct symbol:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过 URL 查询字符串传递其他连接参数；特定符号如 `cx_Oracle.SYSDBA` 将被拦截并转换为正确的符号：
- en: '[PRE120]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Changed in version 1.3: the cx_oracle dialect now accepts all argument names
    within the URL string itself, to be passed to the cx_Oracle DBAPI. As was the
    case earlier but not correctly documented, the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter also accepts all cx_Oracle DBAPI connect
    arguments.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3 开始：cx_oracle 方言现在接受 URL 字符串本身中的所有参数名称，以传递给 cx_Oracle DBAPI。与之前的情况一样，但没有正确记录，[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 参数也接受 cx_Oracle DBAPI 的所有连接参数。
- en: 'To pass arguments directly to `.connect()` without using the query string,
    use the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary. Any cx_Oracle parameter value and/or constant
    may be passed, such as:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接传递参数给 `.connect()` 而不使用查询字符串，可以使用 [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典。可以传递任何 cx_Oracle 参数值和/或常量，例如：
- en: '[PRE121]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Note that the default value for `encoding` and `nencoding` was changed to “UTF-8”
    in cx_Oracle 8.0 so these parameters can be omitted when using that version, or
    later.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 cx_Oracle 8.0 中，`encoding` 和 `nencoding` 的默认值已更改为“UTF-8”，因此在使用该版本或更高版本时，可以省略这些参数。
- en: Options consumed by the SQLAlchemy cx_Oracle dialect outside of the driver
  id: totrans-727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在驱动程序之外由 SQLAlchemy cx_Oracle 方言消耗的选项
- en: 'There are also options that are consumed by the SQLAlchemy cx_oracle dialect
    itself. These options are always passed directly to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , such as:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些选项是由 SQLAlchemy cx_oracle 方言本身消耗的。这些选项总是直接传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") ，例如：
- en: '[PRE122]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The parameters accepted by the cx_oracle dialect are as follows:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: cx_oracle 方言接受的参数如下：
- en: '`arraysize` - set the cx_oracle.arraysize value on cursors; defaults to `None`,
    indicating that the driver default should be used (typically the value is 100).
    This setting controls how many rows are buffered when fetching rows, and can have
    a significant effect on performance when modified. The setting is used for both
    `cx_Oracle` as well as `oracledb`.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arraysize` - 在游标上设置 cx_oracle.arraysize 值；默认为 `None`，表示应使用驱动程序的默认值（通常该值为 100）。此设置控制在获取行时缓冲多少行，并且在修改时可能对性能产生重大影响。该设置用于
    `cx_Oracle` 以及 `oracledb`。'
- en: 'Changed in version 2.0.26: - changed the default value from 50 to None, to
    use the default value of the driver itself.'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0.26 起更改：- 将默认值从 50 更改为 None，以使用驱动程序本身的默认值。
- en: '`auto_convert_lobs` - defaults to True; See [LOB Datatypes](#cx-oracle-lob).'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto_convert_lobs` - 默认为True；详见[LOB数据类型](#cx-oracle-lob)。'
- en: '`coerce_to_decimal` - see [Precision Numerics](#cx-oracle-numeric) for detail.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal` - 详见[精确数值](#cx-oracle-numeric)。'
- en: '`encoding_errors` - see [Encoding Errors](#cx-oracle-unicode-encoding-errors)
    for detail.'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding_errors` - 详见[编码错误](#cx-oracle-unicode-encoding-errors)。'
- en: '### Using cx_Oracle SessionPool'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用cx_Oracle SessionPool'
- en: 'The cx_Oracle library provides its own connection pool implementation that
    may be used in place of SQLAlchemy’s pooling functionality. This can be achieved
    by using the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter to provide a function that returns a new
    connection, along with setting [`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine") to `NullPool` to disable SQLAlchemy’s pooling:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle库提供了自己的连接池实现，可以用来替代SQLAlchemy的连接池功能。这可以通过使用[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")参数提供一个返回新连接的函数，以及设置[`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine")为`NullPool`来禁用SQLAlchemy的连接池来实现：
- en: '[PRE123]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The above engine may then be used normally where cx_Oracle’s pool handles connection
    pooling:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎可以正常使用，其中cx_Oracle的池处理连接池：
- en: '[PRE124]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As well as providing a scalable solution for multi-user applications, the cx_Oracle
    session pool supports some Oracle features such as DRCP and [Application Continuity](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为多用户应用程序提供可扩展的解决方案外，cx_Oracle会话池还支持一些Oracle功能，如DRCP和[应用连续性](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac)。
- en: Using Oracle Database Resident Connection Pooling (DRCP)
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Oracle数据库Resident Connection Pooling（DRCP）
- en: When using Oracle’s [DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086),
    the best practice is to pass a connection class and “purity” when acquiring a
    connection from the SessionPool. Refer to the [cx_Oracle DRCP documentation](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Oracle的[DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086)时，最佳实践是在从SessionPool获取连接时传递连接类和“纯度”。请参阅[cx_Oracle
    DRCP文档](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp)。
- en: 'This can be achieved by wrapping `pool.acquire()`:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过包装`pool.acquire()`来实现：
- en: '[PRE125]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The above engine may then be used normally where cx_Oracle handles session
    pooling and Oracle Database additionally uses DRCP:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎可以正常使用，其中cx_Oracle处理会话池，Oracle数据库另外使用DRCP：
- en: '[PRE126]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '### Unicode'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '### Unicode'
- en: As is the case for all DBAPIs under Python 3, all strings are inherently Unicode
    strings. In all cases however, the driver requires an explicit encoding configuration.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3下的所有DBAPI，所有字符串都是本质上的Unicode字符串。然而，在所有情况下，驱动程序都需要明确的编码配置。
- en: Ensuring the Correct Client Encoding
  id: totrans-750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确保正确的客户端编码
- en: The long accepted standard for establishing client encoding for nearly all Oracle
    related software is via the [NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)
    environment variable. cx_Oracle like most other Oracle drivers will use this environment
    variable as the source of its encoding configuration. The format of this variable
    is idiosyncratic; a typical value would be `AMERICAN_AMERICA.AL32UTF8`.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有与Oracle相关的软件建立客户端编码的长期接受标准是通过[NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)环境变量。cx_Oracle像大多数其他Oracle驱动程序一样将使用此环境变量作为其编码配置的来源。此变量的格式是特殊的；典型值可能是`AMERICAN_AMERICA.AL32UTF8`。
- en: 'The cx_Oracle driver also supports a programmatic alternative which is to pass
    the `encoding` and `nencoding` parameters directly to its `.connect()` function.
    These can be present in the URL as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle驱动程序还支持一种编程替代方案，即直接将`encoding`和`nencoding`参数传递给其`.connect()`函数。这些可以在URL中如下所示：
- en: '[PRE127]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: For the meaning of the `encoding` and `nencoding` parameters, please consult
    [Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`encoding`和`nencoding`参数的含义，请参阅[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)。
- en: See also
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - in the cx_Oracle documentation.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cx_Oracle 文档中 [字符集和国家语言支持 (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)。
- en: Unicode-specific Column datatypes
  id: totrans-757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unicode 特定的列数据类型
- en: The Core expression language handles unicode data by use of the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes. These types correspond to the VARCHAR2
    and CLOB Oracle datatypes by default. When using these datatypes with Unicode
    data, it is expected that the Oracle database is configured with a Unicode-aware
    character set, as well as that the `NLS_LANG` environment variable is set appropriately,
    so that the VARCHAR2 and CLOB datatypes can accommodate the data.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达语言通过使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型处理 Unicode 数据。这些类型默认对应于 VARCHAR2 和 CLOB Oracle 数据类型。当使用这些数据类型处理 Unicode 数据时，期望
    Oracle 数据库配置有 Unicode-aware 字符集，并且 `NLS_LANG` 环境变量已适当设置，以便 VARCHAR2 和 CLOB 数据类型能够容纳数据。
- en: In the case that the Oracle database is not configured with a Unicode character
    set, the two options are to use the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    datatypes explicitly, or to pass the flag `use_nchar_for_unicode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will cause the SQLAlchemy dialect to use NCHAR/NCLOB
    for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes instead of VARCHAR/CLOB.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Oracle 数据库未配置 Unicode 字符集，则有两种选择：显式使用 [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") 和 [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    数据类型，或者在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    时传递标志 `use_nchar_for_unicode=True`，这将导致 SQLAlchemy 方言使用 NCHAR/NCLOB 替代 VARCHAR/CLOB
    用于 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型。
- en: 'Changed in version 1.3: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now correspond to the `VARCHAR2` and
    `CLOB` Oracle datatypes unless the `use_nchar_for_unicode=True` is passed to the
    dialect when [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is called.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 版本更改：[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在默认对应于 `VARCHAR2` 和 `CLOB` Oracle 数据类型，除非在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 时传递了 `use_nchar_for_unicode=True`。
- en: '#### Encoding Errors'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 编码错误'
- en: For the unusual case that data in the Oracle database is present with a broken
    encoding, the dialect accepts a parameter `encoding_errors` which will be passed
    to Unicode decoding functions in order to affect how decoding errors are handled.
    The value is ultimately consumed by the Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    function, and is passed both via cx_Oracle’s `encodingErrors` parameter consumed
    by `Cursor.var()`, as well as SQLAlchemy’s own decoding function, as the cx_Oracle
    dialect makes use of both under different circumstances.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Oracle 数据库中存在损坏编码的情况，方言接受一个参数 `encoding_errors`，该参数将传递给 Unicode 解码函数，以影响如何处理解码错误。该值最终由
    Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    函数消耗，并且通过 cx_Oracle 的 `encodingErrors` 参数和 SQLAlchemy 自己的解码函数传递，因为在不同情况下 cx_Oracle
    方言都会使用它们。
- en: 'New in version 1.3.11.  ### Fine grained control over cx_Oracle data binding
    performance with setinputsizes'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3.11 的新增功能：### 通过 setinputsizes 实现对 cx_Oracle 数据绑定性能的精细控制
- en: The cx_Oracle DBAPI has a deep and fundamental reliance upon the usage of the
    DBAPI `setinputsizes()` call. The purpose of this call is to establish the datatypes
    that are bound to a SQL statement for Python values being passed as parameters.
    While virtually no other DBAPI assigns any use to the `setinputsizes()` call,
    the cx_Oracle DBAPI relies upon it heavily in its interactions with the Oracle
    client interface, and in some scenarios it is not possible for SQLAlchemy to know
    exactly how data should be bound, as some settings can cause profoundly different
    performance characteristics, while altering the type coercion behavior at the
    same time.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle DBAPI 对 DBAPI `setinputsizes()` 调用具有深刻且基本的依赖关系。此调用的目的是为了为作为参数传递的 Python
    值绑定到 SQL 语句的数据类型。虽然几乎没有其他 DBAPI 对`setinputsizes()`调用分配任何用途，但 cx_Oracle DBAPI 在与
    Oracle 客户端接口的交互中严重依赖它，在某些情况下，SQLAlchemy 不可能知道数据应该如何绑定，因为某些设置可能导致完全不同的性能特征，同时还改变了类型强制转换行为。
- en: Users of the cx_Oracle dialect are **strongly encouraged** to read through cx_Oracle’s
    list of built-in datatype symbols at [https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types).
    Note that in some cases, significant performance degradation can occur when using
    these types vs. not, in particular when specifying `cx_Oracle.CLOB`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cx_Oracle 方言的用户**强烈建议**阅读 cx_Oracle 内置数据类型符号列表，网址为[https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types)。请注意，在某些情况下，使用这些类型可能会导致显著的性能下降，尤其是在指定`cx_Oracle.CLOB`时。
- en: On the SQLAlchemy side, the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") event can be used both for
    runtime visibility (e.g. logging) of the setinputsizes step as well as to fully
    control how `setinputsizes()` is used on a per-statement basis.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 方面，可以使用[`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes")事件来实现运行时可见性（例如日志记录）和完全控制每个语句上如何使用`setinputsizes()`。
- en: 'New in version 1.2.9: Added `DialectEvents.setinputsizes()`'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.2.9 中新增：添加了`DialectEvents.setinputsizes()`
- en: Example 1 - logging all setinputsizes calls
  id: totrans-768
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1 - 记录所有 setinputsizes 调用
- en: 'The following example illustrates how to log the intermediary values from a
    SQLAlchemy perspective before they are converted to the raw `setinputsizes()`
    parameter dictionary. The keys of the dictionary are [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects which have a `.key` and a `.type`
    attribute:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了如何在将其转换为原始`setinputsizes()`参数字典之前，从 SQLAlchemy 视角记录中间值。字典的键是具有`.key`和`.type`属性的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象：
- en: '[PRE128]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Example 2 - remove all bindings to CLOB
  id: totrans-771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2 - 删除所有与 CLOB 的绑定
- en: 'The `CLOB` datatype in cx_Oracle incurs a significant performance overhead,
    however is set by default for the `Text` type within the SQLAlchemy 1.2 series.
    This setting can be modified as follows:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cx_Oracle 中，`CLOB` 数据类型会导致显著的性能开销，但在 SQLAlchemy 1.2 系列中默认为`Text`类型。可以按以下方式修改此设置：
- en: '[PRE129]  ### RETURNING Support'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE129]### RETURNING 支持'
- en: 'The cx_Oracle dialect implements RETURNING using OUT parameters. The dialect
    supports RETURNING fully.  ### LOB Datatypes'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 方言使用 OUT 参数实现 RETURNING。该方言完全支持 RETURNING。### LOB 数据类型
- en: LOB datatypes refer to the “large object” datatypes such as CLOB, NCLOB and
    BLOB. Modern versions of cx_Oracle and oracledb are optimized for these datatypes
    to be delivered as a single buffer. As such, SQLAlchemy makes use of these newer
    type handlers by default.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: LOB 数据类型指的是诸如 CLOB、NCLOB 和 BLOB 等“大对象”数据类型。cx_Oracle 和 oracledb 的现代版本经过优化，使得这些数据类型能够作为单个缓冲区传递。因此，默认情况下，SQLAlchemy
    使用这些较新的类型处理程序。
- en: To disable the use of newer type handlers and deliver LOB objects as classic
    buffered objects with a `read()` method, the parameter `auto_convert_lobs=False`
    may be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which takes place only engine-wide.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用较新的类型处理程序，并将 LOB 对象作为具有`read()`方法的经典缓冲对象传递，请将参数`auto_convert_lobs=False`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，该参数仅对整个引擎生效。
- en: Two Phase Transactions Not Supported
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持两阶段事务
- en: Two phase transactions are **not supported** under cx_Oracle due to poor driver
    support. As of cx_Oracle 6.0b1, the interface for two phase transactions has been
    changed to be more of a direct pass-through to the underlying OCI layer with less
    automation. The additional logic to support this system is not implemented in
    SQLAlchemy.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 由于驱动程序支持不佳，cx_Oracle 不支持两阶段事务。 从 cx_Oracle 6.0b1 开始，两阶段事务的接口已更改为更直接地通过底层 OCI
    层进行传递，并减少了自动化。 支持此系统的附加逻辑未在 SQLAlchemy 中实现。
- en: '### Precision Numerics'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '### 精确数字'
- en: SQLAlchemy’s numeric types can handle receiving and returning values as Python
    `Decimal` objects or float objects. When a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") object, or a subclass such as [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), `DOUBLE_PRECISION` etc. is in use, the [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") flag determines if values should be coerced to `Decimal`
    upon return, or returned as float objects. To make matters more complicated under
    Oracle, Oracle’s `NUMBER` type can also represent integer values if the “scale”
    is zero, so the Oracle-specific [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") type takes this into account as well.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的数字类型可以将值作为 Python `Decimal` 对象或 float 对象接收和返回。 当使用 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 对象或其子类（如 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")，`DOUBLE_PRECISION` 等）时， [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") 标志决定是否应在返回时将值强制转换为 `Decimal`，或以 float 对象返回。 在 Oracle
    下情况更加复杂，如果“scale”为零，Oracle 的 `NUMBER` 类型还可以表示整数值，因此 Oracle 特定的 [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") 类型也考虑了这一点。
- en: The cx_Oracle dialect makes extensive use of connection- and cursor-level “outputtypehandler”
    callables in order to coerce numeric values as requested. These callables are
    specific to the specific flavor of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") in use, as well as if no SQLAlchemy typing objects
    are present. There are observed scenarios where Oracle may sends incomplete or
    ambiguous information about the numeric types being returned, such as a query
    where the numeric types are buried under multiple levels of subquery. The type
    handlers do their best to make the right decision in all cases, deferring to the
    underlying cx_Oracle DBAPI for all those cases where the driver can make the best
    decision.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 方言广泛使用连接和游标级别的“outputtypehandler”可调用来根据需要强制转换数值。 这些可调用是针对正在使用的具体 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 的特定风味的，以及如果不存在 SQLAlchemy 类型化对象。 已观察到的情况包括 Oracle
    可能发送有关返回的数字类型的不完整或模糊信息的情况，例如查询，其中数字类型被嵌套在多个子查询的多个级别下。 类型处理程序在所有情况下都尽力做出正确的决定，在所有情况下都将决策委托给底层的
    cx_Oracle DBAPI，以便在驱动程序可以做出最佳决策的所有情况下进行。
- en: 'When no typing objects are present, as when executing plain SQL strings, a
    default “outputtypehandler” is present which will generally return numeric values
    which specify precision and scale as Python `Decimal` objects. To disable this
    coercion to decimal for performance reasons, pass the flag `coerce_to_decimal=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 当不存在类型化对象时，例如在执行纯 SQL 字符串时，存在默认的“outputtypehandler”，该处理程序通常将指定精度和比例的数字值作为 Python
    `Decimal` 对象返回。 为了性能原因禁用此转换为十进制数的操作，请将标志 `coerce_to_decimal=False` 传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")：
- en: '[PRE130]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `coerce_to_decimal` flag only impacts the results of plain string SQL statements
    that are not otherwise associated with a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy type (or a subclass of such).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal` 标志仅影响与 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy 类型（或其子类）无关联的纯字符串 SQL 语句的结果。'
- en: 'Changed in version 1.2: The numeric handling system for cx_Oracle has been
    reworked to take advantage of newer cx_Oracle features as well as better integration
    of outputtypehandlers.'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.2 版本起进行了更改：cx_Oracle 的数字处理系统已经重写，以利用较新的 cx_Oracle 特性以及更好地集成输出类型处理程序。
- en: DBAPI
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for cx-Oracle is available
    at: [https://oracle.github.io/python-cx_Oracle/](https://oracle.github.io/python-cx_Oracle/)'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '[cx-Oracle 的文档和下载信息](https://oracle.github.io/python-cx_Oracle/)（如适用）可在此处获取。'
- en: Connecting
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE131]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: DSN vs. Hostname connections
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DSN vs. 主机名连接
- en: cx_Oracle provides several methods of indicating the target database. The dialect
    translates from a series of different URL forms.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 提供了几种指示目标数据库的方法。方言将一系列不同的 URL 形式进行转换。
- en: Hostname Connections with Easy Connect Syntax
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用简易连接语法连接主机名
- en: 'Given a hostname, port and service name of the target Oracle Database, for
    example from Oracle’s [Easy Connect syntax](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings),
    then connect in SQLAlchemy using the `service_name` query string parameter:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 给定目标 Oracle 数据库的主机名、端口和服务名，例如来自 Oracle 的[简易连接语法](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings)，然后在
    SQLAlchemy 中使用`service_name`查询字符串参数进行连接：
- en: '[PRE132]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The [full Easy Connect syntax](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)
    is not supported. Instead, use a `tnsnames.ora` file and connect using a DSN.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持[完整的简易连接语法](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)。而是使用`tnsnames.ora`文件，并使用
    DSN 进行连接。
- en: Connections with tnsnames.ora or Oracle Cloud
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 tnsnames.ora 或 Oracle Cloud 进行连接
- en: 'Alternatively, if no port, database name, or `service_name` is provided, the
    dialect will use an Oracle DSN “connection string”. This takes the “hostname”
    portion of the URL as the data source name. For example, if the `tnsnames.ora`
    file contains a [Net Service Name](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)
    of `myalias` as below:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，如果未提供端口、数据库名称或`service_name`，则方言将使用 Oracle DSN “连接字符串”。这将 URL 的“主机名”部分作为数据源名称。例如，如果`tnsnames.ora`文件包含如下的[网络服务名称](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)`myalias`：  '
- en: '[PRE133]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The cx_Oracle dialect connects to this database service when `myalias` is the
    hostname portion of the URL, without specifying a port, database name or `service_name`:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当`myalias`是 URL 的主机名部分时，cx_Oracle 方言将连接到此数据库服务，而不指定端口、数据库名称或`service_name`：
- en: '[PRE134]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Users of Oracle Cloud should use this syntax and also configure the cloud wallet
    as shown in cx_Oracle documentation [Connecting to Autononmous Databases](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Cloud 的用户应使用此语法，并按照 cx_Oracle 文档[连接到 Autonomous 数据库](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases)中所示配置云钱包。
- en: SID Connections
  id: totrans-803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SID 连接
- en: 'To use Oracle’s obsolete SID connection syntax, the SID can be passed in a
    “database name” portion of the URL as below:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Oracle 的过时 SID 连接语法，可以如下传递 SID 在 URL 的“数据库名称”部分：
- en: '[PRE135]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Above, the DSN passed to cx_Oracle is created by `cx_Oracle.makedsn()` as follows:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，传递给 cx_Oracle 的 DSN 由`cx_Oracle.makedsn()`创建，如下所示：
- en: '[PRE136]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Hostname Connections with Easy Connect Syntax
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用简易连接语法连接主机名
- en: 'Given a hostname, port and service name of the target Oracle Database, for
    example from Oracle’s [Easy Connect syntax](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings),
    then connect in SQLAlchemy using the `service_name` query string parameter:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 给定目标 Oracle 数据库的主机名、端口和服务名，例如来自 Oracle 的[简易连接语法](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#easy-connect-syntax-for-connection-strings)，然后在
    SQLAlchemy 中使用`service_name`查询字符串参数进行连接：
- en: '[PRE137]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The [full Easy Connect syntax](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)
    is not supported. Instead, use a `tnsnames.ora` file and connect using a DSN.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持[完整的简易连接语法](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-B0437826-43C1-49EC-A94D-B650B6A4A6EE)。而是使用`tnsnames.ora`文件，并使用
    DSN 进行连接。
- en: Connections with tnsnames.ora or Oracle Cloud
  id: totrans-812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 tnsnames.ora 或 Oracle Cloud 进行连接
- en: 'Alternatively, if no port, database name, or `service_name` is provided, the
    dialect will use an Oracle DSN “connection string”. This takes the “hostname”
    portion of the URL as the data source name. For example, if the `tnsnames.ora`
    file contains a [Net Service Name](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)
    of `myalias` as below:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果没有提供端口、数据库名称或`service_name`，则方言将使用 Oracle DSN “连接字符串”。这将 URL 的“主机名”部分作为数据源名称。例如，如果`tnsnames.ora`文件包含如下的[网络服务名](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#net-service-names-for-connection-strings)`myalias`：
- en: '[PRE138]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The cx_Oracle dialect connects to this database service when `myalias` is the
    hostname portion of the URL, without specifying a port, database name or `service_name`:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 当`myalias`是 URL 的主机名部分时，cx_Oracle 方言将连接到此数据库服务，而不指定端口、数据库名称或`service_name`：
- en: '[PRE139]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Users of Oracle Cloud should use this syntax and also configure the cloud wallet
    as shown in cx_Oracle documentation [Connecting to Autononmous Databases](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Cloud 的用户应使用此语法，并按照 cx_Oracle 文档中显示的方式配置云钱包[连接到自主数据库](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#connecting-to-autononmous-databases)。
- en: SID Connections
  id: totrans-818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SID 连接
- en: 'To use Oracle’s obsolete SID connection syntax, the SID can be passed in a
    “database name” portion of the URL as below:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Oracle 的过时 SID 连接语法，SID 可以在 URL 的“数据库名称”部分中传递，如下所示：
- en: '[PRE140]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Above, the DSN passed to cx_Oracle is created by `cx_Oracle.makedsn()` as follows:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，传递给 cx_Oracle 的 DSN 是通过`cx_Oracle.makedsn()`创建的，如下所示：
- en: '[PRE141]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Passing cx_Oracle connect arguments
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递 cx_Oracle 连接参数
- en: 'Additional connection arguments can usually be passed via the URL query string;
    particular symbols like `cx_Oracle.SYSDBA` are intercepted and converted to the
    correct symbol:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过 URL 查询字符串传递其他连接参数；像`cx_Oracle.SYSDBA`这样的特殊符号将被拦截并转换为正确的符号：
- en: '[PRE142]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Changed in version 1.3: the cx_oracle dialect now accepts all argument names
    within the URL string itself, to be passed to the cx_Oracle DBAPI. As was the
    case earlier but not correctly documented, the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter also accepts all cx_Oracle DBAPI connect
    arguments.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3 开始：cx_oracle 方言现在接受 URL 字符串中的所有参数名称，以传递给 cx_Oracle DBAPI。与早期情况相同但没有正确记录的是，[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")参数也接受所有 cx_Oracle DBAPI 连接参数。
- en: 'To pass arguments directly to `.connect()` without using the query string,
    use the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary. Any cx_Oracle parameter value and/or constant
    may be passed, such as:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接传递参数给`.connect()`而不使用查询字符串，请使用[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")字典。可以传递任何 cx_Oracle 参数值和/或常量，例如：
- en: '[PRE143]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note that the default value for `encoding` and `nencoding` was changed to “UTF-8”
    in cx_Oracle 8.0 so these parameters can be omitted when using that version, or
    later.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 cx_Oracle 8.0 中，`encoding`和`nencoding`的默认值已更改为“UTF-8”，因此在使用该版本或更高版本时可以省略这些参数。
- en: Options consumed by the SQLAlchemy cx_Oracle dialect outside of the driver
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLAlchemy cx_Oracle 方言在驱动程序之外消耗的选项
- en: 'There are also options that are consumed by the SQLAlchemy cx_oracle dialect
    itself. These options are always passed directly to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , such as:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些选项是由 SQLAlchemy cx_oracle 方言本身消耗的。这些选项始终直接传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，例如：
- en: '[PRE144]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The parameters accepted by the cx_oracle dialect are as follows:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: cx_oracle 方言接受的参数如下：
- en: '`arraysize` - set the cx_oracle.arraysize value on cursors; defaults to `None`,
    indicating that the driver default should be used (typically the value is 100).
    This setting controls how many rows are buffered when fetching rows, and can have
    a significant effect on performance when modified. The setting is used for both
    `cx_Oracle` as well as `oracledb`.'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arraysize` - 设置光标上的 cx_oracle.arraysize 值；默认为`None`，表示应使用驱动程序的默认值（通常值为 100）。此设置控制在提取行时缓冲多少行，并且在修改时可能会对性能产生显着影响。该设置用于`cx_Oracle`以及`oracledb`。'
- en: 'Changed in version 2.0.26: - changed the default value from 50 to None, to
    use the default value of the driver itself.'
  id: totrans-835
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改变版本 2.0.26：- 将默认值从 50 更改为 None，以使用驱动程序本身的默认值。
- en: '`auto_convert_lobs` - defaults to True; See [LOB Datatypes](#cx-oracle-lob).'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto_convert_lobs` - 默认为 True；请参阅[LOB 数据类型](#cx-oracle-lob)。'
- en: '`coerce_to_decimal` - see [Precision Numerics](#cx-oracle-numeric) for detail.'
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal` - 详情请参阅[精确数字](#cx-oracle-numeric)。'
- en: '`encoding_errors` - see [Encoding Errors](#cx-oracle-unicode-encoding-errors)
    for detail.'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding_errors` - 详情请参阅[编码错误](#cx-oracle-unicode-encoding-errors)。'
- en: '### Using cx_Oracle SessionPool'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 cx_Oracle SessionPool'
- en: 'The cx_Oracle library provides its own connection pool implementation that
    may be used in place of SQLAlchemy’s pooling functionality. This can be achieved
    by using the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter to provide a function that returns a new
    connection, along with setting [`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine") to `NullPool` to disable SQLAlchemy’s pooling:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 库提供了自己的连接池实现，可以代替 SQLAlchemy 的池功能。这可以通过使用 [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") 参数提供一个返回新连接的函数，以及将 [`create_engine.pool_class`](../core/engines.html#sqlalchemy.create_engine.params.pool_class
    "sqlalchemy.create_engine") 设置为 `NullPool` 来实现禁用 SQLAlchemy 的池：
- en: '[PRE145]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The above engine may then be used normally where cx_Oracle’s pool handles connection
    pooling:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以正常使用上述引擎，其中 cx_Oracle 的池处理连接池：
- en: '[PRE146]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As well as providing a scalable solution for multi-user applications, the cx_Oracle
    session pool supports some Oracle features such as DRCP and [Application Continuity](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac).
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为多用户应用程序提供可扩展的解决方案外，cx_Oracle 会话池还支持一些 Oracle 功能，例如 DRCP 和[应用程序连续性](https://cx-oracle.readthedocs.io/en/latest/user_guide/ha.html#application-continuity-ac)。
- en: Using Oracle Database Resident Connection Pooling (DRCP)
  id: totrans-845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Oracle 数据库常驻连接池（DRCP）
- en: When using Oracle’s [DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086),
    the best practice is to pass a connection class and “purity” when acquiring a
    connection from the SessionPool. Refer to the [cx_Oracle DRCP documentation](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Oracle 的[DRCP](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-015CA8C1-2386-4626-855D-CC546DDC1086)时，最佳实践是在从
    SessionPool 获取连接时传递连接类和“纯度”。参考 [cx_Oracle DRCP 文档](https://cx-oracle.readthedocs.io/en/latest/user_guide/connection_handling.html#database-resident-connection-pooling-drcp)。
- en: 'This can be achieved by wrapping `pool.acquire()`:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过包装 `pool.acquire()` 来实现：
- en: '[PRE147]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The above engine may then be used normally where cx_Oracle handles session
    pooling and Oracle Database additionally uses DRCP:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以正常使用上述引擎，其中 cx_Oracle 处理会话池，Oracle 数据库另外使用 DRCP：
- en: '[PRE148]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '### Unicode'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '### Unicode'
- en: As is the case for all DBAPIs under Python 3, all strings are inherently Unicode
    strings. In all cases however, the driver requires an explicit encoding configuration.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3 下的所有 DBAPI，所有字符串本质上都是 Unicode 字符串。然而，在所有情况下，驱动程序都需要明确的编码配置。
- en: Ensuring the Correct Client Encoding
  id: totrans-853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确保正确的客户端编码
- en: The long accepted standard for establishing client encoding for nearly all Oracle
    related software is via the [NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)
    environment variable. cx_Oracle like most other Oracle drivers will use this environment
    variable as the source of its encoding configuration. The format of this variable
    is idiosyncratic; a typical value would be `AMERICAN_AMERICA.AL32UTF8`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有与 Oracle 相关的软件的建立客户端编码的长期接受标准是通过[NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)环境变量。像大多数其他
    Oracle 驱动程序一样，cx_Oracle 将使用此环境变量作为其编码配置的源。该变量的格式是特殊的；典型值可能是 `AMERICAN_AMERICA.AL32UTF8`。
- en: 'The cx_Oracle driver also supports a programmatic alternative which is to pass
    the `encoding` and `nencoding` parameters directly to its `.connect()` function.
    These can be present in the URL as follows:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 驱动程序还支持一种编程替代方法，即直接将 `encoding` 和 `nencoding` 参数传递给其 `.connect()`
    函数。这些可以在 URL 中存在如下：
- en: '[PRE149]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: For the meaning of the `encoding` and `nencoding` parameters, please consult
    [Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `encoding` 和 `nencoding` 参数的含义，请参阅[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)。
- en: See also
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - in the cx_Oracle documentation.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符集和国家语言支持 (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - 在 cx_Oracle 文档中。'
- en: Unicode-specific Column datatypes
  id: totrans-860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unicode 特定的列数据类型
- en: The Core expression language handles unicode data by use of the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes. These types correspond to the VARCHAR2
    and CLOB Oracle datatypes by default. When using these datatypes with Unicode
    data, it is expected that the Oracle database is configured with a Unicode-aware
    character set, as well as that the `NLS_LANG` environment variable is set appropriately,
    so that the VARCHAR2 and CLOB datatypes can accommodate the data.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达式语言通过使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型处理 Unicode 数据。这些类型默认对应于 VARCHAR2 和 CLOB Oracle 数据类型。当使用这些数据类型处理 Unicode 数据时，期望
    Oracle 数据库配置了 Unicode-aware 字符集，并且 `NLS_LANG` 环境变量被适当设置，以便 VARCHAR2 和 CLOB 数据类型可以容纳数据。
- en: In the case that the Oracle database is not configured with a Unicode character
    set, the two options are to use the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    datatypes explicitly, or to pass the flag `use_nchar_for_unicode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will cause the SQLAlchemy dialect to use NCHAR/NCLOB
    for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes instead of VARCHAR/CLOB.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 Oracle 数据库未配置为 Unicode 字符集，则两个选项是显式使用 [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") 和 [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    数据类型，或者在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    时传递 `use_nchar_for_unicode=True` 标志，这将导致 SQLAlchemy 方言对 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 数据类型使用 NCHAR/NCLOB 而不是 VARCHAR/CLOB。  '
- en: 'Changed in version 1.3: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now correspond to the `VARCHAR2` and
    `CLOB` Oracle datatypes unless the `use_nchar_for_unicode=True` is passed to the
    dialect when [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is called.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3 中的变更：[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在对应于 `VARCHAR2` 和 `CLOB` Oracle 数据类型，除非在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 时传递了 `use_nchar_for_unicode=True` 参数给方言。
- en: '#### Encoding Errors'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 编码错误'
- en: For the unusual case that data in the Oracle database is present with a broken
    encoding, the dialect accepts a parameter `encoding_errors` which will be passed
    to Unicode decoding functions in order to affect how decoding errors are handled.
    The value is ultimately consumed by the Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    function, and is passed both via cx_Oracle’s `encodingErrors` parameter consumed
    by `Cursor.var()`, as well as SQLAlchemy’s own decoding function, as the cx_Oracle
    dialect makes use of both under different circumstances.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Oracle 数据库中数据存在破损编码的特殊情况，方言接受一个名为 `encoding_errors` 的参数，该参数将传递给 Unicode 解码函数，以影响如何处理解码错误。该值最终由
    Python 的 [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    函数消耗，并且通过 cx_Oracle 的 `encodingErrors` 参数（由 `Cursor.var()` 消耗）以及 SQLAlchemy 自己的解码函数传递，因为在不同情况下
    cx_Oracle 方言都会使用它们。
- en: New in version 1.3.11.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3.11 中新增。
- en: Ensuring the Correct Client Encoding
  id: totrans-867
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确保正确的客户端编码
- en: The long accepted standard for establishing client encoding for nearly all Oracle
    related software is via the [NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)
    environment variable. cx_Oracle like most other Oracle drivers will use this environment
    variable as the source of its encoding configuration. The format of this variable
    is idiosyncratic; a typical value would be `AMERICAN_AMERICA.AL32UTF8`.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有与 Oracle 相关的软件建立客户端编码的长期接受标准是通过 [NLS_LANG](https://www.oracle.com/database/technologies/faq-nls-lang.html)
    环境变量。cx_Oracle 像大多数其他 Oracle 驱动程序一样将使用此环境变量作为其编码配置的来源。该变量的格式是特殊的；典型值可能是 `AMERICAN_AMERICA.AL32UTF8`。
- en: 'The cx_Oracle driver also supports a programmatic alternative which is to pass
    the `encoding` and `nencoding` parameters directly to its `.connect()` function.
    These can be present in the URL as follows:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 驱动程序还支持一种编程方式，即直接将 `encoding` 和 `nencoding` 参数传递给其 `.connect()` 函数。可以在
    URL 中以以下方式存在：
- en: '[PRE150]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: For the meaning of the `encoding` and `nencoding` parameters, please consult
    [Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `encoding` 和 `nencoding` 参数的含义，请参阅[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)。
- en: See also
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Characters Sets and National Language Support (NLS)](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - in the cx_Oracle documentation.'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符集和国家语言支持（NLS）](https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization)
    - 在 cx_Oracle 文档中。'
- en: Unicode-specific Column datatypes
  id: totrans-874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unicode 特定列数据类型
- en: The Core expression language handles unicode data by use of the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes. These types correspond to the VARCHAR2
    and CLOB Oracle datatypes by default. When using these datatypes with Unicode
    data, it is expected that the Oracle database is configured with a Unicode-aware
    character set, as well as that the `NLS_LANG` environment variable is set appropriately,
    so that the VARCHAR2 and CLOB datatypes can accommodate the data.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达式语言通过使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型处理 Unicode 数据。这些类型默认对应于 VARCHAR2 和 CLOB Oracle 数据类型。当使用这些数据类型处理 Unicode 数据时，预期
    Oracle 数据库已配置为使用 Unicode 意识字符集，并且 `NLS_LANG` 环境变量已适当设置，以便 VARCHAR2 和 CLOB 数据类型可以容纳数据。
- en: In the case that the Oracle database is not configured with a Unicode character
    set, the two options are to use the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") and [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    datatypes explicitly, or to pass the flag `use_nchar_for_unicode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which will cause the SQLAlchemy dialect to use NCHAR/NCLOB
    for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    / [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes instead of VARCHAR/CLOB.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Oracle 数据库未配置为 Unicode 字符集，则两个选项是显式使用 [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") 和 [`NCLOB`](#sqlalchemy.dialects.oracle.NCLOB "sqlalchemy.dialects.oracle.NCLOB")
    数据类型，或者在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    时传递标志 `use_nchar_for_unicode=True` 给 SQLAlchemy 方言，这将导致 SQLAlchemy 方言在 Unicode
    / UnicodeText 数据类型上使用 NCHAR/NCLOB 而不是 VARCHAR/CLOB。
- en: 'Changed in version 1.3: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now correspond to the `VARCHAR2` and
    `CLOB` Oracle datatypes unless the `use_nchar_for_unicode=True` is passed to the
    dialect when [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is called.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3 开始更改：[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在对应于 `VARCHAR2` 和 `CLOB` Oracle 数据类型，除非在调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 时传递了 `use_nchar_for_unicode=True`。
- en: '#### Encoding Errors'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 编码错误'
- en: For the unusual case that data in the Oracle database is present with a broken
    encoding, the dialect accepts a parameter `encoding_errors` which will be passed
    to Unicode decoding functions in order to affect how decoding errors are handled.
    The value is ultimately consumed by the Python [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    function, and is passed both via cx_Oracle’s `encodingErrors` parameter consumed
    by `Cursor.var()`, as well as SQLAlchemy’s own decoding function, as the cx_Oracle
    dialect makes use of both under different circumstances.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Oracle 数据库中存在损坏编码的特殊情况，该方言接受一个名为 `encoding_errors` 的参数，该参数将传递给 Unicode 解码函数，以影响如何处理解码错误。该值最终由
    Python 的 [decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)
    函数消耗，并且通过 cx_Oracle 的 `encodingErrors` 参数传递给 `Cursor.var()`，以及通过 SQLAlchemy 自己的解码函数传递，因为在不同情况下
    cx_Oracle 方言都会使用两者。
- en: New in version 1.3.11.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3.11 起新增。
- en: '### Fine grained control over cx_Oracle data binding performance with setinputsizes'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 setinputsizes 对 cx_Oracle 数据绑定性能进行精细控制'
- en: The cx_Oracle DBAPI has a deep and fundamental reliance upon the usage of the
    DBAPI `setinputsizes()` call. The purpose of this call is to establish the datatypes
    that are bound to a SQL statement for Python values being passed as parameters.
    While virtually no other DBAPI assigns any use to the `setinputsizes()` call,
    the cx_Oracle DBAPI relies upon it heavily in its interactions with the Oracle
    client interface, and in some scenarios it is not possible for SQLAlchemy to know
    exactly how data should be bound, as some settings can cause profoundly different
    performance characteristics, while altering the type coercion behavior at the
    same time.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle DBAPI 对 DBAPI `setinputsizes()` 调用具有深层且根本的依赖性。此调用的目的是为通过参数传递的 Python
    值绑定到 SQL 语句的数据类型建立起来。虽然几乎没有其他 DBAPI 将任何用途分配给 `setinputsizes()` 调用，但是 cx_Oracle
    DBAPI 在与 Oracle 客户端接口的交互中大量依赖它，并且在某些情况下，SQLAlchemy 无法确切地知道数据应该如何绑定，因为某些设置可能会导致性能特性发生深刻不同，同时改变类型强制转换行为。
- en: Users of the cx_Oracle dialect are **strongly encouraged** to read through cx_Oracle’s
    list of built-in datatype symbols at [https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types).
    Note that in some cases, significant performance degradation can occur when using
    these types vs. not, in particular when specifying `cx_Oracle.CLOB`.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议 cx_Oracle 方言的用户阅读 cx_Oracle 内置数据类型符号的列表，网址为 [https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types](https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types)。请注意，在某些情况下，使用这些类型与不使用这些类型相比，性能可能会显著下降，特别是在指定
    `cx_Oracle.CLOB` 时。
- en: On the SQLAlchemy side, the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") event can be used both for
    runtime visibility (e.g. logging) of the setinputsizes step as well as to fully
    control how `setinputsizes()` is used on a per-statement basis.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 方面，[`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") 事件可用于在运行时（例如记录）可见 setinputsizes
    步骤，以及完全控制每个语句如何使用 `setinputsizes()`。
- en: 'New in version 1.2.9: Added `DialectEvents.setinputsizes()`'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.2.9 起新增：增加了 `DialectEvents.setinputsizes()`
- en: Example 1 - logging all setinputsizes calls
  id: totrans-886
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1 - 记录所有 setinputsizes 调用
- en: 'The following example illustrates how to log the intermediary values from a
    SQLAlchemy perspective before they are converted to the raw `setinputsizes()`
    parameter dictionary. The keys of the dictionary are [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects which have a `.key` and a `.type`
    attribute:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在转换为原始 `setinputsizes()` 参数字典之前从 SQLAlchemy 视角记录中间值。字典的键是具有 `.key`
    和 `.type` 属性的 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 对象：
- en: '[PRE151]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Example 2 - remove all bindings to CLOB
  id: totrans-889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2 - 移除所有对 CLOB 的绑定
- en: 'The `CLOB` datatype in cx_Oracle incurs a significant performance overhead,
    however is set by default for the `Text` type within the SQLAlchemy 1.2 series.
    This setting can be modified as follows:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cx_Oracle 中，`CLOB` 数据类型会导致显着的性能开销，但是在 SQLAlchemy 1.2 系列中，默认为 `Text` 类型设置了该类型。可以按照以下方式修改此设置：
- en: '[PRE152]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Example 1 - logging all setinputsizes calls
  id: totrans-892
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 1 - 记录所有 setinputsizes 调用
- en: 'The following example illustrates how to log the intermediary values from a
    SQLAlchemy perspective before they are converted to the raw `setinputsizes()`
    parameter dictionary. The keys of the dictionary are [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects which have a `.key` and a `.type`
    attribute:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在 SQLAlchemy 视角下记录中间值，然后再将它们转换为原始`setinputsizes()`参数字典。字典的键是具有`.key`和`.type`属性的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象：
- en: '[PRE153]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Example 2 - remove all bindings to CLOB
  id: totrans-895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 2 - 删除所有对 CLOB 的绑定
- en: 'The `CLOB` datatype in cx_Oracle incurs a significant performance overhead,
    however is set by default for the `Text` type within the SQLAlchemy 1.2 series.
    This setting can be modified as follows:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cx_Oracle 中，`CLOB` 数据类型会产生显着的性能开销，但在 SQLAlchemy 1.2 系列中默认设置为`Text`类型。可以按以下方式修改此设置：
- en: '[PRE154]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '### RETURNING Support'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '### RETURNING 支持'
- en: The cx_Oracle dialect implements RETURNING using OUT parameters. The dialect
    supports RETURNING fully.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle 方言使用 OUT 参数实现 RETURNING。该方言完全支持 RETURNING。
- en: '### LOB Datatypes'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '### LOB 数据类型'
- en: LOB datatypes refer to the “large object” datatypes such as CLOB, NCLOB and
    BLOB. Modern versions of cx_Oracle and oracledb are optimized for these datatypes
    to be delivered as a single buffer. As such, SQLAlchemy makes use of these newer
    type handlers by default.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: LOB 数据类型指的是诸如 CLOB、NCLOB 和 BLOB 等“大对象”数据类型。现代版本的 cx_Oracle 和 oracledb 都经过优化，以便将这些数据类型作为单个缓冲区传递。因此，默认情况下
    SQLAlchemy 使用这些较新的类型处理程序。
- en: To disable the use of newer type handlers and deliver LOB objects as classic
    buffered objects with a `read()` method, the parameter `auto_convert_lobs=False`
    may be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which takes place only engine-wide.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用较新类型处理程序的使用，并将 LOB 对象作为具有`read()`方法的经典缓冲对象传递，可以将参数`auto_convert_lobs=False`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，这仅在整个引擎范围内生效。
- en: Two Phase Transactions Not Supported
  id: totrans-903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持两阶段事务
- en: Two phase transactions are **not supported** under cx_Oracle due to poor driver
    support. As of cx_Oracle 6.0b1, the interface for two phase transactions has been
    changed to be more of a direct pass-through to the underlying OCI layer with less
    automation. The additional logic to support this system is not implemented in
    SQLAlchemy.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 cx_Oracle 的驱动程序支持不佳，cx_Oracle 不支持两阶段事务。从 cx_Oracle 6.0b1 开始，用于两阶段事务的接口已更改为更直接地通过到底层
    OCI 层的传递，自动化程度较低。支持此系统的附加逻辑未在 SQLAlchemy 中实现。
- en: '### Precision Numerics'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '### 精确数值'
- en: SQLAlchemy’s numeric types can handle receiving and returning values as Python
    `Decimal` objects or float objects. When a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") object, or a subclass such as [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), `DOUBLE_PRECISION` etc. is in use, the [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") flag determines if values should be coerced to `Decimal`
    upon return, or returned as float objects. To make matters more complicated under
    Oracle, Oracle’s `NUMBER` type can also represent integer values if the “scale”
    is zero, so the Oracle-specific [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") type takes this into account as well.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的数值类型可以处理接收和返回 Python `Decimal` 对象或浮点对象的值。当使用 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 对象或其子类如 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")、`DOUBLE_PRECISION` 等时，[`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") 标志确定返回时值是否应强制转换为 `Decimal`，或作为浮点对象返回。在 Oracle 下更加复杂的是，如果“scale”为零，Oracle
    的 `NUMBER` 类型也可以表示整数值，因此 Oracle 特定的 [`NUMBER`](#sqlalchemy.dialects.oracle.NUMBER
    "sqlalchemy.dialects.oracle.NUMBER") 类型也考虑到了这一点。
- en: The cx_Oracle dialect makes extensive use of connection- and cursor-level “outputtypehandler”
    callables in order to coerce numeric values as requested. These callables are
    specific to the specific flavor of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") in use, as well as if no SQLAlchemy typing objects
    are present. There are observed scenarios where Oracle may sends incomplete or
    ambiguous information about the numeric types being returned, such as a query
    where the numeric types are buried under multiple levels of subquery. The type
    handlers do their best to make the right decision in all cases, deferring to the
    underlying cx_Oracle DBAPI for all those cases where the driver can make the best
    decision.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Oracle方言广泛使用连接和游标级别的“outputtypehandler”可调用对象，以按请求强制转换数值。这些可调用对象特定于正在使用的特定[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")的类型，以及如果没有SQLAlchemy类型化对象存在。已经观察到Oracle可能会发送关于返回的数值类型不完整或模糊的信息的情况，例如查询，其中数值类型被埋在多级子查询下。类型处理程序尽最大努力在所有情况下做出正确的决定，在所有情况下都推迟到底层cx_Oracle
    DBAPI，以便在驱动程序可以做出最佳决定的所有这些情况下。
- en: 'When no typing objects are present, as when executing plain SQL strings, a
    default “outputtypehandler” is present which will generally return numeric values
    which specify precision and scale as Python `Decimal` objects. To disable this
    coercion to decimal for performance reasons, pass the flag `coerce_to_decimal=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有类型化对象时，例如执行纯SQL字符串时，存在一个默认的“outputtypehandler”，通常返回指定精度和比例的数值，其类型为Python的`Decimal`对象。为了出于性能考虑禁用对十进制数的强制转换，请在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中传递标志`coerce_to_decimal=False`：
- en: '[PRE155]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The `coerce_to_decimal` flag only impacts the results of plain string SQL statements
    that are not otherwise associated with a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy type (or a subclass of such).
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '`coerce_to_decimal`标志仅影响不与[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") SQLAlchemy类型（或其子类）相关联的纯字符串SQL语句的结果。'
- en: 'Changed in version 1.2: The numeric handling system for cx_Oracle has been
    reworked to take advantage of newer cx_Oracle features as well as better integration
    of outputtypehandlers.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.2版本开始更改：cx_Oracle的数值处理系统已经重新设计，以利用较新的cx_Oracle功能以及更好地集成outputtypehandlers。
- en: '## python-oracledb'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '## python-oracledb'
- en: Support for the Oracle database via the python-oracledb driver.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 通过python-oracledb驱动程序支持Oracle数据库。
- en: DBAPI
  id: totrans-914
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for python-oracledb
    is available at: [https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 有关python-oracledb的文档和下载信息（如果适用），请访问：[https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)
- en: Connecting
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE156]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: python-oracledb is released by Oracle to supersede the cx_Oracle driver. It
    is fully compatible with cx_Oracle and features both a “thin” client mode that
    requires no dependencies, as well as a “thick” mode that uses the Oracle Client
    Interface in the same way as cx_Oracle.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: python-oracledb是由Oracle发布的，旨在取代cx_Oracle驱动程序。它与cx_Oracle完全兼容，具有不需要任何依赖项的“轻客户端”模式，以及使用与cx_Oracle相同的方式使用Oracle
    Client Interface的“厚客户端”模式。
- en: See also
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cx_Oracle](#cx-oracle) - all of cx_Oracle’s notes apply to the oracledb driver
    as well.'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '[cx_Oracle](#cx-oracle) - cx_Oracle的所有注意事项也适用于oracledb驱动程序。'
- en: 'The SQLAlchemy `oracledb` dialect provides both a sync and an async implementation
    under the same dialect name. The proper version is selected depending on how the
    engine is created:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的`oracledb`方言提供了同名的同步和异步实现。根据引擎的创建方式选择合适的版本：
- en: 'calling [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    with `oracle+oracledb://...` will automatically select the sync version, e.g.:'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`oracle+oracledb://...`调用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")将自动选择同步版本，例如：
- en: '[PRE157]'
  id: totrans-924
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'calling [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") with `oracle+oracledb://...` will
    automatically select the async version, e.g.:'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`oracle+oracledb://...`调用[`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine")将自动选择异步版本，例如：
- en: '[PRE158]'
  id: totrans-926
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The asyncio version of the dialect may also be specified explicitly using the
    `oracledb_async` suffix, as:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 可以明确指定方言的异步版本，例如使用`oracledb_async`后缀：
- en: '[PRE159]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'New in version 2.0.25: added support for the async version of oracledb.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.25 中新增对 oracledb 的异步版本的支持。
- en: Thick mode support
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Thick mode 支持
- en: By default the `python-oracledb` is started in thin mode, that does not require
    oracle client libraries to be installed in the system. The `python-oracledb` driver
    also support a “thick” mode, that behaves similarly to `cx_oracle` and requires
    that Oracle Client Interface (OCI) is installed.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`python-oracledb` 以 thin 模式启动，不需要在系统中安装 Oracle 客户端库。`python-oracledb`
    驱动程序还支持一种“thick”模式，其行为类似于`cx_oracle`，并且要求安装 Oracle 客户端接口（OCI）。
- en: 'To enable this mode, the user may call `oracledb.init_oracle_client` manually,
    or by passing the parameter `thick_mode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). To pass custom arguments to `init_oracle_client`,
    like the `lib_dir` path, a dict may be passed to this parameter, as in:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此模式，用户可以手动调用`oracledb.init_oracle_client`，也可以通过将参数`thick_mode=True`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")来实现。要将自定义参数传递给`init_oracle_client`，如`lib_dir`路径，则可以将字典传递给此参数，如下所示：
- en: '[PRE160]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: See also
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
- en: 'New in version 2.0.0: added support for oracledb driver.'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0 中新增对 oracledb 驱动程序的支持。
- en: DBAPI
  id: totrans-937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for python-oracledb
    is available at: [https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: python-oracledb 的文档和下载信息（如适用）可在此处找到：[https://oracle.github.io/python-oracledb/](https://oracle.github.io/python-oracledb/)
- en: Connecting
  id: totrans-939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE161]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Thick mode support
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Thick mode 支持
- en: By default the `python-oracledb` is started in thin mode, that does not require
    oracle client libraries to be installed in the system. The `python-oracledb` driver
    also support a “thick” mode, that behaves similarly to `cx_oracle` and requires
    that Oracle Client Interface (OCI) is installed.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`python-oracledb` 以 thin 模式启动，不需要在系统中安装 Oracle 客户端库。`python-oracledb`
    驱动程序还支持一种“thick”模式，其行为类似于`cx_oracle`，并且要求安装 Oracle 客户端接口（OCI）。
- en: 'To enable this mode, the user may call `oracledb.init_oracle_client` manually,
    or by passing the parameter `thick_mode=True` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). To pass custom arguments to `init_oracle_client`,
    like the `lib_dir` path, a dict may be passed to this parameter, as in:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此模式，用户可以手动调用`oracledb.init_oracle_client`，也可以通过将参数`thick_mode=True`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")来实现。要将自定义参数传递给`init_oracle_client`，如`lib_dir`路径，则可以将字典传递给此参数，如下所示：
- en: '[PRE162]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: See also
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client](https://python-oracledb.readthedocs.io/en/latest/api_manual/module.html#oracledb.init_oracle_client)'
- en: 'New in version 2.0.0: added support for oracledb driver.'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0 中新增对 oracledb 驱动程序的支持。
