- en: Using INSERT Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/data_insert.html](https://docs.sqlalchemy.org/en/20/tutorial/data_insert.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When using Core as well as when using the ORM for bulk operations, a SQL INSERT
    statement is generated directly using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function - this function generates a new instance
    of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    which represents an INSERT statement in SQL, that adds new data into a table.
  prefs: []
  type: TYPE_NORMAL
- en: '**ORM Readers** -'
  prefs: []
  type: TYPE_NORMAL
- en: This section details the Core means of generating an individual SQL INSERT statement
    in order to add new rows to a table. When using the ORM, we normally use another
    tool that rides on top of this called the [unit of work](../glossary.html#term-unit-of-work),
    which will automate the production of many INSERT statements at once. However,
    understanding how the Core handles data creation and manipulation is very useful
    even when the ORM is running it for us. Additionally, the ORM supports direct
    use of INSERT using a feature called [Bulk / Multi Row INSERT, upsert, UPDATE
    and DELETE](orm_data_manipulation.html#tutorial-orm-bulk).
  prefs: []
  type: TYPE_NORMAL
- en: To skip directly to how to INSERT rows with the ORM using normal unit of work
    patterns, see [Inserting Rows using the ORM Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm).
  prefs: []
  type: TYPE_NORMAL
- en: The insert() SQL Expression Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple example of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") illustrating the target table and the VALUES
    clause at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `stmt` variable is an instance of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"). Most SQL expressions can be stringified in
    place as a means to see the general form of what’s being produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The stringified form is created by producing a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") form of the object which includes a database-specific
    string SQL representation of the statement; we can acquire this object directly
    using the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct is an example of a “parameterized” construct, illustrated previously
    at [Sending Parameters](dbapi_transactions.html#tutorial-sending-parameters);
    to view the `name` and `fullname` [bound parameters](../glossary.html#term-bound-parameters),
    these are available from the [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") construct as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Executing the Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Invoking the statement we can INSERT a row into `user_table`. The INSERT SQL
    as well as the bundled parameters can be seen in the SQL logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In its simple form above, the INSERT statement does not return any rows, and
    if only a single row is inserted, it will usually include the ability to return
    information about column-level default values that were generated during the INSERT
    of that row, most commonly an integer primary key value. In the above case the
    first row in a SQLite database will normally return `1` for the first integer
    primary key value, which we can acquire using the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") returns a tuple because
    a primary key may contain multiple columns. This is known as a [composite primary
    key](../glossary.html#term-composite-primary-key). The [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") is intended to always contain
    the complete primary key of the record just inserted, not just a “cursor.lastrowid”
    kind of value, and is also intended to be populated regardless of whether or not
    “autoincrement” were used, hence to express a complete primary key it’s a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.8: the tuple returned by [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") is now a named tuple fulfilled
    by returning it as a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '## INSERT usually generates the “values” clause automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example above made use of the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method to explicitly create the VALUES
    clause of the SQL INSERT statement. If we don’t actually use [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and just print out an “empty” statement,
    we get an INSERT for every column in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that has not had [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") called upon it and execute it rather
    than print it, the statement will be compiled to a string based on the parameters
    that we passed to the [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, and only include columns relevant
    to the parameters that were passed. This is actually the usual way that [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") is used to insert rows without having to type
    out an explicit VALUES clause. The example below illustrates a two-column INSERT
    statement being executed with a list of parameters at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The execution above features “executemany” form first illustrated at [Sending
    Multiple Parameters](dbapi_transactions.html#tutorial-multiple-parameters), however
    unlike when using the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, we didn’t have to spell out any SQL.
    By passing a dictionary or list of dictionaries to the [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method in conjunction with the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") ensures that the column names which are passed
    will be expressed in the VALUES clause of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Alchemy
  prefs: []
  type: TYPE_NORMAL
- en: Hi, welcome to the first edition of **Deep Alchemy**. The person on the left
    is known as **The Alchemist**, and you’ll note they are **not** a wizard, as the
    pointy hat is not sticking upwards. The Alchemist comes around to describe things
    that are generally **more advanced and/or tricky** and additionally **not usually
    needed**, but for whatever reason they feel you should know about this thing that
    SQLAlchemy can do.
  prefs: []
  type: TYPE_NORMAL
- en: In this edition, towards the goal of having some interesting data in the `address_table`
    as well, below is a more advanced example illustrating how the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method may be used explicitly while
    at the same time including for additional VALUES generated from the parameters.
    A [scalar subquery](../glossary.html#term-scalar-subquery) is constructed, making
    use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct introduced in the next section,
    and the parameters used in the subquery are set up using an explicit bound parameter
    name, established using the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct.
  prefs: []
  type: TYPE_NORMAL
- en: This is some slightly **deeper** alchemy just so that we can add related rows
    without fetching the primary key identifiers from the `user_table` operation into
    the application. Most Alchemists will simply use the ORM which takes care of things
    like this for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have some more interesting data in our tables that we will make
    use of in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'A true “empty” INSERT that inserts only the “defaults” for a table without
    including any explicit values at all is generated if we indicate [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with no arguments; not every database
    backend supports this, but here’s what SQLite produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]  ## INSERT…RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RETURNING clause for supported backends is used automatically in order
    to retrieve the last inserted primary key value as well as the values for server
    defaults. However the RETURNING clause may also be specified explicitly using
    the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method; in this case, the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that’s returned when the statement is executed
    has rows which can be fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be combined with [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select"), as in the example below that
    builds upon the example stated in [INSERT…FROM SELECT](#tutorial-insert-from-select):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The RETURNING feature is also supported by UPDATE and DELETE statements, which
    will be introduced later in this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: For INSERT statements, the RETURNING feature may be used both for single-row
    statements as well as for statements that INSERT multiple rows at once. Support
    for multiple-row INSERT with RETURNING is dialect specific, however is supported
    for all the dialects that are included in SQLAlchemy which support RETURNING.
    See the section [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    for background on this feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Bulk INSERT with or without RETURNING is also supported by the ORM. See [ORM
    Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    for reference documentation.  ## INSERT…FROM SELECT'
  prefs: []
  type: TYPE_NORMAL
- en: 'A less used feature of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), but here for completeness, the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct can compose an INSERT that gets
    rows directly from a SELECT using the [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") method. This method accepts a
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is discussed in the next section, along with a list of column
    names to be targeted in the actual INSERT. In the example below, rows are added
    to the `address` table which are derived from rows in the `user_account` table,
    giving each user a free email address at `aol.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This construct is used when one wants to copy data from some other part of the
    database directly into a new set of rows, without actually fetching and re-sending
    the data from the client.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    - in the SQL Expression API documentation'
  prefs: []
  type: TYPE_NORMAL
- en: The insert() SQL Expression Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple example of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") illustrating the target table and the VALUES
    clause at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `stmt` variable is an instance of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"). Most SQL expressions can be stringified in
    place as a means to see the general form of what’s being produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The stringified form is created by producing a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") form of the object which includes a database-specific
    string SQL representation of the statement; we can acquire this object directly
    using the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct is an example of a “parameterized” construct, illustrated previously
    at [Sending Parameters](dbapi_transactions.html#tutorial-sending-parameters);
    to view the `name` and `fullname` [bound parameters](../glossary.html#term-bound-parameters),
    these are available from the [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") construct as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Executing the Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Invoking the statement we can INSERT a row into `user_table`. The INSERT SQL
    as well as the bundled parameters can be seen in the SQL logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In its simple form above, the INSERT statement does not return any rows, and
    if only a single row is inserted, it will usually include the ability to return
    information about column-level default values that were generated during the INSERT
    of that row, most commonly an integer primary key value. In the above case the
    first row in a SQLite database will normally return `1` for the first integer
    primary key value, which we can acquire using the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") returns a tuple because
    a primary key may contain multiple columns. This is known as a [composite primary
    key](../glossary.html#term-composite-primary-key). The [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") is intended to always contain
    the complete primary key of the record just inserted, not just a “cursor.lastrowid”
    kind of value, and is also intended to be populated regardless of whether or not
    “autoincrement” were used, hence to express a complete primary key it’s a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.8: the tuple returned by [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") is now a named tuple fulfilled
    by returning it as a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '## INSERT usually generates the “values” clause automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example above made use of the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method to explicitly create the VALUES
    clause of the SQL INSERT statement. If we don’t actually use [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") and just print out an “empty” statement,
    we get an INSERT for every column in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that has not had [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") called upon it and execute it rather
    than print it, the statement will be compiled to a string based on the parameters
    that we passed to the [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, and only include columns relevant
    to the parameters that were passed. This is actually the usual way that [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") is used to insert rows without having to type
    out an explicit VALUES clause. The example below illustrates a two-column INSERT
    statement being executed with a list of parameters at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The execution above features “executemany” form first illustrated at [Sending
    Multiple Parameters](dbapi_transactions.html#tutorial-multiple-parameters), however
    unlike when using the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, we didn’t have to spell out any SQL.
    By passing a dictionary or list of dictionaries to the [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method in conjunction with the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") ensures that the column names which are passed
    will be expressed in the VALUES clause of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Alchemy
  prefs: []
  type: TYPE_NORMAL
- en: Hi, welcome to the first edition of **Deep Alchemy**. The person on the left
    is known as **The Alchemist**, and you’ll note they are **not** a wizard, as the
    pointy hat is not sticking upwards. The Alchemist comes around to describe things
    that are generally **more advanced and/or tricky** and additionally **not usually
    needed**, but for whatever reason they feel you should know about this thing that
    SQLAlchemy can do.
  prefs: []
  type: TYPE_NORMAL
- en: In this edition, towards the goal of having some interesting data in the `address_table`
    as well, below is a more advanced example illustrating how the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method may be used explicitly while
    at the same time including for additional VALUES generated from the parameters.
    A [scalar subquery](../glossary.html#term-scalar-subquery) is constructed, making
    use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct introduced in the next section,
    and the parameters used in the subquery are set up using an explicit bound parameter
    name, established using the [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") construct.
  prefs: []
  type: TYPE_NORMAL
- en: This is some slightly **deeper** alchemy just so that we can add related rows
    without fetching the primary key identifiers from the `user_table` operation into
    the application. Most Alchemists will simply use the ORM which takes care of things
    like this for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have some more interesting data in our tables that we will make
    use of in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'A true “empty” INSERT that inserts only the “defaults” for a table without
    including any explicit values at all is generated if we indicate [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") with no arguments; not every database
    backend supports this, but here’s what SQLite produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '## INSERT…RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RETURNING clause for supported backends is used automatically in order
    to retrieve the last inserted primary key value as well as the values for server
    defaults. However the RETURNING clause may also be specified explicitly using
    the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method; in this case, the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that’s returned when the statement is executed
    has rows which can be fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be combined with [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select"), as in the example below that
    builds upon the example stated in [INSERT…FROM SELECT](#tutorial-insert-from-select):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The RETURNING feature is also supported by UPDATE and DELETE statements, which
    will be introduced later in this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: For INSERT statements, the RETURNING feature may be used both for single-row
    statements as well as for statements that INSERT multiple rows at once. Support
    for multiple-row INSERT with RETURNING is dialect specific, however is supported
    for all the dialects that are included in SQLAlchemy which support RETURNING.
    See the section [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    for background on this feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT with or without RETURNING is also supported by the ORM. See [ORM
    Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    for reference documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '## INSERT…FROM SELECT'
  prefs: []
  type: TYPE_NORMAL
- en: 'A less used feature of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), but here for completeness, the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct can compose an INSERT that gets
    rows directly from a SELECT using the [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") method. This method accepts a
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct, which is discussed in the next section, along with a list of column
    names to be targeted in the actual INSERT. In the example below, rows are added
    to the `address` table which are derived from rows in the `user_account` table,
    giving each user a free email address at `aol.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This construct is used when one wants to copy data from some other part of the
    database directly into a new set of rows, without actually fetching and re-sending
    the data from the client.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    - in the SQL Expression API documentation'
  prefs: []
  type: TYPE_NORMAL
