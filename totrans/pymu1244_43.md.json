["```py\nclass Shape\n```", "```py\n__init__(self, page)\n```", "```py\ndraw_line(p1, p2)\n```", "```py\ndraw_squiggle(p1, p2, breadth=2)\n```", "```py\n>>> import pymupdf\n>>> doc=pymupdf.open()\n>>> page=doc.new_page()\n>>> r = pymupdf.Rect(100, 100, 300, 200)\n>>> shape=page.new_shape()\n>>> shape.draw_squiggle(r.tl, r.tr)\n>>> shape.draw_squiggle(r.tr, r.br)\n>>> shape.draw_squiggle(r.br, r.tl)\n>>> shape.finish(color=(0, 0, 1), fill=(1, 1, 0))\n>>> shape.commit()\n>>> doc.save(\"x.pdf\") \n```", "```py\ndraw_zigzag(p1, p2, breadth=2)\n```", "```py\ndraw_polyline(points)\n```", "```py\ndraw_bezier(p1, p2, p3, p4)\n```", "```py\ndraw_oval(tetra)\n```", "```py\ndraw_circle(center, radius)\n```", "```py\ndraw_curve(p1, p2, p3)\n```", "```py\ndraw_sector(center, point, angle, fullSector=True)\n```", "```py\ndraw_rect(rect, *, radius=None)\n```", "```py\ndraw_quad(quad)\n```", "```py\nfinish(width=1, color=(0,), fill=None, lineCap=0, lineJoin=0, dashes=None, closePath=True, even_odd=False, morph=(fixpoint, matrix), stroke_opacity=1, fill_opacity=1, oc=0)\n```", "```py\ninsert_text(point, text, fontsize=11, fontname='helv', fontfile=None, set_simple=False, encoding=TEXT_ENCODING_LATIN, color=None, lineheight=None, fill=None, render_mode=0, border_width=1, rotate=0, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)\n```", "```py\ninsert_textbox(rect, buffer, fontsize=11, fontname='helv', fontfile=None, set_simple=False, encoding=TEXT_ENCODING_LATIN, color=None, fill=None, render_mode=0, border_width=1, expandtabs=8, align=TEXT_ALIGN_LEFT, rotate=0, lineheight=None, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)\n```", "```py\ncommit(overlay=True)\n```", "```py\ndoc\n```", "```py\npage\n```", "```py\nheight\n```", "```py\nwidth\n```", "```py\ndraw_cont\n```", "```py\ntext_cont\n```", "```py\nrect\n```", "```py\n>>> # assuming ...\n>>> morph = (point, matrix)\n>>> # ... recalculate the shape rectangle like so:\n>>> shape.rect = (shape.rect - pymupdf.Rect(point, point)) * ~matrix + pymupdf.Rect(point, point) \n```", "```py\ntotalcont\n```", "```py\nlastPoint\n```", "```py\n>>> shape = page.new_shape()\n>>> shape.draw1(...)\n>>> shape.draw2(...)\n>>> ...\n>>> shape.finish(width=..., color=..., fill=..., morph=...)\n>>> shape.draw3(...)\n>>> shape.draw4(...)\n>>> ...\n>>> shape.finish(width=..., color=..., fill=..., morph=...)\n>>> ...\n>>> shape.insert_text*\n>>> ...\n>>> shape.commit()\n>>> .... \n```", "```py\n    shape = page.new_shape()  # start a new shape\n    cols = (...)  # a sequence of RGB color triples\n    pieces = len(cols)  # number of pieces to draw\n    beta = 360. / pieces  # angle of each piece of pie\n    center = pymupdf.Point(...)  # center of the pie\n    p0 = pymupdf.Point(...)  # starting point\n    for i in range(pieces):\n        p0 = shape.draw_sector(center, p0, beta,\n                              fullSector=True) # draw piece\n        # now fill it but do not connect ends of the arc\n        shape.finish(fill=cols[i], closePath=False)\n    shape.commit()  # update the page \n    ```", "```py\n    shape = page.new_shape() # start a new shape\n    beta = -360.0 / n  # our angle, drawn clockwise\n    center = pymupdf.Point(...)  # center of circle\n    p0 = pymupdf.Point(...)  # start here (1st edge)\n    points = [p0]  # store polygon edges\n    for i in range(n):  # calculate the edges\n        p0 = shape.draw_sector(center, p0, beta)\n        points.append(p0)\n    shape.draw_cont = \"\"  # do not draw the circle sectors\n    shape.draw_polyline(points)  # draw the polygon\n    shape.finish(color=(1,0,0), fill=(1,1,0), closePath=False)\n    shape.commit() \n    ```", "```py\n>>> shape = page.new_shape()\n>>> shape.draw1(...)\n>>> shape.draw2(...)\n>>> ...\n>>> shape.finish(width=..., color=..., fill=..., morph=...)\n>>> shape.draw3(...)\n>>> shape.draw4(...)\n>>> ...\n>>> shape.finish(width=..., color=..., fill=..., morph=...)\n>>> ...\n>>> shape.insert_text*\n>>> ...\n>>> shape.commit()\n>>> .... \n```", "```py\n    shape = page.new_shape()  # start a new shape\n    cols = (...)  # a sequence of RGB color triples\n    pieces = len(cols)  # number of pieces to draw\n    beta = 360. / pieces  # angle of each piece of pie\n    center = pymupdf.Point(...)  # center of the pie\n    p0 = pymupdf.Point(...)  # starting point\n    for i in range(pieces):\n        p0 = shape.draw_sector(center, p0, beta,\n                              fullSector=True) # draw piece\n        # now fill it but do not connect ends of the arc\n        shape.finish(fill=cols[i], closePath=False)\n    shape.commit()  # update the page \n    ```", "```py\n    shape = page.new_shape() # start a new shape\n    beta = -360.0 / n  # our angle, drawn clockwise\n    center = pymupdf.Point(...)  # center of circle\n    p0 = pymupdf.Point(...)  # start here (1st edge)\n    points = [p0]  # store polygon edges\n    for i in range(n):  # calculate the edges\n        p0 = shape.draw_sector(center, p0, beta)\n        points.append(p0)\n    shape.draw_cont = \"\"  # do not draw the circle sectors\n    shape.draw_polyline(points)  # draw the polygon\n    shape.finish(color=(1,0,0), fill=(1,1,0), closePath=False)\n    shape.commit() \n    ```"]