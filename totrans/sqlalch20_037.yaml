- en: Collection Customization and API Details
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合自定义和 API 详情
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/collection_api.html](https://docs.sqlalchemy.org/en/20/orm/collection_api.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/collection_api.html](https://docs.sqlalchemy.org/en/20/orm/collection_api.html)
- en: The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    function defines a linkage between two classes. When the linkage defines a one-to-many
    or many-to-many relationship, it’s represented as a Python collection when objects
    are loaded and manipulated. This section presents additional information about
    collection configuration and techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    函数定义了两个类之间的链接。当链接定义了一对多或多对多的关系时，在加载和操作对象时，它被表示为 Python 集合。本节介绍了有关集合配置和技术的其他信息。'
- en: '## Customizing Collection Access'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '## 自定义集合访问'
- en: 'Mapping a one-to-many or many-to-many relationship results in a collection
    of values accessible through an attribute on the parent instance. The two common
    collection types for these are `list` and `set`, which in [Declarative](declarative_styles.html)
    mappings that use [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    is established by using the collection type within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") container, as demonstrated in the `Parent.children` collection
    below where `list` is used:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将一对多或多对多的关系映射为一组可通过父实例上的属性访问的值的集合。对于这些关系的两种常见集合类型是 `list` 和 `set`，在使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的 [声明式](declarative_styles.html) 映射中，通过在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 容器中使用集合类型来建立，如下面的 `Parent.children` 集合中所示，其中使用了 `list`：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or for a `set`, illustrated in the same `Parent.children` collection:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `set`，在相同的 `Parent.children` 集合中进行说明：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If using Python 3.7 or 3.8, annotations for collections need to use `typing.List`
    or `typing.Set`, e.g. `Mapped[List["Child"]]` or `Mapped[Set["Child"]]`; the `list`
    and `set` Python built-ins don’t yet support generic annotation in these Python
    versions, such as:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Python 3.7 或 3.8，则集合的注释需要使用 `typing.List` 或 `typing.Set`，例如 `Mapped[List["Child"]]`
    或 `Mapped[Set["Child"]]`；在这些 Python 版本中，`list` 和 `set` Python 内置的类型尚不支持通用注释，例如：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When using mappings without the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation, such as when using [imperative mappings](mapping_styles.html#orm-imperative-mapping)
    or untyped Python code, as well as in a few special cases, the collection class
    for a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    can always be specified directly using the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用没有 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注释的映射时，比如使用 [命令式映射](mapping_styles.html#orm-imperative-mapping) 或者未经类型化的 Python
    代码，以及在一些特殊情况下，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的集合类始终可以直接使用 [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") 参数进行指定：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the absence of [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") or [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the default collection type is `list`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在缺少 [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") 或 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的情况下，默认的集合类型是 `list`。
- en: Beyond `list` and `set` builtins, there is also support for two varieties of
    dictionary, described below at [Dictionary Collections](#orm-dictionary-collection).
    There is also support for any arbitrary mutable sequence type can be set up as
    the target collection, with some additional configuration steps; this is described
    in the section [Custom Collection Implementations](#orm-custom-collection).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的 `list` 和 `set`，还支持两种字典的变体，下文将进行描述 [字典集合](#orm-dictionary-collection)。还支持任何任意可变序列类型可以设置为目标集合，需要一些额外的配置步骤；这在
    [自定义集合实现](#orm-custom-collection) 部分进行了描述。
- en: '### Dictionary Collections'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '### 字典集合'
- en: 'A little extra detail is needed when using a dictionary as a collection. This
    because objects are always loaded from the database as lists, and a key-generation
    strategy must be available to populate the dictionary correctly. The [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") function is by far the most common way
    to achieve a simple dictionary collection. It produces a dictionary class that
    will apply a particular attribute of the mapped class as a key. Below we map an
    `Item` class containing a dictionary of `Note` items keyed to the `Note.keyword`
    attribute. When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be typed using the [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") or just plain `dict` as illustrated in the following
    example. However, the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter is required in this case so that the
    [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    may be appropriately parametrized:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字典作为集合时需要一些额外的细节。这是因为对象总是作为列表从数据库加载的，必须提供一种键生成策略才能正确地填充字典。[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")函数是实现简单字典集合的最常见方式。它生成一个字典类，该类将映射类的特定属性作为键。下面我们映射了一个包含以`Note.keyword`属性作为键的`Note`项目字典的`Item`类。当使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")时，可以使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释，可以使用[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")或仅使用普通的`dict`，如下面的示例所示。然而，在这种情况下，需要使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数，以便适当地参数化[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Item.notes` is then a dictionary:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item.notes`然后是一个字典：'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    will ensure that the `.keyword` attribute of each `Note` complies with the key
    in the dictionary. Such as, when assigning to `Item.notes`, the dictionary key
    we supply must match that of the actual `Note` object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")将确保每个`Note`的`.keyword`属性与字典中的键相匹配。例如，当分配给`Item.notes`时，我们提供的字典键必须与实际`Note`对象的键相匹配：'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The attribute which [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") uses as a key does not need to be mapped
    at all! Using a regular Python `@property` allows virtually any detail or combination
    of details about the object to be used as the key, as below when we establish
    it as a tuple of `Note.keyword` and the first ten letters of the `Note.text` field:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")用作键的属性根本不需要被映射！使用常规的Python
    `@property` 允许使用对象的几乎任何细节或组合细节作为键，就像下面我们将其建立为`Note.keyword`元组和`Note.text`字段的前十个字母一样：'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Above we added a `Note.item` relationship, with a bi-directional [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") configuration. Assigning to this reverse relationship,
    the `Note` is added to the `Item.notes` dictionary and the key is generated for
    us automatically:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们添加了一个带有双向[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")配置的`Note.item`关系。将`Note`分配给这个反向关系时，`Note`被添加到`Item.notes`字典中，并且键会自动为我们生成：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Other built-in dictionary types include [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict"), which is almost like [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") except given the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内置的字典类型包括[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")，几乎与[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")类似，只是直接给出[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象：
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'as well as `mapped_collection()` which is passed any callable function. Note
    that it’s usually easier to use [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") along with a `@property` as mentioned earlier:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`mapped_collection()`，它接受任何可调用函数。请注意，通常更容易使用前面提到的`@property`与[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")一起使用：
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Dictionary mappings are often combined with the “Association Proxy” extension
    to produce streamlined dictionary views. See [Proxying to Dictionary Based Collections](extensions/associationproxy.html#proxying-dictionaries)
    and [Composite Association Proxies](extensions/associationproxy.html#composite-association-proxy)
    for examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字典映射经常与“Association Proxy”扩展组合以产生简化的字典视图。请参阅[Proxying to Dictionary Based Collections](extensions/associationproxy.html#proxying-dictionaries)和[Composite
    Association Proxies](extensions/associationproxy.html#composite-association-proxy)以获取示例。
- en: '#### Dealing with Key Mutations and back-populating for Dictionary collections'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 处理键突变和字典集合的反向填充'
- en: 'When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the “key” for the dictionary is taken
    from an attribute on the target object. **Changes to this key are not tracked**.
    This means that the key must be assigned towards when it is first used, and if
    the key changes, the collection will not be mutated. A typical example where this
    might be an issue is when relying upon backrefs to populate an attribute mapped
    collection. Given the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")时，字典的“键”来自目标对象上的属性。**对此键的更改不会被跟踪**。这意味着必须在第一次使用时分配键，并且如果键发生更改，则集合将不会突变。在依赖于反向引用来填充属性映射集合时，这可能是一个典型的问题。给定以下情况：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Above, if we create a `B()` that refers to a specific `A()`, the back populates
    will then add the `B()` to the `A.bs` collection, however if the value of `B.data`
    is not set yet, the key will be `None`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，如果我们创建一个引用特定`A()`的`B()`，那么反向填充将将`B()`添加到`A.bs`集合中，但是如果`B.data`的值尚未设置，则键将为`None`：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Setting `b1.data` after the fact does not update the collection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`b1.data`之后不会更新集合：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can also be seen if one attempts to set up `B()` in the constructor. The
    order of arguments changes the result:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在构造函数中设置`B()`，也可以看到这一点。参数顺序更改了结果：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'vs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: vs：
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If backrefs are being used in this way, ensure that attributes are populated
    in the correct order using an `__init__` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在以这种方式使用反向引用，请确保使用`__init__`方法按正确顺序填充属性。
- en: 'An event handler such as the following may also be used to track changes in
    the collection as well:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件处理程序也可以用于跟踪集合中的更改：
- en: '[PRE16]  ## Custom Collection Implementations'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]  ## 自定义集合实现'
- en: You can use your own types for collections as well. In simple cases, inheriting
    from `list` or `set`, adding custom behavior, is all that’s needed. In other cases,
    special decorators are needed to tell SQLAlchemy more detail about how the collection
    operates.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为集合使用自己的类型。在简单情况下，继承自`list`或`set`，添加自定义行为就足够了。在其他情况下，需要特殊的装饰器来告诉SQLAlchemy关于集合操作的更多详细信息。
- en: Collections in SQLAlchemy are transparently *instrumented*. Instrumentation
    means that normal operations on the collection are tracked and result in changes
    being written to the database at flush time. Additionally, collection operations
    can fire *events* which indicate some secondary operation must take place. Examples
    of a secondary operation include saving the child item in the parent’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") (i.e. the `save-update` cascade), as well as
    synchronizing the state of a bi-directional relationship (i.e. a [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的集合是透明的*instrumented*。仪器化意味着对集合的常规操作将被跟踪，并且在刷新时将更改写入数据库。此外，集合操作可以触发*事件*，这些事件表明必须进行某些次要操作。次要操作的示例包括将子项保存在父项的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session")中（即`save-update`级联），以及同步双向关系的状态（即[`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")）。
- en: 'The collections package understands the basic interface of lists, sets and
    dicts and will automatically apply instrumentation to those built-in types and
    their subclasses. Object-derived types that implement a basic collection interface
    are detected and instrumented via duck-typing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 集合包理解列表、集合和字典的基本接口，并将自动对这些内置类型及其子类应用仪表化。实现基本集合接口的对象衍生类型会通过鸭子类型检测到并进行仪表化：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`append`, `remove`, and `extend` are known members of `list`, and will be instrumented
    automatically. `__iter__` is not a mutator method and won’t be instrumented, and
    `foo` won’t be either.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`、`remove`和`extend`是`list`的已知成员，并且将自动进行仪表化。`__iter__`不是一个修改器方法，不会进行仪表化，`foo`也不会进行仪表化。'
- en: 'Duck-typing (i.e. guesswork) isn’t rock-solid, of course, so you can be explicit
    about the interface you are implementing by providing an `__emulates__` class
    attribute:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，鸭子类型（即猜测）并不是十分可靠，因此您可以通过提供`__emulates__`类属性明确地指定您要实现的接口：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This class looks similar to a Python `list` (i.e. “list-like”) as it has an
    `append` method, but the `__emulates__` attribute forces it to be treated as a
    `set`. `remove` is known to be part of the set interface and will be instrumented.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来类似于Python的`list`（即“类似列表”），因为它有一个`append`方法，但是`__emulates__`属性将其强制视为`set`。`remove`被认为是集合接口的一部分，并将被仪表化。
- en: 'But this class won’t work quite yet: a little glue is needed to adapt it for
    use by SQLAlchemy. The ORM needs to know which methods to use to append, remove
    and iterate over members of the collection. When using a type like `list` or `set`,
    the appropriate methods are well-known and used automatically when present. However
    the class above, which only roughly resembles a `set`, does not provide the expected
    `add` method, so we must indicate to the ORM the method that will instead take
    the place of the `add` method, in this case using a decorator `@collection.appender`;
    this is illustrated in the next section.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个类目前还不起作用：需要一点粘合剂来使其适应SQLAlchemy的使用。ORM需要知道使用哪些方法来附加、删除和迭代集合的成员。当使用`list`或`set`等类型时，适当的方法是众所周知的，并且在存在时会自动使用。然而，上面的类只粗略地类似于`set`，并没有提供预期的`add`方法，因此我们必须告诉ORM将代替`add`方法的方法，在本例中使用装饰器`@collection.appender`来说明这一点；这将在下一节中进行说明。
- en: Annotating Custom Collections via Decorators
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过装饰器对自定义集合进行注释
- en: Decorators can be used to tag the individual methods the ORM needs to manage
    collections. Use them when your class doesn’t quite meet the regular interface
    for its container type, or when you otherwise would like to use a different method
    to get the job done.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的类不完全符合其容器类型的常规接口时，或者当您希望以不同的方法完成工作时，可以使用装饰器标记单个方法供ORM管理集合时使用。
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And that’s all that’s needed to complete the example. SQLAlchemy will add instances
    via the `append` method. `remove` and `__iter__` are the default methods for sets
    and will be used for removing and iteration. Default methods can be changed as
    well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完成示例所需的全部内容。SQLAlchemy将通过`append`方法添加实例。`remove`和`__iter__`是集合的默认方法，并将用于删除和迭代。默认方法也可以更改：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is no requirement to be “list-like” or “set-like” at all. Collection classes
    can be any shape, so long as they have the append, remove and iterate interface
    marked for SQLAlchemy’s use. Append and remove methods will be called with a mapped
    entity as the single argument, and iterator methods are called with no arguments
    and must return an iterator.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不需要“类似列表”或“类似集合”。集合类可以是任何形状，只要它们具有由SQLAlchemy标记的附加、删除和迭代接口。附加和删除方法将以映射的实体作为单个参数调用，迭代器方法将不带参数调用，并且必须返回一个迭代器。
- en: '### Custom Dictionary-Based Collections'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义基于字典的集合'
- en: 'The [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    class can be used as a base class for your custom types or as a mix-in to quickly
    add `dict` collection support to other classes. It uses a keying function to delegate
    to `__setitem__` and `__delitem__`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")类可用作自定义类型的基类，也可以用作快速将`dict`集合支持添加到其他类的混合。它使用键函数来委托给`__setitem__`和`__delitem__`：'
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When subclassing [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict"),
    user-defined versions of `__setitem__()` or `__delitem__()` should be decorated
    with [`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented"), **if** they
    call down to those same methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict"). This because the methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") are already instrumented - calling them from within
    an already instrumented call can cause events to be fired off repeatedly, or inappropriately,
    leading to internal state corruption in rare cases:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    时，如果调用相同的方法 `__setitem__()` 或 `__delitem__()`，则用户定义的版本应当被装饰 [`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented")，**如果** 它们在 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") 上调用这些方法。因为 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") 上的方法已经被内部装饰 - 在已经被内部装饰的调用中调用它们可能会导致事件被重复触发，或不恰当地，在极少数情况下导致内部状态损坏：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The ORM understands the `dict` interface just like lists and sets, and will
    automatically instrument all “dict-like” methods if you choose to subclass `dict`
    or provide dict-like collection behavior in a duck-typed class. You must decorate
    appender and remover methods, however- there are no compatible methods in the
    basic dictionary interface for SQLAlchemy to use by default. Iteration will go
    through `values()` unless otherwise decorated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 理解 `dict` 接口就像列表和集合一样，并且如果选择子类化 `dict` 或在鸭子类型类中提供类似于 dict 的集合行为，则会自动为所有“类似于字典”的方法进行仪器化。然而，您必须装饰添加器和删除器方法-因为
    SQLAlchemy 没有默认使用的基本字典接口的兼容方法。迭代将通过 `values()` 进行，除非另有装饰。
- en: Instrumentation and Custom Types
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化和自定义类型
- en: Many custom types and existing library classes can be used as a entity collection
    type as-is without further ado. However, it is important to note that the instrumentation
    process will modify the type, adding decorators around methods automatically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自定义类型和现有库类可以直接用作实体集合类型而无需进一步操作。但是，重要的是要注意，仪器化过程将修改类型，自动在方法周围添加装饰器。
- en: 'The decorations are lightweight and no-op outside of relationships, but they
    do add unneeded overhead when triggered elsewhere. When using a library class
    as a collection, it can be good practice to use the “trivial subclass” trick to
    restrict the decorations to just your usage in relationships. For example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰很轻量级，在关系之外是无操作的，但是在其他地方触发时会增加不必要的开销。当将库类用作集合时，将装饰限制为仅在关系中使用的“简单子类”技巧是一个好习惯。例如：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The ORM uses this approach for built-ins, quietly substituting a trivial subclass
    when a `list`, `set` or `dict` is used directly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 对内置类型使用此方法，当直接使用 `list`、`set` 或 `dict` 时，会悄悄地替换为一个简单的子类。
- en: Collection API
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合 API
- en: '| Object Name | Description |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [attribute_keyed_dict](#sqlalchemy.orm.attribute_keyed_dict)(attr_name, *,
    [ignore_unpopulated_attribute]) | A dictionary-based collection type with attribute-based
    keying. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| [attribute_keyed_dict](#sqlalchemy.orm.attribute_keyed_dict)(attr_name, *,
    [ignore_unpopulated_attribute]) | 基于字典的集合类型，具有基于属性的键。 |'
- en: '| [attribute_mapped_collection](#sqlalchemy.orm.attribute_mapped_collection)
    | A dictionary-based collection type with attribute-based keying. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| [attribute_mapped_collection](#sqlalchemy.orm.attribute_mapped_collection)
    | 基于字典的集合类型，具有基于属性的键。 |'
- en: '| [column_keyed_dict](#sqlalchemy.orm.column_keyed_dict)(mapping_spec, *, [ignore_unpopulated_attribute])
    | A dictionary-based collection type with column-based keying. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| [column_keyed_dict](#sqlalchemy.orm.column_keyed_dict)(mapping_spec, *, [ignore_unpopulated_attribute])
    | 基于列的键的字典型集合类型。 |'
- en: '| [column_mapped_collection](#sqlalchemy.orm.column_mapped_collection) | A
    dictionary-based collection type with column-based keying. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| [column_mapped_collection](#sqlalchemy.orm.column_mapped_collection) | 基于列的键的字典型集合类型。
    |'
- en: '| [keyfunc_mapping](#sqlalchemy.orm.keyfunc_mapping)(keyfunc, *, [ignore_unpopulated_attribute])
    | A dictionary-based collection type with arbitrary keying. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| [keyfunc_mapping](#sqlalchemy.orm.keyfunc_mapping)(keyfunc, *, [ignore_unpopulated_attribute])
    | 基于字典的集合类型，具有任意的键。 |'
- en: '| [KeyFuncDict](#sqlalchemy.orm.KeyFuncDict) | Base for ORM mapped dictionary
    classes. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| [KeyFuncDict](#sqlalchemy.orm.KeyFuncDict) | 基于 ORM 映射字典类的基类。 |'
- en: '| [mapped_collection](#sqlalchemy.orm.mapped_collection) | A dictionary-based
    collection type with arbitrary keying. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| [mapped_collection](#sqlalchemy.orm.mapped_collection) | 基于字典的集合类型，具有任意的键。
    |'
- en: '| [MappedCollection](#sqlalchemy.orm.MappedCollection) | Base for ORM mapped
    dictionary classes. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| [MappedCollection](#sqlalchemy.orm.MappedCollection) | ORM映射字典类的基类。 |'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A dictionary-based collection type with attribute-based keying.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性键的字典类型的集合。
- en: 'Changed in version 2.0: Renamed [`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection") to [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict").'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.0 中的更改：将[`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection")重命名为[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    named attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，它将根据ORM映射实例上的特定命名属性的值生成新的字典键，以添加到字典中。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时被赋予其值。另外，**不会跟踪**键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参阅[处理键变异和反向填充字典集合](#key-collections-mutations)。
- en: See also
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`attr_name` – string name of an ORM-mapped attribute on the mapped class, the
    value of which on a particular instance is to be used as the key for a new dictionary
    entry for that instance.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr_name` - 映射类上的ORM映射属性的字符串名称，其值将在特定实例上用作新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` -'
- en: if True, and the target attribute on an object is not populated at all, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且对象上的目标属性根本未填充，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") parameter may be set which will instead
    indicate that this condition should be ignored, and the append operation silently
    skipped. This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本 2.0 中的新特性：如果确定用于字典键的属性从未填充过任何值，则默认会引发错误。可以设置[`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict")参数，该参数将指示忽略此条件，并在静默跳过附加操作。这与 1.x 系列的行为相反，后者会错误地使用任意键值`None`填充字典中的值。
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A dictionary-based collection type with column-based keying.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基于列键的字典类型的集合。
- en: 'Changed in version 2.0: Renamed [`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") to `column_keyed_dict`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.0 中的更改：将[`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection")重命名为`column_keyed_dict`。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")-mapped
    attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，它将根据ORM映射实例上的特定[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")映射属性的值生成新的字典键，以添加到字典中。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时分配其值。此外，**不会跟踪**键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参见[处理键突变和为字典集合回填](#key-collections-mutations)。
- en: See also
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`mapping_spec` – a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object that is expected to be mapped by the target
    mapper to a particular attribute on the mapped class, the value of which on a
    particular instance is to be used as the key for a new dictionary entry for that
    instance.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping_spec` - 一个预期由目标映射器映射到映射类上特定属性的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，其在特定实例上的值将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` - '
- en: if True, and the mapped attribute indicated by the given [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") target attribute on an object is not populated at
    all, the operation will be silently skipped. By default, an error is raised.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且对象上由给定[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")目标属性指示的映射属性根本未填充，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0版本中的新功能：如果确定用于字典键的属性从未填充任何值，则默认情况下会引发错误。可以设置[`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict")参数，该参数将指示应忽略此条件，并且附加操作将被静默跳过。这与1.x系列的行为相反，后者会错误地使用任意键值`None`填充字典中的值。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A dictionary-based collection type with arbitrary keying.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合类型，具有任意键。
- en: 'Changed in version 2.0: Renamed [`mapped_collection`](#sqlalchemy.orm.mapped_collection
    "sqlalchemy.orm.mapped_collection") to [`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping").'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中的更改：将[`mapped_collection`](#sqlalchemy.orm.mapped_collection "sqlalchemy.orm.mapped_collection")重命名为[`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory with a keying function generated from keyfunc, a callable that takes an
    entity and returns a key value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从keyfunc生成的键函数的[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，一个可调用对象，接受一个实体并返回一个键值。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the given keyfunc is called only once at the time that the target object is
    being added to the collection. Changes to the effective value returned by the
    function are not tracked.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的keyfunc仅在将目标对象添加到集合时调用一次。不会跟踪函数返回的有效值的更改。
- en: See also
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`keyfunc` – a callable that will be passed the ORM-mapped instance which should
    then generate a new key to use in the dictionary. If the value returned is [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), an error is raised.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyfunc` - 一个可调用对象，将传递ORM映射的实例，然后生成一个用于字典中的新键。如果返回的值是[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则会引发错误。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` - '
- en: if True, and the callable returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE") for a particular instance, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且可调用函数对特定实例返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则操作将被静默跳过。默认情况下会引发错误。
- en: 'New in version 2.0: an error is raised by default if the callable being used
    for the dictionary key returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), which in an ORM attribute context
    indicates an attribute that was never populated with any value. The [`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0版本中的新功能：如果用于字典键的可调用函数返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则默认情况下会引发错误，这在ORM属性上下文中表示从未填充任何值的属性。可以设置[`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection")参数，该参数将指示应忽略此条件，并且附加操作将被静默跳过。这与1.x系列的行为相反，后者会错误地使用任意键值`None`填充字典中的值。
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A dictionary-based collection type with attribute-based keying.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的键的字典集合类型。
- en: 'Changed in version 2.0: Renamed [`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection") to [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict").'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版本中的更改：将[`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection")重命名为[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    named attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，该工厂将根据ORM映射实例上特定命名属性的值生成新的字典键，以添加到字典中。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时分配其值。此外，**不会跟踪**键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参阅[处理键突变和为字典集合回填](#key-collections-mutations)。
- en: See also
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`attr_name` – string name of an ORM-mapped attribute on the mapped class, the
    value of which on a particular instance is to be used as the key for a new dictionary
    entry for that instance.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr_name` – 映射类上ORM映射属性的字符串名称，特定实例上的该值将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the target attribute on an object is not populated at all, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且对象上的目标属性根本未填充，则操作将被静默跳过。默认情况下会引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") parameter may be set which will instead
    indicate that this condition should be ignored, and the append operation silently
    skipped. This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版新功能：默认情况下，如果确定用于字典键的属性从未被填充任何值，则将引发错误。可以设置 [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") 参数，以指示应忽略此条件，并静默跳过追加操作。这与 1.x 系列的行为相反，后者将错误地使用任意键值
    `None` 填充字典中的值。
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A dictionary-based collection type with column-based keying.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合类型，使用列作为键。
- en: 'Changed in version 2.0: Renamed [`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") to `column_keyed_dict`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版更改：将 [`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") 重命名为 `column_keyed_dict`。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")-mapped
    attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    工厂，它将根据 ORM 映射实例上的特定 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 映射的属性的值产生新的字典键，并将其添加到字典中。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时被赋值。另外，不会**跟踪**键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。参见[处理键变化和字典集合的反填充](#key-collections-mutations)获取更多详细信息。
- en: See also
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`mapping_spec` – a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object that is expected to be mapped by the target
    mapper to a particular attribute on the mapped class, the value of which on a
    particular instance is to be used as the key for a new dictionary entry for that
    instance.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping_spec` – 一个预期由目标映射器映射到映射类上特定属性的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，其在特定实例上的值将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the mapped attribute indicated by the given [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") target attribute on an object is not populated at
    all, the operation will be silently skipped. By default, an error is raised.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为 True，并且对象上由给定 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 目标属性指示的映射属性根本未被填充，则操作将被静默跳过。默认情况下，将引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版新功能：默认情况下，如果确定用于字典键的属性从未被填充任何值，则将引发错误。可以设置 [`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") 参数，以指示应忽略此条件，并静默跳过追加操作。这与 1.x 系列的行为相反，后者将错误地使用任意键值
    `None` 填充字典中的值。
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A dictionary-based collection type with arbitrary keying.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一种基于字典的集合类型，具有任意键。
- en: 'Changed in version 2.0: Renamed [`mapped_collection`](#sqlalchemy.orm.mapped_collection
    "sqlalchemy.orm.mapped_collection") to [`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping").'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0开始更改：将[`mapped_collection`](#sqlalchemy.orm.mapped_collection "sqlalchemy.orm.mapped_collection")重命名为[`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory with a keying function generated from keyfunc, a callable that takes an
    entity and returns a key value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，其中包含从keyfunc生成的键函数，一个接受实体并返回键值的可调用对象。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the given keyfunc is called only once at the time that the target object is
    being added to the collection. Changes to the effective value returned by the
    function are not tracked.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的keyfunc仅在将目标对象添加到集合时调用一次。不会跟踪函数返回的有效值的更改。
- en: See also
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`keyfunc` – a callable that will be passed the ORM-mapped instance which should
    then generate a new key to use in the dictionary. If the value returned is [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), an error is raised.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyfunc` – 一个可调用对象，将传递给ORM映射的实例，然后生成一个新的键用于字典。如果返回的值是[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则会引发错误。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the callable returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE") for a particular instance, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且可调用对象对于特定实例返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the callable being used
    for the dictionary key returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), which in an ORM attribute context
    indicates an attribute that was never populated with any value. The [`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本2.0开始：如果用于字典键的可调用对象返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则默认情况下会引发错误，这在ORM属性上下文中表示从未用任何值填充的属性。可以设置[`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection")参数，该参数将指示应忽略此条件，并且附加操作将被静默跳过。这与1.x系列的行为相反，后者会错误地使用任意键值`None`填充字典中的值。
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Base for ORM mapped dictionary classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ORM映射字典类的基础。
- en: Extends the `dict` type with additional methods needed by SQLAlchemy ORM collection
    classes. Use of [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    is most directly by using the [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") or [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") class factories. [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") may also serve as the base for user-defined custom
    dictionary classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外方法扩展了`dict`类型，这些方法是SQLAlchemy ORM集合类所需的。最直接使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")或[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict")类工厂来使用[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")也可以作为用户定义的自定义字典类的基础。
- en: 'Changed in version 2.0: Renamed `MappedCollection` to [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict").'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.0开始更改：将`MappedCollection`重命名为[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。
- en: See also
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
- en: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
- en: '[Dictionary Collections](#orm-dictionary-collection)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection)'
- en: '[Custom Collection Implementations](#orm-custom-collection)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合实现](#orm-custom-collection)'
- en: '**Members**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.orm.KeyFuncDict.__init__), [clear()](#sqlalchemy.orm.KeyFuncDict.clear),
    [pop()](#sqlalchemy.orm.KeyFuncDict.pop), [popitem()](#sqlalchemy.orm.KeyFuncDict.popitem),
    [remove()](#sqlalchemy.orm.KeyFuncDict.remove), [set()](#sqlalchemy.orm.KeyFuncDict.set),
    [setdefault()](#sqlalchemy.orm.KeyFuncDict.setdefault), [update()](#sqlalchemy.orm.KeyFuncDict.update)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.orm.KeyFuncDict.__init__), [clear()](#sqlalchemy.orm.KeyFuncDict.clear),
    [pop()](#sqlalchemy.orm.KeyFuncDict.pop), [popitem()](#sqlalchemy.orm.KeyFuncDict.popitem),
    [remove()](#sqlalchemy.orm.KeyFuncDict.remove), [set()](#sqlalchemy.orm.KeyFuncDict.set),
    [setdefault()](#sqlalchemy.orm.KeyFuncDict.setdefault), [update()](#sqlalchemy.orm.KeyFuncDict.update)'
- en: '**Class signature**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    (`builtins.dict`, `typing.Generic`)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.orm.KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    (`builtins.dict`, `typing.Generic`)
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create a new collection with keying provided by keyfunc.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用keyfunc提供的键创建一个新的集合。
- en: keyfunc may be any callable that takes an object and returns an object for use
    as a dictionary key.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: keyfunc 可以是任何接受对象并返回用作字典键的对象的可调用对象。
- en: The keyfunc will be called every time the ORM needs to add a member by value-only
    (such as when loading instances from the database) or remove a member. The usual
    cautions about dictionary keying apply- `keyfunc(object)` should return the same
    output for the life of the collection. Keying based on mutable properties can
    result in unreachable instances “lost” in the collection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每次ORM需要按值添加成员（例如从数据库加载实例时）或移除成员时都会调用keyfunc。通常的字典键警告适用- `keyfunc(object)` 应该在集合的生命周期内返回相同的输出。基于可变属性的键可能会导致集合中“丢失”的不可达实例。
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the key is not found, return the default if given; otherwise, raise a KeyError.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到键，则返回给定的默认值；否则，引发 KeyError。
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remove and return a (key, value) pair as a 2-tuple.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 移除并返回一个（键，值）对作为2元组。
- en: Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the
    dict is empty.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对中的对以LIFO（后进先出）顺序返回。如果字典为空，则引发 KeyError。
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Remove an item by value, consulting the keyfunc for the key.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值删除项，查询keyfunc以获取键。
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add an item by value, consulting the keyfunc for the key.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值添加项，查询keyfunc以获取键。
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Insert key with a value of default if key is not in the dictionary.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不在字典中，则将键插入并将默认值设置为默认值。
- en: Return the value for key if key is in the dictionary, else default.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中，则返回键的值，否则返回默认值。
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v
    In either case, this is followed by: for k in F: D[k] = F[k]'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 E 存在并且具有 .keys() 方法，则执行以下操作：for k in E: D[k] = E[k] 如果 E 存在并且缺少 .keys()
    方法，则执行以下操作：for k, v in E: D[k] = v 在任一情况下，这之后都会执行：for k in F: D[k] = F[k]'
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Base for ORM mapped dictionary classes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ORM映射字典类的基础。
- en: Extends the `dict` type with additional methods needed by SQLAlchemy ORM collection
    classes. Use of [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    is most directly by using the [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") or [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") class factories. [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") may also serve as the base for user-defined custom
    dictionary classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展了 `dict` 类型，提供了SQLAlchemy ORM集合类所需的附加方法。最直接使用 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 或 [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") 类工厂创建 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    也可以作为用户定义的自定义字典类的基类。
- en: 'Changed in version 2.0: Renamed `MappedCollection` to [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict").'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本中更改：将 `MappedCollection` 重命名为 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。
- en: See also
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
- en: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
- en: '[Dictionary Collections](#orm-dictionary-collection)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection)'
- en: '[Custom Collection Implementations](#orm-custom-collection)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合实现](#orm-custom-collection)'
- en: Collection Internals
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合内部
- en: '| Object Name | Description |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [bulk_replace](#sqlalchemy.orm.collections.bulk_replace)(values, existing_adapter,
    new_adapter[, initiator]) | Load a new collection, firing events based on prior
    like membership. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| [bulk_replace](#sqlalchemy.orm.collections.bulk_replace)(values, existing_adapter,
    new_adapter[, initiator]) | 加载一个新的集合，根据先前的成员关系触发事件。'
- en: '| [collection](#sqlalchemy.orm.collections.collection) | Decorators for entity
    collection classes. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| [collection](#sqlalchemy.orm.collections.collection) | 实体集合类的装饰器。 |'
- en: '| [collection_adapter](#sqlalchemy.orm.collections.collection_adapter) | attrgetter(attr,
    …) –> attrgetter object |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| [collection_adapter](#sqlalchemy.orm.collections.collection_adapter) | attrgetter(attr,
    …) –> attrgetter 对象 |'
- en: '| [CollectionAdapter](#sqlalchemy.orm.collections.CollectionAdapter) | Bridges
    between the ORM and arbitrary Python collections. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| [CollectionAdapter](#sqlalchemy.orm.collections.CollectionAdapter) | ORM和任意Python集合之间的桥梁。
    |'
- en: '| [InstrumentedDict](#sqlalchemy.orm.collections.InstrumentedDict) | An instrumented
    version of the built-in dict. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedDict](#sqlalchemy.orm.collections.InstrumentedDict) | 内置字典的受控版本。
    |'
- en: '| [InstrumentedList](#sqlalchemy.orm.collections.InstrumentedList) | An instrumented
    version of the built-in list. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedList](#sqlalchemy.orm.collections.InstrumentedList) | 内置列表的受控版本。
    |'
- en: '| [InstrumentedSet](#sqlalchemy.orm.collections.InstrumentedSet) | An instrumented
    version of the built-in set. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedSet](#sqlalchemy.orm.collections.InstrumentedSet) | 内置集合的受控版本。
    |'
- en: '| [prepare_instrumentation](#sqlalchemy.orm.collections.prepare_instrumentation)(factory)
    | Prepare a callable for future use as a collection class factory. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| [prepare_instrumentation](#sqlalchemy.orm.collections.prepare_instrumentation)(factory)
    | 为将来用作集合类工厂的可调用对象做准备。 |'
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Load a new collection, firing events based on prior like membership.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 加载一个新的集合，根据先前的成员关系触发事件。
- en: Appends instances in `values` onto the `new_adapter`. Events will be fired for
    any instance not present in the `existing_adapter`. Any instances in `existing_adapter`
    not present in `values` will have remove events fired upon them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将`values`中的实例附加到`new_adapter`。对于`existing_adapter`中不存在的任何实例，将触发事件。对于`existing_adapter`中存在但在`values`中不存在的任何实例，将触发删除事件。
- en: 'Parameters:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`values` – An iterable of collection member instances'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values` – 一个集合成员实例的可迭代对象'
- en: '`existing_adapter` – A [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") of instances to be replaced'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`existing_adapter` – 要替换的实例的[`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter")'
- en: '`new_adapter` – An empty [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") to load with `values`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_adapter` – 一个空的[`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter")，用于加载`values`'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Decorators for entity collection classes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实体集合类的装饰器。
- en: 'The decorators fall into two groups: annotations and interception recipes.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器分为两组：注释和拦截配方。
- en: 'The annotating decorators (appender, remover, iterator, converter, internally_instrumented)
    indicate the method’s purpose and take no arguments. They are not written with
    parens:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 标注装饰器（appender, remover, iterator, converter, internally_instrumented）指示方法的目的，并且不接受任何参数。它们不带括号：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The recipe decorators all require parens, even those that take no arguments:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配方装饰器都需要括号，即使没有参数：
- en: '**Members**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[adds()](#sqlalchemy.orm.collections.collection.adds), [appender()](#sqlalchemy.orm.collections.collection.appender),
    [converter()](#sqlalchemy.orm.collections.collection.converter), [internally_instrumented()](#sqlalchemy.orm.collections.collection.internally_instrumented),
    [iterator()](#sqlalchemy.orm.collections.collection.iterator), [remover()](#sqlalchemy.orm.collections.collection.remover),
    [removes()](#sqlalchemy.orm.collections.collection.removes), [removes_return()](#sqlalchemy.orm.collections.collection.removes_return),
    [replaces()](#sqlalchemy.orm.collections.collection.replaces)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[adds()](#sqlalchemy.orm.collections.collection.adds), [appender()](#sqlalchemy.orm.collections.collection.appender),
    [converter()](#sqlalchemy.orm.collections.collection.converter), [internally_instrumented()](#sqlalchemy.orm.collections.collection.internally_instrumented),
    [iterator()](#sqlalchemy.orm.collections.collection.iterator), [remover()](#sqlalchemy.orm.collections.collection.remover),
    [removes()](#sqlalchemy.orm.collections.collection.removes), [removes_return()](#sqlalchemy.orm.collections.collection.removes_return),
    [replaces()](#sqlalchemy.orm.collections.collection.replaces)'
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Mark the method as adding an entity to the collection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为向集合添加实体。
- en: 'Adds “add to collection” handling to the method. The decorator argument indicates
    which method argument holds the SQLAlchemy-relevant value. Arguments can be specified
    positionally (i.e. integer) or by name:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将“添加到集合”处理添加到方法中。装饰器参数指示哪个方法参数保存着与 SQLAlchemy 相关的值。参数可以通过位置指定（即整数），也可以通过名称指定：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tag the method as the collection appender.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合附加器。
- en: 'The appender method is called with one positional argument: the value to append.
    The method will be automatically decorated with ‘adds(1)’ if not already decorated:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 appender 方法时，将使用一个位置参数：要附加的值。如果尚未装饰该方法，将自动用 'adds(1)' 装饰该方法：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the value to append is not allowed in the collection, you may raise an exception.
    Something to remember is that the appender will be called for each object mapped
    by a database query. If the database contains rows that violate your collection
    semantics, you will need to get creative to fix the problem, as access via the
    collection will not work.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要附加的值不允许在集合中，您可以引发异常。需要记住的一件事是，对于由数据库查询映射的每个对象，都会调用 appender。如果数据库包含违反集合语义的行，则需要有创造性地解决问题，因为通过集合访问将无法正常工作。
- en: If the appender method is internally instrumented, you must also receive the
    keyword argument ‘_sa_initiator’ and ensure its promulgation to collection events.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 appender 方法在内部被仪器化，则还必须接收关键字参数 ‘_sa_initiator’ 并确保其在集合事件中的传播。
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tag the method as the collection converter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合转换器。
- en: 'Deprecated since version 1.3: The [`collection.converter()`](#sqlalchemy.orm.collections.collection.converter
    "sqlalchemy.orm.collections.collection.converter") handler is deprecated and will
    be removed in a future release. Please refer to the `bulk_replace` listener interface
    in conjunction with the [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") function.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3 起弃用：[`collection.converter()`](#sqlalchemy.orm.collections.collection.converter
    "sqlalchemy.orm.collections.collection.converter") 处理程序已弃用，并将在将来的版本中删除。请参考 [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") 函数结合 `bulk_replace` 监听器接口。
- en: 'This optional method will be called when a collection is being replaced entirely,
    as in:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当要完全替换集合时，将调用此可选方法，例如：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The converter method will receive the object being assigned and should return
    an iterable of values suitable for use by the `appender` method. A converter must
    not assign values or mutate the collection, its sole job is to adapt the value
    the user provides into an iterable of values for the ORM’s use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器方法将接收到被分配的对象，并应返回适用于 `appender` 方法使用的值的可迭代对象。转换器不能分配值或改变集合，它的唯一工作是将用户提供的值适应为
    ORM 使用的值的可迭代对象。
- en: 'The default converter implementation will use duck-typing to do the conversion.
    A dict-like collection will be convert into an iterable of dictionary values,
    and other types will simply be iterated:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的转换器实现将使用鸭子类型进行转换。类似字典的集合将转换为字典值的可迭代对象，而其他类型将简单地进行迭代：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If the duck-typing of the object does not match the type of this collection,
    a TypeError is raised.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的鸭子类型与此集合的类型不匹配，则会引发 TypeError。
- en: Supply an implementation of this method if you want to expand the range of possible
    types that can be assigned in bulk or perform validation on the values about to
    be assigned.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要扩展可以批量分配的可能类型的范围，或者对即将被分配的值执行验证，请提供此方法的实现。
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tag the method as instrumented.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为受仪器控制的。
- en: 'This tag will prevent any decoration from being applied to the method. Use
    this if you are orchestrating your own calls to `collection_adapter()` in one
    of the basic SQLAlchemy interface methods, or to prevent an automatic ABC method
    decoration from wrapping your implementation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记将阻止对该方法应用任何装饰。如果您正在编排自己对 `collection_adapter()` 的调用，并且在基本 SQLAlchemy 接口方法中的一个方法中，或者防止自动
    ABC 方法装饰包装您的实现，请使用此标记：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tag the method as the collection remover.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合移除器。
- en: 'The iterator method is called with no arguments. It is expected to return an
    iterator over all collection members:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 iterator 方法时不使用参数。预期它将返回所有集合成员的迭代器：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tag the method as the collection remover.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合移除器。
- en: 'The remover method is called with one positional argument: the value to remove.
    The method will be automatically decorated with [`removes_return()`](#sqlalchemy.orm.collections.collection.removes_return
    "sqlalchemy.orm.collections.collection.removes_return") if not already decorated:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`remover` 方法接受一个位置参数：要移除的值。如果方法尚未装饰，则会自动装饰为 [`removes_return()`](#sqlalchemy.orm.collections.collection.removes_return
    "sqlalchemy.orm.collections.collection.removes_return")：'
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the value to remove is not present in the collection, you may raise an exception
    or return None to ignore the error.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要移除的值在集合中不存在，则可以引发异常或返回 None 以忽略错误。
- en: If the remove method is internally instrumented, you must also receive the keyword
    argument ‘_sa_initiator’ and ensure its promulgation to collection events.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 remove 方法在内部被检测，则还必须接收关键字参数 ‘_sa_initiator’ 并确保其传播到集合事件。
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Mark the method as removing an entity in the collection.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为从集合中移除实体。
- en: 'Adds “remove from collection” handling to the method. The decorator argument
    indicates which method argument holds the SQLAlchemy-relevant value to be removed.
    Arguments can be specified positionally (i.e. integer) or by name:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将“从集合中移除”处理添加到方法中。装饰器参数指示哪个方法参数保存了要从 SQLAlchemy 中移除的值。参数可以通过位置（即整数）或名称指定：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For methods where the value to remove is not known at call-time, use collection.removes_return.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在调用时不知道要移除的值的方法，请使用 `collection.removes_return`。
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Mark the method as removing an entity in the collection.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为从集合中移除实体。
- en: 'Adds “remove from collection” handling to the method. The return value of the
    method, if any, is considered the value to remove. The method arguments are not
    inspected:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将“从集合中移除”处理添加到方法中。如果有，则方法的返回值将被视为要移除的值。不会检查方法参数：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For methods where the value to remove is known at call-time, use collection.remove.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在调用时知道要移除的值的方法，请使用 `collection.remove`。
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Mark the method as replacing an entity in the collection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为替换集合中的实体。
- en: Adds “add to collection” and “remove from collection” handling to the method.
    The decorator argument indicates which method argument holds the SQLAlchemy-relevant
    value to be added, and return value, if any will be considered the value to remove.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将“添加到集合中”和“从集合中移除”处理添加到方法中。装饰器参数指示哪个方法参数保存了要添加到 SQLAlchemy 中的值，如果有，则返回值将被视为要移除的值。
- en: 'Arguments can be specified positionally (i.e. integer) or by name:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过位置（即整数）或名称指定：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: attrgetter(attr, …) –> attrgetter object
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrgetter(attr, …)` –> `attrgetter` 对象'
- en: Return a callable object that fetches the given attribute(s) from its operand.
    After f = attrgetter(‘name’), the call f(r) returns r.name. After g = attrgetter(‘name’,
    ‘date’), the call g(r) returns (r.name, r.date). After h = attrgetter(‘name.first’,
    ‘name.last’), the call h(r) returns (r.name.first, r.name.last).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可调用对象，它从其操作数中获取给定属性。执行 `f = attrgetter('name')` 后，调用 `f(r)` 返回 `r.name`。执行
    `g = attrgetter('name', 'date')` 后，调用 `g(r)` 返回 `(r.name, r.date)`。执行 `h = attrgetter('name.first',
    'name.last')` 后，调用 `h(r)` 返回 `(r.name.first, r.name.last)`。
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Bridges between the ORM and arbitrary Python collections.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 和任意 Python 集合之间架设桥梁。
- en: Proxies base-level collection operations (append, remove, iterate) to the underlying
    Python collection, and emits add/remove events for entities entering or leaving
    the collection.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将基本级别的集合操作（追加、移除、迭代）代理到底层的 Python 集合，并为进入或离开集合的实体发出添加/移除事件。
- en: The ORM uses [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") exclusively for interaction with
    entity collections.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 专门使用 [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") 与实体集合交互。
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: An instrumented version of the built-in dict.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 内置字典的受检测版本。
- en: '**Class signature**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedDict`](#sqlalchemy.orm.collections.InstrumentedDict
    "sqlalchemy.orm.collections.InstrumentedDict") (`builtins.dict`, `typing.Generic`)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.orm.collections.InstrumentedDict`](#sqlalchemy.orm.collections.InstrumentedDict
    "sqlalchemy.orm.collections.InstrumentedDict") 类（`builtins.dict`, `typing.Generic`）'
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: An instrumented version of the built-in list.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 内置列表的受检测版本。
- en: '**Class signature**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedList`](#sqlalchemy.orm.collections.InstrumentedList
    "sqlalchemy.orm.collections.InstrumentedList") (`builtins.list`, `typing.Generic`)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.orm.collections.InstrumentedList`](#sqlalchemy.orm.collections.InstrumentedList
    "sqlalchemy.orm.collections.InstrumentedList") 类（`builtins.list`, `typing.Generic`）'
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: An instrumented version of the built-in set.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 内置集合的受检测版本。
- en: '**Class signature**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedSet`](#sqlalchemy.orm.collections.InstrumentedSet
    "sqlalchemy.orm.collections.InstrumentedSet") (`builtins.set`, `typing.Generic`)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.orm.collections.InstrumentedSet`](#sqlalchemy.orm.collections.InstrumentedSet
    "sqlalchemy.orm.collections.InstrumentedSet") (`builtins.set`, `typing.Generic`)
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Prepare a callable for future use as a collection class factory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个可调用对象，以便将来用作集合类工厂。
- en: Given a collection class factory (either a type or no-arg callable), return
    another factory that will produce compatible instances when called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个集合类工厂（类型或无参数可调用对象），返回另一个工厂，当调用时将产生兼容的实例。
- en: This function is responsible for converting collection_class=list into the run-time
    behavior of collection_class=InstrumentedList.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责将 collection_class=list 转换为 collection_class=InstrumentedList 的运行时行为。
- en: '## Customizing Collection Access'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '## 自定义集合访问'
- en: 'Mapping a one-to-many or many-to-many relationship results in a collection
    of values accessible through an attribute on the parent instance. The two common
    collection types for these are `list` and `set`, which in [Declarative](declarative_styles.html)
    mappings that use [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    is established by using the collection type within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") container, as demonstrated in the `Parent.children` collection
    below where `list` is used:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 映射一对多或多对多的关系会导致通过父实例上的属性访问的值集合。这两种常见的集合类型是 `list` 和 `set`，在使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的 [声明](declarative_styles.html) 映射中，通过在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 容器内使用集合类型来建立，如下面 `Parent.children` 集合中所示，其中使用了 `list`：
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Or for a `set`, illustrated in the same `Parent.children` collection:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于 `set`，在同样的 `Parent.children` 集合中示例：
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If using Python 3.7 or 3.8, annotations for collections need to use `typing.List`
    or `typing.Set`, e.g. `Mapped[List["Child"]]` or `Mapped[Set["Child"]]`; the `list`
    and `set` Python built-ins don’t yet support generic annotation in these Python
    versions, such as:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Python 3.7 或 3.8，集合的注释需要使用 `typing.List` 或 `typing.Set`，例如 `Mapped[List["Child"]]`
    或 `Mapped[Set["Child"]]`；在这些 Python 版本中，`list` 和 `set` 内置的 Python 不支持泛型注释，例如：
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When using mappings without the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation, such as when using [imperative mappings](mapping_styles.html#orm-imperative-mapping)
    or untyped Python code, as well as in a few special cases, the collection class
    for a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    can always be specified directly using the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注解的映射中，比如在使用 [命令式映射](mapping_styles.html#orm-imperative-mapping) 或未类型化的 Python
    代码时，以及在一些特殊情况下，总是可以直接指定 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的集合类，使用 [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") 参数：
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the absence of [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") or [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the default collection type is `list`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在缺少 [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") 或 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的情况下，默认的集合类型是 `list`。
- en: Beyond `list` and `set` builtins, there is also support for two varieties of
    dictionary, described below at [Dictionary Collections](#orm-dictionary-collection).
    There is also support for any arbitrary mutable sequence type can be set up as
    the target collection, with some additional configuration steps; this is described
    in the section [Custom Collection Implementations](#orm-custom-collection).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的 `list` 和 `set` 外，还支持两种字典的变体，下面在 [字典集合](#orm-dictionary-collection) 中描述。还支持将任何任意可变序列类型设置为目标集合，只需进行一些额外的配置步骤；这在
    [自定义集合实现](#orm-custom-collection) 部分有描述。
- en: '### Dictionary Collections'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '### 字典集合'
- en: 'A little extra detail is needed when using a dictionary as a collection. This
    because objects are always loaded from the database as lists, and a key-generation
    strategy must be available to populate the dictionary correctly. The [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") function is by far the most common way
    to achieve a simple dictionary collection. It produces a dictionary class that
    will apply a particular attribute of the mapped class as a key. Below we map an
    `Item` class containing a dictionary of `Note` items keyed to the `Note.keyword`
    attribute. When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be typed using the [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") or just plain `dict` as illustrated in the following
    example. However, the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter is required in this case so that the
    [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    may be appropriately parametrized:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典作为集合时需要一些额外的细节。这是因为对象总是以列表形式从数据库加载的，必须提供一种键生成策略以正确地填充字典。[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 函数是实现简单字典集合的最常见方式。它生成一个字典类，将映射类的特定属性应用为键。在下面的示例中，我们映射了一个包含以
    `Note.keyword` 属性为键的 `Note` 项字典的 `Item` 类。当使用 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 时，可能会使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 注释使用 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    或普通的 `dict`，如下例所示。但是，在这种情况下，必须使用 [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") 参数，以便适当地参数化 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")：
- en: '[PRE73]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`Item.notes` is then a dictionary:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item.notes` 现在是一个字典：'
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    will ensure that the `.keyword` attribute of each `Note` complies with the key
    in the dictionary. Such as, when assigning to `Item.notes`, the dictionary key
    we supply must match that of the actual `Note` object:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    会确保每个 `Note` 的 `.keyword` 属性与字典中的键一致。例如，当分配给 `Item.notes` 时，我们提供的字典键必须与实际 `Note`
    对象的键匹配：'
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The attribute which [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") uses as a key does not need to be mapped
    at all! Using a regular Python `@property` allows virtually any detail or combination
    of details about the object to be used as the key, as below when we establish
    it as a tuple of `Note.keyword` and the first ten letters of the `Note.text` field:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    用作键的属性根本不需要被映射！使用普通的 Python `@property` 允许几乎任何关于对象的细节或组合细节被用作键，就像下面我们将其建立为 `Note.keyword`
    和 `Note.text` 字段的前十个字母的元组时那样：'
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Above we added a `Note.item` relationship, with a bi-directional [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") configuration. Assigning to this reverse relationship,
    the `Note` is added to the `Item.notes` dictionary and the key is generated for
    us automatically:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们添加了一个 `Note.item` 关系，具有双向的 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 配置。将 `Note` 分配给这个反向关系时，`Note` 被添加到 `Item.notes`
    字典中，键会自动为我们生成：
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Other built-in dictionary types include [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict"), which is almost like [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") except given the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内置字典类型包括 [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")，它几乎和
    [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    类似，除了直接给出 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象之外：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'as well as `mapped_collection()` which is passed any callable function. Note
    that it’s usually easier to use [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") along with a `@property` as mentioned earlier:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以及传递任何可调用函数的 `mapped_collection()`。请注意，通常更容易使用 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 以及前面提到的 `@property`：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Dictionary mappings are often combined with the “Association Proxy” extension
    to produce streamlined dictionary views. See [Proxying to Dictionary Based Collections](extensions/associationproxy.html#proxying-dictionaries)
    and [Composite Association Proxies](extensions/associationproxy.html#composite-association-proxy)
    for examples.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 字典映射通常与“Association Proxy”扩展结合使用以生成简化的字典视图。有关示例，请参见[代理到基于字典的集合](extensions/associationproxy.html#proxying-dictionaries)
    和 [复合关联代理](extensions/associationproxy.html#composite-association-proxy)。
- en: '#### Dealing with Key Mutations and back-populating for Dictionary collections'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 处理键的突变和字典集合的反向填充'
- en: 'When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the “key” for the dictionary is taken
    from an attribute on the target object. **Changes to this key are not tracked**.
    This means that the key must be assigned towards when it is first used, and if
    the key changes, the collection will not be mutated. A typical example where this
    might be an issue is when relying upon backrefs to populate an attribute mapped
    collection. Given the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    时，字典的“键”来自目标对象上的属性。**不会跟踪此键的更改**。这意味着必须在首次使用时分配键，如果键更改，则集合将不会发生变化。可能出现问题的典型示例是依赖
    backrefs 填充属性映射集合。给定以下情况：
- en: '[PRE80]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Above, if we create a `B()` that refers to a specific `A()`, the back populates
    will then add the `B()` to the `A.bs` collection, however if the value of `B.data`
    is not set yet, the key will be `None`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个引用特定 `A()` 的 `B()`，那么 back populates 将把 `B()` 添加到 `A.bs` 集合中，但是如果 `B.data`
    的值尚未设置，则键将为 `None`：
- en: '[PRE81]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Setting `b1.data` after the fact does not update the collection:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 事后设置 `b1.data` 并不会更新集合：
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This can also be seen if one attempts to set up `B()` in the constructor. The
    order of arguments changes the result:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在构造函数中设置 `B()`，也会出现这种情况。参数的顺序改变了结果：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'vs:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对比：
- en: '[PRE84]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If backrefs are being used in this way, ensure that attributes are populated
    in the correct order using an `__init__` method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 backrefs 被这样使用，请确保使用 `__init__` 方法按正确顺序填充属性。
- en: 'An event handler such as the following may also be used to track changes in
    the collection as well:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序可以用来跟踪集合中的更改，例如以下示例：
- en: '[PRE85]  ### Dictionary Collections'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE85]  ### 字典集合'
- en: 'A little extra detail is needed when using a dictionary as a collection. This
    because objects are always loaded from the database as lists, and a key-generation
    strategy must be available to populate the dictionary correctly. The [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") function is by far the most common way
    to achieve a simple dictionary collection. It produces a dictionary class that
    will apply a particular attribute of the mapped class as a key. Below we map an
    `Item` class containing a dictionary of `Note` items keyed to the `Note.keyword`
    attribute. When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation may be typed using the [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") or just plain `dict` as illustrated in the following
    example. However, the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter is required in this case so that the
    [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    may be appropriately parametrized:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典作为集合时需要一些额外的细节。这是因为对象总是以列表形式从数据库加载，必须提供一种键生成策略来正确填充字典。[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 函数是实现简单字典集合的最常见方式。它生成一个字典类，该类将应用映射类的特定属性作为键。下面我们映射了一个包含以`Note.keyword`属性为键的`Note`项目字典的`Item`类。在使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")时，可以使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释使用[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")或普通的`dict`，如下例所示。然而，在这种情况下，必须使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数，以便适当地对[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")进行参数化：
- en: '[PRE86]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`Item.notes` is then a dictionary:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Item.notes`是一个字典：
- en: '[PRE87]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    will ensure that the `.keyword` attribute of each `Note` complies with the key
    in the dictionary. Such as, when assigning to `Item.notes`, the dictionary key
    we supply must match that of the actual `Note` object:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")
    将确保每个 `Note` 的 `.keyword` 属性与字典中的键相符合。例如，当分配给 `Item.notes` 时，我们提供的字典键必须与实际 `Note`
    对象的键相匹配：'
- en: '[PRE88]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The attribute which [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") uses as a key does not need to be mapped
    at all! Using a regular Python `@property` allows virtually any detail or combination
    of details about the object to be used as the key, as below when we establish
    it as a tuple of `Note.keyword` and the first ten letters of the `Note.text` field:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")用作键的属性根本不需要被映射！使用普通的
    Python `@property` 允许使用对象的几乎任何细节或细节组合作为键，如下所示，当我们将其建立为 `Note.keyword` 的元组和 `Note.text`
    字段的前十个字母时：'
- en: '[PRE89]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Above we added a `Note.item` relationship, with a bi-directional [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") configuration. Assigning to this reverse relationship,
    the `Note` is added to the `Item.notes` dictionary and the key is generated for
    us automatically:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我们添加了一个具有双向 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 配置的 `Note.item` 关系。给这个反向关系赋值时，`Note` 被添加到 `Item.notes`
    字典中，并且键会自动生成：
- en: '[PRE90]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Other built-in dictionary types include [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict"), which is almost like [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") except given the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内置的字典类型包括 [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")，它几乎类似于
    [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")，只是直接给出了
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象：
- en: '[PRE91]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'as well as `mapped_collection()` which is passed any callable function. Note
    that it’s usually easier to use [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") along with a `@property` as mentioned earlier:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`mapped_collection()`，它将传递任何可调用函数。请注意，通常最好与前面提到的`@property`一起使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")更容易：
- en: '[PRE92]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Dictionary mappings are often combined with the “Association Proxy” extension
    to produce streamlined dictionary views. See [Proxying to Dictionary Based Collections](extensions/associationproxy.html#proxying-dictionaries)
    and [Composite Association Proxies](extensions/associationproxy.html#composite-association-proxy)
    for examples.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 字典映射经常与“关联代理”扩展组合以产生流畅的字典视图。参见[基于字典的集合的代理](extensions/associationproxy.html#proxying-dictionaries)和[复合关联代理](extensions/associationproxy.html#composite-association-proxy)以获取示例。
- en: '#### Dealing with Key Mutations and back-populating for Dictionary collections'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 处理键变化和字典集合的反向填充'
- en: 'When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the “key” for the dictionary is taken
    from an attribute on the target object. **Changes to this key are not tracked**.
    This means that the key must be assigned towards when it is first used, and if
    the key changes, the collection will not be mutated. A typical example where this
    might be an issue is when relying upon backrefs to populate an attribute mapped
    collection. Given the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")时，字典的“键”来自目标对象上的属性。**对此键的更改不会被跟踪**。这意味着键必须在首次使用时被分配，并且如果键发生更改，则集合将不会发生变化。一个典型的例子是当依赖反向引用来填充属性映射集合时可能会出现问题。给定以下内容：
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Above, if we create a `B()` that refers to a specific `A()`, the back populates
    will then add the `B()` to the `A.bs` collection, however if the value of `B.data`
    is not set yet, the key will be `None`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建引用特定`A()`的`B()`，那么反向填充将把`B()`添加到`A.bs`集合中，但是如果`B.data`的值尚未设置，则键将为`None`：
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Setting `b1.data` after the fact does not update the collection:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在事后设置`b1.data`不会更新集合：
- en: '[PRE95]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This can also be seen if one attempts to set up `B()` in the constructor. The
    order of arguments changes the result:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在构造函数中设置 `B()`，也可以看到这一点。参数的顺序会改变结果：
- en: '[PRE96]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'vs:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对比：
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: If backrefs are being used in this way, ensure that attributes are populated
    in the correct order using an `__init__` method.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以这种方式使用反向引用，请确保使用`__init__`方法以正确的顺序填充属性。
- en: 'An event handler such as the following may also be used to track changes in
    the collection as well:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用以下事件处理程序来跟踪集合中的更改：
- en: '[PRE98]  #### Dealing with Key Mutations and back-populating for Dictionary
    collections'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE98] #### 处理键变化和字典集合的反向填充'
- en: 'When using [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict"), the “key” for the dictionary is taken
    from an attribute on the target object. **Changes to this key are not tracked**.
    This means that the key must be assigned towards when it is first used, and if
    the key changes, the collection will not be mutated. A typical example where this
    might be an issue is when relying upon backrefs to populate an attribute mapped
    collection. Given the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")时，字典的“键”来自目标对象上的属性。**对此键的更改不会被跟踪**。这意味着键必须在首次使用时被分配，并且如果键发生更改，则集合将不会发生变化。一个典型的例子是当依赖反向引用来填充属性映射集合时可能会出现问题。给定以下内容：
- en: '[PRE99]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Above, if we create a `B()` that refers to a specific `A()`, the back populates
    will then add the `B()` to the `A.bs` collection, however if the value of `B.data`
    is not set yet, the key will be `None`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建引用特定`A()`的`B()`，那么反向填充将把`B()`添加到`A.bs`集合中，但是如果`B.data`的值尚未设置，则键将为`None`：
- en: '[PRE100]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Setting `b1.data` after the fact does not update the collection:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在事后设置`b1.data`不会更新集合：
- en: '[PRE101]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This can also be seen if one attempts to set up `B()` in the constructor. The
    order of arguments changes the result:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在构造函数中设置 `B()`，也可以看到这一点。参数的顺序会改变结果：
- en: '[PRE102]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'vs:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对比：
- en: '[PRE103]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: If backrefs are being used in this way, ensure that attributes are populated
    in the correct order using an `__init__` method.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以这种方式使用反向引用，请确保使用`__init__`方法以正确的顺序填充属性。
- en: 'An event handler such as the following may also be used to track changes in
    the collection as well:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用以下事件处理程序来跟踪集合中的更改：
- en: '[PRE104]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '## Custom Collection Implementations'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '## 自定义集合实现'
- en: You can use your own types for collections as well. In simple cases, inheriting
    from `list` or `set`, adding custom behavior, is all that’s needed. In other cases,
    special decorators are needed to tell SQLAlchemy more detail about how the collection
    operates.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为集合使用自己的类型。在简单情况下，继承自 `list` 或 `set`，添加自定义行为即可。在其他情况下，需要特殊的装饰器来告诉 SQLAlchemy
    关于集合操作的更多细节。
- en: Collections in SQLAlchemy are transparently *instrumented*. Instrumentation
    means that normal operations on the collection are tracked and result in changes
    being written to the database at flush time. Additionally, collection operations
    can fire *events* which indicate some secondary operation must take place. Examples
    of a secondary operation include saving the child item in the parent’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") (i.e. the `save-update` cascade), as well as
    synchronizing the state of a bi-directional relationship (i.e. a [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 中的集合是**透明的** *instrumented*。仪器化意味着对集合的常规操作将被跟踪，并在刷新时写入数据库中。此外，集合操作可以触发
    *事件*，指示必须进行某些次要操作。次要操作的示例包括在父项的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session")（即 `save-update` 级联）中保存子项，以及同步双向关系的状态（即 [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")）。
- en: 'The collections package understands the basic interface of lists, sets and
    dicts and will automatically apply instrumentation to those built-in types and
    their subclasses. Object-derived types that implement a basic collection interface
    are detected and instrumented via duck-typing:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 集合包理解列表、集合和字典的基本接口，并将自动将仪器应用于这些内置类型及其子类。通过鸭子类型检测实现基本集合接口的对象派生类型，以进行仪器化：
- en: '[PRE105]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`append`, `remove`, and `extend` are known members of `list`, and will be instrumented
    automatically. `__iter__` is not a mutator method and won’t be instrumented, and
    `foo` won’t be either.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`、`remove` 和 `extend` 是 `list` 的已知成员，并将自动进行仪器化。`__iter__` 不是一个修改器方法，不会被仪器化，`foo`
    也不会被仪器化。'
- en: 'Duck-typing (i.e. guesswork) isn’t rock-solid, of course, so you can be explicit
    about the interface you are implementing by providing an `__emulates__` class
    attribute:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，鸭子类型（即猜测）并不是百分之百可靠的，所以您可以通过提供一个 `__emulates__` 类属性来明确您正在实现的接口：
- en: '[PRE106]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This class looks similar to a Python `list` (i.e. “list-like”) as it has an
    `append` method, but the `__emulates__` attribute forces it to be treated as a
    `set`. `remove` is known to be part of the set interface and will be instrumented.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此类似于 Python `list`（即 “类似列表”），因为它有一个 `append` 方法，但 `__emulates__` 属性强制将其视为 `set`。
    `remove` 已知是集合接口的一部分，并将被仪器化。
- en: 'But this class won’t work quite yet: a little glue is needed to adapt it for
    use by SQLAlchemy. The ORM needs to know which methods to use to append, remove
    and iterate over members of the collection. When using a type like `list` or `set`,
    the appropriate methods are well-known and used automatically when present. However
    the class above, which only roughly resembles a `set`, does not provide the expected
    `add` method, so we must indicate to the ORM the method that will instead take
    the place of the `add` method, in this case using a decorator `@collection.appender`;
    this is illustrated in the next section.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，此类暂时无法正常工作：需要一点粘合剂来使其适应 SQLAlchemy 的使用。ORM 需要知道用于附加、删除和迭代集合成员的方法。当使用类似于 `list`
    或 `set` 的类型时，当存在时，适当的方法是众所周知的并且会自动使用。然而，上面的类，虽然只大致类似于 `set`，但并未提供预期的 `add` 方法，因此我们必须告诉
    ORM 替代 `add` 方法的方法，在这种情况下使用装饰器 `@collection.appender`；这在下一节中进行了说明。
- en: Annotating Custom Collections via Decorators
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过装饰器注释自定义集合
- en: Decorators can be used to tag the individual methods the ORM needs to manage
    collections. Use them when your class doesn’t quite meet the regular interface
    for its container type, or when you otherwise would like to use a different method
    to get the job done.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的类不完全符合其容器类型的常规接口时，或者您希望以其他方式使用不同的方法来完成工作时，可以使用装饰器标记 ORM 需要管理集合的各个方法。
- en: '[PRE107]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'And that’s all that’s needed to complete the example. SQLAlchemy will add instances
    via the `append` method. `remove` and `__iter__` are the default methods for sets
    and will be used for removing and iteration. Default methods can be changed as
    well:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 而这就是完成示例所需的全部。SQLAlchemy 将通过`append`方法添加实例。`remove`和`__iter__`是集合的默认方法，将用于移除和迭代。默认方法也可以更改：
- en: '[PRE108]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: There is no requirement to be “list-like” or “set-like” at all. Collection classes
    can be any shape, so long as they have the append, remove and iterate interface
    marked for SQLAlchemy’s use. Append and remove methods will be called with a mapped
    entity as the single argument, and iterator methods are called with no arguments
    and must return an iterator.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不需要“类似于列表”或“类似于集合”。集合类可以是任何形状，只要它们有被标记为 SQLAlchemy 使用的 append、remove 和 iterate
    接口。append 和 remove 方法将以映射实体作为唯一参数调用，迭代器方法将以无参数调用，并且必须返回迭代器。
- en: '### Custom Dictionary-Based Collections'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义基于字典的集合'
- en: 'The [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    class can be used as a base class for your custom types or as a mix-in to quickly
    add `dict` collection support to other classes. It uses a keying function to delegate
    to `__setitem__` and `__delitem__`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")类可以用作自定义类型的基类，也可以作为混合类快速为其他类添加`dict`集合支持。它使用一个键函数来委托`__setitem__`和`__delitem__`：'
- en: '[PRE109]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When subclassing [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict"),
    user-defined versions of `__setitem__()` or `__delitem__()` should be decorated
    with [`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented"), **if** they
    call down to those same methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict"). This because the methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") are already instrumented - calling them from within
    an already instrumented call can cause events to be fired off repeatedly, or inappropriately,
    leading to internal state corruption in rare cases:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")时，如果用户定义了`__setitem__()`或`__delitem__()`的版本，并且它们调用了相同的方法[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")上的方法，则应使用[`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented")进行装饰，**如果**它们调用了相同的方法[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")上的方法。这是因为[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")上的方法已经被仪器化了 - 从已经仪器化的调用中调用它们可能会导致事件被重复触发，或者不适当地触发，在极少数情况下会导致内部状态损坏：
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The ORM understands the `dict` interface just like lists and sets, and will
    automatically instrument all “dict-like” methods if you choose to subclass `dict`
    or provide dict-like collection behavior in a duck-typed class. You must decorate
    appender and remover methods, however- there are no compatible methods in the
    basic dictionary interface for SQLAlchemy to use by default. Iteration will go
    through `values()` unless otherwise decorated.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 与`dict`接口的理解方式与列表和集合一样，并且如果选择对`dict`进行子类化或在鸭式类型的类中提供类似于字典的集合行为，则会自动对所有“类似于字典”的方法进行仪器化。但是，必须装饰追加和删除方法
    - 基本字典接口中没有兼容的方法供 SQLAlchemy 默认使用。迭代将通过`values()`进行，除非另有装饰。
- en: Instrumentation and Custom Types
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化和自定义类型
- en: Many custom types and existing library classes can be used as a entity collection
    type as-is without further ado. However, it is important to note that the instrumentation
    process will modify the type, adding decorators around methods automatically.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自定义类型和现有库类可以直接使用作为实体集合类型，无需额外操作。但是，重要的是要注意，仪器化过程将修改类型，自动在方法周围添加装饰器。
- en: 'The decorations are lightweight and no-op outside of relationships, but they
    do add unneeded overhead when triggered elsewhere. When using a library class
    as a collection, it can be good practice to use the “trivial subclass” trick to
    restrict the decorations to just your usage in relationships. For example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰很轻量级，在关系之外不起作用，但是当在其他地方触发时会增加不必要的开销。当将库类用作集合时，最好使用“微不足道的子类”技巧将装饰限制为关系中的使用。例如：
- en: '[PRE111]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The ORM uses this approach for built-ins, quietly substituting a trivial subclass
    when a `list`, `set` or `dict` is used directly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 使用这种方法进行内置，当直接使用`list`、`set`或`dict`时，会悄悄地替换为一个微不足道的子类。
- en: Annotating Custom Collections via Decorators
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过装饰器注释自定义集合
- en: Decorators can be used to tag the individual methods the ORM needs to manage
    collections. Use them when your class doesn’t quite meet the regular interface
    for its container type, or when you otherwise would like to use a different method
    to get the job done.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用装饰器标记ORM需要管理集合的各个方法。当您的类不完全符合其容器类型的常规接口时，或者当您希望以不同的方法完成工作时，请使用它们。
- en: '[PRE112]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And that’s all that’s needed to complete the example. SQLAlchemy will add instances
    via the `append` method. `remove` and `__iter__` are the default methods for sets
    and will be used for removing and iteration. Default methods can be changed as
    well:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完成示例所需的全部内容。SQLAlchemy将通过`append`方法添加实例。`remove`和`__iter__`是集合的默认方法，将用于删除和迭代。默认方法也可以更改：
- en: '[PRE113]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There is no requirement to be “list-like” or “set-like” at all. Collection classes
    can be any shape, so long as they have the append, remove and iterate interface
    marked for SQLAlchemy’s use. Append and remove methods will be called with a mapped
    entity as the single argument, and iterator methods are called with no arguments
    and must return an iterator.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不需要“类似于列表”或“类似于集合”。集合类可以是任何形状，只要它们具有标记为SQLAlchemy使用的追加、移除和迭代接口即可。追加和移除方法将以映射实体作为单个参数调用，并且迭代方法将不带参数调用，并且必须返回迭代器。
- en: '### Custom Dictionary-Based Collections'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自定义基于字典的集合'
- en: 'The [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    class can be used as a base class for your custom types or as a mix-in to quickly
    add `dict` collection support to other classes. It uses a keying function to delegate
    to `__setitem__` and `__delitem__`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict") 类可以作为自定义类型的基类，也可以作为混合类快速将`dict`集合支持添加到其他类中。它使用键函数来委托`__setitem__`和`__delitem__`：'
- en: '[PRE114]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'When subclassing [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict"),
    user-defined versions of `__setitem__()` or `__delitem__()` should be decorated
    with [`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented"), **if** they
    call down to those same methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict"). This because the methods on [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") are already instrumented - calling them from within
    an already instrumented call can cause events to be fired off repeatedly, or inappropriately,
    leading to internal state corruption in rare cases:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类化[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")时，用户定义的`__setitem__()`或`__delitem__()`版本应该用[`collection.internally_instrumented()`](#sqlalchemy.orm.collections.collection.internally_instrumented
    "sqlalchemy.orm.collections.collection.internally_instrumented")进行修饰，**如果**它们调用同样的方法。这是因为[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")上的方法已经被仪器化-在已经仪器化的调用中调用它们可能会导致事件重复触发，或者在罕见情况下导致内部状态损坏：
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The ORM understands the `dict` interface just like lists and sets, and will
    automatically instrument all “dict-like” methods if you choose to subclass `dict`
    or provide dict-like collection behavior in a duck-typed class. You must decorate
    appender and remover methods, however- there are no compatible methods in the
    basic dictionary interface for SQLAlchemy to use by default. Iteration will go
    through `values()` unless otherwise decorated.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ORM理解`dict`接口就像理解列表和集合一样，并且如果您选择子类化`dict`或在鸭子类型的类中提供类似于dict的集合行为，则会自动仪器化所有“类似于dict”的方法。但是，您必须修饰追加和移除方法-默认情况下，基本字典接口中没有兼容的方法供SQLAlchemy使用。迭代将通过`values()`进行，除非另有修饰。
- en: Instrumentation and Custom Types
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化和自定义类型
- en: Many custom types and existing library classes can be used as a entity collection
    type as-is without further ado. However, it is important to note that the instrumentation
    process will modify the type, adding decorators around methods automatically.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自定义类型和现有的库类可以直接用作实体集合类型，无需进一步操作。但是，需要注意的是，仪器化过程将修改类型，自动在方法周围添加修饰符。
- en: 'The decorations are lightweight and no-op outside of relationships, but they
    do add unneeded overhead when triggered elsewhere. When using a library class
    as a collection, it can be good practice to use the “trivial subclass” trick to
    restrict the decorations to just your usage in relationships. For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰是轻量级的，并且在关系之外不起作用，但是当在其他地方触发时它们会增加不必要的开销。当将库类用作集合时，使用“trivial subclass”技巧将装饰限制为仅在关系中使用的情况可能是一个好习惯。例如：
- en: '[PRE116]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The ORM uses this approach for built-ins, quietly substituting a trivial subclass
    when a `list`, `set` or `dict` is used directly.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 使用此方法处理内置功能，当直接使用 `list`、`set` 或 `dict` 时，会静默地替换为一个微不足道的子类。
- en: Collection API
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合 API
- en: '| Object Name | Description |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [attribute_keyed_dict](#sqlalchemy.orm.attribute_keyed_dict)(attr_name, *,
    [ignore_unpopulated_attribute]) | A dictionary-based collection type with attribute-based
    keying. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| [attribute_keyed_dict](#sqlalchemy.orm.attribute_keyed_dict)(attr_name, *,
    [ignore_unpopulated_attribute]) | 基于属性的键的字典类型集合。 |'
- en: '| [attribute_mapped_collection](#sqlalchemy.orm.attribute_mapped_collection)
    | A dictionary-based collection type with attribute-based keying. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| [attribute_mapped_collection](#sqlalchemy.orm.attribute_mapped_collection)
    | 基于属性的键的字典类型集合。 |'
- en: '| [column_keyed_dict](#sqlalchemy.orm.column_keyed_dict)(mapping_spec, *, [ignore_unpopulated_attribute])
    | A dictionary-based collection type with column-based keying. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| [column_keyed_dict](#sqlalchemy.orm.column_keyed_dict)(mapping_spec, *, [ignore_unpopulated_attribute])
    | 基于列的键的字典类型集合。 |'
- en: '| [column_mapped_collection](#sqlalchemy.orm.column_mapped_collection) | A
    dictionary-based collection type with column-based keying. |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| [column_mapped_collection](#sqlalchemy.orm.column_mapped_collection) | 基于列的键的字典类型集合。
    |'
- en: '| [keyfunc_mapping](#sqlalchemy.orm.keyfunc_mapping)(keyfunc, *, [ignore_unpopulated_attribute])
    | A dictionary-based collection type with arbitrary keying. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| [keyfunc_mapping](#sqlalchemy.orm.keyfunc_mapping)(keyfunc, *, [ignore_unpopulated_attribute])
    | 具有任意键的基于字典的集合类型。 |'
- en: '| [KeyFuncDict](#sqlalchemy.orm.KeyFuncDict) | Base for ORM mapped dictionary
    classes. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| [KeyFuncDict](#sqlalchemy.orm.KeyFuncDict) | 用于 ORM 映射字典类的基础。 |'
- en: '| [mapped_collection](#sqlalchemy.orm.mapped_collection) | A dictionary-based
    collection type with arbitrary keying. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| [mapped_collection](#sqlalchemy.orm.mapped_collection) | 具有任意键的基于字典的集合类型。
    |'
- en: '| [MappedCollection](#sqlalchemy.orm.MappedCollection) | Base for ORM mapped
    dictionary classes. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| [MappedCollection](#sqlalchemy.orm.MappedCollection) | 用于 ORM 映射字典类的基础。 |'
- en: '[PRE117]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: A dictionary-based collection type with attribute-based keying.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的键的字典类型集合。
- en: 'Changed in version 2.0: Renamed [`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection") to [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict").'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版本更改：将[`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection")重命名为[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    named attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，它将根据要添加到字典中的
    ORM 映射实例上的特定命名属性的值产生新的字典键。
- en: Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在对象添加到字典集合时被赋值。此外，**不会跟踪**关键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关更多详细信息，请参阅[处理键变化和反向填充字典集合](#key-collections-mutations)。
- en: See also
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`attr_name` – string name of an ORM-mapped attribute on the mapped class, the
    value of which on a particular instance is to be used as the key for a new dictionary
    entry for that instance.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr_name` – 映射类上的 ORM 映射属性的字符串名称，该属性的值将作为该实例的新字典条目的键值。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the target attribute on an object is not populated at all, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为 True，并且对象上的目标属性根本未填充，则该操作将被静默跳过。默认情况下，将引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") parameter may be set which will instead
    indicate that this condition should be ignored, and the append operation silently
    skipped. This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版2.0中：如果确定用于字典键的属性从未填充任何值，则默认情况下会引发错误。[`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") 参数可以设置，表示应忽略此条件，并且静默跳过追加操作。这与1.x系列的行为形成对比，后者会错误地用任意键值`None`填充字典中的值。
- en: '[PRE118]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: A dictionary-based collection type with column-based keying.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 基于列的键控字典集合类型。
- en: 'Changed in version 2.0: Renamed [`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") to `column_keyed_dict`.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0中更改：将[`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") 更名为 `column_keyed_dict`。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")-mapped
    attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    工厂，它将根据ORM映射实例上的特定[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")-映射属性的值生成新的字典键，以添加到字典中。
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时分配其值。此外，不跟踪键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参阅[处理键变化和向字典集合回填](#key-collections-mutations)。
- en: See also
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 也可参阅
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`mapping_spec` – a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object that is expected to be mapped by the target
    mapper to a particular attribute on the mapped class, the value of which on a
    particular instance is to be used as the key for a new dictionary entry for that
    instance.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping_spec` – 预期由目标映射器映射到映射类上的特定属性的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，该属性的值在特定实例上将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the mapped attribute indicated by the given [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") target attribute on an object is not populated at
    all, the operation will be silently skipped. By default, an error is raised.
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且对象上由给定[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")目标属性指示的映射属性根本未填充，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版2.0中：如果确定用于字典键的属性从未填充任何值，则默认情况下会引发错误。[`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") 参数可以设置，表示应忽略此条件，并且静默跳过追加操作。这与1.x系列的行为形成对比，后者会错误地用任意键值`None`填充字典中的值。
- en: '[PRE119]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: A dictionary-based collection type with arbitrary keying.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有任意键的基于字典的集合类型。
- en: 'Changed in version 2.0: Renamed [`mapped_collection`](#sqlalchemy.orm.mapped_collection
    "sqlalchemy.orm.mapped_collection") to [`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping").'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：将 [`mapped_collection`](#sqlalchemy.orm.mapped_collection "sqlalchemy.orm.mapped_collection")
    重命名为 [`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping "sqlalchemy.orm.keyfunc_mapping")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory with a keying function generated from keyfunc, a callable that takes an
    entity and returns a key value.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从 `keyfunc` 生成的键函数的 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    工厂，`keyfunc` 是一个可调用对象，接受一个实体并返回一个键值。
- en: Note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the given keyfunc is called only once at the time that the target object is
    being added to the collection. Changes to the effective value returned by the
    function are not tracked.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `keyfunc` 只在将目标对象添加到集合时调用一次。不跟踪对函数返回的有效值的更改。
- en: See also
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`keyfunc` – a callable that will be passed the ORM-mapped instance which should
    then generate a new key to use in the dictionary. If the value returned is [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), an error is raised.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyfunc` – 应传递 ORM 映射实例的可调用对象，然后生成一个新的用于字典的键。如果返回的值是 [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则会引发错误。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the callable returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE") for a particular instance, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为 True，并且可调用对象对于特定实例返回 [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the callable being used
    for the dictionary key returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), which in an ORM attribute context
    indicates an attribute that was never populated with any value. The [`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始：如果用于字典键的可调用对象返回 [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，默认情况下会引发错误，这在 ORM 属性上下文中表示一个从未填充任何值的属性。可以设置
    [`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection") 参数，该参数将指示忽略此条件，并且追加操作将被静默跳过。这与 1.x 系列的行为形成对比，后者会错误地用任意的键值
    `None` 填充字典中的值。
- en: '[PRE120]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: A dictionary-based collection type with attribute-based keying.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于字典的集合类型，具有基于属性的键。
- en: 'Changed in version 2.0: Renamed [`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection") to [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict").'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：将 [`attribute_mapped_collection`](#sqlalchemy.orm.attribute_mapped_collection
    "sqlalchemy.orm.attribute_mapped_collection") 重命名为 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    named attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个根据要添加到字典中的 ORM 映射实例的特定命名属性的值生成新字典键的 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") 工厂。
- en: Note
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时分配其值。此外，不跟踪键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参见[处理键变异和向字典集合反填充](#key-collections-mutations)。
- en: See also
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`attr_name` – string name of an ORM-mapped attribute on the mapped class, the
    value of which on a particular instance is to be used as the key for a new dictionary
    entry for that instance.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr_name` – 映射类上的ORM映射属性的字符串名称，在特定实例上的值将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the target attribute on an object is not populated at all, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为True，并且对象上的目标属性根本未填充，则操作将被静默跳过。默认情况下，将引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") parameter may be set which will instead
    indicate that this condition should be ignored, and the append operation silently
    skipped. This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本2.0中：如果确定用于字典键的属性从未填充任何值，则默认会引发错误。 [`attribute_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.attribute_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.attribute_keyed_dict") 参数可以设置，以指示应忽略此条件，并且附加操作将被静默跳过。这与1.x系列的行为相反，后者会错误地使用任意键值为`None`填充字典中的值。
- en: '[PRE121]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: A dictionary-based collection type with column-based keying.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合类型，以列为键。
- en: 'Changed in version 2.0: Renamed [`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection") to `column_keyed_dict`.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0版更改：将[`column_mapped_collection`](#sqlalchemy.orm.column_mapped_collection
    "sqlalchemy.orm.column_mapped_collection")重命名为`column_keyed_dict`。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory which will produce new dictionary keys based on the value of a particular
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")-mapped
    attribute on ORM mapped instances to be added to the dictionary.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，它将根据ORM映射实例上的特定[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")属性的值生成新的字典键，以添加到字典中。
- en: Note
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the value of the target attribute must be assigned with its value at the time
    that the object is being added to the dictionary collection. Additionally, changes
    to the key attribute are **not tracked**, which means the key in the dictionary
    is not automatically synchronized with the key value on the target object itself.
    See [Dealing with Key Mutations and back-populating for Dictionary collections](#key-collections-mutations)
    for further details.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性的值必须在将对象添加到字典集合时分配其值。此外，不跟踪键属性的更改，这意味着字典中的键不会自动与目标对象本身的键值同步。有关详细信息，请参见[处理键变异和向字典集合反填充](#key-collections-mutations)。
- en: See also
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`mapping_spec` – a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object that is expected to be mapped by the target
    mapper to a particular attribute on the mapped class, the value of which on a
    particular instance is to be used as the key for a new dictionary entry for that
    instance.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping_spec` – 预期由目标映射器映射到映射类上的特定属性的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，在特定实例上的值将用作该实例的新字典条目的键。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the mapped attribute indicated by the given [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") target attribute on an object is not populated at
    all, the operation will be silently skipped. By default, an error is raised.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为 True，并且对象上的给定[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")目标属性指示的映射属性根本未填充，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the attribute being used
    for the dictionary key is determined that it was never populated with any value.
    The [`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本 2.0 中的新功能：如果确定用于字典键的属性从未填充任何值，则默认情况下会引发错误。可以设置[`column_keyed_dict.ignore_unpopulated_attribute`](#sqlalchemy.orm.column_keyed_dict.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.column_keyed_dict")参数，该参数将指示忽略此条件，并静默跳过追加操作。这与 1.x 系列的行为相反，后者将错误地用任意键值`None`填充字典中的值。
- en: '[PRE122]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: A dictionary-based collection type with arbitrary keying.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 具有任意键的基于字典的集合类型。
- en: 'Changed in version 2.0: Renamed [`mapped_collection`](#sqlalchemy.orm.mapped_collection
    "sqlalchemy.orm.mapped_collection") to [`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping").'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 2.0 起更改：将[`mapped_collection`](#sqlalchemy.orm.mapped_collection "sqlalchemy.orm.mapped_collection")重命名为[`keyfunc_mapping()`](#sqlalchemy.orm.keyfunc_mapping
    "sqlalchemy.orm.keyfunc_mapping")。
- en: Returns a [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    factory with a keying function generated from keyfunc, a callable that takes an
    entity and returns a key value.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个由 keyfunc 生成的键函数的[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")工厂，keyfunc
    是一个可调用的函数，它接受一个实体并返回一个键值。
- en: Note
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: the given keyfunc is called only once at the time that the target object is
    being added to the collection. Changes to the effective value returned by the
    function are not tracked.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 keyfunc 仅在将目标对象添加到集合时调用一次。不跟踪函数返回的有效值的更改。
- en: See also
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dictionary Collections](#orm-dictionary-collection) - background on use'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection) - 使用背景'
- en: 'Parameters:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`keyfunc` – a callable that will be passed the ORM-mapped instance which should
    then generate a new key to use in the dictionary. If the value returned is [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), an error is raised.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyfunc` – 一个可调用的函数，将传递 ORM 映射实例，然后生成一个新的键用于字典中。如果返回的值为[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则会引发错误。'
- en: '`ignore_unpopulated_attribute` –'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_unpopulated_attribute` –'
- en: if True, and the callable returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE") for a particular instance, the
    operation will be silently skipped. By default, an error is raised.
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果为 True，并且可调用函数对于特定实例返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则操作将被静默跳过。默认情况下，会引发错误。
- en: 'New in version 2.0: an error is raised by default if the callable being used
    for the dictionary key returns [`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE"), which in an ORM attribute context
    indicates an attribute that was never populated with any value. The [`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection") parameter may be set which will instead indicate
    that this condition should be ignored, and the append operation silently skipped.
    This is in contrast to the behavior of the 1.x series which would erroneously
    populate the value in the dictionary with an arbitrary key value of `None`.'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本 2.0 中，默认情况下，如果用于字典键的可调用函数返回[`LoaderCallableStatus.NO_VALUE`](internals.html#sqlalchemy.orm.LoaderCallableStatus.NO_VALUE
    "sqlalchemy.orm.LoaderCallableStatus.NO_VALUE")，则会引发错误。在 ORM 属性上下文中，这表示从未填充任何值的属性。可以设置[`mapped_collection.ignore_unpopulated_attribute`](#sqlalchemy.orm.mapped_collection.params.ignore_unpopulated_attribute
    "sqlalchemy.orm.mapped_collection")参数，该参数将表示应忽略此条件，并且附加操作会被静默跳过。这与 1.x 系列的行为形成对比，后者会错误地使用任意键值`None`填充字典中的值。
- en: '[PRE123]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Base for ORM mapped dictionary classes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 映射字典类的基类。
- en: Extends the `dict` type with additional methods needed by SQLAlchemy ORM collection
    classes. Use of [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    is most directly by using the [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") or [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") class factories. [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") may also serve as the base for user-defined custom
    dictionary classes.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 SQLAlchemy ORM 集合类添加所需的附加方法来扩展`dict`类型。最直接使用[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict")或[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict")类工厂来使用[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")也可以用作用户定义的自定义字典类的基类。
- en: 'Changed in version 2.0: Renamed `MappedCollection` to [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict").'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 中的变更：将`MappedCollection`重命名为[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。
- en: See also
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
- en: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
- en: '[Dictionary Collections](#orm-dictionary-collection)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection)'
- en: '[Custom Collection Implementations](#orm-custom-collection)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合实现](#orm-custom-collection)'
- en: '**Members**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.orm.KeyFuncDict.__init__), [clear()](#sqlalchemy.orm.KeyFuncDict.clear),
    [pop()](#sqlalchemy.orm.KeyFuncDict.pop), [popitem()](#sqlalchemy.orm.KeyFuncDict.popitem),
    [remove()](#sqlalchemy.orm.KeyFuncDict.remove), [set()](#sqlalchemy.orm.KeyFuncDict.set),
    [setdefault()](#sqlalchemy.orm.KeyFuncDict.setdefault), [update()](#sqlalchemy.orm.KeyFuncDict.update)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.orm.KeyFuncDict.__init__), [clear()](#sqlalchemy.orm.KeyFuncDict.clear),
    [pop()](#sqlalchemy.orm.KeyFuncDict.pop), [popitem()](#sqlalchemy.orm.KeyFuncDict.popitem),
    [remove()](#sqlalchemy.orm.KeyFuncDict.remove), [set()](#sqlalchemy.orm.KeyFuncDict.set),
    [setdefault()](#sqlalchemy.orm.KeyFuncDict.setdefault), [update()](#sqlalchemy.orm.KeyFuncDict.update)'
- en: '**Class signature**'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    (`builtins.dict`, `typing.Generic`)
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.orm.KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    (`builtins.dict`, `typing.Generic`)
- en: '[PRE124]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Create a new collection with keying provided by keyfunc.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 keyfunc 提供的键制作新集合。
- en: keyfunc may be any callable that takes an object and returns an object for use
    as a dictionary key.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: keyfunc 可以是任何接受对象并返回对象以用作字典键的可调用函数。
- en: The keyfunc will be called every time the ORM needs to add a member by value-only
    (such as when loading instances from the database) or remove a member. The usual
    cautions about dictionary keying apply- `keyfunc(object)` should return the same
    output for the life of the collection. Keying based on mutable properties can
    result in unreachable instances “lost” in the collection.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 ORM 需要通过仅基于值的方式添加成员（例如从数据库加载实例时）或删除成员时，都会调用 keyfunc。通常的字典键的注意事项也适用 - `keyfunc(object)`
    应该在集合的生命周期内返回相同的输出。基于可变属性的键值可能导致集合中“丢失”的不可达实例。
- en: '[PRE125]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: If the key is not found, return the default if given; otherwise, raise a KeyError.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到键，则如果给定默认值，则返回默认值；否则，引发 KeyError。
- en: '[PRE127]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Remove and return a (key, value) pair as a 2-tuple.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 移除并返回一个 (key, value) 对作为 2-元组。
- en: Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the
    dict is empty.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 以 LIFO（后进先出）顺序返回对。如果字典为空，则引发 KeyError。
- en: '[PRE128]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Remove an item by value, consulting the keyfunc for the key.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值删除项目，并查询键的键函数。
- en: '[PRE129]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Add an item by value, consulting the keyfunc for the key.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值添加项目，并查询键的键函数。
- en: '[PRE130]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Insert key with a value of default if key is not in the dictionary.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 插入具有默认值的键，如果键不在字典中。
- en: Return the value for key if key is in the dictionary, else default.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中，则返回键的值，否则返回默认值。
- en: '[PRE131]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v
    In either case, this is followed by: for k in F: D[k] = F[k]'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 E 存在且具有 .keys() 方法，则执行以下操作：for k in E: D[k] = E[k] 如果 E 存在且缺少 .keys() 方法，则执行以下操作：for
    k, v in E: D[k] = v 在任何一种情况下，都会执行以下操作：for k in F: D[k] = F[k]'
- en: '[PRE132]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Base for ORM mapped dictionary classes.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 映射字典类的基础。
- en: Extends the `dict` type with additional methods needed by SQLAlchemy ORM collection
    classes. Use of [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    is most directly by using the [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") or [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") class factories. [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict") may also serve as the base for user-defined custom
    dictionary classes.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展了 `dict` 类型，以包含 SQLAlchemy ORM 集合类所需的附加方法。最直接使用 [`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict
    "sqlalchemy.orm.attribute_keyed_dict") 或 [`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict
    "sqlalchemy.orm.column_keyed_dict") 类工厂来使用 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。[`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict "sqlalchemy.orm.KeyFuncDict")
    也可以作为用户定义的自定义字典类的基础。
- en: 'Changed in version 2.0: Renamed `MappedCollection` to [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict").'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本中更改：将 `MappedCollection` 重命名为 [`KeyFuncDict`](#sqlalchemy.orm.KeyFuncDict
    "sqlalchemy.orm.KeyFuncDict")。
- en: See also
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[`attribute_keyed_dict()`](#sqlalchemy.orm.attribute_keyed_dict "sqlalchemy.orm.attribute_keyed_dict")'
- en: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_keyed_dict()`](#sqlalchemy.orm.column_keyed_dict "sqlalchemy.orm.column_keyed_dict")'
- en: '[Dictionary Collections](#orm-dictionary-collection)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[字典集合](#orm-dictionary-collection)'
- en: '[Custom Collection Implementations](#orm-custom-collection)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合实现](#orm-custom-collection)'
- en: Collection Internals
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合内部
- en: '| Object Name | Description |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| Object Name | 描述 |'
- en: '| --- | --- |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [bulk_replace](#sqlalchemy.orm.collections.bulk_replace)(values, existing_adapter,
    new_adapter[, initiator]) | Load a new collection, firing events based on prior
    like membership. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| [bulk_replace](#sqlalchemy.orm.collections.bulk_replace)(values, existing_adapter,
    new_adapter[, initiator]) | 加载一个新的集合，并根据先前的相似成员资格触发事件。 |'
- en: '| [collection](#sqlalchemy.orm.collections.collection) | Decorators for entity
    collection classes. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| [collection](#sqlalchemy.orm.collections.collection) | 实体集合类的装饰器。 |'
- en: '| [collection_adapter](#sqlalchemy.orm.collections.collection_adapter) | attrgetter(attr,
    …) –> attrgetter object |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| [collection_adapter](#sqlalchemy.orm.collections.collection_adapter) | attrgetter(attr,
    …) –> attrgetter 对象 |'
- en: '| [CollectionAdapter](#sqlalchemy.orm.collections.CollectionAdapter) | Bridges
    between the ORM and arbitrary Python collections. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| [CollectionAdapter](#sqlalchemy.orm.collections.CollectionAdapter) | 在 ORM
    和任意 Python 集合之间建立桥梁。 |'
- en: '| [InstrumentedDict](#sqlalchemy.orm.collections.InstrumentedDict) | An instrumented
    version of the built-in dict. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedDict](#sqlalchemy.orm.collections.InstrumentedDict) | 内置字典的受控版本。
    |'
- en: '| [InstrumentedList](#sqlalchemy.orm.collections.InstrumentedList) | An instrumented
    version of the built-in list. |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedList](#sqlalchemy.orm.collections.InstrumentedList) | 内置列表的受控版本。
    |'
- en: '| [InstrumentedSet](#sqlalchemy.orm.collections.InstrumentedSet) | An instrumented
    version of the built-in set. |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| [InstrumentedSet](#sqlalchemy.orm.collections.InstrumentedSet) | 内置集合的受控版本。
    |'
- en: '| [prepare_instrumentation](#sqlalchemy.orm.collections.prepare_instrumentation)(factory)
    | Prepare a callable for future use as a collection class factory. |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| [prepare_instrumentation](#sqlalchemy.orm.collections.prepare_instrumentation)(factory)
    | 准备一个可调用对象，以便将来用作集合类工厂。 |'
- en: '[PRE133]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Load a new collection, firing events based on prior like membership.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 加载一个新的集合，并根据先前的相似成员资格触发事件。
- en: Appends instances in `values` onto the `new_adapter`. Events will be fired for
    any instance not present in the `existing_adapter`. Any instances in `existing_adapter`
    not present in `values` will have remove events fired upon them.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 将`values`中的实例追加到`new_adapter`中。对于`existing_adapter`中不存在的任何实例，将触发事件。`existing_adapter`中存在但在`values`中不存在的任何实例将触发删除事件。
- en: 'Parameters:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`values` – An iterable of collection member instances'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values` – 一个包含集合成员实例的可迭代对象'
- en: '`existing_adapter` – A [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") of instances to be replaced'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`existing_adapter` – 一个要替换的实例的[`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter")'
- en: '`new_adapter` – An empty [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") to load with `values`'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_adapter` – 一个空的[`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter")，用于加载`values`'
- en: '[PRE134]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Decorators for entity collection classes.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 用于实体集合类的装饰器。
- en: 'The decorators fall into two groups: annotations and interception recipes.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器分为两组：注解和拦截配方。
- en: 'The annotating decorators (appender, remover, iterator, converter, internally_instrumented)
    indicate the method’s purpose and take no arguments. They are not written with
    parens:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注解装饰器（appender、remover、iterator、converter、internally_instrumented）指示方法的目的并且不带参数。它们不带括号写成：
- en: '[PRE135]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The recipe decorators all require parens, even those that take no arguments:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的装饰器都需要括号，即使没有参数：
- en: '**Members**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[adds()](#sqlalchemy.orm.collections.collection.adds), [appender()](#sqlalchemy.orm.collections.collection.appender),
    [converter()](#sqlalchemy.orm.collections.collection.converter), [internally_instrumented()](#sqlalchemy.orm.collections.collection.internally_instrumented),
    [iterator()](#sqlalchemy.orm.collections.collection.iterator), [remover()](#sqlalchemy.orm.collections.collection.remover),
    [removes()](#sqlalchemy.orm.collections.collection.removes), [removes_return()](#sqlalchemy.orm.collections.collection.removes_return),
    [replaces()](#sqlalchemy.orm.collections.collection.replaces)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[adds()](#sqlalchemy.orm.collections.collection.adds), [appender()](#sqlalchemy.orm.collections.collection.appender),
    [converter()](#sqlalchemy.orm.collections.collection.converter), [internally_instrumented()](#sqlalchemy.orm.collections.collection.internally_instrumented),
    [iterator()](#sqlalchemy.orm.collections.collection.iterator), [remover()](#sqlalchemy.orm.collections.collection.remover),
    [removes()](#sqlalchemy.orm.collections.collection.removes), [removes_return()](#sqlalchemy.orm.collections.collection.removes_return),
    [replaces()](#sqlalchemy.orm.collections.collection.replaces)'
- en: '[PRE136]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Mark the method as adding an entity to the collection.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为向集合添加实体。
- en: 'Adds “add to collection” handling to the method. The decorator argument indicates
    which method argument holds the SQLAlchemy-relevant value. Arguments can be specified
    positionally (i.e. integer) or by name:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 将“添加到集合”处理添加到方法中。装饰器参数指示哪个方法参数保存了与SQLAlchemy相关的值。参数可以按位置指定（即整数）或按名称指定：
- en: '[PRE138]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Tag the method as the collection appender.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合追加器。
- en: 'The appender method is called with one positional argument: the value to append.
    The method will be automatically decorated with ‘adds(1)’ if not already decorated:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果追加器方法调用时带有一个位置参数：要追加的值。如果尚未装饰，则该方法将自动装饰为‘adds(1)’：
- en: '[PRE140]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: If the value to append is not allowed in the collection, you may raise an exception.
    Something to remember is that the appender will be called for each object mapped
    by a database query. If the database contains rows that violate your collection
    semantics, you will need to get creative to fix the problem, as access via the
    collection will not work.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要追加的值不允许在集合中，您可以引发异常。需要记住的是，追加器将针对数据库查询映射的每个对象调用。如果数据库包含违反集合语义的行，则您需要有创意地解决问题，因为通过集合访问将无法工作。
- en: If the appender method is internally instrumented, you must also receive the
    keyword argument ‘_sa_initiator’ and ensure its promulgation to collection events.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果追加器方法在内部被检测到，您还必须接收关键字参数‘_sa_initiator’并确保将其传播到集合事件。
- en: '[PRE141]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Tag the method as the collection converter.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为集合转换器。
- en: 'Deprecated since version 1.3: The [`collection.converter()`](#sqlalchemy.orm.collections.collection.converter
    "sqlalchemy.orm.collections.collection.converter") handler is deprecated and will
    be removed in a future release. Please refer to the `bulk_replace` listener interface
    in conjunction with the [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") function.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.3 弃用：[`collection.converter()`](#sqlalchemy.orm.collections.collection.converter
    "sqlalchemy.orm.collections.collection.converter") 处理程序已弃用，并将在未来的版本中移除。请参考 [`listen()`](../core/event.html#sqlalchemy.event.listen
    "sqlalchemy.event.listen") 函数结合 `bulk_replace` 监听器接口。
- en: 'This optional method will be called when a collection is being replaced entirely,
    as in:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合被完全替换时，将调用此可选方法，如下所示：
- en: '[PRE142]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The converter method will receive the object being assigned and should return
    an iterable of values suitable for use by the `appender` method. A converter must
    not assign values or mutate the collection, its sole job is to adapt the value
    the user provides into an iterable of values for the ORM’s use.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器方法将接收到要分配的对象，并应返回适用于 `appender` 方法使用的值的可迭代对象。转换器不得分配值或更改集合，它的唯一任务是将用户提供的值适应为
    ORM 使用的值的可迭代对象。
- en: 'The default converter implementation will use duck-typing to do the conversion.
    A dict-like collection will be convert into an iterable of dictionary values,
    and other types will simply be iterated:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的转换器实现将使用鸭子类型进行转换。类似字典的集合将被转换为字典值的可迭代对象，而其他类型将简单地进行迭代：
- en: '[PRE143]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: If the duck-typing of the object does not match the type of this collection,
    a TypeError is raised.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的鸭子类型与此集合的类型不匹配，则会引发 TypeError。
- en: Supply an implementation of this method if you want to expand the range of possible
    types that can be assigned in bulk or perform validation on the values about to
    be assigned.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望扩展可以批量分配的可能类型的范围或对即将分配的值进行验证，请提供此方法的实现。
- en: '[PRE144]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Tag the method as instrumented.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为受检测的。
- en: 'This tag will prevent any decoration from being applied to the method. Use
    this if you are orchestrating your own calls to `collection_adapter()` in one
    of the basic SQLAlchemy interface methods, or to prevent an automatic ABC method
    decoration from wrapping your implementation:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记将阻止对该方法应用任何装饰。如果您正在 orchestrating 在基本的 SQLAlchemy 接口方法之一中调用 `collection_adapter()`，或者要防止自动
    ABC 方法装饰器包装您的实现，请使用此标记：
- en: '[PRE145]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Tag the method as the collection remover.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为集合移除器。
- en: 'The iterator method is called with no arguments. It is expected to return an
    iterator over all collection members:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器方法无需参数调用。它应返回所有集合成员的迭代器：
- en: '[PRE147]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Tag the method as the collection remover.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为集合移除器。
- en: 'The remover method is called with one positional argument: the value to remove.
    The method will be automatically decorated with [`removes_return()`](#sqlalchemy.orm.collections.collection.removes_return
    "sqlalchemy.orm.collections.collection.removes_return") if not already decorated:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 移除器方法使用一个位置参数调用：要移除的值。如果尚未被其他装饰器装饰，该方法将自动使用 [`removes_return()`](#sqlalchemy.orm.collections.collection.removes_return
    "sqlalchemy.orm.collections.collection.removes_return") 进行装饰：
- en: '[PRE149]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: If the value to remove is not present in the collection, you may raise an exception
    or return None to ignore the error.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要移除的值不存在于集合中，则可以引发异常或返回 None 以忽略错误。
- en: If the remove method is internally instrumented, you must also receive the keyword
    argument ‘_sa_initiator’ and ensure its promulgation to collection events.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移除方法在内部进行了检测，请确保也接收关键字参数 ‘_sa_initiator’ 并确保其在集合事件中传播。
- en: '[PRE150]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Mark the method as removing an entity in the collection.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为从集合中移除实体。
- en: 'Adds “remove from collection” handling to the method. The decorator argument
    indicates which method argument holds the SQLAlchemy-relevant value to be removed.
    Arguments can be specified positionally (i.e. integer) or by name:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 为方法添加“从集合中移除”的处理。修饰器参数指示哪个方法参数包含要移除的与 SQLAlchemy 相关的值。参数可以按位置指定（即整数），也可以按名称指定：
- en: '[PRE151]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: For methods where the value to remove is not known at call-time, use collection.removes_return.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在调用时未知要移除的值的方法，请使用 collection.removes_return。
- en: '[PRE152]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Mark the method as removing an entity in the collection.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法标记为从集合中移除实体。
- en: 'Adds “remove from collection” handling to the method. The return value of the
    method, if any, is considered the value to remove. The method arguments are not
    inspected:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 为方法添加“从集合中移除”的处理。如果没有被其他装饰器装饰，该方法的返回值（如果有）将被视为要移除的值。不会检查方法参数：
- en: '[PRE153]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: For methods where the value to remove is known at call-time, use collection.remove.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在调用时已知要移除的值的方法，请使用 collection.remove。
- en: '[PRE154]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Mark the method as replacing an entity in the collection.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 标记该方法用于替换集合中的实体。
- en: Adds “add to collection” and “remove from collection” handling to the method.
    The decorator argument indicates which method argument holds the SQLAlchemy-relevant
    value to be added, and return value, if any will be considered the value to remove.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 为方法添加“添加到集合”和“从集合中移除”处理。装饰器参数指示哪个方法参数保存了要添加的与 SQLAlchemy 相关的值，以及返回值（如果有）将被视为要移除的值。
- en: 'Arguments can be specified positionally (i.e. integer) or by name:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过位置（即整数）或名称指定：
- en: '[PRE155]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: attrgetter(attr, …) –> attrgetter object
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: attrgetter(attr, …) –> attrgetter 对象
- en: Return a callable object that fetches the given attribute(s) from its operand.
    After f = attrgetter(‘name’), the call f(r) returns r.name. After g = attrgetter(‘name’,
    ‘date’), the call g(r) returns (r.name, r.date). After h = attrgetter(‘name.first’,
    ‘name.last’), the call h(r) returns (r.name.first, r.name.last).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可调用对象，从其操作数中提取给定的属性。在 f = attrgetter(‘name’) 后，调用 f(r) 返回 r.name。在 g = attrgetter(‘name’,
    ‘date’) 后，调用 g(r) 返回 (r.name, r.date)。在 h = attrgetter(‘name.first’, ‘name.last’)
    后，调用 h(r) 返回 (r.name.first, r.name.last)。
- en: '[PRE157]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Bridges between the ORM and arbitrary Python collections.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 和任意 Python 集合之间建立桥梁。
- en: Proxies base-level collection operations (append, remove, iterate) to the underlying
    Python collection, and emits add/remove events for entities entering or leaving
    the collection.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 将基本级别的集合操作（追加、删除、迭代）代理给底层的 Python 集合，并为进入或离开集合的实体发出添加/删除事件。
- en: The ORM uses [`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") exclusively for interaction with
    entity collections.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 专门使用[`CollectionAdapter`](#sqlalchemy.orm.collections.CollectionAdapter
    "sqlalchemy.orm.collections.CollectionAdapter") 与实体集合进行交互。
- en: '[PRE158]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: An instrumented version of the built-in dict.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 内置字典的受检版本。
- en: '**Class signature**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedDict`](#sqlalchemy.orm.collections.InstrumentedDict
    "sqlalchemy.orm.collections.InstrumentedDict") (`builtins.dict`, `typing.Generic`)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.orm.collections.InstrumentedDict`](#sqlalchemy.orm.collections.InstrumentedDict
    "sqlalchemy.orm.collections.InstrumentedDict") (`builtins.dict`, `typing.Generic`)
- en: '[PRE159]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: An instrumented version of the built-in list.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 内置列表的受检版本。
- en: '**Class signature**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedList`](#sqlalchemy.orm.collections.InstrumentedList
    "sqlalchemy.orm.collections.InstrumentedList") (`builtins.list`, `typing.Generic`)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.orm.collections.InstrumentedList`](#sqlalchemy.orm.collections.InstrumentedList
    "sqlalchemy.orm.collections.InstrumentedList") (`builtins.list`, `typing.Generic`)
- en: '[PRE160]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: An instrumented version of the built-in set.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 内置集合的受检版本。
- en: '**Class signature**'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.orm.collections.InstrumentedSet`](#sqlalchemy.orm.collections.InstrumentedSet
    "sqlalchemy.orm.collections.InstrumentedSet") (`builtins.set`, `typing.Generic`)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.orm.collections.InstrumentedSet`](#sqlalchemy.orm.collections.InstrumentedSet
    "sqlalchemy.orm.collections.InstrumentedSet") (`builtins.set`, `typing.Generic`)
- en: '[PRE161]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Prepare a callable for future use as a collection class factory.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个可调用对象，以便将来用作集合类工厂。
- en: Given a collection class factory (either a type or no-arg callable), return
    another factory that will produce compatible instances when called.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个集合类工厂（类型或无参数可调用对象），返回另一个工厂，当调用时将生成兼容的实例。
- en: This function is responsible for converting collection_class=list into the run-time
    behavior of collection_class=InstrumentedList.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数负责将 collection_class=list 转换为 collection_class=InstrumentedList 的运行时行为。
