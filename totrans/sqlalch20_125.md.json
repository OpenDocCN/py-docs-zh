["```py\n    # (variable) str_col: ColumnClause[str]\n    str_col = column(\"a\", String)\n\n    # (variable) int_col: ColumnClause[int]\n    int_col = column(\"a\", Integer)\n\n    # (variable) expr1: ColumnElement[str]\n    expr1 = str_col + \"x\"\n\n    # (variable) expr2: ColumnElement[int]\n    expr2 = int_col + 10\n\n    # (variable) expr3: ColumnElement[bool]\n    expr3 = int_col == 15\n    ```", "```py\n    # (variable) stmt: Select[Tuple[str, int]]\n    stmt = select(str_col, int_col)\n\n    # (variable) stmt: ReturningInsert[Tuple[str, int]]\n    ins_stmt = insert(table(\"t\")).returning(str_col, int_col)\n    ```", "```py\n    with engine.connect() as conn:\n        # (variable) stmt: Select[Tuple[str, int]]\n        stmt = select(str_col, int_col)\n\n        # (variable) result: Result[Tuple[str, int]]\n        result = conn.execute(stmt)\n\n        # (variable) row: Row[Tuple[str, int]] | None\n        row = result.first()\n\n        if row is not None:\n            # for typed tuple unpacking or indexed access,\n            # use row.tuple() or row.t  (this is the small typing-oriented accessor)\n            strval, intval = row.t\n\n            # (variable) strval: str\n            strval\n\n            # (variable) intval: int\n            intval\n    ```", "```py\n    # (variable) data: Sequence[str]\n    data = connection.execute(select(str_col)).scalars().all()\n    ```", "```py\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import mapped_column\n\n    class Base(DeclarativeBase):\n        pass\n\n    class User(Base):\n        __tablename__ = \"user_account\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str]\n        addresses: Mapped[List[\"Address\"]] = relationship()\n\n    class Address(Base):\n        __tablename__ = \"address\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        email_address: Mapped[str]\n        user_id = mapped_column(ForeignKey(\"user_account.id\"))\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[int, str]]\n        stmt_1 = select(User.id, User.name)\n\n        # (variable) result_1: Result[Tuple[int, str]]\n        result_1 = session.execute(stmt_1)\n\n        # (variable) intval: int\n        # (variable) strval: str\n        intval, strval = result_1.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[User, Address]]\n        stmt_2 = select(User, Address).join_from(User, Address)\n\n        # (variable) result_2: Result[Tuple[User, Address]]\n        result_2 = session.execute(stmt_2)\n\n        # (variable) user_obj: User\n        # (variable) address_obj: Address\n        user_obj, address_obj = result_2.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # this is in fact an Annotated type, but typing tools don't\n        # generally display this\n\n        # (variable) u1: Type[User]\n        u1 = aliased(User)\n\n        # (variable) stmt: Select[Tuple[User, User, str]]\n        stmt = select(User, u1, User.name).filter(User.id == 5)\n\n        # (variable) result: Result[Tuple[User, User, str]]\n        result = session.execute(stmt)\n    ```", "```py\n    # (variable) users1: Sequence[User]\n    users1 = session.scalars(select(User)).all()\n\n    # (variable) user: User\n    user = session.query(User).one()\n\n    # (variable) user_iter: Iterator[User]\n    user_iter = iter(session.scalars(select(User)))\n    ```", "```py\n    # (variable) q1: RowReturningQuery[Tuple[int, str]]\n    q1 = session.query(User.id, User.name)\n\n    # (variable) rows: List[Row[Tuple[int, str]]]\n    rows = q1.all()\n\n    # (variable) q2: Query[User]\n    q2 = session.query(User)\n\n    # (variable) users: List[User]\n    users = q2.all()\n    ```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(30), nullable=False)\n    fullname = Column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(30), nullable=False)\n    fullname = mapped_column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String, nullable=False)\n    user_id = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(30), nullable=False)\n    fullname: Mapped[Optional[str]] = mapped_column(String)\n    addresses: Mapped[List[\"Address\"]] = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    email_address: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email_address: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\nfrom typing_extensions import Annotated\nfrom sqlalchemy.orm import DeclarativeBase\n\nstr50 = Annotated[str, 50]\n\n# declarative base with a type-level override, using a type that is\n# expected to be used in multiple places\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\n# declarative base from previous example\nstr50 = Annotated[str, 50]\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n\n# set up mapped_column() overrides, using whole column styles that are\n# expected to be used in multiple places\nintpk = Annotated[int, mapped_column(primary_key=True)]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk]\n    name: Mapped[str50]\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk]\n    email_address: Mapped[str50]\n    user_id: Mapped[user_fk]\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\n# (variable) stmt: Select[Tuple[int, str]]\nstmt = select(User.id, User.name)\n\nwith Session(e) as sess:\n    for row in sess.execute(stmt):\n        # (variable) row: Row[Tuple[int, str]]\n        print(row)\n\n    # (variable) users: Sequence[User]\n    users = sess.scalars(select(User)).all()\n\n    # (variable) users_legacy: List[User]\n    users_legacy = sess.query(User).all()\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import MappedAsDataclass\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(MappedAsDataclass, DeclarativeBase):\n  \"\"\"subclasses will be converted to dataclasses\"\"\"\n\nintpk = Annotated[int, mapped_column(primary_key=True)]\nstr30 = Annotated[str, mapped_column(String(30))]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    name: Mapped[str30]\n    fullname: Mapped[Optional[str]] = mapped_column(default=None)\n    addresses: Mapped[List[\"Address\"]] = relationship(\n        back_populates=\"user\", default_factory=list\n    )\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    email_address: Mapped[str]\n    user_id: Mapped[user_fk] = mapped_column(init=False)\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\", default=None)\n```", "```py\n>>> u1 = User(\"username\", fullname=\"full name\", addresses=[Address(\"email@address\")])\n>>> u1\nUser(id=None, name='username', fullname='full name', addresses=[Address(id=None, email_address='email@address', user_id=None, user=...)])\n```", "```py\n@Profiler.profile\ndef test_flush_no_pk(n):\n  \"\"\"INSERT statements via the ORM (batched with RETURNING if available),\n fetching generated row id\"\"\"\n    session = Session(bind=engine)\n    for chunk in range(0, n, 1000):\n        session.add_all(\n            [\n                Customer(\n                    name=\"customer name %d\" % i,\n                    description=\"customer description %d\" % i,\n                )\n                for i in range(chunk, chunk + 1000)\n            ]\n        )\n        session.flush()\n    session.commit()\n```", "```py\npython -m examples.performance.bulk_inserts --test test_flush_no_pk\n```", "```py\n>>> users = session.scalars(\n...     insert(User).returning(User),\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n>>> print(users.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\n User(name='sandy', fullname='Sandy Cheeks'),\n User(name='patrick', fullname='Patrick Star'),\n User(name='squidward', fullname='Squidward Tentacles'),\n User(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> from sqlalchemy.dialects.sqlite import insert as sqlite_upsert\n>>> stmt = sqlite_upsert(User).values(\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ]\n... )\n>>> stmt = stmt.on_conflict_do_update(\n...     index_elements=[User.name], set_=dict(fullname=stmt.excluded.fullname)\n... )\n>>> result = session.scalars(stmt.returning(User))\n>>> print(result.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\nUser(name='sandy', fullname='Sandy Cheeks'),\nUser(name='patrick', fullname='Patrick Star'),\nUser(name='squidward', fullname='Squidward Tentacles'),\nUser(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> stmt = (\n...     update(User)\n...     .where(User.name == \"squidward\")\n...     .values(name=\"spongebob\")\n...     .returning(User)\n... )\n>>> result = session.scalars(stmt, execution_options={\"synchronize_session\": \"fetch\"})\n>>> print(result.all())\n```", "```py\nfrom sqlalchemy.orm import WriteOnlyMapped\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"account\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    identifier: Mapped[str]\n    account_transactions: WriteOnlyMapped[\"AccountTransaction\"] = relationship(\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        order_by=\"AccountTransaction.timestamp\",\n    )\n\nclass AccountTransaction(Base):\n    __tablename__ = \"account_transaction\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    account_id: Mapped[int] = mapped_column(\n        ForeignKey(\"account.id\", ondelete=\"cascade\")\n    )\n    description: Mapped[str]\n    amount: Mapped[Decimal]\n    timestamp: Mapped[datetime] = mapped_column(default=func.now())\n```", "```py\nnew_account = Account(\n    identifier=\"account_01\",\n    account_transactions=[\n        AccountTransaction(description=\"initial deposit\", amount=Decimal(\"500.00\")),\n        AccountTransaction(description=\"transfer\", amount=Decimal(\"1000.00\")),\n        AccountTransaction(description=\"withdrawal\", amount=Decimal(\"-29.50\")),\n    ],\n)\n\nnew_account.account_transactions.add(\n    AccountTransaction(description=\"transfer\", amount=Decimal(\"2000.00\"))\n)\n```", "```py\naccount_transactions = session.scalars(\n    existing_account.account_transactions.select()\n    .where(AccountTransaction.amount < 0)\n    .limit(10)\n).all()\n```", "```py\nfrom sqlalchemy.orm import DynamicMapped\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"account\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    identifier: Mapped[str]\n    account_transactions: DynamicMapped[\"AccountTransaction\"] = relationship(\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        order_by=\"AccountTransaction.timestamp\",\n    )\n\nclass AccountTransaction(Base):\n    __tablename__ = \"account_transaction\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    account_id: Mapped[int] = mapped_column(\n        ForeignKey(\"account.id\", ondelete=\"cascade\")\n    )\n    description: Mapped[str]\n    amount: Mapped[Decimal]\n    timestamp: Mapped[datetime] = mapped_column(default=func.now())\n```", "```py\nmeta = MetaData()\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(dialect=\"postgresql\"),\n    CheckConstraint(\"num > 5\").ddl_if(dialect=\"postgresql\"),\n)\n\ne1 = create_engine(\"sqlite://\", echo=True)\nmeta.create_all(e1)  # will not generate CHECK and INDEX\n\ne2 = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\nmeta.create_all(e2)  # will generate CHECK and INDEX\n```", "```py\n>>> import datetime\n\n>>> from sqlalchemy import DATETIME\n>>> from sqlalchemy import literal\n>>> from sqlalchemy.dialects import oracle\n>>> from sqlalchemy.dialects import postgresql\n\n>>> date_literal = literal(datetime.datetime.now(), DATETIME)\n\n>>> print(\n...     date_literal.compile(\n...         dialect=postgresql.dialect(), compile_kwargs={\"literal_binds\": True}\n...     )\n... )\n'2022-12-17 11:02:13.575789'\n>>> print(\n...     date_literal.compile(\n...         dialect=oracle.dialect(), compile_kwargs={\"literal_binds\": True}\n...     )\n... )\nTO_TIMESTAMP('2022-12-17 11:02:13.575789',  'YYYY-MM-DD HH24:MI:SS.FF') \n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nasync with async_engine.connect() as conn:\n    async with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nclass SomeTest(TestCase):\n    def setUp(self):\n        # connect to the database\n        self.connection = engine.connect()\n\n        # begin a non-ORM transaction\n        self.trans = self.connection.begin()\n\n        # bind an individual Session to the connection, selecting\n        # \"create_savepoint\" join_transaction_mode\n        self.session = Session(\n            bind=self.connection, join_transaction_mode=\"create_savepoint\"\n        )\n\n    def tearDown(self):\n        self.session.close()\n\n        # rollback non-ORM transaction\n        self.trans.rollback()\n\n        # return connection to the Engine\n        self.connection.close()\n```", "```py\nengine = create_engine(\"...\")\n\n# setup outer connection with a transaction and a SAVEPOINT\nconn = engine.connect()\ntrans = conn.begin()\nnested = conn.begin_nested()\n\n# bind a Session to that connection and operate upon it, including\n# a commit\nsession = Session(conn)\nsession.connection()\nsession.commit()\nsession.close()\n\n# assert both SAVEPOINT and transaction remain active\nassert nested.is_active\nnested.rollback()\ntrans.rollback()\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(str(e1.url))\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(e1.url)\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> url_string = e1.url.render_as_string(hide_password=False)\n>>> e2 = create_engine(url_string)\n```", "```py\nclass Foo:\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Bar:\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n\nclass Model(Base, Foo, Bar):\n    id = mapped_column(Integer, primary_key=True)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True)\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True, sort_order=-10)\n    col1 = mapped_column(Integer, sort_order=-1)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\n>>> # SQLAlchemy 1.3 (and 2.0)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq \n```", "```py\n>>> # SQLAlchemy 1.4 (only)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\n>>> # All SQLAlchemy versions\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\", start=1)))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\nimport typing\n\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.mysql import VARCHAR\n\ntype_ = String(255).with_variant(VARCHAR(255, charset=\"utf8mb4\"), \"mysql\", \"mariadb\")\n\nif typing.TYPE_CHECKING:\n    reveal_type(type_)\n```", "```py\ninfo: Type of \"type_\" is \"String\"\n```", "```py\nexpr = literal(5, Integer) / literal(10, Integer)\n```", "```py\n%(param_1)s  /  CAST(%(param_2)s  AS  NUMERIC)\n```", "```py\nexpr = literal(5, Integer) // literal(10, Integer)\n```", "```py\nFLOOR(%(param_1)s  /  %(param_2)s)\n```", "```py\nexpr = func.floor(literal(5, Integer) / literal(10, Integer))\n```", "```py\nTraceback (most recent call last):\nFile \"/home/classic/dev/sqlalchemy/test3.py\", line 30, in worker\n    sess.execute(select(A)).all()\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1691, in execute\n    conn = self._connection_for_bind(bind)\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1532, in _connection_for_bind\n    return self._transaction._connection_for_bind(\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 754, in _connection_for_bind\n    if self.session.twophase and self._parent is None:\nAttributeError: 'NoneType' object has no attribute 'twophase'\n```", "```py\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1785, in close\n   self._close_impl(invalidate=False)\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1827, in _close_impl\n   transaction.close(invalidate)\nFile \"<string>\", line 2, in close\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 506, in _go\n   raise sa_exc.InvalidRequestError(\nsqlalchemy.exc.InvalidRequestError: Method 'close()' can't be called here;\nmethod '_connection_for_bind()' is already in progress and this would cause\nan unexpected state change to symbol('CLOSED')\n```", "```py\nfrom sqlalchemy.dialects import oracle\n\nTable(\"some_table\", metadata, Column(\"value\", oracle.FLOAT(126)))\n```", "```py\nfrom sqlalchemy.types import Float\nfrom sqlalchemy.dialects import oracle\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"value\", Float(5).with_variant(oracle.FLOAT(16), \"oracle\")),\n)\n```", "```py\n    # (variable) str_col: ColumnClause[str]\n    str_col = column(\"a\", String)\n\n    # (variable) int_col: ColumnClause[int]\n    int_col = column(\"a\", Integer)\n\n    # (variable) expr1: ColumnElement[str]\n    expr1 = str_col + \"x\"\n\n    # (variable) expr2: ColumnElement[int]\n    expr2 = int_col + 10\n\n    # (variable) expr3: ColumnElement[bool]\n    expr3 = int_col == 15\n    ```", "```py\n    # (variable) stmt: Select[Tuple[str, int]]\n    stmt = select(str_col, int_col)\n\n    # (variable) stmt: ReturningInsert[Tuple[str, int]]\n    ins_stmt = insert(table(\"t\")).returning(str_col, int_col)\n    ```", "```py\n    with engine.connect() as conn:\n        # (variable) stmt: Select[Tuple[str, int]]\n        stmt = select(str_col, int_col)\n\n        # (variable) result: Result[Tuple[str, int]]\n        result = conn.execute(stmt)\n\n        # (variable) row: Row[Tuple[str, int]] | None\n        row = result.first()\n\n        if row is not None:\n            # for typed tuple unpacking or indexed access,\n            # use row.tuple() or row.t  (this is the small typing-oriented accessor)\n            strval, intval = row.t\n\n            # (variable) strval: str\n            strval\n\n            # (variable) intval: int\n            intval\n    ```", "```py\n    # (variable) data: Sequence[str]\n    data = connection.execute(select(str_col)).scalars().all()\n    ```", "```py\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import mapped_column\n\n    class Base(DeclarativeBase):\n        pass\n\n    class User(Base):\n        __tablename__ = \"user_account\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str]\n        addresses: Mapped[List[\"Address\"]] = relationship()\n\n    class Address(Base):\n        __tablename__ = \"address\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        email_address: Mapped[str]\n        user_id = mapped_column(ForeignKey(\"user_account.id\"))\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[int, str]]\n        stmt_1 = select(User.id, User.name)\n\n        # (variable) result_1: Result[Tuple[int, str]]\n        result_1 = session.execute(stmt_1)\n\n        # (variable) intval: int\n        # (variable) strval: str\n        intval, strval = result_1.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[User, Address]]\n        stmt_2 = select(User, Address).join_from(User, Address)\n\n        # (variable) result_2: Result[Tuple[User, Address]]\n        result_2 = session.execute(stmt_2)\n\n        # (variable) user_obj: User\n        # (variable) address_obj: Address\n        user_obj, address_obj = result_2.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # this is in fact an Annotated type, but typing tools don't\n        # generally display this\n\n        # (variable) u1: Type[User]\n        u1 = aliased(User)\n\n        # (variable) stmt: Select[Tuple[User, User, str]]\n        stmt = select(User, u1, User.name).filter(User.id == 5)\n\n        # (variable) result: Result[Tuple[User, User, str]]\n        result = session.execute(stmt)\n    ```", "```py\n    # (variable) users1: Sequence[User]\n    users1 = session.scalars(select(User)).all()\n\n    # (variable) user: User\n    user = session.query(User).one()\n\n    # (variable) user_iter: Iterator[User]\n    user_iter = iter(session.scalars(select(User)))\n    ```", "```py\n    # (variable) q1: RowReturningQuery[Tuple[int, str]]\n    q1 = session.query(User.id, User.name)\n\n    # (variable) rows: List[Row[Tuple[int, str]]]\n    rows = q1.all()\n\n    # (variable) q2: Query[User]\n    q2 = session.query(User)\n\n    # (variable) users: List[User]\n    users = q2.all()\n    ```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(30), nullable=False)\n    fullname = Column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(30), nullable=False)\n    fullname = mapped_column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String, nullable=False)\n    user_id = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(30), nullable=False)\n    fullname: Mapped[Optional[str]] = mapped_column(String)\n    addresses: Mapped[List[\"Address\"]] = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    email_address: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email_address: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\nfrom typing_extensions import Annotated\nfrom sqlalchemy.orm import DeclarativeBase\n\nstr50 = Annotated[str, 50]\n\n# declarative base with a type-level override, using a type that is\n# expected to be used in multiple places\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\n# declarative base from previous example\nstr50 = Annotated[str, 50]\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n\n# set up mapped_column() overrides, using whole column styles that are\n# expected to be used in multiple places\nintpk = Annotated[int, mapped_column(primary_key=True)]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk]\n    name: Mapped[str50]\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk]\n    email_address: Mapped[str50]\n    user_id: Mapped[user_fk]\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\n# (variable) stmt: Select[Tuple[int, str]]\nstmt = select(User.id, User.name)\n\nwith Session(e) as sess:\n    for row in sess.execute(stmt):\n        # (variable) row: Row[Tuple[int, str]]\n        print(row)\n\n    # (variable) users: Sequence[User]\n    users = sess.scalars(select(User)).all()\n\n    # (variable) users_legacy: List[User]\n    users_legacy = sess.query(User).all()\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import MappedAsDataclass\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(MappedAsDataclass, DeclarativeBase):\n  \"\"\"subclasses will be converted to dataclasses\"\"\"\n\nintpk = Annotated[int, mapped_column(primary_key=True)]\nstr30 = Annotated[str, mapped_column(String(30))]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    name: Mapped[str30]\n    fullname: Mapped[Optional[str]] = mapped_column(default=None)\n    addresses: Mapped[List[\"Address\"]] = relationship(\n        back_populates=\"user\", default_factory=list\n    )\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    email_address: Mapped[str]\n    user_id: Mapped[user_fk] = mapped_column(init=False)\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\", default=None)\n```", "```py\n>>> u1 = User(\"username\", fullname=\"full name\", addresses=[Address(\"email@address\")])\n>>> u1\nUser(id=None, name='username', fullname='full name', addresses=[Address(id=None, email_address='email@address', user_id=None, user=...)])\n```", "```py\n    # (variable) str_col: ColumnClause[str]\n    str_col = column(\"a\", String)\n\n    # (variable) int_col: ColumnClause[int]\n    int_col = column(\"a\", Integer)\n\n    # (variable) expr1: ColumnElement[str]\n    expr1 = str_col + \"x\"\n\n    # (variable) expr2: ColumnElement[int]\n    expr2 = int_col + 10\n\n    # (variable) expr3: ColumnElement[bool]\n    expr3 = int_col == 15\n    ```", "```py\n    # (variable) stmt: Select[Tuple[str, int]]\n    stmt = select(str_col, int_col)\n\n    # (variable) stmt: ReturningInsert[Tuple[str, int]]\n    ins_stmt = insert(table(\"t\")).returning(str_col, int_col)\n    ```", "```py\n    with engine.connect() as conn:\n        # (variable) stmt: Select[Tuple[str, int]]\n        stmt = select(str_col, int_col)\n\n        # (variable) result: Result[Tuple[str, int]]\n        result = conn.execute(stmt)\n\n        # (variable) row: Row[Tuple[str, int]] | None\n        row = result.first()\n\n        if row is not None:\n            # for typed tuple unpacking or indexed access,\n            # use row.tuple() or row.t  (this is the small typing-oriented accessor)\n            strval, intval = row.t\n\n            # (variable) strval: str\n            strval\n\n            # (variable) intval: int\n            intval\n    ```", "```py\n    # (variable) data: Sequence[str]\n    data = connection.execute(select(str_col)).scalars().all()\n    ```", "```py\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import mapped_column\n\n    class Base(DeclarativeBase):\n        pass\n\n    class User(Base):\n        __tablename__ = \"user_account\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str]\n        addresses: Mapped[List[\"Address\"]] = relationship()\n\n    class Address(Base):\n        __tablename__ = \"address\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        email_address: Mapped[str]\n        user_id = mapped_column(ForeignKey(\"user_account.id\"))\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[int, str]]\n        stmt_1 = select(User.id, User.name)\n\n        # (variable) result_1: Result[Tuple[int, str]]\n        result_1 = session.execute(stmt_1)\n\n        # (variable) intval: int\n        # (variable) strval: str\n        intval, strval = result_1.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[User, Address]]\n        stmt_2 = select(User, Address).join_from(User, Address)\n\n        # (variable) result_2: Result[Tuple[User, Address]]\n        result_2 = session.execute(stmt_2)\n\n        # (variable) user_obj: User\n        # (variable) address_obj: Address\n        user_obj, address_obj = result_2.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # this is in fact an Annotated type, but typing tools don't\n        # generally display this\n\n        # (variable) u1: Type[User]\n        u1 = aliased(User)\n\n        # (variable) stmt: Select[Tuple[User, User, str]]\n        stmt = select(User, u1, User.name).filter(User.id == 5)\n\n        # (variable) result: Result[Tuple[User, User, str]]\n        result = session.execute(stmt)\n    ```", "```py\n    # (variable) users1: Sequence[User]\n    users1 = session.scalars(select(User)).all()\n\n    # (variable) user: User\n    user = session.query(User).one()\n\n    # (variable) user_iter: Iterator[User]\n    user_iter = iter(session.scalars(select(User)))\n    ```", "```py\n    # (variable) q1: RowReturningQuery[Tuple[int, str]]\n    q1 = session.query(User.id, User.name)\n\n    # (variable) rows: List[Row[Tuple[int, str]]]\n    rows = q1.all()\n\n    # (variable) q2: Query[User]\n    q2 = session.query(User)\n\n    # (variable) users: List[User]\n    users = q2.all()\n    ```", "```py\n    # (variable) str_col: ColumnClause[str]\n    str_col = column(\"a\", String)\n\n    # (variable) int_col: ColumnClause[int]\n    int_col = column(\"a\", Integer)\n\n    # (variable) expr1: ColumnElement[str]\n    expr1 = str_col + \"x\"\n\n    # (variable) expr2: ColumnElement[int]\n    expr2 = int_col + 10\n\n    # (variable) expr3: ColumnElement[bool]\n    expr3 = int_col == 15\n    ```", "```py\n    # (variable) stmt: Select[Tuple[str, int]]\n    stmt = select(str_col, int_col)\n\n    # (variable) stmt: ReturningInsert[Tuple[str, int]]\n    ins_stmt = insert(table(\"t\")).returning(str_col, int_col)\n    ```", "```py\n    with engine.connect() as conn:\n        # (variable) stmt: Select[Tuple[str, int]]\n        stmt = select(str_col, int_col)\n\n        # (variable) result: Result[Tuple[str, int]]\n        result = conn.execute(stmt)\n\n        # (variable) row: Row[Tuple[str, int]] | None\n        row = result.first()\n\n        if row is not None:\n            # for typed tuple unpacking or indexed access,\n            # use row.tuple() or row.t  (this is the small typing-oriented accessor)\n            strval, intval = row.t\n\n            # (variable) strval: str\n            strval\n\n            # (variable) intval: int\n            intval\n    ```", "```py\n    # (variable) data: Sequence[str]\n    data = connection.execute(select(str_col)).scalars().all()\n    ```", "```py\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import mapped_column\n\n    class Base(DeclarativeBase):\n        pass\n\n    class User(Base):\n        __tablename__ = \"user_account\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str]\n        addresses: Mapped[List[\"Address\"]] = relationship()\n\n    class Address(Base):\n        __tablename__ = \"address\"\n\n        id: Mapped[int] = mapped_column(primary_key=True)\n        email_address: Mapped[str]\n        user_id = mapped_column(ForeignKey(\"user_account.id\"))\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[int, str]]\n        stmt_1 = select(User.id, User.name)\n\n        # (variable) result_1: Result[Tuple[int, str]]\n        result_1 = session.execute(stmt_1)\n\n        # (variable) intval: int\n        # (variable) strval: str\n        intval, strval = result_1.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # (variable) stmt: Select[Tuple[User, Address]]\n        stmt_2 = select(User, Address).join_from(User, Address)\n\n        # (variable) result_2: Result[Tuple[User, Address]]\n        result_2 = session.execute(stmt_2)\n\n        # (variable) user_obj: User\n        # (variable) address_obj: Address\n        user_obj, address_obj = result_2.one().t\n    ```", "```py\n    with Session(engine) as session:\n        # this is in fact an Annotated type, but typing tools don't\n        # generally display this\n\n        # (variable) u1: Type[User]\n        u1 = aliased(User)\n\n        # (variable) stmt: Select[Tuple[User, User, str]]\n        stmt = select(User, u1, User.name).filter(User.id == 5)\n\n        # (variable) result: Result[Tuple[User, User, str]]\n        result = session.execute(stmt)\n    ```", "```py\n    # (variable) users1: Sequence[User]\n    users1 = session.scalars(select(User)).all()\n\n    # (variable) user: User\n    user = session.query(User).one()\n\n    # (variable) user_iter: Iterator[User]\n    user_iter = iter(session.scalars(select(User)))\n    ```", "```py\n    # (variable) q1: RowReturningQuery[Tuple[int, str]]\n    q1 = session.query(User.id, User.name)\n\n    # (variable) rows: List[Row[Tuple[int, str]]]\n    rows = q1.all()\n\n    # (variable) q2: Query[User]\n    q2 = session.query(User)\n\n    # (variable) users: List[User]\n    users = q2.all()\n    ```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(30), nullable=False)\n    fullname = Column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(30), nullable=False)\n    fullname = mapped_column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String, nullable=False)\n    user_id = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(30), nullable=False)\n    fullname: Mapped[Optional[str]] = mapped_column(String)\n    addresses: Mapped[List[\"Address\"]] = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    email_address: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email_address: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\nfrom typing_extensions import Annotated\nfrom sqlalchemy.orm import DeclarativeBase\n\nstr50 = Annotated[str, 50]\n\n# declarative base with a type-level override, using a type that is\n# expected to be used in multiple places\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\n# declarative base from previous example\nstr50 = Annotated[str, 50]\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n\n# set up mapped_column() overrides, using whole column styles that are\n# expected to be used in multiple places\nintpk = Annotated[int, mapped_column(primary_key=True)]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk]\n    name: Mapped[str50]\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk]\n    email_address: Mapped[str50]\n    user_id: Mapped[user_fk]\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\n# (variable) stmt: Select[Tuple[int, str]]\nstmt = select(User.id, User.name)\n\nwith Session(e) as sess:\n    for row in sess.execute(stmt):\n        # (variable) row: Row[Tuple[int, str]]\n        print(row)\n\n    # (variable) users: Sequence[User]\n    users = sess.scalars(select(User)).all()\n\n    # (variable) users_legacy: List[User]\n    users_legacy = sess.query(User).all()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(30), nullable=False)\n    fullname = Column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(30), nullable=False)\n    fullname = mapped_column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String, nullable=False)\n    user_id = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(30), nullable=False)\n    fullname: Mapped[Optional[str]] = mapped_column(String)\n    addresses: Mapped[List[\"Address\"]] = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    email_address: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email_address: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\nfrom typing_extensions import Annotated\nfrom sqlalchemy.orm import DeclarativeBase\n\nstr50 = Annotated[str, 50]\n\n# declarative base with a type-level override, using a type that is\n# expected to be used in multiple places\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\n# declarative base from previous example\nstr50 = Annotated[str, 50]\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n\n# set up mapped_column() overrides, using whole column styles that are\n# expected to be used in multiple places\nintpk = Annotated[int, mapped_column(primary_key=True)]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk]\n    name: Mapped[str50]\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk]\n    email_address: Mapped[str50]\n    user_id: Mapped[user_fk]\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\n# (variable) stmt: Select[Tuple[int, str]]\nstmt = select(User.id, User.name)\n\nwith Session(e) as sess:\n    for row in sess.execute(stmt):\n        # (variable) row: Row[Tuple[int, str]]\n        print(row)\n\n    # (variable) users: Sequence[User]\n    users = sess.scalars(select(User)).all()\n\n    # (variable) users_legacy: List[User]\n    users_legacy = sess.query(User).all()\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(30), nullable=False)\n    fullname = Column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(30), nullable=False)\n    fullname = mapped_column(String)\n    addresses = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String, nullable=False)\n    user_id = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(30), nullable=False)\n    fullname: Mapped[Optional[str]] = mapped_column(String)\n    addresses: Mapped[List[\"Address\"]] = relationship(\"Address\", back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    email_address: Mapped[str] = mapped_column(String, nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"), nullable=False)\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"addresses\")\n```", "```py\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email_address: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\nfrom typing_extensions import Annotated\nfrom sqlalchemy.orm import DeclarativeBase\n\nstr50 = Annotated[str, 50]\n\n# declarative base with a type-level override, using a type that is\n# expected to be used in multiple places\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\n# declarative base from previous example\nstr50 = Annotated[str, 50]\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        str50: String(50),\n    }\n\n# set up mapped_column() overrides, using whole column styles that are\n# expected to be used in multiple places\nintpk = Annotated[int, mapped_column(primary_key=True)]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk]\n    name: Mapped[str50]\n    fullname: Mapped[Optional[str]]\n    addresses: Mapped[List[\"Address\"]] = relationship(back_populates=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk]\n    email_address: Mapped[str50]\n    user_id: Mapped[user_fk]\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\")\n```", "```py\n# (variable) stmt: Select[Tuple[int, str]]\nstmt = select(User.id, User.name)\n\nwith Session(e) as sess:\n    for row in sess.execute(stmt):\n        # (variable) row: Row[Tuple[int, str]]\n        print(row)\n\n    # (variable) users: Sequence[User]\n    users = sess.scalars(select(User)).all()\n\n    # (variable) users_legacy: List[User]\n    users_legacy = sess.query(User).all()\n```", "```py\nfrom typing_extensions import Annotated\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import MappedAsDataclass\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(MappedAsDataclass, DeclarativeBase):\n  \"\"\"subclasses will be converted to dataclasses\"\"\"\n\nintpk = Annotated[int, mapped_column(primary_key=True)]\nstr30 = Annotated[str, mapped_column(String(30))]\nuser_fk = Annotated[int, mapped_column(ForeignKey(\"user_account.id\"))]\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    name: Mapped[str30]\n    fullname: Mapped[Optional[str]] = mapped_column(default=None)\n    addresses: Mapped[List[\"Address\"]] = relationship(\n        back_populates=\"user\", default_factory=list\n    )\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id: Mapped[intpk] = mapped_column(init=False)\n    email_address: Mapped[str]\n    user_id: Mapped[user_fk] = mapped_column(init=False)\n    user: Mapped[\"User\"] = relationship(back_populates=\"addresses\", default=None)\n```", "```py\n>>> u1 = User(\"username\", fullname=\"full name\", addresses=[Address(\"email@address\")])\n>>> u1\nUser(id=None, name='username', fullname='full name', addresses=[Address(id=None, email_address='email@address', user_id=None, user=...)])\n```", "```py\n@Profiler.profile\ndef test_flush_no_pk(n):\n  \"\"\"INSERT statements via the ORM (batched with RETURNING if available),\n fetching generated row id\"\"\"\n    session = Session(bind=engine)\n    for chunk in range(0, n, 1000):\n        session.add_all(\n            [\n                Customer(\n                    name=\"customer name %d\" % i,\n                    description=\"customer description %d\" % i,\n                )\n                for i in range(chunk, chunk + 1000)\n            ]\n        )\n        session.flush()\n    session.commit()\n```", "```py\npython -m examples.performance.bulk_inserts --test test_flush_no_pk\n```", "```py\n@Profiler.profile\ndef test_flush_no_pk(n):\n  \"\"\"INSERT statements via the ORM (batched with RETURNING if available),\n fetching generated row id\"\"\"\n    session = Session(bind=engine)\n    for chunk in range(0, n, 1000):\n        session.add_all(\n            [\n                Customer(\n                    name=\"customer name %d\" % i,\n                    description=\"customer description %d\" % i,\n                )\n                for i in range(chunk, chunk + 1000)\n            ]\n        )\n        session.flush()\n    session.commit()\n```", "```py\npython -m examples.performance.bulk_inserts --test test_flush_no_pk\n```", "```py\n>>> users = session.scalars(\n...     insert(User).returning(User),\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n>>> print(users.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\n User(name='sandy', fullname='Sandy Cheeks'),\n User(name='patrick', fullname='Patrick Star'),\n User(name='squidward', fullname='Squidward Tentacles'),\n User(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> from sqlalchemy.dialects.sqlite import insert as sqlite_upsert\n>>> stmt = sqlite_upsert(User).values(\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ]\n... )\n>>> stmt = stmt.on_conflict_do_update(\n...     index_elements=[User.name], set_=dict(fullname=stmt.excluded.fullname)\n... )\n>>> result = session.scalars(stmt.returning(User))\n>>> print(result.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\nUser(name='sandy', fullname='Sandy Cheeks'),\nUser(name='patrick', fullname='Patrick Star'),\nUser(name='squidward', fullname='Squidward Tentacles'),\nUser(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> stmt = (\n...     update(User)\n...     .where(User.name == \"squidward\")\n...     .values(name=\"spongebob\")\n...     .returning(User)\n... )\n>>> result = session.scalars(stmt, execution_options={\"synchronize_session\": \"fetch\"})\n>>> print(result.all())\n```", "```py\n>>> users = session.scalars(\n...     insert(User).returning(User),\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ],\n... )\n>>> print(users.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\n User(name='sandy', fullname='Sandy Cheeks'),\n User(name='patrick', fullname='Patrick Star'),\n User(name='squidward', fullname='Squidward Tentacles'),\n User(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> session.execute(\n...     update(User),\n...     [\n...         {\"id\": 1, \"fullname\": \"Spongebob Squarepants\"},\n...         {\"id\": 3, \"fullname\": \"Patrick Star\"},\n...     ],\n... )\n```", "```py\n>>> from sqlalchemy.dialects.sqlite import insert as sqlite_upsert\n>>> stmt = sqlite_upsert(User).values(\n...     [\n...         {\"name\": \"spongebob\", \"fullname\": \"Spongebob Squarepants\"},\n...         {\"name\": \"sandy\", \"fullname\": \"Sandy Cheeks\"},\n...         {\"name\": \"patrick\", \"fullname\": \"Patrick Star\"},\n...         {\"name\": \"squidward\", \"fullname\": \"Squidward Tentacles\"},\n...         {\"name\": \"ehkrabs\", \"fullname\": \"Eugene H. Krabs\"},\n...     ]\n... )\n>>> stmt = stmt.on_conflict_do_update(\n...     index_elements=[User.name], set_=dict(fullname=stmt.excluded.fullname)\n... )\n>>> result = session.scalars(stmt.returning(User))\n>>> print(result.all())\n[User(name='spongebob', fullname='Spongebob Squarepants'),\nUser(name='sandy', fullname='Sandy Cheeks'),\nUser(name='patrick', fullname='Patrick Star'),\nUser(name='squidward', fullname='Squidward Tentacles'),\nUser(name='ehkrabs', fullname='Eugene H. Krabs')]\n```", "```py\n>>> from sqlalchemy import update\n>>> stmt = (\n...     update(User)\n...     .where(User.name == \"squidward\")\n...     .values(name=\"spongebob\")\n...     .returning(User)\n... )\n>>> result = session.scalars(stmt, execution_options={\"synchronize_session\": \"fetch\"})\n>>> print(result.all())\n```", "```py\nfrom sqlalchemy.orm import WriteOnlyMapped\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"account\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    identifier: Mapped[str]\n    account_transactions: WriteOnlyMapped[\"AccountTransaction\"] = relationship(\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        order_by=\"AccountTransaction.timestamp\",\n    )\n\nclass AccountTransaction(Base):\n    __tablename__ = \"account_transaction\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    account_id: Mapped[int] = mapped_column(\n        ForeignKey(\"account.id\", ondelete=\"cascade\")\n    )\n    description: Mapped[str]\n    amount: Mapped[Decimal]\n    timestamp: Mapped[datetime] = mapped_column(default=func.now())\n```", "```py\nnew_account = Account(\n    identifier=\"account_01\",\n    account_transactions=[\n        AccountTransaction(description=\"initial deposit\", amount=Decimal(\"500.00\")),\n        AccountTransaction(description=\"transfer\", amount=Decimal(\"1000.00\")),\n        AccountTransaction(description=\"withdrawal\", amount=Decimal(\"-29.50\")),\n    ],\n)\n\nnew_account.account_transactions.add(\n    AccountTransaction(description=\"transfer\", amount=Decimal(\"2000.00\"))\n)\n```", "```py\naccount_transactions = session.scalars(\n    existing_account.account_transactions.select()\n    .where(AccountTransaction.amount < 0)\n    .limit(10)\n).all()\n```", "```py\nfrom sqlalchemy.orm import DynamicMapped\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"account\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    identifier: Mapped[str]\n    account_transactions: DynamicMapped[\"AccountTransaction\"] = relationship(\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        order_by=\"AccountTransaction.timestamp\",\n    )\n\nclass AccountTransaction(Base):\n    __tablename__ = \"account_transaction\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    account_id: Mapped[int] = mapped_column(\n        ForeignKey(\"account.id\", ondelete=\"cascade\")\n    )\n    description: Mapped[str]\n    amount: Mapped[Decimal]\n    timestamp: Mapped[datetime] = mapped_column(default=func.now())\n```", "```py\nfrom sqlalchemy.orm import DynamicMapped\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"account\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    identifier: Mapped[str]\n    account_transactions: DynamicMapped[\"AccountTransaction\"] = relationship(\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        order_by=\"AccountTransaction.timestamp\",\n    )\n\nclass AccountTransaction(Base):\n    __tablename__ = \"account_transaction\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    account_id: Mapped[int] = mapped_column(\n        ForeignKey(\"account.id\", ondelete=\"cascade\")\n    )\n    description: Mapped[str]\n    amount: Mapped[Decimal]\n    timestamp: Mapped[datetime] = mapped_column(default=func.now())\n```", "```py\nmeta = MetaData()\n\nmy_table = Table(\n    \"my_table\",\n    meta,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"num\", Integer),\n    Column(\"data\", String),\n    Index(\"my_pg_index\", \"data\").ddl_if(dialect=\"postgresql\"),\n    CheckConstraint(\"num > 5\").ddl_if(dialect=\"postgresql\"),\n)\n\ne1 = create_engine(\"sqlite://\", echo=True)\nmeta.create_all(e1)  # will not generate CHECK and INDEX\n\ne2 = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=True)\nmeta.create_all(e2)  # will generate CHECK and INDEX\n```", "```py\n>>> import datetime\n\n>>> from sqlalchemy import DATETIME\n>>> from sqlalchemy import literal\n>>> from sqlalchemy.dialects import oracle\n>>> from sqlalchemy.dialects import postgresql\n\n>>> date_literal = literal(datetime.datetime.now(), DATETIME)\n\n>>> print(\n...     date_literal.compile(\n...         dialect=postgresql.dialect(), compile_kwargs={\"literal_binds\": True}\n...     )\n... )\n'2022-12-17 11:02:13.575789'\n>>> print(\n...     date_literal.compile(\n...         dialect=oracle.dialect(), compile_kwargs={\"literal_binds\": True}\n...     )\n... )\nTO_TIMESTAMP('2022-12-17 11:02:13.575789',  'YYYY-MM-DD HH24:MI:SS.FF') \n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nasync with async_engine.connect() as conn:\n    async with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nclass SomeTest(TestCase):\n    def setUp(self):\n        # connect to the database\n        self.connection = engine.connect()\n\n        # begin a non-ORM transaction\n        self.trans = self.connection.begin()\n\n        # bind an individual Session to the connection, selecting\n        # \"create_savepoint\" join_transaction_mode\n        self.session = Session(\n            bind=self.connection, join_transaction_mode=\"create_savepoint\"\n        )\n\n    def tearDown(self):\n        self.session.close()\n\n        # rollback non-ORM transaction\n        self.trans.rollback()\n\n        # return connection to the Engine\n        self.connection.close()\n```", "```py\nengine = create_engine(\"...\")\n\n# setup outer connection with a transaction and a SAVEPOINT\nconn = engine.connect()\ntrans = conn.begin()\nnested = conn.begin_nested()\n\n# bind a Session to that connection and operate upon it, including\n# a commit\nsession = Session(conn)\nsession.connection()\nsession.commit()\nsession.close()\n\n# assert both SAVEPOINT and transaction remain active\nassert nested.is_active\nnested.rollback()\ntrans.rollback()\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(str(e1.url))\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(e1.url)\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> url_string = e1.url.render_as_string(hide_password=False)\n>>> e2 = create_engine(url_string)\n```", "```py\nclass Foo:\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Bar:\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n\nclass Model(Base, Foo, Bar):\n    id = mapped_column(Integer, primary_key=True)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True)\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True, sort_order=-10)\n    col1 = mapped_column(Integer, sort_order=-1)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\n>>> # SQLAlchemy 1.3 (and 2.0)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq \n```", "```py\n>>> # SQLAlchemy 1.4 (only)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\n>>> # All SQLAlchemy versions\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\", start=1)))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\nimport typing\n\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.mysql import VARCHAR\n\ntype_ = String(255).with_variant(VARCHAR(255, charset=\"utf8mb4\"), \"mysql\", \"mariadb\")\n\nif typing.TYPE_CHECKING:\n    reveal_type(type_)\n```", "```py\ninfo: Type of \"type_\" is \"String\"\n```", "```py\nexpr = literal(5, Integer) / literal(10, Integer)\n```", "```py\n%(param_1)s  /  CAST(%(param_2)s  AS  NUMERIC)\n```", "```py\nexpr = literal(5, Integer) // literal(10, Integer)\n```", "```py\nFLOOR(%(param_1)s  /  %(param_2)s)\n```", "```py\nexpr = func.floor(literal(5, Integer) / literal(10, Integer))\n```", "```py\nTraceback (most recent call last):\nFile \"/home/classic/dev/sqlalchemy/test3.py\", line 30, in worker\n    sess.execute(select(A)).all()\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1691, in execute\n    conn = self._connection_for_bind(bind)\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1532, in _connection_for_bind\n    return self._transaction._connection_for_bind(\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 754, in _connection_for_bind\n    if self.session.twophase and self._parent is None:\nAttributeError: 'NoneType' object has no attribute 'twophase'\n```", "```py\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1785, in close\n   self._close_impl(invalidate=False)\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1827, in _close_impl\n   transaction.close(invalidate)\nFile \"<string>\", line 2, in close\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 506, in _go\n   raise sa_exc.InvalidRequestError(\nsqlalchemy.exc.InvalidRequestError: Method 'close()' can't be called here;\nmethod '_connection_for_bind()' is already in progress and this would cause\nan unexpected state change to symbol('CLOSED')\n```", "```py\nfrom sqlalchemy.dialects import oracle\n\nTable(\"some_table\", metadata, Column(\"value\", oracle.FLOAT(126)))\n```", "```py\nfrom sqlalchemy.types import Float\nfrom sqlalchemy.dialects import oracle\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"value\", Float(5).with_variant(oracle.FLOAT(16), \"oracle\")),\n)\n```", "```py\nclass SomeTest(TestCase):\n    def setUp(self):\n        # connect to the database\n        self.connection = engine.connect()\n\n        # begin a non-ORM transaction\n        self.trans = self.connection.begin()\n\n        # bind an individual Session to the connection, selecting\n        # \"create_savepoint\" join_transaction_mode\n        self.session = Session(\n            bind=self.connection, join_transaction_mode=\"create_savepoint\"\n        )\n\n    def tearDown(self):\n        self.session.close()\n\n        # rollback non-ORM transaction\n        self.trans.rollback()\n\n        # return connection to the Engine\n        self.connection.close()\n```", "```py\nengine = create_engine(\"...\")\n\n# setup outer connection with a transaction and a SAVEPOINT\nconn = engine.connect()\ntrans = conn.begin()\nnested = conn.begin_nested()\n\n# bind a Session to that connection and operate upon it, including\n# a commit\nsession = Session(conn)\nsession.connection()\nsession.commit()\nsession.close()\n\n# assert both SAVEPOINT and transaction remain active\nassert nested.is_active\nnested.rollback()\ntrans.rollback()\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(str(e1.url))\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> e2 = create_engine(e1.url)\n```", "```py\n>>> e1 = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n>>> url_string = e1.url.render_as_string(hide_password=False)\n>>> e2 = create_engine(url_string)\n```", "```py\nclass Foo:\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Bar:\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n\nclass Model(Base, Foo, Bar):\n    id = mapped_column(Integer, primary_key=True)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True)\n    col1 = mapped_column(Integer)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  col2  INTEGER,\n  col4  INTEGER,\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass Foo:\n    id = mapped_column(Integer, primary_key=True, sort_order=-10)\n    col1 = mapped_column(Integer, sort_order=-1)\n    col3 = mapped_column(Integer)\n\nclass Model(Foo, Base):\n    col2 = mapped_column(Integer)\n    col4 = mapped_column(Integer)\n    __tablename__ = \"model\"\n```", "```py\nCREATE  TABLE  model  (\n  id  INTEGER  NOT  NULL,\n  col1  INTEGER,\n  col2  INTEGER,\n  col4  INTEGER,\n  col3  INTEGER,\n  PRIMARY  KEY  (id)\n)\n```", "```py\n>>> # SQLAlchemy 1.3 (and 2.0)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq \n```", "```py\n>>> # SQLAlchemy 1.4 (only)\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\")))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\n>>> # All SQLAlchemy versions\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> print(CreateSequence(Sequence(\"my_seq\", start=1)))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\nimport typing\n\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.mysql import VARCHAR\n\ntype_ = String(255).with_variant(VARCHAR(255, charset=\"utf8mb4\"), \"mysql\", \"mariadb\")\n\nif typing.TYPE_CHECKING:\n    reveal_type(type_)\n```", "```py\ninfo: Type of \"type_\" is \"String\"\n```", "```py\nexpr = literal(5, Integer) / literal(10, Integer)\n```", "```py\n%(param_1)s  /  CAST(%(param_2)s  AS  NUMERIC)\n```", "```py\nexpr = literal(5, Integer) // literal(10, Integer)\n```", "```py\nFLOOR(%(param_1)s  /  %(param_2)s)\n```", "```py\nexpr = func.floor(literal(5, Integer) / literal(10, Integer))\n```", "```py\nTraceback (most recent call last):\nFile \"/home/classic/dev/sqlalchemy/test3.py\", line 30, in worker\n    sess.execute(select(A)).all()\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1691, in execute\n    conn = self._connection_for_bind(bind)\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1532, in _connection_for_bind\n    return self._transaction._connection_for_bind(\nFile \"/home/classic/tmp/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 754, in _connection_for_bind\n    if self.session.twophase and self._parent is None:\nAttributeError: 'NoneType' object has no attribute 'twophase'\n```", "```py\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1785, in close\n   self._close_impl(invalidate=False)\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 1827, in _close_impl\n   transaction.close(invalidate)\nFile \"<string>\", line 2, in close\nFile \"/home/classic/dev/sqlalchemy/lib/sqlalchemy/orm/session.py\", line 506, in _go\n   raise sa_exc.InvalidRequestError(\nsqlalchemy.exc.InvalidRequestError: Method 'close()' can't be called here;\nmethod '_connection_for_bind()' is already in progress and this would cause\nan unexpected state change to symbol('CLOSED')\n```", "```py\nfrom sqlalchemy.dialects import oracle\n\nTable(\"some_table\", metadata, Column(\"value\", oracle.FLOAT(126)))\n```", "```py\nfrom sqlalchemy.types import Float\nfrom sqlalchemy.dialects import oracle\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"value\", Float(5).with_variant(oracle.FLOAT(16), \"oracle\")),\n)\n```"]