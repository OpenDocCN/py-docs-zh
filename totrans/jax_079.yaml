- en: 'JEP 18137: Scope of JAX NumPy & SciPy Wrappers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 18137：JAX NumPy 和 SciPy 包的范围
- en: 原文：[`jax.readthedocs.io/en/latest/jep/18137-numpy-scipy-scope.html`](https://jax.readthedocs.io/en/latest/jep/18137-numpy-scipy-scope.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jax.readthedocs.io/en/latest/jep/18137-numpy-scipy-scope.html`](https://jax.readthedocs.io/en/latest/jep/18137-numpy-scipy-scope.html)
- en: '*Jake VanderPlas*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jake VanderPlas*'
- en: '*October 2023*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*2023 年 10 月*'
- en: Until now, the intended scope of `jax.numpy` and `jax.scipy` has been relatively
    ill-defined. This document proposes a well-defined scope for these packages to
    better guide and evaluate future contributions, and to motivate the removal of
    some out-of-scope code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`jax.numpy` 和 `jax.scipy` 的预期范围相对模糊。本文提出了这些包的明确定义范围，以更好地指导和评估未来的贡献，并促使移除一些超出范围的代码。
- en: Background
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: From the beginning, JAX has aimed to provide a NumPy-like API for executing
    code in XLA, and a big part of the project’s development has been building out
    the `jax.numpy` and `jax.scipy` namespaces as JAX-based implementations of NumPy
    and SciPy APIs. There has always been an implicit understanding that some parts
    of [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy "(in
    NumPy v2.0)") and [`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(in SciPy v1.13.1)") are out-of-scope for JAX, but this scope has not been well
    defined. This can lead to confusion and frustration for contributors, because
    there’s no clear answer to whether potential `jax.numpy` and `jax.scipy` contributions
    will be accepted into JAX.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，JAX 的目标是为在 XLA 中执行代码提供类似于 NumPy 的 API，项目的发展的一大部分是建立 `jax.numpy` 和 `jax.scipy`
    命名空间，作为基于 JAX 的 NumPy 和 SciPy API 实现。一直有一个隐含的认识，即[`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(在 NumPy v2.0 中)")和 [`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(在 SciPy v1.13.1 中)") 的某些部分超出了 JAX 的范围，但这一范围并没有明确定义。这可能会导致贡献者困惑和沮丧，因为对于潜在的 `jax.numpy`
    和 `jax.scipy` 贡献是否会被接受，没有明确的答案。
- en: Why Limit the Scope?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么限制范围？
- en: 'To avoid leaving this unsaid, we should be explicit: it is a fact that any
    code included in a project like JAX incurs a small but nonzero ongoing maintenance
    burden for the developers. The success of a project over time directly relates
    to the ability of maintainers to continue this maintenance for the sum of all
    the project’s parts: documenting functionality, responding to questions, fixing
    bugs, etc. For long-term success and sustainability of any software tool, it’s
    vital that maintainers carefully weigh whether any particular contribution will
    be a net positive for the project given its goals and resources.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免遗漏，我们应该明确一点：像 JAX 这样的项目中包含的任何代码都会为开发者带来一定的持续维护负担，虽然小但非零。项目长期成功直接与维护者能否继续为项目的所有部分承担维护工作有关：包括文档功能的记录、回答问题、修复错误等。对于任何软件工具的长期成功和可持续性，维护者必须仔细权衡每一项贡献是否对项目的目标和资源是净正面影响。
- en: Evaluation Rubric
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估标准
- en: This document proposes a rubric of six axes along which the scope of any particular
    [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy "(in
    NumPy v2.0)") or [`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(in SciPy v1.13.1)") API can be judged for inclusion into JAX. An API which is
    strong along all axes is an excellent candidate for inclusion in the JAX package;
    a strong weakness along *any* of the six axes is a good argument against inclusion
    in JAX.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本文提出了一个六轴评估标准，用来评判任何特定[`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(在 NumPy v2.0 中)")或[`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(在 SciPy v1.13.1 中)") API 的适用范围，以确定是否适合纳入 JAX。在所有轴上表现强劲的 API 是纳入 JAX 包的极佳候选；在六个轴中的任何一个上表现极差都是不适合纳入
    JAX 的充分理由。
- en: 'Axis 1: XLA alignment'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轴 1：XLA 对齐
- en: 'The first axis we consider is the degree to which the proposed API aligns with
    native XLA operations. For example, `jax.numpy.exp()` is a function that more-or-less
    directly mirrors `jax.lax.exp`. A large number of functions in [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(in NumPy v2.0)"), [`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(in SciPy v1.13.1)"), [`numpy.linalg`](https://numpy.org/doc/stable/reference/routines.linalg.html#module-numpy.linalg
    "(in NumPy v2.0)"), `scipy.linalg`, and others meet this criteria: such functions
    pass the XLA-alignment check when considering their inclusion into JAX.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的第一个方向是建议 API 与本地 XLA 操作的对齐程度。例如，`jax.numpy.exp()` 函数几乎直接镜像了 `jax.lax.exp`。[`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(在 NumPy v2.0)")、[`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(在 SciPy v1.13.1)")、[`numpy.linalg`](https://numpy.org/doc/stable/reference/routines.linalg.html#module-numpy.linalg
    "(在 NumPy v2.0)")、`scipy.linalg` 等中的大多数函数符合此标准：这类函数在考虑其是否应包含在 JAX 中时通过了 XLA 对齐检查。
- en: On the other end, there are functions like [`numpy.unique()`](https://numpy.org/doc/stable/reference/generated/numpy.unique.html#numpy.unique
    "(in NumPy v2.0)"), which do not directly correspond to any XLA operation, and
    in some cases are fundamentally incompatible with JAX’s current computational
    model, which requires statically-shaped arrays (e.g. `unique` returns a value-dependent
    dynamic array shape). Such functions do not pass the XLA alignment check when
    considering their inclusion into JAX.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有些函数如[`numpy.unique()`](https://numpy.org/doc/stable/reference/generated/numpy.unique.html#numpy.unique
    "(在 NumPy v2.0)")，它们不直接对应任何 XLA 操作，在某些情况下甚至与 JAX 的当前计算模型根本不兼容，后者要求静态形状的数组（例如 `unique`
    返回依赖于值的动态数组形状）。这类函数在考虑其是否应包含在 JAX 中时未能通过 XLA 对齐检查。
- en: We also consider as part of this axis the need for pure function semantics.
    For example, [`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0)") is built on an implicitly-updated state-based RNG, which is
    fundamentally incompatible with JAX’s computational model built on XLA.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑纯函数语义的必要性。例如，[`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(在 NumPy v2.0)") 基于一个隐式更新的基于状态的随机数生成器，这与基于 XLA 的 JAX 计算模型根本不兼容。
- en: 'Axis 2: Array API Alignment'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轴 2：数组 API 对齐
- en: 'The second axis we consider focuses on the [Python Array API Standard](https://data-apis.org/array-api/2022.12/):
    this is in some senses a community-driven outline of which array operations are
    central to array-oriented programming across a wide range of user communities.
    If an API in [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(in NumPy v2.0)") or [`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(in SciPy v1.13.1)") is listed within the Array API standard, it is a strong
    signal that JAX should include it. Using the example from above, the Array API
    standard includes several variants of [`numpy.unique()`](https://numpy.org/doc/stable/reference/generated/numpy.unique.html#numpy.unique
    "(in NumPy v2.0)") (`unique_all`, `unique_counts`, `unique_inverse`, `unique_values`)
    which suggests that, despite the function not being precisely aligned with XLA,
    it is important enough to the Python user community that JAX should perhaps implement
    it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的第二个方向集中在[Python 数组 API 标准](https://data-apis.org/array-api/2022.12/)上：在某些意义上，这是一个社区驱动的大纲，用于定义在各种用户社区中重要的面向数组编程的数组操作。如果[`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(在 NumPy v2.0)") 或 [`scipy`](https://docs.scipy.org/doc/scipy/index.html#module-scipy
    "(在 SciPy v1.13.1)") 中的 API 列在数组 API 标准中，这表明 JAX 应该包含它。以上述示例为例，数组 API 标准包含了 [`numpy.unique()`](https://numpy.org/doc/stable/reference/generated/numpy.unique.html#numpy.unique
    "(在 NumPy v2.0)") 的多个变体（`unique_all`、`unique_counts`、`unique_inverse`、`unique_values`），这表明，尽管该函数与
    XLA 的精确对齐并不完全，但它对于 Python 用户社区非常重要，因此 JAX 或许应该实现它。
- en: 'Axis 3: Existence of Downstream Implementations'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轴 3：下游实现的存在
- en: 'For functionality that does not align with Axis 1 or 2, an important consideration
    for inclusion into JAX is whether there exist well-supported downstream packages
    that supply the functionality in question. A good example of this is [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(in SciPy v1.13.1)"): while JAX does include a minimal set of wrappers of [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(in SciPy v1.13.1)") functionality, a much more complete treatment exists in
    the [JAXopt](https://jaxopt.github.io/) package, which is actively maintained
    by JAX collaborators. In cases like this, we should lean toward pointing users
    and contributors to these specialized packages rather than re-implementing such
    APIs in JAX itself.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不符合 Axis 1 或 2 的功能，是否存在良好支持的下游包供应该功能是纳入 JAX 的一个重要考虑因素。一个很好的例子是 [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(在 SciPy v1.13.1)")：虽然 JAX 包含了对 [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(在 SciPy v1.13.1)") 功能的最小包装集，但更完整的实现存在于由 JAX 协作者积极维护的 [JAXopt](https://jaxopt.github.io/)
    包中。在这种情况下，我们应倾向于指向用户和贡献者这些专业化的包，而不是在 JAX 自身重新实现这些 API。
- en: 'Axis 4: Complexity & Robustness of Implementation'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Axis 4: Implementation 的复杂性与健壮性'
- en: 'For functionality that does not align with XLA, one consideration is the degree
    of complexity of the proposed implementation. This aligns to some degree with
    Axis 1, but nevertheless is important to call out. A number of functions have
    been contributed to JAX which have relatively complex implementations which are
    difficult to validate and introduce outsized maintenance burdens; an example is
    `jax.scipy.special.bessel_jn()`: as of the writing of this JEP, its current implementation
    is a non-straightforward iterative approximation that has [convergence issues
    in some domains](https://github.com/google/jax/issues/12402#issuecomment-1384828637),
    and [proposed fixes](https://github.com/google/jax/pull/17038/files) introduce
    further complexity. Had we more carefully weighed the complexity and robustness
    of the implementation when accepting the contribution, we may have chosen not
    to accept this contribution to the package.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不符合 XLA 的功能，一个考虑因素是提议实现的复杂程度。这在某种程度上与 Axis 1 一致，但仍然是需要强调的。有许多函数已经贡献给 JAX，它们具有相对复杂的实现，难以验证并引入了过多的维护负担；一个例子是
    `jax.scipy.special.bessel_jn()`：在撰写本 JEP 时，其当前实现是一个非直观的迭代逼近，存在 [某些领域的收敛问题](https://github.com/google/jax/issues/12402#issuecomment-1384828637)，而
    [提出的修复方案](https://github.com/google/jax/pull/17038/files) 则引入了更多的复杂性。如果在接受贡献时更加仔细地权衡了实现的复杂性和健壮性，我们可能选择不接受这个包的贡献。
- en: 'Axis 5: Functional vs. Object-Oriented APIs'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Axis 5: 功能型 vs. 面向对象的 API'
- en: JAX works best with functional APIs rather than object-oriented APIs. Object-oriented
    APIs can often hide impure semantics, making them often difficult to implement
    well. NumPy and SciPy generally stick to functional APIs, but sometimes provide
    object-oriented convenience wrappers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 最适合使用功能型 API 而不是面向对象的 API。面向对象的 API 通常会隐藏不纯的语义，使其往往难以实现良好。NumPy 和 SciPy
    通常坚持使用功能型 API，但有时提供面向对象的便利包装器。
- en: Examples of this are `numpy.polynomial.Polynomial`, which wraps lower-level
    operations like [`numpy.polyadd()`](https://numpy.org/doc/stable/reference/generated/numpy.polyadd.html#numpy.polyadd
    "(in NumPy v2.0)"), [`numpy.polydiv()`](https://numpy.org/doc/stable/reference/generated/numpy.polydiv.html#numpy.polydiv
    "(in NumPy v2.0)"), etc. In general, when there are both functional and object-oriented
    APIs available, JAX should avoid providing wrappers for the object-oriented APIs
    and instead provide wrappers for the functional APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 `numpy.polynomial.Polynomial`，它包装了像 [`numpy.polyadd()`](https://numpy.org/doc/stable/reference/generated/numpy.polyadd.html#numpy.polyadd
    "(在 NumPy v2.0)")，[`numpy.polydiv()`](https://numpy.org/doc/stable/reference/generated/numpy.polydiv.html#numpy.polydiv
    "(在 NumPy v2.0)") 等低级操作。一般情况下，当既有功能型 API 又有面向对象 API 时，JAX 应避免为面向对象 API 提供包装器，而应为功能型
    API 提供包装器。
- en: In cases where only the object-oriented APIs exist, JAX should avoid providing
    wrappers unless the case is strong along other axes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在只存在面向对象的 API 的情况下，JAX 应避免提供包装器，除非在其他轴上有很强的案例支持。
- en: 'Axis 6: General “Importance” to JAX Users & Stakeholders'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Axis 6: 对 JAX 用户和利益相关者的“重要性”'
- en: The decision to include a NumPy/SciPy API in JAX should also take into account
    the importance of the algorithm to the general user community. It is admittedly
    difficult to quantify who is a “stakeholder” and how this importance should be
    measured; but we include this to make clear that any decision about what to include
    in JAX’s NumPy and SciPy wrappers will involve some amount of discretion that
    cannot be easily quantified.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 决定在JAX中包含NumPy/SciPy API还应考虑到该算法对一般用户社区的重要性。诚然，很难量化谁是“利益相关者”以及如何衡量这种重要性；但我们包括这一点是为了明确说明，在JAX的NumPy和SciPy包装中包含什么的任何决定都将涉及某种不容易量化的自由裁量权。
- en: 'For existing APIs, searches for usage in github may be useful in establishing
    importance or lack thereof; as an example, we might return to `jax.scipy.special.bessel_jn()`
    discussed above: a search shows that this function has only a [handful of uses](https://github.com/search?q=jax+AND+%22bessel_jn%28%22+NOT+MathJax&amp;type=code)
    on github, probably partly to do with the previously mentioned accuracy issues.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有API，通过在github中搜索使用情况可能有助于确定其重要性或缺失；例如，我们可以回到上面讨论过的 `jax.scipy.special.bessel_jn()`
    ：搜索显示，这个函数在github上仅有少数用例，这可能部分原因与先前提到的精度问题有关。
- en: 'Evaluation: what’s in scope?'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估：什么在范围内？
- en: In this section, we’ll attempt to evaluate the NumPy and SciPy APIs, including
    some examples from the current JAX API, in light of the above rubric. This will
    not be a comprehensive listing of all existing functions and classes, but rather
    a more general discussion by submodule and topic, with relevant examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试根据上述标准评估NumPy和SciPy的API，包括当前JAX API中的一些示例。这不会是所有现有函数和类的详尽列表，而是一个更一般的子模块和主题讨论，附带相关示例。
- en: NumPy APIs
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy API
- en: ✅ `numpy` namespace
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `numpy` 命名空间
- en: We consider the functions in the main [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(in NumPy v2.0)") namespace to be essentially all in-scope for JAX, due to its
    general alignment with XLA (Axis 1) and the Python Array API (Axis 2), as well
    as its general importance to the JAX user community (Axis 6). Some functions are
    perhaps borderline (functions like [`numpy.intersect1d()`](https://numpy.org/doc/stable/reference/generated/numpy.intersect1d.html#numpy.intersect1d
    "(in NumPy v2.0)"), `np.setdiff1d()`, `np.union1d()` arguably fail parts of the
    rubric) but for simplicity we declare that all array functions in the main numpy
    namespace are in-scope for JAX.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为主要 [`numpy`](https://numpy.org/doc/stable/reference/index.html#module-numpy
    "(在 NumPy v2.0)") 命名空间中的函数基本上都适用于JAX，因为它与XLA（轴 1）和Python数组API（轴 2）的一般对齐性以及对JAX用户社区的一般重要性（轴
    6）保持一致。一些函数可能处于边界地带（例如 [`numpy.intersect1d()`](https://numpy.org/doc/stable/reference/generated/numpy.intersect1d.html#numpy.intersect1d
    "(在 NumPy v2.0)")，`np.setdiff1d()`，`np.union1d()` 可能在某些标准下不完全符合），但为简单起见，我们声明所有主要numpy命名空间中的数组函数都适用于JAX。
- en: ✅ `numpy.linalg` & `numpy.fft`
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `numpy.linalg` 和 `numpy.fft`
- en: The [`numpy.linalg`](https://numpy.org/doc/stable/reference/routines.linalg.html#module-numpy.linalg
    "(in NumPy v2.0)") and [`numpy.fft`](https://numpy.org/doc/stable/reference/routines.fft.html#module-numpy.fft
    "(in NumPy v2.0)") submodules contain many functions that broadly align with functionality
    provided by XLA. Others have complicated device-specific lowerings, but represent
    a case where importance to stakeholders (Axis 6) outweighs complexity. For this
    reason, we deem both of these submodules in-scope for JAX.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.linalg`](https://numpy.org/doc/stable/reference/routines.linalg.html#module-numpy.linalg
    "(在 NumPy v2.0)") 和 [`numpy.fft`](https://numpy.org/doc/stable/reference/routines.fft.html#module-numpy.fft
    "(在 NumPy v2.0)") 子模块包含许多与XLA提供的功能广泛对齐的函数。其他函数具有复杂的特定设备的低级实现，但代表一种情况，其中对利益相关者的重要性（轴
    6）超过了复杂性。因此，我们认为这两个子模块都适用于JAX。'
- en: ❌ `numpy.random`
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `numpy.random`
- en: '[`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0)") is out-of-scope for JAX, because state-based RNGs are fundamentally
    incompatible with JAX’s computation model. We instead focus on `jax.random`, which
    offers similar functionality using a counter-based PRNG.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.random`](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random
    "(在 NumPy v2.0)") 对于JAX而言超出范围，因为基于状态的随机数生成器与JAX的计算模型基本不兼容。相反，我们将重点放在 `jax.random`
    上，它使用基于计数器的伪随机数生成器提供类似的功能。'
- en: ❌ `numpy.ma` & `numpy.polynomial`
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `numpy.ma` 和 `numpy.polynomial`
- en: The [`numpy.ma`](https://numpy.org/doc/stable/reference/maskedarray.generic.html#module-numpy.ma
    "(in NumPy v2.0)") and [`numpy.polynomial`](https://numpy.org/doc/stable/reference/routines.polynomials-package.html#module-numpy.polynomial
    "(in NumPy v2.0)") submodules are mostly concerned with providing object-oriented
    interfaces to computations that can be expressed via other functional means (Axis
    5); for this reason, we deem them out-of-scope for JAX.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.ma`](https://numpy.org/doc/stable/reference/maskedarray.generic.html#module-numpy.ma
    "(在 NumPy v2.0)") 和 [`numpy.polynomial`](https://numpy.org/doc/stable/reference/routines.polynomials-package.html#module-numpy.polynomial
    "(在 NumPy v2.0)") 子模块主要关注通过其他函数手段表达的计算的面向对象接口（轴5）。因此，我们认为它们不适用于 JAX。'
- en: ❌ `numpy.testing`
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `numpy.testing`
- en: NumPy’s testing functionality only really makes sense for host-side computation,
    and so we don’t include any wrappers for it in JAX. That said, JAX arrays are
    compatible with [`numpy.testing`](https://numpy.org/doc/stable/reference/routines.testing.html#module-numpy.testing
    "(in NumPy v2.0)"), and JAX makes frequent use of it throughout the JAX test suite.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的测试功能只对主机端计算有意义，因此我们在 JAX 中不包含任何包装器。尽管如此，JAX 数组与 [`numpy.testing`](https://numpy.org/doc/stable/reference/routines.testing.html#module-numpy.testing
    "(在 NumPy v2.0)") 兼容，并且在整个 JAX 测试套件中频繁使用它。
- en: SciPy APIs
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SciPy API
- en: SciPy has no functions in the top-level namespace, but includes a number of
    submodules. We consider each below, leaving out modules which have been deprecated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 没有顶层命名空间中的函数，但包含多个子模块。我们逐一考虑每个子模块，略过已弃用的模块。
- en: ❌ `scipy.cluster`
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.cluster`
- en: 'The [`scipy.cluster`](https://docs.scipy.org/doc/scipy/reference/cluster.html#module-scipy.cluster
    "(in SciPy v1.13.1)") module includes tools for hierarchical clustering, k-means,
    and related algorithms. These are weak along several axes, and would be better
    served by a downstream package. One function already exists within JAX (`jax.scipy.cluster.vq.vq()`)
    but has [no obvious usage](https://github.com/search?q=%22jax.scipy.cluster%22+AND+vq&amp;type=code&amp;p=5)
    on github: this suggests that clustering is not broadly important to JAX users.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.cluster`](https://docs.scipy.org/doc/scipy/reference/cluster.html#module-scipy.cluster
    "(在 SciPy v1.13.1)") 模块包含用于层次聚类、K均值和相关算法的工具。这些在多个方面表现不佳，更适合由下游包处理。JAX 中已经存在一个函数（`jax.scipy.cluster.vq.vq()`），但在
    [github](https://github.com/search?q=%22jax.scipy.cluster%22+AND+vq&amp;type=code&amp;p=5)
    上没有明显的使用示例，这表明聚类对于 JAX 用户并不广泛重要。'
- en: '*Recommendation: deprecate and remove `jax.scipy.cluster.vq()`.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：弃用并移除 `jax.scipy.cluster.vq()`。*'
- en: ❌ `scipy.constants`
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.constants`
- en: The [`scipy.constants`](https://docs.scipy.org/doc/scipy/reference/constants.html#module-scipy.constants
    "(in SciPy v1.13.1)") module includes mathematical and physical constants. These
    constants can be used directly with JAX, and so there is no reason to re-implement
    this in JAX.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.constants`](https://docs.scipy.org/doc/scipy/reference/constants.html#module-scipy.constants
    "(在 SciPy v1.13.1)") 模块包含数学和物理常数。这些常数可以直接在 JAX 中使用，因此没有必要在 JAX 中重新实现。'
- en: ❌ `scipy.datasets`
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.datasets`
- en: The [`scipy.datasets`](https://docs.scipy.org/doc/scipy/reference/datasets.html#module-scipy.datasets
    "(in SciPy v1.13.1)") module includes tools to fetch and load datasets. These
    fetched datasets can be used directly with JAX, and so there is no reason to re-implement
    this in JAX.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.datasets`](https://docs.scipy.org/doc/scipy/reference/datasets.html#module-scipy.datasets
    "(在 SciPy v1.13.1)") 模块包含获取和加载数据集的工具。这些获取的数据集可以直接在 JAX 中使用，因此没有必要在 JAX 中重新实现。'
- en: ✅ `scipy.fft`
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `scipy.fft`
- en: The [`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "(in SciPy v1.13.1)") module contains functions that broadly align with functionality
    provided by XLA, and fare well along other axes as well. For this reason, we deem
    them in-scope for JAX.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "(在 SciPy v1.13.1)") 模块包含与 XLA 提供的功能大致对齐的函数，并且在其他方面表现良好。因此，我们认为它们适用于 JAX 的范围内。'
- en: ❌ `scipy.integrate`
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.integrate`
- en: The [`scipy.integrate`](https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate
    "(in SciPy v1.13.1)") module contains functions for numerical integration. The
    more sophisticated of these (`quad`, `dblquad`, `ode`) are out-of-scope for JAX
    by axes 1 & 4, since they tend to be loopy algorithms based on dynamic numbers
    of evaluations. `jax.experimental.ode.odeint()` is related, but rather limited
    and not under any active development.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.integrate`](https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate
    "(在 SciPy v1.13.1 中)") 模块包含用于数值积分的函数。其中更复杂的函数（`quad`、`dblquad`、`ode`）基于动态评估的循环算法，根据轴
    1 和 4 应视为 JAX 范围之外。`jax.experimental.ode.odeint()` 相关，但相当有限，未处于任何活跃开发状态。'
- en: JAX does currently include `jax.scipy.integrate.trapezoid()`, but this is only
    because `numpy.trapz()` was recently deprecated in favor of this. For any particular
    input, its implementation could be replaced with one line of `jax.numpy` expressions,
    so it’s not a particularly useful API to provide.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 当前确实包括 `jax.scipy.integrate.trapezoid()`，但这仅因为`numpy.trapz()` 最近已弃用，推荐使用此功能。对于任何特定输入，其实现可以用一行
    `jax.numpy` 表达式替换，因此它并不是提供的特别有用的 API。
- en: Based on Axes 1, 2, 4, and 6, [`scipy.integrate`](https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate
    "(in SciPy v1.13.1)") should be considered out-of-scope for JAX.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于轴 1、2、4 和 6，[`scipy.integrate`](https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate
    "(在 SciPy v1.13.1 中)") 应被视为 JAX 范围之外。
- en: '*Recommendation: remove `jax.scipy.integrate.trapezoid()`, which was added
    in JAX 0.4.14.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：移除 `jax.scipy.integrate.trapezoid()`，此功能已在 JAX 0.4.14 中添加。*'
- en: ❌ `scipy.interpolate`
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.interpolate`
- en: 'The [`scipy.interpolate`](https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate
    "(in SciPy v1.13.1)") module provides both low-level and object-oriented routines
    for interpolating in one or more dimensions. These APIs rate poorly along a number
    of the axes above: they are class-based rather than low-level, and none but the
    simplest methods can be expressed efficiently in terms of XLA operations.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.interpolate`](https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate
    "(在 SciPy v1.13.1 中)") 模块提供了在一维或多维中进行插值的低级和面向对象的例程。从多个角度评估，这些 API 表现不佳：它们基于类而非低级，除了最简单的方法外，无法有效地用
    XLA 操作表达。'
- en: JAX does currently have wrappers for [`scipy.interpolate.RegularGridInterpolator`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.html#scipy.interpolate.RegularGridInterpolator
    "(in SciPy v1.13.1)"). Were we considering this contribution today, we would probably
    reject it by the above criteria. But this code has been fairly stable so there
    is not much downside to continuing to maintain it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 当前具有 [`scipy.interpolate.RegularGridInterpolator`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.html#scipy.interpolate.RegularGridInterpolator
    "(在 SciPy v1.13.1 中)") 的包装器。如果今天考虑此贡献，我们可能会根据以上标准拒绝它。但此代码相当稳定，因此继续维护没有太大的风险。
- en: Going forward, we should consider other members of [`scipy.interpolate`](https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate
    "(in SciPy v1.13.1)") to be out-of-scope for JAX.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我们应考虑将 [`scipy.interpolate`](https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate
    "(在 SciPy v1.13.1 中)") 的其他成员视为 JAX 范围之外。
- en: ❌ `scipy.io`
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.io`
- en: The [`scipy.io`](https://docs.scipy.org/doc/scipy/reference/io.html#module-scipy.io
    "(in SciPy v1.13.1)") submodule has to do with file input/output. There is no
    reason to re-implement this in JAX.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.io`](https://docs.scipy.org/doc/scipy/reference/io.html#module-scipy.io
    "(在 SciPy v1.13.1 中)") 子模块涉及文件输入/输出。在 JAX 中重新实现这一功能没有必要。'
- en: ✅ `scipy.linalg`
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `scipy.linalg`
- en: The [`scipy.linalg`](https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg
    "(in SciPy v1.13.1)") submodule contains functions that broadly align with functionality
    provided by XLA, and fast linear algebra is broadly important to the JAX user
    community. For this reason, we deem it in-scope for JAX.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.linalg`](https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg
    "(在 SciPy v1.13.1 中)") 子模块包含与 XLA 提供的功能大致对应的函数，快速线性代数对 JAX 用户社区至关重要。因此，我们认为它适用于
    JAX 的范围之内。'
- en: ❌ `scipy.ndimage`
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.ndimage`
- en: The [`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(in SciPy v1.13.1)") submodule contains a set of tools for working on image data.
    Many of these overlap with tools in [`scipy.signal`](https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal
    "(in SciPy v1.13.1)") (e.g. convolutions and filtering). JAX currently provides
    one [`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(in SciPy v1.13.1)") API, in `jax.scipy.ndimage.map_coordinates()`. Additionally,
    JAX provides some image-related tools in the `jax.image` module. The deepmind
    ecosystem includes [dm-pix](https://github.com/google-deepmind/dm_pix), a more
    full-featured set of tools for image manipulation in JAX. Given all these factors,
    I’d suggest that [`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(in SciPy v1.13.1)") should be considered out-of-scope for JAX core; we can point
    interested users and contributors to dm-pix. We can consider moving `map_coordinates`
    to `dm-pix` or to another appropriate package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(在 SciPy v1.13.1)") 子模块包含一组用于处理图像数据的工具。其中许多与 [`scipy.signal`](https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal
    "(在 SciPy v1.13.1)") 中的工具重叠（例如卷积和滤波）。JAX 目前在 `jax.scipy.ndimage.map_coordinates()`
    中提供了一个 [`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(在 SciPy v1.13.1)") API。此外，JAX 在 `jax.image` 模块中提供了一些与图像相关的工具。DeepMind 生态系统包括
    [dm-pix](https://github.com/google-deepmind/dm_pix)，一个更全面的用于在 JAX 中进行图像处理的工具集。考虑到所有这些因素，我建议
    [`scipy.ndimage`](https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage
    "(在 SciPy v1.13.1)") 应被视为 JAX 核心之外的范畴；我们可以将感兴趣的用户和贡献者指向 dm-pix。我们可以考虑将 `map_coordinates`
    移至 `dm-pix` 或其他适当的包中。'
- en: ❌ `scipy.odr`
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.odr`
- en: The [`scipy.odr`](https://docs.scipy.org/doc/scipy/reference/odr.html#module-scipy.odr
    "(in SciPy v1.13.1)") module provides an object-oriented wrapper around `ODRPACK`
    for performing orthogonal distance regressions. It is not clear that this could
    be cleanly expressed using existing JAX primitives, and so we deem it out of scope
    for JAX itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.odr`](https://docs.scipy.org/doc/scipy/reference/odr.html#module-scipy.odr
    "(在 SciPy v1.13.1)") 模块提供了一个面向对象的 `ODRPACK` 包装器，用于执行正交距离回归。目前尚不清楚是否可以使用现有的 JAX
    原语清晰地表达这一功能，因此我们认为它超出了 JAX 本身的范畴。'
- en: ❌ `scipy.optimize`
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.optimize`
- en: The [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(in SciPy v1.13.1)") module provides high-level and low-level interfaces for
    optimization. Such functionality is important to a lot of JAX users, and very
    early on JAX created `jax.scipy.optimize` wrappers. However, developers of these
    routines soon realized that the [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(in SciPy v1.13.1)") API was too constraining, and different teams began working
    on the [JAXopt](https://jaxopt.github.io/) package and the [Optimistix](https://github.com/patrick-kidger/optimistix)
    package, each of which contain a much more comprehensive and better-tested set
    of optimization routines in JAX.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(在 SciPy v1.13.1)") 模块提供了用于优化的高级和低级接口。这样的功能对许多 JAX 用户非常重要，在 JAX 创建 `jax.scipy.optimize`
    包装器时非常早就开始。然而，这些程序的开发人员很快意识到 [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(在 SciPy v1.13.1)") API 过于约束，并且不同的团队开始开发 [JAXopt](https://jaxopt.github.io/)
    包和 [Optimistix](https://github.com/patrick-kidger/optimistix) 包，每个包都包含了在 JAX 中更全面和经过更好测试的优化程序集。'
- en: Because of these well-supported external packages, we now consider [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(in SciPy v1.13.1)") to be out-of-scope for JAX.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些受到良好支持的外部包，我们现在认为 [`scipy.optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
    "(在 SciPy v1.13.1)") 超出了 JAX 的范围。
- en: '*Recommendation: deprecate `jax.scipy.optimize` and/or make it a lightweight
    wrapper around an optional JAXopt or Optimistix dependency.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：弃用 `jax.scipy.optimize` 或使其成为一个轻量级的包装器，周围包装一个可选的 JAXopt 或 Optimistix 依赖。*'
- en: 🟡 `scipy.signal`
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 🟡 `scipy.signal`
- en: 'The [`scipy.signal`](https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal
    "(in SciPy v1.13.1)") module is mixed: some functions are squarely in-scope for
    JAX (e.g. `correlate` and `convolve`, which are more user-friendly wrappers of
    `lax.conv_general_dilated`), while many others are squarely out-of-scope (domain-specific
    tools with no viable lowering path to XLA). Potential contributions to `jax.scipy.signal`
    will have to be weighed on a case-by-case basis.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.signal`](https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal
    "(在SciPy v1.13.1中)") 模块则有所不同：一些函数完全适用于JAX（例如`correlate`和`convolve`，这些函数是`lax.conv_general_dilated`的更友好的包装），而其他许多函数则完全不适用于JAX（专门领域的工具没有合适的降低路径到XLA）。对于`jax.scipy.signal`的潜在贡献将需要具体问题具体分析。'
- en: 🟡 `scipy.sparse`
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 🟡 `scipy.sparse`
- en: The [`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(in SciPy v1.13.1)") submodule mainly contains data structures for storing and
    operating on sparse matrices and arrays in a variety of formats. Additionally,
    [`scipy.sparse.linalg`](https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html#module-scipy.sparse.linalg
    "(in SciPy v1.13.1)") contains a number of matrix-free solvers, suitable for use
    with sparse matrices, dense matrices, and linear operators.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(在SciPy v1.13.1中)") 子模块主要包含了多种格式的稀疏矩阵和数组的存储和操作数据结构。此外，[`scipy.sparse.linalg`](https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html#module-scipy.sparse.linalg
    "(在SciPy v1.13.1中)") 还包含了许多无矩阵的求解器，适用于稀疏矩阵、稠密矩阵和线性算子。'
- en: The [`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(in SciPy v1.13.1)") array and matrix data structures are out-of-scope for JAX,
    because they do not align with JAX’s computational model (e.g. many operations
    depend on dynamically-sized buffers). JAX has developed the `jax.experimental.sparse`
    module as an alternative set of data structures that are more in-line with JAX’s
    computational constraints. For these reasons, we consider the data structures
    in [`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(in SciPy v1.13.1)") to be out-of-scope for JAX.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(在SciPy v1.13.1中)") 的数组和矩阵数据结构也超出了JAX的范围，因为它们与JAX的计算模型不符（例如，许多操作依赖于动态大小的缓冲区）。JAX已经开发了`jax.experimental.sparse`模块作为一组更符合JAX计算约束的替代数据结构。因此，我们认为[`scipy.sparse`](https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse
    "(在SciPy v1.13.1中)") 中的数据结构超出了JAX的范围。'
- en: On the other hand, [`scipy.sparse.linalg`](https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html#module-scipy.sparse.linalg
    "(in SciPy v1.13.1)") has proven to be an interesting area, and `jax.scipy.sparse.linalg`
    includes the `bicgstab`, `cg`, and `gmres` solvers. These are useful to the JAX
    user community (Axis 6) but aside from this do not fare well along other axes.
    They would be very suitable for moving into a downstream library; one potential
    option may be [Lineax](https://github.com/google/lineax), which features a number
    of linear solvers built on JAX.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，[`scipy.sparse.linalg`](https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html#module-scipy.sparse.linalg
    "(在SciPy v1.13.1中)") 已经被证明是一个有趣的领域，`jax.scipy.sparse.linalg`包括了`bicgstab`、`cg`和`gmres`求解器。这些对于JAX用户社区（轴6）非常有用，但在其他轴上并不适用。它们非常适合移入一个下游库；一个潜在的选择可能是[Lineax](https://github.com/google/lineax)，它包括了多个基于JAX构建的线性求解器。
- en: '*Recommendation: explore moving sparse solvers into Lineax, and otherwise treat
    `scipy.sparse`` as out-of-scope for JAX.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：考虑将稀疏求解器移入Lineax，并且将`scipy.sparse`视为JAX范围外的内容。*'
- en: ❌ `scipy.spatial`
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ❌ `scipy.spatial`
- en: The [`scipy.spatial`](https://docs.scipy.org/doc/scipy/reference/spatial.html#module-scipy.spatial
    "(in SciPy v1.13.1)") module contains mainly object-oriented interfaces to spatial/distance
    computations and nearest neighbor searches. It is mostly out-of-scope for JAX
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.spatial`](https://docs.scipy.org/doc/scipy/reference/spatial.html#module-scipy.spatial
    "(在SciPy v1.13.1中)") 模块主要包含面向对象的空间/距离计算和最近邻搜索接口。这在很大程度上超出了JAX的范围。'
- en: The [`scipy.spatial.transform`](https://docs.scipy.org/doc/scipy/reference/spatial.transform.html#module-scipy.spatial.transform
    "(in SciPy v1.13.1)") submodule provides tools for manipulating three-dimensional
    spatial rotations. It is a relatively complicated object-oriented interface, and
    could perhaps be better served by a downstream project. JAX currently contains
    partial implementations of `Rotation` and `Slerp` within `jax.scipy.spatial.transform`;
    these are object-oriented wrappers of otherwise basic functions, which introduce
    a very large API surface and have very few users. It is our judgment that they
    are out-of-scope for JAX itself, with users better-served by a hypothetical downstream
    project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.spatial.transform`](https://docs.scipy.org/doc/scipy/reference/spatial.transform.html#module-scipy.spatial.transform
    "(在SciPy v1.13.1中)") 子模块提供了用于操作三维空间旋转的工具。这是一个相对复杂的面向对象接口，也许最好由下游项目更好地服务。JAX目前在`jax.scipy.spatial.transform`中部分实现了`Rotation`和`Slerp`；这些是对基本函数的面向对象包装器，引入了非常庞大的API表面，且使用者非常少。我们认为它们超出了JAX本身的范围，用户最好由一个假设的下游项目更好地服务。'
- en: The [`scipy.spatial.distance`](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html#module-scipy.spatial.distance
    "(in SciPy v1.13.1)") submodule contains a useful collection of distance metrics,
    and it might be tempting to provide JAX wrappers for these. That said, with jit
    and vmap it would be straightforward for a user to define efficient versions of
    most of these from scratch if needed, so adding them to JAX is not particularly
    beneficial.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.spatial.distance`](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html#module-scipy.spatial.distance
    "(在SciPy v1.13.1中)") 子模块包含一组有用的距离度量标准，可能会诱人地为这些提供JAX包装器。尽管如此，通过`jit`和`vmap`，用户可以很容易地根据需要从头开始定义大多数这些的高效版本，因此将它们添加到JAX中并不特别有益。'
- en: '*Recommendation: consider deprecating and removing the `Rotation` and `Slerp`
    APIs, and consider [`scipy.spatial`](https://docs.scipy.org/doc/scipy/reference/spatial.html#module-scipy.spatial
    "(in SciPy v1.13.1)") as a whole out-of-scope for future contributions.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：考虑废弃和移除`Rotation`和`Slerp` API，并考虑将[`scipy.spatial`](https://docs.scipy.org/doc/scipy/reference/spatial.html#module-scipy.spatial
    "(在SciPy v1.13.1中)")整体视为不适合未来贡献。*'
- en: ✅ `scipy.special`
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `scipy.special`
- en: 'The [`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(in SciPy v1.13.1)") module includes implementations of a number of more specialized
    functions. In many cases, these functions are squarely in scope: for example,
    functions like `gammaln`, `betainc`, `digamma`, and many others correspond directly
    to available XLA primitives, and are clearly in-scope by Axis 1 and others.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(在SciPy v1.13.1中)") 模块包括一些更专业函数的实现。在许多情况下，这些函数完全在范围内：例如，像`gammaln`、`betainc`、`digamma`和许多其他函数直接对应于可用的XLA基元，并且明显在轴1和其他轴上在范围内。'
- en: 'Other functions require more complicated implementations; one example mentioned
    above is `bessel_jn`. Despite not aligning on Axes 1 and 2, these functions tend
    to be very strong along Axis 6: [`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(in SciPy v1.13.1)") provides fundamental functions necessary for computation
    in a variety of domains, so even functions with complicated implementations should
    lean toward in-scope, so long as the implementations are well-designed and robust.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数需要更复杂的实现；一个上面提到的例子是`bessel_jn`。尽管在轴1和2上不对齐，但这些函数往往在轴6上非常强大：[`scipy.special`](https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special
    "(在SciPy v1.13.1中)") 提供了在多个领域中进行计算所需的基本函数，因此即使是具有复杂实现的函数，只要实现良好且健壮，也应倾向于在范围内。
- en: 'There are a few existing function wrappers that we should take a closer look
    at; for example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些现有的函数包装器值得我们更仔细地看一看；例如：
- en: '`jax.scipy.special.lpmn()`: this generates legendre polynomials via a complicated
    fori_loop, in a way that does not match the scipy API (e.g. for `scipy`, `z` must
    be a scalar, while for JAX, `z` must be a 1D array). The function has few discoverable
    uses making it a weak candidate along Axes 1, 2, 4, and 6.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jax.scipy.special.lpmn()`: 这个函数通过一个复杂的`fori_loop`生成Legendre多项式，其方式与scipy的API不匹配（例如，对于`scipy`，`z`必须是标量，而对于JAX，则`z`必须是1D数组）。该函数有少数发现的用途，使其成为Axes
    1、2、4和6上的一个薄弱候选者。'
- en: '`jax.scipy.special.lpmn_values()`: this has similar weaknesses to `lmpn` above.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jax.scipy.special.lpmn_values()`: 这与上述的`lmpn`有类似的弱点。'
- en: '`jax.scipy.special.sph_harm()`: this is built on lpmn, and similarly has an
    API that diverges from the corresponding `scipy` function.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jax.scipy.special.sph_harm()`：此函数基于lpmn构建，其API与对应的`scipy`函数不同。'
- en: '`jax.scipy.special.bessel_jn()`: as discussed under Axis 4 above, this has
    weaknesses in terms of robustness of implementation and little usage. We might
    consider replacing it with a new, more robust implementation (e.g. [#17038](https://github.com/google/jax/issues/17038)).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jax.scipy.special.bessel_jn()`：如上述第4轴中讨论的那样，这在实现的健壮性方面存在弱点，使用较少。我们可能会考虑用一个新的、更健壮的实现替换它（例如
    [#17038](https://github.com/google/jax/issues/17038)）。'
- en: '*Recommendation: refactor and improve robustness & test coverage for `bessel_jn`.
    Consider deprecating `lpmn`, `lpmn_values`, and `sph_harm` if they cannot be modified
    to more closely match the `scipy` APIs.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：重构并提高`bessel_jn`的健壮性和测试覆盖率。如果无法修改以更接近`scipy`的API，则考虑废弃`lpmn`、`lpmn_values`和`sph_harm`。*'
- en: ✅ `scipy.stats`
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ✅ `scipy.stats`
- en: 'The [`scipy.stats`](https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats
    "(in SciPy v1.13.1)") module contains a wide range of statistical functions, including
    discrete and continuous distributions, summary statistics, and hypothesis testing.
    JAX currently wraps a number of these in `jax.scipy.stats`, primarily including
    20 or so statistical distributions, along with a few other functions (`mode`,
    `rankdata`, `gaussian_kde`). In general these are well-aligned with JAX: distributions
    usually are expressible in terms of efficient XLA operations, and the APIs are
    clean and functional.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.stats`](https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats
    "(在SciPy v1.13.1中)") 模块包含广泛的统计函数，包括离散和连续分布、汇总统计以及假设检验。JAX目前在`jax.scipy.stats`中包装了其中一些，主要包括大约20种统计分布以及一些其他函数（如`mode`、`rankdata`、`gaussian_kde`）。总体来说，这些与JAX很好地对齐：分布通常可以用高效的XLA操作表达，API清晰且功能齐全。'
- en: We don’t currently have any wrappers for hypothesis testing functions, probably
    because these are less useful to the primary user-base of JAX.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们没有任何假设检验函数的包装器，这可能是因为这些对于JAX的主要用户群体不太有用。
- en: Regarding distributions, in some cases, `tensorflow_probability` provides similar
    functionality, and in the future we might consider whether to deprecate the scipy.stats
    distributions in favor of that implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分布，在某些情况下，`tensorflow_probability`提供类似的功能，未来我们可能会考虑是否应该废弃scipy.stats中的分布以支持这种实现。
- en: '*Recommendation: going forward, we should treat statistical distributions and
    summary statistics as in-scope, and consider hypothesis tests and related functionality
    generally out-of-scope.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议：未来，我们应将统计分布和汇总统计视为范围内的内容，并考虑假设检验及其相关功能通常不在范围内。*'
