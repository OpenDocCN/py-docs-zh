["```py\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef f(x):\n  jax.debug.print(\"ðŸ¤¯ {x} ðŸ¤¯\", x=x)\n  y = jnp.sin(x)\n  jax.debug.print(\"ðŸ¤¯ {y} ðŸ¤¯\", y=y)\n  return y\n\nf(2.)\n# Prints:\n# ðŸ¤¯ 2.0 ðŸ¤¯\n# ðŸ¤¯ 0.9092974662780762 ðŸ¤¯ \n```", "```py\ndef debug.print(fmt: str, *args: PyTree[Array], **kwargs: PyTree[Array]) -> None:\n  print(fmt.format(*args, **kwargs)) \n```", "```py\nxs = jnp.arange(3.)\n\ndef f(x):\n  jax.debug.print(\"x: {}\", x)\n  y = jnp.sin(x)\n  jax.debug.print(\"y: {}\", y)\n  return y\njax.vmap(f)(xs)\n# Prints: x: 0.0\n#         x: 1.0\n#         x: 2.0\n#         y: 0.0\n#         y: 0.841471\n#         y: 0.9092974\njax.lax.map(f, xs)\n# Prints: x: 0.0\n#         y: 0.0\n#         x: 1.0\n#         y: 0.841471\n#         x: 2.0\n#         y: 0.9092974 \n```", "```py\nxs = jnp.arange(2.)\n\ndef f(x):\n  jax.debug.print(\"x: {}\", x)\n  return x\njax.pmap(f)(xs)\n# Prints: x: 1.0\n#         x: 0.0\n# OR\n# Prints: x: 1.0\n#         x: 0.0 \n```", "```py\ndef f(x):\n  jax.debug.print(\"x: {}\", x)\n  return x * 2.\n\njax.grad(f)(1.)\n# Prints: x: 1.0 \n```", "```py\n@jax.custom_vjp\ndef print_grad(x):\n  return x\n\ndef print_grad_fwd(x):\n  return x, None\n\ndef print_grad_bwd(_, x_grad):\n  jax.debug.print(\"x_grad: {}\", x_grad)\n  return (x_grad,)\n\nprint_grad.defvjp(print_grad_fwd, print_grad_bwd)\n\ndef f(x):\n  x = print_grad(x)\n  return x * 2.\njax.grad(f)(1.)\n# Prints: x_grad: 2.0 \n```", "```py\ndef callback(fun: Callable, *args: PyTree[Array], **kwargs: PyTree[Array]) -> None:\n  fun(*args, **kwargs)\n  return None \n```", "```py\n@jax.jit\ndef f(x, y):\n  jax.debug.print(\"x: {}\", x)\n  jax.debug.print(\"y: {}\", y)\n  return x + y\n\nf(2., 3.)\n# Prints: x: 2.0\n#         y: 3.0\n# OR\n# Prints: y: 3.0\n#         x: 2.0 \n```", "```py\n@jax.jit\ndef f(x):\n  jax.debug.print(\"x: {}\", x)\n  return x\nf(2.).block_until_ready()\n# <do something else>\n# Prints: x: 2. \n```", "```py\n@jax.jit\ndef f(x):\n  jax.debug.print(\"x: {}\", x)\n  return x\nf(2.).block_until_ready()\njax.effects_barrier()\n# Prints: x: 2.\n# <do something else> \n```", "```py\ndef f(w, b, x):\n  logits = w.dot(x) + b\n  jax.debug.print(\"logits: {}\", logits)\n  return jax.nn.relu(logits) \n```", "```py\n@jax.jit\ndef f(x):\n  y, z = jnp.sin(x), jnp.cos(x)\n  jax.debug.breakpoint()\n  return y * z\nf(2.) # ==> Pauses during execution! \n```", "```py\ndef breakpoint_if_nonfinite(x):\n  is_finite = jnp.isfinite(x).all()\n  def true_fn(x):\n    pass\n  def false_fn(x):\n    jax.debug.breakpoint()\n  lax.cond(is_finite, true_fn, false_fn, x)\n\n@jax.jit\ndef f(x, y):\n  z = x / y\n  breakpoint_if_nonfinite(z)\n  return z\nf(2., 0.) # ==> Pauses during execution! \n```"]