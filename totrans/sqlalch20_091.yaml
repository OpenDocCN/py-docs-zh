- en: Defining Constraints and Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/constraints.html](https://docs.sqlalchemy.org/en/20/core/constraints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section will discuss SQL [constraints](../glossary.html#term-constraints)
    and indexes. In SQLAlchemy the key classes include [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") and [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: '## Defining Foreign Keys'
  prefs: []
  type: TYPE_NORMAL
- en: A *foreign key* in SQL is a table-level construct that constrains one or more
    columns in that table to only allow values that are present in a different set
    of columns, typically but not always located on a different table. We call the
    columns which are constrained the *foreign key* columns and the columns which
    they are constrained towards the *referenced* columns. The referenced columns
    almost always define the primary key for their owning table, though there are
    exceptions to this. The foreign key is the “joint” that connects together pairs
    of rows which have a relationship with each other, and SQLAlchemy assigns very
    deep importance to this concept in virtually every area of its operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy as well as in DDL, foreign key constraints can be defined as
    additional attributes within the table clause, or for single-column foreign keys
    they may optionally be specified within the definition of a single column. The
    single column foreign key is more common, and at the column level is specified
    by constructing a [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object as an argument to a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, we define a new table `user_preference` for which each row must contain
    a value in the `user_id` column that also exists in the `user` table’s `user_id`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument to [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    is most commonly a string of the form *<tablename>.<columnname>*, or for a table
    in a remote schema or “owner” of the form *<schemaname>.<tablename>.<columnname>*.
    It may also be an actual [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object, which as we’ll see later is accessed from an existing [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object via its `c` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The advantage to using a string is that the in-python linkage between `user`
    and `user_preference` is resolved only when first needed, so that table objects
    can be easily spread across multiple modules and defined in any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Foreign keys may also be defined at the table level, using the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object. This object can describe a single-
    or multi-column foreign key. A multi-column foreign key is known as a *composite*
    foreign key, and almost always references a table that has a composite primary
    key. Below we define a table `invoice` which has a composite primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then a table `invoice_item` with a composite foreign key referencing `invoice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note that the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is the only way to define a composite
    foreign key. While we could also have placed individual [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects on both the `invoice_item.invoice_id`
    and `invoice_item.ref_num` columns, SQLAlchemy would not be aware that these two
    values should be paired together - it would be two individual foreign key constraints
    instead of a single composite foreign key referencing two columns.
  prefs: []
  type: TYPE_NORMAL
- en: '### Creating/Dropping Foreign Key Constraints via ALTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior we’ve seen in tutorials and elsewhere involving foreign keys with
    DDL illustrates that the constraints are typically rendered “inline” within the
    CREATE TABLE statement, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CONSTRAINT .. FOREIGN KEY` directive is used to create the constraint in
    an “inline” fashion within the CREATE TABLE definition. The [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods do this by default, using a topological
    sort of all the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects involved such that tables are created and dropped in order of their foreign
    key dependency (this sort is also available via the [`MetaData.sorted_tables`](metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor).
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can’t work when two or more foreign key constraints are involved
    in a “dependency cycle”, where a set of tables are mutually dependent on each
    other, assuming the backend enforces foreign keys (always the case except on SQLite,
    MySQL/MyISAM). The methods will therefore break out constraints in such a cycle
    into separate ALTER statements, on all backends other than SQLite which does not
    support most forms of ALTER. Given a schema like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call upon [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") on a backend such as the PostgreSQL backend,
    the cycle between these two tables is resolved and the constraints are created
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit DROP for these tables, the same logic applies, however note
    here that in SQL, to emit DROP CONSTRAINT requires that the constraint has a name.
    In the case of the `''node''` table above, we haven’t named this constraint; the
    system will therefore attempt to emit DROP for only those constraints that are
    named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where the cycle cannot be resolved, such as if we hadn’t applied
    a name to either constraint here, we will receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This error only applies to the DROP case as we can emit “ADD CONSTRAINT” in
    the CREATE case without a name; the database typically assigns one automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") keyword arguments can be used to manually resolve
    dependency cycles. We can add this flag only to the `''element''` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'in our CREATE DDL we will see the ALTER statement only for this constraint,
    and not the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey"), when used in conjunction with a drop operation,
    will require that the constraint is named, else an error like the following is
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sort_tables_and_constraints()`](ddl.html#sqlalchemy.schema.sort_tables_and_constraints
    "sqlalchemy.schema.sort_tables_and_constraints")  ### ON UPDATE and ON DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most databases support *cascading* of foreign key values, that is the when
    a parent row is updated the new value is placed in child rows, or when the parent
    row is deleted all corresponding child rows are set to null or deleted. In data
    definition language these are specified using phrases like “ON UPDATE CASCADE”,
    “ON DELETE CASCADE”, and “ON DELETE SET NULL”, corresponding to foreign key constraints.
    The phrase after “ON UPDATE” or “ON DELETE” may also allow other phrases that
    are specific to the database in use. The [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects support the generation of this
    clause via the `onupdate` and `ondelete` keyword arguments. The value is any string
    which will be output after the appropriate “ON UPDATE” or “ON DELETE” phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that these clauses require `InnoDB` tables when used with MySQL. They may
    also not be supported on other databases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'For background on integration of `ON DELETE CASCADE` with ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, see the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE cascade with ORM relationships](../orm/cascades.html#passive-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE with many-to-many relationships](../orm/cascades.html#passive-deletes-many-to-many)  ##
    UNIQUE Constraint'
  prefs: []
  type: TYPE_NORMAL
- en: Unique constraints can be created anonymously on a single column using the `unique`
    keyword on [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column").
    Explicitly named unique constraints and/or those with multiple columns are created
    via the [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint "sqlalchemy.schema.UniqueConstraint")
    table-level construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: CHECK Constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check constraints can be named or unnamed and can be created at the Column or
    Table level, using the [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") construct. The text of the check constraint
    is passed directly through to the database, so there is limited “database independent”
    behavior. Column level check constraints generally should only refer to the column
    to which they are placed, while table level constraints can refer to any columns
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some databases do not actively support check constraints such as older
    versions of MySQL (prior to 8.0.16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: PRIMARY KEY Constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary key constraint of any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object is implicitly present, based on the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are marked with the [`Column.primary_key`](metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") flag. The [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object provides explicit access to this
    constraint, which includes the option of being configured directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint "sqlalchemy.schema.PrimaryKeyConstraint")
    - detailed API documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Constraints when using the Declarative ORM Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is the SQLAlchemy Core construct that allows one to define table metadata, which
    among other things can be used by the SQLAlchemy ORM as a target to map a class.
    The [Declarative](../orm/extensions/declarative/index.html) extension allows the
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    to be created automatically, given the contents of the table primarily as a mapping
    of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: To apply table-level constraint objects such as [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") to a table defined using Declarative,
    use the `__table_args__` attribute, described at [Table Configuration](../orm/extensions/declarative/table_config.html#declarative-table-args).
  prefs: []
  type: TYPE_NORMAL
- en: '## Configuring Constraint Naming Conventions'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases typically assign explicit names to all constraints and
    indexes. In the common case that a table is created using `CREATE TABLE` where
    constraints such as CHECK, UNIQUE, and PRIMARY KEY constraints are produced inline
    with the table definition, the database usually has a system in place in which
    names are automatically assigned to these constraints, if a name is not otherwise
    specified. When an existing database table is altered in a database using a command
    such as `ALTER TABLE`, this command typically needs to specify explicit names
    for new constraints as well as be able to specify the name of an existing constraint
    that is to be dropped or modified.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints can be named explicitly using the [`Constraint.name`](#sqlalchemy.schema.Constraint.params.name
    "sqlalchemy.schema.Constraint") parameter, and for indexes the [`Index.name`](#sqlalchemy.schema.Index.params.name
    "sqlalchemy.schema.Index") parameter. However, in the case of constraints this
    parameter is optional. There are also the use cases of using the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") and [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameters which create [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    objects without an explicit name being specified.
  prefs: []
  type: TYPE_NORMAL
- en: The use case of alteration of existing tables and constraints can be handled
    by schema migration tools such as [Alembic](https://alembic.sqlalchemy.org/).
    However, neither Alembic nor SQLAlchemy currently create names for constraint
    objects where the name is otherwise unspecified, leading to the case where being
    able to alter existing constraints means that one must reverse-engineer the naming
    system used by the relational database to auto-assign names, or that care must
    be taken to ensure that all constraints are named.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to having to assign explicit names to all [`Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") and [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    objects, automated naming schemes can be constructed using events. This approach
    has the advantage that constraints will get a consistent naming scheme without
    the need for explicit name parameters throughout the code, and also that the convention
    takes place just as well for those constraints and indexes produced by the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") and [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameters. As of SQLAlchemy 0.9.2 this event-based
    approach is included, and can be configured using the argument [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData").
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Naming Convention for a MetaData Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") refers to a dictionary which accepts the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") class or individual [`Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") classes as keys, and Python string templates as
    values. It also accepts a series of string-codes as alternative keys, `"fk"`,
    `"pk"`, `"ix"`, `"ck"`, `"uq"` for foreign key, primary key, index, check, and
    unique constraint, respectively. The string templates in this dictionary are used
    whenever a constraint or index is associated with this [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that does not have an existing name given
    (including one exception case where an existing name can be further embellished).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example naming convention that suits basic cases is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The above convention will establish names for all constraints within the target
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection. For example, we can observe the name produced when we create an unnamed
    [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint "sqlalchemy.schema.UniqueConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This same feature takes effect even if we just use the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A key advantage to the naming convention approach is that the names are established
    at Python construction time, rather than at DDL emit time. The effect this has
    when using Alembic’s `--autogenerate` feature is that the naming convention will
    be explicit when a new migration script is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The above `"uq_user_name"` string was copied from the [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") object that `--autogenerate` located in
    our metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The tokens available include `%(table_name)s`, `%(referred_table_name)s`, `%(column_0_name)s`,
    `%(column_0_label)s`, `%(column_0_key)s`, `%(referred_column_0_name)s`, and `%(constraint_name)s`,
    as well as multiple-column versions of each including `%(column_0N_name)s`, `%(column_0_N_name)s`,
    `%(referred_column_0_N_name)s` which render all column names separated with or
    without an underscore. The documentation for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") has further detail on each of these conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Default Naming Convention'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") handles the long-standing SQLAlchemy behavior of
    assigning a name to a [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object that is created using the [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Truncation of Long Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a generated name, particularly those that use the multiple-column tokens,
    is too long for the identifier length limit of the target database (for example,
    PostgreSQL has a limit of 63 characters), the name will be deterministically truncated
    using a 4-character suffix based on the md5 hash of the long name. For example,
    the naming convention below will generate very long names given the column names
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the PostgreSQL dialect, names longer than 63 characters will be truncated
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Tokens for Naming Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New tokens can also be added, by specifying an additional token and a callable
    within the naming_convention dictionary. For example, if we wanted to name our
    foreign key constraints using a GUID scheme, we could do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, when we create a new [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), we will get a name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") - for additional usage details as well as a listing
    of all available naming components.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Importance of Naming Constraints](https://alembic.sqlalchemy.org/en/latest/naming.html)
    - in the Alembic documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.0: added multi-column naming tokens such as `%(column_0_N_name)s`.
    Generated names that go beyond the character limit for the target database will
    be deterministically truncated.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Naming CHECK Constraints'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    object is configured against an arbitrary SQL expression, which can have any number
    of columns present, and additionally is often configured using a raw SQL string.
    Therefore a common convention to use with [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") is one where we expect the object to have
    a name already, and we then enhance it with other convention elements. A typical
    convention is `"ck_%(table_name)s_%(constraint_name)s"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the name `ck_foo_value_gt_5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    also supports the `%(columns_0_name)s` token; we can make use of this by ensuring
    we use a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or [`column()`](sqlelement.html#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    element within the constraint’s expression, either by declaring the constraint
    separate from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'or by using a [`column()`](sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Both will produce the name `ck_foo_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The determination of the name of “column zero” is performed by scanning the
    given expression for column objects. If the expression has more than one column
    present, the scan does use a deterministic search, however the structure of the
    expression will determine which column is noted as “column zero”.  ### Configuring
    Naming for Boolean, Enum, and other schema types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    class refers to type objects such as [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") and [`Enum`](type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") which generate a CHECK constraint accompanying the type.
    The name for the constraint here is most directly set up by sending the “name”
    parameter, e.g. [`Boolean.name`](type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The naming convention feature may be combined with these types as well, normally
    by using a convention which includes `%(constraint_name)s` and then applying a
    name to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the constraint name `ck_foo_flag_bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    classes use special internal symbols so that the naming convention is only determined
    at DDL compile time. On PostgreSQL, there’s a native BOOLEAN type, so the CHECK
    constraint of [`Boolean`](type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    is not needed; we are safe to set up a [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") type without a name, even though a naming convention
    is in place for check constraints. This convention will only be consulted for
    the CHECK constraint if we run against a database without a native BOOLEAN type
    like SQLite or MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CHECK constraint may also make use of the `column_0_name` token, which
    works nicely with [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") since these constraints have only one column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The above schema will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using Naming Conventions with ORM Declarative Mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the naming convention feature with [ORM Declarative Mixins](../orm/declarative_mixins.html),
    individual constraint objects must exist for each actual table-mapped subclass.
    See the section [Creating Indexes and Constraints with Naming Conventions on Mixins](../orm/declarative_mixins.html#orm-mixins-named-constraints)
    for background and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [CheckConstraint](#sqlalchemy.schema.CheckConstraint) | A table- or column-level
    CHECK constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollectionConstraint](#sqlalchemy.schema.ColumnCollectionConstraint)
    | A constraint that proxies a ColumnCollection. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollectionMixin](#sqlalchemy.schema.ColumnCollectionMixin) | A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Constraint](#sqlalchemy.schema.Constraint) | A table-level SQL constraint.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [conv](#sqlalchemy.schema.conv) | Mark a string indicating that a name has
    already been converted by a naming convention. |'
  prefs: []
  type: TYPE_TB
- en: '| [ForeignKey](#sqlalchemy.schema.ForeignKey) | Defines a dependency between
    two columns. |'
  prefs: []
  type: TYPE_TB
- en: '| [ForeignKeyConstraint](#sqlalchemy.schema.ForeignKeyConstraint) | A table-level
    FOREIGN KEY constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [HasConditionalDDL](#sqlalchemy.schema.HasConditionalDDL) | define a class
    that includes the [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") method, allowing for conditional
    rendering of DDL. |'
  prefs: []
  type: TYPE_TB
- en: '| [PrimaryKeyConstraint](#sqlalchemy.schema.PrimaryKeyConstraint) | A table-level
    PRIMARY KEY constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [UniqueConstraint](#sqlalchemy.schema.UniqueConstraint) | A table-level UNIQUE
    constraint. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A table-level SQL constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    serves as the base class for the series of constraint objects that can be associated
    with [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, including [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.Constraint.__init__), [argument_for()](#sqlalchemy.schema.Constraint.argument_for),
    [copy()](#sqlalchemy.schema.Constraint.copy), [ddl_if()](#sqlalchemy.schema.Constraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.Constraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.Constraint.dialect_options),
    [info](#sqlalchemy.schema.Constraint.info), [kwargs](#sqlalchemy.schema.Constraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Create a SQL constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this `Constraint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. See the documentation regarding an individual
    dialect at [Dialects](../dialects/index.html) for detail on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_create_rule` – used internally by some datatypes that also create constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_type_bound` – used internally to indicate that this constraint is associated
    with a specific datatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`Constraint.copy()`](#sqlalchemy.schema.Constraint.copy
    "sqlalchemy.schema.Constraint.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: This collection represents the columns which are referred to by this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A constraint that proxies a ColumnCollection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ColumnCollectionConstraint.__init__), [argument_for()](#sqlalchemy.schema.ColumnCollectionConstraint.argument_for),
    [columns](#sqlalchemy.schema.ColumnCollectionConstraint.columns), [contains_column()](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column),
    [copy()](#sqlalchemy.schema.ColumnCollectionConstraint.copy), [ddl_if()](#sqlalchemy.schema.ColumnCollectionConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs),
    [dialect_options](#sqlalchemy.schema.ColumnCollectionConstraint.dialect_options),
    [info](#sqlalchemy.schema.ColumnCollectionConstraint.info), [kwargs](#sqlalchemy.schema.ColumnCollectionConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint") ([`sqlalchemy.schema.ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin"), [`sqlalchemy.schema.Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*columns` – A sequence of column names or Column objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – other keyword arguments including dialect-specific arguments
    are propagated to the [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A table- or column-level CHECK constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Can be included in the definition of a Table or Column.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.CheckConstraint.__init__), [argument_for()](#sqlalchemy.schema.CheckConstraint.argument_for),
    [columns](#sqlalchemy.schema.CheckConstraint.columns), [contains_column()](#sqlalchemy.schema.CheckConstraint.contains_column),
    [copy()](#sqlalchemy.schema.CheckConstraint.copy), [ddl_if()](#sqlalchemy.schema.CheckConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.CheckConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.CheckConstraint.dialect_options),
    [info](#sqlalchemy.schema.CheckConstraint.info), [kwargs](#sqlalchemy.schema.CheckConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Construct a CHECK constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqltext` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A string containing the constraint definition, which will be used verbatim,
    or a SQL expression construct. If given as a string, the object is converted to
    a [`text()`](sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    object. If the textual string includes a colon character, escape this using a
    backslash:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`CheckConstraint.sqltext`](#sqlalchemy.schema.CheckConstraint.params.sqltext
    "sqlalchemy.schema.CheckConstraint") argument to [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") can be passed as a Python string argument,
    which will be treated as **trusted SQL text** and rendered as given. **DO NOT
    PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`CheckConstraint.copy()`](#sqlalchemy.schema.CheckConstraint.copy
    "sqlalchemy.schema.CheckConstraint.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Defines a dependency between two columns.
  prefs: []
  type: TYPE_NORMAL
- en: '`ForeignKey` is specified as an argument to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note that `ForeignKey` is only a marker object that defines a dependency between
    two columns. The actual constraint is in all cases represented by the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object. This object will be generated
    automatically when a `ForeignKey` is associated with a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") which in turn is associated with a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Conversely, when [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is applied to a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), `ForeignKey` markers are automatically generated to
    be present on each associated [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), which are also associated with the constraint object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you cannot define a “composite” foreign key constraint, that is a
    constraint between a grouping of multiple parent/child columns, using `ForeignKey`
    objects. To define this grouping, the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object must be used, and applied to
    the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
    The associated `ForeignKey` objects are created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForeignKey` objects associated with an individual [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object are available in the foreign_keys collection
    of that column.
  prefs: []
  type: TYPE_NORMAL
- en: Further examples of foreign key configuration are in [Defining Foreign Keys](#metadata-foreignkeys).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ForeignKey.__init__), [argument_for()](#sqlalchemy.schema.ForeignKey.argument_for),
    [column](#sqlalchemy.schema.ForeignKey.column), [copy()](#sqlalchemy.schema.ForeignKey.copy),
    [dialect_kwargs](#sqlalchemy.schema.ForeignKey.dialect_kwargs), [dialect_options](#sqlalchemy.schema.ForeignKey.dialect_options),
    [get_referent()](#sqlalchemy.schema.ForeignKey.get_referent), [info](#sqlalchemy.schema.ForeignKey.info),
    [kwargs](#sqlalchemy.schema.ForeignKey.kwargs), [references()](#sqlalchemy.schema.ForeignKey.references),
    [target_fullname](#sqlalchemy.schema.ForeignKey.target_fullname)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Construct a column-level FOREIGN KEY.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object when constructed generates a [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") which is associated with the parent
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object’s
    collection of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`column` – A single target column for the key relationship. A [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or a column name as a string: `tablename.columnkey`
    or `schema.tablename.columnkey`. `columnkey` is the `key` which has been assigned
    to the column (defaults to the column name itself), unless `link_to_name` is `True`
    in which case the rendered name of the column is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional string. An in-database name for the key if constraint is
    not provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupdate` – Optional string. If set, emit ON UPDATE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete` – Optional string. If set, emit ON DELETE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link_to_name` – if True, the string name given in `column` is the rendered
    name of the referenced column, not its locally assigned `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_alter` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: passed to the underlying [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") to indicate the constraint should be
    generated/dropped externally from the CREATE TABLE/ DROP TABLE statement. See
    [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") for further description.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](#use-alter)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`match` – Optional string. If set, emit MATCH <value>when issuing DDL for this
    constraint. Typical values include SIMPLE, PARTIAL and FULL.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. The arguments are ultimately handled by
    a corresponding [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"). See the documentation regarding an
    individual dialect at [Dialects](../dialects/index.html) for detail on documented
    arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Return the target [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: If no target column has been established, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ForeignKey.copy()`](#sqlalchemy.schema.ForeignKey.copy
    "sqlalchemy.schema.ForeignKey.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    in the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    (or any [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause "sqlalchemy.sql.expression.FromClause"))
    referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: Returns None if this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    does not reference the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Return a string based ‘column specification’ for this [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: This is usually the equivalent of the string-based “tablename.colname” argument
    first passed to the object’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: A table-level FOREIGN KEY constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a single column or composite FOREIGN KEY … REFERENCES constraint. For
    a no-frills, single column foreign key, adding a [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") to the definition of a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is a shorthand equivalent for an unnamed, single column
    [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: Examples of foreign key configuration are in [Defining Foreign Keys](#metadata-foreignkeys).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ForeignKeyConstraint.__init__), [argument_for()](#sqlalchemy.schema.ForeignKeyConstraint.argument_for),
    [column_keys](#sqlalchemy.schema.ForeignKeyConstraint.column_keys), [columns](#sqlalchemy.schema.ForeignKeyConstraint.columns),
    [contains_column()](#sqlalchemy.schema.ForeignKeyConstraint.contains_column),
    [copy()](#sqlalchemy.schema.ForeignKeyConstraint.copy), [ddl_if()](#sqlalchemy.schema.ForeignKeyConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.ForeignKeyConstraint.dialect_options),
    [elements](#sqlalchemy.schema.ForeignKeyConstraint.elements), [info](#sqlalchemy.schema.ForeignKeyConstraint.info),
    [kwargs](#sqlalchemy.schema.ForeignKeyConstraint.kwargs), [referred_table](#sqlalchemy.schema.ForeignKeyConstraint.referred_table)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Construct a composite-capable FOREIGN KEY.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`columns` – A sequence of local column names. The named columns must be defined
    and present in the parent Table. The names should match the `key` given to each
    column (defaults to the name) unless `link_to_name` is True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refcolumns` – A sequence of foreign column names or Column objects. The columns
    must all be located within the same Table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupdate` – Optional string. If set, emit ON UPDATE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete` – Optional string. If set, emit ON DELETE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link_to_name` – if True, the string name given in `column` is the rendered
    name of the referenced column, not its locally assigned `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_alter` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If True, do not emit the DDL for this constraint as part of the CREATE TABLE
    definition. Instead, generate it via an ALTER TABLE statement issued after the
    full collection of tables have been created, and drop it via an ALTER TABLE statement
    before the full collection of tables are dropped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") is particularly geared towards the case
    where two or more tables are established within a mutually-dependent foreign key
    constraint relationship; however, the [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will perform this resolution automatically,
    so the flag is normally not needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](#use-alter)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`match` – Optional string. If set, emit MATCH <value>when issuing DDL for this
    constraint. Typical values include SIMPLE, PARTIAL and FULL.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. See the documentation regarding an individual
    dialect at [Dialects](../dialects/index.html) for detail on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of string keys representing the local columns in this [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: This list is either the original string arguments sent to the constructor of
    the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint "sqlalchemy.schema.ForeignKeyConstraint"),
    or if the constraint has been initialized with [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, is the string `.key` of each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ForeignKeyConstraint.copy()`](#sqlalchemy.schema.ForeignKeyConstraint.copy
    "sqlalchemy.schema.ForeignKeyConstraint.copy") method is deprecated and will be
    removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: A sequence of [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Each [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    represents a single referring column/referred column pair.
  prefs: []
  type: TYPE_NORMAL
- en: This collection is intended to be read-only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object to which this [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") references.
  prefs: []
  type: TYPE_NORMAL
- en: This is a dynamically calculated attribute which may not be available if the
    constraint and/or parent table is not yet associated with a metadata collection
    that contains the referred table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: define a class that includes the [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") method, allowing for conditional
    rendering of DDL.
  prefs: []
  type: TYPE_NORMAL
- en: Currently applies to constraints and indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[ddl_if()](#sqlalchemy.schema.HasConditionalDDL.ddl_if)'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: A table-level PRIMARY KEY constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint "sqlalchemy.schema.PrimaryKeyConstraint")
    object is present automatically on any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object; it is assigned a set of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects corresponding to those marked with the [`Column.primary_key`](metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary key of a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can also be specified by using a [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object explicitly; in this mode of usage,
    the “name” of the constraint can also be specified, as well as other options which
    may be recognized by dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The two styles of column-specification should generally not be mixed. An warning
    is emitted if the columns present in the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") don’t match the columns that were marked
    as `primary_key=True`, if both are present; in this case, the columns are taken
    strictly from the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") declaration, and those columns otherwise
    marked as `primary_key=True` are ignored. This behavior is intended to be backwards
    compatible with previous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the use case where specific options are to be specified on the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), but the usual style of using `primary_key=True`
    flags is still desirable, an empty [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") may be specified, which will take on
    the primary key column collection from the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") based on the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[argument_for()](#sqlalchemy.schema.PrimaryKeyConstraint.argument_for), [columns](#sqlalchemy.schema.PrimaryKeyConstraint.columns),
    [contains_column()](#sqlalchemy.schema.PrimaryKeyConstraint.contains_column),
    [copy()](#sqlalchemy.schema.PrimaryKeyConstraint.copy), [ddl_if()](#sqlalchemy.schema.PrimaryKeyConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.PrimaryKeyConstraint.dialect_options),
    [info](#sqlalchemy.schema.PrimaryKeyConstraint.info), [kwargs](#sqlalchemy.schema.PrimaryKeyConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: A table-level UNIQUE constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a single column or composite UNIQUE constraint. For a no-frills, single
    column constraint, adding `unique=True` to the `Column` definition is a shorthand
    equivalent for an unnamed, single column UniqueConstraint.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.UniqueConstraint.__init__), [argument_for()](#sqlalchemy.schema.UniqueConstraint.argument_for),
    [columns](#sqlalchemy.schema.UniqueConstraint.columns), [contains_column()](#sqlalchemy.schema.UniqueConstraint.contains_column),
    [copy()](#sqlalchemy.schema.UniqueConstraint.copy), [ddl_if()](#sqlalchemy.schema.UniqueConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.UniqueConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.UniqueConstraint.dialect_options),
    [info](#sqlalchemy.schema.UniqueConstraint.info), [kwargs](#sqlalchemy.schema.UniqueConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.schema.ColumnCollectionConstraint.__init__`
    *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*columns` – A sequence of column names or Column objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – other keyword arguments including dialect-specific arguments
    are propagated to the [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Mark a string indicating that a name has already been converted by a naming
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: This is a string subclass that indicates a name that should not be subject to
    any further naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. when we create a [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    using a naming convention as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The name of the above constraint will be rendered as `"ck_t_x5"`. That is, the
    existing name `x5` is used in the naming convention as the `constraint_name` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, such as in migration scripts, we may be rendering the above
    [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    with a name that’s already been converted. In order to make sure the name isn’t
    double-modified, the new name is applied using the [`conv()`](#sqlalchemy.schema.conv
    "sqlalchemy.schema.conv") marker. We can use this explicitly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`conv()`](#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    marker indicates that the constraint name here is final, and the name will render
    as `"ck_t_x5"` and not `"ck_t_ck_t_x5"`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes can be created anonymously (using an auto-generated name `ix_<column
    label>`) for a single column using the inline `index` keyword on [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), which also modifies the usage of `unique` to apply
    the uniqueness to the index itself, instead of adding a separate UNIQUE constraint.
    For indexes with specific names or which encompass more than one column, use the
    [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") construct, which
    requires a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below we illustrate a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    with several [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") objects
    associated. The DDL for “CREATE INDEX” is issued right after the create statements
    for the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the example above, the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is created externally to the table which it corresponds, using [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects directly. [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") also supports “inline” definition inside the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), using string names to identify columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") object also
    supports its own `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '### Functional Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") supports SQL
    and function expressions, as supported by the target backend. To create an index
    against a column using a descending value, the [`ColumnElement.desc()`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifier may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with a backend that supports functional indexes such as PostgreSQL, a “case
    insensitive” index can be created using the `lower()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Index API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Index](#sqlalchemy.schema.Index) | A table-level INDEX. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: A table-level INDEX.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a composite (one or more column) INDEX.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'For a no-frills, single column index, adding [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") also supports `index=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'For a composite index, multiple columns can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Functional indexes are supported as well, typically by using the [`func`](sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct in conjunction with table-bound [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'An [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") can also be
    manually associated with a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    either through inline declaration or using [`Table.append_constraint()`](metadata.html#sqlalchemy.schema.Table.append_constraint
    "sqlalchemy.schema.Table.append_constraint"). When this approach is used, the
    names of the indexed columns can be specified as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'To support functional or expression-based indexes in this form, the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexes](#schema-indexes) - General information on [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL-Specific Index Options](../dialects/postgresql.html#postgresql-indexes)
    - PostgreSQL-specific options available for the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB- Specific Index Options](../dialects/mysql.html#mysql-indexes)
    - MySQL-specific options available for the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes) - MSSQL-specific
    options available for the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.Index.__init__), [argument_for()](#sqlalchemy.schema.Index.argument_for),
    [create()](#sqlalchemy.schema.Index.create), [ddl_if()](#sqlalchemy.schema.Index.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.Index.dialect_kwargs), [dialect_options](#sqlalchemy.schema.Index.dialect_options),
    [drop()](#sqlalchemy.schema.Index.drop), [info](#sqlalchemy.schema.Index.info),
    [kwargs](#sqlalchemy.schema.Index.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin"), [`sqlalchemy.schema.HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Construct an index object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – The name of the index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*expressions` – Column expressions to include in the index. The expressions
    are normally instances of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    but may also be arbitrary SQL expressions which ultimately refer to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique=False` – Keyword only argument; if True, create a unique index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quote=None` – Keyword only argument; whether to apply quoting to the name
    of the index. Works in the same manner as that of [`Column.quote`](metadata.html#sqlalchemy.schema.Column.params.quote
    "sqlalchemy.schema.Column").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info=None` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments not mentioned above are dialect
    specific, and passed in the form `<dialectname>_<argname>`. See the documentation
    regarding an individual dialect at [Dialects](../dialects/index.html) for detail
    on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Issue a `CREATE` statement for this [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index"),
    using the given [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or `Engine`` for connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Issue a `DROP` statement for this [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index"),
    using the given [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    for connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all "sqlalchemy.schema.MetaData.drop_all").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '## Defining Foreign Keys'
  prefs: []
  type: TYPE_NORMAL
- en: A *foreign key* in SQL is a table-level construct that constrains one or more
    columns in that table to only allow values that are present in a different set
    of columns, typically but not always located on a different table. We call the
    columns which are constrained the *foreign key* columns and the columns which
    they are constrained towards the *referenced* columns. The referenced columns
    almost always define the primary key for their owning table, though there are
    exceptions to this. The foreign key is the “joint” that connects together pairs
    of rows which have a relationship with each other, and SQLAlchemy assigns very
    deep importance to this concept in virtually every area of its operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy as well as in DDL, foreign key constraints can be defined as
    additional attributes within the table clause, or for single-column foreign keys
    they may optionally be specified within the definition of a single column. The
    single column foreign key is more common, and at the column level is specified
    by constructing a [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object as an argument to a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Above, we define a new table `user_preference` for which each row must contain
    a value in the `user_id` column that also exists in the `user` table’s `user_id`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument to [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    is most commonly a string of the form *<tablename>.<columnname>*, or for a table
    in a remote schema or “owner” of the form *<schemaname>.<tablename>.<columnname>*.
    It may also be an actual [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object, which as we’ll see later is accessed from an existing [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object via its `c` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The advantage to using a string is that the in-python linkage between `user`
    and `user_preference` is resolved only when first needed, so that table objects
    can be easily spread across multiple modules and defined in any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Foreign keys may also be defined at the table level, using the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object. This object can describe a single-
    or multi-column foreign key. A multi-column foreign key is known as a *composite*
    foreign key, and almost always references a table that has a composite primary
    key. Below we define a table `invoice` which has a composite primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'And then a table `invoice_item` with a composite foreign key referencing `invoice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note that the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is the only way to define a composite
    foreign key. While we could also have placed individual [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects on both the `invoice_item.invoice_id`
    and `invoice_item.ref_num` columns, SQLAlchemy would not be aware that these two
    values should be paired together - it would be two individual foreign key constraints
    instead of a single composite foreign key referencing two columns.
  prefs: []
  type: TYPE_NORMAL
- en: '### Creating/Dropping Foreign Key Constraints via ALTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior we’ve seen in tutorials and elsewhere involving foreign keys with
    DDL illustrates that the constraints are typically rendered “inline” within the
    CREATE TABLE statement, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The `CONSTRAINT .. FOREIGN KEY` directive is used to create the constraint in
    an “inline” fashion within the CREATE TABLE definition. The [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods do this by default, using a topological
    sort of all the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects involved such that tables are created and dropped in order of their foreign
    key dependency (this sort is also available via the [`MetaData.sorted_tables`](metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor).
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can’t work when two or more foreign key constraints are involved
    in a “dependency cycle”, where a set of tables are mutually dependent on each
    other, assuming the backend enforces foreign keys (always the case except on SQLite,
    MySQL/MyISAM). The methods will therefore break out constraints in such a cycle
    into separate ALTER statements, on all backends other than SQLite which does not
    support most forms of ALTER. Given a schema like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call upon [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") on a backend such as the PostgreSQL backend,
    the cycle between these two tables is resolved and the constraints are created
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit DROP for these tables, the same logic applies, however note
    here that in SQL, to emit DROP CONSTRAINT requires that the constraint has a name.
    In the case of the `''node''` table above, we haven’t named this constraint; the
    system will therefore attempt to emit DROP for only those constraints that are
    named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where the cycle cannot be resolved, such as if we hadn’t applied
    a name to either constraint here, we will receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: This error only applies to the DROP case as we can emit “ADD CONSTRAINT” in
    the CREATE case without a name; the database typically assigns one automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") keyword arguments can be used to manually resolve
    dependency cycles. We can add this flag only to the `''element''` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'in our CREATE DDL we will see the ALTER statement only for this constraint,
    and not the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey"), when used in conjunction with a drop operation,
    will require that the constraint is named, else an error like the following is
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sort_tables_and_constraints()`](ddl.html#sqlalchemy.schema.sort_tables_and_constraints
    "sqlalchemy.schema.sort_tables_and_constraints")  ### ON UPDATE and ON DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most databases support *cascading* of foreign key values, that is the when
    a parent row is updated the new value is placed in child rows, or when the parent
    row is deleted all corresponding child rows are set to null or deleted. In data
    definition language these are specified using phrases like “ON UPDATE CASCADE”,
    “ON DELETE CASCADE”, and “ON DELETE SET NULL”, corresponding to foreign key constraints.
    The phrase after “ON UPDATE” or “ON DELETE” may also allow other phrases that
    are specific to the database in use. The [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects support the generation of this
    clause via the `onupdate` and `ondelete` keyword arguments. The value is any string
    which will be output after the appropriate “ON UPDATE” or “ON DELETE” phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Note that these clauses require `InnoDB` tables when used with MySQL. They may
    also not be supported on other databases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'For background on integration of `ON DELETE CASCADE` with ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, see the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE cascade with ORM relationships](../orm/cascades.html#passive-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE with many-to-many relationships](../orm/cascades.html#passive-deletes-many-to-many)  ###
    Creating/Dropping Foreign Key Constraints via ALTER'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior we’ve seen in tutorials and elsewhere involving foreign keys with
    DDL illustrates that the constraints are typically rendered “inline” within the
    CREATE TABLE statement, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The `CONSTRAINT .. FOREIGN KEY` directive is used to create the constraint in
    an “inline” fashion within the CREATE TABLE definition. The [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods do this by default, using a topological
    sort of all the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects involved such that tables are created and dropped in order of their foreign
    key dependency (this sort is also available via the [`MetaData.sorted_tables`](metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor).
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can’t work when two or more foreign key constraints are involved
    in a “dependency cycle”, where a set of tables are mutually dependent on each
    other, assuming the backend enforces foreign keys (always the case except on SQLite,
    MySQL/MyISAM). The methods will therefore break out constraints in such a cycle
    into separate ALTER statements, on all backends other than SQLite which does not
    support most forms of ALTER. Given a schema like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call upon [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") on a backend such as the PostgreSQL backend,
    the cycle between these two tables is resolved and the constraints are created
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit DROP for these tables, the same logic applies, however note
    here that in SQL, to emit DROP CONSTRAINT requires that the constraint has a name.
    In the case of the `''node''` table above, we haven’t named this constraint; the
    system will therefore attempt to emit DROP for only those constraints that are
    named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where the cycle cannot be resolved, such as if we hadn’t applied
    a name to either constraint here, we will receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: This error only applies to the DROP case as we can emit “ADD CONSTRAINT” in
    the CREATE case without a name; the database typically assigns one automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") keyword arguments can be used to manually resolve
    dependency cycles. We can add this flag only to the `''element''` table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'in our CREATE DDL we will see the ALTER statement only for this constraint,
    and not the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey"), when used in conjunction with a drop operation,
    will require that the constraint is named, else an error like the following is
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sort_tables_and_constraints()`](ddl.html#sqlalchemy.schema.sort_tables_and_constraints
    "sqlalchemy.schema.sort_tables_and_constraints")'
  prefs: []
  type: TYPE_NORMAL
- en: '### ON UPDATE and ON DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most databases support *cascading* of foreign key values, that is the when
    a parent row is updated the new value is placed in child rows, or when the parent
    row is deleted all corresponding child rows are set to null or deleted. In data
    definition language these are specified using phrases like “ON UPDATE CASCADE”,
    “ON DELETE CASCADE”, and “ON DELETE SET NULL”, corresponding to foreign key constraints.
    The phrase after “ON UPDATE” or “ON DELETE” may also allow other phrases that
    are specific to the database in use. The [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects support the generation of this
    clause via the `onupdate` and `ondelete` keyword arguments. The value is any string
    which will be output after the appropriate “ON UPDATE” or “ON DELETE” phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Note that these clauses require `InnoDB` tables when used with MySQL. They may
    also not be supported on other databases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'For background on integration of `ON DELETE CASCADE` with ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, see the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE cascade with ORM relationships](../orm/cascades.html#passive-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using foreign key ON DELETE with many-to-many relationships](../orm/cascades.html#passive-deletes-many-to-many)'
  prefs: []
  type: TYPE_NORMAL
- en: '## UNIQUE Constraint'
  prefs: []
  type: TYPE_NORMAL
- en: Unique constraints can be created anonymously on a single column using the `unique`
    keyword on [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column").
    Explicitly named unique constraints and/or those with multiple columns are created
    via the [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint "sqlalchemy.schema.UniqueConstraint")
    table-level construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: CHECK Constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check constraints can be named or unnamed and can be created at the Column or
    Table level, using the [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") construct. The text of the check constraint
    is passed directly through to the database, so there is limited “database independent”
    behavior. Column level check constraints generally should only refer to the column
    to which they are placed, while table level constraints can refer to any columns
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some databases do not actively support check constraints such as older
    versions of MySQL (prior to 8.0.16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: PRIMARY KEY Constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary key constraint of any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object is implicitly present, based on the [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are marked with the [`Column.primary_key`](metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") flag. The [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object provides explicit access to this
    constraint, which includes the option of being configured directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint "sqlalchemy.schema.PrimaryKeyConstraint")
    - detailed API documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Constraints when using the Declarative ORM Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is the SQLAlchemy Core construct that allows one to define table metadata, which
    among other things can be used by the SQLAlchemy ORM as a target to map a class.
    The [Declarative](../orm/extensions/declarative/index.html) extension allows the
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object
    to be created automatically, given the contents of the table primarily as a mapping
    of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: To apply table-level constraint objects such as [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") to a table defined using Declarative,
    use the `__table_args__` attribute, described at [Table Configuration](../orm/extensions/declarative/table_config.html#declarative-table-args).
  prefs: []
  type: TYPE_NORMAL
- en: '## Configuring Constraint Naming Conventions'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases typically assign explicit names to all constraints and
    indexes. In the common case that a table is created using `CREATE TABLE` where
    constraints such as CHECK, UNIQUE, and PRIMARY KEY constraints are produced inline
    with the table definition, the database usually has a system in place in which
    names are automatically assigned to these constraints, if a name is not otherwise
    specified. When an existing database table is altered in a database using a command
    such as `ALTER TABLE`, this command typically needs to specify explicit names
    for new constraints as well as be able to specify the name of an existing constraint
    that is to be dropped or modified.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints can be named explicitly using the [`Constraint.name`](#sqlalchemy.schema.Constraint.params.name
    "sqlalchemy.schema.Constraint") parameter, and for indexes the [`Index.name`](#sqlalchemy.schema.Index.params.name
    "sqlalchemy.schema.Index") parameter. However, in the case of constraints this
    parameter is optional. There are also the use cases of using the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") and [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameters which create [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    objects without an explicit name being specified.
  prefs: []
  type: TYPE_NORMAL
- en: The use case of alteration of existing tables and constraints can be handled
    by schema migration tools such as [Alembic](https://alembic.sqlalchemy.org/).
    However, neither Alembic nor SQLAlchemy currently create names for constraint
    objects where the name is otherwise unspecified, leading to the case where being
    able to alter existing constraints means that one must reverse-engineer the naming
    system used by the relational database to auto-assign names, or that care must
    be taken to ensure that all constraints are named.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to having to assign explicit names to all [`Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") and [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    objects, automated naming schemes can be constructed using events. This approach
    has the advantage that constraints will get a consistent naming scheme without
    the need for explicit name parameters throughout the code, and also that the convention
    takes place just as well for those constraints and indexes produced by the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") and [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameters. As of SQLAlchemy 0.9.2 this event-based
    approach is included, and can be configured using the argument [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData").
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Naming Convention for a MetaData Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") refers to a dictionary which accepts the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") class or individual [`Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") classes as keys, and Python string templates as
    values. It also accepts a series of string-codes as alternative keys, `"fk"`,
    `"pk"`, `"ix"`, `"ck"`, `"uq"` for foreign key, primary key, index, check, and
    unique constraint, respectively. The string templates in this dictionary are used
    whenever a constraint or index is associated with this [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that does not have an existing name given
    (including one exception case where an existing name can be further embellished).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example naming convention that suits basic cases is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The above convention will establish names for all constraints within the target
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection. For example, we can observe the name produced when we create an unnamed
    [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint "sqlalchemy.schema.UniqueConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'This same feature takes effect even if we just use the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'A key advantage to the naming convention approach is that the names are established
    at Python construction time, rather than at DDL emit time. The effect this has
    when using Alembic’s `--autogenerate` feature is that the naming convention will
    be explicit when a new migration script is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The above `"uq_user_name"` string was copied from the [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") object that `--autogenerate` located in
    our metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The tokens available include `%(table_name)s`, `%(referred_table_name)s`, `%(column_0_name)s`,
    `%(column_0_label)s`, `%(column_0_key)s`, `%(referred_column_0_name)s`, and `%(constraint_name)s`,
    as well as multiple-column versions of each including `%(column_0N_name)s`, `%(column_0_N_name)s`,
    `%(referred_column_0_N_name)s` which render all column names separated with or
    without an underscore. The documentation for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") has further detail on each of these conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Default Naming Convention'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") handles the long-standing SQLAlchemy behavior of
    assigning a name to a [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object that is created using the [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Truncation of Long Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a generated name, particularly those that use the multiple-column tokens,
    is too long for the identifier length limit of the target database (for example,
    PostgreSQL has a limit of 63 characters), the name will be deterministically truncated
    using a 4-character suffix based on the md5 hash of the long name. For example,
    the naming convention below will generate very long names given the column names
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'On the PostgreSQL dialect, names longer than 63 characters will be truncated
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Tokens for Naming Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New tokens can also be added, by specifying an additional token and a callable
    within the naming_convention dictionary. For example, if we wanted to name our
    foreign key constraints using a GUID scheme, we could do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, when we create a new [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), we will get a name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") - for additional usage details as well as a listing
    of all available naming components.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Importance of Naming Constraints](https://alembic.sqlalchemy.org/en/latest/naming.html)
    - in the Alembic documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.0: added multi-column naming tokens such as `%(column_0_N_name)s`.
    Generated names that go beyond the character limit for the target database will
    be deterministically truncated.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Naming CHECK Constraints'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    object is configured against an arbitrary SQL expression, which can have any number
    of columns present, and additionally is often configured using a raw SQL string.
    Therefore a common convention to use with [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") is one where we expect the object to have
    a name already, and we then enhance it with other convention elements. A typical
    convention is `"ck_%(table_name)s_%(constraint_name)s"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the name `ck_foo_value_gt_5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    also supports the `%(columns_0_name)s` token; we can make use of this by ensuring
    we use a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or [`column()`](sqlelement.html#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    element within the constraint’s expression, either by declaring the constraint
    separate from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'or by using a [`column()`](sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Both will produce the name `ck_foo_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'The determination of the name of “column zero” is performed by scanning the
    given expression for column objects. If the expression has more than one column
    present, the scan does use a deterministic search, however the structure of the
    expression will determine which column is noted as “column zero”.  ### Configuring
    Naming for Boolean, Enum, and other schema types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    class refers to type objects such as [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") and [`Enum`](type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") which generate a CHECK constraint accompanying the type.
    The name for the constraint here is most directly set up by sending the “name”
    parameter, e.g. [`Boolean.name`](type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'The naming convention feature may be combined with these types as well, normally
    by using a convention which includes `%(constraint_name)s` and then applying a
    name to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the constraint name `ck_foo_flag_bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    classes use special internal symbols so that the naming convention is only determined
    at DDL compile time. On PostgreSQL, there’s a native BOOLEAN type, so the CHECK
    constraint of [`Boolean`](type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    is not needed; we are safe to set up a [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") type without a name, even though a naming convention
    is in place for check constraints. This convention will only be consulted for
    the CHECK constraint if we run against a database without a native BOOLEAN type
    like SQLite or MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CHECK constraint may also make use of the `column_0_name` token, which
    works nicely with [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") since these constraints have only one column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'The above schema will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Using Naming Conventions with ORM Declarative Mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the naming convention feature with [ORM Declarative Mixins](../orm/declarative_mixins.html),
    individual constraint objects must exist for each actual table-mapped subclass.
    See the section [Creating Indexes and Constraints with Naming Conventions on Mixins](../orm/declarative_mixins.html#orm-mixins-named-constraints)
    for background and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Naming Convention for a MetaData Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") refers to a dictionary which accepts the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") class or individual [`Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") classes as keys, and Python string templates as
    values. It also accepts a series of string-codes as alternative keys, `"fk"`,
    `"pk"`, `"ix"`, `"ck"`, `"uq"` for foreign key, primary key, index, check, and
    unique constraint, respectively. The string templates in this dictionary are used
    whenever a constraint or index is associated with this [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that does not have an existing name given
    (including one exception case where an existing name can be further embellished).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example naming convention that suits basic cases is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The above convention will establish names for all constraints within the target
    [`MetaData`](metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection. For example, we can observe the name produced when we create an unnamed
    [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint "sqlalchemy.schema.UniqueConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'This same feature takes effect even if we just use the [`Column.unique`](metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'A key advantage to the naming convention approach is that the names are established
    at Python construction time, rather than at DDL emit time. The effect this has
    when using Alembic’s `--autogenerate` feature is that the naming convention will
    be explicit when a new migration script is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The above `"uq_user_name"` string was copied from the [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") object that `--autogenerate` located in
    our metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The tokens available include `%(table_name)s`, `%(referred_table_name)s`, `%(column_0_name)s`,
    `%(column_0_label)s`, `%(column_0_key)s`, `%(referred_column_0_name)s`, and `%(constraint_name)s`,
    as well as multiple-column versions of each including `%(column_0N_name)s`, `%(column_0_N_name)s`,
    `%(referred_column_0_N_name)s` which render all column names separated with or
    without an underscore. The documentation for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") has further detail on each of these conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Default Naming Convention'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for [`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") handles the long-standing SQLAlchemy behavior of
    assigning a name to a [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object that is created using the [`Column.index`](metadata.html#sqlalchemy.schema.Column.params.index
    "sqlalchemy.schema.Column") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Truncation of Long Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a generated name, particularly those that use the multiple-column tokens,
    is too long for the identifier length limit of the target database (for example,
    PostgreSQL has a limit of 63 characters), the name will be deterministically truncated
    using a 4-character suffix based on the md5 hash of the long name. For example,
    the naming convention below will generate very long names given the column names
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'On the PostgreSQL dialect, names longer than 63 characters will be truncated
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Tokens for Naming Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New tokens can also be added, by specifying an additional token and a callable
    within the naming_convention dictionary. For example, if we wanted to name our
    foreign key constraints using a GUID scheme, we could do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, when we create a new [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"), we will get a name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") - for additional usage details as well as a listing
    of all available naming components.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Importance of Naming Constraints](https://alembic.sqlalchemy.org/en/latest/naming.html)
    - in the Alembic documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.0: added multi-column naming tokens such as `%(column_0_N_name)s`.
    Generated names that go beyond the character limit for the target database will
    be deterministically truncated.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Naming CHECK Constraints'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    object is configured against an arbitrary SQL expression, which can have any number
    of columns present, and additionally is often configured using a raw SQL string.
    Therefore a common convention to use with [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") is one where we expect the object to have
    a name already, and we then enhance it with other convention elements. A typical
    convention is `"ck_%(table_name)s_%(constraint_name)s"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the name `ck_foo_value_gt_5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    also supports the `%(columns_0_name)s` token; we can make use of this by ensuring
    we use a [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or [`column()`](sqlelement.html#sqlalchemy.sql.expression.column "sqlalchemy.sql.expression.column")
    element within the constraint’s expression, either by declaring the constraint
    separate from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'or by using a [`column()`](sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Both will produce the name `ck_foo_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: The determination of the name of “column zero” is performed by scanning the
    given expression for column objects. If the expression has more than one column
    present, the scan does use a deterministic search, however the structure of the
    expression will determine which column is noted as “column zero”.
  prefs: []
  type: TYPE_NORMAL
- en: '### Configuring Naming for Boolean, Enum, and other schema types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    class refers to type objects such as [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") and [`Enum`](type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") which generate a CHECK constraint accompanying the type.
    The name for the constraint here is most directly set up by sending the “name”
    parameter, e.g. [`Boolean.name`](type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The naming convention feature may be combined with these types as well, normally
    by using a convention which includes `%(constraint_name)s` and then applying a
    name to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will produce the constraint name `ck_foo_flag_bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: The [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    classes use special internal symbols so that the naming convention is only determined
    at DDL compile time. On PostgreSQL, there’s a native BOOLEAN type, so the CHECK
    constraint of [`Boolean`](type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    is not needed; we are safe to set up a [`Boolean`](type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") type without a name, even though a naming convention
    is in place for check constraints. This convention will only be consulted for
    the CHECK constraint if we run against a database without a native BOOLEAN type
    like SQLite or MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CHECK constraint may also make use of the `column_0_name` token, which
    works nicely with [`SchemaType`](type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") since these constraints have only one column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'The above schema will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Using Naming Conventions with ORM Declarative Mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the naming convention feature with [ORM Declarative Mixins](../orm/declarative_mixins.html),
    individual constraint objects must exist for each actual table-mapped subclass.
    See the section [Creating Indexes and Constraints with Naming Conventions on Mixins](../orm/declarative_mixins.html#orm-mixins-named-constraints)
    for background and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [CheckConstraint](#sqlalchemy.schema.CheckConstraint) | A table- or column-level
    CHECK constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollectionConstraint](#sqlalchemy.schema.ColumnCollectionConstraint)
    | A constraint that proxies a ColumnCollection. |'
  prefs: []
  type: TYPE_TB
- en: '| [ColumnCollectionMixin](#sqlalchemy.schema.ColumnCollectionMixin) | A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Constraint](#sqlalchemy.schema.Constraint) | A table-level SQL constraint.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [conv](#sqlalchemy.schema.conv) | Mark a string indicating that a name has
    already been converted by a naming convention. |'
  prefs: []
  type: TYPE_TB
- en: '| [ForeignKey](#sqlalchemy.schema.ForeignKey) | Defines a dependency between
    two columns. |'
  prefs: []
  type: TYPE_TB
- en: '| [ForeignKeyConstraint](#sqlalchemy.schema.ForeignKeyConstraint) | A table-level
    FOREIGN KEY constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [HasConditionalDDL](#sqlalchemy.schema.HasConditionalDDL) | define a class
    that includes the [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") method, allowing for conditional
    rendering of DDL. |'
  prefs: []
  type: TYPE_TB
- en: '| [PrimaryKeyConstraint](#sqlalchemy.schema.PrimaryKeyConstraint) | A table-level
    PRIMARY KEY constraint. |'
  prefs: []
  type: TYPE_TB
- en: '| [UniqueConstraint](#sqlalchemy.schema.UniqueConstraint) | A table-level UNIQUE
    constraint. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: A table-level SQL constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    serves as the base class for the series of constraint objects that can be associated
    with [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, including [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") [`UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.Constraint.__init__), [argument_for()](#sqlalchemy.schema.Constraint.argument_for),
    [copy()](#sqlalchemy.schema.Constraint.copy), [ddl_if()](#sqlalchemy.schema.Constraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.Constraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.Constraint.dialect_options),
    [info](#sqlalchemy.schema.Constraint.info), [kwargs](#sqlalchemy.schema.Constraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Create a SQL constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this `Constraint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. See the documentation regarding an individual
    dialect at [Dialects](../dialects/index.html) for detail on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_create_rule` – used internally by some datatypes that also create constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_type_bound` – used internally to indicate that this constraint is associated
    with a specific datatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`Constraint.copy()`](#sqlalchemy.schema.Constraint.copy
    "sqlalchemy.schema.Constraint.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: This collection represents the columns which are referred to by this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: A constraint that proxies a ColumnCollection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ColumnCollectionConstraint.__init__), [argument_for()](#sqlalchemy.schema.ColumnCollectionConstraint.argument_for),
    [columns](#sqlalchemy.schema.ColumnCollectionConstraint.columns), [contains_column()](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column),
    [copy()](#sqlalchemy.schema.ColumnCollectionConstraint.copy), [ddl_if()](#sqlalchemy.schema.ColumnCollectionConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs),
    [dialect_options](#sqlalchemy.schema.ColumnCollectionConstraint.dialect_options),
    [info](#sqlalchemy.schema.ColumnCollectionConstraint.info), [kwargs](#sqlalchemy.schema.ColumnCollectionConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint") ([`sqlalchemy.schema.ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin"), [`sqlalchemy.schema.Constraint`](#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*columns` – A sequence of column names or Column objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – other keyword arguments including dialect-specific arguments
    are propagated to the [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: A table- or column-level CHECK constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Can be included in the definition of a Table or Column.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.CheckConstraint.__init__), [argument_for()](#sqlalchemy.schema.CheckConstraint.argument_for),
    [columns](#sqlalchemy.schema.CheckConstraint.columns), [contains_column()](#sqlalchemy.schema.CheckConstraint.contains_column),
    [copy()](#sqlalchemy.schema.CheckConstraint.copy), [ddl_if()](#sqlalchemy.schema.CheckConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.CheckConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.CheckConstraint.dialect_options),
    [info](#sqlalchemy.schema.CheckConstraint.info), [kwargs](#sqlalchemy.schema.CheckConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Construct a CHECK constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqltext` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A string containing the constraint definition, which will be used verbatim,
    or a SQL expression construct. If given as a string, the object is converted to
    a [`text()`](sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    object. If the textual string includes a colon character, escape this using a
    backslash:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`CheckConstraint.sqltext`](#sqlalchemy.schema.CheckConstraint.params.sqltext
    "sqlalchemy.schema.CheckConstraint") argument to [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") can be passed as a Python string argument,
    which will be treated as **trusted SQL text** and rendered as given. **DO NOT
    PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`CheckConstraint.copy()`](#sqlalchemy.schema.CheckConstraint.copy
    "sqlalchemy.schema.CheckConstraint.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Defines a dependency between two columns.
  prefs: []
  type: TYPE_NORMAL
- en: '`ForeignKey` is specified as an argument to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Note that `ForeignKey` is only a marker object that defines a dependency between
    two columns. The actual constraint is in all cases represented by the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object. This object will be generated
    automatically when a `ForeignKey` is associated with a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") which in turn is associated with a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). Conversely, when [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is applied to a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), `ForeignKey` markers are automatically generated to
    be present on each associated [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), which are also associated with the constraint object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you cannot define a “composite” foreign key constraint, that is a
    constraint between a grouping of multiple parent/child columns, using `ForeignKey`
    objects. To define this grouping, the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object must be used, and applied to
    the [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
    The associated `ForeignKey` objects are created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForeignKey` objects associated with an individual [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object are available in the foreign_keys collection
    of that column.
  prefs: []
  type: TYPE_NORMAL
- en: Further examples of foreign key configuration are in [Defining Foreign Keys](#metadata-foreignkeys).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ForeignKey.__init__), [argument_for()](#sqlalchemy.schema.ForeignKey.argument_for),
    [column](#sqlalchemy.schema.ForeignKey.column), [copy()](#sqlalchemy.schema.ForeignKey.copy),
    [dialect_kwargs](#sqlalchemy.schema.ForeignKey.dialect_kwargs), [dialect_options](#sqlalchemy.schema.ForeignKey.dialect_options),
    [get_referent()](#sqlalchemy.schema.ForeignKey.get_referent), [info](#sqlalchemy.schema.ForeignKey.info),
    [kwargs](#sqlalchemy.schema.ForeignKey.kwargs), [references()](#sqlalchemy.schema.ForeignKey.references),
    [target_fullname](#sqlalchemy.schema.ForeignKey.target_fullname)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Construct a column-level FOREIGN KEY.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    object when constructed generates a [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") which is associated with the parent
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") object’s
    collection of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`column` – A single target column for the key relationship. A [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or a column name as a string: `tablename.columnkey`
    or `schema.tablename.columnkey`. `columnkey` is the `key` which has been assigned
    to the column (defaults to the column name itself), unless `link_to_name` is `True`
    in which case the rendered name of the column is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional string. An in-database name for the key if constraint is
    not provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupdate` – Optional string. If set, emit ON UPDATE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete` – Optional string. If set, emit ON DELETE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link_to_name` – if True, the string name given in `column` is the rendered
    name of the referenced column, not its locally assigned `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_alter` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: passed to the underlying [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") to indicate the constraint should be
    generated/dropped externally from the CREATE TABLE/ DROP TABLE statement. See
    [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") for further description.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](#use-alter)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`match` – Optional string. If set, emit MATCH <value>when issuing DDL for this
    constraint. Typical values include SIMPLE, PARTIAL and FULL.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. The arguments are ultimately handled by
    a corresponding [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint"). See the documentation regarding an
    individual dialect at [Dialects](../dialects/index.html) for detail on documented
    arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Return the target [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: If no target column has been established, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ForeignKey.copy()`](#sqlalchemy.schema.ForeignKey.copy
    "sqlalchemy.schema.ForeignKey.copy") method is deprecated and will be removed
    in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    in the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    (or any [`FromClause`](selectable.html#sqlalchemy.sql.expression.FromClause "sqlalchemy.sql.expression.FromClause"))
    referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: Returns None if this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    does not reference the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the given [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is referenced by this [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Return a string based ‘column specification’ for this [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey").
  prefs: []
  type: TYPE_NORMAL
- en: This is usually the equivalent of the string-based “tablename.colname” argument
    first passed to the object’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: A table-level FOREIGN KEY constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a single column or composite FOREIGN KEY … REFERENCES constraint. For
    a no-frills, single column foreign key, adding a [`ForeignKey`](#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") to the definition of a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") is a shorthand equivalent for an unnamed, single column
    [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: Examples of foreign key configuration are in [Defining Foreign Keys](#metadata-foreignkeys).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.ForeignKeyConstraint.__init__), [argument_for()](#sqlalchemy.schema.ForeignKeyConstraint.argument_for),
    [column_keys](#sqlalchemy.schema.ForeignKeyConstraint.column_keys), [columns](#sqlalchemy.schema.ForeignKeyConstraint.columns),
    [contains_column()](#sqlalchemy.schema.ForeignKeyConstraint.contains_column),
    [copy()](#sqlalchemy.schema.ForeignKeyConstraint.copy), [ddl_if()](#sqlalchemy.schema.ForeignKeyConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.ForeignKeyConstraint.dialect_options),
    [elements](#sqlalchemy.schema.ForeignKeyConstraint.elements), [info](#sqlalchemy.schema.ForeignKeyConstraint.info),
    [kwargs](#sqlalchemy.schema.ForeignKeyConstraint.kwargs), [referred_table](#sqlalchemy.schema.ForeignKeyConstraint.referred_table)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Construct a composite-capable FOREIGN KEY.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`columns` – A sequence of local column names. The named columns must be defined
    and present in the parent Table. The names should match the `key` given to each
    column (defaults to the name) unless `link_to_name` is True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refcolumns` – A sequence of foreign column names or Column objects. The columns
    must all be located within the same Table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupdate` – Optional string. If set, emit ON UPDATE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete` – Optional string. If set, emit ON DELETE <value>when issuing DDL
    for this constraint. Typical values include CASCADE, DELETE and RESTRICT.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link_to_name` – if True, the string name given in `column` is the rendered
    name of the referenced column, not its locally assigned `key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_alter` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If True, do not emit the DDL for this constraint as part of the CREATE TABLE
    definition. Instead, generate it via an ALTER TABLE statement issued after the
    full collection of tables have been created, and drop it via an ALTER TABLE statement
    before the full collection of tables are dropped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of [`ForeignKeyConstraint.use_alter`](#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") is particularly geared towards the case
    where two or more tables are established within a mutually-dependent foreign key
    constraint relationship; however, the [`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will perform this resolution automatically,
    so the flag is normally not needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](#use-alter)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`match` – Optional string. If set, emit MATCH <value>when issuing DDL for this
    constraint. Typical values include SIMPLE, PARTIAL and FULL.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional string that will render an SQL comment on foreign key constraint creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments are dialect specific, and passed
    in the form `<dialectname>_<argname>`. See the documentation regarding an individual
    dialect at [Dialects](../dialects/index.html) for detail on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of string keys representing the local columns in this [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint").
  prefs: []
  type: TYPE_NORMAL
- en: This list is either the original string arguments sent to the constructor of
    the [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint "sqlalchemy.schema.ForeignKeyConstraint"),
    or if the constraint has been initialized with [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, is the string `.key` of each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.4: The [`ForeignKeyConstraint.copy()`](#sqlalchemy.schema.ForeignKeyConstraint.copy
    "sqlalchemy.schema.ForeignKeyConstraint.copy") method is deprecated and will be
    removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: A sequence of [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Each [`ForeignKey`](#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    represents a single referring column/referred column pair.
  prefs: []
  type: TYPE_NORMAL
- en: This collection is intended to be read-only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: The [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object to which this [`ForeignKeyConstraint`](#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") references.
  prefs: []
  type: TYPE_NORMAL
- en: This is a dynamically calculated attribute which may not be available if the
    constraint and/or parent table is not yet associated with a metadata collection
    that contains the referred table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: define a class that includes the [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") method, allowing for conditional
    rendering of DDL.
  prefs: []
  type: TYPE_NORMAL
- en: Currently applies to constraints and indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[ddl_if()](#sqlalchemy.schema.HasConditionalDDL.ddl_if)'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: A table-level PRIMARY KEY constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint "sqlalchemy.schema.PrimaryKeyConstraint")
    object is present automatically on any [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object; it is assigned a set of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects corresponding to those marked with the [`Column.primary_key`](metadata.html#sqlalchemy.schema.Column.params.primary_key
    "sqlalchemy.schema.Column") flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary key of a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can also be specified by using a [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object explicitly; in this mode of usage,
    the “name” of the constraint can also be specified, as well as other options which
    may be recognized by dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: The two styles of column-specification should generally not be mixed. An warning
    is emitted if the columns present in the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") don’t match the columns that were marked
    as `primary_key=True`, if both are present; in this case, the columns are taken
    strictly from the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") declaration, and those columns otherwise
    marked as `primary_key=True` are ignored. This behavior is intended to be backwards
    compatible with previous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the use case where specific options are to be specified on the [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), but the usual style of using `primary_key=True`
    flags is still desirable, an empty [`PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") may be specified, which will take on
    the primary key column collection from the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") based on the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[argument_for()](#sqlalchemy.schema.PrimaryKeyConstraint.argument_for), [columns](#sqlalchemy.schema.PrimaryKeyConstraint.columns),
    [contains_column()](#sqlalchemy.schema.PrimaryKeyConstraint.contains_column),
    [copy()](#sqlalchemy.schema.PrimaryKeyConstraint.copy), [ddl_if()](#sqlalchemy.schema.PrimaryKeyConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.PrimaryKeyConstraint.dialect_options),
    [info](#sqlalchemy.schema.PrimaryKeyConstraint.info), [kwargs](#sqlalchemy.schema.PrimaryKeyConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.PrimaryKeyConstraint`](#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: A table-level UNIQUE constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a single column or composite UNIQUE constraint. For a no-frills, single
    column constraint, adding `unique=True` to the `Column` definition is a shorthand
    equivalent for an unnamed, single column UniqueConstraint.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.UniqueConstraint.__init__), [argument_for()](#sqlalchemy.schema.UniqueConstraint.argument_for),
    [columns](#sqlalchemy.schema.UniqueConstraint.columns), [contains_column()](#sqlalchemy.schema.UniqueConstraint.contains_column),
    [copy()](#sqlalchemy.schema.UniqueConstraint.copy), [ddl_if()](#sqlalchemy.schema.UniqueConstraint.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.UniqueConstraint.dialect_kwargs), [dialect_options](#sqlalchemy.schema.UniqueConstraint.dialect_options),
    [info](#sqlalchemy.schema.UniqueConstraint.info), [kwargs](#sqlalchemy.schema.UniqueConstraint.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.UniqueConstraint`](#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.schema.ColumnCollectionConstraint.__init__`
    *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*columns` – A sequence of column names or Column objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – other keyword arguments including dialect-specific arguments
    are propagated to the [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `ColumnCollectionMixin.columns` *attribute of* [`ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin")'
  prefs: []
  type: TYPE_NORMAL
- en: A [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") representing the set of columns
    for this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.contains_column()`](#sqlalchemy.schema.ColumnCollectionConstraint.contains_column
    "sqlalchemy.schema.ColumnCollectionConstraint.contains_column") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: Return True if this constraint contains the given column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this object also contains an attribute `.columns` which is a [`ColumnCollection`](sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") of [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") *method of* [`ColumnCollectionConstraint`](#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The [`ColumnCollectionConstraint.copy()`](#sqlalchemy.schema.ColumnCollectionConstraint.copy
    "sqlalchemy.schema.ColumnCollectionConstraint.copy") method is deprecated and
    will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Mark a string indicating that a name has already been converted by a naming
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: This is a string subclass that indicates a name that should not be subject to
    any further naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. when we create a [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    using a naming convention as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: The name of the above constraint will be rendered as `"ck_t_x5"`. That is, the
    existing name `x5` is used in the naming convention as the `constraint_name` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, such as in migration scripts, we may be rendering the above
    [`CheckConstraint`](#sqlalchemy.schema.CheckConstraint "sqlalchemy.schema.CheckConstraint")
    with a name that’s already been converted. In order to make sure the name isn’t
    double-modified, the new name is applied using the [`conv()`](#sqlalchemy.schema.conv
    "sqlalchemy.schema.conv") marker. We can use this explicitly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`conv()`](#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    marker indicates that the constraint name here is final, and the name will render
    as `"ck_t_x5"` and not `"ck_t_ck_t_x5"`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes can be created anonymously (using an auto-generated name `ix_<column
    label>`) for a single column using the inline `index` keyword on [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), which also modifies the usage of `unique` to apply
    the uniqueness to the index itself, instead of adding a separate UNIQUE constraint.
    For indexes with specific names or which encompass more than one column, use the
    [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") construct, which
    requires a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below we illustrate a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    with several [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") objects
    associated. The DDL for “CREATE INDEX” is issued right after the create statements
    for the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the example above, the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is created externally to the table which it corresponds, using [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects directly. [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") also supports “inline” definition inside the [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), using string names to identify columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") object also
    supports its own `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '### Functional Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") supports SQL
    and function expressions, as supported by the target backend. To create an index
    against a column using a descending value, the [`ColumnElement.desc()`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifier may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with a backend that supports functional indexes such as PostgreSQL, a “case
    insensitive” index can be created using the `lower()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]  ### Functional Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") supports SQL
    and function expressions, as supported by the target backend. To create an index
    against a column using a descending value, the [`ColumnElement.desc()`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc
    "sqlalchemy.sql.expression.ColumnElement.desc") modifier may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with a backend that supports functional indexes such as PostgreSQL, a “case
    insensitive” index can be created using the `lower()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Index API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Index](#sqlalchemy.schema.Index) | A table-level INDEX. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: A table-level INDEX.
  prefs: []
  type: TYPE_NORMAL
- en: Defines a composite (one or more column) INDEX.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'For a no-frills, single column index, adding [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") also supports `index=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'For a composite index, multiple columns can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Functional indexes are supported as well, typically by using the [`func`](sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct in conjunction with table-bound [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'An [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index") can also be
    manually associated with a [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    either through inline declaration or using [`Table.append_constraint()`](metadata.html#sqlalchemy.schema.Table.append_constraint
    "sqlalchemy.schema.Table.append_constraint"). When this approach is used, the
    names of the indexed columns can be specified as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'To support functional or expression-based indexes in this form, the [`text()`](sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexes](#schema-indexes) - General information on [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL-Specific Index Options](../dialects/postgresql.html#postgresql-indexes)
    - PostgreSQL-specific options available for the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB- Specific Index Options](../dialects/mysql.html#mysql-indexes)
    - MySQL-specific options available for the [`Index`](#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes) - MSSQL-specific
    options available for the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.schema.Index.__init__), [argument_for()](#sqlalchemy.schema.Index.argument_for),
    [create()](#sqlalchemy.schema.Index.create), [ddl_if()](#sqlalchemy.schema.Index.ddl_if),
    [dialect_kwargs](#sqlalchemy.schema.Index.dialect_kwargs), [dialect_options](#sqlalchemy.schema.Index.dialect_options),
    [drop()](#sqlalchemy.schema.Index.drop), [info](#sqlalchemy.schema.Index.info),
    [kwargs](#sqlalchemy.schema.Index.kwargs)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.schema.Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    ([`sqlalchemy.sql.base.DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs"), [`sqlalchemy.schema.ColumnCollectionMixin`](#sqlalchemy.schema.ColumnCollectionMixin
    "sqlalchemy.schema.ColumnCollectionMixin"), [`sqlalchemy.schema.HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL"), [`sqlalchemy.schema.SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Construct an index object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – The name of the index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*expressions` – Column expressions to include in the index. The expressions
    are normally instances of [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    but may also be arbitrary SQL expressions which ultimately refer to a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique=False` – Keyword only argument; if True, create a unique index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quote=None` – Keyword only argument; whether to apply quoting to the name
    of the index. Works in the same manner as that of [`Column.quote`](metadata.html#sqlalchemy.schema.Column.params.quote
    "sqlalchemy.schema.Column").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info=None` – Optional data dictionary which will be populated into the [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") attribute of this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**dialect_kw` – Additional keyword arguments not mentioned above are dialect
    specific, and passed in the form `<dialectname>_<argname>`. See the documentation
    regarding an individual dialect at [Dialects](../dialects/index.html) for detail
    on documented arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") *method of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new kind of dialect-specific keyword argument for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: The [`DialectKWArgs.argument_for()`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.argument_for
    "sqlalchemy.sql.base.DialectKWArgs.argument_for") method is a per-argument way
    adding extra arguments to the [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") dictionary. This
    dictionary provides a list of argument names accepted by various schema-level
    constructs on behalf of a dialect.
  prefs: []
  type: TYPE_NORMAL
- en: New dialects should typically specify this dictionary all at once as a data
    member of the dialect class. The use case for ad-hoc addition of argument names
    is typically for end-user code that is also using a custom compilation scheme
    which consumes the additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect_name` – name of a dialect. The dialect must be locatable, else a [`NoSuchModuleError`](exceptions.html#sqlalchemy.exc.NoSuchModuleError
    "sqlalchemy.exc.NoSuchModuleError") is raised. The dialect must also include an
    existing [`DefaultDialect.construct_arguments`](internals.html#sqlalchemy.engine.default.DefaultDialect.construct_arguments
    "sqlalchemy.engine.default.DefaultDialect.construct_arguments") collection, indicating
    that it participates in the keyword-argument validation and default system, else
    [`ArgumentError`](exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    is raised. If the dialect does not include this collection, then any keyword argument
    can be specified on behalf of this dialect already. All dialects packaged within
    SQLAlchemy include this collection, however for third party dialects, support
    may vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument_name` – name of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – default value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Issue a `CREATE` statement for this [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index"),
    using the given [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or `Engine`` for connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.create_all()`](metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if
    "sqlalchemy.schema.HasConditionalDDL.ddl_if") *method of* [`HasConditionalDDL`](#sqlalchemy.schema.HasConditionalDDL
    "sqlalchemy.schema.HasConditionalDDL")'
  prefs: []
  type: TYPE_NORMAL
- en: apply a conditional DDL rule to this schema item.
  prefs: []
  type: TYPE_NORMAL
- en: These rules work in a similar manner to the [`ExecutableDDLElement.execute_if()`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if
    "sqlalchemy.schema.ExecutableDDLElement.execute_if") callable, with the added
    feature that the criteria may be checked within the DDL compilation phase for
    a construct such as [`CreateTable`](ddl.html#sqlalchemy.schema.CreateTable "sqlalchemy.schema.CreateTable").
    [`HasConditionalDDL.ddl_if()`](#sqlalchemy.schema.HasConditionalDDL.ddl_if "sqlalchemy.schema.HasConditionalDDL.ddl_if")
    currently applies towards the [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct as well as all [`Constraint`](#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – string name of a dialect, or a tuple of string names to indicate
    multiple dialect types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable_` – a callable that is constructed using the same form as that described
    in [`ExecutableDDLElement.execute_if.callable_`](ddl.html#sqlalchemy.schema.ExecutableDDLElement.execute_if.params.callable_
    "sqlalchemy.schema.ExecutableDDLElement.execute_if").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` – any arbitrary object that will be passed to the callable, if present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](ddl.html#schema-ddl-ddl-if)
    - background and usage examples'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are present here in their original `<dialect>_<kwarg>` format.
    Only arguments that were actually passed are included; unlike the [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") collection, which contains
    all options known by this dialect including defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The collection is also writable; keys are accepted of the form `<dialect>_<kwarg>`
    where the value will be assembled into the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") - nested dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.dialect_options`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_options
    "sqlalchemy.sql.base.DialectKWArgs.dialect_options") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of keyword arguments specified as dialect-specific options to this
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-level nested registry, keyed to `<dialect_name>` and `<argument_name>`.
    For example, the `postgresql_where` argument would be locatable as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: New in version 0.9.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs") - flat dictionary form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Issue a `DROP` statement for this [`Index`](#sqlalchemy.schema.Index "sqlalchemy.schema.Index"),
    using the given [`Connection`](connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    or [`Engine`](connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    for connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.drop_all()`](metadata.html#sqlalchemy.schema.MetaData.drop_all "sqlalchemy.schema.MetaData.drop_all").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaItem.info`](metadata.html#sqlalchemy.schema.SchemaItem.info
    "sqlalchemy.schema.SchemaItem.info") *attribute of* [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem")'
  prefs: []
  type: TYPE_NORMAL
- en: Info dictionary associated with the object, allowing user-defined data to be
    associated with this [`SchemaItem`](metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem").
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary is automatically generated when first accessed. It can also be
    specified in the constructor of some objects, such as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`DialectKWArgs.kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.kwargs
    "sqlalchemy.sql.base.DialectKWArgs.kwargs") *attribute of* [`DialectKWArgs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs
    "sqlalchemy.sql.base.DialectKWArgs")'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`DialectKWArgs.dialect_kwargs`](foundation.html#sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs
    "sqlalchemy.sql.base.DialectKWArgs.dialect_kwargs").
  prefs: []
  type: TYPE_NORMAL
