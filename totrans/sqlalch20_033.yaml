- en: Basic Relationship Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本关系模式
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html](https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html](https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html)
- en: A quick walkthrough of the basic relational patterns, which in this section
    are illustrated using [Declarative](declarative_styles.html#orm-explicit-declarative-base)
    style mappings based on the use of the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过基本关系模式的快速概述，使用基于[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注释类型的[声明性](declarative_styles.html#orm-explicit-declarative-base)样式映射来进行说明。
- en: 'The setup for each of the following sections is as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以下章节的设置如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declarative vs. Imperative Forms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式与命令式形式的对比
- en: 'As SQLAlchemy has evolved, different ORM configurational styles have emerged.
    For examples in this section and others that use annotated [Declarative](declarative_styles.html#orm-explicit-declarative-base)
    mappings with [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"),
    the corresponding non-annotated form should use the desired class, or string class
    name, as the first argument passed to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below illustrates the form used in
    this document, which is a fully Declarative example using [**PEP 484**](https://peps.python.org/pep-0484/)
    annotations, where the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is also deriving the target class and
    collection type from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation, which is the most modern form of SQLAlchemy Declarative mapping:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 SQLAlchemy 的发展，不同的 ORM 配置样式已经出现。在本节和其他使用带有注释的[声明性](declarative_styles.html#orm-explicit-declarative-base)映射的示例中，相应的非注释形式应该使用所需的类或字符串类名作为传递给[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的第一个参数。下面的示例说明了本文档中使用的形式，这是一个完全使用 [**PEP 484**](https://peps.python.org/pep-0484/)
    注释的声明性示例，其中 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造还从 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 注释中派生出目标类和集合类型，这是 SQLAlchemy 声明式映射的最现代形式：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In contrast, using a Declarative mapping **without** annotations is the more
    “classic” form of mapping, where [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") requires all parameters passed to it directly,
    as in the example below:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用不带注释的声明式映射是更加“经典”的映射形式，其中[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")要求直接传递所有参数，就像下面的示例中所示：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, using [Imperative Mapping](mapping_styles.html#orm-imperative-mapping),
    which is SQLAlchemy’s original mapping form before Declarative was made (which
    nonetheless remains preferred by a vocal minority of users), the above configuration
    looks like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用[命令式映射](mapping_styles.html#orm-imperative-mapping)，这是 SQLAlchemy 在声明式之前的原始映射形式（尽管仍然是一小部分用户偏爱的形式），以上配置看起来如下：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Additionally, the default collection style for non-annotated mappings is `list`.
    To use a `set` or other collection without annotations, indicate it using the
    [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，非注释映射的默认集合样式是`list`。要在没有注释的情况下使用`set`或其他集合，请使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数进行指定：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Detail on collection configuration for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is at [Customizing Collection Access](collection_api.html#custom-collections).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的集合配置的详细信息，请参阅[自定义集合访问](collection_api.html#custom-collections)。
- en: Additional differences between annotated and non-annotated / imperative styles
    will be noted as needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要将带有注释和不带注释 / 命令式样式之间的其他差异进行说明。
- en: '## One To Many'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '## 一对多'
- en: 'A one to many relationship places a foreign key on the child table referencing
    the parent. [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is then specified on the parent, as referencing
    a collection of items represented by the child:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多关系在子表上放置一个引用父表的外键。然后在父表上指定[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，表示引用子项的集合：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To establish a bidirectional relationship in one-to-many, where the “reverse”
    side is a many to one, specify an additional [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and connect the two using the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter, using the attribute name of each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as the value for [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") on the other:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一对多关系中建立双向关系，其中“反向”方是多对一，请指定一个额外的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")并使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数将两者连接起来，使用每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的属性名称作为另一个[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")上的值：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Child` will get a `parent` attribute with many-to-one semantics.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child`将获得一个具有多对一语义的`parent`属性。'
- en: '### Using Sets, Lists, or other Collection Types for One To Many'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用集合、列表或其他集合类型进行一对多关系'
- en: 'Using annotated Declarative mappings, the type of collection used for the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is derived from the collection type passed to the
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") container
    type. The example from the previous section may be written to use a `set` rather
    than a `list` for the `Parent.children` collection using `Mapped[Set["Child"]]`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带注释的声明性映射，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")所使用的集合类型是从传递给[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")容器类型的集合类型派生出来的。前一节中的示例可以编写为使用`set`而不是`list`作为`Parent.children`集合，使用`Mapped[Set["Child"]]`：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using non-annotated forms including imperative mappings, the Python class
    to use as a collection may be passed using the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用非带注释形式的映射时，可以通过[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递要用作集合的Python类。
- en: See also
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含了对集合配置的进一步细节，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技巧。'
- en: Configuring Delete Behavior for One to Many
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置一对多的删除行为
- en: It is often the case that all `Child` objects should be deleted when their owning
    `Parent` is deleted. To configure this behavior, the `delete` cascade option described
    at [delete](cascades.html#cascade-delete) is used. An additional option is that
    a `Child` object can itself be deleted when it is deassociated from its parent.
    This behavior is described at [delete-orphan](cascades.html#cascade-delete-orphan).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 往往情况下，当它们所属的`Parent`被删除时，所有的`Child`对象都应该被删除。为了配置这种行为，使用在[delete](cascades.html#cascade-delete)中描述的`delete`级联选项。另一个选项是，当`Child`对象与其父对象解除关联时，可以将`Child`对象本身删除。该行为在[delete-orphan](cascades.html#cascade-delete-orphan)中描述。
- en: See also
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[delete](cascades.html#cascade-delete)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](cascades.html#cascade-delete)'
- en: '[Using foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 ORM 关联的外键 ON DELETE cascade](cascades.html#passive-deletes)'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan)  ## Many To One'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](cascades.html#cascade-delete-orphan)  ## 多对一'
- en: 'Many to one places a foreign key in the parent table referencing the child.
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    is declared on the parent, where a new scalar-holding attribute will be created:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 多对一（Many to one）在父表中放置一个外键，指向子表。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在父表上声明，在此将创建一个新的标量持有属性：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above example shows a many-to-one relationship that assumes non-nullable
    behavior; the next section, [Nullable Many-to-One](#relationship-patterns-nullable-m2o),
    illustrates a nullable version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子展示了假定非空行为的多对一关系；下一节，[可空的多对一（Nullable Many-to-One）](#relationship-patterns-nullable-m2o)，说明了可空版本。
- en: 'Bidirectional behavior is achieved by adding a second [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and applying the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter in both directions, using the attribute
    name of each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as the value for [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") on the other:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 双向行为通过添加第二个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 并在两个方向上应用 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 参数来实现，在另一个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的属性名称作为 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 的值：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '### Nullable Many-to-One'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可空的多对一（Nullable Many-to-One）'
- en: 'In the preceding example, the `Parent.child` relationship is not typed as allowing
    `None`; this follows from the `Parent.child_id` column itself not being nullable,
    as it is typed with `Mapped[int]`. If we wanted `Parent.child` to be a **nullable**
    many-to-one, we can set both `Parent.child_id` and `Parent.child` to be `Optional[]`,
    in which case the configuration would look like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，`Parent.child` 关系未被类型化为允许 `None`；这源于 `Parent.child_id` 列本身不可为空，因为它使用
    `Mapped[int]` 类型。如果我们希望 `Parent.child` 是**可空**的多对一关系，我们可以将 `Parent.child_id` 和
    `Parent.child` 都设置为 `Optional[]`，在这种情况下，配置将如下所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Above, the column for `Parent.child_id` will be created in DDL to allow `NULL`
    values. When using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") with explicit typing declarations, the specification
    of `child_id: Mapped[Optional[int]]` is equivalent to setting [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") to `True` on the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), whereas `child_id: Mapped[int]` is equivalent to
    setting it to `False`. See [mapped_column() derives the datatype and nullability
    from the Mapped annotation](declarative_tables.html#orm-declarative-mapped-column-nullability)
    for background on this behavior.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '上面，DDL中将创建 `Parent.child_id` 列以允许 `NULL` 值。当使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 与显式类型声明时，指定 `child_id: Mapped[Optional[int]]`
    等效于在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    上设置 [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") 为 `True`，而 `child_id: Mapped[int]` 等效于将其设置为 `False`。有关此行为的背景，请参见
    [mapped_column() 从 Mapped 注释中派生数据类型和可为空性](declarative_tables.html#orm-declarative-mapped-column-nullability)。'
- en: Tip
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If using Python 3.10 or greater, [**PEP 604**](https://peps.python.org/pep-0604/)
    syntax is more convenient to indicate optional types using `| None`, which when
    combined with [**PEP 563**](https://peps.python.org/pep-0563/) postponed annotation
    evaluation so that string-quoted types aren’t required, would look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Python 3.10 或更高版本，[**PEP 604**](https://peps.python.org/pep-0604/) 语法更方便，可以使用
    `| None` 指示可选类型，与[**PEP 563**](https://peps.python.org/pep-0563/)延迟注释评估结合使用，这样就不需要使用带字符串引号的类型，如下所示：
- en: '[PRE11]  ## One To One'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]  ## 一对一（One To One）'
- en: One To One is essentially a [One To Many](#relationship-patterns-o2m) relationship
    from a foreign key perspective, but indicates that there will only be one row
    at any time that refers to a particular parent row.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一（One To One）在外键视角上本质上是[一对多（One To Many）](#relationship-patterns-o2m)关系，但表示任何时候只会有一行引用特定父行。
- en: 'When using annotated mappings with [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the “one-to-one” convention is achieved by applying
    a non-collection type to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation on both sides of the relationship, which will imply to the ORM that
    a collection should not be used on either side, as in the example below:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注释的映射时，通过在关系的两端都应用非集合类型的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释来实现“一对一”约定，这将使ORM意识到不应在任一侧使用集合，就像下面的示例一样：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Above, when we load a `Parent` object, the `Parent.child` attribute will refer
    to a single `Child` object rather than a collection. If we replace the value of
    `Parent.child` with a new `Child` object, the ORM’s unit of work process will
    replace the previous `Child` row with the new one, setting the previous `child.parent_id`
    column to NULL by default unless there are specific [cascade](cascades.html#unitofwork-cascades)
    behaviors set up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，当我们加载一个`Parent`对象时，`Parent.child`属性将引用单个`Child`对象而不是集合。如果我们用一个新的`Child`对象替换`Parent.child`的值，ORM的工作单元过程将用新的对象替换以前的对象，将以前的`child.parent_id`列默认设置为NULL，除非设置了特定的[级联](cascades.html#unitofwork-cascades)行为。
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As mentioned previously, the ORM considers the “one-to-one” pattern as a convention,
    where it makes the assumption that when it loads the `Parent.child` attribute
    on a `Parent` object, it will get only one row back. If more than one row is returned,
    the ORM will emit a warning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，ORM将“一对一”模式视为一种约定，其中它假设当它加载`Parent.child`属性时，将只返回一行。如果返回多行，ORM将发出警告。
- en: 'However, the `Child.parent` side of the above relationship remains as a “many-to-one”
    relationship. By itself, it will not detect assignment of more than one `Child`,
    unless the [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") parameter is set, which may be useful:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，上述关系的`Child.parent`一侧仍然保持为“多对一”关系。单独使用它，它将无法检测到分配超过一个`Child`的情况，除非设置了[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")参数，这可能很有用：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Outside of setting this parameter, the “one-to-many” side (which here is one-to-one
    by convention) will also not reliably detect if more than one `Child` is associated
    with a single `Parent`, such as in the case where the multiple `Child` objects
    are pending and not database-persistent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此参数之外，“一对多”侧（在这里按照惯例是一对一）也无法可靠地检测到一个`Parent`关联多个`Child`的情况，例如，多个`Child`对象处于挂起状态且不在数据库中持久存在的情况。
- en: 'Whether or not [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") is used, it is recommended that the database schema
    include a [unique constraint](../core/constraints.html#schema-unique-constraint)
    to indicate that the `Child.parent_id` column should be unique, to ensure at the
    database level that only one `Child` row may refer to a particular `Parent` row
    at a time (see [Declarative Table Configuration](declarative_tables.html#orm-declarative-table-configuration)
    for background on the `__table_args__` tuple syntax):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")，建议数据库模式包含一个[唯一约束](../core/constraints.html#schema-unique-constraint)，以指示`Child.parent_id`列应该是唯一的，以确保在数据库级别上，只有一个`Child`行可以同时引用特定的`Parent`行（有关`__table_args__`元组语法的背景，请参阅[声明性表配置](declarative_tables.html#orm-declarative-table-configuration)）：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'New in version 2.0: The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct can derive the effective value of the
    [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") parameter from a given [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造可以从给定的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释中派生出[`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship")参数的有效值。
- en: Setting uselist=False for non-annotated configurations
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将非注释配置的uselist参数设置为False
- en: 'When using [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") without the benefit of [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotations, the one-to-one pattern can be enabled using
    the [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") parameter set to `False` on what would normally
    be the “many” side, illustrated in a non-annotated Declarative configuration below:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用没有 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注解的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    时，可以通过在通常是“多”的一侧将 [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") 参数设置为 `False` 来启用一对一模式，如下所示的非注解式声明配置：
- en: '[PRE15]  ## Many To Many'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]  ## 多对多'
- en: 'Many to Many adds an association table between two classes. The association
    table is nearly always given as a Core [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object or other Core selectable such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") object, and is indicated by the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). Usually, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") uses the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object associated with the declarative base class,
    so that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") directives can locate the remote tables with which
    to link:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Many to Many 在两个类之间添加了一个关联表。关联表几乎总是作为一个核心 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象或其他核心可选择的对象，比如一个 [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") 对象来给出，并且通过 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 函数的 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数来指定。通常，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 使用与声明基类关联的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象，这样 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 指令就可以定位远程表以进行关联：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The “association table” above has foreign key constraints established that
    refer to the two entity tables on either side of the relationship. The data type
    of each of `association.left_id` and `association.right_id` is normally inferred
    from that of the referenced table and may be omitted. It is also **recommended**,
    though not in any way required by SQLAlchemy, that the columns which refer to
    the two entity tables are established within either a **unique constraint** or
    more commonly as the **primary key constraint**; this ensures that duplicate rows
    won’t be persisted within the table regardless of issues on the application side:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的“关联表”中已经建立了指向关系两侧实体表的外键约束。`association.left_id` 和 `association.right_id`
    的每个数据类型通常从引用表中推断出，并且可以省略。虽然 SQLAlchemy 并不强制要求，但也**建议**将引用两个实体表的列建立在**唯一约束**或更常见的**主键约束**中；这样可以确保无论应用程序端出现什么问题，都不会在表中持久化重复的行：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Setting Bi-Directional Many-to-many
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置双向 Many-to-many
- en: 'For a bidirectional relationship, both sides of the relationship contain a
    collection. Specify using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), and for each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") specify the common association table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双向关系，关系的两侧都包含一个集合。使用 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 进行指定，并且对于每个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 指定共同的关联表：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using a late-evaluated form for the “secondary” argument
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用延迟评估形式来处理“次要”参数
- en: The [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") also accepts two different “late evaluated” forms,
    including string table name as well as lambda callable. See the section [Using
    a late-evaluated form for the “secondary” argument of many-to-many](#orm-declarative-relationship-secondary-eval)
    for background and examples.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数还接受两种不同的“延迟评估”形式，包括字符串表名以及lambda可调用。请参阅[使用“secondary”参数的延迟评估形式进行多对多关系](#orm-declarative-relationship-secondary-eval)部分了解背景和示例。'
- en: Using Sets, Lists, or other Collection Types for Many To Many
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合（Sets）、列表（Lists）或其他集合类型进行多对多关系
- en: 'Configuration of collections for a Many to Many relationship is identical to
    that of [One To Many](#relationship-patterns-o2m), as described at [Using Sets,
    Lists, or other Collection Types for One To Many](#relationship-patterns-o2m-collection).
    For an annotated mapping using [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the collection can be indicated by the type of collection
    used within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic class, such as `set`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为多对多关系配置集合的方式与[一对多](#relationship-patterns-o2m)完全相同，如在[使用集合（Sets）、列表（Lists）或其他集合类型进行一对多关系](#relationship-patterns-o2m-collection)中描述的那样。对于使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")进行注释的映射，可以通过[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类内部使用的集合类型来指示集合，例如`set`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When using non-annotated forms including imperative mappings, as is the case
    with one-to-many, the Python class to use as a collection may be passed using
    the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非注释形式包括命令式映射时，如一对多的情况，可以通过[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递要用作集合的Python类。
- en: See also
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含有关集合配置的进一步详细信息，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技术。'
- en: '### Deleting Rows from the Many to Many Table'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从多对多表中删除行'
- en: 'A behavior which is unique to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which is specified here is automatically subject to
    INSERT and DELETE statements, as objects are added or removed from the collection.
    There is **no need to delete from this table manually**. The act of removing a
    record from the collection will have the effect of the row being deleted on flush:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数的一个独特行为是，此处指定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")会自动受到INSERT和DELETE语句的影响，因为对象被添加或从集合中删除。**无需手动从此表中删除**。从集合中删除记录的操作将在刷新时将行删除：'
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A question which often arises is how the row in the “secondary” table can be
    deleted when the child object is handed directly to [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的一个问题是，当直接将子对象传递给[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")时，如何删除“secondary”表中的行：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are several possibilities here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种可能性：
- en: If there is a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") from `Parent` to `Child`, but there is **not**
    a reverse-relationship that links a particular `Child` to each `Parent`, SQLAlchemy
    will not have any awareness that when deleting this particular `Child` object,
    it needs to maintain the “secondary” table that links it to the `Parent`. No delete
    of the “secondary” table will occur.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从`Parent`到`Child`有一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，但没有反向关系将特定的`Child`链接到每个`Parent`，SQLAlchemy 将不会意识到在删除此特定的`Child`对象时，需要维护将其链接到`Parent`的“secondary”表。不会删除“secondary”表。
- en: If there is a relationship that links a particular `Child` to each `Parent`,
    suppose it’s called `Child.parents`, SQLAlchemy by default will load in the `Child.parents`
    collection to locate all `Parent` objects, and remove each row from the “secondary”
    table which establishes this link. Note that this relationship does not need to
    be bidirectional; SQLAlchemy is strictly looking at every [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") associated with the `Child` object being deleted.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在将特定的`Child`链接到每个`Parent`的关系，假设它称为`Child.parents`，SQLAlchemy 默认将加载`Child.parents`集合以定位所有`Parent`对象，并从建立此链接的“secondary”表中删除每行。请注意，此关系不需要是双向的；SQLAlchemy
    严格查看与要删除的`Child`对象关联的每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。
- en: A higher performing option here is to use ON DELETE CASCADE directives with
    the foreign keys used by the database. Assuming the database supports this feature,
    the database itself can be made to automatically delete rows in the “secondary”
    table as referencing rows in “child” are deleted. SQLAlchemy can be instructed
    to forego actively loading in the `Child.parents` collection in this case using
    the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); see [Using foreign key ON DELETE cascade with
    ORM relationships](cascades.html#passive-deletes) for more details on this.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的一个性能更高的选项是使用数据库使用的外键 ON DELETE CASCADE 指令。假设数据库支持此功能，数据库本身可以被设置为在删除“child”中的引用行时自动删除“secondary”表中的行。在这种情况下，SQLAlchemy
    可以通过在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")上使用[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")指令来指示放弃主动加载`Child.parents`集合；有关此操作的更多详细信息，请参阅[使用外键
    ON DELETE cascade 处理 ORM 关系](cascades.html#passive-deletes)。
- en: Note again, these behaviors are *only* relevant to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option used with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). If dealing with association tables that are mapped
    explicitly and are *not* present in the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option of a relevant [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), cascade rules can be used instead to automatically
    delete entities in reaction to a related entity being deleted - see [Cascades](cascades.html#unitofwork-cascades)
    for information on this feature.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这些行为仅与与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")一起使用的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")选项相关。如果处理的是显式映射的关联表，并且不存在于相关[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")选项中，那么可以使用级联规则来自动删除实体以响应相关实体的删除 - 有关此功能的信息，请参阅[级联](cascades.html#unitofwork-cascades)。
- en: See also
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using delete cascade with many-to-many relationships](cascades.html#cascade-delete-many-to-many)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用级联删除处理多对多关系](cascades.html#cascade-delete-many-to-many)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](cascades.html#passive-deletes-many-to-many)  ##
    Association Object'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用外键 ON DELETE 处理多对多关系](cascades.html#passive-deletes-many-to-many)  ## 关联对象'
- en: 'The association object pattern is a variant on many-to-many: it’s used when
    an association table contains additional columns beyond those which are foreign
    keys to the parent and child (or left and right) tables, columns which are most
    ideally mapped to their own ORM mapped class. This mapped class is mapped against
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that would otherwise be noted as [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") when using the many-to-many pattern.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关联对象模式是一种与多对多模式相异的变体：当一个关联表包含除了与父表和子表（或左表和右表）是外键关系的列之外的其他列时，最理想的情况是将这些列映射到它们自己的
    ORM 映射类中。这个映射类被映射到了 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    ，否则会在使用多对多模式时被标记为 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")。
- en: In the association object pattern, the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter is not used; instead, a class is mapped
    directly to the association table. Two individual [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs then link first the parent side to the
    mapped association class via one to many, and then the mapped association class
    to the child side via many-to-one, to form a uni-directional association object
    relationship from parent, to association, to child. For a bi-directional relationship,
    four [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs are used to link the mapped association class to both parent and child
    in both directions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联对象模式中，不使用 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数；相反，一个类直接映射到关联表。然后，两个独立的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造将首先父侧通过一对多连接到映射的关联类，然后通过多对一将映射的关联类连接到子侧，以形成从父对象到关联对象到子对象的单向关联对象关系。对于双向关系，使用四个
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    构造将映射的关联类链接到父对象和子对象，以在两个方向上建立联系。
- en: 'The example below illustrates a new class `Association` which maps to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") named `association`; this table now includes an additional
    column called `extra_data`, which is a string value that is stored along with
    each association between `Parent` and `Child`. By mapping the table to an explicit
    class, rudimental access from `Parent` to `Child` makes explicit use of `Association`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了一个新的类 `Association` ，它映射到了名为 `association` 的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") ，这个表现在包含了一个名为 `extra_data` 的额外列，这是一个字符串值，与 `Parent`
    和 `Child` 之间的每个关联一起存储。通过将表映射到一个显式类，从 `Parent` 到 `Child` 的原始访问明确地使用了 `Association`：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To illustrate the bi-directional version, we add two more [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, linked to the existing ones using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明双向版本，我们增加了两个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造，通过 [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 与现有的构造相连：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Working with the association pattern in its direct form requires that child
    objects are associated with an association instance before being appended to the
    parent; similarly, access from parent to child goes through the association object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在其直接形式中使用关联模式需要在将子对象附加到父对象之前将其与关联实例关联起来；同样，从父对象到子对象的访问通过关联对象进行：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To enhance the association object pattern such that direct access to the `Association`
    object is optional, SQLAlchemy provides the [Association Proxy](extensions/associationproxy.html)
    extension. This extension allows the configuration of attributes which will access
    two “hops” with a single access, one “hop” to the associated object, and a second
    to a target attribute.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强关联对象模式，使直接访问 `Association` 对象是可选的，SQLAlchemy 提供了 [Association Proxy](extensions/associationproxy.html)
    扩展。这个扩展允许配置属性，这些属性将通过单一访问访问两个“跳”，一个“跳”到关联对象，第二个“跳”到目标属性。
- en: See also
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Association Proxy](extensions/associationproxy.html) - allows direct “many
    to many” style access between parent and child for a three-class association object
    mapping.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联代理](extensions/associationproxy.html) - 允许父级和子级之间进行直接“多对多”样式访问，用于三类关联对象映射。'
- en: Warning
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid mixing the association object pattern with the [many-to-many](#relationships-many-to-many)
    pattern directly, as this produces conditions where data may be read and written
    in an inconsistent fashion without special steps; the [association proxy](extensions/associationproxy.html)
    is typically used to provide more succinct access. For more detailed background
    on the caveats introduced by this combination, see the next section [Combining
    Association Object with Many-to-Many Access Patterns](#association-pattern-w-m2m).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接混合使用关联对象模式和[多对多](#relationships-many-to-many)模式，因为这会产生数据可能以不一致的方式读取和写入的情况，而无需特殊步骤；[关联代理](extensions/associationproxy.html)通常用于提供更简洁的访问。有关此组合引入的注意事项的更详细背景，请参阅下一节[结合关联对象与多对多访问模式](#association-pattern-w-m2m)。
- en: '### Combining Association Object with Many-to-Many Access Patterns'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '### 结合关联对象与多对多访问模式'
- en: As mentioned in the previous section, the association object pattern does not
    automatically integrate with usage of the many-to-many pattern against the same
    tables/columns at the same time. From this it follows that read operations may
    return conflicting data and write operations may also attempt to flush conflicting
    changes, causing either integrity errors or unexpected inserts or deletes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，关联对象模式不会自动与同时针对相同表/列使用多对多模式的情况集成。由此可见，读操作可能返回冲突的数据，写操作也可能尝试刷新冲突的更改，导致完整性错误或意外的插入或删除。
- en: 'To illustrate, the example below configures a bidirectional many-to-many relationship
    between `Parent` and `Child` via `Parent.children` and `Child.parents`. At the
    same time, an association object relationship is also configured, between `Parent.child_associations
    -> Association.child` and `Child.parent_associations -> Association.parent`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，下面的示例配置了`Parent`和`Child`之间的双向多对多关系，通过`Parent.children`和`Child.parents`。同时，还配置了一个关联对象关系，即`Parent.child_associations
    -> Association.child`和`Child.parent_associations -> Association.parent`之间的关系：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When using this ORM model to make changes, changes made to `Parent.children`
    will not be coordinated with changes made to `Parent.child_associations` or `Child.parent_associations`
    in Python; while all of these relationships will continue to function normally
    by themselves, changes on one will not show up in another until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is expired, which normally occurs automatically after
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此ORM模型进行更改时，在Python中对`Parent.children`进行的更改将不会与对`Parent.child_associations`或`Child.parent_associations`进行的更改协调；虽然所有这些关系本身都将继续正常运行，但在一个关系上的更改不会显示在另一个关系中，直到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期，通常在[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")之后会自动发生。
- en: 'Additionally, if conflicting changes are made, such as adding a new `Association`
    object while also appending the same related `Child` to `Parent.children`, this
    will raise integrity errors when the unit of work flush process proceeds, as in
    the example below:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果进行了冲突的更改，例如同时添加了一个新的`Association`对象，同时将相同的相关`Child`附加到`Parent.children`，则在工作单元刷新过程进行时将引发完整性错误，如下例所示：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Appending `Child` to `Parent.children` directly also implies the creation of
    rows in the `association` table without indicating any value for the `association.extra_data`
    column, which will receive `NULL` for its value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将`Child`附加到`Parent.children`中也意味着在`association`表中创建行，而不指示`association.extra_data`列的任何值，该值将接收`NULL`作为其值。
- en: 'It’s fine to use a mapping like the above if you know what you’re doing; there
    may be good reason to use many-to-many relationships in the case where use of
    the “association object” pattern is infrequent, which is that it’s easier to load
    relationships along a single many-to-many relationship, which can also optimize
    slightly better how the “secondary” table is used in SQL statements, compared
    to how two separate relationships to an explicit association class is used. It’s
    at least a good idea to apply the [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") parameter to the “secondary” relationship to avoid
    the issue of conflicting changes occurring, as well as preventing `NULL` being
    written to the additional association columns, as below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你在做什么，像上面这样使用映射是可以的；在很少使用“关联对象”模式的情况下使用多对多关系可能是有充分理由的，因为通过单个多对多关系加载关系更容易，这也可以优化“次要”表在
    SQL 语句中的使用效果，与两个对显式关联类的分开关系的使用相比略有优势。至少将 [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 参数应用于“次要”关系是一个好主意，以避免发生冲突的更改，同时防止将 `NULL` 写入额外的关联列，如下所示：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The above mapping will not write any changes to `Parent.children` or `Child.parents`
    to the database, preventing conflicting writes. However, reads of `Parent.children`
    or `Child.parents` will not necessarily match the data that’s read from `Parent.child_associations`
    or `Child.parent_associations`, if changes are being made to these collections
    within the same transaction or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as where the viewonly collections are being read. If
    use of the association object relationships is infrequent and is carefully organized
    against code that accesses the many-to-many collections to avoid stale reads (in
    extreme cases, making direct use of [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") to cause collections to be refreshed within the
    current transaction), the pattern may be feasible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射不会将任何更改写入到数据库的 `Parent.children` 或 `Child.parents` 中，从而防止冲突写入。然而，如果在同一个事务或
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中对视图集合进行读取的同时对 `Parent.children` 或 `Child.parents` 进行读取，则对 `Parent.children` 或
    `Child.parents` 的读取不一定会匹配从 `Parent.child_associations` 或 `Child.parent_associations`
    中读取的数据。如果很少使用关联对象关系，并且对访问多对多集合的代码进行了精心组织以避免过时的读取（在极端情况下，直接使用 [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 来使集合在当前事务内刷新），则该模式可能是可行的。
- en: A popular alternative to the above pattern is one where the direct many-to-many
    `Parent.children` and `Child.parents` relationships are replaced with an extension
    that will transparently proxy through the `Association` class, while keeping everything
    consistent from the ORM’s point of view. This extension is known as the [Association
    Proxy](extensions/associationproxy.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的一个流行替代方案是，直接的多对多 `Parent.children` 和 `Child.parents` 关系被替换为一个扩展，该扩展将通过
    `Association` 类透明代理，同时从 ORM 的角度保持一切一致。这个扩展被称为[关联代理](extensions/associationproxy.html)。
- en: See also
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Association Proxy](extensions/associationproxy.html) - allows direct “many
    to many” style access between parent and child for a three-class association object
    mapping.  ## Late-Evaluation of Relationship Arguments'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联代理](extensions/associationproxy.html) - 允许父对象和子对象之间直接“多对多”样式的访问，用于三类关联对象映射。##
    关系参数的延迟评估'
- en: 'Most of the examples in the preceding sections illustrate mappings where the
    various [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs refer to their target classes using a string name, rather than the
    class itself, such as when using [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), a forward reference is generated that exists at runtime
    only as a string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，大多数示例都说明了各种[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造是如何使用字符串名称而不是类本身来引用它们的目标类的，比如当使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")时，会生成一个仅在运行时存在的字符串引用：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, when using non-annotated forms such as non-annotated Declarative
    or Imperative mappings, a string name is also supported directly by the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当使用非注释形式，如非注释的声明式或命令式映射时，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造也直接支持字符串名称：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These string names are resolved into classes in the mapper resolution stage,
    which is an internal process that occurs typically after all mappings have been
    defined and is normally triggered by the first usage of the mappings themselves.
    The [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object is the container where these names are stored and resolved to the mapped
    classes to which they refer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串名称在映射解析阶段解析为类，这是一个内部过程，通常在所有映射都被定义后发生，并且通常由映射本身的第一次使用触发。[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象是存储这些名称并将其解析为它们所引用的映射类的容器。
- en: In addition to the main class argument for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), other arguments which depend upon the columns
    present on an as-yet undefined class may also be specified either as Python functions,
    or more commonly as strings. For most of these arguments except that of the main
    argument, string inputs are **evaluated as Python expressions using Python’s built-in
    eval() function**, as they are intended to receive complete SQL expressions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的主类参数之外，还可以指定依赖于尚未定义类中存在的列的其他参数，这些参数可以是Python函数，或更常见的是字符串。对于这些参数中的大多数（除了主参数之外），字符串输入
    **使用Python内置的eval()函数求值为Python表达式**，因为它们旨在接收完整的SQL表达式。
- en: Warning
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As the Python `eval()` function is used to interpret the late-evaluated string
    arguments passed to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mapper configuration construct, these arguments
    should **not** be repurposed such that they would receive untrusted user input;
    `eval()` is **not secure** against untrusted user input.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的`eval()`函数用于解释传递给[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射配置构造函数的后期评估的字符串参数，因此这些参数 **不应该** 被重新用于接收不受信任的用户输入；`eval()`对不受信任的用户输入
    **不安全**。
- en: 'The full namespace available within this evaluation includes all classes mapped
    for this declarative base, as well as the contents of the `sqlalchemy` package,
    including expression functions like [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") and `sqlalchemy.sql.functions.func`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此评估中可用的完整命名空间包括为此声明基类映射的所有类，以及`sqlalchemy`包的内容，包括表达式函数如[`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc")和`sqlalchemy.sql.functions.func`：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the case where more than one module contains a class of the same name,
    string class names can also be specified as module-qualified paths within any
    of these string expressions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含多个模块都包含相同名称类的情况，字符串类名也可以在任何这些字符串表达式中指定为模块限定路径：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In an example like the above, the string passed to [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") can be disambiguated from a specific class argument by
    passing the class location string directly to [`relationship.argument`](relationship_api.html#sqlalchemy.orm.relationship.params.argument
    "sqlalchemy.orm.relationship") as well. Below illustrates a typing-only import
    for `Child`, combined with a runtime specifier for the target class that will
    search for the correct name within the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似上面的示例中，传递给[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的字符串也可以通过直接将类位置字符串传递给[`relationship.argument`](relationship_api.html#sqlalchemy.orm.relationship.params.argument
    "sqlalchemy.orm.relationship")来消除特定类参数的歧义。下面演示了对`Child`进行仅类型导入，并与将在[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")中搜索正确名称的目标类的运行时说明符相结合的示例：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The qualified path can be any partial path that removes ambiguity between the
    names. For example, to disambiguate between `myapp.model1.Child` and `myapp.model2.Child`,
    we can specify `model1.Child` or `model2.Child`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 合格的路径可以是任何消除名称歧义的部分路径。例如，为了消除`myapp.model1.Child`和`myapp.model2.Child`之间的歧义，我们可以指定`model1.Child`或`model2.Child`：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    construct also accepts Python functions or lambdas as input for these arguments.
    A Python functional approach might look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    构造还接受 Python 函数或 lambda 作为这些参数的输入。Python 函数式方法可能如下所示：'
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The full list of parameters which accept Python functions/lambdas or strings
    that will be passed to `eval()` are:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 Python 函数/lambda 或将传递给 `eval()` 的字符串的完整参数列表为：
- en: '[`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship")'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")'
- en: '[`relationship._user_defined_foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params._user_defined_foreign_keys
    "sqlalchemy.orm.relationship")'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship._user_defined_foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params._user_defined_foreign_keys
    "sqlalchemy.orm.relationship")'
- en: Warning
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As stated previously, the above parameters to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are **evaluated as Python code expressions using
    eval(). DO NOT PASS UNTRUSTED INPUT TO THESE ARGUMENTS.**
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，上述参数[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")将**作为 Python 代码表达式使用 eval() 进行评估。不要向这些参数传递不受信任的输入。**
- en: '### Adding Relationships to Mapped Classes After Declaration'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在声明后向映射类添加关系'
- en: 'It should also be noted that in a similar way as described at [Appending additional
    columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns),
    any [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    construct can be added to a declarative base mapping at any time (noting that
    annotated forms are not supported in this context). If we wanted to implement
    this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    after the `Address` class were available, we could also apply it afterwards:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意，与[向现有的 Declarative 映射类添加附加列](declarative_tables.html#orm-declarative-table-adding-columns)中描述的类似，任何[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") 构造都可以随时添加到声明基本映射中（请注意，在此上下文中不支持注释形式）。如果我们希望在
    `Address` 类可用后实现此 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，我们也可以稍后应用它：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As is the case for ORM mapped columns, there’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in this operation; therefore,
    the related class must be specified directly within the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, either as the class itself, the string
    name of the class, or a callable function that returns a reference to the target
    class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM 映射列一样，[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注释类型没有参与此操作的能力；因此，相关类必须直接在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造中指定，可以作为类本身、类的字符串名称或返回目标类引用的可调用函数。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As is the case for ORM mapped columns, assignment of mapped properties to an
    already mapped class will only function correctly if the “declarative base” class
    is used, meaning the user-defined subclass of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") or the dynamically generated class returned
    by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base "sqlalchemy.orm.declarative_base")
    or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM 映射列一样，只有当“声明基类”类被使用时，即用户定义的 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 的子类或由 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 或 [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") 返回的动态生成的类时，将映射属性分配给已经映射的类才会正常工作。这个“基”类包含一个实现特殊
    `__setattr__()` 方法的 Python 元类，该方法拦截这些操作。
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ### Using a late-evaluated form
    for the “secondary” argument of many-to-many'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类使用装饰器如[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")或者使用命令式函数如[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")进行映射，那么将类映射属性运行时分配给映射类 **不会** 起作用。###
    对于多对多关系使用后期评估的形式
- en: Many-to-many relationships make use of the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, which ordinarily indicates a reference
    to a typically non-mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object or other Core selectable object. Late evaluation
    using a lambda callable is typical.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系使用 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数，通常指示一个参考到通常非映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象或其他 Core 可选择对象。通常使用 lambda 可调用对象进行延迟评估。
- en: 'For the example given at [Many To Many](#relationships-many-to-many), if we
    assumed that the `association_table` [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be defined at a point later on in the
    module than the mapped class itself, we may write the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using a lambda as:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的示例在[多对多关系](#relationships-many-to-many)中，如果我们假设`association_table` [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象会在模块中的后面定义，我们可以使用 lambda 来编写[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")如下：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As a shortcut for table names that are also **valid Python identifiers**, the
    [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter may also be passed as a string, where
    resolution works by evaluation of the string as a Python expression, with simple
    identifier names linked to same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that are present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection referenced by the current [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于也是**有效的 Python 标识符**的表名的快捷方式，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数也可以作为字符串传递，其中解析工作通过将字符串作为 Python 表达式进行评估，简单标识符名称与当前
    [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    引用的相同名称 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象链接到相同的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    集合中。
- en: 'In the example below, the expression `"association_table"` is evaluated as
    a variable named “association_table” that is resolved against the table names
    within the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，表达式 `"association_table"` 被视为一个名为“association_table”的变量，该变量相对于 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合中的表名进行解析：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When passed as a string, the name passed to [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") **must be a valid Python identifier** starting
    with a letter and containing only alphanumeric characters or underscores. Other
    characters such as dashes etc. will be interpreted as Python operators which will
    not resolve to the name given. Please consider using lambda expressions rather
    than strings for improved clarity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，传递给[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")的名称**必须是有效的Python标识符**，以字母开头，并且只包含字母数字字符或下划线。其他字符如短划线等将被解释为Python运算符，不会解析为给定的名称。请考虑使用lambda表达式而不是字符串以提高清晰度。
- en: Warning
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a string, [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function, even though it’s typically the name of a table. **DO NOT PASS UNTRUSTED
    INPUT TO THIS STRING**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数将使用Python的`eval()`函数进行解释，即使它通常是表的名称。**不要传递不可信的输入给这个字符串**。
- en: Declarative vs. Imperative Forms
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式 vs. 命令式形式
- en: 'As SQLAlchemy has evolved, different ORM configurational styles have emerged.
    For examples in this section and others that use annotated [Declarative](declarative_styles.html#orm-explicit-declarative-base)
    mappings with [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"),
    the corresponding non-annotated form should use the desired class, or string class
    name, as the first argument passed to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below illustrates the form used in
    this document, which is a fully Declarative example using [**PEP 484**](https://peps.python.org/pep-0484/)
    annotations, where the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct is also deriving the target class and
    collection type from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation, which is the most modern form of SQLAlchemy Declarative mapping:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SQLAlchemy的发展，不同的ORM配置风格已经出现。对于本节及其他使用带注解的[声明式](declarative_styles.html#orm-explicit-declarative-base)映射的示例，相应的非带注解形式应使用所需的类或字符串类名作为传递给[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的第一个参数。下面的示例说明了本文档中使用的形式，这是一个完全声明式的示例，使用[**PEP 484**](https://peps.python.org/pep-0484/)注解，其中[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造还从[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注解中推断目标类和集合类型，这是SQLAlchemy声明式映射的最现代形式：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In contrast, using a Declarative mapping **without** annotations is the more
    “classic” form of mapping, where [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") requires all parameters passed to it directly,
    as in the example below:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用不带注解的声明式映射更像是更“经典”的映射形式，其中[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")需要直接传递所有参数，如下例所示：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, using [Imperative Mapping](mapping_styles.html#orm-imperative-mapping),
    which is SQLAlchemy’s original mapping form before Declarative was made (which
    nonetheless remains preferred by a vocal minority of users), the above configuration
    looks like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用[命令式映射](mapping_styles.html#orm-imperative-mapping)，这是在声明式之前SQLAlchemy的原始映射形式（尽管仍然被少数用户偏爱），以上配置如下所示：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Additionally, the default collection style for non-annotated mappings is `list`.
    To use a `set` or other collection without annotations, indicate it using the
    [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于非带注解的映射，默认的集合样式是`list`。要使用`set`或其他集合而不带注解，可以使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数进行指示：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Detail on collection configuration for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is at [Customizing Collection Access](collection_api.html#custom-collections).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的集合配置详细信息，请参阅[自定义集合访问](collection_api.html#custom-collections)。
- en: Additional differences between annotated and non-annotated / imperative styles
    will be noted as needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，将注意到注释和非注释/命令式样式之间的其他差异。
- en: '## One To Many'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '## 一对多'
- en: 'A one to many relationship places a foreign key on the child table referencing
    the parent. [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is then specified on the parent, as referencing
    a collection of items represented by the child:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '一对多关系在子表上放置一个外键，引用父表。然后在父表上指定[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，作为对由子表表示的项目集合的引用： '
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To establish a bidirectional relationship in one-to-many, where the “reverse”
    side is a many to one, specify an additional [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and connect the two using the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter, using the attribute name of each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as the value for [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") on the other:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在一对多关系中建立双向关系时，其中“反向”端是多对一，需要指定一个额外的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")并使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数将两者连接起来，其中使用每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的属性名称作为另一个[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")的值：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Child` will get a `parent` attribute with many-to-one semantics.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child`将获得一个具有多对一语义的`parent`属性。'
- en: '### Using Sets, Lists, or other Collection Types for One To Many'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用集合、列表或其他集合类型进行一对多关系'
- en: 'Using annotated Declarative mappings, the type of collection used for the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is derived from the collection type passed to the
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") container
    type. The example from the previous section may be written to use a `set` rather
    than a `list` for the `Parent.children` collection using `Mapped[Set["Child"]]`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带注释的声明性映射时，用于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的集合类型是从传递给[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")容器类型的集合类型派生的。上一节的示例可以编写为使用`set`而不是`list`来表示`Parent.children`集合，使用`Mapped[Set["Child"]]`：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When using non-annotated forms including imperative mappings, the Python class
    to use as a collection may be passed using the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非注释形式，包括命令式映射时，可以使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递要用作集合的Python类。
- en: See also
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含了更多关于集合配置的细节，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技术。'
- en: Configuring Delete Behavior for One to Many
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置一对多关系的删除行为
- en: It is often the case that all `Child` objects should be deleted when their owning
    `Parent` is deleted. To configure this behavior, the `delete` cascade option described
    at [delete](cascades.html#cascade-delete) is used. An additional option is that
    a `Child` object can itself be deleted when it is deassociated from its parent.
    This behavior is described at [delete-orphan](cascades.html#cascade-delete-orphan).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当其所属的`Parent`被删除时，所有`Child`对象都应该被删除。为了配置这种行为，使用[delete](cascades.html#cascade-delete)中描述的`delete`级联选项。另一个选项是，当`Child`对象与其父对象解除关联时，可以删除`Child`对象本身。这种行为在[delete-orphan](cascades.html#cascade-delete-orphan)中描述。
- en: See also
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[delete](cascades.html#cascade-delete)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](cascades.html#cascade-delete)'
- en: '[Using foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用ORM关系的外键ON DELETE级联](cascades.html#passive-deletes)'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](cascades.html#cascade-delete-orphan)'
- en: '### Using Sets, Lists, or other Collection Types for One To Many'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用集合、列表或其他集合类型进行一对多关系'
- en: 'Using annotated Declarative mappings, the type of collection used for the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is derived from the collection type passed to the
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") container
    type. The example from the previous section may be written to use a `set` rather
    than a `list` for the `Parent.children` collection using `Mapped[Set["Child"]]`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带注释的声明性映射，从传递给[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")容器类型的集合类型派生出用于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的集合类型。可以写一个例子，以使用`set`而不是`list`来表示`Parent.children`集合，使用`Mapped[Set["Child"]]`：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When using non-annotated forms including imperative mappings, the Python class
    to use as a collection may be passed using the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用非注释形式，包括命令式映射时，可以使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递要用作集合的Python类。
- en: See also
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含有关集合配置的更多详细信息，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技术。'
- en: Configuring Delete Behavior for One to Many
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置一对多的删除行为
- en: It is often the case that all `Child` objects should be deleted when their owning
    `Parent` is deleted. To configure this behavior, the `delete` cascade option described
    at [delete](cascades.html#cascade-delete) is used. An additional option is that
    a `Child` object can itself be deleted when it is deassociated from its parent.
    This behavior is described at [delete-orphan](cascades.html#cascade-delete-orphan).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当其所属的`Parent`被删除时，所有的`Child`对象都应该被删除。要配置此行为，可以使用在[删除](cascades.html#cascade-delete)中描述的`delete`级联选项。另一个选项是当`Child`对象与其父对象解除关联时，它本身也可以被删除。这种行为在[删除孤儿](cascades.html#cascade-delete-orphan)中描述。
- en: See also
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[delete](cascades.html#cascade-delete)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[删除](cascades.html#cascade-delete)'
- en: '[Using foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用ORM关系的外键ON DELETE级联](cascades.html#passive-deletes)'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[删除孤儿](cascades.html#cascade-delete-orphan)'
- en: '## Many To One'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '## 多对一'
- en: 'Many to one places a foreign key in the parent table referencing the child.
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    is declared on the parent, where a new scalar-holding attribute will be created:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 多对一在父表中放置了一个引用子表的外键。在父级上声明[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，将创建一个新的标量持有属性：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The above example shows a many-to-one relationship that assumes non-nullable
    behavior; the next section, [Nullable Many-to-One](#relationship-patterns-nullable-m2o),
    illustrates a nullable version.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例显示了一个假定为非空的多对一关系；下一节，[可空多对一](#relationship-patterns-nullable-m2o)，介绍了一个可空版本。
- en: 'Bidirectional behavior is achieved by adding a second [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and applying the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter in both directions, using the attribute
    name of each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as the value for [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") on the other:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在两个方向添加第二个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")并在两个方向上应用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数，使用每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的属性名称作为另一个[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")的值，实现了双向行为：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '### Nullable Many-to-One'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可空多对一'
- en: 'In the preceding example, the `Parent.child` relationship is not typed as allowing
    `None`; this follows from the `Parent.child_id` column itself not being nullable,
    as it is typed with `Mapped[int]`. If we wanted `Parent.child` to be a **nullable**
    many-to-one, we can set both `Parent.child_id` and `Parent.child` to be `Optional[]`,
    in which case the configuration would look like:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`Parent.child` 的关系未被类型化为允许 `None`；这是因为 `Parent.child_id` 列本身不可为空，因为它被类型化为
    `Mapped[int]`。如果我们想要 `Parent.child` 成为一个**可为空的**多对一关系，我们可以将 `Parent.child_id`
    和 `Parent.child` 都设置为 `Optional[]`，在这种情况下，配置将如下所示：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Above, the column for `Parent.child_id` will be created in DDL to allow `NULL`
    values. When using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") with explicit typing declarations, the specification
    of `child_id: Mapped[Optional[int]]` is equivalent to setting [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") to `True` on the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), whereas `child_id: Mapped[int]` is equivalent to
    setting it to `False`. See [mapped_column() derives the datatype and nullability
    from the Mapped annotation](declarative_tables.html#orm-declarative-mapped-column-nullability)
    for background on this behavior.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，用于 `Parent.child_id` 的列将在 DDL 中被创建以允许 `NULL` 值。在使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 进行显式类型声明时，对 `child_id: Mapped[Optional[int]]`
    的规定等效于将 [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") 设置为 `True` 在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 上，而 `child_id: Mapped[int]` 等效于将其设置为 `False`。有关此行为的背景信息，请参阅
    [mapped_column() 从 Mapped 注释中推导出数据类型和可为空性](declarative_tables.html#orm-declarative-mapped-column-nullability)。'
- en: Tip
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If using Python 3.10 or greater, [**PEP 604**](https://peps.python.org/pep-0604/)
    syntax is more convenient to indicate optional types using `| None`, which when
    combined with [**PEP 563**](https://peps.python.org/pep-0563/) postponed annotation
    evaluation so that string-quoted types aren’t required, would look like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Python 3.10 或更高版本，[**PEP 604**](https://peps.python.org/pep-0604/) 语法更方便，可使用
    `| None` 来指示可选类型，结合 [**PEP 563**](https://peps.python.org/pep-0563/) 推迟注释评估，以便不需要字符串引号类型，这将如下所示：
- en: '[PRE49]  ### Nullable Many-to-One'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE49] ### 可为空的多对一关系'
- en: 'In the preceding example, the `Parent.child` relationship is not typed as allowing
    `None`; this follows from the `Parent.child_id` column itself not being nullable,
    as it is typed with `Mapped[int]`. If we wanted `Parent.child` to be a **nullable**
    many-to-one, we can set both `Parent.child_id` and `Parent.child` to be `Optional[]`,
    in which case the configuration would look like:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`Parent.child` 的关系未被类型化为允许 `None`；这是因为 `Parent.child_id` 列本身不可为空，因为它被类型化为
    `Mapped[int]`。如果我们想要 `Parent.child` 成为一个**可为空的**多对一关系，我们可以将 `Parent.child_id`
    和 `Parent.child` 都设置为 `Optional[]`，在这种情况下，配置将如下所示：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Above, the column for `Parent.child_id` will be created in DDL to allow `NULL`
    values. When using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") with explicit typing declarations, the specification
    of `child_id: Mapped[Optional[int]]` is equivalent to setting [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") to `True` on the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), whereas `child_id: Mapped[int]` is equivalent to
    setting it to `False`. See [mapped_column() derives the datatype and nullability
    from the Mapped annotation](declarative_tables.html#orm-declarative-mapped-column-nullability)
    for background on this behavior.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，用于 `Parent.child_id` 的列将在 DDL 中被创建以允许 `NULL` 值。在使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 进行显式类型声明时，对 `child_id: Mapped[Optional[int]]`
    的规定等效于将 [`Column.nullable`](../core/metadata.html#sqlalchemy.schema.Column.params.nullable
    "sqlalchemy.schema.Column") 设置为 `True` 在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 上，而 `child_id: Mapped[int]` 等效于将其设置为 `False`。有关此行为的背景信息，请参阅
    [mapped_column() 从 Mapped 注释中推导出数据类型和可为空性](declarative_tables.html#orm-declarative-mapped-column-nullability)。'
- en: Tip
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If using Python 3.10 or greater, [**PEP 604**](https://peps.python.org/pep-0604/)
    syntax is more convenient to indicate optional types using `| None`, which when
    combined with [**PEP 563**](https://peps.python.org/pep-0563/) postponed annotation
    evaluation so that string-quoted types aren’t required, would look like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Python 3.10 或更高版本，[**PEP 604**](https://peps.python.org/pep-0604/) 语法更方便地使用`|
    None`来指示可选类型，与[**PEP 563**](https://peps.python.org/pep-0563/)推迟的注释评估结合使用，以便不需要字符串引号的类型，会是这样的：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '## One To One'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '## 一对一'
- en: One To One is essentially a [One To Many](#relationship-patterns-o2m) relationship
    from a foreign key perspective, but indicates that there will only be one row
    at any time that refers to a particular parent row.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: One To One 本质上是一个从外键角度来看的[一对多](#relationship-patterns-o2m)关系，但表示在任何时候只会有一行指向特定父行的行。
- en: 'When using annotated mappings with [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the “one-to-one” convention is achieved by applying
    a non-collection type to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation on both sides of the relationship, which will imply to the ORM that
    a collection should not be used on either side, as in the example below:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带注释的映射和[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")时，“一对一”约定通过在关系的两侧应用非集合类型到[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释来实现，这将暗示 ORM 不应在任一侧使用集合，如下面的示例所示：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Above, when we load a `Parent` object, the `Parent.child` attribute will refer
    to a single `Child` object rather than a collection. If we replace the value of
    `Parent.child` with a new `Child` object, the ORM’s unit of work process will
    replace the previous `Child` row with the new one, setting the previous `child.parent_id`
    column to NULL by default unless there are specific [cascade](cascades.html#unitofwork-cascades)
    behaviors set up.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子中，当我们加载一个`Parent`对象时，`Parent.child`属性将引用一个单个的`Child`对象而不是一个集合。如果我们用一个新的`Child`对象替换`Parent.child`的值，ORM
    的工作单元过程将用新的对象替换之前的对象，将之前的`child.parent_id`列默认设置为 NULL，除非设置了特定的[级联行为](cascades.html#unitofwork-cascades)。
- en: Tip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As mentioned previously, the ORM considers the “one-to-one” pattern as a convention,
    where it makes the assumption that when it loads the `Parent.child` attribute
    on a `Parent` object, it will get only one row back. If more than one row is returned,
    the ORM will emit a warning.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，ORM 将“一对一”模式视为一种约定，其中它假设当它加载`Parent.child`属性时，它只会得到一行返回。如果返回多行，ORM 将发出警告。
- en: 'However, the `Child.parent` side of the above relationship remains as a “many-to-one”
    relationship. By itself, it will not detect assignment of more than one `Child`,
    unless the [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") parameter is set, which may be useful:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述关系中的`Child.parent`方面仍然是一个“多对一”的关系。独自使用时，它不会检测到多个`Child`的赋值，除非设置了[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")参数，这可能是有用的：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Outside of setting this parameter, the “one-to-many” side (which here is one-to-one
    by convention) will also not reliably detect if more than one `Child` is associated
    with a single `Parent`, such as in the case where the multiple `Child` objects
    are pending and not database-persistent.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此参数之外，“一对多”方面（这里按照惯例是一对一）也不会可靠地检测到多个`Child`关联到单个`Parent`的情况，比如多个`Child`对象是挂起的并且不是数据库持久的情况。
- en: 'Whether or not [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") is used, it is recommended that the database schema
    include a [unique constraint](../core/constraints.html#schema-unique-constraint)
    to indicate that the `Child.parent_id` column should be unique, to ensure at the
    database level that only one `Child` row may refer to a particular `Parent` row
    at a time (see [Declarative Table Configuration](declarative_tables.html#orm-declarative-table-configuration)
    for background on the `__table_args__` tuple syntax):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用了[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")，建议数据库模式包括一个[唯一约束](../core/constraints.html#schema-unique-constraint)来指示`Child.parent_id`列应该是唯一的，以确保在数据库级别只有一行`Child`可能指向特定的`Parent`行（有关`__table_args__`元组语法的背景，请参阅[声明式表配置](declarative_tables.html#orm-declarative-table-configuration)）：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'New in version 2.0: The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct can derive the effective value of the
    [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") parameter from a given [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造可以从给定的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注解推导出[`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship")参数的有效值。
- en: Setting uselist=False for non-annotated configurations
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于非注解配置设置uselist=False
- en: 'When using [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") without the benefit of [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotations, the one-to-one pattern can be enabled using
    the [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") parameter set to `False` on what would normally
    be the “many” side, illustrated in a non-annotated Declarative configuration below:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当在没有使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注解的情况下使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，可以通过将通常是“多”端的[`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship")参数设置为`False`来启用一对一模式，如下面的非注解式声明配置所示：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Setting uselist=False for non-annotated configurations
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于非注解配置设置uselist=False
- en: 'When using [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") without the benefit of [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotations, the one-to-one pattern can be enabled using
    the [`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship") parameter set to `False` on what would normally
    be the “many” side, illustrated in a non-annotated Declarative configuration below:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当在没有使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注解的情况下使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，可以通过将通常是“多”端的[`relationship.uselist`](relationship_api.html#sqlalchemy.orm.relationship.params.uselist
    "sqlalchemy.orm.relationship")参数设置为`False`来启用一对一模式，如下面的非注解式声明配置所示：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '## Many To Many'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '## 多对多'
- en: 'Many to Many adds an association table between two classes. The association
    table is nearly always given as a Core [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object or other Core selectable such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") object, and is indicated by the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). Usually, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") uses the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object associated with the declarative base class,
    so that the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") directives can locate the remote tables with which
    to link:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多在两个类之间添加了一个关联表。这个关联表几乎总是以一个核心[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象或其他核心可选项（如[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象）的形式给出，并通过[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")函数的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数指示。通常，[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")使用与声明基类关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象，以便[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")指令可以定位要链接的远程表：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The “association table” above has foreign key constraints established that
    refer to the two entity tables on either side of the relationship. The data type
    of each of `association.left_id` and `association.right_id` is normally inferred
    from that of the referenced table and may be omitted. It is also **recommended**,
    though not in any way required by SQLAlchemy, that the columns which refer to
    the two entity tables are established within either a **unique constraint** or
    more commonly as the **primary key constraint**; this ensures that duplicate rows
    won’t be persisted within the table regardless of issues on the application side:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的“关联表”已建立了引用关系的外键约束，这些约束指向关系两侧的两个实体表。`association.left_id`和`association.right_id`的数据类型通常是从引用表的数据类型推断出来的，可以省略。虽然SQLAlchemy没有要求，但**建议**将指向两个实体表的列建立在**唯一约束**或更常见的**主键约束**中；这样可以确保无论应用程序端是否存在问题，表中都不会持续存在重复行：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Setting Bi-Directional Many-to-many
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置双向多对多
- en: 'For a bidirectional relationship, both sides of the relationship contain a
    collection. Specify using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), and for each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") specify the common association table:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双向关系，关系的两侧都包含一个集合。使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")进行指定，并且对于每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")指定共同的关联表：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using a late-evaluated form for the “secondary” argument
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“secondary”参数的后期评估形式
- en: The [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") also accepts two different “late evaluated” forms,
    including string table name as well as lambda callable. See the section [Using
    a late-evaluated form for the “secondary” argument of many-to-many](#orm-declarative-relationship-secondary-eval)
    for background and examples.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数还接受两种不同的“后期评估”形式，包括字符串表名称以及lambda可调用。有关背景和示例，请参见[使用“secondary”参数的后期评估形式进行多对多关系](#orm-declarative-relationship-secondary-eval)部分。'
- en: Using Sets, Lists, or other Collection Types for Many To Many
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合、列表或其他集合类型进行多对多
- en: 'Configuration of collections for a Many to Many relationship is identical to
    that of [One To Many](#relationship-patterns-o2m), as described at [Using Sets,
    Lists, or other Collection Types for One To Many](#relationship-patterns-o2m-collection).
    For an annotated mapping using [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the collection can be indicated by the type of collection
    used within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic class, such as `set`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 配置多对多关系的集合与[一对多](#relationship-patterns-o2m)的配置相同，如在[使用集合、列表或其他集合类型进行一对多关系](#relationship-patterns-o2m-collection)中所述。对于使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")进行注释的映射，集合可以由[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类内部使用的集合类型指示，例如`set`：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When using non-annotated forms including imperative mappings, as is the case
    with one-to-many, the Python class to use as a collection may be passed using
    the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用命令式映射（即一对多情况）的非注释形式时，可以通过[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递用作集合的Python类。
- en: See also
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含有关集合配置的进一步详细信息，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技术。'
- en: '### Deleting Rows from the Many to Many Table'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从多对多表中删除行'
- en: 'A behavior which is unique to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which is specified here is automatically subject to
    INSERT and DELETE statements, as objects are added or removed from the collection.
    There is **no need to delete from this table manually**. The act of removing a
    record from the collection will have the effect of the row being deleted on flush:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数是唯一的行为，这里指定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")将自动受到INSERT和DELETE语句的影响，当对象被添加或从集合中删除时。**没有必要手动从此表中删除**。从集合中删除记录的行为将导致刷新时删除该行的效果：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A question which often arises is how the row in the “secondary” table can be
    deleted when the child object is handed directly to [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当子对象直接传递给[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")时，“次要”表中的行如何删除经常会引起一个问题：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There are several possibilities here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种可能性：
- en: If there is a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") from `Parent` to `Child`, but there is **not**
    a reverse-relationship that links a particular `Child` to each `Parent`, SQLAlchemy
    will not have any awareness that when deleting this particular `Child` object,
    it needs to maintain the “secondary” table that links it to the `Parent`. No delete
    of the “secondary” table will occur.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从`Parent`到`Child`有一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，但是没有将特定的`Child`链接到每个`Parent`的反向关系，SQLAlchemy不会意识到删除此特定`Child`对象时需要维护链接到`Parent`的“次要”表。不会删除“次要”表的删除。
- en: If there is a relationship that links a particular `Child` to each `Parent`,
    suppose it’s called `Child.parents`, SQLAlchemy by default will load in the `Child.parents`
    collection to locate all `Parent` objects, and remove each row from the “secondary”
    table which establishes this link. Note that this relationship does not need to
    be bidirectional; SQLAlchemy is strictly looking at every [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") associated with the `Child` object being deleted.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在将特定的`Child`链接到每个`Parent`的关系，假设它被称为`Child.parents`，SQLAlchemy默认会加载`Child.parents`集合以定位所有`Parent`对象，并从建立此链接的“次要”表中删除每行。请注意，此关系不需要是双向的；SQLAlchemy严格地查看与被删除的`Child`对象相关联的每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。
- en: A higher performing option here is to use ON DELETE CASCADE directives with
    the foreign keys used by the database. Assuming the database supports this feature,
    the database itself can be made to automatically delete rows in the “secondary”
    table as referencing rows in “child” are deleted. SQLAlchemy can be instructed
    to forego actively loading in the `Child.parents` collection in this case using
    the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); see [Using foreign key ON DELETE cascade with
    ORM relationships](cascades.html#passive-deletes) for more details on this.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里的一个性能较高的选项是使用数据库中使用的外键的ON DELETE CASCADE指令。假设数据库支持这个特性，数据库本身可以被设置为在“子”中的引用行被删除时自动删除“次要”表中的行。在这种情况下，SQLAlchemy可以被指示放弃主动加载`Child.parents`集合，使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上的[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")指令；参见[使用ORM关系的外键ON DELETE级联](cascades.html#passive-deletes)以获取更多关于此的详细信息。
- en: Note again, these behaviors are *only* relevant to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option used with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). If dealing with association tables that are mapped
    explicitly and are *not* present in the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option of a relevant [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), cascade rules can be used instead to automatically
    delete entities in reaction to a related entity being deleted - see [Cascades](cascades.html#unitofwork-cascades)
    for information on this feature.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这些行为*仅*与与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")一起使用的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")选项相关。如果处理的是显式映射的关联表，并且这些表*不*出现在相关[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")选项中，则可以改用级联规则来自动删除实体，以响应相关实体的删除 - 有关此功能的信息，请参阅[级联](cascades.html#unitofwork-cascades)。
- en: See also
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using delete cascade with many-to-many relationships](cascades.html#cascade-delete-many-to-many)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[在多对多关系中使用级联删除](cascades.html#cascade-delete-many-to-many)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](cascades.html#passive-deletes-many-to-many)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[在多对多关系中使用外键ON DELETE](cascades.html#passive-deletes-many-to-many)'
- en: Setting Bi-Directional Many-to-many
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置双向多对多
- en: 'For a bidirectional relationship, both sides of the relationship contain a
    collection. Specify using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), and for each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") specify the common association table:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双向关系，关系的两端都包含一个集合。使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")来指定，并且对于每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")都要指定共同的关联表：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using a late-evaluated form for the “secondary” argument
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用延迟评估形式的“secondary”参数
- en: The [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") also accepts two different “late evaluated” forms,
    including string table name as well as lambda callable. See the section [Using
    a late-evaluated form for the “secondary” argument of many-to-many](#orm-declarative-relationship-secondary-eval)
    for background and examples.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数还接受两种不同的“延迟评估”形式，包括字符串表名以及lambda可调用。有关背景和示例，请参阅[使用“secondary”参数的延迟评估形式进行多对多关系](#orm-declarative-relationship-secondary-eval)部分。'
- en: Using Sets, Lists, or other Collection Types for Many To Many
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合、列表或其他集合类型进行多对多关系
- en: 'Configuration of collections for a Many to Many relationship is identical to
    that of [One To Many](#relationship-patterns-o2m), as described at [Using Sets,
    Lists, or other Collection Types for One To Many](#relationship-patterns-o2m-collection).
    For an annotated mapping using [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), the collection can be indicated by the type of collection
    used within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic class, such as `set`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多对多关系的集合配置与[一对多](#relationship-patterns-o2m)完全相同，如[使用集合、列表或其他集合类型进行一对多关系](#relationship-patterns-o2m-collection)中所述。对于使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")进行注释的映射，可以通过[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类中使用的集合类型来指示集合，例如`set`：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When using non-annotated forms including imperative mappings, as is the case
    with one-to-many, the Python class to use as a collection may be passed using
    the [`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship") parameter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用非注释形式，包括命令式映射时，就像一对多一样，可以使用[`relationship.collection_class`](relationship_api.html#sqlalchemy.orm.relationship.params.collection_class
    "sqlalchemy.orm.relationship")参数传递要用作集合的Python类。
- en: See also
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing Collection Access](collection_api.html#custom-collections) - contains
    further detail on collection configuration including some techniques to map [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to dictionaries.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义集合访问](collection_api.html#custom-collections) - 包含有关集合配置的进一步详细信息，包括一些将[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射到字典的技术。'
- en: '### Deleting Rows from the Many to Many Table'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从多对多表中删除行'
- en: 'A behavior which is unique to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is that the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which is specified here is automatically subject to
    INSERT and DELETE statements, as objects are added or removed from the collection.
    There is **no need to delete from this table manually**. The act of removing a
    record from the collection will have the effect of the row being deleted on flush:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")参数中唯一的行为是，指定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")在对象被添加或从集合中删除时会自动受到INSERT和DELETE语句的影响。**无需手动从此表中删除**。从集合中删除记录的行为将导致在flush时删除该行：'
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A question which often arises is how the row in the “secondary” table can be
    deleted when the child object is handed directly to [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的一个问题是当直接将子对象传递给[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")时如何删除“secondary”表中的行：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There are several possibilities here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种可能性：
- en: If there is a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") from `Parent` to `Child`, but there is **not**
    a reverse-relationship that links a particular `Child` to each `Parent`, SQLAlchemy
    will not have any awareness that when deleting this particular `Child` object,
    it needs to maintain the “secondary” table that links it to the `Parent`. No delete
    of the “secondary” table will occur.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从`Parent`到`Child`有一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，但没有一个反向关系将特定的`Child`与每个`Parent`关联起来，SQLAlchemy将不会意识到当删除这个特定的`Child`对象时，它需要维护将其与`Parent`链接起来的“secondary”表。不会删除“secondary”表。
- en: If there is a relationship that links a particular `Child` to each `Parent`,
    suppose it’s called `Child.parents`, SQLAlchemy by default will load in the `Child.parents`
    collection to locate all `Parent` objects, and remove each row from the “secondary”
    table which establishes this link. Note that this relationship does not need to
    be bidirectional; SQLAlchemy is strictly looking at every [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") associated with the `Child` object being deleted.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个将特定的`Child`与每个`Parent`关联起来的关系，假设它被称为`Child.parents`，SQLAlchemy默认会加载`Child.parents`集合以定位所有`Parent`对象，并从建立此链接的“secondary”表中删除每一行。请注意，此关系不需要是双向的；SQLAlchemy严格查看与正在删除的`Child`对象相关联的每一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。
- en: A higher performing option here is to use ON DELETE CASCADE directives with
    the foreign keys used by the database. Assuming the database supports this feature,
    the database itself can be made to automatically delete rows in the “secondary”
    table as referencing rows in “child” are deleted. SQLAlchemy can be instructed
    to forego actively loading in the `Child.parents` collection in this case using
    the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); see [Using foreign key ON DELETE cascade with
    ORM relationships](cascades.html#passive-deletes) for more details on this.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的一个性能更高的选项是与数据库一起使用 ON DELETE CASCADE 指令。假设数据库支持这个功能，数据库本身可以被设置为在“子”中的引用行被删除时自动删除“辅助”表中的行。在这种情况下，SQLAlchemy
    可以被指示不要主动加载 `Child.parents` 集合，使用 [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 指令在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上；有关此更多详细信息，请参阅 [使用外键 ON DELETE cascade 处理 ORM
    关系](cascades.html#passive-deletes)。
- en: Note again, these behaviors are *only* relevant to the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option used with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). If dealing with association tables that are mapped
    explicitly and are *not* present in the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") option of a relevant [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), cascade rules can be used instead to automatically
    delete entities in reaction to a related entity being deleted - see [Cascades](cascades.html#unitofwork-cascades)
    for information on this feature.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这些行为*仅*与 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 选项相关。如果处理显式映射的关联表，而不是存在于相关 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 选项中的关联表，那么级联规则可以被用来在相关实体被删除时自动删除实体 - 有关此功能的信息，请参阅
    [级联](cascades.html#unitofwork-cascades)。
- en: See also
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using delete cascade with many-to-many relationships](cascades.html#cascade-delete-many-to-many)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用多对多关系的级联删除](cascades.html#cascade-delete-many-to-many)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](cascades.html#passive-deletes-many-to-many)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用外键 ON DELETE 处理多对多关系](cascades.html#passive-deletes-many-to-many)'
- en: '## Association Object'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '## 协会对象'
- en: 'The association object pattern is a variant on many-to-many: it’s used when
    an association table contains additional columns beyond those which are foreign
    keys to the parent and child (or left and right) tables, columns which are most
    ideally mapped to their own ORM mapped class. This mapped class is mapped against
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that would otherwise be noted as [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") when using the many-to-many pattern.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 协会对象模式是多对多关系的一种变体：当一个关联表包含除了那些与父表和子表（或左表和右表）的外键不同的额外列时，通常最理想的是将这些列映射到自己的 ORM
    映射类。这个映射类被映射到了[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，在使用多对多模式时，它本来会被指定为
    [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")。
- en: In the association object pattern, the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter is not used; instead, a class is mapped
    directly to the association table. Two individual [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs then link first the parent side to the
    mapped association class via one to many, and then the mapped association class
    to the child side via many-to-one, to form a uni-directional association object
    relationship from parent, to association, to child. For a bi-directional relationship,
    four [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs are used to link the mapped association class to both parent and child
    in both directions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联对象模式中，不使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数；相反，将类直接映射到关联表。然后，两个独立的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造首先通过一对多将父侧链接到映射的关联类，然后通过多对一将映射的关联类链接到子侧，以形成从父对象到关联对象到子对象的单向关联对象关系。对于双向关系，使用四个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造将映射的关联类与父对象和子对象在两个方向上进行链接。
- en: 'The example below illustrates a new class `Association` which maps to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") named `association`; this table now includes an additional
    column called `extra_data`, which is a string value that is stored along with
    each association between `Parent` and `Child`. By mapping the table to an explicit
    class, rudimental access from `Parent` to `Child` makes explicit use of `Association`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了一个新的类`Association`，它映射到名为`association`的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")；此表现在包括一个额外的列称为`extra_data`，它是一个字符串值，与`Parent`和`Child`之间的每个关联一起存储。通过将表映射到显式类，从`Parent`到`Child`的基本访问明确使用了`Association`：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To illustrate the bi-directional version, we add two more [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, linked to the existing ones using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明双向版本，我们添加了两个更多的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造，使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")连接到现有的构造：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Working with the association pattern in its direct form requires that child
    objects are associated with an association instance before being appended to the
    parent; similarly, access from parent to child goes through the association object:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关联对象模式的直接形式需要在将子对象附加到父对象之前将其与关联实例关联；同样，从父对象到子对象的访问需要通过关联对象进行：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To enhance the association object pattern such that direct access to the `Association`
    object is optional, SQLAlchemy provides the [Association Proxy](extensions/associationproxy.html)
    extension. This extension allows the configuration of attributes which will access
    two “hops” with a single access, one “hop” to the associated object, and a second
    to a target attribute.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强关联对象模式，使得对`Association`对象的直接访问是可选的，SQLAlchemy提供了[关联代理](extensions/associationproxy.html)扩展。该扩展允许配置属性，这些属性将通过单个访问实现两次“跳跃”，一次是到关联对象，另一次是到目标属性。
- en: See also
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Association Proxy](extensions/associationproxy.html) - allows direct “many
    to many” style access between parent and child for a three-class association object
    mapping.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联代理](extensions/associationproxy.html) - 允许在三类关联对象映射中在父对象和子对象之间直接进行“多对多”样式的访问。'
- en: Warning
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid mixing the association object pattern with the [many-to-many](#relationships-many-to-many)
    pattern directly, as this produces conditions where data may be read and written
    in an inconsistent fashion without special steps; the [association proxy](extensions/associationproxy.html)
    is typically used to provide more succinct access. For more detailed background
    on the caveats introduced by this combination, see the next section [Combining
    Association Object with Many-to-Many Access Patterns](#association-pattern-w-m2m).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接混合使用关联对象模式和[多对多](#relationships-many-to-many)模式，因为这会导致数据可能以不一致的方式读取和写入，除非采取特殊步骤；[关联代理](extensions/associationproxy.html)通常用于提供更简洁的访问。有关此组合引入的注意事项的更详细背景，请参阅下一节[将关联对象与多对多访问模式组合使用](#association-pattern-w-m2m)。
- en: '### Combining Association Object with Many-to-Many Access Patterns'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将关联对象与多对多访问模式结合使用'
- en: As mentioned in the previous section, the association object pattern does not
    automatically integrate with usage of the many-to-many pattern against the same
    tables/columns at the same time. From this it follows that read operations may
    return conflicting data and write operations may also attempt to flush conflicting
    changes, causing either integrity errors or unexpected inserts or deletes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，关联对象模式不会自动与相同表/列的多对多模式集成。由此可知，读操作可能返回冲突数据，写操作也可能尝试刷新冲突更改，导致完整性错误或意外插入或删除。
- en: 'To illustrate, the example below configures a bidirectional many-to-many relationship
    between `Parent` and `Child` via `Parent.children` and `Child.parents`. At the
    same time, an association object relationship is also configured, between `Parent.child_associations
    -> Association.child` and `Child.parent_associations -> Association.parent`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，下面的示例配置了`Parent`和`Child`之间的双向多对多关系，通过`Parent.children`和`Child.parents`。同时，还配置了一个关联对象关系，即`Parent.child_associations
    -> Association.child`和`Child.parent_associations -> Association.parent`之间的关系：
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When using this ORM model to make changes, changes made to `Parent.children`
    will not be coordinated with changes made to `Parent.child_associations` or `Child.parent_associations`
    in Python; while all of these relationships will continue to function normally
    by themselves, changes on one will not show up in another until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is expired, which normally occurs automatically after
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此ORM模型进行更改时，对`Parent.children`进行的更改不会与在Python中对`Parent.child_associations`或`Child.parent_associations`进行的更改协调；虽然所有这些关系将继续正常运作，但一个上的更改不会显示在另一个上，直到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期，通常在[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")之后会自动发生。
- en: 'Additionally, if conflicting changes are made, such as adding a new `Association`
    object while also appending the same related `Child` to `Parent.children`, this
    will raise integrity errors when the unit of work flush process proceeds, as in
    the example below:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果发生冲突更改，例如同时添加新的`Association`对象并将相同相关的`Child`附加到`Parent.children`，则在工作单元刷新过程中会引发完整性错误，如下例所示：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Appending `Child` to `Parent.children` directly also implies the creation of
    rows in the `association` table without indicating any value for the `association.extra_data`
    column, which will receive `NULL` for its value.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将`Parent.children`附加`Child`也意味着在`association`表中创建行，而不指定`association.extra_data`列的任何值，该列将接收`NULL`作为其值。
- en: 'It’s fine to use a mapping like the above if you know what you’re doing; there
    may be good reason to use many-to-many relationships in the case where use of
    the “association object” pattern is infrequent, which is that it’s easier to load
    relationships along a single many-to-many relationship, which can also optimize
    slightly better how the “secondary” table is used in SQL statements, compared
    to how two separate relationships to an explicit association class is used. It’s
    at least a good idea to apply the [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") parameter to the “secondary” relationship to avoid
    the issue of conflicting changes occurring, as well as preventing `NULL` being
    written to the additional association columns, as below:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果知道自己在做什么，使用上述映射是可以的；在很少使用“关联对象”模式的情况下使用多对多关系可能有充分的理由，因为在单个多对多关系中加载关系更容易，这也可以稍微优化“secondary”表在SQL语句中的使用方式，与两个分开的关系到显式关联类的使用方式相比。至少最好将[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")参数应用于“secondary”关系，以避免发生冲突更改的问题，并防止将`NULL`写入附加的关联列，如下所示：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The above mapping will not write any changes to `Parent.children` or `Child.parents`
    to the database, preventing conflicting writes. However, reads of `Parent.children`
    or `Child.parents` will not necessarily match the data that’s read from `Parent.child_associations`
    or `Child.parent_associations`, if changes are being made to these collections
    within the same transaction or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as where the viewonly collections are being read. If
    use of the association object relationships is infrequent and is carefully organized
    against code that accesses the many-to-many collections to avoid stale reads (in
    extreme cases, making direct use of [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") to cause collections to be refreshed within the
    current transaction), the pattern may be feasible.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射不会将任何更改写入到数据库的`Parent.children`或`Child.parents`，从而防止冲突的写入。然而，如果在相同事务或[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中对这些集合进行更改，那么对`Parent.children`或`Child.parents`的读取将不一定匹配从`Parent.child_associations`或`Child.parent_associations`读取的数据。如果关联对象关系的使用不频繁，并且针对访问多对多集合的代码进行了精心组织以避免过时的读取（在极端情况下，直接使用[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")来使集合在当前事务中刷新），那么这种模式可能是可行的。
- en: A popular alternative to the above pattern is one where the direct many-to-many
    `Parent.children` and `Child.parents` relationships are replaced with an extension
    that will transparently proxy through the `Association` class, while keeping everything
    consistent from the ORM’s point of view. This extension is known as the [Association
    Proxy](extensions/associationproxy.html).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的一种流行替代方案是，直接的多对多`Parent.children`和`Child.parents`关系被一个扩展所取代，该扩展将通过`Association`类透明地代理，同时从ORM的角度保持一切一致。这个扩展被称为[关联代理](extensions/associationproxy.html)。
- en: See also
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Association Proxy](extensions/associationproxy.html) - allows direct “many
    to many” style access between parent and child for a three-class association object
    mapping.  ### Combining Association Object with Many-to-Many Access Patterns'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联代理](extensions/associationproxy.html) - 允许在三类关联对象映射之间直接进行“多对多”样式的父子访问。###
    将关联对象与多对多访问模式结合使用'
- en: As mentioned in the previous section, the association object pattern does not
    automatically integrate with usage of the many-to-many pattern against the same
    tables/columns at the same time. From this it follows that read operations may
    return conflicting data and write operations may also attempt to flush conflicting
    changes, causing either integrity errors or unexpected inserts or deletes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在上一节中，关联对象模式不会自动与同时针对相同表/列使用的多对多模式集成。由此可见，读取操作可能会返回冲突的数据，并且写入操作也可能尝试刷新冲突的更改，导致完整性错误或意外的插入或删除。
- en: 'To illustrate, the example below configures a bidirectional many-to-many relationship
    between `Parent` and `Child` via `Parent.children` and `Child.parents`. At the
    same time, an association object relationship is also configured, between `Parent.child_associations
    -> Association.child` and `Child.parent_associations -> Association.parent`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，下面的示例配置了`Parent`和`Child`之间的双向多对多关系，通过`Parent.children`和`Child.parents`。同时，还配置了一个关联对象关系，`Parent.child_associations
    -> Association.child`和`Child.parent_associations -> Association.parent`：
- en: '[PRE73]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When using this ORM model to make changes, changes made to `Parent.children`
    will not be coordinated with changes made to `Parent.child_associations` or `Child.parent_associations`
    in Python; while all of these relationships will continue to function normally
    by themselves, changes on one will not show up in another until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is expired, which normally occurs automatically after
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit").
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此ORM模型进行更改时，在Python中对`Parent.children`进行的更改不会与对`Parent.child_associations`或`Child.parent_associations`进行的更改协调；虽然所有这些关系都将继续正常运行，但在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期之前，一个的更改不会显示在另一个上，[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")通常会在自动发生后使之过期。
- en: 'Additionally, if conflicting changes are made, such as adding a new `Association`
    object while also appending the same related `Child` to `Parent.children`, this
    will raise integrity errors when the unit of work flush process proceeds, as in
    the example below:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果发生冲突的更改，例如同时添加一个新的`Association`对象，同时将相同的相关`Child`附加到`Parent.children`，则在工作单元刷新过程进行时，会引发完整性错误，如下例所示：
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Appending `Child` to `Parent.children` directly also implies the creation of
    rows in the `association` table without indicating any value for the `association.extra_data`
    column, which will receive `NULL` for its value.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将`Child`附加到`Parent.children`也意味着在`association`表中创建行，而不指定`association.extra_data`列的任何值，该列的值将为`NULL`。
- en: 'It’s fine to use a mapping like the above if you know what you’re doing; there
    may be good reason to use many-to-many relationships in the case where use of
    the “association object” pattern is infrequent, which is that it’s easier to load
    relationships along a single many-to-many relationship, which can also optimize
    slightly better how the “secondary” table is used in SQL statements, compared
    to how two separate relationships to an explicit association class is used. It’s
    at least a good idea to apply the [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") parameter to the “secondary” relationship to avoid
    the issue of conflicting changes occurring, as well as preventing `NULL` being
    written to the additional association columns, as below:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己在做什么，像上面的映射那样使用映射是可以的；在很少使用“关联对象”模式的情况下使用多对多关系可能是有充分理由的，这是因为沿着单一的多对多关系加载关系是更容易的，这也可以略微优化“辅助”表在SQL语句中的使用方式，与如何使用两个到显式关联类的分离关系相比。至少应该将[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")参数应用于“辅助”关系，以避免出现冲突更改的问题，并防止将`NULL`写入附加的关联列，如下所示：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The above mapping will not write any changes to `Parent.children` or `Child.parents`
    to the database, preventing conflicting writes. However, reads of `Parent.children`
    or `Child.parents` will not necessarily match the data that’s read from `Parent.child_associations`
    or `Child.parent_associations`, if changes are being made to these collections
    within the same transaction or [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as where the viewonly collections are being read. If
    use of the association object relationships is infrequent and is carefully organized
    against code that accesses the many-to-many collections to avoid stale reads (in
    extreme cases, making direct use of [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") to cause collections to be refreshed within the
    current transaction), the pattern may be feasible.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的映射不会将对`Parent.children`或`Child.parents`的任何更改写入数据库，从而防止冲突写入。但是，如果在相同的事务或[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中对这些集合进行更改的地方读取`Parent.children`或`Child.parents`将不一定与从`Parent.child_associations`或`Child.parent_associations`中读取的数据匹配。如果对关联对象关系的使用不频繁，并且针对访问多对多集合的代码进行了精心组织以避免过时读取（在极端情况下，直接使用[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")来导致集合在当前事务中被刷新），那么这种模式可能是可行的。
- en: A popular alternative to the above pattern is one where the direct many-to-many
    `Parent.children` and `Child.parents` relationships are replaced with an extension
    that will transparently proxy through the `Association` class, while keeping everything
    consistent from the ORM’s point of view. This extension is known as the [Association
    Proxy](extensions/associationproxy.html).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的替代模式是，直接的多对多`Parent.children`和`Child.parents`关系被一个扩展所取代，该扩展将通过`Association`类透明地代理，同时从ORM的角度保持一切一致。这个扩展被称为[关联代理](extensions/associationproxy.html)。
- en: See also
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Association Proxy](extensions/associationproxy.html) - allows direct “many
    to many” style access between parent and child for a three-class association object
    mapping.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[关联代理](extensions/associationproxy.html) - 允许在三类关联对象映射中直接实现“多对多”样式的父子访问。'
- en: '## Late-Evaluation of Relationship Arguments'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '## 关系参数的延迟评估'
- en: 'Most of the examples in the preceding sections illustrate mappings where the
    various [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs refer to their target classes using a string name, rather than the
    class itself, such as when using [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), a forward reference is generated that exists at runtime
    only as a string:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面部分的示例展示了映射，其中各种[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造使用字符串名称而不是类本身引用其目标类，例如在使用[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")时，会生成一个仅作为字符串存在的前向引用：
- en: '[PRE76]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Similarly, when using non-annotated forms such as non-annotated Declarative
    or Imperative mappings, a string name is also supported directly by the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在使用非注释形式，如非注释性的声明式或命令式映射时，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造也直接支持字符串名称：
- en: '[PRE77]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: These string names are resolved into classes in the mapper resolution stage,
    which is an internal process that occurs typically after all mappings have been
    defined and is normally triggered by the first usage of the mappings themselves.
    The [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object is the container where these names are stored and resolved to the mapped
    classes to which they refer.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串名称在映射器解析阶段被解析为类，这是一个内部过程，通常在定义所有映射之后发生，并且通常由映射本身的第一次使用触发。[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象是这些名称存储和解析为它们引用的映射类的容器。
- en: In addition to the main class argument for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), other arguments which depend upon the columns
    present on an as-yet undefined class may also be specified either as Python functions,
    or more commonly as strings. For most of these arguments except that of the main
    argument, string inputs are **evaluated as Python expressions using Python’s built-in
    eval() function**, as they are intended to receive complete SQL expressions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的主要类参数之外，还可以指定依赖于尚未定义类上存在的列的其他参数，这些参数可以是Python函数，或更常见的是字符串。对于这些参数中的大多数，除了主要参数之外，字符串输入都会**使用Python内置的eval()函数评估为Python表达式**，因为它们旨在接收完整的SQL表达式。
- en: Warning
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As the Python `eval()` function is used to interpret the late-evaluated string
    arguments passed to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mapper configuration construct, these arguments
    should **not** be repurposed such that they would receive untrusted user input;
    `eval()` is **not secure** against untrusted user input.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的`eval()`函数用于解释传递给[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射配置构造的延迟评估的字符串参数，这些参数不应该被重新用于接收不受信任的用户输入；`eval()`对不受信任的用户输入**不安全**。
- en: 'The full namespace available within this evaluation includes all classes mapped
    for this declarative base, as well as the contents of the `sqlalchemy` package,
    including expression functions like [`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc") and `sqlalchemy.sql.functions.func`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个评估中可用的完整命名空间包括为这个声明基类映射的所有类，以及`sqlalchemy`包的内容，包括表达式函数如[`desc()`](../core/sqlelement.html#sqlalchemy.sql.expression.desc
    "sqlalchemy.sql.expression.desc")和`sqlalchemy.sql.functions.func`：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For the case where more than one module contains a class of the same name,
    string class names can also be specified as module-qualified paths within any
    of these string expressions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个模块包含多个同名类的情况，字符串类名也可以在这些字符串表达式中作为模块限定路径指定：
- en: '[PRE79]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In an example like the above, the string passed to [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") can be disambiguated from a specific class argument by
    passing the class location string directly to [`relationship.argument`](relationship_api.html#sqlalchemy.orm.relationship.params.argument
    "sqlalchemy.orm.relationship") as well. Below illustrates a typing-only import
    for `Child`, combined with a runtime specifier for the target class that will
    search for the correct name within the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，传递给[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的字符串也可以通过直接将类位置字符串传递给[`relationship.argument`](relationship_api.html#sqlalchemy.orm.relationship.params.argument
    "sqlalchemy.orm.relationship")来消除特定类参数。下面说明了仅类型导入`Child`的示例，结合了将运行时说明符与将在[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")中搜索正确名称的目标类相结合：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The qualified path can be any partial path that removes ambiguity between the
    names. For example, to disambiguate between `myapp.model1.Child` and `myapp.model2.Child`,
    we can specify `model1.Child` or `model2.Child`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 合格路径可以是任何消除名称之间歧义的部分路径。例如，要消除`myapp.model1.Child`和`myapp.model2.Child`之间的歧义，我们可以指定`model1.Child`或`model2.Child`：
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    construct also accepts Python functions or lambdas as input for these arguments.
    A Python functional approach might look like the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构造还接受Python函数或lambda作为这些参数的输入。Python函数式方法可能如下所示：'
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The full list of parameters which accept Python functions/lambdas or strings
    that will be passed to `eval()` are:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的参数列表接受Python函数/lambda或将传递给`eval()`的字符串的参数包括：
- en: '[`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship")'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")'
- en: '[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")'
- en: '[`relationship._user_defined_foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params._user_defined_foreign_keys
    "sqlalchemy.orm.relationship")'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship._user_defined_foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params._user_defined_foreign_keys
    "sqlalchemy.orm.relationship")'
- en: Warning
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As stated previously, the above parameters to [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are **evaluated as Python code expressions using
    eval(). DO NOT PASS UNTRUSTED INPUT TO THESE ARGUMENTS.**
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")中的上述参数会**作为Python代码表达式使用eval()进行评估。不要将不受信任的输入传递给这些参数。**
- en: '### Adding Relationships to Mapped Classes After Declaration'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在声明后将关系添加到映射类'
- en: 'It should also be noted that in a similar way as described at [Appending additional
    columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns),
    any [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    construct can be added to a declarative base mapping at any time (noting that
    annotated forms are not supported in this context). If we wanted to implement
    this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    after the `Address` class were available, we could also apply it afterwards:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意，与[向现有的声明映射类添加附加列](declarative_tables.html#orm-declarative-table-adding-columns)中描述的类似方式，任何[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")构造都可以随时添加到声明基础映射中（注意在此上下文中不支持注释形式）。如果我们想要在`Address`类可用之后实现这个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，我们也可以随后应用它：
- en: '[PRE83]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As is the case for ORM mapped columns, there’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in this operation; therefore,
    the related class must be specified directly within the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, either as the class itself, the string
    name of the class, or a callable function that returns a reference to the target
    class.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与ORM映射列一样，[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注解类型无法参与此操作；因此，相关类必须直接在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造中指定，可以是类本身、类的字符串名称或返回目标类引用的可调用函数。
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As is the case for ORM mapped columns, assignment of mapped properties to an
    already mapped class will only function correctly if the “declarative base” class
    is used, meaning the user-defined subclass of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") or the dynamically generated class returned
    by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base "sqlalchemy.orm.declarative_base")
    or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与ORM映射列一样，对已映射类的映射属性的赋值仅在使用“声明基类”类时才能正确执行，这意味着用户定义的[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")子类或[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")返回的动态生成类或[`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")。这个“基”类包括一个Python元类，实现了一个特殊的`__setattr__()`方法来拦截这些操作。
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ### Using a late-evaluated form
    for the “secondary” argument of many-to-many'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '如果类使用像[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")这样的装饰器或像[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")这样的命令式函数进行映射，则无法在运行时将类映射属性分配给映射类。  ###
    使用多对多关系的“secondary”参数的延迟评估形式'
- en: Many-to-many relationships make use of the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, which ordinarily indicates a reference
    to a typically non-mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object or other Core selectable object. Late evaluation
    using a lambda callable is typical.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数，通常表示对通常不映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象或其他Core可选择对象的引用。通常使用lambda可调用进行延迟评估。
- en: 'For the example given at [Many To Many](#relationships-many-to-many), if we
    assumed that the `association_table` [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be defined at a point later on in the
    module than the mapped class itself, we may write the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using a lambda as:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[Many To Many](#relationships-many-to-many)中给出的示例，如果我们假设`association_table`
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象将在模块中稍后定义，则我们可以使用lambda编写[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As a shortcut for table names that are also **valid Python identifiers**, the
    [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter may also be passed as a string, where
    resolution works by evaluation of the string as a Python expression, with simple
    identifier names linked to same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that are present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection referenced by the current [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 作为也是**有效Python标识符**的表名的快捷方式，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数也可以作为字符串传递，其中解析通过将字符串作为Python表达式进行评估来完成，简单标识符名称链接到当前[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")引用的相同命名的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。
- en: 'In the example below, the expression `"association_table"` is evaluated as
    a variable named “association_table” that is resolved against the table names
    within the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，表达式`"association_table"`将作为名为“association_table”的变量进行评估，该变量将根据[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中的表名进行解析：
- en: '[PRE85]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When passed as a string, the name passed to [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") **must be a valid Python identifier** starting
    with a letter and containing only alphanumeric characters or underscores. Other
    characters such as dashes etc. will be interpreted as Python operators which will
    not resolve to the name given. Please consider using lambda expressions rather
    than strings for improved clarity.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，传递给[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")的名称**必须是有效的Python标识符**，以字母开头，只包含字母数字字符或下划线。其他字符，如破折号等，将被解释为Python运算符，而不会解析为给定的名称。请考虑使用lambda表达式而不是字符串以提高清晰度。
- en: Warning
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'When passed as a string, [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function, even though it’s typically the name of a table. **DO NOT PASS UNTRUSTED
    INPUT TO THIS STRING**.  ### Adding Relationships to Mapped Classes After Declaration'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数使用Python的`eval()`函数进行解释，即使它通常是一个表的名称。**不要将不受信任的输入传递给此字符串**。###在声明后向映射类添加关系
- en: 'It should also be noted that in a similar way as described at [Appending additional
    columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns),
    any [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    construct can be added to a declarative base mapping at any time (noting that
    annotated forms are not supported in this context). If we wanted to implement
    this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    after the `Address` class were available, we could also apply it afterwards:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意，在类似于[Appending additional columns to an existing Declarative mapped class](declarative_tables.html#orm-declarative-table-adding-columns)描述的方式中，任何[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")构造都可以随时添加到声明基本映射中（注意，此上下文中不支持注释形式）。如果我们希望在`Address`类可用后实现此[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，我们也可以随后应用它：
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As is the case for ORM mapped columns, there’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in this operation; therefore,
    the related class must be specified directly within the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, either as the class itself, the string
    name of the class, or a callable function that returns a reference to the target
    class.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与ORM映射列一样，[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")注解类型没有参与此操作的能力；因此，相关类必须直接在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造中指定，可以是类本身、类的字符串名称，或者返回目标类引用的可调用函数。
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As is the case for ORM mapped columns, assignment of mapped properties to an
    already mapped class will only function correctly if the “declarative base” class
    is used, meaning the user-defined subclass of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") or the dynamically generated class returned
    by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base "sqlalchemy.orm.declarative_base")
    or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 与ORM映射列一样，将映射属性分配给已经映射的类只有在使用“声明式基类”时才能正确运行，这意味着必须使用用户定义的[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")子类或者[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")返回的动态生成的类或者[`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")返回的动态生成的类。这个“基类”包含一个实现了特殊`__setattr__()`方法的Python元类，它拦截这些操作。
- en: Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用类似于[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")这样的装饰器或像[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")这样的命令式函数来映射类，则无法在运行时将映射属性分配给映射类。
- en: '### Using a late-evaluated form for the “secondary” argument of many-to-many'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用“secondary”参数的延迟评估形式来处理多对多关系'
- en: Many-to-many relationships make use of the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, which ordinarily indicates a reference
    to a typically non-mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object or other Core selectable object. Late evaluation
    using a lambda callable is typical.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数，通常表示对通常非映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象或其他核心可选择对象的引用。典型的延迟评估使用lambda可调用。
- en: 'For the example given at [Many To Many](#relationships-many-to-many), if we
    assumed that the `association_table` [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be defined at a point later on in the
    module than the mapped class itself, we may write the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using a lambda as:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[Many To Many](#relationships-many-to-many)中给出的例子，如果我们假设`association_table`
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象将在模块中的某个后续点被定义，那么我们可以使用lambda来编写[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，如下所示：
- en: '[PRE87]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As a shortcut for table names that are also **valid Python identifiers**, the
    [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter may also be passed as a string, where
    resolution works by evaluation of the string as a Python expression, with simple
    identifier names linked to same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that are present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection referenced by the current [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 作为表名的快捷方式，也可以将[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数传递为字符串，其中解析工作通过将字符串作为Python表达式进行评估，简单标识符名称链接到与当前[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")引用的相同[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中存在的同名[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。
- en: 'In the example below, the expression `"association_table"` is evaluated as
    a variable named “association_table” that is resolved against the table names
    within the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，表达式`"association_table"`被解析为一个名为“association_table”的变量，该变量根据[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中的表名解析：
- en: '[PRE88]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When passed as a string, the name passed to [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") **must be a valid Python identifier** starting
    with a letter and containing only alphanumeric characters or underscores. Other
    characters such as dashes etc. will be interpreted as Python operators which will
    not resolve to the name given. Please consider using lambda expressions rather
    than strings for improved clarity.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，传递给[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")的名称**必须是有效的Python标识符**，以字母开头，仅包含字母数字字符或下划线。其他字符，如破折号等，将被解释为Python操作符，而不会解析为给定的名称。请考虑使用lambda表达式而不是字符串，以提高清晰度。
- en: Warning
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a string, [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function, even though it’s typically the name of a table. **DO NOT PASS UNTRUSTED
    INPUT TO THIS STRING**.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为字符串传递时，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数将使用Python的`eval()`函数进行解释，即使它通常是一个表的名称。**不要将不受信任的输入传递给该字符串**。
