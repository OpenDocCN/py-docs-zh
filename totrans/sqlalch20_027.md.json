["```py\nfrom sqlalchemy import Table, Column, Integer, String, MetaData, join, ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import column_property\n\nmetadata_obj = MetaData()\n\n# define two Table objects\nuser_table = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String),\n)\n\naddress_table = Table(\n    \"address\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.id\")),\n    Column(\"email_address\", String),\n)\n\n# define a join between them.  This\n# takes place across the user.id and address.user_id\n# columns.\nuser_address_join = join(user_table, address_table)\n\nclass Base(DeclarativeBase):\n    metadata = metadata_obj\n\n# map to it\nclass AddressUser(Base):\n    __table__ = user_address_join\n\n    id = column_property(user_table.c.id, address_table.c.user_id)\n    address_id = address_table.c.id\n```", "```py\nstmt = select(AddressUser).group_by(*AddressUser.id.expressions)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(PtoQ, \"before_update\")\ndef receive_before_update(mapper, connection, target):\n    if target.some_required_attr_on_q is None:\n        connection.execute(q_table.insert(), {\"id\": target.id})\n```", "```py\nfrom sqlalchemy import select, func\n\nsubq = (\n    select(\n        func.count(orders.c.id).label(\"order_count\"),\n        func.max(orders.c.price).label(\"highest_order\"),\n        orders.c.customer_id,\n    )\n    .group_by(orders.c.customer_id)\n    .subquery()\n)\n\ncustomer_select = (\n    select(customers, subq)\n    .join_from(customers, subq, customers.c.id == subq.c.customer_id)\n    .subquery()\n)\n\nclass Customer(Base):\n    __table__ = customer_select\n```", "```py\nfrom sqlalchemy import Table, Column, Integer, String, MetaData, join, ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import column_property\n\nmetadata_obj = MetaData()\n\n# define two Table objects\nuser_table = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String),\n)\n\naddress_table = Table(\n    \"address\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.id\")),\n    Column(\"email_address\", String),\n)\n\n# define a join between them.  This\n# takes place across the user.id and address.user_id\n# columns.\nuser_address_join = join(user_table, address_table)\n\nclass Base(DeclarativeBase):\n    metadata = metadata_obj\n\n# map to it\nclass AddressUser(Base):\n    __table__ = user_address_join\n\n    id = column_property(user_table.c.id, address_table.c.user_id)\n    address_id = address_table.c.id\n```", "```py\nstmt = select(AddressUser).group_by(*AddressUser.id.expressions)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(PtoQ, \"before_update\")\ndef receive_before_update(mapper, connection, target):\n    if target.some_required_attr_on_q is None:\n        connection.execute(q_table.insert(), {\"id\": target.id})\n```", "```py\nfrom sqlalchemy import select, func\n\nsubq = (\n    select(\n        func.count(orders.c.id).label(\"order_count\"),\n        func.max(orders.c.price).label(\"highest_order\"),\n        orders.c.customer_id,\n    )\n    .group_by(orders.c.customer_id)\n    .subquery()\n)\n\ncustomer_select = (\n    select(customers, subq)\n    .join_from(customers, subq, customers.c.id == subq.c.customer_id)\n    .subquery()\n)\n\nclass Customer(Base):\n    __table__ = customer_select\n```"]