- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/performance.html](https://docs.sqlalchemy.org/en/20/faq/performance.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*   [Why is my application slow after upgrading to 1.4 and/or 2.x?](#why-is-my-application-slow-after-upgrading-to-1-4-and-or-2-x)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Step one - turn on SQL logging and confirm whether or not caching is working](#step-one-turn-on-sql-logging-and-confirm-whether-or-not-caching-is-working)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step two - identify what constructs are blocking caching from being enabled](#step-two-identify-what-constructs-are-blocking-caching-from-being-enabled)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step three - enable caching for the given objects and/or seek alternatives](#step-three-enable-caching-for-the-given-objects-and-or-seek-alternatives)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How can I profile a SQLAlchemy powered application?](#how-can-i-profile-a-sqlalchemy-powered-application)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Query Profiling](#query-profiling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Code Profiling](#code-profiling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Execution Slowness](#execution-slowness)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Result Fetching Slowness - Core](#result-fetching-slowness-core)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Result Fetching Slowness - ORM](#result-fetching-slowness-orm)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I’m inserting 400,000 rows with the ORM and it’s really slow!](#i-m-inserting-400-000-rows-with-the-orm-and-it-s-really-slow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Why is my application slow after upgrading to 1.4 and/or 2.x?'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](../core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: The caching system allows SQLAlchemy 1.4 and above to be more performant than
    SQLAlchemy 1.3 with regards to the time spent converting SQL constructs into strings
    repeatedly. However, this only works if caching is enabled for the dialect and
    SQL constructs in use; if not, string compilation is usually similar to that of
    SQLAlchemy 1.3, with a slight decrease in speed in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: There is one case however where if SQLAlchemy’s new caching system has been
    disabled (for reasons below), performance for the ORM may be in fact significantly
    poorer than that of 1.3 or other prior releases which is due to the lack of caching
    within ORM lazy loaders and object refresh queries, which in the 1.3 and earlier
    releases used the now-legacy `BakedQuery` system. If an application is seeing
    significant (30% or higher) degradations in performance (measured in time for
    operations to complete) when switching to 1.4, this is the likely cause of the
    issue, with steps to mitigate below.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching) - overview
    of the caching system'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object will not produce a cache key, Performance Implications](../errors.html#caching-caveats)
    - additional information regarding the warnings generated for elements that don’t
    enable caching.'
  prefs: []
  type: TYPE_NORMAL
- en: Step one - turn on SQL logging and confirm whether or not caching is working
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we want to use the technique described at [engine logging](../core/connections.html#sql-caching-logging),
    looking for statements with the `[no key]` indicator or even `[dialect does not
    support caching]`. The indicators we would see for SQL statements that are successfully
    participating in the caching system would be indicating `[generated in Xs]` when
    statements are invoked for the first time and then `[cached since Xs ago]` for
    the vast majority of statements subsequent. If `[no key]` is prevalent in particular
    for SELECT statements, or if caching is disabled entirely due to `[dialect does
    not support caching]`, this can be the cause of significant performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](../core/connections.html#sql-caching-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Step two - identify what constructs are blocking caching from being enabled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming statements are not being cached, there should be warnings emitted early
    in the application’s log (SQLAlchemy 1.4.28 and above only) indicating dialects,
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, and SQL constructs that are not participating in caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For user defined datatypes such as those which extend [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party SQL elements, such as those constructed using the
    techniques described at [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    these warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party dialects which make use of the [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") class hierarchy, the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Step three - enable caching for the given objects and/or seek alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steps to mitigate the lack of caching include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review and set [`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") to `True` for all custom types which
    extend from [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), as well as subclasses of these such as [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"). Set this **only** if the custom type does not
    include any additional state attributes which affect how it renders SQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the types in use are from a third-party library, consult with the maintainers
    of that library so that it may be adjusted and released.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") - background on requirements to enable
    caching for custom datatypes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure third party dialects set [`Dialect.supports_statement_cache`](../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") to `True`. What this indicates
    is that the maintainers of a third party dialect have made sure their dialect
    works with SQLAlchemy 1.4 or greater, and that their dialect doesn’t include any
    compilation features which may get in the way of caching. As there are some common
    compilation patterns which can in fact interfere with caching, it’s important
    that dialect maintainers check and test this carefully, adjusting for any of the
    legacy patterns which won’t work with caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Caching for Third Party Dialects](../core/connections.html#engine-thirdparty-caching)
    - background and examples for third-party dialects to participate in SQL statement
    caching.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Custom SQL classes, including all DQL / DML constructs one might create using
    the [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    as well as ad-hoc subclasses of objects such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). The [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute may be set to
    `True` for trivial subclasses, which do not contain any subclass-specific state
    information which affects the SQL compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - guidelines for applying the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching) - caching system
    overview'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object will not produce a cache key, Performance Implications](../errors.html#caching-caveats)
    - background on warnings emitted when caching is not enabled for specific constructs
    and/or dialects.  ## How can I profile a SQLAlchemy powered application?'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for performance issues typically involves two strategies. One is query
    profiling, and the other is code profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Query Profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes just plain SQL logging (enabled via python’s logging module or via
    the `echo=True` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")) can give an idea how long things are taking. For
    example, if you log something right after a SQL operation, you’d see something
    like this in your log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: if you logged `myapp.somemessage` right after the operation, you know it took
    334ms to complete the SQL part of things.
  prefs: []
  type: TYPE_NORMAL
- en: Logging SQL will also illustrate if dozens/hundreds of queries are being issued
    which could be better organized into much fewer queries. When using the SQLAlchemy
    ORM, the “eager loading” feature is provided to partially ([`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")) or fully ([`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")) automate this activity, but without the ORM “eager
    loading” typically means to use joins so that results across multiple tables can
    be loaded in one result set instead of multiplying numbers of queries as more
    depth is added (i.e. `r + r*r2 + r*r2*r3` …)
  prefs: []
  type: TYPE_NORMAL
- en: 'For more long-term profiling of queries, or to implement an application-side
    “slow query” monitor, events can be used to intercept cursor executions, using
    a recipe like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use the [`ConnectionEvents.before_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") and [`ConnectionEvents.after_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute
    "sqlalchemy.events.ConnectionEvents.after_cursor_execute") events to establish
    an interception point around when a statement is executed. We attach a timer onto
    the connection using the `info` dictionary; we use a stack here for the occasional
    case where the cursor execute events may be nested.
  prefs: []
  type: TYPE_NORMAL
- en: '### Code Profiling'
  prefs: []
  type: TYPE_NORMAL
- en: If logging reveals that individual queries are taking too long, you’d need a
    breakdown of how much time was spent within the database processing the query,
    sending results over the network, being handled by the [DBAPI](../glossary.html#term-DBAPI),
    and finally being received by SQLAlchemy’s result set and/or ORM layer. Each of
    these stages can present their own individual bottlenecks, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that you need to use the [Python Profiling Module](https://docs.python.org/2/library/profile.html).
    Below is a simple recipe which works profiling into a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To profile a section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of profiling can be used to give an idea where time is being spent.
    A section of profiling output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Above, we can see that the `instances()` SQLAlchemy function was called 222
    times (recursively, and 21 times from the outside), taking a total of .011 seconds
    for all calls combined.
  prefs: []
  type: TYPE_NORMAL
- en: Execution Slowness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specifics of these calls can tell us where the time is being spent. If
    for example, you see time being spent within `cursor.execute()`, e.g. against
    the DBAPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: this would indicate that the database is taking a long time to start returning
    results, and it means your query should be optimized, either by adding indexes
    or restructuring the query and/or underlying schema. For that task, analysis of
    the query plan is warranted, using a system such as EXPLAIN, SHOW PLAN, etc. as
    is provided by the database backend.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If on the other hand you see many thousands of calls related to fetching rows,
    or very long calls to `fetchall()`, it may mean your query is returning more rows
    than expected, or that the fetching of rows itself is slow. The ORM itself typically
    uses `fetchall()` to fetch rows (or `fetchmany()` if the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") option is used).
  prefs: []
  type: TYPE_NORMAL
- en: 'An inordinately large number of rows would be indicated by a very slow call
    to `fetchall()` at the DBAPI level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An unexpectedly large number of rows, even if the ultimate result doesn’t seem
    to have many rows, can be the result of a cartesian product - when multiple sets
    of rows are combined together without appropriately joining the tables together.
    It’s often easy to produce this behavior with SQLAlchemy Core or ORM query if
    the wrong [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are used in a complex query, pulling in additional FROM clauses that are
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a fast call to `fetchall()` at the DBAPI level, but then
    slowness when SQLAlchemy’s [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") is asked to do a `fetchall()`, may indicate
    slowness in processing of datatypes, such as unicode conversions and similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, a backend might be doing type-level processing that isn’t needed.
    More specifically, seeing calls within the type API that are slow are better indicators
    - below is what it looks like when we use a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'the profiling output of this intentionally slow operation can be seen like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: that is, we see many expensive calls within the `type_api` system, and the actual
    time consuming thing is the `time.sleep()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to check the [Dialect documentation](../dialects/index.html) for notes
    on known performance tuning suggestions at this level, especially for databases
    like Oracle. There may be systems related to ensuring numeric accuracy or string
    processing that may not be needed in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: There also may be even more low-level points at which row-fetching performance
    is suffering; for example, if time spent seems to focus on a call like `socket.receive()`,
    that could indicate that everything is fast except for the actual network connection,
    and too much time is spent with data moving over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - ORM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To detect slowness in ORM fetching of rows (which is the most common area of
    performance concern), calls like `populate_state()` and `_instance()` will illustrate
    individual ORM object populations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The ORM’s slowness in turning rows into ORM-mapped objects is a product of
    the complexity of this operation combined with the overhead of cPython. Common
    strategies to mitigate this include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fetch individual columns instead of full entities, that is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'instead of:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    objects to organize column-based results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use result caching - see [Dogpile Caching](../orm/examples.html#examples-caching)
    for an in-depth example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a faster interpreter like that of PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of a profile can be a little daunting but after some practice they
    are very easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance) - a suite of performance
    demonstrations with bundled profiling capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: I’m inserting 400,000 rows with the ORM and it’s really slow!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nature of ORM inserts has changed, as most included drivers use RETURNING
    with [insertmanyvalues](../core/connections.html#engine-insertmanyvalues) support
    as of SQLAlchemy 2.0\. See the section [Optimized ORM bulk insert now implemented
    for all backends other than MySQL](../changelog/whatsnew_20.html#change-6047)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, SQLAlchemy built-in drivers other than that of MySQL should now offer
    very fast ORM bulk insert performance.
  prefs: []
  type: TYPE_NORMAL
- en: Third party drivers can opt in to the new bulk infrastructure as well with some
    small code changes assuming their backends support the necessary syntaxes. SQLAlchemy
    developers would encourage users of third party dialects to post issues with these
    drivers, so that they may contact SQLAlchemy developers for assistance.
  prefs: []
  type: TYPE_NORMAL
- en: '## Why is my application slow after upgrading to 1.4 and/or 2.x?'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](../core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: The caching system allows SQLAlchemy 1.4 and above to be more performant than
    SQLAlchemy 1.3 with regards to the time spent converting SQL constructs into strings
    repeatedly. However, this only works if caching is enabled for the dialect and
    SQL constructs in use; if not, string compilation is usually similar to that of
    SQLAlchemy 1.3, with a slight decrease in speed in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: There is one case however where if SQLAlchemy’s new caching system has been
    disabled (for reasons below), performance for the ORM may be in fact significantly
    poorer than that of 1.3 or other prior releases which is due to the lack of caching
    within ORM lazy loaders and object refresh queries, which in the 1.3 and earlier
    releases used the now-legacy `BakedQuery` system. If an application is seeing
    significant (30% or higher) degradations in performance (measured in time for
    operations to complete) when switching to 1.4, this is the likely cause of the
    issue, with steps to mitigate below.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching) - overview
    of the caching system'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object will not produce a cache key, Performance Implications](../errors.html#caching-caveats)
    - additional information regarding the warnings generated for elements that don’t
    enable caching.'
  prefs: []
  type: TYPE_NORMAL
- en: Step one - turn on SQL logging and confirm whether or not caching is working
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we want to use the technique described at [engine logging](../core/connections.html#sql-caching-logging),
    looking for statements with the `[no key]` indicator or even `[dialect does not
    support caching]`. The indicators we would see for SQL statements that are successfully
    participating in the caching system would be indicating `[generated in Xs]` when
    statements are invoked for the first time and then `[cached since Xs ago]` for
    the vast majority of statements subsequent. If `[no key]` is prevalent in particular
    for SELECT statements, or if caching is disabled entirely due to `[dialect does
    not support caching]`, this can be the cause of significant performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](../core/connections.html#sql-caching-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Step two - identify what constructs are blocking caching from being enabled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming statements are not being cached, there should be warnings emitted early
    in the application’s log (SQLAlchemy 1.4.28 and above only) indicating dialects,
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, and SQL constructs that are not participating in caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For user defined datatypes such as those which extend [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party SQL elements, such as those constructed using the
    techniques described at [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    these warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party dialects which make use of the [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") class hierarchy, the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Step three - enable caching for the given objects and/or seek alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steps to mitigate the lack of caching include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review and set [`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") to `True` for all custom types which
    extend from [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), as well as subclasses of these such as [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"). Set this **only** if the custom type does not
    include any additional state attributes which affect how it renders SQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the types in use are from a third-party library, consult with the maintainers
    of that library so that it may be adjusted and released.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") - background on requirements to enable
    caching for custom datatypes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure third party dialects set [`Dialect.supports_statement_cache`](../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") to `True`. What this indicates
    is that the maintainers of a third party dialect have made sure their dialect
    works with SQLAlchemy 1.4 or greater, and that their dialect doesn’t include any
    compilation features which may get in the way of caching. As there are some common
    compilation patterns which can in fact interfere with caching, it’s important
    that dialect maintainers check and test this carefully, adjusting for any of the
    legacy patterns which won’t work with caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Caching for Third Party Dialects](../core/connections.html#engine-thirdparty-caching)
    - background and examples for third-party dialects to participate in SQL statement
    caching.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Custom SQL classes, including all DQL / DML constructs one might create using
    the [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    as well as ad-hoc subclasses of objects such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). The [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute may be set to
    `True` for trivial subclasses, which do not contain any subclass-specific state
    information which affects the SQL compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - guidelines for applying the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching) - caching system
    overview'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object will not produce a cache key, Performance Implications](../errors.html#caching-caveats)
    - background on warnings emitted when caching is not enabled for specific constructs
    and/or dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: Step one - turn on SQL logging and confirm whether or not caching is working
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we want to use the technique described at [engine logging](../core/connections.html#sql-caching-logging),
    looking for statements with the `[no key]` indicator or even `[dialect does not
    support caching]`. The indicators we would see for SQL statements that are successfully
    participating in the caching system would be indicating `[generated in Xs]` when
    statements are invoked for the first time and then `[cached since Xs ago]` for
    the vast majority of statements subsequent. If `[no key]` is prevalent in particular
    for SELECT statements, or if caching is disabled entirely due to `[dialect does
    not support caching]`, this can be the cause of significant performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](../core/connections.html#sql-caching-logging)'
  prefs: []
  type: TYPE_NORMAL
- en: Step two - identify what constructs are blocking caching from being enabled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming statements are not being cached, there should be warnings emitted early
    in the application’s log (SQLAlchemy 1.4.28 and above only) indicating dialects,
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, and SQL constructs that are not participating in caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For user defined datatypes such as those which extend [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party SQL elements, such as those constructed using the
    techniques described at [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    these warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For custom and third party dialects which make use of the [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") class hierarchy, the warnings will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Step three - enable caching for the given objects and/or seek alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Steps to mitigate the lack of caching include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review and set [`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") to `True` for all custom types which
    extend from [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType"), as well as subclasses of these such as [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"). Set this **only** if the custom type does not
    include any additional state attributes which affect how it renders SQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the types in use are from a third-party library, consult with the maintainers
    of that library so that it may be adjusted and released.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ExternalType.cache_ok`](../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") - background on requirements to enable
    caching for custom datatypes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure third party dialects set [`Dialect.supports_statement_cache`](../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") to `True`. What this indicates
    is that the maintainers of a third party dialect have made sure their dialect
    works with SQLAlchemy 1.4 or greater, and that their dialect doesn’t include any
    compilation features which may get in the way of caching. As there are some common
    compilation patterns which can in fact interfere with caching, it’s important
    that dialect maintainers check and test this carefully, adjusting for any of the
    legacy patterns which won’t work with caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Caching for Third Party Dialects](../core/connections.html#engine-thirdparty-caching)
    - background and examples for third-party dialects to participate in SQL statement
    caching.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Custom SQL classes, including all DQL / DML constructs one might create using
    the [Custom SQL Constructs and Compilation Extension](../core/compiler.html),
    as well as ad-hoc subclasses of objects such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). The [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute may be set to
    `True` for trivial subclasses, which do not contain any subclass-specific state
    information which affects the SQL compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - guidelines for applying the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching) - caching system
    overview'
  prefs: []
  type: TYPE_NORMAL
- en: '[Object will not produce a cache key, Performance Implications](../errors.html#caching-caveats)
    - background on warnings emitted when caching is not enabled for specific constructs
    and/or dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: '## How can I profile a SQLAlchemy powered application?'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for performance issues typically involves two strategies. One is query
    profiling, and the other is code profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Query Profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes just plain SQL logging (enabled via python’s logging module or via
    the `echo=True` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")) can give an idea how long things are taking. For
    example, if you log something right after a SQL operation, you’d see something
    like this in your log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: if you logged `myapp.somemessage` right after the operation, you know it took
    334ms to complete the SQL part of things.
  prefs: []
  type: TYPE_NORMAL
- en: Logging SQL will also illustrate if dozens/hundreds of queries are being issued
    which could be better organized into much fewer queries. When using the SQLAlchemy
    ORM, the “eager loading” feature is provided to partially ([`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")) or fully ([`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")) automate this activity, but without the ORM “eager
    loading” typically means to use joins so that results across multiple tables can
    be loaded in one result set instead of multiplying numbers of queries as more
    depth is added (i.e. `r + r*r2 + r*r2*r3` …)
  prefs: []
  type: TYPE_NORMAL
- en: 'For more long-term profiling of queries, or to implement an application-side
    “slow query” monitor, events can be used to intercept cursor executions, using
    a recipe like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use the [`ConnectionEvents.before_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") and [`ConnectionEvents.after_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute
    "sqlalchemy.events.ConnectionEvents.after_cursor_execute") events to establish
    an interception point around when a statement is executed. We attach a timer onto
    the connection using the `info` dictionary; we use a stack here for the occasional
    case where the cursor execute events may be nested.
  prefs: []
  type: TYPE_NORMAL
- en: '### Code Profiling'
  prefs: []
  type: TYPE_NORMAL
- en: If logging reveals that individual queries are taking too long, you’d need a
    breakdown of how much time was spent within the database processing the query,
    sending results over the network, being handled by the [DBAPI](../glossary.html#term-DBAPI),
    and finally being received by SQLAlchemy’s result set and/or ORM layer. Each of
    these stages can present their own individual bottlenecks, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that you need to use the [Python Profiling Module](https://docs.python.org/2/library/profile.html).
    Below is a simple recipe which works profiling into a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To profile a section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of profiling can be used to give an idea where time is being spent.
    A section of profiling output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Above, we can see that the `instances()` SQLAlchemy function was called 222
    times (recursively, and 21 times from the outside), taking a total of .011 seconds
    for all calls combined.
  prefs: []
  type: TYPE_NORMAL
- en: Execution Slowness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specifics of these calls can tell us where the time is being spent. If
    for example, you see time being spent within `cursor.execute()`, e.g. against
    the DBAPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: this would indicate that the database is taking a long time to start returning
    results, and it means your query should be optimized, either by adding indexes
    or restructuring the query and/or underlying schema. For that task, analysis of
    the query plan is warranted, using a system such as EXPLAIN, SHOW PLAN, etc. as
    is provided by the database backend.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If on the other hand you see many thousands of calls related to fetching rows,
    or very long calls to `fetchall()`, it may mean your query is returning more rows
    than expected, or that the fetching of rows itself is slow. The ORM itself typically
    uses `fetchall()` to fetch rows (or `fetchmany()` if the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") option is used).
  prefs: []
  type: TYPE_NORMAL
- en: 'An inordinately large number of rows would be indicated by a very slow call
    to `fetchall()` at the DBAPI level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: An unexpectedly large number of rows, even if the ultimate result doesn’t seem
    to have many rows, can be the result of a cartesian product - when multiple sets
    of rows are combined together without appropriately joining the tables together.
    It’s often easy to produce this behavior with SQLAlchemy Core or ORM query if
    the wrong [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are used in a complex query, pulling in additional FROM clauses that are
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a fast call to `fetchall()` at the DBAPI level, but then
    slowness when SQLAlchemy’s [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") is asked to do a `fetchall()`, may indicate
    slowness in processing of datatypes, such as unicode conversions and similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, a backend might be doing type-level processing that isn’t needed.
    More specifically, seeing calls within the type API that are slow are better indicators
    - below is what it looks like when we use a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'the profiling output of this intentionally slow operation can be seen like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: that is, we see many expensive calls within the `type_api` system, and the actual
    time consuming thing is the `time.sleep()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to check the [Dialect documentation](../dialects/index.html) for notes
    on known performance tuning suggestions at this level, especially for databases
    like Oracle. There may be systems related to ensuring numeric accuracy or string
    processing that may not be needed in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: There also may be even more low-level points at which row-fetching performance
    is suffering; for example, if time spent seems to focus on a call like `socket.receive()`,
    that could indicate that everything is fast except for the actual network connection,
    and too much time is spent with data moving over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - ORM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To detect slowness in ORM fetching of rows (which is the most common area of
    performance concern), calls like `populate_state()` and `_instance()` will illustrate
    individual ORM object populations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The ORM’s slowness in turning rows into ORM-mapped objects is a product of
    the complexity of this operation combined with the overhead of cPython. Common
    strategies to mitigate this include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fetch individual columns instead of full entities, that is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'instead of:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    objects to organize column-based results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use result caching - see [Dogpile Caching](../orm/examples.html#examples-caching)
    for an in-depth example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a faster interpreter like that of PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of a profile can be a little daunting but after some practice they
    are very easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance) - a suite of performance
    demonstrations with bundled profiling capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Query Profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes just plain SQL logging (enabled via python’s logging module or via
    the `echo=True` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")) can give an idea how long things are taking. For
    example, if you log something right after a SQL operation, you’d see something
    like this in your log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: if you logged `myapp.somemessage` right after the operation, you know it took
    334ms to complete the SQL part of things.
  prefs: []
  type: TYPE_NORMAL
- en: Logging SQL will also illustrate if dozens/hundreds of queries are being issued
    which could be better organized into much fewer queries. When using the SQLAlchemy
    ORM, the “eager loading” feature is provided to partially ([`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")) or fully ([`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")) automate this activity, but without the ORM “eager
    loading” typically means to use joins so that results across multiple tables can
    be loaded in one result set instead of multiplying numbers of queries as more
    depth is added (i.e. `r + r*r2 + r*r2*r3` …)
  prefs: []
  type: TYPE_NORMAL
- en: 'For more long-term profiling of queries, or to implement an application-side
    “slow query” monitor, events can be used to intercept cursor executions, using
    a recipe like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use the [`ConnectionEvents.before_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute
    "sqlalchemy.events.ConnectionEvents.before_cursor_execute") and [`ConnectionEvents.after_cursor_execute()`](../core/events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute
    "sqlalchemy.events.ConnectionEvents.after_cursor_execute") events to establish
    an interception point around when a statement is executed. We attach a timer onto
    the connection using the `info` dictionary; we use a stack here for the occasional
    case where the cursor execute events may be nested.
  prefs: []
  type: TYPE_NORMAL
- en: '### Code Profiling'
  prefs: []
  type: TYPE_NORMAL
- en: If logging reveals that individual queries are taking too long, you’d need a
    breakdown of how much time was spent within the database processing the query,
    sending results over the network, being handled by the [DBAPI](../glossary.html#term-DBAPI),
    and finally being received by SQLAlchemy’s result set and/or ORM layer. Each of
    these stages can present their own individual bottlenecks, depending on specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that you need to use the [Python Profiling Module](https://docs.python.org/2/library/profile.html).
    Below is a simple recipe which works profiling into a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To profile a section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of profiling can be used to give an idea where time is being spent.
    A section of profiling output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Above, we can see that the `instances()` SQLAlchemy function was called 222
    times (recursively, and 21 times from the outside), taking a total of .011 seconds
    for all calls combined.
  prefs: []
  type: TYPE_NORMAL
- en: Execution Slowness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specifics of these calls can tell us where the time is being spent. If
    for example, you see time being spent within `cursor.execute()`, e.g. against
    the DBAPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: this would indicate that the database is taking a long time to start returning
    results, and it means your query should be optimized, either by adding indexes
    or restructuring the query and/or underlying schema. For that task, analysis of
    the query plan is warranted, using a system such as EXPLAIN, SHOW PLAN, etc. as
    is provided by the database backend.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If on the other hand you see many thousands of calls related to fetching rows,
    or very long calls to `fetchall()`, it may mean your query is returning more rows
    than expected, or that the fetching of rows itself is slow. The ORM itself typically
    uses `fetchall()` to fetch rows (or `fetchmany()` if the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") option is used).
  prefs: []
  type: TYPE_NORMAL
- en: 'An inordinately large number of rows would be indicated by a very slow call
    to `fetchall()` at the DBAPI level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: An unexpectedly large number of rows, even if the ultimate result doesn’t seem
    to have many rows, can be the result of a cartesian product - when multiple sets
    of rows are combined together without appropriately joining the tables together.
    It’s often easy to produce this behavior with SQLAlchemy Core or ORM query if
    the wrong [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are used in a complex query, pulling in additional FROM clauses that are
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a fast call to `fetchall()` at the DBAPI level, but then
    slowness when SQLAlchemy’s [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") is asked to do a `fetchall()`, may indicate
    slowness in processing of datatypes, such as unicode conversions and similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, a backend might be doing type-level processing that isn’t needed.
    More specifically, seeing calls within the type API that are slow are better indicators
    - below is what it looks like when we use a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'the profiling output of this intentionally slow operation can be seen like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: that is, we see many expensive calls within the `type_api` system, and the actual
    time consuming thing is the `time.sleep()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to check the [Dialect documentation](../dialects/index.html) for notes
    on known performance tuning suggestions at this level, especially for databases
    like Oracle. There may be systems related to ensuring numeric accuracy or string
    processing that may not be needed in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: There also may be even more low-level points at which row-fetching performance
    is suffering; for example, if time spent seems to focus on a call like `socket.receive()`,
    that could indicate that everything is fast except for the actual network connection,
    and too much time is spent with data moving over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Result Fetching Slowness - ORM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To detect slowness in ORM fetching of rows (which is the most common area of
    performance concern), calls like `populate_state()` and `_instance()` will illustrate
    individual ORM object populations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The ORM’s slowness in turning rows into ORM-mapped objects is a product of
    the complexity of this operation combined with the overhead of cPython. Common
    strategies to mitigate this include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fetch individual columns instead of full entities, that is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'instead of:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    objects to organize column-based results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use result caching - see [Dogpile Caching](../orm/examples.html#examples-caching)
    for an in-depth example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a faster interpreter like that of PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of a profile can be a little daunting but after some practice they
    are very easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance) - a suite of performance
    demonstrations with bundled profiling capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: I’m inserting 400,000 rows with the ORM and it’s really slow!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nature of ORM inserts has changed, as most included drivers use RETURNING
    with [insertmanyvalues](../core/connections.html#engine-insertmanyvalues) support
    as of SQLAlchemy 2.0\. See the section [Optimized ORM bulk insert now implemented
    for all backends other than MySQL](../changelog/whatsnew_20.html#change-6047)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, SQLAlchemy built-in drivers other than that of MySQL should now offer
    very fast ORM bulk insert performance.
  prefs: []
  type: TYPE_NORMAL
- en: Third party drivers can opt in to the new bulk infrastructure as well with some
    small code changes assuming their backends support the necessary syntaxes. SQLAlchemy
    developers would encourage users of third party dialects to post issues with these
    drivers, so that they may contact SQLAlchemy developers for assistance.
  prefs: []
  type: TYPE_NORMAL
