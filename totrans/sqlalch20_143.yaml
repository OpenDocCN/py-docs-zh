- en: What’s New in SQLAlchemy 1.2?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_12.html](https://docs.sqlalchemy.org/en/20/changelog/migration_12.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 1.1 and SQLAlchemy
    version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.2, and also documents
    changes which affect users migrating their applications from the 1.1 series of
    SQLAlchemy to 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Platform Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Targeting Python 2.7 and Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### “Baked” loading now the default for lazy loads'
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  prefs: []
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  prefs: []
  type: TYPE_NORMAL
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### New “selectin” eager
    loading, loads all collections at once using IN'
  prefs: []
  type: TYPE_NORMAL
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SELECT statement includes these advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” polymorphic
    loading, loads subclasses using separate IN queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### ORM attributes that
    can receive ad-hoc SQL expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM Support of multiple-table
    deletes'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### Support for bulk updates
    of hybrids, composites'
  prefs: []
  type: TYPE_NORMAL
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  prefs: []
  type: TYPE_NORMAL
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an UPDATE can be rendered using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)  ###
    Hybrid attributes support reuse among subclasses, redefinition of @getter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### New bulk_replace
    event'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### New “modified” event
    handler for sqlalchemy.ext.mutable'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### Added “for update”
    arguments to Session.refresh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### In-place mutation
    operators work for MutableSet, MutableList'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    any(), has(), contains() work with chained association proxies'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### Identity key enhancements
    to support sharding'
  prefs: []
  type: TYPE_NORMAL
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Boolean datatype now enforces strict True/False/None values'
  prefs: []
  type: TYPE_NORMAL
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### Pessimistic disconnection
    detection added to the connection pool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified'
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### Late-expanded IN
    parameter sets allow IN expressions with cached statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The feature should be regarded as **experimental** within the 1.2 series.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### Flattened operator
    precedence for comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### Support for SQL Comments
    on Table, Column, includes DDL, reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  prefs: []
  type: TYPE_NORMAL
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### Multiple-table criteria
    support for DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### New “autoescape” option
    for startswith(), endswith()'
  prefs: []
  type: TYPE_NORMAL
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  prefs: []
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an expression that has backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### Stronger typing added
    to “float” datatypes'
  prefs: []
  type: TYPE_NORMAL
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for GROUPING SETS, CUBE, ROLLUP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  prefs: []
  type: TYPE_NORMAL
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### The after_rollback() Session event now emits before the expiration of objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### Fixed issue involving
    single-table inheritance with `select_from()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Would generate SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### Previous collection
    is no longer mutated upon replacement'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### A @validates method
    receives all values on bulk-collection set before comparison'
  prefs: []
  type: TYPE_NORMAL
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, if we began with a collection as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, replaced the collection with one that overlaps the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New bulk_replace event](#change-3896-event)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### Use flag_dirty()
    to mark an object as “dirty” without any attribute changing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### “scope” keyword removed
    from scoped_session'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### Refinements to post_update
    in conjunction with onupdate'
  prefs: []
  type: TYPE_NORMAL
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update integrates
    with ORM versioning'
  prefs: []
  type: TYPE_NORMAL
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  prefs: []
  type: TYPE_NORMAL
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### The typing behavior of custom operators has been made consistent'
  prefs: []
  type: TYPE_NORMAL
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]  ### Percent signs in literal_column() now conditionally escaped'
  prefs: []
  type: TYPE_NORMAL
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### The column-level
    COLLATE keyword now quotes the collation name'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for Batch Mode / Fast Execution Helpers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### Support for fields
    specification in INTERVAL, including full reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for INSERT..ON DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Major Refactor to cx_Oracle Dialect, Typing System'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.  ### Oracle Unique, Check constraints now reflected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle foreign key
    constraint names are now “name normalized”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the foreign keys result would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Where the above could create problems particularly with Alembic autogenerate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### SQL Server schema names with embedded dots supported'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  prefs: []
  type: TYPE_NORMAL
- en: AUTOCOMMIT isolation level support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.2, and also documents
    changes which affect users migrating their applications from the 1.1 series of
    SQLAlchemy to 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Platform Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Targeting Python 2.7 and Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting Python 2.7 and Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 1.2 now moves the minimum Python version to 2.7, no longer supporting
    2.6\. New language features are expected to be merged into the 1.2 series that
    were not supported in Python 2.6\. For Python 3 support, SQLAlchemy is currently
    tested on versions 3.5 and 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### “Baked” loading now the default for lazy loads'
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  prefs: []
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  prefs: []
  type: TYPE_NORMAL
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)  ### New “selectin” eager
    loading, loads all collections at once using IN'
  prefs: []
  type: TYPE_NORMAL
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SELECT statement includes these advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)  ### “selectin” polymorphic
    loading, loads subclasses using separate IN queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)  ### ORM attributes that
    can receive ad-hoc SQL expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)  ### ORM Support of multiple-table
    deletes'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### Support for bulk updates
    of hybrids, composites'
  prefs: []
  type: TYPE_NORMAL
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  prefs: []
  type: TYPE_NORMAL
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an UPDATE can be rendered using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)  ###
    Hybrid attributes support reuse among subclasses, redefinition of @getter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)  ### New bulk_replace
    event'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### New “modified” event
    handler for sqlalchemy.ext.mutable'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)  ### Added “for update”
    arguments to Session.refresh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)  ### In-place mutation
    operators work for MutableSet, MutableList'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)  ### AssociationProxy
    any(), has(), contains() work with chained association proxies'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)  ### Identity key enhancements
    to support sharding'
  prefs: []
  type: TYPE_NORMAL
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)  ### “Baked” loading now
    the default for lazy loads'
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.ext.baked`](../orm/extensions/baked.html#module-sqlalchemy.ext.baked
    "sqlalchemy.ext.baked") extension, first introduced in the 1.0 series, allows
    for the construction of a so-called [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") object, which is an object that generates a
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in conjunction with a cache key representing the structure of the query;
    this cache key is then linked to the resulting string SQL statement so that subsequent
    use of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") with the same structure will bypass all the
    overhead of building the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, building the core [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object within, as well as the compilation
    of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    into a string, cutting out well the majority of function call overhead normally
    associated with constructing and emitting an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object.
  prefs: []
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") is now used by default by the ORM when it generates
    a “lazy” query for the lazy load of a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, e.g. that of the default `lazy="select"`
    relationship loader strategy. This will allow for a significant reduction in function
    calls within the scope of an application’s use of lazy load queries to load collections
    and related objects. Previously, this feature was available in 1.0 and 1.1 through
    the use of a global API method or by using the `baked_select` strategy, it’s now
    the only implementation for this behavior. The feature has also been improved
    such that the caching can still take place for objects that have additional loader
    options in effect subsequent to the lazy load.
  prefs: []
  type: TYPE_NORMAL
- en: The caching behavior can be disabled on a per-relationship basis using the [`relationship.bake_queries`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries
    "sqlalchemy.orm.relationship") flag, which is available for very unusual cases,
    such as a relationship that uses a custom [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") implementation that’s not compatible with caching.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3954](https://www.sqlalchemy.org/trac/ticket/3954)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “selectin” eager loading, loads all collections at once using IN'
  prefs: []
  type: TYPE_NORMAL
- en: A new eager loader called “selectin” loading is added, which in many ways is
    similar to “subquery” loading, however produces a simpler SQL statement that is
    cacheable as well as more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL produced would be the query against `User` followed by the subqueryload
    for `User.addresses` (note the parameters are also listed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'With “selectin” loading, we instead get a SELECT that refers to the actual
    primary key values loaded in the parent query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SELECT statement includes these advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t use a subquery, just an INNER JOIN, meaning it will perform much
    better on a database like MySQL that doesn’t like subqueries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its structure is independent of the original query; in conjunction with the
    new [expanding IN parameter system](#change-3953) we can in most cases use the
    “baked” query to cache the string SQL, reducing per-query overhead significantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the query only fetches for a given list of primary key identifiers,
    “selectin” loading is potentially compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") to operate on chunks of a SELECT result at a
    time, provided that the database driver allows for multiple, simultaneous cursors
    (SQLite, PostgreSQL; **not** MySQL drivers or SQL Server ODBC drivers). Neither
    joined eager loading nor subquery eager loading are compatible with [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of selectin eager loading are potentially large SQL queries,
    with large lists of IN parameters. The list of IN parameters themselves are chunked
    in groups of 500, so a result set of more than 500 lead objects will have more
    additional “SELECT IN” queries following. Also, support for composite primary
    keys depends on the database’s ability to use tuples with IN, e.g. `(table.column_one,
    table_column_two) IN ((?, ?), (?, ?) (?, ?))`. Currently, PostgreSQL and MySQL
    are known to be compatible with this syntax, SQLite is not.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3944](https://www.sqlalchemy.org/trac/ticket/3944)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “selectin” polymorphic loading, loads subclasses using separate IN queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along similar lines as the “selectin” relationship loading feature just described
    at [New “selectin” eager loading, loads all collections at once using IN](#change-3944)
    is “selectin” polymorphic loading. This is a polymorphic loading feature tailored
    primarily towards joined eager loading that allows the loading of the base entity
    to proceed with a simple SELECT statement, but then the attributes of the additional
    subclasses are loaded with additional SELECT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using selectin_polymorphic()](../orm/queryguide/inheritance.html#polymorphic-selectin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3948](https://www.sqlalchemy.org/trac/ticket/3948)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM attributes that can receive ad-hoc SQL expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new ORM attribute type [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") is added which is similar to [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred"), except its SQL expression is determined at query time
    using a new option [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression"); if not specified, the attribute defaults to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Query-time SQL expressions as mapped attributes](../orm/mapped_sql_expr.html#mapper-querytime-expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3058](https://www.sqlalchemy.org/trac/ticket/3058)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Support of multiple-table deletes'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") method supports multiple-table criteria for DELETE,
    as introduced in [Multiple-table criteria support for DELETE](#change-959). The
    feature works in the same manner as multiple-table criteria for UPDATE, first
    introduced in 0.8 and described at [Query.update() supports UPDATE..FROM](migration_08.html#change-orm-2365).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below, we emit a DELETE against `SomeEntity`, adding a FROM clause (or equivalent,
    depending on backend) against `SomeOtherEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple-table criteria support for DELETE](#change-959)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for bulk updates of hybrids, composites'
  prefs: []
  type: TYPE_NORMAL
- en: Both hybrid attributes (e.g. [`sqlalchemy.ext.hybrid`](../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid
    "sqlalchemy.ext.hybrid")) as well as composite attributes ([Composite Column Types](../orm/composites.html#mapper-composite))
    now support being used in the SET clause of an UPDATE statement when using [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update").
  prefs: []
  type: TYPE_NORMAL
- en: 'For hybrids, simple expressions can be used directly, or the new decorator
    [`hybrid_property.update_expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.update_expression
    "sqlalchemy.ext.hybrid.hybrid_property.update_expression") can be used to break
    a value into multiple columns/expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, an UPDATE can be rendered using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar functionality is available for composites, where composite values will
    be broken out into their individual columns for bulk UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Allowing Bulk ORM Update](../orm/extensions/hybrid.html#hybrid-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Hybrid attributes support reuse among subclasses, redefinition of @getter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`sqlalchemy.ext.hybrid.hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") class now supports calling mutators like
    `@setter`, `@expression` etc. multiple times across subclasses, and now provides
    a `@getter` mutator, so that a particular hybrid can be repurposed across subclasses
    or other classes. This now is similar to the behavior of `@property` in standard
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `FirstNameOnly.name` hybrid is referenced by the `FirstNameLastName`
    subclass in order to repurpose it specifically to the new subclass. This is achieved
    by copying the hybrid object to a new one within each call to `@getter`, `@setter`,
    as well as in all other mutator methods like `@expression`, leaving the previous
    hybrid’s definition intact. Previously, methods like `@setter` would modify the
    existing hybrid in-place, interfering with the definition on the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to read the documentation at [Reusing Hybrid Properties across Subclasses](../orm/extensions/hybrid.html#hybrid-reuse-subclass)
    for important notes regarding how to override [`hybrid_property.expression()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression
    "sqlalchemy.ext.hybrid.hybrid_property.expression") and [`hybrid_property.comparator()`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator
    "sqlalchemy.ext.hybrid.hybrid_property.comparator"), as a special qualifier [`hybrid_property.overrides`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.overrides
    "sqlalchemy.ext.hybrid.hybrid_property.overrides") may be necessary to avoid name
    conflicts with [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute") in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This change in `@hybrid_property` implies that when adding setters and other
    state to a `@hybrid_property`, the **methods must retain the name of the original
    hybrid**, else the new hybrid with the additional state will be present on the
    class as the non-matching name. This is the same behavior as that of the `@property`
    construct that is part of standard Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[#3911](https://www.sqlalchemy.org/trac/ticket/3911)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3912](https://www.sqlalchemy.org/trac/ticket/3912)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New bulk_replace event'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the validation use case described in [A @validates method receives
    all values on bulk-collection set before comparison](#change-3896-validates),
    a new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") method is added, which is called
    in conjunction with the [`AttributeEvents.append()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.append
    "sqlalchemy.orm.AttributeEvents.append") and [`AttributeEvents.remove()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.remove
    "sqlalchemy.orm.AttributeEvents.remove") events. “bulk_replace” is called before
    “append” and “remove” so that the collection can be modified ahead of comparison
    to the existing collection. After that, individual items are appended to a new
    target collection, firing off the “append” event for items new to the collection,
    as was the previous behavior. Below illustrates both “bulk_replace” and “append”
    at the same time, including that “append” will receive an object already handled
    by “bulk_replace” if collection assignment is used. A new symbol `attributes.OP_BULK_REPLACE`
    may be used to determine if this “append” event is the second part of a bulk replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “modified” event handler for sqlalchemy.ext.mutable'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new event handler [`AttributeEvents.modified()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.modified
    "sqlalchemy.orm.AttributeEvents.modified") is added, which is triggered corresponding
    to calls to the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") method, which is normally called from
    the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Above, the event handler will be triggered when an in-place change to the `.data`
    dictionary occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3303](https://www.sqlalchemy.org/trac/ticket/3303)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Added “for update” arguments to Session.refresh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added new argument [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") to the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method. When the `Query.with_lockmode()` method
    were deprecated in favor of [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"), the [`Session.refresh()`](../orm/session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method was never updated to reflect the new
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Session.refresh.with_for_update`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.with_for_update
    "sqlalchemy.orm.Session.refresh") argument accepts a dictionary of options that
    will be passed as the same arguments which are sent to [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The new parameter supersedes the [`Session.refresh.lockmode`](../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.lockmode
    "sqlalchemy.orm.Session.refresh") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3991](https://www.sqlalchemy.org/trac/ticket/3991)'
  prefs: []
  type: TYPE_NORMAL
- en: '### In-place mutation operators work for MutableSet, MutableList'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implemented the in-place mutation operators `__ior__`, `__iand__`, `__ixor__`
    and `__isub__` for [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") and `__iadd__` for [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). While these methods would successfully
    update the collection previously, they would not correctly fire off change events.
    The operators mutate the collection as before but additionally emit the correct
    change event so that the change becomes part of the next flush process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[#3853](https://www.sqlalchemy.org/trac/ticket/3853)'
  prefs: []
  type: TYPE_NORMAL
- en: '### AssociationProxy any(), has(), contains() work with chained association
    proxies'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AssociationProxy.any()`, `AssociationProxy.has()` and `AssociationProxy.contains()`
    comparison methods now support linkage to an attribute that is itself also an
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy"), recursively. Below, `A.b_values`
    is an association proxy that links to `AtoB.bvalue`, which is itself an association
    proxy onto `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query on `A.b_values` using `AssociationProxy.contains()` to query across
    the two proxies `A.b_values`, `AtoB.b_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can query on `A.c_values` using `AssociationProxy.any()` to query
    across the two proxies `A.c_values`, `AtoB.c_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[#3769](https://www.sqlalchemy.org/trac/ticket/3769)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Identity key enhancements to support sharding'
  prefs: []
  type: TYPE_NORMAL
- en: The identity key structure used by the ORM now contains an additional member,
    so that two identical primary keys that originate from different contexts can
    co-exist within the same identity map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example at [Horizontal Sharding](../orm/examples.html#examples-sharding)
    has been updated to illustrate this behavior. The example shows a sharded class
    `WeatherLocation` that refers to a dependent `WeatherReport` object, where the
    `WeatherReport` class is mapped to a table that stores a simple integer primary
    key. Two `WeatherReport` objects from different databases may have the same primary
    key value. The example now illustrates that a new `identity_token` field tracks
    this difference so that the two objects can co-exist in the same identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[#4137](https://www.sqlalchemy.org/trac/ticket/4137)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Boolean datatype now enforces strict True/False/None values'
  prefs: []
  type: TYPE_NORMAL
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)  ### Pessimistic disconnection
    detection added to the connection pool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)  ### The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified'
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)  ### Late-expanded IN
    parameter sets allow IN expressions with cached statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The feature should be regarded as **experimental** within the 1.2 series.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)  ### Flattened operator
    precedence for comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)  ### Support for SQL Comments
    on Table, Column, includes DDL, reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  prefs: []
  type: TYPE_NORMAL
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)  ### Multiple-table criteria
    support for DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)  ### New “autoescape” option
    for startswith(), endswith()'
  prefs: []
  type: TYPE_NORMAL
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  prefs: []
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an expression that has backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)  ### Stronger typing added
    to “float” datatypes'
  prefs: []
  type: TYPE_NORMAL
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for GROUPING SETS, CUBE, ROLLUP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  prefs: []
  type: TYPE_NORMAL
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)  ### Boolean datatype
    now enforces strict True/False/None values'
  prefs: []
  type: TYPE_NORMAL
- en: In version 1.1, the change described in [Non-native boolean integer values coerced
    to zero/one/None in all cases](migration_11.html#change-3730) produced an unintended
    side effect of altering the way [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") behaves when presented with a non-integer value, such
    as a string. In particular, the string value `"0"`, which would previously result
    in the value `False` being generated, would now produce `True`. Making matters
    worse, the change in behavior was only for some backends and not others, meaning
    code that sends string `"0"` values to [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would break inconsistently across backends.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate solution to this problem is that **string values are not supported
    with Boolean**, so in 1.2 a hard `TypeError` is raised if a non-integer / True/False/None
    value is passed. Additionally, only the integer values 0 and 1 are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that wish to have more liberal interpretation
    of boolean values, the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should be used. Below illustrates a recipe that
    will allow for the “liberal” behavior of the pre-1.1 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[#4102](https://www.sqlalchemy.org/trac/ticket/4102)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Pessimistic disconnection detection added to the connection pool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection pool documentation has long featured a recipe for using the
    [`ConnectionEvents.engine_connect()`](../core/events.html#sqlalchemy.events.ConnectionEvents.engine_connect
    "sqlalchemy.events.ConnectionEvents.engine_connect") engine event to emit a simple
    statement on a checked-out connection to test it for liveness. The functionality
    of this recipe has now been added into the connection pool itself, when used in
    conjunction with an appropriate dialect. Using the new parameter [`create_engine.pool_pre_ping`](../core/engines.html#sqlalchemy.create_engine.params.pool_pre_ping
    "sqlalchemy.create_engine"), each connection checked out will be tested for freshness
    before being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: While the “pre-ping” approach adds a small amount of latency to the connection
    pool checkout, for a typical application that is transactionally-oriented (which
    includes most ORM applications), this overhead is minimal, and eliminates the
    problem of acquiring a stale connection that will raise an error, requiring that
    the application either abandon or retry the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The feature does **not** accommodate for connections dropped within an ongoing
    transaction or SQL operation. If an application must recover from these as well,
    it would need to employ its own operation retry logic to anticipate these errors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3919](https://www.sqlalchemy.org/trac/ticket/3919)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The IN / NOT IN operator’s empty collection behavior is now configurable;
    default expression simplified'
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `column.in_([])`, which is assumed to be false, now produces
    the expression `1 != 1` by default, instead of `column != column`. This will **change
    the result** of a query that is comparing a SQL expression or column that evaluates
    to NULL when compared to an empty set, producing a boolean value false or true
    (for NOT IN) rather than NULL. The warning that would emit under this condition
    is also removed. The old behavior is available using the [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, the IN and NOT IN operators do not support comparison to a collection
    of values that is explicitly empty; meaning, this syntax is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: To work around this, SQLAlchemy and other database libraries detect this condition
    and render an alternative expression that evaluates to false, or in the case of
    NOT IN, to true, based on the theory that “col IN ()” is always false since nothing
    is in “the empty set”. Typically, in order to produce a false/true constant that
    is portable across databases and works in the context of the WHERE clause, a simple
    tautology such as `1 != 1` is used to evaluate to false and `1 = 1` to evaluate
    to true (a simple constant “0” or “1” often does not work as the target of a WHERE
    clause).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy in its early days began with this approach as well, but soon it was
    theorized that the SQL expression `column IN ()` would not evaluate to false if
    the “column” were NULL; instead, the expression would produce NULL, since “NULL”
    means “unknown”, and comparisons to NULL in SQL usually produce NULL.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this result, SQLAlchemy changed from using `1 != 1` to instead use
    th expression `expr != expr` for empty “IN” and `expr = expr` for empty “NOT IN”;
    that is, instead of using a fixed value we use the actual left-hand side of the
    expression. If the left-hand side of the expression passed evaluates to NULL,
    then the comparison overall also gets the NULL result instead of false or true.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, users eventually complained that this expression had a very severe
    performance impact on some query planners. At that point, a warning was added
    when an empty IN expression was encountered, favoring that SQLAlchemy continues
    to be “correct” and urging users to avoid code that generates empty IN predicates
    in general, since typically they can be safely omitted. However, this is of course
    burdensome in the case of queries that are built up dynamically from input variables,
    where an incoming set of values might be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent months, the original assumptions of this decision have been questioned.
    The notion that the expression “NULL IN ()” should return NULL was only theoretical,
    and could not be tested since databases don’t support that syntax. However, as
    it turns out, you can in fact ask a relational database what value it would return
    for “NULL IN ()” by simulating the empty set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: With the above test, we see that the databases themselves can’t agree on the
    answer. PostgreSQL, considered by most to be the most “correct” database, returns
    False; because even though “NULL” represents “unknown”, the “empty set” means
    nothing is present, including all unknown values. On the other hand, MySQL and
    MariaDB return NULL for the above expression, defaulting to the more common behavior
    of “all comparisons to NULL return NULL”.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s SQL architecture is more sophisticated than it was when this design
    decision was first made, so we can now allow either behavior to be invoked at
    SQL string compilation time. Previously, the conversion to a comparison expression
    were done at construction time, that is, the moment the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") or [`ColumnOperators.notin_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notin_
    "sqlalchemy.sql.expression.ColumnOperators.notin_") operators were invoked. With
    the compilation-time behavior, the dialect itself can be instructed to invoke
    either approach, that is, the “static” `1 != 1` comparison or the “dynamic” `expr
    != expr` comparison. The default has been **changed** to be the “static” comparison,
    since this agrees with the behavior that PostgreSQL would have in any case and
    this is also what the vast majority of users prefer. This will **change the result**
    of a query that is comparing a null expression to the empty set, particularly
    one that is querying for the negation `where(~null_expr.in_([]))`, since this
    now evaluates to true and not NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior can now be controlled using the flag [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine"), which defaults to the `"static"` setting, but may
    also be set to `"dynamic"` or `"dynamic_warn"`, where the `"dynamic_warn"` setting
    is equivalent to the previous behavior of emitting `expr != expr` as well as a
    performance warning. However, it is anticipated that most users will appreciate
    the “static” default.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3907](https://www.sqlalchemy.org/trac/ticket/3907)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Late-expanded IN parameter sets allow IN expressions with cached statements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added a new kind of [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") called “expanding”. This is for use in
    `IN` expressions where the list of elements is rendered into individual bound
    parameters at statement execution time, rather than at statement compilation time.
    This allows both a single bound parameter name to be linked to an IN expression
    of multiple elements, as well as allows query caching to be used with IN expressions.
    The new feature allows the related features of “select in” loading and “polymorphic
    in” loading to make use of the baked query extension to reduce call overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The feature should be regarded as **experimental** within the 1.2 series.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3953](https://www.sqlalchemy.org/trac/ticket/3953)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Flattened operator precedence for comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator precedence for operators like IN, LIKE, equals, IS, MATCH, and
    other comparison operators has been flattened into one level. This will have the
    effect of more parenthesization being generated when comparison operators are
    combined together, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Will now generate `(q IS NULL) != (y IS NULL)` rather than `q IS NULL != y IS
    NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3999](https://www.sqlalchemy.org/trac/ticket/3999)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for SQL Comments on Table, Column, includes DDL, reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Core receives support for string comments associated with tables and columns.
    These are specified via the [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column") arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Above, DDL will be rendered appropriately upon table create to associate the
    above comments with the table/ column within the schema. When the above table
    is autoloaded or inspected with [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"), the comments are included.
    The table comment is also available independently using the [`Inspector.get_table_comment()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_comment
    "sqlalchemy.engine.reflection.Inspector.get_table_comment") method.
  prefs: []
  type: TYPE_NORMAL
- en: Current backend support includes MySQL, PostgreSQL, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1546](https://www.sqlalchemy.org/trac/ticket/1546)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Multiple-table criteria support for DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    construct now supports multiple-table criteria, implemented for those backends
    which support it, currently these are PostgreSQL, MySQL and Microsoft SQL Server
    (support is also added to the currently non-working Sybase dialect). The feature
    works in the same was as that of multiple-table criteria for UPDATE, first introduced
    in the 0.7 and 0.8 series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting SQL from the above statement on a PostgreSQL backend would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple Table Deletes](../tutorial/data_update.html#tutorial-multi-table-deletes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#959](https://www.sqlalchemy.org/trac/ticket/959)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “autoescape” option for startswith(), endswith()'
  prefs: []
  type: TYPE_NORMAL
- en: The “autoescape” parameter is added to [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"), [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"), [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"). This parameter when set
    to `True` will automatically escape all occurrences of `%`, `_` with an escape
    character, which defaults to a forwards slash `/`; occurrences of the escape character
    itself are also escaped. The forwards slash is used to avoid conflicts with settings
    like PostgreSQL’s `standard_confirming_strings`, whose default value changed as
    of PostgreSQL 9.1, and MySQL’s `NO_BACKSLASH_ESCAPES` settings. The existing “escape”
    parameter can now be used to change the autoescape character, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This feature has been changed as of 1.2.0 from its initial implementation in
    1.2.0b2 such that autoescape is now passed as a boolean value, rather than a specific
    character to use as the escape character.
  prefs: []
  type: TYPE_NORMAL
- en: 'An expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Where the value of the parameter “x_1” is `'total/%score'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an expression that has backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Will render the same way, with the value of the parameter “x_1” as `'total//score'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2694](https://www.sqlalchemy.org/trac/ticket/2694)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Stronger typing added to “float” datatypes'
  prefs: []
  type: TYPE_NORMAL
- en: A series of changes allow for use of the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype to more strongly link itself to Python floating
    point values, instead of the more generic [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"). The changes are mostly related to ensuring that Python
    floating point values are not erroneously coerced to `Decimal()`, and are coerced
    to `float` if needed, on the result side, if the application is working with plain
    floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'A plain Python “float” value passed to a SQL expression will now be pulled
    into a literal parameter with the type [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"); previously, the type was [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), with the default “asdecimal=True” flag, which meant
    the result type would coerce to `Decimal()`. In particular, this would emit a
    confusing warning on SQLite:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Math operations between [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"), and [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") will now preserve the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") or [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") type in the resulting expression’s type, including the
    `asdecimal` flag as well as if the type should be [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype will apply the `float()` processor to result values unconditionally if
    the DBAPI is known to support native `Decimal()` mode. Some backends do not always
    guarantee that a floating point number comes back as plain float and not precision
    numeric such as MySQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4017](https://www.sqlalchemy.org/trac/ticket/4017)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4018](https://www.sqlalchemy.org/trac/ticket/4018)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4020](https://www.sqlalchemy.org/trac/ticket/4020)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for GROUPING SETS, CUBE, ROLLUP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All three of GROUPING SETS, CUBE, ROLLUP are available via the `func` namespace.
    In the case of CUBE and ROLLUP, these functions already work in previous versions,
    however for GROUPING SETS, a placeholder is added to the compiler to allow for
    the space. All three functions are named in the documentation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[#3429](https://www.sqlalchemy.org/trac/ticket/3429)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Parameter helper for multi-valued INSERT with contextual default generator'
  prefs: []
  type: TYPE_NORMAL
- en: 'A default generation function, e.g. that described at [Context-Sensitive Default
    Functions](../core/defaults.html#context-default-functions), can look at the current
    parameters relevant to the statement via the [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") attribute.
    However, in the case of a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct that specifies multiple VALUES clauses
    via the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the user-defined function is
    called multiple times, once for each parameter set, however there was no way to
    know which subset of keys in [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") apply
    to that column. A new function [`DefaultExecutionContext.get_current_parameters()`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") is
    added, which includes a keyword argument [`DefaultExecutionContext.get_current_parameters.isolate_multiinsert_groups`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters.params.isolate_multiinsert_groups
    "sqlalchemy.engine.default.DefaultExecutionContext.get_current_parameters") defaulting
    to `True`, which performs the extra work of delivering a sub-dictionary of [`DefaultExecutionContext.current_parameters`](../core/internals.html#sqlalchemy.engine.default.DefaultExecutionContext.current_parameters
    "sqlalchemy.engine.default.DefaultExecutionContext.current_parameters") which
    has the names localized to the current VALUES clause being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[#4075](https://www.sqlalchemy.org/trac/ticket/4075)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### The after_rollback() Session event now emits before the expiration of objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)  ### Fixed issue involving
    single-table inheritance with `select_from()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Would generate SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)  ### Previous collection
    is no longer mutated upon replacement'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)  ### A @validates method
    receives all values on bulk-collection set before comparison'
  prefs: []
  type: TYPE_NORMAL
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, if we began with a collection as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, replaced the collection with one that overlaps the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New bulk_replace event](#change-3896-event)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)  ### Use flag_dirty()
    to mark an object as “dirty” without any attribute changing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)  ### “scope” keyword removed
    from scoped_session'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)  ### Refinements to post_update
    in conjunction with onupdate'
  prefs: []
  type: TYPE_NORMAL
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)  ### post_update integrates
    with ORM versioning'
  prefs: []
  type: TYPE_NORMAL
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  prefs: []
  type: TYPE_NORMAL
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)  ### The after_rollback()
    Session event now emits before the expiration of objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SessionEvents.after_rollback()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_rollback
    "sqlalchemy.orm.SessionEvents.after_rollback") event now has access to the attribute
    state of objects before their state has been expired (e.g. the “snapshot removal”).
    This allows the event to be consistent with the behavior of the [`SessionEvents.after_commit()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_commit
    "sqlalchemy.orm.SessionEvents.after_commit") event which also emits before the
    “snapshot” has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Note that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will still disallow SQL from being emitted within this event; meaning that unloaded
    attributes will still not be able to load within the scope of the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3934](https://www.sqlalchemy.org/trac/ticket/3934)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Fixed issue involving single-table inheritance with `select_from()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method now honors the single-table inheritance
    column discriminator when generating SQL; previously, only the expressions in
    the query column list would be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing `Manager` is a subclass of `Employee`. A query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Would generate SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `Manager` were only specified by [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and not in the columns list, the discriminator
    would not be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'With the fix, [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") now works correctly and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Applications that may have been working around this by supplying the WHERE clause
    manually may need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3891](https://www.sqlalchemy.org/trac/ticket/3891)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Previous collection is no longer mutated upon replacement'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM emits events whenever the members of a mapped collection change. In
    the case of assigning a collection to an attribute that would replace the previous
    collection, a side effect of this was that the collection being replaced would
    also be mutated, which is misleading and unnecessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Above, prior to the change, the `previous_collection` would have had the “a1”
    member removed, corresponding to the member that’s no longer in the new collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3913](https://www.sqlalchemy.org/trac/ticket/3913)'
  prefs: []
  type: TYPE_NORMAL
- en: '### A @validates method receives all values on bulk-collection set before comparison'
  prefs: []
  type: TYPE_NORMAL
- en: A method that uses `@validates` will now receive all members of a collection
    during a “bulk set” operation, before comparison is applied against the existing
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we could use the validator as follows, to convert from an incoming dictionary
    to an instance of `B` upon collection append:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a collection assignment would fail, since the ORM would assume incoming
    objects are already instances of `B` as it attempts to compare them to the existing
    members of the collection, before doing collection appends which actually invoke
    the validator. This would make it impossible for bulk set operations to accommodate
    non-ORM objects like dictionaries that needed up-front modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The new logic uses the new [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event to ensure that all values
    are sent to the `@validates` function up front.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, this means that validators will now receive **all**
    members of a collection upon bulk set, not just the members that are new. Supposing
    a simple validator such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, if we began with a collection as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, replaced the collection with one that overlaps the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the second assignment would trigger the `A.validate_b` method only
    once, for the `b3` object. The `b2` object would be seen as being already present
    in the collection and not validated. With the new behavior, both `b2` and `b3`
    are passed to `A.validate_b` before passing onto the collection. It is thus important
    that validation methods employ idempotent behavior to suit such a case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New bulk_replace event](#change-3896-event)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3896](https://www.sqlalchemy.org/trac/ticket/3896)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Use flag_dirty() to mark an object as “dirty” without any attribute changing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception is now raised if the [`flag_modified()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_modified
    "sqlalchemy.orm.attributes.flag_modified") function is used to mark an attribute
    as modified that isn’t actually loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'This because the flush process will most likely fail in any case if the attribute
    remains un-present by the time flush occurs. To mark an object as “modified” without
    referring to any attribute specifically, so that it is considered within the flush
    process for the purpose of custom event handlers such as [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"), use the new [`flag_dirty()`](../orm/session_api.html#sqlalchemy.orm.attributes.flag_dirty
    "sqlalchemy.orm.attributes.flag_dirty") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[#3753](https://www.sqlalchemy.org/trac/ticket/3753)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “scope” keyword removed from scoped_session'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very old and undocumented keyword argument `scope` has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this keyword was an attempt to allow for variable “scopes”, where
    `None` indicated “no scope” and would therefore return a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The keyword has never been documented and will now
    raise `TypeError` if encountered. It is not anticipated that this keyword is in
    use, however if users report issues related to this during beta testing, it can
    be restored with a deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3796](https://www.sqlalchemy.org/trac/ticket/3796)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Refinements to post_update in conjunction with onupdate'
  prefs: []
  type: TYPE_NORMAL
- en: 'A relationship that uses the [`relationship.post_update`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.post_update
    "sqlalchemy.orm.relationship") feature will now interact better with a column
    that has an [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") value set. If an object is inserted with an explicit
    value for the column, it is re-stated during the UPDATE so that the “onupdate”
    rule does not overwrite it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the previous behavior would be that an UPDATE would emit after the INSERT,
    thus triggering the “onupdate” and overwriting the value “5”. The SQL now looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if the value of “updated” is *not* set, then we correctly get
    back the newly generated value on `a1.updated`; previously, the logic that refreshes
    or expires the attribute to allow the generated value to be present would not
    fire off for a post-update. The [`InstanceEvents.refresh_flush()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh_flush
    "sqlalchemy.orm.InstanceEvents.refresh_flush") event is also emitted when a refresh
    within flush occurs in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3471](https://www.sqlalchemy.org/trac/ticket/3471)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3472](https://www.sqlalchemy.org/trac/ticket/3472)'
  prefs: []
  type: TYPE_NORMAL
- en: '### post_update integrates with ORM versioning'
  prefs: []
  type: TYPE_NORMAL
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. This UPDATE statement now participates in the versioning feature,
    documented at [Configuring a Version Counter](../orm/versioning.html#mapper-version-counter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'An UPDATE of a node that associates another node as “favorite” will now increment
    the version counter as well as match the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Note that this means an object that receives an UPDATE in response to other
    attributes changing, and a second UPDATE due to a post_update relationship change,
    will now receive **two version counter updates for one flush**. However, if the
    object is subject to an INSERT within the current flush, the version counter **will
    not** be incremented an additional time, unless a server-side versioning scheme
    is in place.
  prefs: []
  type: TYPE_NORMAL
- en: The reason post_update emits an UPDATE even for an UPDATE is now discussed at
    [Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Rows that point to themselves / Mutually Dependent Rows](../orm/relationship_persistence.html#post-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](../faq/sessions.html#faq-post-update-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3496](https://www.sqlalchemy.org/trac/ticket/3496)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### The typing behavior of custom operators has been made consistent'
  prefs: []
  type: TYPE_NORMAL
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]  ### Percent signs in literal_column() now conditionally escaped'
  prefs: []
  type: TYPE_NORMAL
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)  ### The column-level
    COLLATE keyword now quotes the collation name'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)  ### The typing behavior
    of custom operators has been made consistent'
  prefs: []
  type: TYPE_NORMAL
- en: User defined operators can be made on the fly using the [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") function. Previously, the typing behavior
    of an expression against such an operator was inconsistent and also not controllable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas in 1.1, an expression such as the following would produce a result
    with no return type (assume `-%>` is some special operator supported by the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Other types would use the default behavior of using the left-hand type as the
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'These behaviors were mostly by accident, so the behavior has been made consistent
    with the second form, that is the default return type is the same as the left-hand
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'As most user-defined operators tend to be “comparison” operators, often one
    of the many special operators defined by PostgreSQL, the [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag has been repaired to follow its
    documented behavior of allowing the return type to be [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") in all cases, including for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") and [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'To assist with boolean comparison operators, a new shorthand method [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") has been added. This method should
    be preferred for on-the-fly boolean operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '### Percent signs in literal_column() now conditionally escaped'
  prefs: []
  type: TYPE_NORMAL
- en: The [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct now escapes percent sign
    characters conditionally, based on whether or not the DBAPI in use makes use of
    a percent-sign-sensitive paramstyle or not (e.g. ‘format’ or ‘pyformat’).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, it was not possible to produce a [`literal_column`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") construct that stated a single percent
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The percent sign is now unaffected for dialects that are not set to use the
    ‘format’ or ‘pyformat’ paramstyles; dialects such most MySQL dialects which do
    state one of these paramstyles will continue to escape as is appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: As part of this change, the doubling that has been present when using operators
    like [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"), [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") and [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") is also refined to only
    occur when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3740](https://www.sqlalchemy.org/trac/ticket/3740)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The column-level COLLATE keyword now quotes the collation name'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug in the [`collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.collate
    "sqlalchemy.sql.expression.collate") and [`ColumnOperators.collate()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate") functions, used to supply
    ad-hoc column collations at the statement level, is fixed, where a case sensitive
    name would not be quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the case sensitive name “fr_FR” would not be quoted. Currently,
    manual quoting of the “fr_FR” name is **not** detected, so applications that are
    manually quoting the identifier should be adjusted. Note that this change does
    not impact the use of collations at the type level (e.g. specified on the datatype
    like [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    at the table level), where quoting is already applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3785](https://www.sqlalchemy.org/trac/ticket/3785)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for Batch Mode / Fast Execution Helpers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)  ### Support for fields
    specification in INTERVAL, including full reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)  ### Support for Batch
    Mode / Fast Execution Helpers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 `cursor.executemany()` method has been identified as performing
    poorly, particularly with INSERT statements. To alleviate this, psycopg2 has added
    [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    which rework statements into fewer server round trips by sending multiple DML
    statements in batch. SQLAlchemy 1.2 now includes support for these helpers to
    be used transparently whenever the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") makes use of `cursor.executemany()` to invoke a statement
    against multiple parameter sets. The feature is off by default and can be enabled
    using the `use_batch_mode` argument on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The feature is considered to be experimental for the moment but may become on
    by default in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-batch-mode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4109](https://www.sqlalchemy.org/trac/ticket/4109)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for fields specification in INTERVAL, including full reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “fields” specifier in PostgreSQL’s INTERVAL datatype allows specification
    of which fields of the interval to store, including such values as “YEAR”, “MONTH”,
    “YEAR TO MONTH”, etc. The [`INTERVAL`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") datatype now allows these values to
    be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, all INTERVAL datatypes can now be reflected independently of
    the “fields” specifier present; the “fields” parameter in the datatype itself
    will also be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[#3959](https://www.sqlalchemy.org/trac/ticket/3959)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for INSERT..ON DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)  ### Support for INSERT..ON
    DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON DUPLICATE KEY UPDATE` clause of `INSERT` supported by MySQL is now
    supported using a MySQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.mysql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds a new method `Insert.on_duplicate_key_update()` that implements
    MySQL’s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4009](https://www.sqlalchemy.org/trac/ticket/4009)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Major Refactor to cx_Oracle Dialect, Typing System'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.  ### Oracle Unique, Check constraints now reflected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)  ### Oracle foreign key
    constraint names are now “name normalized”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the foreign keys result would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Where the above could create problems particularly with Alembic autogenerate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)  ### Major Refactor to
    cx_Oracle Dialect, Typing System'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the 6.x series of the cx_Oracle DBAPI, SQLAlchemy’s
    cx_Oracle dialect has been reworked and simplified to take advantage of recent
    improvements in cx_Oracle as well as dropping support for patterns that were more
    relevant before the 5.x series of cx_Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum cx_Oracle version supported is now 5.1.3; 5.3 or the most recent
    6.x series are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handling of datatypes has been refactored. The `cursor.setinputsizes()`
    method is no longer used for any datatype except LOB types, per advice from cx_Oracle’s
    developers. As a result, the parameters `auto_setinputsizes` and `exclude_setinputsizes`
    are deprecated and no longer have any effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `coerce_to_decimal` flag, when set to False to indicate that coercion of
    numeric types with precision and scale to `Decimal` should not occur, only impacts
    untyped (e.g. plain string with no [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") objects) statements. A Core expression that includes
    a [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    type or subtype will now follow the decimal coercion rules of that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “two phase” transaction support in the dialect, already dropped for the
    6.x series of cx_Oracle, has now been removed entirely as this feature has never
    worked correctly and is unlikely to have been in production use. As a result,
    the `allow_twophase` dialect flag is deprecated and also has no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed a bug involving the column keys present with RETURNING. Given a statement
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the keys in each row of the result would be `ret_0` and `ret_1`,
    which are identifiers internal to the cx_Oracle RETURNING implementation. The
    keys will now be `a` and `b` as is expected for other dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cx_Oracle’s LOB datatype represents return values as a `cx_Oracle.LOB` object,
    which is a cursor-associated proxy that returns the ultimate data value via a
    `.read()` method. Historically, if more rows were read before these LOB objects
    were consumed (specifically, more rows than the value of cursor.arraysize which
    causes a new batch of rows to be read), these LOB objects would raise the error
    “LOB variable no longer valid after subsequent fetch”. SQLAlchemy worked around
    this by both automatically calling `.read()` upon these LOBs within its typing
    system, as well as using a special `BufferedColumnResultSet` which would ensure
    this data was buffered in case a call like `cursor.fetchmany()` or `cursor.fetchall()`
    were used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialect now makes use of a cx_Oracle outputtypehandler to handle these `.read()`
    calls, so that they are always called up front regardless of how many rows are
    being fetched, so that this error can no longer occur. As a result, the use of
    the `BufferedColumnResultSet`, as well as some other internals to the Core `ResultSet`
    that were specific to this use case, have been removed. The type objects are also
    simplified as they no longer need to process a binary column result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, cx_Oracle 6.x has removed the conditions under which this error
    occurs in any case, so the error is no longer possible. The error can occur on
    SQLAlchemy in the case that the seldom (if ever) used `auto_convert_lobs=False`
    option is in use, in conjunction with the previous 5.x series of cx_Oracle, and
    more rows are read before the LOB objects can be consumed. Upgrading to cx_Oracle
    6.x will resolve that issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### Oracle Unique, Check constraints now reflected'
  prefs: []
  type: TYPE_NORMAL
- en: UNIQUE and CHECK constraints now reflect via [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") and [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints"). A [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object that’s reflected will now include [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects as well. See the notes at [Constraint
    Reflection](../dialects/oracle.html#oracle-constraint-reflection) for information
    on behavioral quirks here, including that most [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will still not include any [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") objects as these usually represent via [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Constraint Reflection](../dialects/oracle.html#oracle-constraint-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4003](https://www.sqlalchemy.org/trac/ticket/4003)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Oracle foreign key constraint names are now “name normalized”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of foreign key constraints as delivered to a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object during table reflection as well
    as within the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now be
    “name normalized”, that is, expressed as lower case for a case insensitive name,
    rather than the raw UPPERCASE format that Oracle uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the foreign keys result would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Where the above could create problems particularly with Alembic autogenerate.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3276](https://www.sqlalchemy.org/trac/ticket/3276)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### SQL Server schema names with embedded dots supported'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  prefs: []
  type: TYPE_NORMAL
- en: AUTOCOMMIT isolation level support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  prefs: []
  type: TYPE_NORMAL
- en: '### SQL Server schema names with embedded dots supported'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL Server dialect has a behavior such that a schema name with a dot inside
    of it is assumed to be a “database”.”owner” identifier pair, which is necessarily
    split up into these separate components during table and component reflection
    operations, as well as when rendering quoting for the schema name so that the
    two symbols are quoted separately. The schema argument can now be passed using
    brackets to manually specify where this split occurs, allowing database and/or
    owner names that themselves contain one or more dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table will consider the “owner” to be `MyDataBase.dbo`, which will
    also be quoted upon render, and the “database” as None. To individually refer
    to database name and owner, use two pairs of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct is now honored when passed
    to “schema” by the SQL Server dialect; the given symbol will not be split on the
    dot if the quote flag is True and will be interpreted as the “owner”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Multipart Schema Names](../dialects/mssql.html#multipart-schema-names)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2626](https://www.sqlalchemy.org/trac/ticket/2626)'
  prefs: []
  type: TYPE_NORMAL
- en: AUTOCOMMIT isolation level support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the PyODBC and pymssql dialects now support the “AUTOCOMMIT” isolation
    level as set by [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options") which will establish the correct
    flags on the DBAPI connection object.
  prefs: []
  type: TYPE_NORMAL
